

<!DOCTYPE html>
<html lang="zh-Hans" color-mode=light>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>gunicorn源码分析 - So1n blog</title>
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="google" content="notranslate" />
  
  <meta name="description" content="前记Gunicorn是一个基于Python实现的动态W...">
  <meta name="author" content="So1n">
  <link rel="icon" href="/images/icons/favicon.ico" type="image/png" sizes="16x16">
  <link rel="icon" href="/images/icons/favicon.ico" type="image/png" sizes="32x32">
  <link rel="apple-touch-icon" href="/images/icons/favicon.ico" sizes="180x180">
  <meta rel="mask-icon" href="/images/icons/stun-logo.svg" color="#333333">
  
    <meta rel="msapplication-TileImage" content="/images/icons/favicon.ico">
    <meta rel="msapplication-TileColor" content="#000000">
  

  
<link rel="stylesheet" href="/css/style.css">


  
    
<link rel="stylesheet" href="//at.alicdn.com/t/font_1445822_s6x2xcokxrl.css">

  

  
    
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css">

  

  
    
      
        
        
<link rel="stylesheet" href="https://cdn.bootcss.com/highlight.js/9.18.1/styles/atom-one-dark-reasonable.min.css" name="highlight-style" mode="light">

      
        
        
<link rel="stylesheet" href="https://cdn.bootcss.com/highlight.js/9.18.1/styles/atom-one-dark-reasonable.min.css" name="highlight-style" mode="dark">

      
  

  <script>
    var CONFIG = window.CONFIG || {};
    var ZHAOO = window.ZHAOO || {};
    CONFIG = {
      isHome: false,
      fancybox: true,
      pjax: false,
      lazyload: {
        enable: true,
        only_post: 'true',
        loading: '/images/theme/puff.svg'
      },
      donate: {
        enable: true,
        alipay: 'https://github.com/so1n/so1n_blog_photo/blob/master/blog_photo/4d2ebf32586d8799ee2e75333d6f5d2.jpg?raw=true',
        wechat: ''
      },
      galleries: {
        enable: true
      },
      fab: {
        enable: true,
        always_show: true
      },
      carrier: {
        enable: false
      },
      daovoice: {
        enable: false
      },
      preview: {
        background: {
          default: '',
          api: ''
        },
        motto: {
          default: 'I`m   So1n',
          typing: true,
          api: '',
          data_contents: '["data","content"]'
        },
      },
      qrcode: {
        enable: true,
        type: 'url',
        image: 'https://pic.izhaoo.com/weapp-code.jpg',
      },
      toc: {
        enable: true
      },
      scrollbar: {
        type: 'simple'
      },
      notification: {
        enable: false,
        delay: 4500,
        list: '',
        page_white_list: '',
        page_black_list: ''
      },
      search: {
        enable: true,
        path: 'search.xml'
      }
    }
  </script>

  

  

<meta name="generator" content="Hexo 5.4.0"></head>

<body class="lock-screen">
  <div class="loading"></div>
  
    


  <nav class="navbar">
    <div class="left">
      
        <i class="iconfont iconhome j-navbar-back-home"></i>
      
      
        <i class="iconfont iconqrcode j-navbar-qrcode"></i>
      
      
        <i class="iconfont iconmoono" id="color-toggle" color-toggle="light"></i>
      
      
        <i class="iconfont iconsearch j-navbar-search"></i>
      
    </div>
    <div class="center">gunicorn源码分析</div>
    <div class="right">
      <i class="iconfont iconmenu j-navbar-menu"></i>
    </div>
    
      <div id="qrcode-navbar"></div>
    
  </nav>

  
  

<nav class="menu">
  <div class="menu-container">
    <div class="menu-close">
      <i class="iconfont iconbaseline-close-px"></i>
    </div>
    <ul class="menu-content"><li class="menu-item">
        <a href="/ " class="underline "> 首页</a>
      </li><li class="menu-item">
        <a target="_blank" rel="noopener" href="http://so1nz.lofter.com/ " class="underline "> 时光</a>
      </li><li class="menu-item">
        <a href="/archives/ " class="underline "> 归档</a>
      </li><li class="menu-item">
        <a href="/tags/ " class="underline "> 标签</a>
      </li><li class="menu-item">
        <a href="/categories/ " class="underline "> 分类</a>
      </li><li class="menu-item">
        <a href="/project/ " class="underline "> 项目</a>
      </li><li class="menu-item">
        <a href="/about/ " class="underline "> 关于</a>
      </li></ul>
    
      <div class="menu-copyright"><p>Powered by <a target="_blank" href="https://hexo.io">Hexo</a>  |  Theme - <a target="_blank" href="https://github.com/izhaoo/hexo-theme-zhaoo">zhaoo</a></p></div>
    
  </div>
</nav>
  <main id="main">
  <div class="article-wrap">
    <div class="row container">
      <div class="col-xl-3"></div>
      <div class="col-xl-6"><article class="article">
  <div class="wrap">
    <section class="head">
  <img src="https://cdn.jsdelivr.net/gh/so1n/so1n_blog_photo@master/1646123474839enabling-the-flask-interactive-debugger-in-development-with-gunicorn-f6927cf4d1c653c36832549bafbfd1227ab2bd879c6e17c6082fec284651f7e4.jpg" draggable="false">
  <div class="head-mask">
    <h1 class="head-title">gunicorn源码分析</h1>
    <div class="head-info">
      <span class="post-info-item"><i class="iconfont iconcalendar"></i>February 22, 2022</span>
      
      本文总阅读量<span id="busuanzi_value_page_pv"></span>次
      <span class="post-info-item"><i class="iconfont iconfont-size"></i>26203</span>
    </div>
  </div>
</section>

    <section class="main">
      <section class="content">
        <!-- 展示文章摘录 -->
        
        <h2 id="前记"><a href="#前记" class="headerlink" title="前记"></a>前记</h2><p><code>Gunicorn</code>是一个基于<code>Python</code>实现的动态Web服务器，它通过Pre-Worker模型来实现并发，本身带有多种工作模式，基本上可以与所有<code>Python</code>Web框架集成，为他们带来一个多功能又稳定的服务器托管核心。</p>
<p>从学习<code>Python</code> Web的第一天就开始接触了<code>Gunicorn</code>,那时候还不知道他具体的作用是什么， 只知道在项目中使用他运行之后可以变得十分的稳定，高性能，从未研究它是如何实现的。随着使用时间的增长，越来越想知道它的运行原理是什么，特别是它性能为何会高，跟类Unix有什么特殊结合，<code>Pre-Worker</code>模型是如何通信的，如何设计一个比较好的<code>Pre-Worker</code>模型服务器？<br>于是，本文就是阅读源码之后的产物。</p>
<h2 id="1-简单了解"><a href="#1-简单了解" class="headerlink" title="1.简单了解"></a>1.简单了解</h2><p>通过<a target="_blank" rel="noopener" href="https://github.com/benoitc/gunicorn/tree/20.x">Gunicorn代码仓库</a>把代码拉到本地，使用<code>Tree</code>命令可以简单的看到<code>Gunicorn</code>的代码结构，可以看出文件数量并不是很多，以下是<code>Gunicorn</code>的代码结构以及他们每个文件夹或者每个文件的说明:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs bash">├── app             <span class="hljs-comment"># Gunicorn的运行实例,由该示例来运行arbiter，但在重启或者重新加载配置时，会由arbiter重新运行一个新的app实例</span><br>├── http            <span class="hljs-comment"># 用于Worker中处理客户端发送的HTTP请求</span><br>├── instrument      <span class="hljs-comment"># 使用statsd协议把自身信息发送到Statsd服务</span><br>├── workers         <span class="hljs-comment"># Pre-Worker模型中的Worker， 负责运行Web应用， 这些worker大部分都是基于WSGI协议封装的，但可以通过自定义协议封装来支持TCP传输</span><br>├── __init__.py<br>├── __main__.py<br>├── arbiter.py      <span class="hljs-comment"># Pre-Worker模型中的Master， 负责管理Worker, 配置重载，重新启动新的进程等。 </span><br>├── config.py       <span class="hljs-comment"># 加载配置相关</span><br>├── debug.py        <span class="hljs-comment"># 基于sys.settrace钩子实现的debug信息输出 </span><br>├── errors.py       <span class="hljs-comment"># Master错误的封装</span><br>├── glogging.py     <span class="hljs-comment"># 日志输出</span><br>├── pidfile.py      <span class="hljs-comment"># 进程PID文件管理 </span><br>├── reloader.py     <span class="hljs-comment"># 文件自动重载功能</span><br>├── sock.py         <span class="hljs-comment"># 对不同类型的socket做统一的封装</span><br>├── systemd.py      <span class="hljs-comment"># 激活systemd的socket，通过systemd文档即可知道如何交互，所以不做分析</span><br>└── util.py         <span class="hljs-comment"># 常用代码封装</span><br></code></pre></td></tr></table></figure>

<h2 id="2-开始入手"><a href="#2-开始入手" class="headerlink" title="2.开始入手"></a>2.开始入手</h2><p>了解完代码结构后接着从官方文档的示例开始入手：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ pip install gunicorn<br>$ cat myapp.py<br>  def app(environ, start_response):<br>      data = b<span class="hljs-string">&quot;Hello, World!\n&quot;</span><br>      start_response(<span class="hljs-string">&quot;200 OK&quot;</span>, [<br>          (<span class="hljs-string">&quot;Content-Type&quot;</span>, <span class="hljs-string">&quot;text/plain&quot;</span>),<br>          (<span class="hljs-string">&quot;Content-Length&quot;</span>, str(len(data)))<br>      ])<br>      <span class="hljs-built_in">return</span> iter([data])<br>$ gunicorn -w 4 myapp:app<br>[2014-09-10 10:22:28 +0000] [30869] [INFO] Listening at: http://127.0.0.1:8000 (30869)<br>[2014-09-10 10:22:28 +0000] [30869] [INFO] Using worker: sync<br>[2014-09-10 10:22:28 +0000] [30874] [INFO] Booting worker with pid: 30874<br>[2014-09-10 10:22:28 +0000] [30875] [INFO] Booting worker with pid: 30875<br>[2014-09-10 10:22:28 +0000] [30876] [INFO] Booting worker with pid: 30876<br>[2014-09-10 10:22:28 +0000] [30877] [INFO] Booting worker with pid: 30877<br></code></pre></td></tr></table></figure>
<p>这个示例演示了如何通过命令行来使<code>Gunicorn</code>来运行一个最小的<code>WSGI</code>Web应用，如果熟悉<code>Python</code>的打包规则的话，这个命令中的<code>gunicorn</code>实际上是在<code>setup.py</code>文件中定义好的， 重新打开仓库，找到<code>setup.py</code>:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">from</span> setuptools <span class="hljs-keyword">import</span> setup, find_packages<br><br><br>setup(<br>    entry_points=<span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    [console_scripts]</span><br><span class="hljs-string">    gunicorn=gunicorn.app.wsgiapp:run</span><br><span class="hljs-string">    &quot;&quot;&quot;</span>,<br>)<br></code></pre></td></tr></table></figure>
<p>这里移除了其它部分的代码，只保留了相关的代码，在这段代码中，指定了<code>gunicorn</code>的命令实际上是<code>gunicorn.app.wsgiapp:run</code>，所以这段代码实际上执行了<code>gunicorn.app.wsgiapp</code>文件中的<code>run</code>函数:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span>():</span><br>    <span class="hljs-keyword">from</span> gunicorn.app.wsgiapp <span class="hljs-keyword">import</span> WSGIApplication<br>    WSGIApplication(<span class="hljs-string">&quot;%(prog)s [OPTIONS] [APP_MODULE]&quot;</span>).run()<br></code></pre></td></tr></table></figure>

<p>而<code>run</code>函数的运行逻辑也是很简单， 它是直接实例化一个承于<code>gunicorn.app.base</code>文件的<code>BaseApplication</code>的<code>WSGIApplication</code>类， 这个类在实例化时会执行它的<code>do_load_config</code>方法，也就是在这时候会初始化实例的<code>cfg</code>变量，并调用<code>cfg.parse</code>，其中这个实例是<code>config.Config</code>的实例化，而<code>parse</code>方法是用来解析用户传入的参数并供后续的<code>Arbiter</code>以及<code>Worker</code>使用。</p>
<h2 id="3-加载配置"><a href="#3-加载配置" class="headerlink" title="3.加载配置"></a>3.加载配置</h2><p>一般项目中的加载配置是没有什么可以说的， 但是<code>Gunicorn</code>比较特殊， 在<code>config</code>文件中除了<code>Config</code>这个类和一些校验方法外，还存在大量类似于：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WorkerConnections</span>(<span class="hljs-params">Setting</span>):</span><br>    name = <span class="hljs-string">&quot;worker_connections&quot;</span><br>    section = <span class="hljs-string">&quot;Worker Processes&quot;</span><br>    cli = [<span class="hljs-string">&quot;--worker-connections&quot;</span>]<br>    meta = <span class="hljs-string">&quot;INT&quot;</span><br>    validator = validate_pos_int<br>    <span class="hljs-built_in">type</span> = <span class="hljs-built_in">int</span><br>    default = <span class="hljs-number">1000</span><br>    desc = <span class="hljs-string">&quot;&quot;&quot;\</span><br><span class="hljs-string">        The maximum number of simultaneous clients.</span><br><span class="hljs-string"></span><br><span class="hljs-string">        This setting only affects the Eventlet and Gevent worker types.</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br></code></pre></td></tr></table></figure>
<p>的类， 这些类就是<code>Gunicorn</code>支持的参数或配置值以及它对应的类型，校验规则，默认值和帮助文档等，这些类都按照一定的规范进行编写，同时又继承于<code>Setting</code>这个类，而<code>Setting</code>这个类又继承了<code>SettingMeta</code>,<code>SettingMeta</code>的作用就是在程序运行的时候，把所有继承于<code>Setting</code>的类加入到<code>config</code>文件的<code>local</code>变量中，供<code>gunicorn</code>来使用。</p>
<blockquote>
<p><code>Gunicorn</code>在启动时通过<code>config</code>模块把用户传入的命令进行初始化后, 再通过环境变量来初始化配置，此时的配置会覆盖掉用户传入命令初始化时的配置，接着在判断用户是否有指定配置文件，如果有就加载配置文件的配置，再覆盖已经存在的配置。<br>也就是说，配置的优先级是配置文件最高，然后环境变量次之，用户通过命令行传入的配置最后。<br>但是读取配置文件路径的优先级是命令行最高，然后才是环境变量。</p>
</blockquote>
<h2 id="4-Gunicorn的核心–Arbiter-run"><a href="#4-Gunicorn的核心–Arbiter-run" class="headerlink" title="4.Gunicorn的核心–Arbiter.run"></a>4.Gunicorn的核心–Arbiter.run</h2><p><code>Application</code>实例化完成后，会调用<code>BaseApplication.run</code>方法, 该方法如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span>(<span class="hljs-params">self</span>):</span><br>    <span class="hljs-keyword">try</span>:<br>        Arbiter(self).run()<br>    <span class="hljs-keyword">except</span> RuntimeError <span class="hljs-keyword">as</span> e:<br>        print(<span class="hljs-string">&quot;\nError: %s\n&quot;</span> % e, file=sys.stderr)<br>        sys.stderr.flush()<br>        sys.exit(<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure>
<p>该方法会执行<code>gunicorn.arbiter</code>文件的<code>Arbiter</code>类，这个类是<code>gunicorn</code>的核心类，负责启动和管理所有运行的worker，而运行的<code>run</code>方法则是核心中的核心，负责着整个服务的运行管理，同时又跟<code>Arbiter</code>的其它方法有交互，所以可以通过分析<code>run</code>方法进行分析，进而纵观整个<code>Arbiter</code>类, <code>run</code>的方法如下（具体说明见注释,其它具体分析见小章节）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span>(<span class="hljs-params">self</span>):</span><br>    <span class="hljs-string">&quot;Main master loop.&quot;</span><br>    <span class="hljs-comment"># 1.初始化实例，并信号监听以及sock</span><br>    self.start()<br>    util._setproctitle(<span class="hljs-string">&quot;master [%s]&quot;</span> % self.proc_name)<br><br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-comment"># 2.创建worker直到worker数量满足用户的指定条件，如果当前worker数量超过用户指定的条件，则会杀掉创建时间比较长的worker</span><br>        self.manage_workers()<br><br>        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>            <span class="hljs-comment"># 3.负责判断该进程是否是正真的master，如果是则提升为正真的master(这一块放在最后一部分进行分析)</span><br>            self.maybe_promote_master()<br><br>            <span class="hljs-comment"># 4.获取信号</span><br>            sig = self.SIG_QUEUE.pop(<span class="hljs-number">0</span>) <span class="hljs-keyword">if</span> self.SIG_QUEUE <span class="hljs-keyword">else</span> <span class="hljs-literal">None</span><br>            <span class="hljs-keyword">if</span> sig <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>                <span class="hljs-comment"># 5.利用select休眠1小时</span><br>                self.sleep()<br>                <span class="hljs-comment"># 6.判断worker是否超时，如果是则杀掉worker(将在Worker章节进行分析) </span><br>                self.murder_workers()<br>                self.manage_workers()<br>                <span class="hljs-keyword">continue</span><br><br>            <span class="hljs-keyword">if</span> sig <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> self.SIG_NAMES:<br>                self.log.info(<span class="hljs-string">&quot;Ignoring unknown signal: %s&quot;</span>, sig)<br>                <span class="hljs-keyword">continue</span><br><br>            signame = self.SIG_NAMES.get(sig)<br>            <span class="hljs-comment"># 调用对应的信号处理</span><br>            handler = <span class="hljs-built_in">getattr</span>(self, <span class="hljs-string">&quot;handle_%s&quot;</span> % signame, <span class="hljs-literal">None</span>)<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> handler:<br>                self.log.error(<span class="hljs-string">&quot;Unhandled signal: %s&quot;</span>, signame)<br>                <span class="hljs-keyword">continue</span><br>            self.log.info(<span class="hljs-string">&quot;Handling signal: %s&quot;</span>, signame)<br>            handler()<br>            <span class="hljs-comment"># 7.这样下次循环就不会等待一秒了</span><br>            self.wakeup()<br>    <span class="hljs-comment"># 8.服务异常，进行退出处理</span><br>    <span class="hljs-keyword">except</span> (StopIteration, KeyboardInterrupt):<br>        <span class="hljs-comment"># 收到用户的退出信号(按下CTRL+C) </span><br>        self.halt()<br>    <span class="hljs-keyword">except</span> HaltServer <span class="hljs-keyword">as</span> inst:<br>        <span class="hljs-comment"># Worker运行异常的时候</span><br>        self.halt(reason=inst.reason, exit_status=inst.exit_status)<br>    <span class="hljs-keyword">except</span> SystemExit:<br>        <span class="hljs-keyword">raise</span><br>    <span class="hljs-keyword">except</span> Exception:<br>        <span class="hljs-comment"># 其它的运行异常</span><br>        self.log.info(<span class="hljs-string">&quot;Unhandled exception in main loop&quot;</span>,<br>                      exc_info=<span class="hljs-literal">True</span>)<br>        self.stop(<span class="hljs-literal">False</span>)<br>        <span class="hljs-keyword">if</span> self.pidfile <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            self.pidfile.unlink()<br>        sys.exit(-<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure>

<h3 id="4-1初始化–Arbiter-start"><a href="#4-1初始化–Arbiter-start" class="headerlink" title="4.1初始化–Arbiter.start"></a>4.1初始化–Arbiter.start</h3><p><code>Arbiter.start</code>方法的第一步是进行初始化，首先是判断该进程是否是另一个进程启动的，这里是<code>Gunicorn</code>的<a target="_blank" rel="noopener" href="https://docs.gunicorn.org/en/stable/signals.html#upgrading-to-a-new-binary-on-the-fly">Upgrading to a new binary on the fly</a>功能，将在后面统一说明，然后他通过<code>init_signals</code>方法初始化信号的回调：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">init_signals</span>(<span class="hljs-params">self</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;\</span><br><span class="hljs-string">    Initialize master signal handling. Most of the signals</span><br><span class="hljs-string">    are queued. Child signals only wake up the master.</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-comment"># close old PIPE</span><br>    <span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> self.PIPE:<br>        os.close(p)<br><br>    <span class="hljs-comment"># initialize the pipe</span><br>    self.PIPE = pair = os.pipe()<br>    <span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> pair:<br>        util.set_non_blocking(p)<br>        util.close_on_exec(p)<br><br>    self.log.close_on_exec()<br><br>    <span class="hljs-comment"># initialize all signals</span><br>    <span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> self.SIGNALS:<br>        signal.signal(s, self.signal)<br>    <span class="hljs-comment"># 捕获子进程exit前发出的sigchld信号,然后函数里面通过waitpid来收拾，避免僵尸进程的存在</span><br>    signal.signal(signal.SIGCHLD, self.handle_chld)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">signal</span>(<span class="hljs-params">self, sig, frame</span>):</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(self.SIG_QUEUE) &lt; <span class="hljs-number">5</span>:<br>        self.SIG_QUEUE.append(sig)<br>        self.wakeup()<br><br></code></pre></td></tr></table></figure>
<p>这个方法做了两件事:</p>
<ul>
<li><p>1.首先是初始化<code>PIPE</code>, <code>Gunicorn</code>的<code>Master</code>是一个一直在循环的单进程，每次循环会<code>sleep</code>一秒防止空转，通过<code>PIPE</code>可以使<code>Master</code>进程从<code>sleep</code>阶段提前唤醒，<code>PIPE</code>在初始化时会先通过<code>util.set_non_blocking</code>方法来设置不阻塞来防止收到信号时，阻塞到<code>Master</code>进程的主流程。<br>然后通过<code>util.close_on_exec</code>来关闭子进程无用的描述符，之所以要这样处理是因为<code>Gunicorn</code>采用了<code>Pre-Worker</code>的模型，在运行的时候<code>Master</code>进程会通过<code>fork</code>的方法来创建<code>worker</code>进程，<code>fork</code>出来的子进程是通过写时复制来获得父进程的数据的，当子进程在<code>exec</code>阶段时就会创建一份新的资源引用，此时保存原来文件描述符的变量当然也不存在了，也就无法关闭无用的文件描述符了， 这意味着对于某个文件描述符有两个引用，而<code>Linux</code>的文件描述符是等到都没有引用的时候才会删掉， 所以我们在使用的时候都会期望在<code>fork</code>阶段后，<code>exec</code>阶段之前直接关掉无用的物件描述符，这时候就可以用到<code>Linux</code>的<code>close-on-exec</code>功能。<br>在初始化文件描述符后， 通过直接对文件描述符设置<code>FD_CLOEXEC</code>标记， 这样在<code>fork</code>阶段后<code>exec</code>阶段前，<code>Linux</code>会自动关掉无用的文件描述符， 在<code>Gunicorn</code>中，会对所有文件描述符都调用<code>util.close_on_exec</code>。 </p>
</li>
<li><p>2.初始化真正的信号监听， 注册了<code>Gunicortn</code>所有会用到的信号回调，该回调会把信息注册到一个名为<code>SIG_QUEUE</code>的队列中，同时会执行<code>wakeup</code>来唤醒<code>worker</code>的循环(将在run中的sleep介绍这个机制是怎么实现的)</p>
</li>
</ul>
<p>在完成了信号监听的注册后， 会开始创建<code>sock</code>,<code>Gunicorn</code>为各种类型的<code>sock</code>做了统一的封装， 它会判断用户配置要监听的<code>IP</code>端口来挑选一个合适的<code>sock</code>,然后进行初始化，其中最重要的初始化方法就是<code>BaseCocket</code>的<code>set_options</code>方法， 它的源码如下: </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseSocket</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, address, conf, log, fd=<span class="hljs-literal">None</span></span>):</span><br>        self.log = log<br>        self.conf = conf<br><br>        self.cfg_addr = address<br>        <span class="hljs-keyword">if</span> fd <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            sock = socket.socket(self.FAMILY, socket.SOCK_STREAM)<br>            bound = <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">else</span>:<br>            sock = socket.fromfd(fd, self.FAMILY, socket.SOCK_STREAM)<br>            os.close(fd)<br>            bound = <span class="hljs-literal">True</span><br><br>        self.sock = self.set_options(sock, bound=bound)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">set_options</span>(<span class="hljs-params">self, sock, bound=<span class="hljs-literal">False</span></span>):</span><br>        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">if</span> (self.conf.reuse_port<br>            <span class="hljs-keyword">and</span> <span class="hljs-built_in">hasattr</span>(socket, <span class="hljs-string">&#x27;SO_REUSEPORT&#x27;</span>)):  <span class="hljs-comment"># pragma: no cover</span><br>            <span class="hljs-keyword">try</span>:<br>                sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEPORT, <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">except</span> socket.error <span class="hljs-keyword">as</span> err:<br>                <span class="hljs-keyword">if</span> err.errno <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> (errno.ENOPROTOOPT, errno.EINVAL):<br>                    <span class="hljs-keyword">raise</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> bound:<br>            self.bind(sock)<br>        sock.setblocking(<span class="hljs-number">0</span>)<br><br>        <span class="hljs-comment"># make sure that the socket can be inherited</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">hasattr</span>(sock, <span class="hljs-string">&quot;set_inheritable&quot;</span>):<br>            sock.set_inheritable(<span class="hljs-literal">True</span>)<br><br>        sock.listen(self.conf.backlog)<br>        <span class="hljs-keyword">return</span> sock<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">bind</span>(<span class="hljs-params">self, sock</span>):</span><br>        sock.bind(self.cfg_addr)<br></code></pre></td></tr></table></figure>
<p>在<code>Gunicorn</code>中，它创建的所有<code>Scoket</code>都是继承于<code>BaseSocket</code>,所以<code>Gunicorn</code>在创建<code>scoket</code>后会调用<code>set_options</code>方法，这个方法默认会设置<code>SO_REUSEADDR</code>标记，然后再依赖配置设置<code>SO_REUSEPORT</code>标记， 设置<code>SO_REUSEPORT</code>标记可以解决部分惊群问题，同时也能解决不同进程收到请求的负载均衡问题，但是会带来响应请求的延迟，所以<code>Gunicorn</code>将这个配置设置为可选项（关于这几个参数以及惊群问题会另开文章说明）。 接着<code>Gunicorn</code>会调用<code>sock.bind</code>且设置<code>scoket</code>是不阻塞的，再进行监听，并返回给<code>Master</code>。 <code>Gunicorn</code>之所以这样做是因为<code>Gunicorn</code>是<code>Pre-Worker</code>模型的，在这个模型中， 所有的<code>scoket</code>都是由<code>Master</code>进程创建并监听，然后在通过<code>fork</code>子进程的时候把<code>scoket</code>传递给子进程，然后子进程可以通过该<code>scoket</code>可以进行<code>accept</code>获取到对应的请求。</p>
<h3 id="4-2-管理woeker数量–manage-workers"><a href="#4-2-管理woeker数量–manage-workers" class="headerlink" title="4.2.管理woeker数量–manage_workers"></a>4.2.管理woeker数量–manage_workers</h3><p>在<code>Gunicorn</code>的<code>Arbiter</code>中，通过<code>manage_workers</code>方法对<code>Worker</code>进行管理， 当前运行的<code>Worker</code>数量不满足与用户指定的数量时，会通过<code>spawn_workers</code>来调用<code>spawn_worker</code>创建<code>Worker</code>，前者是批量创建一批<code>Worker</code>，而后者是每次调用创建一个<code>Worker</code>,他们的代码十分简单, 具体说明见注释:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">spawn_worker</span>(<span class="hljs-params">self</span>):</span><br>    <span class="hljs-comment"># 每个新创建的Worker, age都加1, Worker越大，则代表越新</span><br>    self.worker_age += <span class="hljs-number">1</span><br>    <span class="hljs-comment"># 把一些参数传给worker</span><br>    worker = self.worker_class(self.worker_age, self.pid, self.LISTENERS,<br>                               self.app, self.timeout / <span class="hljs-number">2.0</span>,<br>                               self.cfg, self.log)<br>    self.cfg.pre_fork(self, worker)<br>    <span class="hljs-comment"># 开始Fork</span><br>    pid = os.fork()<br>    <span class="hljs-keyword">if</span> pid != <span class="hljs-number">0</span>:<br>        <span class="hljs-comment"># 对于主进程，记录创建的worker</span><br>        worker.pid = pid<br>        self.WORKERS[pid] = worker<br>        <span class="hljs-keyword">return</span> pid<br><br>    <span class="hljs-comment"># 对于创建的子进程</span><br>    <br>    <span class="hljs-comment"># 不继承其它worker的tmp文件</span><br>    <span class="hljs-keyword">for</span> sibling <span class="hljs-keyword">in</span> self.WORKERS.values():<br>        sibling.tmp.close()<br><br>    worker.pid = os.getpid()<br>    <span class="hljs-keyword">try</span>:<br>        util._setproctitle(<span class="hljs-string">&quot;worker [%s]&quot;</span> % self.proc_name)<br>        self.log.info(<span class="hljs-string">&quot;Booting worker with pid: %s&quot;</span>, worker.pid)<br>        self.cfg.post_fork(self, worker)<br>        <span class="hljs-comment"># 开始运行，在init_process方法编写worker的方法，因为__init__方法属于在主进程运行</span><br>        worker.init_process()<br>        <span class="hljs-comment"># exit 0 代表进程常退出</span><br>        sys.exit(<span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">except</span> SystemExit:<br>        <span class="hljs-keyword">raise</span><br>    <span class="hljs-keyword">except</span> AppImportError <span class="hljs-keyword">as</span> e:<br>        <span class="hljs-comment"># 初始化实例失败</span><br>        self.log.debug(<span class="hljs-string">&quot;Exception while loading the application&quot;</span>,<br>                       exc_info=<span class="hljs-literal">True</span>)<br>        print(<span class="hljs-string">&quot;%s&quot;</span> % e, file=sys.stderr)<br>        sys.stderr.flush()<br>        sys.exit(self.APP_LOAD_ERROR)<br>    <span class="hljs-keyword">except</span> Exception:<br>        <span class="hljs-comment"># 其它失败方法</span><br>        self.log.exception(<span class="hljs-string">&quot;Exception in worker process&quot;</span>)<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> worker.booted:<br>            sys.exit(self.WORKER_BOOT_ERROR)<br>        sys.exit(-<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">finally</span>:<br>        self.log.info(<span class="hljs-string">&quot;Worker exiting (pid: %s)&quot;</span>, worker.pid)<br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-comment"># 不管如何，都要关闭临时文件</span><br>            worker.tmp.close()<br>            self.cfg.worker_exit(self, worker)<br>        <span class="hljs-keyword">except</span> Exception:<br>            self.log.warning(<span class="hljs-string">&quot;Exception during worker exit:\n%s&quot;</span>,<br>                             traceback.format_exc())<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">spawn_workers</span>(<span class="hljs-params">self</span>):</span><br>    <span class="hljs-comment"># 判断现在还需要多少个worker, 并创建</span><br>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(self.num_workers - <span class="hljs-built_in">len</span>(self.WORKERS)):<br>        self.spawn_worker()<br>        <span class="hljs-comment"># 随机休息一段时间， 防止同时创建多个worker</span><br>        time.sleep(<span class="hljs-number">0.1</span> * random.random())<br></code></pre></td></tr></table></figure>
<p>在这里面中有两个注意点，第一个点是在<code>spawn_worker</code>中，会先初始化<code>worker</code>,接着在<code>fork</code>出子进程运行代码部分会先执行<code>worker.init_process</code>然后就调用<code>sys,exit(0)</code>退出，所以我们最好不要在<code>worker.__init__</code>里面初始化数据，因为这部分是在<code>Master</code>中执行的。我们应该在<code>worker.init_process</code>中执行初始化,并在初始化代码执行后调用<code>super().init_process()</code>,如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">init_process</span>(<span class="hljs-params">self</span>):</span><br>    <span class="hljs-comment"># 初始化代码</span><br>    <span class="hljs-built_in">super</span>().init_process()<br></code></pre></td></tr></table></figure>
<p>这样做是因为<code>BaseWorker</code>会在自己的<code>init_process</code>方法中执行一些通用的初始化功能，然后再调用<code>BaseWorker.run</code>来运行<code>Worker</code>。</p>
<h3 id="4-3-核心循环与信号处理"><a href="#4-3-核心循环与信号处理" class="headerlink" title="4.3.核心循环与信号处理"></a>4.3.核心循环与信号处理</h3><p>在经过<code>manage_workers</code>后，<code>Worker</code>都已经以子进程的形式在运行了，但是<code>Master</code>进程还需要处理一些家务事，比如管理<code>Worker</code>进程是否存活以及用户在运行时指派给<code>Master</code>的一些工作等，而这些将通过信号来进行交互。</p>
<p>这个阶段的<code>Master</code>以一个循环不断的跑着， 如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    <span class="hljs-comment"># 3.负责判断该进程是否是正真的master，如果是则提升为正真的master(这一块放在最后一部分进行分析)</span><br>    self.maybe_promote_master()<br><br>    <span class="hljs-comment"># 4.获取信号</span><br>    sig = self.SIG_QUEUE.pop(<span class="hljs-number">0</span>) <span class="hljs-keyword">if</span> self.SIG_QUEUE <span class="hljs-keyword">else</span> <span class="hljs-literal">None</span><br>    <span class="hljs-keyword">if</span> sig <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>        <span class="hljs-comment"># 5.利用select休眠1小时</span><br>        self.sleep()<br>        <span class="hljs-comment"># 6.判断worker是否超时，如果是则杀掉worker(将在Worker章节进行分析) </span><br>        self.murder_workers()<br>        self.manage_workers()<br>        <span class="hljs-keyword">continue</span><br><br>    <span class="hljs-keyword">if</span> sig <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> self.SIG_NAMES:<br>        self.log.info(<span class="hljs-string">&quot;Ignoring unknown signal: %s&quot;</span>, sig)<br>        <span class="hljs-keyword">continue</span><br><br>    signame = self.SIG_NAMES.get(sig)<br>    <span class="hljs-comment"># 调用对应的信号处理</span><br>    handler = <span class="hljs-built_in">getattr</span>(self, <span class="hljs-string">&quot;handle_%s&quot;</span> % signame, <span class="hljs-literal">None</span>)<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> handler:<br>        self.log.error(<span class="hljs-string">&quot;Unhandled signal: %s&quot;</span>, signame)<br>        <span class="hljs-keyword">continue</span><br>    self.log.info(<span class="hljs-string">&quot;Handling signal: %s&quot;</span>, signame)<br>    handler()<br>    <span class="hljs-comment"># 7.这样下次循环就不会等待一秒了</span><br>    self.wakeup()<br></code></pre></td></tr></table></figure>
<p>它的运行逻辑很简单，首先是判断当前进程是不是真的主进程，如果是将晋升为主进程，然后就是获取信号，如果当前信号队列有信号存在就取最前的一个并执行对应的信号对用以及调用<code>wakeup</code>方法，防止下次循环还在睡眠；如果获取不到信号，就先休眠1秒，然后清除超时的<code>Worker</code>最后执行<code>manage_worker</code>并进入下个循环。</p>
<p>在<code>Gunicorn</code>中，它确保每个循环只执行一次操作，确保该循环要不就执行信号回调，要不就执行<code>Worker</code>管理，同时它还确保执行信号回调的优先级是最高的，但是<code>Gunicorn</code>对传入的信号的数量也有限制，通过<code>4.1.初始化--Arbiter.start</code>的源码:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">signal</span>(<span class="hljs-params">self, sig, frame</span>):</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(self.SIG_QUEUE) &lt; <span class="hljs-number">5</span>:<br>        self.SIG_QUEUE.append(sig)<br>        self.wakeup()<br></code></pre></td></tr></table></figure>
<p>中可以知道，<code>Gunicorn</code>只允许最多有5个信号在队列中，防止同一时刻执行太多了信号处理，同时可以看到在正常接收信号后会执行<code>wakeup</code>函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">wakeup</span>(<span class="hljs-params">self</span>):</span><br>    <span class="hljs-keyword">try</span>:<br>        os.write(self.PIPE[<span class="hljs-number">1</span>], <span class="hljs-string">b&#x27;.&#x27;</span>)<br>    <span class="hljs-keyword">except</span> IOError <span class="hljs-keyword">as</span> e:<br>        <span class="hljs-keyword">if</span> e.errno <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> [errno.EAGAIN, errno.EINTR]:<br>            <span class="hljs-keyword">raise</span><br></code></pre></td></tr></table></figure>
<p>这个函数十分简单，就是往管道<code>PIPE</code>写入了一个字节，这样就能快速唤醒<code>Gunicorn</code>继续运行循环，不会停留在<code>sleep</code>阶段。</p>
<p>单看<code>wakeup</code>函数是无法理解它为啥能换新<code>Gunicorn</code>的主循环的， 需要结合<code>Arbiter.sleep</code>源码来了解为何这样设计。通常情况下，我们都会使用<code>Python</code>的标准函数<code>time.sleep</code>来实现进程睡眠，但是该函数是阻塞的，意味着该函数运行期间是没办法通过其它方法来进行打断。所以<code>Gunicorn</code>采用了事件循环的思路实现<code>Arbiter.sleep</code>，该通过使用<code>select.select</code>来读取<code>PIPE</code>,同时设置超时为1秒，<code>sleep</code>源码如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sleep</span>(<span class="hljs-params">self</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;\</span><br><span class="hljs-string">    Sleep until PIPE is readable or we timeout.</span><br><span class="hljs-string">    A readable PIPE means a signal occurred.</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-keyword">try</span>:<br>        ready = select.select([self.PIPE[<span class="hljs-number">0</span>]], [], [], <span class="hljs-number">1.0</span>)<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> ready[<span class="hljs-number">0</span>]:<br>            <span class="hljs-keyword">return</span><br>        <span class="hljs-keyword">while</span> os.read(self.PIPE[<span class="hljs-number">0</span>], <span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">pass</span><br>    <span class="hljs-keyword">except</span> (select.error, OSError) <span class="hljs-keyword">as</span> e:<br>        <span class="hljs-comment"># <span class="hljs-doctag">TODO:</span> select.error is a subclass of OSError since Python 3.3.</span><br>        error_number = <span class="hljs-built_in">getattr</span>(e, <span class="hljs-string">&#x27;errno&#x27;</span>, e.args[<span class="hljs-number">0</span>])<br>        <span class="hljs-comment"># 如果是中断或者重试错误，则直接return</span><br>        <span class="hljs-keyword">if</span> error_number <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> [errno.EAGAIN, errno.EINTR]:<br>            <span class="hljs-keyword">raise</span><br>    <span class="hljs-keyword">except</span> KeyboardInterrupt:<br>        sys.exit()<br></code></pre></td></tr></table></figure>
<p>在这段逻辑中，会把<code>PIPE</code>的读文件描述符传给<code>select.select</code>中,这样<code>select.select</code>会等待<code>PIPE</code>的事件再返回，同时它的最大等待时间为1秒，之后这段运行逻辑会停留在这里，但并不会阻塞当前线程，如果这时候进程有收到信号，还是可以正常接受信号, 当收到信号后，会通过<code>wakeup</code>函数往<code>PIPE</code>写入一个字节，接着<code>select.select</code>就能通过<code>PIPE</code>捕获到事件并返回，这时候上面停留的代码逻辑就会继续执行，等于<code>sleep</code>函数可以提前结束等待，<code>Gunicorn</code>的主循环能继续转了。</p>
<blockquote>
<p>这一段主要是依赖于事件循环相关来防止主进程被阻塞，可以通过搜索<code>事件循环</code>,<code>epoll</code>来了解更多相关的。<br>如果想知道如何在阻塞代码中实现一个协程，可以通过<a href="https://so1n.me/2021/11/08/%E5%88%9D%E8%AF%86Python%20Async%E7%9A%84%E5%AE%9E%E7%8E%B0/">初识Python协程的实现</a>了解</p>
</blockquote>
<h2 id="5-无感切换实例"><a href="#5-无感切换实例" class="headerlink" title="5.无感切换实例"></a>5.无感切换实例</h2><p>在分析<code>Arbiter</code>，有几处都是先忽略跳过不分析，这部分的功能我把他称为无感切换新实例，这里的无感是指与<code>Gunicorn</code>绑定的scoket交互的应用程序，如<code>Nginx</code>或者客户端等。<br>这个功能可以在<code>Gunicorn</code>运行的时候，重新开一个新的<code>Gunicorn</code>实例来运行我们指定的代码，这时候读取的代码和配置都是最新的，与我们当前正在运行的旧实例不一样，但是他们都能针对同一批socket处理请求。</p>
<blockquote>
<p>为了方便阐述，我把一个<code>Master</code>进程与它fork出来的<code>Worker</code>进程统称为一个实例。</p>
</blockquote>
<p>实际上官方把这个功能称为：<a target="_blank" rel="noopener" href="https://docs.gunicorn.org/en/stable/signals.html#upgrading-to-a-new-binary-on-the-fly">Upgrading to a new binary on the fly</a>，这个功能是大多数<code>Pre-Worker</code>模型的服务器都会支持的，不过这个功能需要多块不同生命周期的代码来结合才可以完成，所以单独拎出来分析。</p>
<p>根据文档：</p>
<blockquote>
<p>First, replace the old binary with a new one, then send a USR2 signal to the current master process. It executes a new binary whose PID file is postfixed with .2 (e.g. /var/run/gunicorn.pid.2), which in turn starts a new master process and new worker processes</p>
</blockquote>
<p>可以知道，<code>Gunicorn</code>在收到<code>USR2</code>的信号后，收到信号的进程会创建一个新的子进程，这部分的源代码如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">handle_usr2</span>(<span class="hljs-params">self</span>):</span><br>    <span class="hljs-comment"># 收到信号，执行对应的函数 </span><br>    self.reexec()<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reexec</span>(<span class="hljs-params">self</span>):</span><br>    <span class="hljs-comment"># 防止多个信号同时处理</span><br>    <span class="hljs-keyword">if</span> self.reexec_pid != <span class="hljs-number">0</span>:<br>        self.log.warning(<span class="hljs-string">&quot;USR2 signal ignored. Child exists.&quot;</span>)<br>        <span class="hljs-keyword">return</span><br><br>    <span class="hljs-keyword">if</span> self.master_pid != <span class="hljs-number">0</span>:<br>        self.log.warning(<span class="hljs-string">&quot;USR2 signal ignored. Parent exists.&quot;</span>)<br>        <span class="hljs-keyword">return</span><br><br>    master_pid = os.getpid()<br>    self.reexec_pid = os.fork()<br>    <span class="hljs-keyword">if</span> self.reexec_pid != <span class="hljs-number">0</span>:<br>        <span class="hljs-comment"># 对于主进程，不用再执行对应的代码</span><br>        <span class="hljs-keyword">return</span><br><br>    <span class="hljs-comment"># 对于fork出来的子进程，执行的代码逻辑</span><br>    self.cfg.pre_exec(self)<br><br>    <span class="hljs-comment"># 复制当前Master进程初始化时的环境变量（不被后面运行时的变量影响）</span><br>    environ = self.cfg.env_orig.copy()<br>    <span class="hljs-comment"># 设置当前Master进程的PID</span><br>    environ[<span class="hljs-string">&#x27;GUNICORN_PID&#x27;</span>] = <span class="hljs-built_in">str</span>(master_pid)<br><br>    <span class="hljs-comment"># 设置文件描述符地址到环境变量</span><br>    <span class="hljs-keyword">if</span> self.systemd:<br>        environ[<span class="hljs-string">&#x27;LISTEN_PID&#x27;</span>] = <span class="hljs-built_in">str</span>(os.getpid())<br>        environ[<span class="hljs-string">&#x27;LISTEN_FDS&#x27;</span>] = <span class="hljs-built_in">str</span>(<span class="hljs-built_in">len</span>(self.LISTENERS))<br>    <span class="hljs-keyword">else</span>:<br>        environ[<span class="hljs-string">&#x27;GUNICORN_FD&#x27;</span>] = <span class="hljs-string">&#x27;,&#x27;</span>.join(<br>            <span class="hljs-built_in">str</span>(l.fileno()) <span class="hljs-keyword">for</span> l <span class="hljs-keyword">in</span> self.LISTENERS)<br><br>    <span class="hljs-comment"># 更改cwd</span><br>    os.chdir(self.START_CTX[<span class="hljs-string">&#x27;cwd&#x27;</span>])<br><br>    <span class="hljs-comment"># exec the process using the original environment</span><br>    <span class="hljs-comment"># Gunicorn通过os.execvpe来运行一个新的Master进程</span><br>    <span class="hljs-comment"># execvpe会通过PATH环境变量来查找用户指定的程序，并用当前的Python运行环境来运行程序，同时使用的是指定的环境变量</span><br>    <span class="hljs-comment"># 其中用到的参数分别是：</span><br>    <span class="hljs-comment">#   0是当前的Python运行环境</span><br>    <span class="hljs-comment">#   args是参数</span><br>    <span class="hljs-comment">#   environ是环境变量</span><br>    os.execvpe(self.START_CTX[<span class="hljs-number">0</span>], self.START_CTX[<span class="hljs-string">&#x27;args&#x27;</span>], environ)<br></code></pre></td></tr></table></figure>
<p>按官方文档的示例，当<code>Gunicorn</code>执行完这段逻辑后，就有一个新的<code>Gunicorn</code>实例开始运行了，由于这个实例的环境变量中存在一个名为<code>GUNICORN_PID</code>的KEY， 所以在运行时会有一些不一样， 在<code>Arbiter.start</code>进行初始化时会设置不一样的属性:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">start</span>(<span class="hljs-params">self</span>):</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;GUNICORN_PID&#x27;</span> <span class="hljs-keyword">in</span> os.environ:<br>        <span class="hljs-comment"># 代表这是一个被一个master进程创建的master进程</span><br>        self.master_pid = <span class="hljs-built_in">int</span>(os.environ.get(<span class="hljs-string">&#x27;GUNICORN_PID&#x27;</span>))<br>        self.proc_name = self.proc_name + <span class="hljs-string">&quot;.2&quot;</span><br>        self.master_name = <span class="hljs-string">&quot;Master.2&quot;</span><br><br>    self.pid = os.getpid()<br>    <span class="hljs-keyword">if</span> self.cfg.pidfile <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>        pidname = self.cfg.pidfile<br>        <span class="hljs-keyword">if</span> self.master_pid != <span class="hljs-number">0</span>:<br>            pidname += <span class="hljs-string">&quot;.2&quot;</span><br>            <span class="hljs-comment"># 重新启动时创建新的pidfile</span><br>        self.pidfile = Pidfile(pidname)<br>        self.pidfile.create(self.pid)<br></code></pre></td></tr></table></figure>
<p>同时，在初始化scoket时，还会沿用环境变量中名为<code>GUNICORN_FD</code>的值，这个值是创建这个进程的<code>Master</code>进程用到的文件描述符，通过复用相同的文件描述符，使其两个进程都能读取到相同端口的网络请求数据：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">start</span>(<span class="hljs-params">self</span>):</span><br>    ...<br>    <span class="hljs-comment"># 省去之前的代码</span><br>    <span class="hljs-keyword">elif</span> self.master_pid:<br>        <span class="hljs-comment"># 获取之前进程的fd</span><br>        fds = []<br>        <span class="hljs-keyword">for</span> fd <span class="hljs-keyword">in</span> os.environ.pop(<span class="hljs-string">&#x27;GUNICORN_FD&#x27;</span>).split(<span class="hljs-string">&#x27;,&#x27;</span>):<br>            fds.append(<span class="hljs-built_in">int</span>(fd))<br><br>    self.LISTENERS = sock.create_sockets(self.cfg, self.log, fds)<br></code></pre></td></tr></table></figure>
<p>在新创建的实例运行后， 机器上的<code>Gunicorn</code>进程列表将变为这样子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-comment"># 来自官方文档</span><br>  PID USER      PR  NI  VIRT  RES  SHR S  %CPU %MEM    TIME+  COMMAND<br><span class="hljs-number">20844</span> benoitc   <span class="hljs-number">20</span>   <span class="hljs-number">0</span> <span class="hljs-number">54808</span>  11m <span class="hljs-number">3352</span> S   <span class="hljs-number">0.0</span>  <span class="hljs-number">0.1</span>   <span class="hljs-number">0</span>:<span class="hljs-number">00.36</span> gunicorn: master [test:app]<br><span class="hljs-number">20849</span> benoitc   <span class="hljs-number">20</span>   <span class="hljs-number">0</span> <span class="hljs-number">54808</span> <span class="hljs-number">9.9</span>m <span class="hljs-number">1500</span> S   <span class="hljs-number">0.0</span>  <span class="hljs-number">0.1</span>   <span class="hljs-number">0</span>:<span class="hljs-number">00.02</span> gunicorn: worker [test:app]<br><span class="hljs-number">20850</span> benoitc   <span class="hljs-number">20</span>   <span class="hljs-number">0</span> <span class="hljs-number">54808</span> <span class="hljs-number">9.9</span>m <span class="hljs-number">1500</span> S   <span class="hljs-number">0.0</span>  <span class="hljs-number">0.1</span>   <span class="hljs-number">0</span>:<span class="hljs-number">00.01</span> gunicorn: worker [test:app]<br><span class="hljs-number">20851</span> benoitc   <span class="hljs-number">20</span>   <span class="hljs-number">0</span> <span class="hljs-number">54808</span> <span class="hljs-number">9.9</span>m <span class="hljs-number">1500</span> S   <span class="hljs-number">0.0</span>  <span class="hljs-number">0.1</span>   <span class="hljs-number">0</span>:<span class="hljs-number">00.01</span> gunicorn: worker [test:app]<br><span class="hljs-number">20854</span> benoitc   <span class="hljs-number">20</span>   <span class="hljs-number">0</span> <span class="hljs-number">55748</span>  12m <span class="hljs-number">3348</span> S   <span class="hljs-number">0.0</span>  <span class="hljs-number">0.2</span>   <span class="hljs-number">0</span>:<span class="hljs-number">00.35</span> gunicorn: master [test:app]<br><span class="hljs-number">20859</span> benoitc   <span class="hljs-number">20</span>   <span class="hljs-number">0</span> <span class="hljs-number">55748</span>  11m <span class="hljs-number">1500</span> S   <span class="hljs-number">0.0</span>  <span class="hljs-number">0.1</span>   <span class="hljs-number">0</span>:<span class="hljs-number">00.01</span> gunicorn: worker [test:app]<br><span class="hljs-number">20860</span> benoitc   <span class="hljs-number">20</span>   <span class="hljs-number">0</span> <span class="hljs-number">55748</span>  11m <span class="hljs-number">1500</span> S   <span class="hljs-number">0.0</span>  <span class="hljs-number">0.1</span>   <span class="hljs-number">0</span>:<span class="hljs-number">00.00</span> gunicorn: worker [test:app]<br><span class="hljs-number">20861</span> benoitc   <span class="hljs-number">20</span>   <span class="hljs-number">0</span> <span class="hljs-number">55748</span>  11m <span class="hljs-number">1500</span> S   <span class="hljs-number">0.0</span>  <span class="hljs-number">0.1</span>   <span class="hljs-number">0</span>:<span class="hljs-number">00.01</span> gunicorn: worker [test:app]<br></code></pre></td></tr></table></figure>
<p>从这个进程列表可以发现目前有两个<code>Master</code>进程，他们分别有3个<code>Worker</code>子进程，这时候两个实例是一起运行的，如果指定的代码文件没有进行修改，指定的配置也没变，那么这两个实例是等效的。</p>
<p>当用户判断新的实例能正常处理请求后， 可以发送信号<code>TERM</code>给实例的<code>Master</code>，让它开始优雅的关闭<code>Worker</code>并退出，然后新创建的<code>Master</code>示例会在核心循环中发现创建自己的父进程已经退出了， 就让自己晋升为真正名义上的<code>Master</code>进程，源码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">maybe_promote_master</span>(<span class="hljs-params">self</span>):</span><br>    <span class="hljs-keyword">if</span> self.master_pid == <span class="hljs-number">0</span>:<br>        <span class="hljs-comment"># 已经是真正的`Master`进程，直接返回</span><br>        <span class="hljs-keyword">return</span><br><br>    <span class="hljs-keyword">if</span> self.master_pid != os.getppid():<br>        <span class="hljs-comment"># 该进程是从之前的主进程派生的，获取不到父进程id证明父进程被kill了  这时自己将晋升为主进程</span><br>        self.log.info(<span class="hljs-string">&quot;Master has been promoted.&quot;</span>)<br>        <span class="hljs-comment"># 设置属性，标明自己是正真的Master</span><br>        <span class="hljs-comment"># reset master infos</span><br>        self.master_name = <span class="hljs-string">&quot;Master&quot;</span><br>        self.master_pid = <span class="hljs-number">0</span><br>        self.proc_name = self.cfg.proc_name<br>        <span class="hljs-keyword">del</span> os.environ[<span class="hljs-string">&#x27;GUNICORN_PID&#x27;</span>]<br>        <span class="hljs-comment"># rename the pidfile</span><br>        <span class="hljs-keyword">if</span> self.pidfile <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            self.pidfile.rename(self.cfg.pidfile)<br>        <span class="hljs-comment"># reset proctitle</span><br>        util._setproctitle(<span class="hljs-string">&quot;master [%s]&quot;</span> % self.proc_name)<br></code></pre></td></tr></table></figure>
<p>通过源码可以发现，无论新实例有没有通过<code>may_be_promote_master</code>晋升为名义上的<code>Master</code>进程， 总体上的逻辑跟原先的<code>Master</code>进程是一样的，只不过是没办法通过接受<code>USR2</code>信号来创建新的实例。</p>
<blockquote>
<p>通过这种方式可以无感的升级应用代码，结合其它的信号，在升级失败时也能关闭新创建的实例，切回到旧实例，具体可以通过<a target="_blank" rel="noopener" href="https://docs.gunicorn.org/en/stable/signals.html#upgrading-to-a-new-binary-on-the-fly">Upgrading to a new binary on the fly</a>了解。</p>
</blockquote>
<h2 id="6-Worker与Master的交互"><a href="#6-Worker与Master的交互" class="headerlink" title="6.Worker与Master的交互"></a>6.Worker与Master的交互</h2><p>分析完了<code>Arbiter</code>后，整个<code>Gunicorn</code>的核心还剩下<code>Worker</code>尚未分析，<code>Gunicorn</code>中带了多种<code>Worker</code>，比如用在<code>gevent</code>场景的<code>Worker.ggevent.GeventWorker</code>,用在<code>Tornado</code>的<code>Worker.gtornado.TornadoWorker</code>,这些<code>Worker</code>除了一些与<code>Arbiter</code>交互的方法外， 还有一些方法用来通过读取<code>scoket</code>的数据并转化为<code>WSGI</code>协议发给挂在后面的<code>WSGI</code>应用。这意味着<code>Gunicorn</code>不仅用于<code>WSGI</code>场景，还可以通过自己编写<code>Worker</code>来对接其它的场景，比如<code>Uvicorn.Worker</code>就是对接<code>ASGI</code>应用等。</p>
<blockquote>
<p>由于我在分析<code>Gunicorn</code>时，我是抱着使用<code>Gunicorn</code>来托管我的TCP服务的，所以我是着重了解<code>Worker</code>与<code>Arbiter</code>的交互，对于自带的其它<code>Worker</code>,则不多做说明(通过了解<code>WSGI</code>协议也能了解它们的执行逻辑)。</p>
</blockquote>
<p><code>Worker</code>与<code>Arbiter</code>的交互可以简化为如下图:</p>
<p><img  src="https://s2.loli.net/2022/03/01/arnM8u2DIfjxHU7.jpg"  ><span class="image-caption">Gunicorn源码分析-Worker与Arbiter交互</span></p>
<p>图中蓝色和绿色线条代表两种类型的信号交互，黑色代表其它的<code>Master</code>进程与<code>Worker</code>进程的交互。</p>
<h3 id="6-1-基于信号的交互"><a href="#6-1-基于信号的交互" class="headerlink" title="6.1.基于信号的交互"></a>6.1.基于信号的交互</h3><p>在图中见到了已经在<code>4.2.管理worker数量--manager-workers</code>说过的<code>manage_workers</code>，它除了在<code>Arbiter</code>中会调用<code>manage_workers</code>进行<code>Worker</code>初始化，之后会在接收到用户发起信号的时候调用<code>manage_worker</code>来进行增减。这类型信号更改<code>Worker</code>数量有两种， 一种是修改配置的<code>Worker</code>数量， 然后通过信号<code>HUP</code>重载配置:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">handle_hup</span>(<span class="hljs-params">self</span>):</span><br>    self.log.info(<span class="hljs-string">&quot;Hang up: %s&quot;</span>, self.master_name)<br>    self.reload()<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reload</span>(<span class="hljs-params">self</span>):</span><br>    ...<br>    <span class="hljs-comment"># 省略其它代码</span><br><br>    <span class="hljs-comment"># spawn new workers</span><br>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(self.cfg.workers):<br>        self.spawn_worker()<br><br>    <span class="hljs-comment"># manage workers</span><br>    self.manage_workers()<br></code></pre></td></tr></table></figure>

<p>另外一种就是通过信号<code>TTIN</code>和<code>TTOU</code>来更改数量的加减：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">handle_ttin</span>(<span class="hljs-params">self</span>):</span><br>    self.num_workers += <span class="hljs-number">1</span><br>    self.manage_workers()<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">handle_ttou</span>(<span class="hljs-params">self</span>):</span><br>    <span class="hljs-keyword">if</span> self.num_workers &lt;= <span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">return</span><br>    self.num_workers -= <span class="hljs-number">1</span><br>    self.manage_workers()<br></code></pre></td></tr></table></figure>

<p>此外，<code>Master</code>除了接收用户的信号外，还接收自己创建的<code>Worker</code>进程的信号，当<code>Worker</code>进程退出时，会发送信号<code>CHLD</code>给<code>Master</code>进程，<code>Master</code>进程会调用<code>reap_worker</code>来回收对应<code>Worker</code>的进程资源, <code>reap_worker</code>源码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reap_workers</span>(<span class="hljs-params">self</span>):</span><br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-comment"># 注意信号不排队的问题，你可以循环检查waitpid()子进程的状态. </span><br>        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>            <span class="hljs-comment"># 获取僵死子进程的信息</span><br>            wpid, status = os.waitpid(-<span class="hljs-number">1</span>, os.WNOHANG)<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> wpid:<br>                <span class="hljs-keyword">break</span><br>            <span class="hljs-keyword">if</span> self.reexec_pid == wpid:<br>                self.reexec_pid = <span class="hljs-number">0</span><br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-comment"># A worker was terminated. If the termination reason was</span><br>                <span class="hljs-comment"># that it could not boot, we&#x27;ll shut it down to avoid</span><br>                <span class="hljs-comment"># infinite start/stop cycles.</span><br>                exitcode = status &gt;&gt; <span class="hljs-number">8</span><br>                <span class="hljs-keyword">if</span> exitcode == self.WORKER_BOOT_ERROR:<br>                    reason = <span class="hljs-string">&quot;Worker failed to boot.&quot;</span><br>                    <span class="hljs-keyword">raise</span> HaltServer(reason, self.WORKER_BOOT_ERROR)<br>                <span class="hljs-keyword">if</span> exitcode == self.APP_LOAD_ERROR:<br>                    reason = <span class="hljs-string">&quot;App failed to load.&quot;</span><br>                    <span class="hljs-keyword">raise</span> HaltServer(reason, self.APP_LOAD_ERROR)<br>                <span class="hljs-comment"># WIFSIGNALED(status)为非0表明进程异常终止，记录异常信息。 </span><br>                <span class="hljs-keyword">if</span> os.WIFSIGNALED(status):<br>                    self.log.warning(<br>                        <span class="hljs-string">&quot;Worker with pid %s was terminated due to signal %s&quot;</span>,<br>                        wpid,<br>                        os.WTERMSIG(status)<br>                    )<br><br>                <span class="hljs-comment"># 清除Master进程的数据</span><br>                worker = self.WORKERS.pop(wpid, <span class="hljs-literal">None</span>)<br>                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> worker:<br>                    <span class="hljs-keyword">continue</span><br>                <span class="hljs-comment"># 关闭临时文件</span><br>                worker.tmp.close()<br>                self.cfg.child_exit(self, worker)<br>    <span class="hljs-keyword">except</span> OSError <span class="hljs-keyword">as</span> e:<br>        <span class="hljs-comment"># errno.ECHILD代表调用进程没有任何子进程，该类型的错误不应该报错</span><br>        <span class="hljs-keyword">if</span> e.errno != errno.ECHILD:<br>            <span class="hljs-keyword">raise</span><br></code></pre></td></tr></table></figure>
<p>这段代码实际上是为了解决一个类Unix系统等待终止子进程的问题， 该问题是如果子进程在终止过程中，子进程完全消失了，就没有给父进程留下任何可以来了解子进程的东西,父进程没办法清理与子进程相关的数据，所以类Unix系统有这样一个设计：如果子进程在父进程之前结束会先发送信号给父进程，然后内核会把子进程设置为一个特殊的状态。处于这个状态的进程叫做僵死进程，这类进程只保留最小的概要信息并等待分进程来查询自己的信息，只要父进程获取了子进程的信息，子进程就会消失，否则会一直保持僵死状态(zombie)。其中父进程获取子进程的信息有多种方式，在<code>Gunicorn</code>是采用<code>waitpid</code>来获取子进程的信息，而<code>reap_workers</code>的主要责任就是通过<code>waitpid</code>获取子进程信息并做出响应。</p>
<p>在<code>Gunicorn</code>中，采用<code>waitpid</code>来获取僵死进程的状态和信息，直接使用<code>waitpid</code>会暂时停止目前进程的执行，直到有信号来到或者有子进程结束，所以设置了<code>WHOHANG</code>标记，表示如果没有任何已经结束的子进程也马上返回结果，不等待并采用循环的方式来解决可能同时出现多个进程变为僵死状态的问题。此外<code>Gunicorn</code>在<code>waitpid</code>中传了一个参数值<code>-1</code>,这个参数的名为<code>pid</code>，输入不同的值有不同的意义：</p>
<ul>
<li>pid&gt;0时，只等待进程ID等于pid的子进程，不管其它已经有多少子进程运行结束退出了，只要指定的子进程还没有结束，waitpid就会一直等下去。</li>
<li>pid=-1时，等待任何一个子进程退出，没有任何限制，此时waitpid和wait的作用一模一样。</li>
<li>pid=0时，等待同一个进程组中的任何子进程，如果子进程已经加入了别的进程组，waitpid不会处理它。</li>
<li>pid&lt;-1时，等待一个指定进程组中的任何子进程，这个进程组的ID等于pid的绝对值。</li>
</ul>
<p><code>Gunicorn</code>在通过<code>waitpid</code>获取到的返回信息中第一个pid代表退出进程的pid, 如果为空就代表没有子进程退出，应该直接退出逻辑返回到循环中，第二个status它包含了一些子进程的附加信息，该参数的高8位记录进程调用exit退出的状态，低8位记录进程接收到的信号，如果是正常退出，高8位数为退出状态，低8位数为0,如果是非正常退出，高8位数为0，低8位数为信号id，所以<code>Gunicorn</code>会通过<code>status &gt;&gt; 8</code>来获取低8位的数据，且当它不为0时就判断是否是自己定义的特殊信号，如果是则按照信号进行抛异常。</p>
<h3 id="6-2-Master进程主动检测"><a href="#6-2-Master进程主动检测" class="headerlink" title="6.2.Master进程主动检测"></a>6.2.Master进程主动检测</h3><p>上面虽然说到<code>Master</code>进程虽然可以收到子进程退出时发出的<code>CHLD</code>信号，但是并不是所有子进程退出时都能发出<code>CHLD</code>信号，所以<code>Master</code>进程还需要做到主动检测，<code>Gunicorn</code>在主动检查中用到了一个比较奇特的方法–临时文件的最后修改时间，该方法是通过<code>Worker</code>进程每隔一段时间更新临时文件的最后修改时间，<code>Master</code>进程每隔一段时间就去检测最后修改时间是否在一段范围内， 如果不合法就剔除这个<code>Worker</code>进程。</p>
<blockquote>
<p>这种方式挺让人困惑的，同时容易引起性能问题，具体见<a target="_blank" rel="noopener" href="https://docs.gunicorn.org/en/stable/faq.html#how-do-i-avoid-gunicorn-excessively-blocking-in-os-fchmod">How do I avoid Gunicorn excessively blocking in os.fchmod?</a>，目前官方表示可能会进行改进， 见<code>Gunicorn</code>中的一条<a target="_blank" rel="noopener" href="https://github.com/benoitc/gunicorn/issues/1305">issue</a></p>
</blockquote>
<p>这个检测是思路通过<code>WorkerTmp</code>类来实现，它的源码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WorkerTmp</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, cfg</span>):</span><br>        ...<br>        <span class="hljs-comment"># 省略代码，这一步只是做初始化 </span><br>        self.spinner = <span class="hljs-number">0</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">notify</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-comment"># 通过更改权限的方式更新修改时间</span><br>        self.spinner = (self.spinner + <span class="hljs-number">1</span>) % <span class="hljs-number">2</span><br>        os.fchmod(self._tmp.fileno(), self.spinner)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">last_update</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-comment"># 获取文件描述符的修改时间</span><br>        <span class="hljs-keyword">return</span> os.fstat(self._tmp.fileno()).st_ctime<br></code></pre></td></tr></table></figure>
<p>它会在<code>Worker</code>初始化时实例化为<code>Worker.tmp</code>属性，对于<code>Worker</code>进程，必须在<code>self.timeout / 2</code>的时间间隔调用<code>tmp.notify</code>来更新修改文件的更新时间；对于<code>Master</code>则通过<code>tmp.last_update</code>来获取临时文件的最后修改时间，以此判断<code>Worker</code>是否还存活，这部分就是示例图的<code>murder_workers</code>,它的源码如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">murder_workers</span>(<span class="hljs-params">self</span>):</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self.timeout:<br>        <span class="hljs-keyword">return</span><br>    workers = <span class="hljs-built_in">list</span>(self.WORKERS.items())<br>    <span class="hljs-keyword">for</span> (pid, worker) <span class="hljs-keyword">in</span> workers:<br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-comment"># 通过临时文件的最后更新时间判断是否合法</span><br>            <span class="hljs-keyword">if</span> time.time() - worker.tmp.last_update() &lt;= self.timeout:<br>                <span class="hljs-keyword">continue</span><br>        <span class="hljs-keyword">except</span> (OSError, ValueError):<br>            <span class="hljs-keyword">continue</span><br><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> worker.aborted:<br>            <span class="hljs-comment"># 第一次发现不合法，发送警告指令</span><br>            self.log.critical(<span class="hljs-string">&quot;WORKER TIMEOUT (pid:%s)&quot;</span>, pid)<br>            worker.aborted = <span class="hljs-literal">True</span><br>            <span class="hljs-comment"># 发送ABRT信号</span><br>            self.kill_worker(pid, signal.SIGABRT)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-comment"># 第二次发现不合法，关闭进程</span><br>            self.kill_worker(pid, signal.SIGKILL)<br></code></pre></td></tr></table></figure>

<h2 id="7-总结"><a href="#7-总结" class="headerlink" title="7.总结"></a>7.总结</h2><p>至此，<code>Gunicorn</code>的主核心逻辑源码分析已经分析完毕了，可以发现<code>Gunicorn</code>就是一个大管家，会把获取网络请求的功能下放给下面工作的<code>Worker</code>，自己只负责一些<code>Worker</code>的管理等功能。不过，通过分析后还是没办法解决我的一个疑惑：当前有4个<code>Worker</code>进程在运行，同时监听了同一个<code>socket</code>的情况下，它是如何做到负载均衡的？（或者是没做到）</p>

      </section>
      <section class="extra">
        
          <ul class="copyright">
  
    <li><strong>本文作者：</strong>So1n</li>
    <li><strong>本文链接：</strong><a href="http://so1n.me/2022/02/22/gunicorn/index.html" title="http:&#x2F;&#x2F;so1n.me&#x2F;2022&#x2F;02&#x2F;22&#x2F;gunicorn&#x2F;index.html">http:&#x2F;&#x2F;so1n.me&#x2F;2022&#x2F;02&#x2F;22&#x2F;gunicorn&#x2F;index.html</a></li>
    <li><strong>版权声明：</strong>本博客所有文章均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" title="BY-NC-SA" target="_blank" rel="noopener">BY-NC-SA</a> 许可协议，转载请注明出处！</li>
  
</ul>
        
        
          <section class="donate">
  <div id="qrcode-donate">
    <img src="https://github.com/so1n/so1n_blog_photo/blob/master/blog_photo/4d2ebf32586d8799ee2e75333d6f5d2.jpg?raw=true">
  </div>
  <div class="icon">
    <a href="javascript:;" id="alipay"><i class="iconfont iconalipay"></i></a>
    <a href="javascript:;" id="wechat"><i class="iconfont iconwechat-fill"></i></a>
  </div>
</section>
        
        
  <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python/" rel="tag">Python</a></li></ul> 

        
  <nav class="nav">
    <a></a>
    <a href="/2022/02/05/Python-gRPC%E5%AE%9E%E8%B7%B5(2)--Protocol%20buffer/">Python-gRPC实践（2）--Protocol Buffer<i class="iconfont iconright"></i></a>
  </nav>

      </section>
      
        <section class="comments">
  
    <div class="btn" id="comments-btn">查看评论</div>
  
  
<link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<div id="gitalk" class="gitalk"></div>
<script defer src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
<script>
  window.onload = function () {
    var gitalk = new Gitalk({
      clientID: '59f804e526b05c378470',
      clientSecret: '36679ff697cec424936a0f7c4bcd6d2988dac28e',
      id: window.location.pathname,
      repo: 'so1n.github.io',
      owner: 'so1n',
      admin: 'so1n'
    });
    if ( true ) {
      $("#comments-btn").on("click", function () {
        $(this).hide();
        gitalk.render('gitalk');
      });
    } else {
      gitalk.render('gitalk');
    }
  }
</script>

</section>
      
    </section>
  </div>
</article>
</div>
      <div class="col-xl-3">
          
  <aside class="toc-wrap">
    <h3 class="toc-title">文章目录：</h3>
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%AE%B0"><span class="toc-text">前记</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E7%AE%80%E5%8D%95%E4%BA%86%E8%A7%A3"><span class="toc-text">1.简单了解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%BC%80%E5%A7%8B%E5%85%A5%E6%89%8B"><span class="toc-text">2.开始入手</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%8A%A0%E8%BD%BD%E9%85%8D%E7%BD%AE"><span class="toc-text">3.加载配置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-Gunicorn%E7%9A%84%E6%A0%B8%E5%BF%83%E2%80%93Arbiter-run"><span class="toc-text">4.Gunicorn的核心–Arbiter.run</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1%E5%88%9D%E5%A7%8B%E5%8C%96%E2%80%93Arbiter-start"><span class="toc-text">4.1初始化–Arbiter.start</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E7%AE%A1%E7%90%86woeker%E6%95%B0%E9%87%8F%E2%80%93manage-workers"><span class="toc-text">4.2.管理woeker数量–manage_workers</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E6%A0%B8%E5%BF%83%E5%BE%AA%E7%8E%AF%E4%B8%8E%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86"><span class="toc-text">4.3.核心循环与信号处理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E6%97%A0%E6%84%9F%E5%88%87%E6%8D%A2%E5%AE%9E%E4%BE%8B"><span class="toc-text">5.无感切换实例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-Worker%E4%B8%8EMaster%E7%9A%84%E4%BA%A4%E4%BA%92"><span class="toc-text">6.Worker与Master的交互</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-%E5%9F%BA%E4%BA%8E%E4%BF%A1%E5%8F%B7%E7%9A%84%E4%BA%A4%E4%BA%92"><span class="toc-text">6.1.基于信号的交互</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-Master%E8%BF%9B%E7%A8%8B%E4%B8%BB%E5%8A%A8%E6%A3%80%E6%B5%8B"><span class="toc-text">6.2.Master进程主动检测</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E6%80%BB%E7%BB%93"><span class="toc-text">7.总结</span></a></li></ol>
  </aside>

        
          
  <aside class="toc-wrap">
    <h3 class="toc-title">文章目录：</h3>
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%AE%B0"><span class="toc-text">前记</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E7%AE%80%E5%8D%95%E4%BA%86%E8%A7%A3"><span class="toc-text">1.简单了解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%BC%80%E5%A7%8B%E5%85%A5%E6%89%8B"><span class="toc-text">2.开始入手</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%8A%A0%E8%BD%BD%E9%85%8D%E7%BD%AE"><span class="toc-text">3.加载配置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-Gunicorn%E7%9A%84%E6%A0%B8%E5%BF%83%E2%80%93Arbiter-run"><span class="toc-text">4.Gunicorn的核心–Arbiter.run</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1%E5%88%9D%E5%A7%8B%E5%8C%96%E2%80%93Arbiter-start"><span class="toc-text">4.1初始化–Arbiter.start</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E7%AE%A1%E7%90%86woeker%E6%95%B0%E9%87%8F%E2%80%93manage-workers"><span class="toc-text">4.2.管理woeker数量–manage_workers</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E6%A0%B8%E5%BF%83%E5%BE%AA%E7%8E%AF%E4%B8%8E%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86"><span class="toc-text">4.3.核心循环与信号处理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E6%97%A0%E6%84%9F%E5%88%87%E6%8D%A2%E5%AE%9E%E4%BE%8B"><span class="toc-text">5.无感切换实例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-Worker%E4%B8%8EMaster%E7%9A%84%E4%BA%A4%E4%BA%92"><span class="toc-text">6.Worker与Master的交互</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-%E5%9F%BA%E4%BA%8E%E4%BF%A1%E5%8F%B7%E7%9A%84%E4%BA%A4%E4%BA%92"><span class="toc-text">6.1.基于信号的交互</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-Master%E8%BF%9B%E7%A8%8B%E4%B8%BB%E5%8A%A8%E6%A3%80%E6%B5%8B"><span class="toc-text">6.2.Master进程主动检测</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E6%80%BB%E7%BB%93"><span class="toc-text">7.总结</span></a></li></ol>
  </aside>

        
      </div>
    </div>
  </div>
</main>

  <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js">
</script>


<footer class="footer">
  <div class="footer-social"><a 
        href="https://github.com/so1n "
        target="_blank"
        class="footer-social-item"
        onMouseOver="this.style.color= '#9f7be1'" 
        onMouseOut="this.style.color='#33333D'">
          <i class="iconfont  icongithub-fill "></i>
      </a></div>
  
    <div class="footer-copyright"><p>Powered by <a target="_blank" href="https://hexo.io">Hexo</a>  |  Theme - <a target="_blank" href="https://github.com/izhaoo/hexo-theme-zhaoo">zhaoo</a></p></div>
  
  <div class="footer-copyright">
    总访问量<span id="busuanzi_value_site_pv"></span>次
    访客数<span id="busuanzi_value_site_uv"></span>人次
  </div>

</footer>

  
      <div class="fab fab-plus">
    <i class="iconfont iconplus"></i>
  </div>
  
  
  <div class="fab fab-up">
    <i class="iconfont iconcaret-up"></i>
  </div>
  
  
    <div class="scrollbar j-scrollbar">
  <div class="scrollbar-current j-scrollbar-current"></div>
</div>
  
  
    
<script src="/js/color-mode.js"></script>

  
  
    <div class="search">
  <div class="search-container">
    <div class="search-close">
      <i class="iconfont iconbaseline-close-px"></i>
    </div>
    <div class="search-input-wrapper">
      <i class="search-input-icon iconfont iconsearch"></i>
      <input class="search-input" type="search" id="search-input" placeholder="Search..." autofocus autocomplete="off"
        autocorrect="off" autocapitalize="off">
    </div>
    <div class="search-output" id="search-output"></div>
  </div>
</div>
  
</body>

<script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script>



  
<script src="https://cdn.bootcdn.net/ajax/libs/jquery.lazyload/1.9.1/jquery.lazyload.min.js"></script>




  
<script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js"></script>






  
<script src="https://cdn.bootcdn.net/ajax/libs/jquery.qrcode/1.0/jquery.qrcode.min.js"></script>




<script src="/js/utils.js"></script>
<script src="/js/script.js"></script>







  <script>
    (function () {
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
      } else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>













</html>