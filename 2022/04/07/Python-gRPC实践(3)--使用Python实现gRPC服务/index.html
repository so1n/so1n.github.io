

<!DOCTYPE html>
<html lang="zh-Hans" color-mode=light>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Python-gRPC实践(3)--使用Python实现gRPC服务 - So1n blog</title>
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="google" content="notranslate" />
  
  <meta name="description" content="前言通过前面的文章了解到了gRPC是什么，以及清楚使用...">
  <meta name="author" content="So1n">
  <link rel="icon" href="/images/icons/favicon.ico" type="image/png" sizes="16x16">
  <link rel="icon" href="/images/icons/favicon.ico" type="image/png" sizes="32x32">
  <link rel="apple-touch-icon" href="/images/icons/favicon.ico" sizes="180x180">
  <meta rel="mask-icon" href="/images/icons/stun-logo.svg" color="#333333">
  
    <meta rel="msapplication-TileImage" content="/images/icons/favicon.ico">
    <meta rel="msapplication-TileColor" content="#000000">
  

  
<link rel="stylesheet" href="/css/style.css">


  
    
<link rel="stylesheet" href="//at.alicdn.com/t/font_1445822_s6x2xcokxrl.css">

  

  
    
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css">

  

  
    
      
        
        
<link rel="stylesheet" href="https://cdn.bootcss.com/highlight.js/9.18.1/styles/atom-one-dark-reasonable.min.css" name="highlight-style" mode="light">

      
        
        
<link rel="stylesheet" href="https://cdn.bootcss.com/highlight.js/9.18.1/styles/atom-one-dark-reasonable.min.css" name="highlight-style" mode="dark">

      
  

  <script>
    var CONFIG = window.CONFIG || {};
    var ZHAOO = window.ZHAOO || {};
    CONFIG = {
      isHome: false,
      fancybox: true,
      pjax: false,
      loading: {
        gif: '',
        lottie: ''
      },
      lazyload: {
        enable: true,
        only_post: 'true',
        loading: {
          gif: '',
          lottie: ''
        }
      },
      donate: {
        enable: true,
        alipay: 'https://fastly.jsdelivr.net/gh/so1n/so1n_blog_photo@master/blog_photo/16550449287744d2ebf32586d8799ee2e75333d6f5d2.jpg',
        wechat: ''
      },
      galleries: {
        enable: true
      },
      fab: {
        enable: true,
        always_show: true
      },
      carrier: {
        enable: false
      },
      daovoice: {
        enable: false
      },
      preview: {
        background: {
          default: '',
          api: ''
        },
        motto: {
          default: 'I`m   So1n',
          typing: true,
          api: '',
          data_contents: '["data","content"]'
        },
      },
      qrcode: {
        enable: true,
        type: 'url',
        image: 'https://pic.izhaoo.com/weapp-code.jpg',
      },
      toc: {
        enable: true
      },
      scrollbar: {
        type: 'simple'
      },
      notification: {
        enable: false,
        delay: 4500,
        list: '',
        page_white_list: '',
        page_black_list: ''
      },
      search: {
        enable: true,
        path: 'search.xml'
      }
    }
  </script>

  

  

<meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="So1n blog" type="application/atom+xml">
</head>

<body class="lock-screen">
  <div class="loading" id="loading"></div>
  
    


  <nav class="navbar">
    <div class="left">
      
        <i class="iconfont iconhome j-navbar-back-home"></i>
      
      
        <i class="iconfont iconqrcode j-navbar-qrcode"></i>
      
      
        <i class="iconfont iconmoono" id="color-toggle" color-toggle="light"></i>
      
      
        <i class="iconfont iconsearch j-navbar-search"></i>
      
    </div>
    <div class="center">Python-gRPC实践(3)--使用Python实现gRPC服务</div>
    <div class="right">
      <i class="iconfont iconmenu j-navbar-menu"></i>
    </div>
    
      <div id="qrcode-navbar"></div>
    
  </nav>


  
  

<nav class="menu">
  <div class="menu-container">
    <div class="menu-close">
      <i class="iconfont iconbaseline-close-px"></i>
    </div>
    <ul class="menu-content"><li class="menu-item">
        <a href="/ " class="underline "> 首页</a>
      </li><li class="menu-item">
        <a href="/archives/ " class="underline "> 归档</a>
      </li><li class="menu-item">
        <a href="/tags/ " class="underline "> 标签</a>
      </li><li class="menu-item">
        <a href="/categories/ " class="underline "> 分类</a>
      </li><li class="menu-item">
        <a href="/project/ " class="underline "> 项目</a>
      </li><li class="menu-item">
        <a href="/about/ " class="underline "> 关于</a>
      </li></ul>
    
      <div class="menu-copyright"><p>Powered by <a target="_blank" href="https://hexo.io">Hexo</a>  |  Theme - <a target="_blank" href="https://github.com/izhaoo/hexo-theme-zhaoo">zhaoo</a>| <a target="_blank" href="/atom.xml">RSS</a> </p></div>
    
  </div>
</nav>
  <main id="main">
  <div class="article-wrap">
    <div class="row container">
      <div class="col-xl-3"></div>
      <div class="col-xl-6"><article class="article">
  <div class="wrap">
    <section class="head">
  <img src="https://ftp.bmp.ovh/imgs/2022/02/bd67e15aa8d46101.png" draggable="false">
  <div class="head-mask">
    <h1 class="head-title">Python-gRPC实践(3)--使用Python实现gRPC服务</h1>
    <div class="head-info">
      <span class="post-info-item"><i class="iconfont iconcalendar"></i>April 07, 2022</span>
      
      本文总阅读量<span id="busuanzi_value_page_pv"></span>次
      <span class="post-info-item"><i class="iconfont iconfont-size"></i>30757</span>
    </div>
  </div>
</section>

    <section class="main">
      <section class="content">
        <!-- 展示文章摘录 -->
        
          <p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>通过前面的文章了解到了<code>gRPC</code>是什么，以及清楚使用它的优缺点，现在终于可以开始实现一个<code>gRPC</code>服务了。</p></p>
        
        <p>这里演示的是一个用户与书互动的项目，用户可以通过该项目进行注册，登录，注销等操作，同时也可以上传，查看和评论对应的书籍，通常情况下我们会由一个简单的Web应用来提供这些服务，现在，我们假设这个服务非常庞大，需要把他们按照功能拆分成不同的微服务了，这些服务与Web应用通过<code>gRPC</code>进行通信。</p>
<blockquote>
<p>注：由于篇幅原因，不会夹杂大量的源代码，需要跳转到<code>Github</code>中查看，同时对于业务逻辑也不会详细的介绍，所以可能需要一些接口开发经验才容易阅读懂。</p>
</blockquote>
<h2 id="1-初始化准备"><a href="#1-初始化准备" class="headerlink" title="1.初始化准备"></a>1.初始化准备</h2><p>在创建项目之前，我们需要确定我们的需求是什么，就像开发API接口一样，先了解需求，然后多方根据需求定义好接口，最后才为每个接口编写对应的代码，在这个项目中，我假定了拆分了两个服务，一个是与用户有关， 一个是与书籍有关，书籍部分又细分为书籍管理，书籍社交两部分。为此，先编写了Protobuf文件，之前在<a href="https://so1n.me/2022/02/05/Python-gRPC%E5%AE%9E%E8%B7%B5(2)--Protocol%20buffer/">Python-gRPC实践（2）–Protocol Buffer</a>中说过，我们创建<code>gRPC</code>对应的Protobuf文件应该放在一个公有的仓库中，这样就方便后续的Protobuf文件升级以及不同语言都能共享同一份Protobuf文件。</p>
<p>所以创建一个<code>gRPC</code>服务的第一步就是先创建一个包含Protobuf文件的仓库，我把它命名为<code>grpc-example-common</code>，具体源码可以通过<a target="_blank" rel="noopener" href="https://github.com/so1n/grpc-example-common/tree/part-1">grpc-example-common</a>获取。</p>
<p>这个仓库中<code>pyproject.toml</code>文件的<code>tool.poetry.dependencies</code>部分如下:</p>
<figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs toml"><span class="hljs-section">[tool.poetry.dependencies]</span><br><span class="hljs-attr">python</span> = <span class="hljs-string">&quot;^3.8&quot;</span><br><span class="hljs-attr">grpcio</span> = <span class="hljs-string">&quot;^1.43.0&quot;</span><br><span class="hljs-attr">grpcio-tools</span> = <span class="hljs-string">&quot;^1.43.0&quot;</span><br></code></pre></td></tr></table></figure>
<p>通过这部分文件可以知道这个项目是基于<code>Python3.8</code>版本的，然后用到了2个依赖分别是<code>grpcio</code>以及<code>grpcio-tools</code>，其中<code>grpcio</code>是<code>Python</code>的<code>gRPC</code>实现，它是通过c语言翻译的，所以很多底层都是c实现的，如果在使用gRPC框架的过程中找不到对应的使用方法说明，那可以直接到gRPC的c项目中找到对应的函数并查看它的函数说明进而了解该函数的作用；而另一个库<code>grpcio-tools</code>的作用是把<code>proto</code>文件转译为<code>Python</code>代码，不过单靠<code>grpcio-tools</code>转译的代码很难使用，比如是这段代码:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">from</span> grpc_example_common.protos.user.user_pb2 <span class="hljs-keyword">import</span> LoginUserResult <br><br><br>login_user_result: LoginUserResult = LoginUserResult()<br></code></pre></td></tr></table></figure>
<p>这段代码引入了由<code>grpcio-tools</code>通过用户Protobuf文件生成的<code>LoginUserResult</code>对象，开发者在后续想要使用这个对象的时候，IDE是没办法提示你这个对象有什么属性的，只能凭自己的记忆进行填写，或者回到对应的Protobuf文件查看该对象的定义：</p>
<figure class="highlight plain"><figcaption><span>buffer</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Protocol">message LoginUserResult &#123;<br>  string uid &#x3D; 1;<br>  string user_name &#x3D; 2;<br>  string token &#x3D; 3;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>发现它有<code>uid</code>，<code>user_name</code>，<code>token</code>三个属性，然后才会在代码填写<code>LoginUserResult</code>对象的属性进行调用：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">from</span> grpc_example_common.protos.user.user_pb2 <span class="hljs-keyword">import</span> LoginUserResult <br><br><br>login_user_result: LoginUserResult = LoginUserResult(<br>    uid=<span class="hljs-string">&quot;123&quot;</span>,<br>    user_name=<span class="hljs-string">&quot;so1n&quot;</span>,<br>    token=<span class="hljs-string">&quot;aaa&quot;</span><br>)<br>print(login_user_result.uid)<br><span class="hljs-comment"># 123</span><br></code></pre></td></tr></table></figure>
<p>这时即使填错了，比如<code>uid</code>写为<code>uid1</code>IDE也不会提示有错误，我们需要等到运行时报错才知道是填错了。</p>
<p>这样一个场景是会让开发者非常难受的，明明都定义了一个Protobuf文件，文件中已经写了这个消息有什么属性了，结果生成对应的类却无法让IDE了解它有什么属性(跳进去源码也无法知道)，这时就需要通过<a target="_blank" rel="noopener" href="https://github.com/nipunn1313/mypy-protobuf">mypy-protobuf</a>来解决这一个问题。<code>mypy-protobuf</code>会生成的一份独立的<code>.pyi</code>文件，这样一来IDE就可以帮忙提示这个对象有什么属性了，如图：<br><img  src="https://cdn.jsdelivr.net/gh/so1n/so1n_blog_photo@master/blog_photo/16471860867391647186085970.png"  ><span class="image-caption">IDE提醒</span><br>此外，通过<code>.pyi</code>文件可以使<code>mypy</code>等工具校验我们的代码类型是否正确，这样在运行前就能知道代码是否有问题。</p>
<p><code>mypy-protobuf</code>的使用方法十分的简单，它以<code>grpcio-tools</code>的一个插件来运行，具体的使用方法如下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 定义生产文件的存放目录，通常都会在指定的目录下生成一个proto的文件夹</span><br>target_p = <span class="hljs-string">&quot;xxx&quot;</span><br><span class="hljs-comment"># 定义proto文件的目录</span><br>sourct_p = <span class="hljs-string">&quot;xxx&quot;</span><br>python -m grpc_tools.protoc \<br>    <span class="hljs-comment"># 指定xxx_pb2文件和xxx_pb2_grpc文件生成位置，通常我们都让他们在同一个文件夹生产</span><br>    --python_out=./<span class="hljs-variable">$target_p</span> \<br>    --grpc_python_out=./<span class="hljs-variable">$target_p</span> \<br>    <span class="hljs-comment"># 指定proto文件的位置</span><br>    -I. \<br>    <span class="hljs-variable">$source_p</span>/user/*.proto<br><span class="hljs-comment"># 上面是标准的grpcio-tools执行的标准语句</span><br>    <span class="hljs-comment"># 指定`mypy-protobuf`生成xxx_pb2和xxx_pb2_grpc对应的pyi文件的位置，必须与xxx_pb2和xxx_pb2_grpc位置保持一致</span><br>    --mypy_grpc_out=./<span class="hljs-variable">$target_p</span> \<br>    --mypy_out=./<span class="hljs-variable">$target_p</span> \<br></code></pre></td></tr></table></figure>
<p>只要运行了这段命令，<code>grpc_tools</code>就能在对应的路径下生成Protobuf对应的代码和对应的<code>pyi</code>文件，不过当前的<code>grpcio-tools</code>默认生成的代码所在的目录名是<code>protos</code>，它认为这个目录是在项目对应的根目录下生成的，如果我们指定在某个子目录下生产对应的代码，那么在运行程序时会直接报错，因为生成的代码文件中有一个大概长成这样的语句:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-comment"># xxx为proto文件的名</span><br><span class="hljs-keyword">from</span> protos.xxx <span class="hljs-keyword">import</span><br></code></pre></td></tr></table></figure>
<p>这意味着它永远都是从项目的根目录开始引入的<code>protos</code>包，但我们根目录却没有这个包，所以就会报错，这时就需要手动把生成的语句替换为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-comment"># xxx为proto文件的名</span><br><span class="hljs-keyword">from</span> .xxx <span class="hljs-keyword">import</span><br></code></pre></td></tr></table></figure>

<p>这样就可以完美运行了，但是每个文件手动改一下会非常的麻烦，因为每次生成代码后都要手动更改代码，同时由于项目存在多个Protobuf文件，每个文件都需要执行一次命令才能生成对应的代码。对于一个开发者来说，最讨厌的就是一直执行重复的工作，这种工作是非常烦心的， 所以需要编写了一个脚本来自动的把所有Protobuf文件转为<code>Python</code>代码(也就是项目中的<code>gen_rpc.sh</code>文件)，该脚本如下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 设置脚本运行的Python环境 </span><br><span class="hljs-built_in">export</span> VENV_PREFIX=<span class="hljs-string">&quot;&quot;</span><br><span class="hljs-keyword">if</span> [ -d <span class="hljs-string">&#x27;venv&#x27;</span> ] ; <span class="hljs-keyword">then</span><br>    <span class="hljs-built_in">export</span> VENV_PREFIX=<span class="hljs-string">&quot;venv/bin/&quot;</span><br><span class="hljs-keyword">fi</span><br><span class="hljs-keyword">if</span> [ -d <span class="hljs-string">&#x27;.venv&#x27;</span> ] ; <span class="hljs-keyword">then</span><br>    <span class="hljs-built_in">export</span> VENV_PREFIX=<span class="hljs-string">&quot;.venv/bin/&quot;</span><br><span class="hljs-keyword">fi</span><br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;use venv path:&#x27;</span> <span class="hljs-variable">$&#123;VENV_PREFIX&#125;</span><br><br><span class="hljs-comment"># 设置生成的存放Python代码的proto文件夹的目录 </span><br>target_p=<span class="hljs-string">&#x27;grpc_example_common&#x27;</span><br><span class="hljs-comment"># 设置Proyobuf文件所在位置</span><br>source_p=<span class="hljs-string">&#x27;protos&#x27;</span><br><span class="hljs-comment"># 设置生成protobuf代码文件的文件名 </span><br>service_list=(<span class="hljs-string">&quot;book&quot;</span> <span class="hljs-string">&quot;user&quot;</span>)<br><br><span class="hljs-comment"># 清理之前生成的代码</span><br>rm -r <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;target_p:?&#125;</span>/<span class="hljs-variable">$&#123;source_p:?&#125;</span>&quot;</span>*<br><span class="hljs-comment"># 创建对应的文件夹</span><br>mkdir -p <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;target_p:?&#125;</span>/<span class="hljs-variable">$&#123;source_p:?&#125;</span>&quot;</span><br><br><span class="hljs-comment"># 批处理</span><br><span class="hljs-keyword">for</span> service <span class="hljs-keyword">in</span> <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;service_list[@]&#125;</span>&quot;</span><br><span class="hljs-keyword">do</span><br>  <span class="hljs-comment"># 生成proto文件对应的Python代码逻辑，每个proto文件执行一次</span><br>  mkdir -p <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;target_p:?&#125;</span>/<span class="hljs-variable">$&#123;source_p:?&#125;</span>/<span class="hljs-variable">$&#123;service:?&#125;</span>&quot;</span><br>  <span class="hljs-built_in">echo</span>  <span class="hljs-string">&quot;from proto file:&quot;</span> <span class="hljs-variable">$source_p</span>/<span class="hljs-string">&quot;<span class="hljs-variable">$service</span>&quot;</span>/*.proto <span class="hljs-string">&quot;gen proto py file to&quot;</span> <span class="hljs-variable">$target_p</span>/<span class="hljs-variable">$source_p</span><br>  <span class="hljs-variable">$&#123;VENV_PREFIX&#125;</span>python -m grpc_tools.protoc \<br>    --mypy_grpc_out=./<span class="hljs-variable">$target_p</span> \<br>    --mypy_out=./<span class="hljs-variable">$target_p</span> \<br>    --python_out=./<span class="hljs-variable">$target_p</span> \<br>    --grpc_python_out=./<span class="hljs-variable">$target_p</span> \<br>    -I. \<br>    <span class="hljs-variable">$source_p</span>/<span class="hljs-string">&quot;<span class="hljs-variable">$service</span>&quot;</span>/*.proto<br><br>  <span class="hljs-comment"># 创建一个__init__文件，这样一来这个文件夹就是一个包了，下面转换为from . import语句才能生效</span><br>  touch <span class="hljs-variable">$target_p</span>/<span class="hljs-variable">$source_p</span>/<span class="hljs-string">&quot;<span class="hljs-variable">$service</span>&quot;</span>/__init__.py<br>  <span class="hljs-comment"># fix grpc tools bug</span><br>  sed -i <span class="hljs-string">&quot;s/from protos.<span class="hljs-variable">$service</span> import/from . import/&quot;</span> <span class="hljs-variable">$target_p</span>/<span class="hljs-variable">$source_p</span>/<span class="hljs-variable">$service</span>/*.py<br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure>
<p>这样一来，我们通过Protobuf文件生成<code>Python</code>代码的操作就非常省心了，不管Protobuf文件有何改动，只要通过调用命令后就能在<code>grpc_example_common.protos</code>目录下看到已经生成的最新的<code>Python</code>代码，目前<code>grpc_example_common</code>的项目结构如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash">├── grpc_example_common    <span class="hljs-comment"># Python与gRPC相关的调用</span><br>│   ├── helper<br>│   ├── __init__.py<br>│   ├── interceptor<br>│   └── protos             <span class="hljs-comment"># 生成的对应Python代码</span><br>├── protos                 <span class="hljs-comment"># Protobuf文件</span><br>│   ├── book<br>│   └── user<br>├──.flake8                 <span class="hljs-comment"># 格式化工具的配置</span><br>├──.pre-commit-config.yaml <span class="hljs-comment"># 格式化工具的配置</span><br>├── gen_rpc.sh             <span class="hljs-comment"># 通过proto文件生成Python gRPC调用代码的脚本</span><br>├── mypy.ini               <span class="hljs-comment"># 格式化工具的配置</span><br>├── pyproject.toml         <span class="hljs-comment"># Python项目配置文件</span><br>├── README.md<br>├── requirements-dev.txt   <span class="hljs-comment"># 测试环境的依赖文件</span><br>├── requirements.txt       <span class="hljs-comment"># 正式环境的依赖文件</span><br>└── setup.py <br></code></pre></td></tr></table></figure>
<p>通过项目结构可以看出还有其它的东西，这是我为了方便，我还在这个项目中添加一些<code>Python</code>与<code>gRPC</code>相关的调用封装，把它当做一个<code>Python</code>的自定义包。</p>
<p>需要注意的是，每修改一次Protobuf文件应该视为一次版本发布，当生成完Protobuf文件的对应代码后，我们需要提交代码并打上对应的tag，这样其它项目才能引用到对应的版本代码。</p>
<blockquote>
<p>对于格式化工具以及poetry包管理工具不了解的可以通过文章<a href="https://so1n.me/2021/08/10/%E4%BF%9D%E9%9A%9CPython%E9%A1%B9%E7%9B%AE%E8%B4%A8%E9%87%8F%E7%9A%84%E5%B7%A5%E5%85%B7/">保障Python项目质量的工具</a>了解。</p>
</blockquote>
<blockquote>
<p><code>grpc_example_common</code>目录下还有其它常用的封装，将会在后续章节介绍。</p>
</blockquote>
<h2 id="2-编写gRPC服务项目"><a href="#2-编写gRPC服务项目" class="headerlink" title="2.编写gRPC服务项目"></a>2.编写gRPC服务项目</h2><p>目前这个演示的项目有两个子gRPC项目，分别为<a target="_blank" rel="noopener" href="https://github.com/so1n/grpc-example-book-grpc-service">grpc-example-book-grpc-service</a>和<a target="_blank" rel="noopener" href="https://github.com/so1n/grpc-example-user-grpc-service">grpc-example-user-grpc-service</a>，他们的结构很像，所以这一节以<a target="_blank" rel="noopener" href="https://github.com/so1n/grpc-example-user-grpc-service">grpc-example-user-grpc-service</a>来阐述如何创建一个gRPC服务。</p>
<p>该项目的代码结构如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">├── tests                 <span class="hljs-comment"># 存放测试用例</span><br>│   ├── __init__.py<br>│   └── test_user.py<br>├── user_grpc_service     <span class="hljs-comment"># 项目代码真正所在的位置</span><br>│   ├── dal               <span class="hljs-comment">#   service代码，一般用于查询Mysql,Redis的逻辑</span><br>│   ├── handler           <span class="hljs-comment">#   业务逻辑代码，继承对应Protobuf文件生成的类</span><br>│   ├── helper            <span class="hljs-comment">#   其它代码封装。</span><br>│   └── __init__.py<br>├── app.py                <span class="hljs-comment"># 项目代码入口</span><br>├── mypy.ini              <span class="hljs-comment"># mypy配置文件</span><br>├── pyproject.toml        <span class="hljs-comment"># 项目配置文件</span><br>└── user.sql              <span class="hljs-comment"># 项目初始化SQL</span><br></code></pre></td></tr></table></figure>
<p>首先，该项目会通过如下配置引入一些依赖：</p>
<figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs toml"><span class="hljs-section">[tool.poetry.dependencies]</span><br><span class="hljs-attr">python</span> = <span class="hljs-string">&quot;^3.8&quot;</span><br><span class="hljs-attr">DBUtils</span> = <span class="hljs-string">&quot;^3.0.0&quot;</span><br><span class="hljs-attr">PyMySQL</span> = <span class="hljs-string">&quot;^1.0.2&quot;</span><br><span class="hljs-attr">cryptography</span> = <span class="hljs-string">&quot;^36.0.1&quot;</span><br><span class="hljs-attr">grpc_example_common</span> = &#123; git = <span class="hljs-string">&quot;git@github.com:so1n/grpc-example-common.git&quot;</span>, tag=<span class="hljs-string">&quot;v0.1.2&quot;</span>&#125;<br></code></pre></td></tr></table></figure>
<p>其中<code>grpc_example_common</code>项目就是包括我们上面通过Protobuf生成的文件生产的代码，以及一些自定义的封装，通过引入依赖后，可以很方便的引用Protobuf文件生成的代码。</p>
<p>安装依赖后，就可以在项目中编写对应的gRPC服务了， 在这个项目里有一个比较简单的分层，所有的gRPC服务接口处理的函数都在放在<code>user_grpc_service.handler</code>目录中，而与数据库交互的则放在<code>user_grpc_service.dal</code>中。</p>
<p>编写服务的第一步，就是在<code>user_grpc_service.handler</code>编写对应的代码，先创建一个名为<code>user.py</code>的文件，该文件的代码值负责对User服务的调用，由于对于User服务只有一个子服务，里面只需要创建一个名为<code>UserServicer</code>的类，这个类似继承于Protobuf生成的<code>user_pb2_grpc.UserServicer</code>类，如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-comment"># 通过common包引入对应Protobuf文件生成的代码</span><br><span class="hljs-keyword">from</span> grpc_example_common.protos.user <span class="hljs-keyword">import</span> user_pb2_grpc <span class="hljs-keyword">as</span> user_service<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserServicer</span>(<span class="hljs-params">user_service.UserServicer</span>):</span><br>    <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure>
<p>这时候IDE会在<code>UserServicer</code>上显示波浪线，如果鼠标移到波浪线位置上，IDE会提示<code>类 User 必须实现所有 abstract 方法</code>，于是点击<code>实现abstract方法</code>后，就会自动生成类似于下面的代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">from</span> google.protobuf.empty_pb2 <span class="hljs-keyword">import</span> Empty  <span class="hljs-comment"># type: ignore</span><br><span class="hljs-keyword">from</span> grpc_example_common.protos.user <span class="hljs-keyword">import</span> user_pb2 <span class="hljs-keyword">as</span> user_message<br><span class="hljs-keyword">from</span> grpc_example_common.protos.user <span class="hljs-keyword">import</span> user_pb2_grpc <span class="hljs-keyword">as</span> user_service<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserServicer</span>(<span class="hljs-params">user_service.UserServicer</span>):</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">logout_user</span>(<span class="hljs-params">self, request: user_message.LogoutUserRequest,</span></span><br><span class="hljs-function"><span class="hljs-params">                    context: grpc.ServicerContext</span>) -&gt; Empty:</span><br>        <span class="hljs-keyword">pass</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">login_user</span>(<span class="hljs-params">self, request: user_message.LoginUserRequest,</span></span><br><span class="hljs-function"><span class="hljs-params">                   context: grpc.ServicerContext</span>) -&gt; user_message.LoginUserResult:</span><br>        <span class="hljs-keyword">pass</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">create_user</span>(<span class="hljs-params">self, request: user_message.CreateUserRequest,</span></span><br><span class="hljs-function"><span class="hljs-params">                    context: grpc.ServicerContext</span>) -&gt; Empty:</span><br>        <span class="hljs-keyword">pass</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">delete_user</span>(<span class="hljs-params">self, request: user_message.DeleteUserRequest,</span></span><br><span class="hljs-function"><span class="hljs-params">                    context: grpc.ServicerContext</span>) -&gt; Empty:</span><br>        <span class="hljs-keyword">pass</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">check_user_login</span>(<span class="hljs-params">self, request: user_message.LogoutUserRequest,</span></span><br><span class="hljs-function"><span class="hljs-params">                         context: grpc.ServicerContext</span>) -&gt; user_message.CheckLoginResult:</span><br>        <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure>
<p>这段代码就是<a target="_blank" rel="noopener" href="https://github.com/so1n/grpc-example-common/blob/part-1/protos/user/user.proto">protos/user/user.proto</a>对应的<code>Python</code>代码表达，当客户端调用<code>UserServicer.logout_user</code>方法时，服务端就会自动转到该方法执行对应的逻辑，并返回结果给客户端，所以对于开发者来说只要专心完成好这几个接口的实现即可。开发者编写此处的业务逻辑代码与平时编写的API代码基本没什么差别，这里不多做阐述，具体的业务逻辑可见<a target="_blank" rel="noopener" href="https://github.com/so1n/grpc-example-user-grpc-service/blob/part-1/user_grpc_service/handler/user.py">user_grpc_service/handler/user.py</a></p>
<p>不过需要注意的是从<code>request</code>中得到的数据对象并不是<code>Python</code>中常见的对象，而是gRPC封装的且类似于<code>Python</code>常见的对象，如果直接用于<code>pymysql</code>的类似代码:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">with</span> conn.cursor() <span class="hljs-keyword">as</span> cursor:<br>    cursor.execute(sql, param)<br></code></pre></td></tr></table></figure>
<p>那么execute可能会转码失败，导致拼接不了正确的SQL，这时候可以把<code>request</code>中得到的对象转为<code>Python</code>中场见的对象，比如<code>gRPC</code>的时间类型<code>Timestamp</code>与<code>Python</code>时间类型<code>datetime</code>转换如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> datetime<br><span class="hljs-keyword">from</span> dataclasses <span class="hljs-keyword">import</span> MISSING<br><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> Any, Optional<br><br><span class="hljs-keyword">from</span> google.protobuf.timestamp_pb2 <span class="hljs-keyword">import</span> Timestamp  <span class="hljs-comment"># type: ignore</span><br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">timestamp_to_datetime</span>(<span class="hljs-params">t: Timestamp, default: Any = MISSING</span>) -&gt; datetime.datetime:</span><br>    <span class="hljs-string">&quot;&quot;&quot;replace proto.timestamp to python datetime.datetime&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">if</span> t.seconds == <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> t.nanos == <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> default != MISSING:<br>        <span class="hljs-keyword">return</span> default<br>    <span class="hljs-keyword">return</span> t.ToDatetime()<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">datetime_to_timestamp</span>(<span class="hljs-params">d: Optional[datetime.datetime]</span>) -&gt; Timestamp:</span><br>    <span class="hljs-string">&quot;&quot;&quot;replace python datetime.datetime to proto.timestamp&quot;&quot;&quot;</span><br>    t: Timestamp = Timestamp()<br>    <span class="hljs-keyword">if</span> d:<br>        t.FromDatetime(d)<br>    <span class="hljs-keyword">return</span> t<br></code></pre></td></tr></table></figure>
<p>通过封装好的<code>timestamp_to_datetime</code>和<code>datetime_to_timestamp</code>可以方便的在业务逻辑中对<code>gRPC</code>和<code>Python</code>对象进行转换，更多类型转换见<a target="_blank" rel="noopener" href="https://github.com/so1n/grpc-example-common/blob/part-1/grpc_example_common/helper/field.py">grpc_example_common/helper/field.py</a>，不过这种转换的实现是非常简单的，性能也不是很好，如果为了追求性能，可以尝试使用<a target="_blank" rel="noopener" href="https://github.com/eigenein/protobuf">pure-protobuf</a>，它会带来一点复杂性，但是使用感受会非常好，性能也非常棒。</p>
<p>业务代码编写完后，需要绑定到对应的<code>Server</code>上面才能正常的提供服务，于是我们需要像创建<code>Flask Server</code>一样，先创建一个服务，然后把路由注册进去，对于<code>gRPC</code>的实现代码如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> logging<br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">from</span> concurrent <span class="hljs-keyword">import</span> futures<br><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> List, Optional<br><br><span class="hljs-keyword">import</span> grpc<br><span class="hljs-keyword">from</span> grpc_example_common.interceptor.server_interceptor.base <span class="hljs-keyword">import</span> BaseInterceptor<br><span class="hljs-keyword">from</span> grpc_example_common.interceptor.server_interceptor.customer_top <span class="hljs-keyword">import</span> CustomerTopInterceptor<br><br><span class="hljs-keyword">from</span> user_grpc_service.handler.user <span class="hljs-keyword">import</span> UserService, user_service<br><br>logging.basicConfig(<br>    <span class="hljs-built_in">format</span>=<span class="hljs-string">&quot;[%(asctime)s %(levelname)s] %(message)s&quot;</span>,<br>    datefmt=<span class="hljs-string">&quot;%y-%m-%d %H:%M:%S&quot;</span>,<br>    level=logging.DEBUG,<br>)<br>logger: logging.Logger = logging.getLogger()<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>(<span class="hljs-params">host: <span class="hljs-built_in">str</span> = <span class="hljs-string">&quot;127.0.0.1&quot;</span>, port: <span class="hljs-built_in">str</span> = <span class="hljs-string">&quot;9000&quot;</span>, ssl_port: Optional[<span class="hljs-built_in">str</span>] = <span class="hljs-literal">None</span></span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>    <span class="hljs-comment"># 拦截器列表</span><br>    interceptor_list: List[BaseInterceptor] = [CustomerTopInterceptor()]<br>    <span class="hljs-comment"># 创建一个gRPC服务</span><br>    server: grpc.server = grpc.server(<br>        futures.ThreadPoolExecutor(max_workers=<span class="hljs-number">10</span>),<br>        interceptors=interceptor_list,<br>    )<br>    <span class="hljs-comment"># 绑定我们的业务实现到服务上</span><br>    user_service.add_UserServicer_to_server(UserService(), server)<br><br>    <span class="hljs-keyword">if</span> ssl_port:<br>        <span class="hljs-comment"># 如果是启用了ssl,则读取文件，然后建立一个安全的连接</span><br>        port = ssl_port<br>        <span class="hljs-comment"># read in key and certificate</span><br>        <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(os.path.join(os.path.split(__file__)[<span class="hljs-number">0</span>], <span class="hljs-string">&quot;server.key&quot;</span>)) <span class="hljs-keyword">as</span> f:<br>            private_key = f.read().encode()<br>        <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(os.path.join(os.path.split(__file__)[<span class="hljs-number">0</span>], <span class="hljs-string">&quot;server.crt&quot;</span>)) <span class="hljs-keyword">as</span> f:<br>            certificate_chain = f.read().encode()<br>        <span class="hljs-comment"># create server credentials</span><br>        server_creds = grpc.ssl_server_credentials(<br>            (<br>                (<br>                    private_key,<br>                    certificate_chain,<br>                ),<br>            )<br>        )<br>        server.add_secure_port(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;host&#125;</span>:<span class="hljs-subst">&#123;port&#125;</span>&quot;</span>, server_creds)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-comment"># 否则建立一个普通的连接</span><br>        server.add_insecure_port(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;host&#125;</span>:<span class="hljs-subst">&#123;port&#125;</span>&quot;</span>)<br>    <span class="hljs-comment"># 启动服务</span><br>    server.start()<br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-comment"># 打印我们挂载了多少个子服务(也就是上面注册的服务)</span><br>        <span class="hljs-keyword">for</span> generic_handler <span class="hljs-keyword">in</span> server._state.generic_handlers:<br>            logger.info(<br>                <span class="hljs-string">f&quot;add service name:<span class="hljs-subst">&#123;generic_handler.service_name()&#125;</span> cnt:<span class="hljs-subst">&#123;<span class="hljs-built_in">len</span>(generic_handler._method_handlers)&#125;</span>&quot;</span><br>            )<br>        logger.info(<span class="hljs-string">f&quot;server run in <span class="hljs-subst">&#123;host&#125;</span>:<span class="hljs-subst">&#123;port&#125;</span>&quot;</span>)<br>        <span class="hljs-comment"># 一直运行，直到被关闭</span><br>        server.wait_for_termination()<br>    <span class="hljs-keyword">except</span> KeyboardInterrupt:<br>        <span class="hljs-comment"># 收到退出的信号，关闭服务</span><br>        server.stop(<span class="hljs-number">0</span>)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    main()<br></code></pre></td></tr></table></figure>
<p>可以看到这段代码非常简单， 但是他肩负了很多请求和连接的健康维护，会在后续的章节中详细介绍。</p>
<h2 id="3-测试编写的gRPC服务"><a href="#3-测试编写的gRPC服务" class="headerlink" title="3.测试编写的gRPC服务"></a>3.测试编写的gRPC服务</h2><p>代码编写完成后就应该发起请求，看看这个服务是否能正常运行，但是<code>gRPC</code>服务不像<code>HTTP</code>服务一样可以在浏览器等地方输入一个URL就能发起一个请求，所以为了能验证我们的服务能否正常的运行，我们应该编写一个测试用例。</p>
<p>在官方文档<a target="_blank" rel="noopener" href="https://grpc.github.io/grpc/python/grpc_testing.html">gRPC Testing</a>中介绍了<code>gRPC</code>的测试用例编写方法，但是这个只覆盖到了业务代码，无法覆盖到拦截器，参数调优等逻辑，而我目前使用到了一个名为<code>CustomerTopInterceptor</code>的拦截器，它在发现业务代码有异常的时候会把异常通过<code>meta_data</code>传给客户端，然后客户端进行解析并抛出对应的异常(这种实现可能不是最优雅的，但是符合需求)，如果采用了官方的<code>gRPC Testing</code>，那在测试用例中山无法捕获到对应的异常的，所以只能采取其它的测试方法来编写一个覆盖范围更广的测试用例–<a target="_blank" rel="noopener" href="https://pypi.org/project/pytest-grpc/">pytest-grpc</a>。</p>
<p>首先是安装好<a target="_blank" rel="noopener" href="https://pypi.org/project/pytest-grpc/">pytest-grpc</a>，然后按照标准的测试用例编写习惯，在项目根目录创建一个名为<code>tests</code>的目录，(当然，我也在<code>pyproject.toml</code>指定了<code>pytest</code>的执行目录为<code>tests</code>)，然后在里面编写每个子服务的测试代码，一般来说一个子服务对应一个<code>Python</code>文件，接着在这个文件的最前面编写服务<a target="_blank" rel="noopener" href="https://pypi.org/project/pytest-grpc/">pytest-grpc</a>要求的代码:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> Callable, List<br><br><span class="hljs-keyword">import</span> grpc<br><span class="hljs-keyword">from</span> grpc_example_common.interceptor.client_interceptor.customer_top <span class="hljs-keyword">import</span> (<br>    CustomerTopInterceptor <span class="hljs-keyword">as</span> ClientCustomerTopInterceptor,<br>)<br><span class="hljs-keyword">from</span> grpc_example_common.interceptor.server_interceptor.customer_top <span class="hljs-keyword">import</span> CustomerTopInterceptor<br><span class="hljs-keyword">from</span> grpc_example_common.protos.user <span class="hljs-keyword">import</span> user_pb2, user_pb2_grpc<br><br><span class="hljs-keyword">from</span> user_grpc_service.handler.user <span class="hljs-keyword">import</span> UserService<br><span class="hljs-keyword">from</span> user_grpc_service.helper.conn_proxy <span class="hljs-keyword">import</span> SteadyDBConnection, g_db_pool<br><br><span class="hljs-comment"># 应用的是整个文件的测试用例， 所以都需要写上@pytest.fixture(scope=&quot;module&quot;)</span><br><br><br><span class="hljs-meta">@pytest.fixture(<span class="hljs-params">scope=<span class="hljs-string">&quot;module&quot;</span></span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">grpc_add_to_server</span>() -&gt; Callable:</span><br>    <span class="hljs-comment"># 指定该子服务对应的添加服务接口</span><br>    <span class="hljs-keyword">return</span> user_pb2_grpc.add_UserServicer_to_server<br><br><br><span class="hljs-meta">@pytest.fixture(<span class="hljs-params">scope=<span class="hljs-string">&quot;module&quot;</span></span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">grpc_servicer</span>() -&gt; UserService:</span><br>    <span class="hljs-comment"># 指定我们编写该子服务的类</span><br>    <span class="hljs-keyword">return</span> UserService()<br><br><br><span class="hljs-meta">@pytest.fixture(<span class="hljs-params">scope=<span class="hljs-string">&quot;module&quot;</span></span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">grpc_interceptors</span>() -&gt; List[grpc.ServerInterceptor]:</span><br>    <span class="hljs-comment"># 指定服务端对应的拦截器</span><br>    <span class="hljs-keyword">return</span> [CustomerTopInterceptor()]<br><br><br><span class="hljs-meta">@pytest.fixture(<span class="hljs-params">scope=<span class="hljs-string">&quot;module&quot;</span></span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">grpc_stub</span>(<span class="hljs-params">grpc_channel: grpc.Channel</span>) -&gt; user_pb2_grpc.UserStub:</span><br>    <span class="hljs-comment"># 指定子服务对应的客户端</span><br>    <span class="hljs-comment"># 这里会先生成一个channel，该channel用于跟服务端通信，</span><br>    <span class="hljs-comment"># 同时它也有一个与服务端拦截器CustomerTopInterceptor对应的拦截器ClientCustomerTopInterceptor</span><br>    <span class="hljs-comment"># 最后把channel应用到对应的子服务Stub上面</span><br>    channel: grpc.Channel = grpc.intercept_channel(grpc_channel, ClientCustomerTopInterceptor())<br>    <span class="hljs-keyword">return</span> user_pb2_grpc.UserStub(channel)<br></code></pre></td></tr></table></figure>
<p>创建完成后我们就可以继续在该文件编写对应的测试用例代码了，这样在运行的时候都会自动加载上面代码，然后我们可以在每个测试用例都使用上面代码创建的客户端<code>grpc_stub</code>来发起请求进行测试。以创建用户和删除用户两个接口为例子，创建用户接口调用后会在数据库生成一条对应的数据，而删除用户接口会从数据库删除一条对应的数据，如果数据不存在于数据库，则会抛出<code>RuntimeError</code>异常（具体代码逻辑可见<a target="_blank" rel="noopener" href="https://github.com/so1n/grpc-example-user-grpc-service/blob/part-1/user_grpc_service/handler/user.py">user_grpc_service/handler/user.py</a>），他们的测试用例代码如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">from</span> contextlib <span class="hljs-keyword">import</span> contextmanager<br><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> Callable, Generator, List<br><br><span class="hljs-meta">@contextmanager</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">mock_user</span>(<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">    uid: <span class="hljs-built_in">str</span> = <span class="hljs-string">&quot;666666&quot;</span>, </span></span><br><span class="hljs-function"><span class="hljs-params">    user_name: <span class="hljs-built_in">str</span> = <span class="hljs-string">&quot;so1n&quot;</span>, </span></span><br><span class="hljs-function"><span class="hljs-params">    password: <span class="hljs-built_in">str</span> = <span class="hljs-string">&quot;123456&quot;</span></span></span><br><span class="hljs-function"><span class="hljs-params"></span>) -&gt; Generator[<span class="hljs-keyword">None</span>, <span class="hljs-keyword">None</span>, <span class="hljs-keyword">None</span>]:</span><br>    <span class="hljs-string">&quot;&quot;&quot;通过contextmanager可以在对应的代码逻辑创建一个用户，并在结束时自动清除该用户信息&quot;&quot;&quot;</span><br>    conn: SteadyDBConnection = g_db_pool.connection()<br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-keyword">with</span> conn.cursor() <span class="hljs-keyword">as</span> cursor:<br>            cursor.execute(<br>                <span class="hljs-string">&quot;INSERT INTO user (uid, user_name, password) VALUES (%s, %s, %s)&quot;</span>,<br>                (uid, user_name, password),<br>            )<br>            conn.commit()<br>        <span class="hljs-keyword">yield</span><br>    <span class="hljs-keyword">finally</span>:<br>        <span class="hljs-keyword">with</span> conn.cursor() <span class="hljs-keyword">as</span> cursor:<br>            cursor.execute(<span class="hljs-string">&quot;DELETE FROM user WHERE uid=%s&quot;</span>, (uid,))<br>            conn.commit()<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestUser</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_create_user</span>(<span class="hljs-params">self, grpc_stub: user_pb2_grpc.UserStub</span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        <span class="hljs-string">&quot;&quot;&quot;创建用户调用的测试用例&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">try</span>:<br>            request: user_pb2.CreateUserRequest = user_pb2.CreateUserRequest(<br>                uid=<span class="hljs-string">&quot;666666&quot;</span>, user_name=<span class="hljs-string">&quot;so1n&quot;</span>, password=<span class="hljs-string">&quot;123456&quot;</span><br>            )<br>            <span class="hljs-comment"># 通过客户端带有的create_user方法发起请求，他会请求到我们的服务端代码</span><br>            <span class="hljs-comment"># 之后服务端的业务代码会在数据库创建一条对应的用户数据</span><br>            grpc_stub.create_user(request, metadata=[])<br>        <span class="hljs-keyword">finally</span>:<br>            conn: SteadyDBConnection = g_db_pool.connection()<br>            conn.begin()<br>            <span class="hljs-keyword">with</span> conn.cursor() <span class="hljs-keyword">as</span> cursor:<br>                <span class="hljs-comment"># 删除刚才创建的用户数据，返回删除的条目数量</span><br>                ret: <span class="hljs-built_in">int</span> = cursor.execute(<span class="hljs-string">&quot;DELETE FROM user WHERE uid=%s&quot;</span>, (<span class="hljs-string">&quot;666666&quot;</span>,))<br>            conn.commit()<br>            <span class="hljs-comment"># 判断是否成功删除一条用户数据，如果是，则代表刚才创建成功。 </span><br>            <span class="hljs-keyword">assert</span> ret == <span class="hljs-number">1</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_delete_user</span>(<span class="hljs-params">self, grpc_stub: user_pb2_grpc.UserStub</span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        <span class="hljs-string">&quot;&quot;&quot;删除用户调用的测试用例&quot;&quot;&quot;</span><br>        uid: <span class="hljs-built_in">str</span> = <span class="hljs-string">&quot;666666&quot;</span><br>        <span class="hljs-comment"># 创建delete_user对应的请求对象</span><br>        request: user_pb2.DeleteUserRequest = user_pb2.DeleteUserRequest(uid=uid)<br>        <span class="hljs-comment"># user not found</span><br>        <span class="hljs-keyword">with</span> pytest.raises(RuntimeError):<br>            <span class="hljs-comment"># 当前数据库没有对应的用户数据，会抛出RuntimeError异常，如果pytest能够捕获到这个异常，则证明拦截器生效了。</span><br>            grpc_stub.delete_user(request, metadata=[])<br>        <span class="hljs-keyword">with</span> mock_user(uid=uid):<br>            <span class="hljs-comment"># 在数据库存在对应的用户数据下，能正常删除数据，并不抛错</span><br>            grpc_stub.delete_user(request, metadata=[])<br></code></pre></td></tr></table></figure>
<p>运行测试用例可以发现测试通过了，接下来就可以编写我们的API服务，在API服务中调用我们的gRPC服务。</p>
<h2 id="4-编写API服务"><a href="#4-编写API服务" class="headerlink" title="4.编写API服务"></a>4.编写API服务</h2><p><code>gRPC</code>服务搭建完毕后，终于可以来编写API服务了，有了API服务后，才能把功能提供给了用户，API服务的项目结构如下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs bash">├── app_service                   <span class="hljs-comment"># API接口的服务，包括路由和调用封装</span><br>│   ├── social_book_route.py<br>│   ├── manager_book_route.py<br>│   ├── utils.py<br>│   ├── route.py<br>│   ├── user_route.py<br>│   └── __init__.py<br>├── grpc_service                  <span class="hljs-comment"># 调用gRPC的服务</span><br>│   ├── __init__.py<br>│   ├── user_service.py<br>│   └── book_service.py<br>├── tests                         <span class="hljs-comment"># 测试用例</span><br>│   ├── test_route<br>│   ├── __init__.py<br>│   └── conftest.py<br>├── app.py                        <span class="hljs-comment"># app代码</span><br>├── gunicorn.conf.py              <span class="hljs-comment"># gunicorn的配置文件</span><br>├── pyproject.toml<br>├── README.md<br>└── mypy.ini<br></code></pre></td></tr></table></figure>

<p>API服务与<code>gRPC</code>服务一样，通过<code>pyproject.toml</code>的配置:</p>
<figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs toml"><span class="hljs-section">[tool.poetry.dependencies]</span><br><span class="hljs-attr">python</span> = <span class="hljs-string">&quot;^3.8&quot;</span><br><span class="hljs-attr">grpc_example_common</span> = &#123; git = <span class="hljs-string">&quot;git@github.com:so1n/grpc-example-common.git&quot;</span>, tag=<span class="hljs-string">&quot;v0.1.4&quot;</span> &#125;<br><span class="hljs-attr">Flask</span> = <span class="hljs-string">&quot;^2.0.3&quot;</span><br></code></pre></td></tr></table></figure>
<p>引用了<code>grpc_example_common</code>的库， 然后在<code>grpc_service</code>中用到了该库，还是以用户服务为例子，用户服务的代码位于项目的<code>grpc_service.user_service.py</code>中，这个代码首先是创建一个<code>Mixin</code>的类：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserGrpcServiceMixin</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, channel: grpc.Channel</span>):</span><br>        self.user_stub: user_service.UserStub = user_service.UserStub(channel)<br>        <span class="hljs-comment"># 通过grpc_wrapper.grpc_client_func_wrapper为所有的请求带上matedate参数</span><br>        grpc_wrapper.auto_load_wrapper_by_stub(self.user_stub, grpc_wrapper.grpc_client_func_wrapper)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">create_user</span>(<span class="hljs-params">self, *, uid: <span class="hljs-built_in">str</span>, user_name: <span class="hljs-built_in">str</span>, password: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        self.user_stub.create_user(user_message.CreateUserRequest(uid=uid, user_name=user_name, password=password))<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">delete_user</span>(<span class="hljs-params">self, *, uid: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        self.user_stub.delete_user(user_message.DeleteUserRequest(uid=uid))<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">login_user</span>(<span class="hljs-params">self, *, uid: <span class="hljs-built_in">str</span>, password: <span class="hljs-built_in">str</span></span>) -&gt; user_message.LoginUserResult:</span><br>        <span class="hljs-keyword">return</span> self.user_stub.login_user(user_message.LoginUserRequest(uid=uid, password=password))<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">logout_user</span>(<span class="hljs-params">self, *, uid: <span class="hljs-built_in">str</span>, token: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        self.user_stub.logout_user(user_message.LogoutUserRequest(uid=uid, token=token))<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_uid_by_token</span>(<span class="hljs-params">self, *, token: <span class="hljs-built_in">str</span></span>) -&gt; str:</span><br>        result: user_message.GetUidByTokenResult = self.user_stub.get_uid_by_token(<br>            user_message.GetUidByTokenRequest(token=token)<br>        )<br>        <span class="hljs-keyword">return</span> result.uid<br></code></pre></td></tr></table></figure>
<p>这个类就是对<code>user_service.UserStub</code>的简单封装，可以看到方法名和参数与Protobuf保持一致，它只是接受一个负责通信的channel，然后传入到<code>user_stub</code>中，方便后续的方法对<code>user_stub</code>调用，同时这个类还负责一些数据的转换，如上面提到的<code>Protobuf</code>的<code>Timestamps</code>对象转为<code>Python</code>的<code>datetime</code>对象。</p>
<p>接着创建一个负责子服务管理的<code>UserGrpcSerevice</code>类，这个类负责建立通信和维护通信段稳定：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserGrpcService</span>(<span class="hljs-params">UserGrpcServiceMixin</span>):</span><br>    <span class="hljs-comment"># 如果有多个，则在这里继承多个mixin</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, host: <span class="hljs-built_in">str</span>, port: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        <span class="hljs-comment"># 初始化与服务端的通信</span><br>        self.channel: grpc.Channel = grpc.intercept_channel(<br>            grpc.insecure_channel(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;host&#125;</span>:<span class="hljs-subst">&#123;port&#125;</span>&quot;</span>), CustomerTopInterceptor()<br>        )<br>        <span class="hljs-comment"># 传入到对应的服务里</span><br>        UserGrpcServiceMixin.__init__(self, self.channel)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">channel_ready_future</span>(<span class="hljs-params">self, timeout: <span class="hljs-built_in">int</span> = <span class="hljs-number">10</span></span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        <span class="hljs-comment"># 用于检查是否与服务端建立起连接</span><br>        target: <span class="hljs-built_in">str</span> = (<br>            <span class="hljs-string">f&quot;<span class="hljs-subst">&#123;self.__class__.__name__&#125;</span>&quot;</span><br>            <span class="hljs-string">f&quot; <span class="hljs-subst">&#123;self.channel._channel._connectivity_state.channel.target().decode()&#125;</span>&quot;</span>  <span class="hljs-comment"># type: ignore</span><br>        )  <span class="hljs-comment"># type: ignore</span><br>        <span class="hljs-keyword">try</span>:<br>            grpc.channel_ready_future(self.channel).result(timeout=timeout)<br>        <span class="hljs-keyword">except</span> grpc.FutureTimeoutError:<br>            logger.exception(<span class="hljs-string">f&quot;channel:<span class="hljs-subst">&#123;target&#125;</span> connect timeout&quot;</span>)<br>            <span class="hljs-keyword">raise</span> RuntimeError(<span class="hljs-string">f&quot;channel:<span class="hljs-subst">&#123;target&#125;</span> connect timeout&quot;</span>)<br>        <span class="hljs-keyword">else</span>:<br>            logger.info(<span class="hljs-string">f&quot;channel:<span class="hljs-subst">&#123;target&#125;</span> connect success&quot;</span>)<br></code></pre></td></tr></table></figure>
<p>创建完毕后对于gRPC客户端调用服务端的逻辑已经封装完成了，接下来就是在路由函数中进行使用了，一般情况下都是使用单例的模式创建一个<code>UserGrpcService</code>的实例，但是我不太喜欢这样做，于是创建了一个中间件，然后通过<code>flask.g</code>传递创建app时初始化的<code>gRPC</code>服务示例，对应的中间件处理代码如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> Any, Union<br><br><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Blueprint, Flask, Response<br><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> g <span class="hljs-keyword">as</span> flask_g<br><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> jsonify, request<br><br><span class="hljs-keyword">from</span> grpc_service.book_service <span class="hljs-keyword">import</span> BookGrpcService<br><span class="hljs-keyword">from</span> grpc_service.user_service <span class="hljs-keyword">import</span> UserGrpcService<br><br>APP_TYPE = Union[Blueprint, Flask]<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomerGType</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;基于flasg.g的封装，这样就可以无忧的使用IDE的提示和重构功能了&quot;&quot;&quot;</span><br>    book_grpc_service: BookGrpcService<br>    user_grpc_service: UserGrpcService<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__getattr__</span>(<span class="hljs-params">self, key: <span class="hljs-built_in">str</span></span>) -&gt; Any:</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">getattr</span>(flask_g, key)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__setattr__</span>(<span class="hljs-params">self, key: <span class="hljs-built_in">str</span>, value: Any</span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        <span class="hljs-built_in">setattr</span>(flask_g, key, value)<br><br><br>g: CustomerGType = CustomerGType()<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ContextMiddleware</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;基于flask的before_request和after_request钩子创建的一个中间件类&quot;&quot;&quot;</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">        self, *, app: APP_TYPE, book_grpc_service: BookGrpcService, user_grpc_service: UserGrpcService</span></span><br><span class="hljs-function"><span class="hljs-params">    </span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        self._app = app<br>        self._app.before_request(self._before_requests)<br>        self._app.after_request(self._after_requests)<br><br>        self._book_grpc_service: BookGrpcService = book_grpc_service<br>        self._user_grpc_service: UserGrpcService = user_grpc_service<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_before_requests</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        <span class="hljs-comment"># 收到请求点时候把gRPC服务传到指定的变量中</span><br>        g.book_grpc_service = self._book_grpc_service<br>        g.user_grpc_service = self._user_grpc_service<br>        <span class="hljs-keyword">return</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_after_requests</span>(<span class="hljs-params">self, response: Response</span>) -&gt; Response:</span><br>        <span class="hljs-keyword">return</span> response<br></code></pre></td></tr></table></figure>
<p>中间件创建完成后，就可以在<code>create_app</code>工厂函数中创建对应的<code>gRPC</code>服务，然后赋值到对应的中间件中:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">from</span> flask.app <span class="hljs-keyword">import</span> Flask<br><br><span class="hljs-keyword">from</span> app_service.route <span class="hljs-keyword">import</span> manager_book_bp, social_book_bp, user_bp<br><span class="hljs-keyword">from</span> app_service.utils <span class="hljs-keyword">import</span> ContextMiddleware, api_exception<br><span class="hljs-keyword">from</span> grpc_service.book_service <span class="hljs-keyword">import</span> BookGrpcService<br><span class="hljs-keyword">from</span> grpc_service.user_service <span class="hljs-keyword">import</span> UserGrpcService<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">create_app</span>() -&gt; Flask:</span><br>    app: Flask = Flask(__name__)<br>    <span class="hljs-comment"># 注册对应的路由</span><br>    app.register_blueprint(manager_book_bp)<br>    app.register_blueprint(social_book_bp)<br>    app.register_blueprint(user_bp)<br><br>    <span class="hljs-comment"># 初始化对应的gRPC服务，并等待建立连接</span><br>    book_grpc_service: BookGrpcService = BookGrpcService(<span class="hljs-string">&quot;0.0.0.0&quot;</span>, <span class="hljs-number">9000</span>)<br>    book_grpc_service.channel_ready_future(timeout=<span class="hljs-number">3</span>)<br>    user_grpc_service: UserGrpcService = UserGrpcService(<span class="hljs-string">&quot;0.0.0.0&quot;</span>, <span class="hljs-number">9001</span>)<br>    user_grpc_service.channel_ready_future(timeout=<span class="hljs-number">3</span>)<br>    <span class="hljs-comment"># 把gRPC服务注入到中间件中</span><br>    ContextMiddleware(app=app, book_grpc_service=book_grpc_service, user_grpc_service=user_grpc_service)<br><br>    app.errorhandler(Exception)(api_exception)<br>    <span class="hljs-keyword">return</span> app<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    create_app().run(<span class="hljs-string">&quot;localhost&quot;</span>, port=<span class="hljs-number">8000</span>)<br><br></code></pre></td></tr></table></figure>
<p>最后，就可以在路由函数中使用对应的<code>gRPC</code>服务了，还是以创建用户和删除用户为例子:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Response, request<br><span class="hljs-keyword">from</span> grpc_example_common.protos.user <span class="hljs-keyword">import</span> user_pb2 <span class="hljs-keyword">as</span> user_message<br><br><span class="hljs-keyword">from</span> app_service.utils <span class="hljs-keyword">import</span> g, get_uid_by_token, make_response<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">create_user</span>() -&gt; Response:</span><br>    request_dict: <span class="hljs-built_in">dict</span> = request.json()<br>    g.user_grpc_service.create_user(<br>        uid=request_dict[<span class="hljs-string">&quot;uid&quot;</span>], user_name=request_dict[<span class="hljs-string">&quot;user_name&quot;</span>], password=request_dict[<span class="hljs-string">&quot;password&quot;</span>]<br>    )<br>    <span class="hljs-keyword">return</span> make_response()<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">delete_user</span>() -&gt; Response:</span><br>    request_dict: <span class="hljs-built_in">dict</span> = request.json()<br>    g.user_grpc_service.delete_user(uid=request_dict[<span class="hljs-string">&quot;uid&quot;</span>])<br>    <span class="hljs-keyword">return</span> make_response()<br></code></pre></td></tr></table></figure>
<p>这两个接口都是在收到请求后，再调用<code>gRPC</code>服务对应的方法来传递请求，其它服务调用的代码与创建用户和删除用户的例子相同，具体可以访问<a target="_blank" rel="noopener" href="https://github.com/so1n/grpc-example-api-backend-service/tree/part-1/app_service">app_service</a>了解</p>
<p>需要注意的是，通常我们不会在生产环境直接运行<code>Flask</code>，而是采用<code>gunicorn</code>+<code>gevnet</code>来运行我们的API服务，从而增强服务的稳定性和性能，但是<code>gevent</code>是修改<code>Python</code>代码来达到全局代码都不阻塞的，而<code>gRPC</code>本身的调用是包含C代码，<code>gevent</code>无法修改到<code>gRPC</code>调用到的C代码，所以<code>gRPC</code>提供一个名为<code>grpc.experimental.gevent.init_gevent</code>的方法来解决这个问题，如下代码:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> socket<br><br><span class="hljs-keyword">try</span>:<br>    <span class="hljs-keyword">import</span> gevent<br><span class="hljs-keyword">except</span> ImportError:<br>    <span class="hljs-keyword">pass</span><br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-keyword">if</span> socket.socket <span class="hljs-keyword">is</span> gevent.socket.socket:<br>        <span class="hljs-keyword">import</span> grpc.experimental.gevent<br><br>        grpc.experimental.gevent.init_gevent()<br></code></pre></td></tr></table></figure>
<p>这段代码在初始化时可以通过判断是否启用<code>gevnet</code>来启用<code>grpc.experimental.gevent.init_gevent</code>，通常建议放在gunicorn的配置文件里，具体见<a target="_blank" rel="noopener" href="https://github.com/so1n/grpc-example-api-backend-service/blob/part-1/gunicorn.conf.py">gunicorn.conf.py</a></p>
<p>至此，一个API服务就搭建完毕，可以直接运行后在浏览器进行测试。</p>
<h2 id="5-测试编写的API服务"><a href="#5-测试编写的API服务" class="headerlink" title="5.测试编写的API服务"></a>5.测试编写的API服务</h2><p>截止到目前，对于包含gRPC的API服务接口测试没有一个比较好的方法，因为单例测试是不考虑别的服务的，意味着需要对gRPC调用段响应进行Mock，然而用于调用段<code>Stub</code>类只有属性而没有方法，这样会导致mock不成功，所以需要先创建一个gRPC Stub的函数签名，以<code>UserStub</code>为例子，将会创建一个类似于gRPC UserStub的类：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> Any<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserStub</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, channel: Any</span>):</span><br>        <span class="hljs-keyword">pass</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_uid_by_token</span>(<span class="hljs-params">self, *args: Any, **kwargs: Any</span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        <span class="hljs-keyword">pass</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">logout_user</span>(<span class="hljs-params">self, *args: Any, **kwargs: Any</span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        <span class="hljs-keyword">pass</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">login_user</span>(<span class="hljs-params">self, *args: Any, **kwargs: Any</span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        <span class="hljs-keyword">pass</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">create_user</span>(<span class="hljs-params">self, *args: Any, **kwargs: Any</span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        <span class="hljs-keyword">pass</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">delete_user</span>(<span class="hljs-params">self, *args: Any, **kwargs: Any</span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>其它的见:<a target="_blank" rel="noopener" href="https://github.com/so1n/grpc-example-api-backend-service/blob/part-1/tests/grpc_abc_stub.py">tests/grpc_abc_stub.py</a></p>
</blockquote>
<p>然后在<a target="_blank" rel="noopener" href="https://github.com/so1n/grpc-example-api-backend-service/blob/part-1/tests/conftest.py">tests/conftest.py</a>编写一个全局的初始化，该初始化会把gRPC的检查连接方法屏蔽以及把对应的Stub类进行替换：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> pytest<br><span class="hljs-keyword">from</span> grpc <span class="hljs-keyword">import</span> _utilities<br><span class="hljs-keyword">from</span> grpc_example_common.protos.book <span class="hljs-keyword">import</span> manager_pb2_grpc, social_pb2_grpc<br><span class="hljs-keyword">from</span> grpc_example_common.protos.user <span class="hljs-keyword">import</span> user_pb2_grpc<br><br><span class="hljs-keyword">from</span> tests.grpc_abc_stub <span class="hljs-keyword">import</span> BookManagerStub, BookSocialStub, UserStub<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">result</span>(<span class="hljs-params">self: Any, timeout: Any = <span class="hljs-literal">None</span></span>) -&gt; Any:</span><br>    <span class="hljs-keyword">pass</span><br><br><br><span class="hljs-comment"># Blocking the start check of grpc service</span><br>_utilities._ChannelReadyFuture.result = result<br><br>user_pb2_grpc.UserStub = UserStub<br>user_pb2_grpc.UserStub = UserStub<br>social_pb2_grpc.BookSocialStub = BookSocialStub<br>manager_pb2_grpc.BookManagerStub = BookManagerStub<br></code></pre></td></tr></table></figure>
<p>这样就为测试用例初始化完成了， 但是我为每个Stub包装了一个功能，使他们永远会传递<code>metadata</code>变量：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserGrpcServiceMixin</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, channel: grpc.Channel</span>):</span><br>        self.user_stub: user_service.UserStub = user_service.UserStub(channel)<br>        grpc_wrapper.auto_load_wrapper_by_stub(self.user_stub, grpc_wrapper.grpc_client_func_wrapper)<br></code></pre></td></tr></table></figure>
<p>该方法会初始化一定要放在mock之后，否则mock无效，这意味着初始化<code>Flask.TestClient</code>的逻辑必须在测试代码里，于是先创建一个类似于<code>pytest.fixture</code>的初始化<code>Flask.TestClient</code>函数:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-meta">@contextmanager</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">customer_app</span>() -&gt; Generator[FlaskClient, <span class="hljs-keyword">None</span>, <span class="hljs-keyword">None</span>]:</span><br>    flask_app: Flask = create_app()<br>    <span class="hljs-comment"># Flask provides a way to test your application by exposing the Werkzeug test Client</span><br>    <span class="hljs-comment"># and handling the context locals for you.</span><br>    client: FlaskClient = flask_app.test_client()<br>    <span class="hljs-comment"># Establish an application context before running the tests.</span><br>    ctx: AppContext = flask_app.app_context()<br>    ctx.push()<br>    <span class="hljs-keyword">yield</span> client  <span class="hljs-comment"># this is where the testing happens!</span><br>    ctx.pop()<br></code></pre></td></tr></table></figure>
<p>为了偷懒，我把他放到了<code>conftest</code>文件。</p>
<blockquote>
<p>如果没有包装过stub的方法，则可以不用采用该步骤</p>
</blockquote>
<p>现在，所有初始化都编写完毕了，可以编写测试用例，以用户调用路由为例子(说明见注释):</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">from</span> google.protobuf.empty_pb2 <span class="hljs-keyword">import</span> Empty  <span class="hljs-comment"># type: ignore</span><br><span class="hljs-keyword">from</span> grpc_example_common.protos.user <span class="hljs-keyword">import</span> user_pb2 <span class="hljs-keyword">as</span> user_message<br><span class="hljs-keyword">from</span> pytest_mock <span class="hljs-keyword">import</span> MockFixture<br><span class="hljs-keyword">from</span> werkzeug.test <span class="hljs-keyword">import</span> TestResponse<br><br><span class="hljs-keyword">from</span> tests.conftest <span class="hljs-keyword">import</span> customer_app<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestUser</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_create_user</span>(<span class="hljs-params">self, mocker: MockFixture</span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        <span class="hljs-comment"># 该接口会调用到UserStub.create_user，我们把他mock掉，返回的是Empty</span><br>        mocker.patch(<span class="hljs-string">&quot;grpc_example_common.protos.user.user_pb2_grpc.UserStub.create_user&quot;</span>).return_value = Empty()<br>        <span class="hljs-keyword">with</span> customer_app() <span class="hljs-keyword">as</span> client:<br>            resp: TestResponse = client.post(<br>                <span class="hljs-string">&quot;/api/user/create&quot;</span>, json=&#123;<span class="hljs-string">&quot;uid&quot;</span>: <span class="hljs-string">&quot;123&quot;</span>, <span class="hljs-string">&quot;user_name&quot;</span>: <span class="hljs-string">&quot;so1n&quot;</span>, <span class="hljs-string">&quot;password&quot;</span>: <span class="hljs-string">&quot;aha&quot;</span>&#125;<br>            )<br>            <span class="hljs-keyword">assert</span> resp.json[<span class="hljs-string">&quot;code&quot;</span>] == <span class="hljs-number">0</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_delete_user</span>(<span class="hljs-params">self, mocker: MockFixture</span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        <span class="hljs-comment"># 该接口会调用到UserStub.delete_user，我们把他mock掉，返回的是Empty</span><br>        mocker.patch(<span class="hljs-string">&quot;grpc_example_common.protos.user.user_pb2_grpc.UserStub.delete_user&quot;</span>).return_value = Empty()<br>        <span class="hljs-keyword">with</span> customer_app() <span class="hljs-keyword">as</span> client:<br>            resp: TestResponse = client.post(<span class="hljs-string">&quot;/api/user/delete&quot;</span>, json=&#123;<span class="hljs-string">&quot;uid&quot;</span>: <span class="hljs-string">&quot;123&quot;</span>&#125;)<br>            <span class="hljs-keyword">assert</span> resp.json[<span class="hljs-string">&quot;code&quot;</span>] == <span class="hljs-number">0</span><br>        <span class="hljs-comment"># User.Stub.delete_user还有一个会抛错的方法,我们通过mock满足这个条件</span><br>        mocker.patch(<span class="hljs-string">&quot;grpc_example_common.protos.user.user_pb2_grpc.UserStub.delete_user&quot;</span>).side_effect = RuntimeError(<br>            <span class="hljs-string">&quot;test error&quot;</span><br>        )<br>        <span class="hljs-keyword">with</span> customer_app() <span class="hljs-keyword">as</span> client:<br>            resp = client.post(<span class="hljs-string">&quot;/api/user/delete&quot;</span>, json=&#123;<span class="hljs-string">&quot;uid&quot;</span>: <span class="hljs-string">&quot;123&quot;</span>&#125;)<br>            <span class="hljs-keyword">assert</span> resp.json[<span class="hljs-string">&quot;data&quot;</span>] == <span class="hljs-string">&quot;test error&quot;</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_login_user</span>(<span class="hljs-params">self, mocker: MockFixture</span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        <span class="hljs-comment"># 通过mock指定具体的返回数据，返回的数据类型一定要跟Protobuf生成的代码一致</span><br>        mocker.patch(<br>            <span class="hljs-string">&quot;grpc_example_common.protos.user.user_pb2_grpc.UserStub.login_user&quot;</span><br>        ).return_value = user_message.LoginUserResult(uid=<span class="hljs-string">&quot;123&quot;</span>, token=<span class="hljs-string">&quot;66666&quot;</span>)<br>        <span class="hljs-keyword">with</span> customer_app() <span class="hljs-keyword">as</span> client:<br>            resp: TestResponse = client.post(<span class="hljs-string">&quot;/api/user/login&quot;</span>, json=&#123;<span class="hljs-string">&quot;uid&quot;</span>: <span class="hljs-string">&quot;123&quot;</span>, <span class="hljs-string">&quot;password&quot;</span>: <span class="hljs-string">&quot;pw&quot;</span>&#125;)<br>            <span class="hljs-keyword">assert</span> resp.json[<span class="hljs-string">&quot;data&quot;</span>] == &#123;<span class="hljs-string">&quot;uid&quot;</span>: <span class="hljs-string">&quot;123&quot;</span>, <span class="hljs-string">&quot;token&quot;</span>: <span class="hljs-string">&quot;66666&quot;</span>&#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_logout</span>(<span class="hljs-params">self, mocker: MockFixture</span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        mocker.patch(<span class="hljs-string">&quot;grpc_example_common.protos.user.user_pb2_grpc.UserStub.logout_user&quot;</span>).return_value = Empty()<br>        mocker.patch(<br>            <span class="hljs-string">&quot;grpc_example_common.protos.user.user_pb2_grpc.UserStub.get_uid_by_token&quot;</span><br>        ).return_value = user_message.GetUidByTokenResult(uid=<span class="hljs-string">&quot;123&quot;</span>)<br>        <span class="hljs-keyword">with</span> customer_app() <span class="hljs-keyword">as</span> client:<br>            resp: TestResponse = client.post(<span class="hljs-string">&quot;/api/user/logout&quot;</span>, json=&#123;<span class="hljs-string">&quot;uid&quot;</span>: <span class="hljs-string">&quot;123&quot;</span>&#125;, headers=&#123;<span class="hljs-string">&quot;token&quot;</span>: <span class="hljs-string">&quot;666666&quot;</span>&#125;)<br>            <span class="hljs-keyword">assert</span> resp.json[<span class="hljs-string">&quot;code&quot;</span>] == <span class="hljs-number">0</span><br><br>        mocker.patch(<br>            <span class="hljs-string">&quot;grpc_example_common.protos.user.user_pb2_grpc.UserStub.get_uid_by_token&quot;</span><br>        ).return_value = user_message.GetUidByTokenResult(uid=<span class="hljs-string">&quot;1234&quot;</span>)<br>        <span class="hljs-keyword">with</span> customer_app() <span class="hljs-keyword">as</span> client:<br>            resp = client.post(<span class="hljs-string">&quot;/api/user/logout&quot;</span>, json=&#123;<span class="hljs-string">&quot;uid&quot;</span>: <span class="hljs-string">&quot;123&quot;</span>&#125;, headers=&#123;<span class="hljs-string">&quot;token&quot;</span>: <span class="hljs-string">&quot;666666&quot;</span>&#125;)<br>            <span class="hljs-keyword">assert</span> resp.json[<span class="hljs-string">&quot;data&quot;</span>] == <span class="hljs-string">&quot;Uid ERROR&quot;</span><br></code></pre></td></tr></table></figure>
<p>至此，已经实现了一个可以简单使用的gRPC服务，可以在电脑上起不同的进程并观察他们的调用情况，但是这只是一个开始，随着服务的扩大，服务间的维护和调优会变得十分麻烦，要想服务能够健壮的运行，我们需要继续深入。</p>
      </section>
      <section class="extra">
        
          <ul class="copyright">
  
    <li><strong>本文作者：</strong>So1n</li>
    <li><strong>本文链接：</strong><a href="http://so1n.me/2022/04/07/Python-gRPC%E5%AE%9E%E8%B7%B5(3)--%E4%BD%BF%E7%94%A8Python%E5%AE%9E%E7%8E%B0gRPC%E6%9C%8D%E5%8A%A1/index.html" title="http:&#x2F;&#x2F;so1n.me&#x2F;2022&#x2F;04&#x2F;07&#x2F;Python-gRPC%E5%AE%9E%E8%B7%B5(3)--%E4%BD%BF%E7%94%A8Python%E5%AE%9E%E7%8E%B0gRPC%E6%9C%8D%E5%8A%A1&#x2F;index.html">http:&#x2F;&#x2F;so1n.me&#x2F;2022&#x2F;04&#x2F;07&#x2F;Python-gRPC%E5%AE%9E%E8%B7%B5(3)--%E4%BD%BF%E7%94%A8Python%E5%AE%9E%E7%8E%B0gRPC%E6%9C%8D%E5%8A%A1&#x2F;index.html</a></li>
    <li><strong>版权声明：</strong>本博客所有文章均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" title="BY-NC-SA" target="_blank" rel="noopener">BY-NC-SA</a> 许可协议，转载请注明出处！</li>
  
  <img src="https://raw.githubusercontent.com/so1n/so1n_blog_photo/master/blog_photo/%E6%89%AB%E7%A0%81_%E6%90%9C%E7%B4%A2%E8%81%94%E5%90%88%E4%BC%A0%E6%92%AD%E6%A0%B7%E5%BC%8F-%E6%A0%87%E5%87%86%E8%89%B2%E7%89%88.png" alt="text">

</ul>

        
        
          <section class="donate">
  <div id="qrcode-donate">
    <img src="https://fastly.jsdelivr.net/gh/so1n/so1n_blog_photo@master/blog_photo/16550449287744d2ebf32586d8799ee2e75333d6f5d2.jpg">
  </div>
  <div class="icon">
    <a href="javascript:;" id="alipay"><i class="iconfont iconalipay"></i></a>
    <a href="javascript:;" id="wechat"><i class="iconfont iconwechat-fill"></i></a>
  </div>
</section>
        
        
  <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python/" rel="tag">Python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/gRPC/" rel="tag">gRPC</a></li></ul> 

        
  <nav class="nav">
    <a href="/2022/04/11/python's_waitable_objects_in_asyncio/"><i class="iconfont iconleft"></i>Python的可等待对象在Asyncio的作用</a>
    <a href="/2022/03/11/modify-sql-in-python-runtime/">在Python运行时修改业务代码的SQL<i class="iconfont iconright"></i></a>
  </nav>

      </section>
      
        <section class="comments">
  
    <div class="btn" id="comments-btn">查看评论</div>
  
  
<link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<div id="gitalk" class="gitalk"></div>
<script defer src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
<script>
  window.onload = function () {
    var gitalk = new Gitalk({
      clientID: '59f804e526b05c378470',
      clientSecret: '36679ff697cec424936a0f7c4bcd6d2988dac28e',
      id: window.location.pathname,
      repo: 'so1n.github.io',
      owner: 'so1n',
      admin: 'so1n'
    });
    if ( true ) {
      $("#comments-btn").on("click", function () {
        $(this).hide();
        gitalk.render('gitalk');
      });
    } else {
      gitalk.render('gitalk');
    }
  }
</script>

</section>
      
    </section>
  </div>
</article>
</div>
      <div class="col-xl-3">
          
  <aside class="toc-wrap">
    <h3 class="toc-title">文章目录：</h3>
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%87%86%E5%A4%87"><span class="toc-text">1.初始化准备</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E7%BC%96%E5%86%99gRPC%E6%9C%8D%E5%8A%A1%E9%A1%B9%E7%9B%AE"><span class="toc-text">2.编写gRPC服务项目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%B5%8B%E8%AF%95%E7%BC%96%E5%86%99%E7%9A%84gRPC%E6%9C%8D%E5%8A%A1"><span class="toc-text">3.测试编写的gRPC服务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E7%BC%96%E5%86%99API%E6%9C%8D%E5%8A%A1"><span class="toc-text">4.编写API服务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E6%B5%8B%E8%AF%95%E7%BC%96%E5%86%99%E7%9A%84API%E6%9C%8D%E5%8A%A1"><span class="toc-text">5.测试编写的API服务</span></a></li></ol>
  </aside>

        
          
  <aside class="toc-wrap">
    <h3 class="toc-title">文章目录：</h3>
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%87%86%E5%A4%87"><span class="toc-text">1.初始化准备</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E7%BC%96%E5%86%99gRPC%E6%9C%8D%E5%8A%A1%E9%A1%B9%E7%9B%AE"><span class="toc-text">2.编写gRPC服务项目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%B5%8B%E8%AF%95%E7%BC%96%E5%86%99%E7%9A%84gRPC%E6%9C%8D%E5%8A%A1"><span class="toc-text">3.测试编写的gRPC服务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E7%BC%96%E5%86%99API%E6%9C%8D%E5%8A%A1"><span class="toc-text">4.编写API服务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E6%B5%8B%E8%AF%95%E7%BC%96%E5%86%99%E7%9A%84API%E6%9C%8D%E5%8A%A1"><span class="toc-text">5.测试编写的API服务</span></a></li></ol>
  </aside>

        
      </div>
    </div>
  </div>
</main>

  <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js">
</script>


<footer class="footer">
  <div class="footer-social"><a 
        href="https://github.com/so1n "
        target="_blank"
        class="footer-social-item"
        onMouseOver="this.style.color= '#9f7be1'" 
        onMouseOut="this.style.color='#33333D'">
          <i class="iconfont  icongithub-fill "></i>
      </a></div>
  
    <div class="footer-copyright"><p>Powered by <a target="_blank" href="https://hexo.io">Hexo</a>  |  Theme - <a target="_blank" href="https://github.com/izhaoo/hexo-theme-zhaoo">zhaoo</a>| <a target="_blank" href="/atom.xml">RSS</a> </p></div>
  
  <div class="footer-copyright">
      <a href="/atom.xml">
  </div>
  <div class="footer-copyright">
    总访问量<span id="busuanzi_value_site_pv"></span>次
    访客数<span id="busuanzi_value_site_uv"></span>人次
  </div>

</footer>

  
      <div class="fab fab-plus">
    <i class="iconfont iconplus"></i>
  </div>
  
  
  
  <div class="fab fab-up">
    <i class="iconfont iconcaret-up"></i>
  </div>
  
  
    <div class="scrollbar j-scrollbar">
  <div class="scrollbar-current j-scrollbar-current"></div>
</div>
  
  
    
<script src="/js/color-mode.js"></script>

  
  
    <div class="search">
  <div class="search-container">
    <div class="search-close">
      <i class="iconfont iconbaseline-close-px"></i>
    </div>
    <div class="search-input-wrapper">
      <i class="search-input-icon iconfont iconsearch"></i>
      <input class="search-input" type="search" id="search-input" placeholder="Search..." autofocus autocomplete="off"
        autocorrect="off" autocapitalize="off">
    </div>
    <div class="search-output" id="search-output"></div>
  </div>
</div>
  
</body>

<script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>





  
<script src="https://cdn.bootcdn.net/ajax/libs/jquery.lazyload/1.9.1/jquery.lazyload.min.js"></script>




  
<script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js"></script>






  
<script src="https://cdn.bootcdn.net/ajax/libs/jquery.qrcode/1.0/jquery.qrcode.min.js"></script>




<script src="/js/utils.js"></script>
<script src="/js/script.js"></script>







  <script>
    (function () {
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
      } else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>












</html>
