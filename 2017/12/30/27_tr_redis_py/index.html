

<!DOCTYPE html>
<html lang="zh-Hans" color-mode=light>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>redis-py - So1n blog</title>
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="google" content="notranslate" />
  
  <meta name="description" content="前记之前自己渣渣翻译的redi-py文档,redis-...">
  <meta name="author" content="So1n">
  <link rel="icon" href="/images/icons/favicon.ico" type="image/png" sizes="16x16">
  <link rel="icon" href="/images/icons/favicon.ico" type="image/png" sizes="32x32">
  <link rel="apple-touch-icon" href="/images/icons/favicon.ico" sizes="180x180">
  <meta rel="mask-icon" href="/images/icons/stun-logo.svg" color="#333333">
  
    <meta rel="msapplication-TileImage" content="/images/icons/favicon.ico">
    <meta rel="msapplication-TileColor" content="#000000">
  

  
<link rel="stylesheet" href="/css/style.css">


  
    
<link rel="stylesheet" href="//at.alicdn.com/t/font_1445822_s6x2xcokxrl.css">

  

  
    
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css">

  

  
    
      
        
        
<link rel="stylesheet" href="https://cdn.bootcss.com/highlight.js/9.18.1/styles/atom-one-dark-reasonable.min.css" name="highlight-style" mode="light">

      
        
        
<link rel="stylesheet" href="https://cdn.bootcss.com/highlight.js/9.18.1/styles/atom-one-dark-reasonable.min.css" name="highlight-style" mode="dark">

      
  

  <script>
    var CONFIG = window.CONFIG || {};
    var ZHAOO = window.ZHAOO || {};
    CONFIG = {
      isHome: false,
      fancybox: true,
      pjax: false,
      lazyload: {
        enable: true,
        only_post: 'false',
        loading: '/images/theme/loading.gif'
      },
      donate: {
        enable: true,
        alipay: 'https://github.com/so1n/so1n_blog_photo/blob/master/blog_photo/4d2ebf32586d8799ee2e75333d6f5d2.jpg?raw=true',
        wechat: ''
      },
      galleries: {
        enable: true
      },
      fab: {
        enable: true,
        always_show: true
      },
      carrier: {
        enable: false
      },
      daovoice: {
        enable: false
      },
      preview: {
        background: {
          default: '/images/theme/welcome-image.jpg',
          api: 'https://source.unsplash.com/random/1920x1080'
        },
        motto: {
          default: '我们总说社会是个大染缸 其实是我们自己掉色',
          api: '',
          data_contents: '["data","content"]'
        },
      },
      qrcode: {
        enable: true,
        type: 'url',
        image: 'https://pic.izhaoo.com/weapp-code.jpg',
      },
      toc: {
        enable: true
      },
      scrollbar: {
        type: 'simple'
      },
      notification: {
        enable: false,
        delay: 4500,
        list: '',
        page_white_list: '',
        page_black_list: ''
      }
    }
  </script>

  

  

<meta name="generator" content="Hexo 5.3.0"></head>

<body class="lock-screen">
  <div class="loading"></div>
  


  <nav class="navbar">
    <div class="left">
      
        <i class="iconfont iconqrcode j-navbar-qrcode"></i>
      
      
        <i class="iconfont iconmoono" id="color-toggle" color-toggle="light"></i>
      
    </div>
    <div class="center">redis-py</div>
    <div class="right">
      <i class="iconfont iconmenu j-navbar-menu"></i>
    </div>
    
      <div id="qrcode-navbar"></div>
    
  </nav>

  

<nav class="menu">
  <div class="menu-wrap">
    <div class="menu-close">
      <i class="iconfont iconbaseline-close-px"></i>
    </div>
    <ul class="menu-content"><li class="menu-item">
        <a href="/ " class="underline "> 首页</a>
      </li><li class="menu-item">
        <a href="/galleries/ " class="underline "> 摄影</a>
      </li><li class="menu-item">
        <a target="_blank" rel="noopener" href="http://so1nz.lofter.com/ " class="underline "> 时光</a>
      </li><li class="menu-item">
        <a href="/archives/ " class="underline "> 归档</a>
      </li><li class="menu-item">
        <a href="/tags/ " class="underline "> 标签</a>
      </li><li class="menu-item">
        <a href="/categories/ " class="underline "> 分类</a>
      </li><li class="menu-item">
        <a href="/project/ " class="underline "> 项目</a>
      </li><li class="menu-item">
        <a href="/about/ " class="underline "> 关于</a>
      </li></ul>
    
      <div class="menu-copyright"><p>Powered by <a target="_blank" href="https://hexo.io">Hexo</a>  |  Theme - <a target="_blank" href="https://github.com/izhaoo/hexo-theme-zhaoo">zhaoo</a></p></div>
    
  </div>
</nav>
  <main id="main">
  <div class="article-wrap">
    <div class="row container">
      <div class="col-xl-3"></div>
      <div class="col-xl-6"><article class="article">
  <div class="wrap">
    <section class="head">
  <img   class="lazyload" data-original="/images/theme/post-image.jpg" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  draggable="false">
  <div class="head-mask">
    <h1 class="head-title">redis-py</h1>
    <div class="head-info">
      <span class="post-info-item"><i class="iconfont iconcalendar"></i>December 30, 2017</span>
      
      本文总阅读量<span id="busuanzi_value_page_pv"></span>次
      <span class="post-info-item"><i class="iconfont iconfont-size"></i>10897</span>
    </div>
  </div>
</section>

    <section class="main">
      <section class="content">
        <!-- 展示文章摘录 -->
        <h2 id="前记"><a href="#前记" class="headerlink" title="前记"></a>前记</h2><p>之前自己渣渣翻译的<a target="_blank" rel="noopener" href="https://pypi.python.org/pypi/redis">redi-py</a>文档,redis-py可以使用python操作redis数据库</p>
        <h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><h3 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> redis<br><span class="hljs-meta">&gt;&gt;&gt; </span>r = redis.StrictRedis(host=<span class="hljs-string">&#x27;localhost&#x27;</span>, port=<span class="hljs-number">6379</span>, db=<span class="hljs-number">0</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>r.<span class="hljs-built_in">set</span>(<span class="hljs-string">&#x27;foo&#x27;</span>, <span class="hljs-string">&#x27;bar&#x27;</span>)<br><span class="hljs-literal">True</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>r.get(<span class="hljs-string">&#x27;foo&#x27;</span>)<br><span class="hljs-string">&#x27;bar&#x27;</span><br></code></pre></td></tr></table></figure>
<h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><p>Redis官方的命令文档<a target="_blank" rel="noopener" href="https://redis.io/commands">英文</a>,<a target="_blank" rel="noopener" href="http://www.redis.cn/documentation.html">中文</a>做了详细的讲解每个命令的的工作。redis-py公开了两个实现这些命令的类。StrictRedis类尝试遵守官方命令语法。不过有一些例外：</p>
<ul>
<li>SELECT：未实现。请参阅下面的“线程安全”部分中的说明。</li>
<li>DEL：“del”是Python语法中的保留关键字。因此redis-py使用’delete’来代替。</li>
<li>CONFIG GET | SET：这些分别以config_get或config_set来实现。</li>
<li>MULTI / EXEC：这些被实现为Pipeline类的一部分。在执行时，默认情况下，管道是用MULTI和EXEC语句包装的，可以通过指定transaction = False来禁用。查看下面更多关于管道的说明。</li>
<li>SUBSCRIBE / LISTEN：与管道类似，PubSub作为独立的类来实现，因为它将底层连接置于无法执行非pubsub命令的状态。从Redis客户端调用pubsub方法将返回一个PubSub实例，您可以在其中订阅频道并侦听消息。您只能从Redis客户端调用PUBLISH（ 有关详细信息，请参阅 第151期的此评论）。</li>
<li>SCAN / SSCAN / HSCAN / ZSCAN：* SCAN命令按Redis文档中存在的方式执行。另外，每个命令都有一个等价的迭代器方法。这些纯粹是为了方便，所以用户在迭代时不必跟踪光标。对此行为使用scan_iter / sscan_iter / hscan_iter / zscan_iter方法。</li>
</ul>
<p>除了上面所做的更改外，Redis类（StrictRedis的一个子类）还覆盖了其他几个命令，以便与redis-py的旧版本向后兼容：</p>
<ul>
<li>LREM：“num”和“value”参数的顺序相反，使得“num”可以提供默认值零。</li>
<li>ZADD：Redis在’value’之前指定’score’参数。人们使用它们之后才发现这些参数被意外交换。Redis类期望* args的形式为： name1，score1，name2，score2，…</li>
<li>SETEX：“时间”和“值”参数的顺序相反</li>
</ul>
<h3 id="连接池"><a href="#连接池" class="headerlink" title="连接池"></a>连接池</h3><p>redis-py使用连接池来管理与Redis服务器的连接。默认情况下，创建的每个Redis实例将依次创建自己的连接池。可以通过将已创建的连接池实例传递给Redis类的connection_pool参数来覆盖此行为并使用现有连接池。通过这样做，可以实现客户端分片或更好地控制连接的管理方式。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>pool = redis.ConnectionPool(host=<span class="hljs-string">&#x27;localhost&#x27;</span>, port=<span class="hljs-number">6379</span>, db=<span class="hljs-number">0</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>r = redis.Redis(connection_pool=pool)<br></code></pre></td></tr></table></figure>
<h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><p>ConnectionPools管理一组Connection实例。redis-py提供两种类型的连接。默认的Connection是一个普通的基于TCP  socke的连接。UnixDomainSocketConnection允许在与相同的服务器设备上运行的客户端通过unix域套接字进行连接。要使用UnixDomainSocketConnection连接，只需将unix_socket_path参数（它是一个字符串）传递给UnixDomainSocket文件。此外，请确保redis.conf文件中定义了unixsocket参数。因为它被默认注释掉了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>r = redis.Redis(unix_socket_path=<span class="hljs-string">&#x27;/tmp/redis.sock&#x27;</span>)<br></code></pre></td></tr></table></figure>
<p>您也可以创建自己的Connection子类。如果想在异步框架中控制套接字行为，这可能很有用。要使用自己的连接实例化客户端类，需要创建一个连接池，将类传递给connection_class参数。传递给池的其他关键字参数将传递给在初始化过程中指定的类。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>pool = redis.ConnectionPool(connection_class=YourConnectionClass,<br>                                your_arg=<span class="hljs-string">&#x27;...&#x27;</span>, ...)<br></code></pre></td></tr></table></figure>
<h3 id="解析器"><a href="#解析器" class="headerlink" title="解析器"></a>解析器</h3><p>解析器类提供了一种方法来控制如何解析来自Redis服务器的响应。redis-py提供了两个解析器类，PythonParser和HiredisParser。默认情况下，如果已安装hiredis模块，redis-py将尝试使用HiredisParser，否则将回退到PythonParser。</p>
<p>Hiredis是由Redis核心团队维护的C库。Pieter Noordhuis非常友好地创建了Python绑定。使用Hiredis可以使Redis服务器的响应速度提高10倍。当检索许多数据时（例如从LRANGE或SMEMBERS操作），性能提升最为明显<br>可以使用pip进行安装</p>
<h3 id="响应回调"><a href="#响应回调" class="headerlink" title="响应回调"></a>响应回调</h3><p>客户端类使用一组回调来将Redis响应转换为适当的Python类型。在名为RESPONSE_CALLBACKS的dict中，Redis客户端类中定义了许多这样的回调。<br>每个实例的基础上可以使用自定义回调set_response_callback方法添加。该方法接受两个参数：命令名称和回调。以这种方式添加的回调仅在添加了回调的实例上有效。如果要定义或覆盖全局回调，则应该创建Redis客户端的子类并将其回调添加到其RESPONSE_CALLBACKS类dict中。<br>响应回调至少需要一个参数：来自Redis服务器的响应。关键字参数也可以被接受，以便进一步控制如何解释响应。这些关键字参数在命令调用execute_command期间被指定。ZRANGE实现通过其“withscores”参数来演示响应回调关键字参数的使用。</p>
<h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><p>Redis客户端实例可以在线程之间安全地共享。在内部，连接实例只能在命令执行期间从连接池中获取，并在之后直接返回到池中。命令执行不会修改客户端实例的状态。<br>但是，有一个另外：Redis的SELECT命令。SELECT命令允许切换连接当前正在使用的数据库。该数据库保持选定状态，直到选择另一个数据库或连接关闭。这会产生一个问题，连接可能会返回到连接到不同数据库的池。<br>因此，redis-py不会在客户端实例上实现SELECT命令。如果在同一应用程序中使用多个Redis数据库，则应为每个数据库创建一个单独的客户端实例（可能还有一个单独的连接池）。<br>在线程之间传递PubSub或Pipeline对象是不安全的。</p>
<h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><p> 管道是Redis类的一个子类，它提供了在一个请求中缓存多个到服务器的命令的支持。通过减少客户端和服务器之间来回TCP数据包的数量，可以大大提高命令组的性能。<br> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Python"> &gt;&gt;&gt; r = redis.Redis(...)<br><span class="hljs-meta">&gt;&gt;&gt; </span>r.<span class="hljs-built_in">set</span>(<span class="hljs-string">&#x27;bing&#x27;</span>, <span class="hljs-string">&#x27;baz&#x27;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># Use the pipeline() method to create a pipeline instance</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>pipe = r.pipeline()<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># The following SET commands are buffered</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>pipe.<span class="hljs-built_in">set</span>(<span class="hljs-string">&#x27;foo&#x27;</span>, <span class="hljs-string">&#x27;bar&#x27;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>pipe.get(<span class="hljs-string">&#x27;bing&#x27;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># the EXECUTE call sends all buffered commands to the server, returning</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># a list of responses, one for each command.</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>pipe.execute()<br>[<span class="hljs-literal">True</span>, <span class="hljs-string">&#x27;baz&#x27;</span>]<br></code></pre></td></tr></table></figure><br> 为了便于使用，缓冲到管道中的所有命令都返回管道对象本身。因此，调用可以像链接一样<br> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Python"> &gt;&gt;&gt; pipe.<span class="hljs-built_in">set</span>(<span class="hljs-string">&#x27;foo&#x27;</span>, <span class="hljs-string">&#x27;bar&#x27;</span>).sadd(<span class="hljs-string">&#x27;faz&#x27;</span>, <span class="hljs-string">&#x27;baz&#x27;</span>).incr(<span class="hljs-string">&#x27;auto_number&#x27;</span>).execute()<br>[<span class="hljs-literal">True</span>, <span class="hljs-literal">True</span>, <span class="hljs-number">6</span>]<br></code></pre></td></tr></table></figure><br>此外，默认状态下，管道还可以确保缓冲的命令作为一个组自动执行。如果你想禁用管道的原子特性，但仍想缓冲命令，可以关闭事务。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>pipe = r.pipeline(transaction=<span class="hljs-literal">False</span>)<br></code></pre></td></tr></table></figure>
<h3 id="发布-订阅"><a href="#发布-订阅" class="headerlink" title="发布/订阅"></a>发布/订阅</h3><p>redis-py包含一个PubSub对象，用于订阅频道并侦听新消息。创建PubSub对象如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>r = redis.StrictRedis(...)<br><span class="hljs-meta">&gt;&gt;&gt; </span>p = r.pubsub()<br></code></pre></td></tr></table></figure>
<p>一旦创建了PubSub实例，可以订阅给定模式的频道。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>p.subscribe(<span class="hljs-string">&#x27;my-first-channel&#x27;</span>, <span class="hljs-string">&#x27;my-second-channel&#x27;</span>, ...)<br><span class="hljs-meta">&gt;&gt;&gt; </span>p.psubscribe(<span class="hljs-string">&#x27;my-*&#x27;</span>, ...)<br></code></pre></td></tr></table></figure>
<p>在PubSub的实例订阅的频道/模式后，可以通过阅读PubSub 实例的消息来查看订阅</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>p.get_message()<br>&#123;<span class="hljs-string">&#x27;pattern&#x27;</span>: <span class="hljs-literal">None</span>, <span class="hljs-string">&#x27;type&#x27;</span>: <span class="hljs-string">&#x27;subscribe&#x27;</span>, <span class="hljs-string">&#x27;channel&#x27;</span>: <span class="hljs-string">&#x27;my-second-channel&#x27;</span>, <span class="hljs-string">&#x27;data&#x27;</span>: <span class="hljs-number">1L</span>&#125;<br><span class="hljs-meta">&gt;&gt;&gt; </span>p.get_message()<br>&#123;<span class="hljs-string">&#x27;pattern&#x27;</span>: <span class="hljs-literal">None</span>, <span class="hljs-string">&#x27;type&#x27;</span>: <span class="hljs-string">&#x27;subscribe&#x27;</span>, <span class="hljs-string">&#x27;channel&#x27;</span>: <span class="hljs-string">&#x27;my-first-channel&#x27;</span>, <span class="hljs-string">&#x27;data&#x27;</span>: <span class="hljs-number">2L</span>&#125;<br><span class="hljs-meta">&gt;&gt;&gt; </span>p.get_message()<br>&#123;<span class="hljs-string">&#x27;pattern&#x27;</span>: <span class="hljs-literal">None</span>, <span class="hljs-string">&#x27;type&#x27;</span>: <span class="hljs-string">&#x27;psubscribe&#x27;</span>, <span class="hljs-string">&#x27;channel&#x27;</span>: <span class="hljs-string">&#x27;my-*&#x27;</span>, <span class="hljs-string">&#x27;data&#x27;</span>: <span class="hljs-number">3L</span>&#125;<br></code></pre></td></tr></table></figure>
<p>每个从PubSub实例读取的消息都是一个包含以下key的dict。</p>
<ul>
<li>类型： ‘subscribe’, ‘unsubscribe’, ‘psubscribe’, ‘punsubscribe’, ‘message’, ‘pmessage’。备注:发送者(pub)发送消息，订阅者(sub)接收消息</li>
<li>频道：订阅或消息发布到的频道</li>
<li>模式：匹配发布消息频道的模式。如果是None时，那模式就是除“pmessage”类型外的所有情况</li>
<li>数据：消息数据。订阅者订阅消息时，此值将是连接当前订阅的通道和模式的数量。发布者发布消息时，这个值将是实际发布消息的数量</li>
</ul>
<p>发布消息的栗子:<br>publish方法返回匹配频道和订阅模式的号码。 ‘my-first-channel’同时匹配’my-first-channel’和’my-*‘订阅模式，所以这个消息将被传送到2个通道/模式</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>r.publish(<span class="hljs-string">&#x27;my-first-channel&#x27;</span>, <span class="hljs-string">&#x27;some data&#x27;</span>)<br><span class="hljs-number">2</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>p.get_message()<br>&#123;<span class="hljs-string">&#x27;channel&#x27;</span>: <span class="hljs-string">&#x27;my-first-channel&#x27;</span>, <span class="hljs-string">&#x27;data&#x27;</span>: <span class="hljs-string">&#x27;some data&#x27;</span>, <span class="hljs-string">&#x27;pattern&#x27;</span>: <span class="hljs-literal">None</span>, <span class="hljs-string">&#x27;type&#x27;</span>: <span class="hljs-string">&#x27;message&#x27;</span>&#125;<br><span class="hljs-meta">&gt;&gt;&gt; </span>p.get_message()<br>&#123;<span class="hljs-string">&#x27;channel&#x27;</span>: <span class="hljs-string">&#x27;my-first-channel&#x27;</span>, <span class="hljs-string">&#x27;data&#x27;</span>: <span class="hljs-string">&#x27;some data&#x27;</span>, <span class="hljs-string">&#x27;pattern&#x27;</span>: <span class="hljs-string">&#x27;my-*&#x27;</span>, <span class="hljs-string">&#x27;type&#x27;</span>: <span class="hljs-string">&#x27;pmessage&#x27;</span>&#125;<br></code></pre></td></tr></table></figure>
<p>取消订阅就像订阅一样。如果没有参数传递给发送者取消订阅，则所有通道或模式都将取消订阅</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>p.unsubscribe()<br><span class="hljs-meta">&gt;&gt;&gt; </span>p.punsubscribe(<span class="hljs-string">&#x27;my-*&#x27;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>p.get_message()<br>&#123;<span class="hljs-string">&#x27;channel&#x27;</span>: <span class="hljs-string">&#x27;my-second-channel&#x27;</span>, <span class="hljs-string">&#x27;data&#x27;</span>: <span class="hljs-number">2L</span>, <span class="hljs-string">&#x27;pattern&#x27;</span>: <span class="hljs-literal">None</span>, <span class="hljs-string">&#x27;type&#x27;</span>: <span class="hljs-string">&#x27;unsubscribe&#x27;</span>&#125;<br><span class="hljs-meta">&gt;&gt;&gt; </span>p.get_message()<br>&#123;<span class="hljs-string">&#x27;channel&#x27;</span>: <span class="hljs-string">&#x27;my-first-channel&#x27;</span>, <span class="hljs-string">&#x27;data&#x27;</span>: <span class="hljs-number">1L</span>, <span class="hljs-string">&#x27;pattern&#x27;</span>: <span class="hljs-literal">None</span>, <span class="hljs-string">&#x27;type&#x27;</span>: <span class="hljs-string">&#x27;unsubscribe&#x27;</span>&#125;<br><span class="hljs-meta">&gt;&gt;&gt; </span>p.get_message()<br>&#123;<span class="hljs-string">&#x27;channel&#x27;</span>: <span class="hljs-string">&#x27;my-*&#x27;</span>, <span class="hljs-string">&#x27;data&#x27;</span>: <span class="hljs-number">0L</span>, <span class="hljs-string">&#x27;pattern&#x27;</span>: <span class="hljs-literal">None</span>, <span class="hljs-string">&#x27;type&#x27;</span>: <span class="hljs-string">&#x27;punsubscribe&#x27;</span>&#125;<br></code></pre></td></tr></table></figure>
<p>redis-py也允许注册回调函数来处理发布的消息。消息处理（函数）只接受一个参数:message（像上面的例子那样是一个dict）。要使用消息处理（函数）订阅通道/模式，请将通道或模式名称作为关键字参数传递，其值为回调函数。</p>
<p>当消息在消息处理的通道或模式中读取时，将创建消息字典并将其传递给消息处理。在这种情况下，get_message（）返回一个None值，因为消息已经被处理了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">my_handler</span>(<span class="hljs-params">message</span>):</span><br><span class="hljs-meta">... </span>    <span class="hljs-built_in">print</span> (<span class="hljs-string">&#x27;MY HANDLER: &#x27;</span>), message[<span class="hljs-string">&#x27;data&#x27;</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>p.subscribe(**&#123;<span class="hljs-string">&#x27;my-channel&#x27;</span>: my_handler&#125;)<br>＃阅读订阅确认消息<br><span class="hljs-meta">&gt;&gt;&gt; </span>p.get_message()<br>&#123;<span class="hljs-string">&#x27;pattern&#x27;</span>: <span class="hljs-literal">None</span>, <span class="hljs-string">&#x27;type&#x27;</span>: <span class="hljs-string">&#x27;subscribe&#x27;</span>, <span class="hljs-string">&#x27;channel&#x27;</span>: <span class="hljs-string">&#x27;my-channel&#x27;</span>, <span class="hljs-string">&#x27;data&#x27;</span>: <span class="hljs-number">1L</span>&#125;<br><span class="hljs-meta">&gt;&gt;&gt; </span>r.publish(<span class="hljs-string">&#x27;my-channel&#x27;</span>, <span class="hljs-string">&#x27;awesome data&#x27;</span>)<br><span class="hljs-number">1</span><br>＃对于消息处理程序的工作，可以通过get_message（）函数告诉实例读取数据<br><span class="hljs-meta">&gt;&gt;&gt; </span>message = p.get_message()<br>MY HANDLER:  awesome data<br><span class="hljs-meta">&gt;&gt;&gt; </span>print(message)<br><span class="hljs-literal">None</span><br></code></pre></td></tr></table></figure>
<p>如果对订阅/取消订阅的确认消息不感兴趣，则可以通过将ignore_subscribe_messages = True传递给r.pubsub（）来忽略它们 。这将导致所有订阅/取消订阅消息被读取</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>p = r.pubsub(ignore_subscribe_messages=<span class="hljs-literal">True</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>p.subscribe(<span class="hljs-string">&#x27;my-channel&#x27;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>p.get_message()  <span class="hljs-comment"># hides the subscribe message and returns None</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>r.publish(<span class="hljs-string">&#x27;my-channel&#x27;</span>)<br><span class="hljs-number">1</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>p.get_message()<br>&#123;<span class="hljs-string">&#x27;channel&#x27;</span>: <span class="hljs-string">&#x27;my-channel&#x27;</span>, <span class="hljs-string">&#x27;data&#x27;</span>: <span class="hljs-string">&#x27;my data&#x27;</span>, <span class="hljs-string">&#x27;pattern&#x27;</span>: <span class="hljs-literal">None</span>, <span class="hljs-string">&#x27;type&#x27;</span>: <span class="hljs-string">&#x27;message&#x27;</span>&#125;<br></code></pre></td></tr></table></figure>

<p>get_message（）使用系统的“select”模块快速查询连接的 socket。如果可以读取数据，get_message（）将读取它，格式化消息并返回，或者将消息传递给消息处理程序。如果没有要读取的数据，get_message（）会立即返回None。这使得将它集成到应用程序中的现有事件循环中变得容易</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br><span class="hljs-meta">&gt;&gt;&gt; </span>    message = p.get_message()<br><span class="hljs-meta">&gt;&gt;&gt; </span>    <span class="hljs-keyword">if</span> message:<br><span class="hljs-meta">&gt;&gt;&gt; </span>        <span class="hljs-comment"># 处理消息</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>    time.sleep(<span class="hljs-number">0.001</span>)  <span class="hljs-comment">#增加点延迟</span><br></code></pre></td></tr></table></figure>
<p>除了使用.get_message（）外还有其他的方式可以来阅读信息<br>1.阻塞<br>旧版本的redis-py只能用pubsub.listen（）读取消息。listen（）是一个生成器（直到有可用的消息，才解除阻塞）。如果应用程序不需要执行其他任何操作，只需接收和处理从redis接收到的消息，那么listen（）是最简单容易的方法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">for</span> message <span class="hljs-keyword">in</span> p.listen():<br><span class="hljs-meta">... </span>    <span class="hljs-comment"># 处理消息</span><br></code></pre></td></tr></table></figure>
<p>2.非阻塞<br>pubsub.run_in_thread（）创建一个新线程并启动事件循环，线程对象返回给run_in_thread（）的调用者。调用者可以使用thread.stop（）方法关闭事件循环和线程。<br>run_in_thread（），其实只是get_message（）的一个封装，使它在一个单独的线程中运行时，本质上创建了一个非常小的非阻塞事件循环。 run_in_thread（）有一个可选的sleep_time参数。如果指定参数，则事件循环将调用每次迭代时time.sleep()的值。</p>
<p>注意：由于在一个单独的线程中运行，因此无法处理那些不能自动处理和注册小心的函数。因此，如果订阅了没有附加消息处理函数的模式/通道，redis-py将阻止调用run_in_thread（）。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>p.subscribe(**&#123;<span class="hljs-string">&#x27;my-channel&#x27;</span>: my_handler&#125;)<br><span class="hljs-meta">&gt;&gt;&gt; </span>thread = p.run_in_thread(sleep_time=<span class="hljs-number">0.001</span>)<br><span class="hljs-comment"># 事件循环现在正在后台处理消息</span><br><span class="hljs-comment"># 中，直到它被关闭的时...</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>thread.stop()<br></code></pre></td></tr></table></figure>
<p>一个PubSub对象的编码与创建它的客户端实例相同。在发送到Redis之前，任何使用unicode的通道/模式都将使用客户端上指定的字符串编码。如果客户端的decode_responses设置为False（缺省值），则消息字典中的’channel’，’pattern’和’data’值将是（Python 2中的str，Python 3中的bit）。如果客户端的 decode_responses为True，那么’channel’，’pattern’和’data’值将被自动解码为使用客户端字的 unicode字符串编码。</p>
<p>PubSub对象记住它订阅的频道和模式。如果发生网络错误或超时等断开事件，之后又重新连接时，PubSub对象将重新订阅之前的所有通道和模式。不过客户端断开连接时发布的消息则无法传送。所以，当使用完PubSub对象时，要调用 .close（）方法关闭连接。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>p = r.pubsub()<br><span class="hljs-meta">&gt;&gt;&gt; </span>...<br><span class="hljs-meta">&gt;&gt;&gt; </span>p.close()<br></code></pre></td></tr></table></figure>
<p>PubSub对象还支持PUBSUB子命令CHANNELS，NUMSUB和NUMPAT的设置</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>r.pubsub_channels()<br>[<span class="hljs-string">&#x27;foo&#x27;</span>, <span class="hljs-string">&#x27;bar&#x27;</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>r.pubsub_numsub(<span class="hljs-string">&#x27;foo&#x27;</span>, <span class="hljs-string">&#x27;bar&#x27;</span>)<br>[(<span class="hljs-string">&#x27;foo&#x27;</span>, <span class="hljs-number">9001</span>), (<span class="hljs-string">&#x27;bar&#x27;</span>, <span class="hljs-number">42</span>)]<br><span class="hljs-meta">&gt;&gt;&gt; </span>r.pubsub_numsub(<span class="hljs-string">&#x27;baz&#x27;</span>)<br>[(<span class="hljs-string">&#x27;baz&#x27;</span>, <span class="hljs-number">0</span>)]<br><span class="hljs-meta">&gt;&gt;&gt; </span>r.pubsub_numpat()<br><span class="hljs-number">1204</span><br></code></pre></td></tr></table></figure>
<h3 id="提供Sentinel支持"><a href="#提供Sentinel支持" class="headerlink" title="提供Sentinel支持"></a>提供Sentinel支持</h3><p><a target="_blank" rel="noopener" href="http://doc.redisfans.com/topic/sentinel.html">关于Sentinel(哨兵)</a><br>redis-py可以与Redis Sentinel一起用于发现Redis节点。不过需要运行至少一个Sentinel守护进程才能使用redis-py的Sentinel支持。</p>
<p>将redis-py连接到Sentinel实例很容易。可以使用Sentinel连接来发现主从之间的网络地址：<br>ps:主设备（用于写操作）,从设备（用于只读操作）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> redis.sentinel <span class="hljs-keyword">import</span> Sentinel<br><span class="hljs-meta">&gt;&gt;&gt; </span>sentinel = Sentinel([(<span class="hljs-string">&#x27;localhost&#x27;</span>, <span class="hljs-number">26379</span>)], socket_timeout=<span class="hljs-number">0.1</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>sentinel.discover_master(<span class="hljs-string">&#x27;mymaster&#x27;</span>)<br>(<span class="hljs-string">&#x27;127.0.0.1&#x27;</span>, <span class="hljs-number">6379</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>sentinel.discover_slaves(<span class="hljs-string">&#x27;mymaster&#x27;</span>)<br>[(<span class="hljs-string">&#x27;127.0.0.1&#x27;</span>, <span class="hljs-number">6380</span>)]<br></code></pre></td></tr></table></figure>
<p>也可以从Sentinel实例创建Redis客户端连接主从设备。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>master = sentinel.master_for(<span class="hljs-string">&#x27;mymaster&#x27;</span>, socket_timeout=<span class="hljs-number">0.1</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>slave = sentinel.slave_for(<span class="hljs-string">&#x27;mymaster&#x27;</span>, socket_timeout=<span class="hljs-number">0.1</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>master.<span class="hljs-built_in">set</span>(<span class="hljs-string">&#x27;foo&#x27;</span>, <span class="hljs-string">&#x27;bar&#x27;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>slave.get(<span class="hljs-string">&#x27;foo&#x27;</span>)<br><span class="hljs-string">&#x27;bar&#x27;</span><br></code></pre></td></tr></table></figure>
<p>主对象和从属对象是正常的StrictRedis实例，其连接池绑定到Sentinel实例。当支持Sentinel的客户端尝试建立连接时，它首先查询Sentinel服务器以确定要连接的适当主机。如果找不到服务器，则会引发MasterNotFoundError或SlaveNotFoundError，这两个类都是ConnectionError的子类。<br>当尝试连接到从属客户端时，Sentinel连接池将遍历从属列表，直到找到可以连接的从属客户端。如果没有从属客户端可以连接，则与主站建立连接。</p>
<h3 id="扫描迭代器"><a href="#扫描迭代器" class="headerlink" title="扫描迭代器"></a>扫描迭代器</h3><p>redis-py可以通过自带的can_iter，hscan_iter， sscan_iter和zscan_iter方法方便的使用Python迭代器</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">for</span> key, value <span class="hljs-keyword">in</span> ((<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>), (<span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>), (<span class="hljs-string">&#x27;C&#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>)):<br><span class="hljs-meta">... </span>    r.<span class="hljs-built_in">set</span>(key, value)<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">for</span> key <span class="hljs-keyword">in</span> r.scan_iter():<br><span class="hljs-meta">... </span>    print(key, r.get(key))<br>A <span class="hljs-number">1</span><br>B <span class="hljs-number">2</span><br>C <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure>
<h3 id="操作文档"><a href="#操作文档" class="headerlink" title="操作文档"></a>操作文档</h3><p><a target="_blank" rel="noopener" href="http://redis-py.readthedocs.io/en/latest/#indices-and-tables">文档</a></p>
      </section>
      <section class="extra">
        
          <ul class="copyright">
  
    <li><strong>本文作者：</strong>So1n</li>
    <li><strong>本文链接：</strong><a href="http://so1n.me/2017/12/30/27_tr_redis_py/index.html" title="http:&#x2F;&#x2F;so1n.me&#x2F;2017&#x2F;12&#x2F;30&#x2F;27_tr_redis_py&#x2F;index.html">http:&#x2F;&#x2F;so1n.me&#x2F;2017&#x2F;12&#x2F;30&#x2F;27_tr_redis_py&#x2F;index.html</a></li>
    <li><strong>版权声明：</strong>本博客所有文章均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" title="BY-NC-SA" target="_blank" rel="noopener">BY-NC-SA</a> 许可协议，转载请注明出处！</li>
  
</ul>
        
        
          <section class="donate">
  <div id="qrcode-donate">
    <img   class="lazyload" data-original="https://github.com/so1n/so1n_blog_photo/blob/master/blog_photo/4d2ebf32586d8799ee2e75333d6f5d2.jpg?raw=true" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" >
  </div>
  <div class="icon">
    <a href="javascript:;" id="alipay"><i class="iconfont iconalipay"></i></a>
    <a href="javascript:;" id="wechat"><i class="iconfont iconwechat-fill"></i></a>
  </div>
</section>
        
        
  <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/python/" rel="tag">python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/redis/" rel="tag">redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag">数据库</a></li></ul> 

        
  <nav class="nav">
    <a href="/2018/01/01/start-2018/"><i class="iconfont iconleft"></i>收藏</a>
    <a href="/2017/12/29/26_tr_aiohttp/">aiohttp文档翻译<i class="iconfont iconright"></i></a>
  </nav>

      </section>
      
        <section class="comments">
  
    <div class="btn" id="comments-btn">查看评论</div>
  
  
<link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<div id="gitalk" class="gitalk"></div>
<script defer src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
<script>
  window.onload = function () {
    var gitalk = new Gitalk({
      clientID: '59f804e526b05c378470',
      clientSecret: '36679ff697cec424936a0f7c4bcd6d2988dac28e',
      id: window.location.pathname,
      repo: 'so1n.github.io',
      owner: 'so1n',
      admin: 'so1n'
    });
    if ( true ) {
      $("#comments-btn").on("click", function () {
        $(this).hide();
        gitalk.render('gitalk');
      });
    } else {
      gitalk.render('gitalk');
    }
  }
</script>

</section>
      
    </section>
  </div>
</article>
</div>
      <div class="col-xl-3">
          
  <aside class="toc-wrap">
    <h3 class="toc-title">文章目录：</h3>
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%AE%B0"><span class="toc-text">前记</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis"><span class="toc-text">Redis</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A5%E9%97%A8"><span class="toc-text">入门</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#API"><span class="toc-text">API</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5%E6%B1%A0"><span class="toc-text">连接池</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5"><span class="toc-text">连接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90%E5%99%A8"><span class="toc-text">解析器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%8D%E5%BA%94%E5%9B%9E%E8%B0%83"><span class="toc-text">响应回调</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="toc-text">线程安全</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%A1%E9%81%93"><span class="toc-text">管道</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%91%E5%B8%83-%E8%AE%A2%E9%98%85"><span class="toc-text">发布&#x2F;订阅</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%90%E4%BE%9BSentinel%E6%94%AF%E6%8C%81"><span class="toc-text">提供Sentinel支持</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%AB%E6%8F%8F%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-text">扫描迭代器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E6%96%87%E6%A1%A3"><span class="toc-text">操作文档</span></a></li></ol></li></ol>
  </aside>

        
          
  <aside class="toc-wrap">
    <h3 class="toc-title">文章目录：</h3>
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%AE%B0"><span class="toc-text">前记</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis"><span class="toc-text">Redis</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A5%E9%97%A8"><span class="toc-text">入门</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#API"><span class="toc-text">API</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5%E6%B1%A0"><span class="toc-text">连接池</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5"><span class="toc-text">连接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90%E5%99%A8"><span class="toc-text">解析器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%8D%E5%BA%94%E5%9B%9E%E8%B0%83"><span class="toc-text">响应回调</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="toc-text">线程安全</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%A1%E9%81%93"><span class="toc-text">管道</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%91%E5%B8%83-%E8%AE%A2%E9%98%85"><span class="toc-text">发布&#x2F;订阅</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%90%E4%BE%9BSentinel%E6%94%AF%E6%8C%81"><span class="toc-text">提供Sentinel支持</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%AB%E6%8F%8F%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-text">扫描迭代器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E6%96%87%E6%A1%A3"><span class="toc-text">操作文档</span></a></li></ol></li></ol>
  </aside>

        
      </div>
    </div>
  </div>
</main>

  <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js">
</script>


<footer class="footer">
  <div class="footer-social"><a 
        href="https://github.com/so1n "
        target="_blank"
        class="footer-social-item"
        onMouseOver="this.style.color= '#9f7be1'" 
        onMouseOut="this.style.color='#33333D'">
          <i class="iconfont  icongithub-fill "></i>
      </a></div>
  
    <div class="footer-copyright"><p>Powered by <a target="_blank" href="https://hexo.io">Hexo</a>  |  Theme - <a target="_blank" href="https://github.com/izhaoo/hexo-theme-zhaoo">zhaoo</a></p></div>
  
  <div class="footer-copyright">
    总访问量<span id="busuanzi_value_site_pv"></span>次
    访客数<span id="busuanzi_value_site_uv"></span>人次
  </div>

</footer>

  
      <div class="fab fab-plus">
    <i class="iconfont iconplus"></i>
  </div>
  
  
  <div class="fab fab-up">
    <i class="iconfont iconcaret-up"></i>
  </div>
  
  
    <div class="scrollbar j-scrollbar">
  <div class="scrollbar-current j-scrollbar-current"></div>
</div>
  
  
    
<script src="/js/color-mode.js"></script>

  
</body>

<script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script>



  
<script src="https://cdn.bootcdn.net/ajax/libs/jquery.lazyload/1.9.1/jquery.lazyload.min.js"></script>




  
<script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js"></script>






  
<script src="https://cdn.bootcdn.net/ajax/libs/jquery.qrcode/1.0/jquery.qrcode.min.js"></script>




<script src="/js/utils.js"></script>
<script src="/js/script.js"></script>







  <script>
    (function () {
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
      } else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>













</html>