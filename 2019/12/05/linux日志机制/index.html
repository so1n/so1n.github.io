

<!DOCTYPE html>
<html lang="zh-Hans" color-mode=light>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>linux日志规则 - So1n blog</title>
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="google" content="notranslate" />
  
  <meta name="description" content="前记最近系统上出现部分日志丢失的情况,为了解决这个问题...">
  <meta name="author" content="So1n">
  <link rel="icon" href="/images/icons/favicon.ico" type="image/png" sizes="16x16">
  <link rel="icon" href="/images/icons/favicon.ico" type="image/png" sizes="32x32">
  <link rel="apple-touch-icon" href="/images/icons/favicon.ico" sizes="180x180">
  <meta rel="mask-icon" href="/images/icons/stun-logo.svg" color="#333333">
  
    <meta rel="msapplication-TileImage" content="/images/icons/favicon.ico">
    <meta rel="msapplication-TileColor" content="#000000">
  

  
<link rel="stylesheet" href="/css/style.css">


  
    
<link rel="stylesheet" href="//at.alicdn.com/t/font_1445822_s6x2xcokxrl.css">

  

  
    
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css">

  

  
    
      
        
        
<link rel="stylesheet" href="https://cdn.bootcss.com/highlight.js/9.18.1/styles/atom-one-dark-reasonable.min.css" name="highlight-style" mode="light">

      
        
        
<link rel="stylesheet" href="https://cdn.bootcss.com/highlight.js/9.18.1/styles/atom-one-dark-reasonable.min.css" name="highlight-style" mode="dark">

      
  

  <script>
    var CONFIG = window.CONFIG || {};
    var ZHAOO = window.ZHAOO || {};
    CONFIG = {
      isHome: false,
      fancybox: true,
      pjax: false,
      lazyload: {
        enable: true,
        only_post: 'true',
        loading: '/images/theme/puff.svg'
      },
      donate: {
        enable: true,
        alipay: 'https://github.com/so1n/so1n_blog_photo/blob/master/blog_photo/4d2ebf32586d8799ee2e75333d6f5d2.jpg?raw=true',
        wechat: ''
      },
      galleries: {
        enable: true
      },
      fab: {
        enable: true,
        always_show: true
      },
      carrier: {
        enable: false
      },
      daovoice: {
        enable: false
      },
      preview: {
        background: {
          default: '',
          api: ''
        },
        motto: {
          default: 'I`m   So1n',
          typing: true,
          api: '',
          data_contents: '["data","content"]'
        },
      },
      qrcode: {
        enable: true,
        type: 'url',
        image: 'https://pic.izhaoo.com/weapp-code.jpg',
      },
      toc: {
        enable: true
      },
      scrollbar: {
        type: 'simple'
      },
      notification: {
        enable: false,
        delay: 4500,
        list: '',
        page_white_list: '',
        page_black_list: ''
      },
      search: {
        enable: true,
        path: 'search.xml'
      }
    }
  </script>

  

  

<meta name="generator" content="Hexo 5.4.0"></head>

<body class="lock-screen">
  <div class="loading"></div>
  
    


  <nav class="navbar">
    <div class="left">
      
        <i class="iconfont iconhome j-navbar-back-home"></i>
      
      
        <i class="iconfont iconqrcode j-navbar-qrcode"></i>
      
      
        <i class="iconfont iconmoono" id="color-toggle" color-toggle="light"></i>
      
      
        <i class="iconfont iconsearch j-navbar-search"></i>
      
    </div>
    <div class="center">linux日志规则</div>
    <div class="right">
      <i class="iconfont iconmenu j-navbar-menu"></i>
    </div>
    
      <div id="qrcode-navbar"></div>
    
  </nav>

  
  

<nav class="menu">
  <div class="menu-container">
    <div class="menu-close">
      <i class="iconfont iconbaseline-close-px"></i>
    </div>
    <ul class="menu-content"><li class="menu-item">
        <a href="/ " class="underline "> 首页</a>
      </li><li class="menu-item">
        <a target="_blank" rel="noopener" href="http://so1nz.lofter.com/ " class="underline "> 时光</a>
      </li><li class="menu-item">
        <a href="/archives/ " class="underline "> 归档</a>
      </li><li class="menu-item">
        <a href="/tags/ " class="underline "> 标签</a>
      </li><li class="menu-item">
        <a href="/categories/ " class="underline "> 分类</a>
      </li><li class="menu-item">
        <a href="/project/ " class="underline "> 项目</a>
      </li><li class="menu-item">
        <a href="/about/ " class="underline "> 关于</a>
      </li></ul>
    
      <div class="menu-copyright"><p>Powered by <a target="_blank" href="https://hexo.io">Hexo</a>  |  Theme - <a target="_blank" href="https://github.com/izhaoo/hexo-theme-zhaoo">zhaoo</a></p></div>
    
  </div>
</nav>
  <main id="main">
  <div class="article-wrap">
    <div class="row container">
      <div class="col-xl-3"></div>
      <div class="col-xl-6"><article class="article">
  <div class="wrap">
    <section class="head">
  <img src="/images/theme/post-image.jpg" draggable="false">
  <div class="head-mask">
    <h1 class="head-title">linux日志规则</h1>
    <div class="head-info">
      <span class="post-info-item"><i class="iconfont iconcalendar"></i>December 05, 2019</span>
      
      本文总阅读量<span id="busuanzi_value_page_pv"></span>次
      <span class="post-info-item"><i class="iconfont iconfont-size"></i>32899</span>
    </div>
  </div>
</section>

    <section class="main">
      <section class="content">
        <!-- 展示文章摘录 -->
        <h2 id="前记"><a href="#前记" class="headerlink" title="前记"></a>前记</h2><p>最近系统上出现部分日志丢失的情况,为了解决这个问题,开始了解Linux的日志结构和机制。以下是我的学习总结, 主要涉及到了如何发送日志， 怎么处理日志以及怎么管理日志。<br>注:由于这些应用都是需要用配置去改良或者指导他们如何去做,所以除了简述Linux的结构和功能外,更多的是如何去配置他们。但其中最重要的是了解整个日志记录的机制,以及通过配置去了解这套机制会如何去限制日志的记录以及优化传输,这样我们才能去灵活使用他们。</p>
        <h2 id="1-Linux中日志的发送流程"><a href="#1-Linux中日志的发送流程" class="headerlink" title="1.Linux中日志的发送流程"></a>1.Linux中日志的发送流程</h2><p>一般来说， 我们所写的Web应用的日志都是直接打开一个文件， 然后把日志信息写到这个文件中。 这样非常方便, 但是缺少了一个统一的定义和管理, 所以Linux中就使用了一套稳定的日志管理系统–<code>rsyslog</code>。 它可以接收应用程序通过socket发送过来的日志数据， 然后按照规则非常方便的过滤和分发日志, 同时它也支持稳定的把所有日志从某台机器发送到另外一台机器， 不漏一条消息。</p>
<p>那么这整套机制是怎么运行的呢， 先看看一个本机应用程序发送日志， 本机rsyslog接收日志的流程图：</p>
<blockquote>
<p>注:操作系统为debain7, 该流程图以本地发送, 本地接受为例。</p>
</blockquote>
<p><img  src="https://github.com/so1n/so1n_blog_photo/blob/master/blog_photo/Linux%E6%97%A5%E5%BF%97%E6%9C%BA%E5%88%B6%E7%BB%93%E6%9E%84.png?raw=true"  ><span class="image-caption">img</span></p>
<p>在这个流程图中， 第一步是应用程序把日志根据<a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc5424">syslog协议</a>进行封装， 比如用户指定的日志等级， 系统log渠道等等, 然后把封装好的数据发送到指定socket – <code>/dev/log</code>。<br><code>/dev/log</code>是一个UNIX域套接字，它负责接受在本地机器上运行的进程所产生的消息。</p>
<blockquote>
<p>除此之外还有一个与它十分相似的<code>/dev/klog</code>, <code>/dev/klog</code>是一个从UNIX内核接受消息的设备的socket, 如果看到syslog记录了kern的日志,却没记录普通日志,那就是<code>/dev/log</code>这个socket缓冲区满了, 而<code>/dev/klog</code>缓存区还有空间， 还可以正常运行， 这时候可以尝试通过kern.ipc.maxsockbuf改变缓冲区大小,但并不能完全解决问题。</p>
</blockquote>
<p>第二步是由系统的<code>journald</code>开始服务， 在我的系统中，由于使用了<code>Systemd</code>, 它的附属套件<code>systemd/journald</code>提供了一个<code>socket</code> – <code>/run/systemd/journal/syslog</code>，它通过软连接,让发送到<code>/dev/log/</code>的数据转而发送到<code>/run/systemd/journal/syslog</code>， 然后通过读取标准socket来读取日志。不过<code>systemd-journald</code>所记录的数据其实是在内存中，只是系统利用文件的型态将它记录到<code>/run/log/</code>下面, 在重新开机后,这些数据就会被清除掉。<br>当然， 也可以通过在<code>/etc/systemd/journald.conf</code>中更改设置， 设置它的存储位置和存储限制， 但一般都不会去更改它的这些存储相关的配置， 而是设置<code>ForwardToSyslog=yes</code>, 让journald把日志发送到rsyslog， 进入下一步。（journald自己也提供了很多<a target="_blank" rel="noopener" href="https://wiki.archlinux.org/index.php/Systemd/Journal_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)">功能</a>,比如有:过滤输出,大小限制等等）</p>
<blockquote>
<p>PS: 在还没有<code>systemd</code>的时代, 必须要开机完成并且执行了<code>rsyslogd</code>这个<code>daemon</code>之后，登录文件才会开始记录日志。所以，需要自己产生一个<code>klogd</code>的服务， 才能将系统在开机过程、启动服务的过程中的信息记录下来，然后等<code>rsyslogd</code>启动后才传送给它来处理。现在有了systemd主动调用 <code>systemd-journald</code>来协助记载登录文件, 在开机过程中的所有信息， 包括启动服务与服务若启动失败的情况等等，都可以直接被记录到<code>systemd-journald</code>.</p>
</blockquote>
<p>第三步是<code>rsyslog</code>服务了， 在rsyslog服务启动后(以监控本地日志为例子,也就是加载module(load=”imuxsock”)) 从<code>/run/systemd/journal/syslog</code>这个socket消费syslog类型日志, 这些日志在经过预处理后会进入到主队列， 然后根据对应规则被分发, 由于<code>rsyslog</code>采用C/S结构，它可以将日志的信息追加到对应的日志文件中，一般在<code>/var/log</code>目录下(可以通过配置进行更改)。还可以把日志数据通过网络协议发送到另一台Linux服务器上，或者将日志存储在MySQL或Oracle等数据库中。<br>除此之外, <code>rsyslog</code>能够快速的过滤,转发,发送日志(官方说的每秒支持百万级日志),所以rsyslog的内容非常丰富。 <code>rsyslog</code>为了能让我们方便的使用这些功能， 提供了多个版本的配置语言， 我们只要通过对配置文件进行简单的修改,就能实现传输,过滤等功能。</p>
<blockquote>
<p>如上面的结构图,rsyslog中只有一个主消息队列，任何消息都要先进入这个队列，然后直到进入到动作队列之后消息才会从这个队列中删除。通常，我们都不会去动主队列的配置，因为默认的设置已经工作得很好；消息经过主消息队列之后，就被rule processor解析和处理，然后根据预先配置的规则压入各自的动作队列，动作队列的消息最终被消费掉, 而我们经常要配置的就是这一部分。</p>
</blockquote>
<p>可以发现， 上面这三步就是一个简单的消息队列， 应用程序通过syslog把日志输出到一个指定的log， 这是一个生产的步骤， <code>systemd-journald</code>则是以<code>FIFO</code>的形式暂存日志数据， 最后被<code>rsyslog</code>以消费者的形式进行消费。而<code>rsyslog</code>的内部则更像一个高级版本的消费队列， 一个简易版本的<code>RabbitMQ</code>。</p>
<h2 id="2-journald的配置"><a href="#2-journald的配置" class="headerlink" title="2.journald的配置"></a>2.journald的配置</h2><p>上面说到, 整个日志发送流程中， 对于<code>journald</code>只使用到它的暂存日志并转发到<code>rsyslog</code>的功能,所以这里分析的与暂存内存相关的配置, 如果要了解更多可以直接从man手册查看, 如果觉得内容太干， 也可以跳过， 都是从官网那边整理过来的。</p>
<ul>
<li><p>Storage: 指定收到数据时， 如何存数据,默认值为<code>none</code>, 此外它还有几个值：</p>
<ul>
<li>volatile： 表示仅保存在内存中， 也就是仅保存在<code>/run/log/journal</code>目录中(将会被自动按需创建)。 </li>
<li>persistent: 表示优先保存在磁盘上， 也就优先保存在<code>/var/log/journal</code>目录中(将会被自动按需创建)， 但若失败(例如在系统启动早期”/var”尚未挂载)， 则降级转而保存在<code>/run/log/journal</code>目录中(将会被自动按需创建)。 </li>
<li>auto： 与<code>persistent</code>类似， 但不自动创建<code>/var/log/journal</code>目录， 因此可以根据该目录的存在与否决定日志的保存位置。 </li>
<li>none: 表示不保存任何日志(直接丢弃所有收集到的日志)， 但日志转发不受影响。</li>
</ul>
</li>
<li><p>Compress: 默认值”yes”, 它表示压缩存储大于特定阈值(默认为512字节)的对象。 也可以直接设置一个字节值(可以带有 K, M, G 后缀)来表示要压缩存储大于指定阈值的对象。</p>
</li>
<li><p>Seal: 默认值”yes”, 它表示如果存在一个”sealing key”(由 journalctl(1) 的 –setup-keys 命令创建)， 那么就为所有持久保存的日志文件启用FSS(Seekable Sequential Key Generators)保护， 以避免日志文件 被恶意或无意的修改。</p>
</li>
<li><p>SplitMode: 设置是否按照每个用户分割日志文件，以实现对日志的访问控制(日志守护进程会确保每个用户都能读取自己的日志文件)。 默认值为uid, “uid” 表示每个用户都有自己专属的日志文件(无论该用户是否拥有登录会话)，但系统用户的日志依然记录到系统日志中。此外还有一个值”none”， 它表示不对日志文件按不同用户进行分割，而是将所有日志都记录到系统日志中。这意味着非特权用户根本无法读取属于自己的日志信息。 需要注意的是， 仅分割持久保存的日志(/var/log/journal)， 永不分割内存中的日志(/run/log/journal)。</p>
</li>
<li><p>RateLimitIntervalSec: 用于设置一个时间段长度,可以使用下面的时间单位： “ms”, “s”, “min”, “h”, “d”来限制日志的生成速率.表示在 RateLimitIntervalSec 时间段内， 每个服务最多允许产生 RateLimitBurst 数量(条数)的日志。 在同一个时间段内，超出数量限制的日志将被丢弃，直到下一个时间段才能再次开始记录。 对于所有被丢弃的日志消息，仅用一条类似”xxx条消息被丢弃”的消息来代替。 这个限制是针对每个服务的限制，一个服务超限并不会影响到另一个服务的日志记录。<br>如果一个服务已经通过<code>systemd</code>的<code>LogRateLimitIntervalSec=</code> 或 <code>LogRateLimitBurst=</code>选项限制了自身的日志生成速率，那么将会覆盖此处的设置。</p>
</li>
<li><p>RateLimitBurst 用于设置一个正整数，表示消息条数，默认值是10000条, 说明见RateLimitIntervalSec。 </p>
</li>
<li><p>SystemMaxUse: 限制磁盘使用量， 也就是<code>/var/log/journal</code>的使用量。限制全部日志文件加在一起最多可以占用多少空间。默认值是空间的10%与4G空间两者中的较小者；</p>
</li>
<li><p>SystemKeepFree: 限制磁盘使用量， 也就是<code>/var/log/journal</code>的使用量, 但与<code>SystemMaxUse</code>有所不同， 它的值的意思是除日志文件之外，至少保留多少空间给其他用途。<code>systemd-journald</code>会同时使用<code>SystemKeepFree</code>与<code>SystemMaxUse</code>两个值, 并且尽量限制日志文件的总大小，以同时满足这两个限制。默认值是空间的15%与4G空间两者中的较大者；</p>
</li>
<li><p>SystemMaxFileSize: 限制磁盘使用量， 也就是<code>/var/log/journal</code>的使用量。它限制的是单个日志文件的最大体积， 到达此限制后日志文件将会自动滚动。 默认值是对应的 SystemMaxUse值的1/8 ， 这也意味着日志滚动 默认保留7个历史文件。日志大小 可以使用以1024为基数的 K, M, G, T, P, E 后缀， 分别对应于 1024, 1024², … 字节。</p>
</li>
<li><p>SystemMaxFiles,<br>限制磁盘使用量， 也就是<code>/var/log/journal</code>的使用量。 限制最多允许同时存在多少个日志文件， 超出此限制后， 最老的日志文件将被删除， 而当前的活动日志文件 则不受影响。 默认值为100个。</p>
</li>
<li><p>RuntimeMaxUse<br>限制内存使用量， 也就是<code>/run/log/journal</code>的使用量。限制全部日志文件加在一起最多可以占用多少空间。默认值是空间的10%与4G空间两者中的较小者；</p>
</li>
<li><p>RuntimeKeepFree<br>限制内存使用量， 也就是<code>/run/log/journal</code>的使用量。除日志文件之外，至少保留多少空间给其他用途。systemd-journald 会同时RuntimeKeepFree与RuntimeMaxUse ， 并且尽量限制日志文件的总大小，以同时满足这两个限制。默认值是空间的15%与4G空间两者中的较大者；</p>
</li>
<li><p>RuntimeMaxFileSize<br>限制内存使用量， 也就是<code>/run/log/journal</code>的使用量。限制单个日志文件的最大体积， 到达此限制后日志文件将会自动滚动。 默认值是对应的 RuntimeMaxUse值的1/8 ， 这也意味着日志滚动 默认保留7个历史文件。日志大小 可以使用以1024为基数的 K, M, G, T, P, E 后缀， 分别对应于 1024, 1024², … 字节。</p>
</li>
<li><p>RuntimeMaxFiles<br>限制内存使用量， 也就是<code>/run/log/journal</code>的使用量。 限制最多允许同时存在多少个日志文件， 超出此限制后， 最老的日志文件将被删除， 而当前的活动日志文件 则不受影响。 默认值为100个。</p>
</li>
<li><p>MaxFileSec 日志滚动的时间间隔。 默认值是一个月， 设为零表示禁用基于时间的日志滚动策略。 可以使用 “year”, “month”, “week”, “day”, “h”, “m” 时间后缀， 若不使用后缀则表示以秒为单位。<br>通常 并不需要使用基于时间的日志滚动策略， 因为由 SystemMaxFileSize 与 RuntimeMaxFileSize 控制的基于文件大小的日志滚动策略 已经可以确保日志文件的大小不会超标。</p>
</li>
<li><p>MaxRetentionSec 日志文件的最大保留期限。 默认值零表示不使用基于时间的日志删除策略。可以使用 “year”, “month”, “week”, “day”, “h”, “m” 时间后缀， 若不使用后缀则表示以秒为单位。<br>当日志文件的最后修改时间(mtime)与当前时间之差， 大于此处设置的值时，日志文件将会被删除。  通常并不需要使用基于时间的日志删除策略，因为由 SystemMaxUse= 与 RuntimeMaxUse= 控制的基于文件大小的日志滚动策略 已经可以确保日志文件的大小不会超标。 </p>
</li>
<li><p>SyncIntervalSec 向磁盘刷写日志文件的时间间隔， 默认值是五分钟。<br>刷写之后，日志文件将会处于离线(OFFLINE)状态。 注意，当接收到 CRIT, ALERT, EMERG 级别的日志消息后， 将会无条件的立即刷写日志文件。 因此该设置仅对 ERR, WARNING, NOTICE, INFO, DEBUG 级别的日志消息有意义。</p>
</li>
<li><p>ForwardToSyslog 表示是否将接收到的日志消息转发给传统的 syslog 守护进程，默认值为”no”。 如果设为”yes”，但是没有任何进程监听对应的套接字，那么这种转发是无意义的。 此选项可以被内核引导选项 “systemd.journald.forward_to_syslog” 覆盖。</p>
</li>
<li><p>ForwardToKMsg 表示是否将接收到的日志消息转发给内核日志缓冲区(kmsg)，默认值为”no”。 此选项可以被内核引导选项 “systemd.journald.forward_to_kmsg” 覆盖。</p>
</li>
<li><p>ForwardToConsole 表示是否将接收到的日志消息转发给系统控制台，默认值为”no”。 如果设为”yes”，那么可以通过下面的 TTYPath= 指定转发目标。 此选项可以被内核引导选项 “systemd.journald.forward_to_console” 覆盖。 </p>
</li>
<li><p>ForwardToWall 表示是否将接收到的日志消息作为警告信息发送给所有已登录用户，默认值为”yes”。 此选项可以被内核引导选项 “systemd.journald.forward_to_wall” 覆盖。</p>
</li>
<li><p>MaxLevelStore 设置记录到日志文件中的最高日志等级，默认值为”debug”；可以被内核引导选项”systemd.journald.max_level_store”覆盖<br>可以设为日志等级的名称， 也可以设为日志等级对应的数字： “emerg”(0), “alert”(1), “crit”(2), “err”(3), “warning”(4), “notice”(5), “info”(6), “debug”(7) 。 所有高于设定等级的日志消息都将被直接丢弃， 仅保存/转发小于等于设定等级的日志消息。</p>
</li>
<li><p>MaxLevelSyslog 设置转发给传统的 syslog 守护进程的最高日志等级， 默认值为”debug”；可以被内核引导选项”systemd.journald.max_level_syslog”覆盖<br>选项说明同MaxLevelStore</p>
</li>
<li><p>MaxLevelKMsg 设置转发给内核日志缓冲区(kmsg)的最高日志等级，默认值为”notice”； 可以被内核引导选项”systemd.journald.max_level_kmsg”覆盖<br>选项说明同MaxLevelStore</p>
</li>
<li><p>MaxLevelConsole 设置转发给系统控制台的最高日志等级，默认值为”info”；可以被内核引导选项”systemd.journald.max_level_console”覆盖<br>选项说明同MaxLevelStore</p>
</li>
<li><p>MaxLevelWall 设置作为警告信息发送给所有已登录用户的最高日志等级，默认值为”emerg”；可以被内核引导选项”systemd.journald.max_level_wall”覆盖<br>选项说明同MaxLevelStore</p>
</li>
<li><p>ReadKMsg 是否收集内核日志。 默认值 yes 表示从 /dev/kmsg 中读取内核产生的日志消息。</p>
</li>
<li><p>TTYPath 指定 ForwardToConsole=yes 时所使用的控制台TTY， 默认值是 /dev/console</p>
</li>
<li><p>LineMax<br>在将日志流转化为日志记录时，每条日志记录最大允许的长度(字节)。 如果将单元的标准输出(STDOUT)/标准错误(STDERR)通过流套接字连接到日志中， 那么将会以换行符(“\n”, ASCII 10)与NUL字符(“\0”, ASCII 0)作为分割符， 把日志流切分成一条条独立的日志记录。 如果超过此处设置的长度之后仍然没有遇到分割符， 那么将会自动插入一个分割符，以强制将单行超长日志截断为多行。 此选项的值越大，每个日志流客户端日志守护进程占用的内存也越大(最大值等于此选项的值)。 另外，此选项的值太大也会造成与传统日志传输协议的不兼容(太长的日志无法封装在单个 AF_UNIX 或 AF_INET 报文内)。 此选项的值以字节为单位，同时也可以在数字的末尾加上 K, M, G, T 后缀(以1024为基准)。 默认值 48K 是一个足够大并且也能保持与传统日志传输协议兼容的值。 注意， 不能设为小于 79 的值(将被自动提升到79)。</p>
<h2 id="3-rsyslog配置"><a href="#3-rsyslog配置" class="headerlink" title="3.rsyslog配置"></a>3.rsyslog配置</h2><p>上面说到， <code>rsyslog</code>的配置主要是针对主队列之后的所有模块， 同时它目前支持两种语法配置, 个人觉得两种都有它的方便性,所以以下的配置一般都是混用。<code>rsyslog</code>的配置文件一般位于:<code>/etc/rsyslog.conf</code>， 他可以引用模块， 设置变量， 还有设置消息规则， 而规则就是指明一条消息要怎么输出， 也就是上面所说的过滤器+动作队列+输出模块的组合。</p>
<h3 id="3-1过滤器"><a href="#3-1过滤器" class="headerlink" title="3.1过滤器"></a>3.1过滤器</h3><p>消息经过主队列后进来的第一步就是过滤器, 过滤器有时候被称为选择器（selector）, 它用于过滤消息， 并把消息指向对应的操作队列，<code>rsyslog</code>可以配置三种形式的过滤器， 分别为<code>Facility/Priority-based</code>过滤器, <code>Property-based</code>过滤器以及<code>Expression-based</code>过滤器。</p>
</li>
</ul>
<h4 id="3-1-1-Facility-Priority-based-过滤器"><a href="#3-1-1-Facility-Priority-based-过滤器" class="headerlink" title="3.1.1.Facility/Priority-based 过滤器"></a>3.1.1.Facility/Priority-based 过滤器</h4><p>在syslog中指定消息发送时必须带有<code>facility</code>和<code>priority</code>字段， 对于<code>facility</code>我更想把它定义是<code>channel</code>, 也就是渠道， Linux系统默认设置了24个<code>facility</code>, 前16个都有专门的用途， 后8个交给用户自定义， 一般来说一个线上的机器只运行几个服务， 8个是够的， 以下是Linux支持渠道的列表：<br>| 代码 | 名称 | 描述 |<br>| —- | ——– | ———- |<br>| 0 | kern | 内核 |<br>| 1 | user | 用户级 |<br>| 2 | mail | 邮件 |<br>| 3 | daemon | 系统 |<br>| 4 | auth | 安全与授权 |<br>| 5 | syslog | 守护进程 |<br>| 6 | lpr | 打印相关 |<br>| 7 | news | 网络消息 |<br>| 8 | uucp | uucp子系统 |<br>| 9 | | 时钟 |<br>| 10 | authpriv | 安全与授权 |<br>| 11 | ftp | FTP |<br>| 12 | - | NTP |<br>| 13 | - | 日志审计 |<br>| 14 | - | 日志报警 |<br>| 15 | cron | 定时器 |<br>| 16 | local0 | 用户自定义 |<br>| 17 | local1 | 用户自定义 |<br>| 18 | local2 | 用户自定义 |<br>| 19 | local3 | 用户自定义 |<br>| 20 | local4 | 用户自定义 |<br>| 21 | local5 | 用户自定义 |<br>| 22 | local6 | 用户自定义 |<br>| 23 | local7 | 用户自定义 |</p>
<p>而至于<code>priority</code>, 大家都会十分熟悉， 只不过这里换了个说法， 设计上他代表的就是日志等级， 支持的日志等级列表有：<br>|代码|名称|简写|描述|<br>| —- | ————- | —— | —- |<br>| 0 | Emergency | emerg | 紧急 |<br>| 1 | Alert | alert | 报警 |<br>| 2 | Critical | crit | 关键 |<br>| 3 | Error | err | 错误 |<br>| 4 | Warning | warn | 警告 |<br>| 5 | Notice | notice | 通知 |<br>| 6 | Informational | info | 消息 |<br>| 7 | Debug | debug | 调试 |</p>
<p>了解完了<code>Facility</code>和<code>Priority</code>后就可以编写过滤器了, 过滤器编写十分简单， 他就是一个通配符, 通过<code>.</code>来区分<code>Facility</code>和<code>Priority</code>， <code>.</code>前面是<code>Facility</code>, <code>.</code>后面是<code>Priority</code>。<br>例如通配符<code>\*</code>的意思是任何类型, 而<code>\*.\*</code>的意思就是匹配所有的<code>Facility</code>和<code>Priority</code>。</p>
<p>举个例子, 一般默认的配置里都有一段规则：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cron.alert /var/<span class="hljs-built_in">log</span>/cron<br></code></pre></td></tr></table></figure>
<p>其中<code>corn.alert</code>就是规则中的<code>Facility</code>和<code>Priority</code>过滤器，其中<code>Facility</code>为cron的， <code>Priority</code>为alert， 一般来说就是crontab定期任务所产生的日志且任何等级等于或高于alert的日志（也就是代码值大于alert的日志等级）都会被指定的动作处理。<br>如果希望只处理定义等级的日志，而不处理高于这个等级的日志，可以使用等号（=），例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cron.=alert /var/<span class="hljs-built_in">log</span>/cron<br></code></pre></td></tr></table></figure>
<p>此外， 有一些子系统产生的日志可能没有Priority，那么可以使用关键字none，例如</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">news.none /var/<span class="hljs-built_in">log</span>/messages<br></code></pre></td></tr></table></figure>
<p>除了星号和等号，过滤器中还可以使用逗号（,）， 感叹号（!）和分号（；），逗号用于分隔多个Priority，而感叹号的作用是取反，例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cron.!info,!debug /var/<span class="hljs-built_in">log</span>/cron<br></code></pre></td></tr></table></figure>
<p>意思是除了info和debug等级的日志外，都写入到/var/log/cron中。<br>对于分号(;), 它表示或的意思, 如系统中的默认配置：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">*.=debug;\<br>    auth,authpriv.none;\<br>    news.none;mail.none -/var/<span class="hljs-built_in">log</span>/debug<br></code></pre></td></tr></table></figure>
<p>它表示的是<code>*.=debug</code>, <code>auth,authpriv.none</code>, <code>news.none</code>和<code>mail.none</code>四组过滤器都不要马上写入到<code>/var/log/debug</code>中。</p>
<h4 id="3-1-2-Property-based-过滤器"><a href="#3-1-2-Property-based-过滤器" class="headerlink" title="3.1.2.Property-based 过滤器"></a>3.1.2.Property-based 过滤器</h4><p><code>Property-based</code>过滤器是基于属性的过滤器，使我们可以根据不同的属性值进行日志处理。配置文件中常用的属性有：msg、hostname、fromhost、programname、timegenerated等。它的基本语法是:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basg">PROPERTY,[!]COMPARE_OPERATION,&quot;VALUE&quot;<br></code></pre></td></tr></table></figure>
<p>其中<code>PROPERTRY</code>为属性， <code>COMPARE_OPERATION</code>为操作符， <code>VALUE</code>为值</p>
<p>属性过滤器可用的操作符如下：</p>
<ul>
<li>contains 检查属性值是否包含指定的字符串（大小写敏感）</li>
<li>contains_i 和上面一样，但忽略大小写</li>
<li>isequal 属性值是否等于目标字符串</li>
<li>startswith 属性值是否以某字符串开头（大小写敏感）</li>
<li>startswith_i 如上，但忽略大小写</li>
<li>regex 正则表达式匹配</li>
<li>ereregex 使用扩展正则表达式匹配</li>
<li>isempty 属性值是否为空</li>
</ul>
<p>一个具体的例子是：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#日志信息中是否包含“error”字符串</span><br>:msg, contains, <span class="hljs-string">&quot;error&quot;</span> <br><span class="hljs-comment">#主机名称是否相等</span><br>:hostname, isequal, <span class="hljs-string">&quot;host1&quot;</span><br></code></pre></td></tr></table></figure>
<h4 id="3-1-3-Expression-based-过滤器"><a href="#3-1-3-Expression-based-过滤器" class="headerlink" title="3.1.3.Expression-based 过滤器"></a>3.1.3.Expression-based 过滤器</h4><p><code>Expression-based</code>过滤器是一个基于表达式的过滤器，这个表达式是一个条件表达式，即当满足特定条件的时候，执行指定的操作。<br>一般来说，表达式过滤器需要上面两种过滤器来结合使用。<br>基本语法如下(这里使用了新式语法)：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">if</span> expression_true <span class="hljs-keyword">then</span> action <span class="hljs-keyword">else</span> action<br></code></pre></td></tr></table></figure>
<p>else后续部分并不是必须的，它可以指定不满足条件的时候所执行的操作。<br>表达式中可用的操作符有：</p>
<ul>
<li>and、or、not</li>
<li>==、!=、&lt;&gt;、&lt;、&gt;、&lt;=、&gt;= （!=和&lt;&gt;的作用基本相等）</li>
<li>contains</li>
<li>startswith、startswith_i（case-insensitive）</li>
</ul>
<p>一些例子如下：：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#日志中包含error，保存到/var/log/errlog中</span><br><span class="hljs-keyword">if</span> <span class="hljs-variable">$msg</span> contains <span class="hljs-string">&#x27;error&#x27;</span> <span class="hljs-keyword">then</span> /var/<span class="hljs-built_in">log</span>/errlog<br><span class="hljs-comment">#如果要同时满足多个条件，使用and连接这些条件，整个表达式需要写在一行中</span><br><span class="hljs-keyword">if</span> <span class="hljs-variable">$syslogfacility</span>-text == <span class="hljs-string">&#x27;local0&#x27;</span> and <span class="hljs-variable">$msg</span> startswith <span class="hljs-string">&#x27;DEVNAME&#x27;</span> and (<span class="hljs-variable">$msg</span> contains <span class="hljs-string">&#x27;error1&#x27;</span> or <span class="hljs-variable">$msg</span> contains <span class="hljs-string">&#x27;error0&#x27;</span>) <span class="hljs-keyword">then</span> /var/<span class="hljs-built_in">log</span>/somelog<br><span class="hljs-keyword">if</span> <span class="hljs-variable">$syslogfacility</span>-text == <span class="hljs-string">&#x27;local0&#x27;</span> and <span class="hljs-variable">$msg</span> startswith <span class="hljs-string">&#x27;DEVNAME&#x27;</span> and not (<span class="hljs-variable">$msg</span> contains <span class="hljs-string">&#x27;error1&#x27;</span> or <span class="hljs-variable">$msg</span> contains <span class="hljs-string">&#x27;error0&#x27;</span>) <span class="hljs-keyword">then</span> /var/<span class="hljs-built_in">log</span>/somelog<br></code></pre></td></tr></table></figure>
<h3 id="3-1-4-动作"><a href="#3-1-4-动作" class="headerlink" title="3.1.4.动作"></a>3.1.4.动作</h3><p>在上面介绍过滤器时， 其中有一段关于分号(;)配置示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">*.=debug;\<br>    auth,authpriv.none;\<br>    news.none;mail.none -/var/<span class="hljs-built_in">log</span>/debug<br></code></pre></td></tr></table></figure>
<p>其中<code>/var/log/debug</code>前面的<code>-</code>就是一个动作, 表示日志不会马上写入到文件中，而是缓存到内存中。<br>常见的动作有:</p>
<ul>
<li>写入文件</li>
<li>转发到另一台服务器</li>
<li>写入数据库</li>
<li>丢弃</li>
<li>发送给用户</li>
</ul>
<p>如从<code>rsyslog</code>的默认配置:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">auth,authpriv.*	/var/<span class="hljs-built_in">log</span>/auth.log<br>*.*;auth,authpriv.none	-/var/<span class="hljs-built_in">log</span>/syslog<br>cron.*	/var/<span class="hljs-built_in">log</span>/cron.log<br>daemon.*	-/var/<span class="hljs-built_in">log</span>/daemon.log<br>kern.*	-/var/<span class="hljs-built_in">log</span>/kern.log<br>lpr.*	-/var/<span class="hljs-built_in">log</span>/lpr.log<br>mail.*	-/var/<span class="hljs-built_in">log</span>/mail.log<br>user.*	-/var/<span class="hljs-built_in">log</span>/user.log<br><br>*.emerg	:omusrmsg:*<br></code></pre></td></tr></table></figure>
<p>可以看出<code>rsyslog</code>会根据规则写入到各个指定的文件夹,动作前面有一个（-）横杠，表示日志不会马上写入到文件中，而是缓存到内存中，这样可以提高日志系统的性能，但有可能会造成日志的丢失;使用波浪符号（~）表示处理需要丢弃的日志。<br>而omusrmsg则表示会把消息转发给指定的用户,用户登录时就可以收到该消息.默认为全部用户,如果需要指定用户则如下编写:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bahs">*.emerg	:omusrmsg:root,so1n<br></code></pre></td></tr></table></figure>
<p>它代表会把消息发送给用户root以及我(so1n)</p>
<h3 id="3-1-5-输出"><a href="#3-1-5-输出" class="headerlink" title="3.1.5.输出"></a>3.1.5.输出</h3><p><code>rsyslog</code>的输出有多种， 比如上面介绍过滤器时， 它的动作是把日志写入到哪个文件以及通过配置写入到数据库， 此外它还支持把日志通过远程传输的方式传到别的服务器。 <code>rsyslog</code>提供三个远程日志传输方式：</p>
<ul>
<li><p>UDP: 基于传统UDP协议进行远程日志传输，也是传统syslog使用的传输协议；<br>可靠性比较低，但性能损耗最少， 在网络情况比较差， 或者接收服务器压力比较高情况下，可能存在丢日志情况。 仅在对日志完整性要求不是很高，以及在可靠的局域网环境下可以使用。</p>
</li>
<li><p>TCP: 基于传统TCP协议明文传输，需要回传进行确认，可靠性比较高；<br>但在接收服务器宕机或者两者之间网络出问题的情况下，会出现丢日志情况。<br>这种协议相比于UDP在可靠性方面已经好很多，并且rsyslog原生支持，配置简单，<br>同时针对可能丢日志情况，可以进行额外配置提高可靠性，因此使用比较广。</p>
</li>
<li><p>RELP: RELP（Reliable Event Logging Protocol）是基于TCP封装的可靠日志消息传输协议；<br>是为了解决<code>TCP</code>与<code>UDP</code>协议的缺点而在应用层实现的传输协议，也是三者之中最可靠的。 不过需要多安装一个包<code>rsyslog-relp</code>以支持该协议。</p>
</li>
</ul>
<p>远程传输需要更改客户端和服务端的配置， 首先是客户端配置, 客户端配置需要先配置对应的传输模块:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 使用udp传输模块</span><br>module(load=<span class="hljs-string">&quot;imudp&quot;</span>)<br><span class="hljs-comment"># 使用udp传输模块， 指定端口为514</span><br>input(<span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;imudp&quot;</span> port=<span class="hljs-string">&quot;514&quot;</span>)<br><br><span class="hljs-comment"># 使用tcp传输模块</span><br>module(load=<span class="hljs-string">&quot;imtcp&quot;</span>)<br><span class="hljs-comment"># 使用tcp传输模块， 指定端口为514</span><br>input(<span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;imtcp&quot;</span> port=<span class="hljs-string">&quot;514&quot;</span>)<br></code></pre></td></tr></table></figure>
<p>然后在动作那里配上如下格式</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">@[(zNUMBER)]HOST:[PORT]<br></code></pre></td></tr></table></figure>
<p>其中@代表udp(UDP 在主机名前加”@”;TCP 在主机名前加”@@”;RELP 在主机名前加”:omrelp:”),可选值zNUMBER设置了是否允许使用zlib对日志压缩（压缩级别1-9）。比如下面是一个使用relp发送的示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># local0.=warn,local1.* :omrelp:35.227.112.245:30514</span><br></code></pre></td></tr></table></figure>
<p>而服务端的配置也不复杂， 首先是UDP, 先在服务端创建配置文件：/etc/rsyslog.d/udp.conf</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># server configure</span><br><span class="hljs-variable">$ModLoad</span> imudp <span class="hljs-comment"># 加载模块</span><br><span class="hljs-variable">$UDPServerRun</span> 10514 <span class="hljs-comment"># 指定监听端口</span><br><span class="hljs-variable">$AllowedSender</span> UDP, 10.0.0.0/16 <span class="hljs-comment"># 设置白名单, 也就是客户端的IP</span><br><br><span class="hljs-comment"># 创建模板location和uformat</span><br><span class="hljs-comment"># location模板是根据客户端IP存放到不同目录下，以日期命名文件</span><br><span class="hljs-variable">$template</span> location,/data/%fromhost-ip%/%<span class="hljs-variable">$YEAR</span>%-%<span class="hljs-variable">$MONTH</span>%-%<span class="hljs-variable">$DAY</span>%.<span class="hljs-built_in">log</span><br><span class="hljs-comment"># uformat模板是自定义日志格式</span><br><span class="hljs-variable">$template</span> uformat,<span class="hljs-string">&quot;%fromhost-ip% %msg%\n&quot;</span><br><br><span class="hljs-comment"># 使用属性过滤器匹配非本地传输的日志， 然后执行动作， 这个动作使用了上面的模板， 也就是按照指定的文件路径及格式保存</span><br>:fromhost-ip, !isequal, <span class="hljs-string">&quot;127.0.0.1&quot;</span> -?location;uformat<br><span class="hljs-comment"># 最后一句指明了该日志已经被匹配过了， 不需要其他的动作队列处理， 其中&amp; 表示已经匹配处理的内容，~ 表示不再进行其他处理, 是stop元素的一个符号代替</span><br>&amp; ~<br></code></pre></td></tr></table></figure>
<p>接着就是TCP, 在服务端创建配置文件：/etc/rsyslog.d/tcp.conf</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># server configure</span><br><span class="hljs-variable">$ModLoad</span> imtcp <span class="hljs-comment"># 加载模块</span><br><span class="hljs-variable">$InputTCPServerRun</span> 20514 <span class="hljs-comment"># 指定监听端口</span><br><span class="hljs-variable">$AllowedSender</span> TCP, 10.0.0.0/16 <span class="hljs-comment"># 设置白名单</span><br><span class="hljs-comment"># 根据客户端IP存放到不同目录下，以日期命名文件</span><br><span class="hljs-variable">$template</span> location,<span class="hljs-string">&quot;/data/log/syslog/%fromhost-ip%.log&quot;</span><br><span class="hljs-comment"># 自定义日志格式</span><br><span class="hljs-variable">$template</span> uformat,<span class="hljs-string">&quot;%timestamp% %fromhost-ip% %rawmsg%\n&quot;</span><br><span class="hljs-comment"># 把非本地传输的日志按照指定的文件路径及格式保存</span><br>:fromhost-ip, !isequal, <span class="hljs-string">&quot;127.0.0.1&quot;</span> -?location;uformat<br><span class="hljs-comment"># &amp; 表示已经匹配处理的内容，stop 表示不再进行其他处理</span><br>&amp; stop<br></code></pre></td></tr></table></figure>
<p>最后是RELP, 首先需要在客户端和服务端安装RELP</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">apt-get update<br>apt-get -y install rsyslog-relp<br></code></pre></td></tr></table></figure>
<p>客户端需要额外加载模块</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">module(load=<span class="hljs-string">&quot;omrelp&quot;</span>)<br></code></pre></td></tr></table></figure>
<p>然后在服务端编辑配置（/etc/rsyslog.d/relp.conf）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># server configure</span><br><span class="hljs-variable">$ModLoad</span> imrelp    <span class="hljs-comment"># 加载模块</span><br><span class="hljs-variable">$InputRELPServerRun</span> 30514    <span class="hljs-comment"># 指定监听端口</span><br><span class="hljs-comment"># 根据客户端IP存放到不同目录下，以日期命名文件</span><br><span class="hljs-variable">$template</span> location,<span class="hljs-string">&quot;/data/log/syslog/%fromhost-ip%.log&quot;</span><br><span class="hljs-comment"># 自定义日志格式</span><br><span class="hljs-variable">$template</span> uformat,<span class="hljs-string">&quot;%timestamp% %fromhost-ip% %rawmsg%\n&quot;</span><br><span class="hljs-comment"># 把非本地传输的日志按照指定的文件路径及格式保存</span><br>:fromhost-ip, !isequal, <span class="hljs-string">&quot;127.0.0.1&quot;</span> -?location;uformat<br><span class="hljs-comment"># &amp; 表示已经匹配处理的内容，stop 表示不再进行其他处理</span><br>&amp; stop<br></code></pre></td></tr></table></figure>
<h4 id="3-1-6模板"><a href="#3-1-6模板" class="headerlink" title="3.1.6模板"></a>3.1.6模板</h4><p>模板<code>$template</code>常用于接收端, 可用来定义消息格式、文件名。 语法如下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-variable">$template</span> &lt;模板名&gt;,&lt;内容&gt;,&lt;可选项&gt;<br><span class="hljs-variable">$template</span> MyTemplateName,<span class="hljs-string">&quot;\7Text %property% some more text\n&quot;</span>,&lt;options&gt;<br></code></pre></td></tr></table></figure>
<p>其中内容可以使用模板变量， 比如一条消息格式如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;接收内容的时间&gt; &lt;发送者的hostname&gt; &lt;<span class="hljs-variable">$InputFileTag</span>&gt; &lt;原始消息%msg%&gt;<br>Dec 18 20:39:27 jumper-172-31-56-18 karltestdemoTag blala... dummy msg<br></code></pre></td></tr></table></figure>
<p>如果只需要显示原始消息，可设置</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-variable">$template</span> CleanMsgFormat,<span class="hljs-string">&quot;%msg%\n&quot;</span><br></code></pre></td></tr></table></figure>
<p>除了msg变量， 模板还支持很多变量,常见变量如下(<a target="_blank" rel="noopener" href="https://www.rsyslog.com/doc/v5-stable/configuration/properties.html">更多变量见官网文档</a>):</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">%msg%<br>%syslogfacility%<br>%HOSTNAME%<br>%syslogpriority%<br>%timereported:::date-mysql%<br>%timegenerated:::date-mysql%<br>%iut%<br><span class="hljs-string">&#x27;%syslogtag%&#x27;</span><br></code></pre></td></tr></table></figure>
<p>如果要生成动态文件名,并把日志写入该文件,那可以这样配置:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-variable">$template</span> DynamicFile,<span class="hljs-string">&quot;/var/log/test_logs/%timegenerated%-test.log&quot;</span>    <span class="hljs-comment"># timegenerated属性从日志信息中提取出消息的时间戳，这样可以为每个日志生成唯一文件名称。</span><br>*.* ?DynamicFile<br></code></pre></td></tr></table></figure>
<h4 id="3-1-7常用模块"><a href="#3-1-7常用模块" class="headerlink" title="3.1.7常用模块"></a>3.1.7常用模块</h4><p>上面我们看到服务端会通过引入模块来拓展输出模块的功能， 比如输出到本地文件或者输出到<code>Redis</code>,<code>Kafka</code>等等…</p>
<p><strong>imfile模块</strong></p>
<p>imfile模块主要解决的问题是将非syslog日志转为syslog日志<br>假设有个没有按照syslog协议生成的日志文件<code>/var/log/helloworld.log</code>, 下面将用<code>imfile</code>模块把它加载到<code>rsyslog</code>中并处理：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 加载imfile这个模块, 使用inotify模式来实时加载数据</span><br>module(load=<span class="hljs-string">&quot;imfile&quot;</span> mode=<span class="hljs-string">&quot;inotify&quot;</span> PollingInterval=<span class="hljs-string">&quot;1&quot;</span>)<br><span class="hljs-comment"># 指定输入端使用了imfile, 配置是日志文件路径以及tag, severity, facility这些参数</span><br>input(<span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;imfile&quot;</span> File=<span class="hljs-string">&quot;/var/log/helloworld.log&quot;</span> Tag=<span class="hljs-string">&quot;helloworld&quot;</span> Severity=<span class="hljs-string">&quot;error&quot;</span> Facility=<span class="hljs-string">&quot;local0&quot;</span>)<br><span class="hljs-comment"># 由于local有限,一般可以专门预留一个local用来接受带有Tag的日志,解决local不足的问题</span><br><span class="hljs-comment"># 将helloworld的应用日志发送到远程服务器</span><br>:programname, contains, <span class="hljs-string">&quot;helloworld&quot;</span> @192.168.1.2<br></code></pre></td></tr></table></figure>
<p>其他imfile配置如下,如果使用input做输入端,input的参数基本是以下配置的名称去掉input前缀,<br>更多配置见<a target="_blank" rel="noopener" href="https://www.rsyslog.com/doc/v8-stable/configuration/modules/imfile.html">官网</a></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-variable">$InputFileName</span> /path/to/file <span class="hljs-comment"># 待监控的文件路径</span><br><span class="hljs-variable">$InputFileTag</span> tag <span class="hljs-comment"># 文件唯一标识tag，最好保持唯一，用于接收端区分原始log文件，可以包含特殊字符，如&quot;:&quot;、&quot;,&quot;等 </span><br><span class="hljs-variable">$InputFileStateFile</span> /path/to/state/file<br><span class="hljs-comment"># 需要保证发送端唯一，记录读取到哪儿，状态文件保存在$WorkDirectory，默认为 /var/lib/rsyslog</span><br><span class="hljs-comment"># 如果某个要监控的文件名变化了，一定要重新设置该值</span><br><span class="hljs-variable">$InputFileFacility</span> facility <span class="hljs-comment"># log类型，默认local0， local开头的表示自定义类型</span><br><span class="hljs-variable">$InputFileSeverity</span> severity <span class="hljs-comment"># log级别：info，warning，默认notice</span><br><span class="hljs-variable">$InputRunFileMonitor</span> <span class="hljs-comment"># 启动监控当前的文件，如果忘记这行，则啥事也不会发生</span><br><span class="hljs-variable">$InputFilePollInterval</span> seconds <span class="hljs-comment"># 全局设置，默认轮询是10s</span><br><span class="hljs-variable">$InputFilePersistStateInterval</span> lines <span class="hljs-comment"># 每多少行更新state文件状态 </span><br><span class="hljs-variable">$InputFileMaxLinesAtOnce</span> number <span class="hljs-comment"># 默认10240，如果在发送端，需要同时监控多个文件，会处理完当前文件特定行后，切换到下一个文件，避免一个文件一直占用处理，导致收集别的文件不及时。</span><br><span class="hljs-variable">$InputFileBindRuleset</span> ruleset <span class="hljs-comment"># 绑定ruleset，可以把这个listener绑定到特点的规则(http://www.rsyslog.com/doc/v5-stable/concepts/multi_ruleset.html)</span><br></code></pre></td></tr></table></figure>
<p>在input的语法中stateFile参数已经不建议使用。原因在于，为了防止出现重复的state files，rsyslog会基于下面的规则自动生成这些文件：</p>
<ul>
<li>在具体的被监控文件前添加”imfile-state:”字符串</li>
<li>文件名前的反斜杠会被替换为短横杠。<br>尽量在文件刚生成时初始化日志,或者使用freshStartTail参数,然rsyslog并不建议使用该参数…</li>
</ul>
<p><strong>omprog模块</strong></p>
<p>omprog模块可以让日志通过管道的形式发送给程序(以每行日志分开发送),然后再由程序处理日志（类似于Map-Reduce）。</p>
<p>以下是官网的一个例子, 例子中该模块会根据配置执行Python程序,并通过stdin的形式发送到Python程序,Python程序会一直运行,等待数据的到来,如果收到数据则处理数据(这个例子是写入数据库), 如果程序终止,则重新启动,如果rsyslo终止,则程序的stdin会捕获到EOF,此时程序会终止.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 配置</span><br>module(load=<span class="hljs-string">&quot;omprog&quot;</span>)<br><br><span class="hljs-comment"># 省略了过滤器， 只说一下语法</span><br>action(<span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;omprog&quot;</span><br>       name=<span class="hljs-string">&quot;db_forward&quot;</span><br>       binary=<span class="hljs-string">&quot;/usr/share/logging/db_forward.py&quot;</span><br>       confirmMessages=<span class="hljs-string">&quot;on&quot;</span>  <span class="hljs-comment"># 它告诉rsyslog等待程序确认其初始化以及收到的每条消息。该设置的目的是防止由于数据库连接失败而导致日志丢失。如果程序无法将日志写入数据库，它将通过stdout向rsyslog返回否定确认</span><br>       confirmTimeout=<span class="hljs-string">&quot;30000&quot;</span>  <span class="hljs-comment"># 指定超时时间内未收到程序的响应，则rsyslog将终止并重新启动它</span><br>       queue.type=<span class="hljs-string">&quot;LinkedList&quot;</span><br>       queue.saveOnShutdown=<span class="hljs-string">&quot;on&quot;</span><br>       queue.workerThreads=<span class="hljs-string">&quot;5&quot;</span> <span class="hljs-comment"># 使用具有（最多）5个工作线程的专用磁盘辅助队列，以避免在高负载时影响其他日志目标</span><br>       action.resumeInterval=<span class="hljs-string">&quot;5&quot;</span> <span class="hljs-comment"># Rsyslog将失败的日志保留在队列中，并在5秒后再次将其发送给程序。</span><br>       killUnresponsive=<span class="hljs-string">&quot;on&quot;</span><br>       output=<span class="hljs-string">&quot;/var/log/db_forward.log&quot;</span>  <span class="hljs-comment"># 程序将错误详细信息写入stderr,rsyslog捕获并写入/var/log/db_forward.log</span><br>)<br></code></pre></td></tr></table></figure>
<p>除了使用模块接收日志,还可以用程序读取日志(建议用上inotify),或者开个端口接收日志</p>
<h3 id="3-2-各个日志文件简介"><a href="#3-2-各个日志文件简介" class="headerlink" title="3.2.各个日志文件简介"></a>3.2.各个日志文件简介</h3><ul>
<li><p>/var/log/secure：记录用户登陆系统的信息，比如SSH，telnet，ftp等记录</p>
</li>
<li><p>/var/log/btmp：记录登陆失败的信息，被编码过，所以必须使用last解析</p>
</li>
<li><p>/var/log/messages：在开机运行中几乎所有的系统发生的错误都在此记录。</p>
</li>
<li><p>/var/log/boot.log：记录一些开机或者关机启动的一些服务信息</p>
</li>
<li><p>/var/log/cron：用来记录crontab这个服务执行任务计划产生的日志</p>
</li>
<li><p>/var/log/utmp：记录现在登陆的用户</p>
</li>
<li><p>/var/log/dmesg：内核日志</p>
</li>
<li><p>/var/log/kern：内核产生的信息</p>
</li>
<li><p>/var/log/daemon.log：系统监控程序产生的日志。</p>
</li>
</ul>
<h3 id="3-3-队列"><a href="#3-3-队列" class="headerlink" title="3.3.队列"></a>3.3.队列</h3><p>队列是在rsyslog中我们在使用中最无感, 就像上面我们使用的语法中， 其实都用到了队列， 但是很难发现它的存在， 即便如此队列也是最重要的, 因为队列可以加速日志的传输,还会让传输更加可靠。<br><code>Rsyslog</code>中分为两种队列， 主队列和动作队列。</p>
<blockquote>
<p>以下内容大多数来源于<a target="_blank" rel="noopener" href="https://www.rsyslog.com/doc/master/concepts/queues.html">官方文档</a></p>
</blockquote>
<h4 id="3-3-1主队列"><a href="#3-3-1主队列" class="headerlink" title="3.3.1主队列"></a>3.3.1主队列</h4><p>一般日志进来到rsyslog时,都会先进入主队列,然后根据配置消费日志分发到各个队列以及执行动作,一般主队列的鲁棒性很强,我们都不用去修改他, 改改参数即可, 如使用下面命令可以告诉主消息队列在关闭时保存其内容:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-variable">$MainMsgQueueSaveOnShutdown</span> on<br></code></pre></td></tr></table></figure>
<h4 id="3-3-2动作队列"><a href="#3-3-2动作队列" class="headerlink" title="3.3.2动作队列"></a>3.3.2动作队列</h4><p>动作队列用于接受主队列的消息,并根据规则执行动作,一般与动作绑定在一起， <code>rsyslog</code>的动作队列有以下4种:</p>
<ul>
<li><p>Direct queue<br>该队列是默认队列,如果对action没进行配置,则默认采用该队列,该队列既不排队也不缓冲任何队列消息,而是直接将消息传给消费者。同时,该队列是唯一一个会把执行结果从消费者（action processor）返回给生产者的队列。通过这个返回值提醒action queue，让action queue取回这些处理失败的消息，如此循环，直到消息处理成功。</p>
</li>
<li><p>Disk queue<br>该队列使用硬盘进行缓冲,而不在内存中缓冲任何内容。因此该队列是超级可靠的，但到也是效率最慢的队列。正常情况下，不建议使用此队列模式。如果日志数据非常重要，为了确保在极端情况下也不能丢失，则可以使用该队列。<br>写入该队列时，它是分块完成的。每个块接收其各自的文件。文件以前缀命名（通过<code>$&lt;object&gt;QueueFilename</code>设置），后跟7位数字（从1开始，每个文件递增）。默认情况下，块为10mb，可通过<code>$&lt;object&gt;QueueMaxFileSize</code>设置不同的大小。不过，大小限制不是一个很严格的限制,因为rsyslog总是写一个完整的队列条目，即使它会比大小限制还大。因此，块实际上比配置的大小大一点（通常小于1k）,所以，每个块的大小都会不一样。<br>此外，每一个队列可以使用不同的位置保存数据，可以通过队列的$WorkDirectory指令设置，这个指令需要在队列创建之前配置。</p>
</li>
<li><p>memory queue （LinkedList/FixedArray）<br>这种类型的队列会把所有的消息都保存在内存中，因此它的处理速度非常快，缺点是当电脑关闭或死机的时候，所有未被处理的消息都会丢失。如果希望电脑关机的时候保存这些消息，可以设置变量<code>$&lt;Object&gt;QueueSaveOnShutdown</code>。</p>
<p>  memory queue队列拥有两种模式:</p>
<ul>
<li><p><code>FixedArray queue</code>: 预先分配一定的内存来保存这些消息，它的缺点是，无论你的日志有多少，它都需要完全占用这些内存；好处是当数据量不大的时候，它的性能是最好的。</p>
</li>
<li><p><code>LinkedList queue</code>: 内存是运行时分配的，会根据数据量的不同而作出调整，好处是内存利用率高，LinkedList队列适合使用在一些突发数据量大的场景。</p>
<p>如果不知道用哪个模式,建议使用LinkedList模式, 因为它与FixedArray相比，处理开销较低，并且可以通过减少内存使用量来弥补。在大多数不使用的指针数组页面中分页可能比动态分配它们慢得多。创建不同类型的队列方法为分别使用<code>$&lt;object&gt;QueueType LinkedList</code> or <code> /$&lt;object&gt;QueueType FixedArray</code>创建 LinkedLIst和FixesArray队列。</p>
</li>
</ul>
</li>
<li><p>Disk-Assisted In-memory queue<br>这种队列实际上是以内存队列为主，Disk Queue为辅的队列。在正常情况下，不会使用辅助的Disk queue，但当内存队列被填满，或者主机关闭的时候，Disk Queue就会被激活，数据被写入硬盘。结合两者使用，可以同时满足速度和数据的可靠性。</p>
</li>
</ul>
<p>设置队列的旧式语法如下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-variable">$ActionQueueType</span> LinkedList<br><span class="hljs-variable">$ActionQueueFileName</span> fileName<br><br><span class="hljs-comment">#还有另外两个参数设置</span><br>$&lt;Object&gt;QueueHighWatermark  <span class="hljs-comment">#当队列中的数据超过这个设置的值的时候，要么把数据保存，要么把数据丢弃，如果是Disk-Assisted In-memory Queue，队列中的数据超过这个值，Disk Queue就会被激活。</span><br>$&lt;Object&gt;QueueLowWatermark  <span class="hljs-comment">#和上面的相反，这是一个低水位设置，当数据小于这个值的时候，就停止相关的操作，如果是Disk-Assisted In-memory Queue，数据低于这个值，Disk Queue就会被取消激活状态。</span><br></code></pre></td></tr></table></figure>
<p>但是旧语法使用起来很奇怪， 我更喜欢使用新语法， 新式语法使用如下, action表示要执行的操作， 比如这个action指明要以什么方式发送， 发送到哪里， 这个action绑定的是哪个队列: </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">if</span> <span class="hljs-variable">$syslogfacility</span>-text == <span class="hljs-string">&#x27;local6&#x27;</span> <span class="hljs-keyword">then</span> action(<br>       <span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;omrelp&quot;</span>\ <br>       Target=<span class="hljs-string">&quot;127.0.0.1&quot;</span>\<br>       Port=<span class="hljs-string">&quot;30514&quot;</span>\<br>       queue.type=<span class="hljs-string">&quot;LinkedList&quot;</span>\<br>       queue.spoolDirectory=<span class="hljs-string">&quot;/var/spool/rsyslog&quot;</span>\<br>       queue.filename=<span class="hljs-string">&quot;demo&quot;</span>\<br>       queue.size=<span class="hljs-string">&quot;100000&quot;</span>\<br>       queue.maxdiskspace=<span class="hljs-string">&quot;1g&quot;</span>\<br>       queue.highwatermark=<span class="hljs-string">&quot;60000&quot;</span>\<br>       queue.lowwatermark=<span class="hljs-string">&quot;2000&quot;</span>\<br>       queue.discardmark=<span class="hljs-string">&quot;80000&quot;</span>\<br>       queue.timeoutenqueue=<span class="hljs-string">&quot;3000&quot;</span>\<br>       queue.maxfilesize=<span class="hljs-string">&quot;200m&quot;</span>\<br>       queue.dequeuebatchsize=<span class="hljs-string">&quot;1000&quot;</span>\<br>       queue.saveonshutdown=<span class="hljs-string">&quot;on&quot;</span>\<br>       action.resumeRetryCount=<span class="hljs-string">&quot;-1&quot;</span>\<br>)<br></code></pre></td></tr></table></figure>
<h4 id="3-3-3队列管理"><a href="#3-3-3队列管理" class="headerlink" title="3.3.3队列管理"></a>3.3.3队列管理</h4><p>队列的管理过程实际上是对队列的参数进行调优的过程。主队列的参数和动作队列的参数基本一样。这些参数必须在队列创建之后才能使用，每个不同的队列可以设置不同的数值，这些值在下一个队列创建之前被重置，前一个队列设置的值不会影响到下一个队列(如果使用新式队列， 则会与action绑定)。</p>
<ul>
<li><p>限制队列容量</p>
<ul>
<li><code>$&lt;Object&gt;QueueSize &lt;number&gt;</code></li>
<li><code>$&lt;Object&gt;QueueHighWaterMark &lt;number&gt;</code><br>两者之间有细微的差别 <code>$&lt;Object&gt;QueueSize</code>用于设置队列的总容量，即队列可容纳的消息数量。<br>而<code>$&lt;Object&gt;QueueHighWaterMark</code>只用于disk-assisted类型的队列，当队列中的消息数量达到这个值之后，消息就会被写入到硬盘。但是这种行为是有依赖性的，仅当日志的输出目标无法到达的时候（数据库无法访问，远程服务器离线等），它才会发生。</li>
</ul>
</li>
<li><p>丢弃消息</p>
<ul>
<li><code>$&lt;Object&gt;QueueDiscardMark</code>     设置队列的最高值,当队列中的消息达到这个指定的值时，消息就会被丢弃</li>
<li><code>$&lt;Object&gt;QueueDiscardSeverity</code>  设定要丢弃哪些日志消息(见rsyslog的 Priority)</li>
</ul>
</li>
<li><p>队列的终止<br>只有在系统被关闭的那一刻，队列才会被结束。当队列被终止的时候，队列中可能有数据尝试进入,rsyslog会试图处理这些数据,可以使用配置控制rsyslog的做法.</p>
<ul>
<li><code>$&lt;Object&gt;QueueTimeoutShutdown &lt;milliseconds&gt;</code>  队列会仍然去处理这些数据,当队列关闭时间超过这个值，队列中的所有数据被丢弃</li>
<li><code>$&lt;Object&gt;QueueTimeoutActionCompletion</code> 只处理当前被处理的消息,其他的消息全部被抛弃</li>
<li><code>$&lt;Object&gt;QueueSaveOnShutdown</code> 不丢弃任何消息且队列是Disk-Queue或者Disk-assisted-Queue  </li>
</ul>
</li>
</ul>
<h3 id="3-4Ruleset"><a href="#3-4Ruleset" class="headerlink" title="3.4Ruleset"></a>3.4Ruleset</h3><p>Ruleset就是多个规则的集合，当消息进来后<code>rsyslogd</code>会从ruleset的第一条规则开始处理，直到这个ruleset的最后一条规则或者是设置了终止标记。rsyslogd有一个默认的Ruleset，名为<code>RSYSLOG_DefaultRuleset</code>, 它的使用方法如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-variable">$template</span> Centos7Server,<span class="hljs-string">&quot;/var/log/%hostname%/messages-%<span class="hljs-variable">$now</span>%.log&quot;</span><br><span class="hljs-variable">$RuleSet</span> remote<br>*.* ?Centos7Server<br> <br><span class="hljs-variable">$RuleSet</span> RSYSLOG_DefaultRuleset<br></code></pre></td></tr></table></figure>
<p>这个方法先创建了一个名叫remote的Ruleset，规则中使用了一个预先定义的模板。最后切换回默认的Ruleset，不切换回去的话,后面的配置就还是remote Ruleset。</p>
<p>多个Ruleset的使用场景在于区分本地写日志和网络传日志.<br>本地通过$DefaultRuleset命令指定Ruleset,而利用TCP传输模块可以通过如下方法设置规则如下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-variable">$ModLoad</span> imtcp<br><span class="hljs-variable">$InputTCPServerBindRuleset</span> remote <span class="hljs-comment">#绑定自定以的Ruleset</span><br><span class="hljs-variable">$InputTCPServerRun</span> 514<br></code></pre></td></tr></table></figure>
<p>这时走TCP的日志就会使用remote Rules,如果是正常启用TCP传输日志,那么会走DefaultRuleset指定的ruleset,因为没有使用InputTCPServerBindRuleset去覆盖Ruleset.<br>如果有多个端口传输日志,每个端口的ruleset不同,那可以利用InputTCPServerBindRuleset 的覆盖性进行如下配置:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-variable">$InputTCPServerBindRuleset</span> remote10001<br><span class="hljs-variable">$InputTCPServerRun</span> 10001<br> <br><span class="hljs-variable">$InputTCPServerBindRuleset</span> remote10002<br><span class="hljs-variable">$InputTCPServerRun</span> 10002<br> <br><span class="hljs-variable">$InputTCPServerBindRuleset</span> remote10003<br><span class="hljs-variable">$InputTCPServerRun</span> 10003<br></code></pre></td></tr></table></figure>
<p>但是我会更喜欢用新式语法写rule。</p>
<h3 id="3-5-RainerScript"><a href="#3-5-RainerScript" class="headerlink" title="3.5.RainerScript"></a>3.5.RainerScript</h3><p>上面的介绍中我经常说新式语法和旧式语法， 其中新式语法的名字就叫<code>RainerScript</code>它是一个比较新的配置语言, 具有更紧凑的语法，使配置过程更加清晰，更不容易出错, 同时能支持复用， 让人觉得更像在写一个变成语言， 在上面有些情况我已经用了新式的语法了, 下面看看新式语法的区别：</p>
<ul>
<li><p>加载模块</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 旧语法</span><br><span class="hljs-variable">$ModLoad</span> imtcp<br><span class="hljs-comment"># 新语法</span><br>module(load=<span class="hljs-string">&quot;imtcp&quot;</span>)<br></code></pre></td></tr></table></figure></li>
<li><p>input</p>
<p>  上面已经有使用imfile的例子了,这里就不多阐述</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 旧语法</span><br><span class="hljs-variable">$ModLoad</span> imfile <span class="hljs-comment">#导入模块</span><br><span class="hljs-variable">$InputFileName</span> /var/<span class="hljs-built_in">log</span>/nginx/access.log <span class="hljs-comment">#需要导入的文件</span><br><span class="hljs-variable">$InputFileTag</span> ng-acc <span class="hljs-comment">#添加标签名称</span><br><span class="hljs-variable">$InputFilePersistStateInterval</span> 10 <span class="hljs-comment">#多久处理一次追踪文件</span><br><span class="hljs-variable">$InputFileStateFile</span> state-ng-acc<br><span class="hljs-variable">$InputRunFileMonitor</span> <span class="hljs-comment">#开始监控文件</span><br><span class="hljs-comment"># 新语法</span><br>module(load=<span class="hljs-string">&quot;builtin:imfile&quot;</span>)<br>input(Type=<span class="hljs-string">&quot;imfile&quot;</span> File=<span class="hljs-string">&quot;/var/log/nginx/access.log&quot;</span> Tag=<span class="hljs-string">&quot;ng-acc&quot;</span>PersistStateInterval=10)<br></code></pre></td></tr></table></figure></li>
<li><p>action</p>
<p>  action是输出模块,包括了结构图里的action和队列</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 旧语法</span><br>*.* /var/<span class="hljs-built_in">log</span>/messages<br><span class="hljs-comment"># 新语法</span><br>*.* action(Type=<span class="hljs-string">&quot;omfile&quot;</span> File=<span class="hljs-string">&quot;/var/log/messages&quot;</span>)<br><span class="hljs-comment"># 包含队列的新语法</span><br>action(<span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;ommysql&quot;</span> server=<span class="hljs-string">&quot;localhost&quot;</span> db=<span class="hljs-string">&quot;Syslog&quot;</span> uid=<span class="hljs-string">&quot;root&quot;</span> <span class="hljs-built_in">pwd</span>=<span class="hljs-string">&quot;password&quot;</span>\<br>queue.type=<span class="hljs-string">&quot;LinkedList&quot;</span> queue.filename=<span class="hljs-string">&quot;name&quot;</span> queue.saveonshutdown=<span class="hljs-string">&quot;on&quot;</span>\<br>action.resumeRetryCount=<span class="hljs-string">&quot;-1&quot;</span><br></code></pre></td></tr></table></figure></li>
<li><p>template</p>
<p>  新的template对象提供了两种常用的模板定义方式，一种是string，另一种是list。string方式比较接近旧template的定义方式，而list方式可以更清晰的区分字符串和属性值。</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 旧语法</span><br><span class="hljs-variable">$template</span> remote, <span class="hljs-string">&quot;message from %hostname%, received at %timegenerated%.&quot;</span><br><span class="hljs-comment"># 新语法string</span><br>template(namme=<span class="hljs-string">&quot;remote&quot;</span> <span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;string&quot;</span> string=<span class="hljs-string">&quot;message from %hostname%, received at %timegenerated%.&quot;</span>)<br><span class="hljs-comment"># 新语法list</span><br><span class="hljs-comment"># constant用于定义字面字符串值，而property用于定义实际的属性</span><br>template(name=<span class="hljs-string">&quot;dbFormat&quot;</span> <span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;list&quot;</span> option.sql=<span class="hljs-string">&quot;on&quot;</span>) &#123;<br>    constant(value=<span class="hljs-string">&quot;insert into SystemEvents (Message, FromHost,ReceivedAt)&quot;</span>)<br>    constant(value=<span class="hljs-string">&quot; values (&#x27;&quot;</span>)<br>    property(name=<span class="hljs-string">&quot;msg&quot;</span>)<br>    constant(value=<span class="hljs-string">&quot;, &#x27;&quot;</span>)<br>    property(name=<span class="hljs-string">&quot;hostname&quot;</span>)<br>    constant(value=<span class="hljs-string">&quot;&#x27;, &#x27;&quot;</span>)<br>    property(name=<span class="hljs-string">&quot;timegenerated&quot;</span> dateFormat=<span class="hljs-string">&quot;mysql&quot;</span>)<br>    constant(value=<span class="hljs-string">&quot;&#x27;)&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>ruleset</p>
<p>  ruleset推荐用新的语法,比原来的清晰了很多。</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 旧语法</span><br><span class="hljs-variable">$Ruleset</span> remote<br>mail.none /var/<span class="hljs-built_in">log</span>/mail.log<br>cron.none /var/<span class="hljs-built_in">log</span>/cron.log<br><br><span class="hljs-variable">$ModLoad</span> imtcp<br><span class="hljs-variable">$InputTCPBindRuleset</span> remote<br><span class="hljs-variable">$InputTCPServerRun</span> 514<br><span class="hljs-comment"># 新语法</span><br>ruleset(name=<span class="hljs-string">&quot;remote-514&quot;</span>) &#123;<br>cron.none action(<span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;omfile&quot;</span> file=<span class="hljs-string">&quot;/var/log/remote-514-cron&quot;</span>)<br>mail.none action(<span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;omfile&quot;</span> file=<span class="hljs-string">&quot;/var/log/remote-514-mail&quot;</span>)<br>&#125;<br><br>input(<span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;imtcp&quot;</span> port=<span class="hljs-string">&quot;514&quot;</span> ruleset=<span class="hljs-string">&quot;remote-514&quot;</span>);<br></code></pre></td></tr></table></figure>
<h2 id="4-日志轮转–Logrotate"><a href="#4-日志轮转–Logrotate" class="headerlink" title="4.日志轮转–Logrotate"></a>4.日志轮转–Logrotate</h2><p>在查看日志时我们很容易就发现出现有命名类似于syslog syslog.1 syslog.2.gz等类型的日志,这些日志都是靠<code>Logrotate</code>进行日志轮转的,方便我们对日志进行查找和管理。<br><code>Logrotate</code>的主脚本位于<code>/etc/cron.daily/logrotate</code>， 它不会自动运行， 而是通过contab定时运行脚本执行日志轮转。 <code>Logrotate</code>不止可以针对系统日志, 还可以使一些应用本身不带日志轮转功能,或者本身日志轮换功能残缺的应用(对就是说Supervisor)拥有完善,高自定义的日志轮转功能。</p>
<blockquote>
<p>如果多个程序（多个进程）写入到同一个日志文件，那请不要使用程序自己的轮转来轮转日志， 不然会出现丢数据的情况。建议所有的日志轮转都使用<code>Logrotate</code></p>
</blockquote>
</li>
</ul>
<p><code>Logrotate</code>实际运行时，会调用配置文件<code>/etc/logrotate.conf</code>。我们除了修改<code>/etc/logrotate.conf</code>文件外， 还可以在<code>/etc/logrotate.d</code>目录里放置自定义好的配置文件，用来覆盖Logrotate的缺省值。<br>同时， 这些脚本我们也可以手动执行, 不过要记得添加-f参数,表示强制轮转, 否则<code>Logrotate</code>会判断还没达到条件而不执行轮转。此外， 手动运行时最好要添加-d参数来测试配置文件是否有错误,常用参数如下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">logrotate [OPTION...] &lt;configfile&gt;<br>-d, --debug ：debug模式，测试配置文件是否有错误。<br>-f, --force ：强制转储文件。<br>-m, --mail=<span class="hljs-built_in">command</span> ：压缩日志后，发送日志到指定邮箱。<br>-s, --state=statefile ：使用指定的状态文件。<br>-v, --verbose ：显示转储过程。<br></code></pre></td></tr></table></figure>
<p><code>Logrotate</code>的原理是检查日志是否需要轮转, 以及在轮转后使进程重新打开文件描述符(有两种方法， 最优的方法是发送信号量, 不过需要程序支持), 确保进程能重新打开文件，写入到新的文件。</p>
<blockquote>
<p>如果程序不支持信号量重载日志文件描述符的方法， 那就只能在脚本启用copytruncate，该方法会直接把文本的内容复制到新的文件后再清空当前的日志文件， 如果文件的数据量过高则有可能漏掉一些日志。</p>
</blockquote>
<p>一般来说,我们只要在/etc/logrotate.d/目录下配置针对某个日志的日志文件轮转配置就可以了, 这个配置文件主要是声明要轮换的日志文件路径以及花括号内配置轮转属性, 以<code>Nginx</code>为例子:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 匹配Nginx的所有日志</span><br>/usr/<span class="hljs-built_in">local</span>/nginx/logs/*<span class="hljs-built_in">log</span> &#123;<br>    daily<br>    <span class="hljs-comment"># 每天转储</span><br>    rotate 30<br>    <span class="hljs-comment"># 只保存30个备份</span><br>    missingok<br>    <span class="hljs-comment"># 在日志转储期间,任何错误将被忽略</span><br>    notifempty<br>    <span class="hljs-comment"># 文件为空时不转储</span><br>    compress<br>    <span class="hljs-comment"># 通过 gzip 压缩</span><br>    dateext<br>    <span class="hljs-comment"># 日志文件以当前日期为格式结尾</span><br>    sharedscripts<br>    <span class="hljs-comment"># 所有日志文件转储完毕后执行一次脚本</span><br>    postrotate<br>    <span class="hljs-comment"># 转储之后执行命令, 和endscript成对使用</span><br>    <span class="hljs-comment"># 该命令使nginx重新打开日志文件描述符，</span><br>        /bin/<span class="hljs-built_in">kill</span> -USR1 \$(cat /usr/<span class="hljs-built_in">local</span>/nginx/logs/nginx.pid 2&gt;/dev/null) 2&gt;/dev/null || :<br>    endscript<br>    <span class="hljs-comment"># 转储之后执行命令，和postrotate成对使用</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>此外， 如果像<code>rsyslog</code>一样控制的日志比较多,可以像以下这样配置,多个日志文件多行显示,并同样的用花括号把配置包起来</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash">/var/<span class="hljs-built_in">log</span>/mail<br>/var/<span class="hljs-built_in">log</span>/messages<br>/var/<span class="hljs-built_in">log</span>/syslog<br>&#123;<br>    sharedscripts<br>    dateext<br>    rotate 25<br>    size 40M<br>    compress<br>    dateformat -%Y%m%d%s<br>    postrotate<br>            /bin/<span class="hljs-built_in">kill</span> -HUP `cat /var/run/syslogd.pid 2&gt; /dev/null` 2&gt; /dev/null || <span class="hljs-literal">true</span><br>    endscript<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="4-1logrotate参数"><a href="#4-1logrotate参数" class="headerlink" title="4.1logrotate参数"></a>4.1logrotate参数</h3><p><code>Logrotate</code>的主要使用也是以配置为主,需要注意一些配置, 不然logrotate会以文件太小或者时间间隔比较低(如配置1天轮转一次,logrotate首次轮转可能要间隔两天)而不进行轮转<br>| 参数 | 描述 |<br>| ———————– | ———————————————————— |<br>|dateext |  切换后的日志文件会附加上一个短横线和YYYYMMDD格式的日期，没有这个配置项会附加一个小数点加一个数字序号.|<br>|dateformat | 配合dateext使用可以为切割后的日志加上YYYYMMDD格式的日期，如dateformat -%Y%m%d|<br>| compress | 通过gzip 压缩转储以后的日志 |<br>| nocompress | 不需要压缩时，用这个参数 |<br>| copytruncate | 用于还在打开中的日志文件，把当前日志备份并截断 |<br>| nocopytruncate | 备份日志文件但是不截断 |<br>| create mode owner group | 转储文件，使用指定的文件模式创建新的日志文件 |<br>| nocreate | 不建立新的日志文件 |<br>| delaycompress | 一起使用时，转储的日志文件到下一次转储时才压缩 |<br>| nodelaycompress | 覆盖 delaycompress 选项，转储同时压缩。 |<br>| errors address | 专储时的错误信息发送到指定的Email 地址 |<br>| ifempty | 即使是空文件也转储，这个是 logrotate 的缺省选项。 |<br>| notifempty | 如果是空文件的话，不转储 |<br>| mail address | 把转储的日志文件发送到指定的E-mail 地址 |<br>| nomail | 转储时不发送日志文件 |<br>| olddir directory | 转储后的日志文件放入指定的目录，必须和当前日志文件在同一个文件系统 |<br>| noolddir | 转储后的日志文件和当前日志文件放在同一个目录下 |<br>|sharedscripts  | 运行postrotate脚本，作用是在所有日志都轮转后统一执行一次脚本。如果没有配置这个，那么每个日志轮转后都会执行一次脚本 |<br>| prerotate/endscript | 在转储以前需要执行的命令可以放入这个对，这两个关键字必须单独成行 |<br>| postrotate/endscript | 在转储以后需要执行的命令可以放入这个对，这两个关键字必须单独成行 |<br>| daily | 指定转储周期为每天 |<br>| weekly | 指定转储周期为每周 |<br>| monthly | 指定转储周期为每月 |<br>| rotate count | 指定日志文件删除之前转储的次数，0 指没有备份，5 指保留5 个备份 |<br>| tabootext [+] list | 让logrotate 不转储指定扩展名的文件，缺省的扩展名是：.rpm-orig, .rpmsave, v, 和 ~ |<br>| size size | 当日志文件到达指定的大小时才转储，后缀MB. |</p>
<h2 id="5-一些常见坑"><a href="#5-一些常见坑" class="headerlink" title="5.一些常见坑"></a>5.一些常见坑</h2><p>可以看到整套日志流程涉及多个流程和多种参数， 所以容易因为参数导致出现一些问题， 以下是我遇到的几个问题和解决办法：</p>
<ul>
<li>log太长了,被截断;<br>这是由于被$MaxMessageSize限制的,它的默认大小是2k，大概可以保存1000个中文字符,在加载<code>imtcp/imudp</code>之前设置， 此配置包括发送和接收，所以rsyslog客户端、服务端都要设置</li>
<li>如果一行日志消息大小大于4K,只能用TCP。这是因为UDP栈大小限制的。</li>
<li>某个系统日志文件过大;<br>像用debian的话,可以看到/var/log/syslog会随着你的配置,里面的东西越来越多,主要要对该行默认配置进行修改,不然所有日志都会发送到这里了(以定义了local5,6为例子)  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">*.info;mail.none;authpriv.none;cron.none /var/<span class="hljs-built_in">log</span>/syslog<br>*.info;mail.none;authpriv.none;cron.none;local5.none;local6.none /var/<span class="hljs-built_in">log</span>/messages<br></code></pre></td></tr></table></figure></li>
<li>接收端保存的文件路径不对; 主要是用到了tag, 且他们两个tag有共同的前缀导致匹配出错，解决办法是调整顺序， 把长的放在前面, 比如如下配置：  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># For erp_wms</span><br><span class="hljs-variable">$template</span> erp_wms_FileFormat,<span class="hljs-string">&quot;/Data/logs/erp/wms/%fromhost-ip%/%syslogtag:F,44:2%-%<span class="hljs-variable">$YEAR</span>%%<span class="hljs-variable">$MONTH</span>%%<span class="hljs-variable">$DAY</span>%.log&quot;</span><br><span class="hljs-keyword">if</span> <span class="hljs-variable">$syslogtag</span> startswith <span class="hljs-string">&#x27;erp_wms&#x27;</span> <span class="hljs-keyword">then</span> ?erp_wms_FileFormat;CleanMsgFormat<br>&amp; ~<br><br><span class="hljs-comment"># For erp_wms3</span><br><span class="hljs-variable">$template</span> erp_wms3_FileFormat,<span class="hljs-string">&quot;/Data/logs/erp/wms3/%fromhost-ip%/%syslogtag:F,44:2%-%<span class="hljs-variable">$YEAR</span>%%<span class="hljs-variable">$MONTH</span>%%<span class="hljs-variable">$DAY</span>%.log&quot;</span><br><span class="hljs-keyword">if</span> <span class="hljs-variable">$syslogtag</span> startswith <span class="hljs-string">&#x27;erp_wms3&#x27;</span> <span class="hljs-keyword">then</span> ?erp_wms3_FileFormat;CleanMsgFormat<br>&amp; ~<br></code></pre></td></tr></table></figure>
  修改后  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 这里注意下面的tag的顺序， 一定要让长的tag（erp_wms3）保持在上面，因为他们有共同的前缀(erp_wms)</span><br><span class="hljs-comment"># For erp_wms3</span><br><span class="hljs-variable">$template</span> erp_wms3_FileFormat,<span class="hljs-string">&quot;/Data/logs/erp/wms3/%fromhost-ip%/%syslogtag:F,44:2%-%<span class="hljs-variable">$YEAR</span>%%<span class="hljs-variable">$MONTH</span>%%<span class="hljs-variable">$DAY</span>%.log&quot;</span><br><span class="hljs-keyword">if</span> <span class="hljs-variable">$syslogtag</span> startswith <span class="hljs-string">&#x27;erp_wms3&#x27;</span> <span class="hljs-keyword">then</span> ?erp_wms3_FileFormat;CleanMsgFormat<br>&amp; ~<br><br><span class="hljs-comment"># For erp_wms</span><br><span class="hljs-variable">$template</span> erp_wms_FileFormat,<span class="hljs-string">&quot;/Data/logs/erp/wms/%fromhost-ip%/%syslogtag:F,44:2%-%<span class="hljs-variable">$YEAR</span>%%<span class="hljs-variable">$MONTH</span>%%<span class="hljs-variable">$DAY</span>%.log&quot;</span><br><span class="hljs-keyword">if</span> <span class="hljs-variable">$syslogtag</span> startswith <span class="hljs-string">&#x27;erp_wms&#x27;</span> <span class="hljs-keyword">then</span> ?erp_wms_FileFormat;CleanMsgFormat<br>&amp; ~<br></code></pre></td></tr></table></figure></li>
<li>接收端<code>rsyslog</code>文件名太长后被截断, 这个一般是发送端的配置造成的， 如以下发送端默认配置：  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">template (name=<span class="hljs-string">&quot;ForwardFormat&quot;</span> <span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;string&quot;</span> string=<span class="hljs-string">&quot;&lt;%PRI%&gt;%TIMESTAMP:::date-rfc3339% %HOSTNAME%</span><br><span class="hljs-string">%syslogtag:1:32%%msg:::sp-if-no-1st-sp%%msg%&quot;</span>)<br></code></pre></td></tr></table></figure>
  中的<code>%syslogtag:1:32%</code>限制了文件名长度,所以需要发送端重新绑定到一个新的模板<h2 id="6-常见rsyslog不记日志问题"><a href="#6-常见rsyslog不记日志问题" class="headerlink" title="6.常见rsyslog不记日志问题"></a>6.常见rsyslog不记日志问题</h2>前记里说过， 我是因为遇到日志写入缺少时才开始查看整个Linux的日志机制， 在查阅资料后我总结了以下几个不记日志的原因：</li>
<li>1.<code>OOM kernel</code>不能及时释放cache来满足应用程序的突发内存需求的情况。</li>
<li>2.系统内存严重不够或者Rsyslog限制了它将在内存中保留的消息数量。如果该消息大于系统中的内存，则需要调整它。要么给机器更多内存，要么将rsyslog配置为更小的队列大小。</li>
<li>3.jounald配置问题， 数据只暂存于内存中， 且由于系统内存不够导致部分日志被删除了。</li>
<li>4.回车控制符(来源于网络,没遇到过)<br>有可能是由于某用户的debug或者info log中，包含了回车控制符\n，而我们rsyslog client段的配置文件中EscapeControlCharactersOnReceive是off的，即不对控制符做转义，所以含有\n控制符的log被发送给了rsyslog center。而rsyslog center是根据回车控制符\n来判断是不是一条log的。如果用户的log中包含类似字段：GET /123/id=123&amp;\n90887294–sdf，那么rsyslog会把”GET /123/id=123&amp;“当作一条log，而把90887294作为下一条message的长度，并且会有刚才的Framing Error的报错。rsyslog会等待接收90887294byte的数据，然后判断大于了MaxMessageSize 4KB，然后rsyslog就只保存了从90887294开始之后的4KB日志，剩下的90887294 - 4*1024= 90883198byte的数据全被截断丢弃。这就有了received oversize message的报错。<br>解决办法：  <figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs vim">issues：http<span class="hljs-variable">s:</span>//github.<span class="hljs-keyword">com</span>/rsyslog/rsyslog/issues/<span class="hljs-number">111</span><br><span class="hljs-number">1</span>,开启rsyslog client的EscapeControlCharactersOnReceive为<span class="hljs-keyword">on</span>状态。对回车控制符进行转义，即可避免此问题<br>影响：把用户<span class="hljs-built_in">log</span>中的\n转换成了以#开头的三位八进制数#<span class="hljs-number">012</span>。（根基<span class="hljs-keyword">ascii</span>表转换）<br><span class="hljs-number">2</span>,关闭rsyslog <span class="hljs-keyword">center</span>的SupportOctetCountedFraming为off状态。即不支持Octet数据流。<br>影响：当用户<span class="hljs-built_in">log</span>中有\n的时候，<span class="hljs-built_in">log</span>会被截断。<br></code></pre></td></tr></table></figure></li>
<li>5.rsyslog 性能跟不上导致丢日志，需要进行调优如对rsyslog的main queue和action queue进行调优<h2 id="7-附录A-用python发送日志到syslog"><a href="#7-附录A-用python发送日志到syslog" class="headerlink" title="7.附录A:用python发送日志到syslog"></a>7.附录A:用python发送日志到syslog</h2><code>Python</code>的logging模块除了自己输出日志外， 也兼容Linux的日志机制。 修改方法也十分简单， 只需要对logger进行一些小修改， 就可以把日志发向<code>/dev/log/</code>从而被<code>rsyslog</code>捕获到日志, 以下是一个普通的logging代码:<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-comment"># 初始化logger</span><br>logger = logging.getLogger(<span class="hljs-string">&#x27;exp&#x27;</span>)<br>logger.setLevel(logging.INFO)<br><span class="hljs-comment"># 初始化handler</span><br>filehandler = logging.FileHandler(os.environ[<span class="hljs-string">&#x27;HOME&#x27;</span>] + <span class="hljs-string">&#x27;/exp.log&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf8&#x27;</span>)<br>filehandler.setFormatter(logging.Formatter(<span class="hljs-string">&quot;%(asctime)s - %(levelname)s - %(message)s&quot;</span>))<br>logger.addHandler(filehandler)<br></code></pre></td></tr></table></figure>
进行以下修改后， 他就可以发送到<code>rsyslog</code>了:<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-comment"># 初始化logger</span><br>logger = logging.getLogger(<span class="hljs-string">&#x27;exp&#x27;</span>)<br>logger.setLevel(logging.INFO)<br><span class="hljs-comment"># 初始化handler, 这个handler是sysloghandle， 且定义了输出是本机的/dev/log, 还定义了一些syslog参数</span><br>sys_handler = logging.handlers.SysLogHandler(<span class="hljs-string">&#x27;/dev/log&#x27;</span>, facility=logging.handlers.SysLogHandler.LOG_LOCAL0)<br>sys_handler.setFormatter(logging.Formatter(<span class="hljs-string">&#x27;exp_log&#x27;</span> + <span class="hljs-string">&quot;:%(asctime)s - %(name)s - %(levelname)s - %(message)s&quot;</span>))<br>logger.addHandler(sys_handler)<br></code></pre></td></tr></table></figure>
另外,如果你想用python读日志的话也可以直接监听/dev/log/再打印日志<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> socket<br><span class="hljs-keyword">import</span> time<br>sock = socket.socket(socket.AF_UNIX, socket.SOCK_DGRAM)<br>sock.bind(<span class="hljs-string">&#x27;/dev/log&#x27;</span>) <span class="hljs-comment">#需要先手动kill掉已经在运行的[r]syslogd进程，否则这里无法执行成功</span><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    time.sleep(<span class="hljs-number">5</span>)<br>    data, addr = sock.recvfrom(<span class="hljs-number">1024</span>)<br>    print(data)<br></code></pre></td></tr></table></figure></li>
</ul>
      </section>
      <section class="extra">
        
          <ul class="copyright">
  
    <li><strong>本文作者：</strong>So1n</li>
    <li><strong>本文链接：</strong><a href="http://so1n.me/2019/12/05/linux%E6%97%A5%E5%BF%97%E6%9C%BA%E5%88%B6/index.html" title="http:&#x2F;&#x2F;so1n.me&#x2F;2019&#x2F;12&#x2F;05&#x2F;linux%E6%97%A5%E5%BF%97%E6%9C%BA%E5%88%B6&#x2F;index.html">http:&#x2F;&#x2F;so1n.me&#x2F;2019&#x2F;12&#x2F;05&#x2F;linux%E6%97%A5%E5%BF%97%E6%9C%BA%E5%88%B6&#x2F;index.html</a></li>
    <li><strong>版权声明：</strong>本博客所有文章均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" title="BY-NC-SA" target="_blank" rel="noopener">BY-NC-SA</a> 许可协议，转载请注明出处！</li>
  
</ul>
        
        
          <section class="donate">
  <div id="qrcode-donate">
    <img src="https://github.com/so1n/so1n_blog_photo/blob/master/blog_photo/4d2ebf32586d8799ee2e75333d6f5d2.jpg?raw=true">
  </div>
  <div class="icon">
    <a href="javascript:;" id="alipay"><i class="iconfont iconalipay"></i></a>
    <a href="javascript:;" id="wechat"><i class="iconfont iconwechat-fill"></i></a>
  </div>
</section>
        
        
  <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/" rel="tag">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Rsyslog/" rel="tag">Rsyslog</a></li></ul> 

        
  <nav class="nav">
    <a href="/2019/12/16/Python%E7%9A%84Dict%E5%AE%9E%E7%8E%B0/"><i class="iconfont iconleft"></i>Python的Dict实现</a>
    <a href="/2019/11/03/logrotate/">Linux日志--logrotate<i class="iconfont iconright"></i></a>
  </nav>

      </section>
      
        <section class="comments">
  
    <div class="btn" id="comments-btn">查看评论</div>
  
  
<link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<div id="gitalk" class="gitalk"></div>
<script defer src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
<script>
  window.onload = function () {
    var gitalk = new Gitalk({
      clientID: '59f804e526b05c378470',
      clientSecret: '36679ff697cec424936a0f7c4bcd6d2988dac28e',
      id: window.location.pathname,
      repo: 'so1n.github.io',
      owner: 'so1n',
      admin: 'so1n'
    });
    if ( true ) {
      $("#comments-btn").on("click", function () {
        $(this).hide();
        gitalk.render('gitalk');
      });
    } else {
      gitalk.render('gitalk');
    }
  }
</script>

</section>
      
    </section>
  </div>
</article>
</div>
      <div class="col-xl-3">
          
  <aside class="toc-wrap">
    <h3 class="toc-title">文章目录：</h3>
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%AE%B0"><span class="toc-text">前记</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Linux%E4%B8%AD%E6%97%A5%E5%BF%97%E7%9A%84%E5%8F%91%E9%80%81%E6%B5%81%E7%A8%8B"><span class="toc-text">1.Linux中日志的发送流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-journald%E7%9A%84%E9%85%8D%E7%BD%AE"><span class="toc-text">2.journald的配置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-rsyslog%E9%85%8D%E7%BD%AE"><span class="toc-text">3.rsyslog配置</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="toc-text">3.1过滤器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-4-%E5%8A%A8%E4%BD%9C"><span class="toc-text">3.1.4.动作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-5-%E8%BE%93%E5%87%BA"><span class="toc-text">3.1.5.输出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E5%90%84%E4%B8%AA%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6%E7%AE%80%E4%BB%8B"><span class="toc-text">3.2.各个日志文件简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E9%98%9F%E5%88%97"><span class="toc-text">3.3.队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4Ruleset"><span class="toc-text">3.4Ruleset</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-RainerScript"><span class="toc-text">3.5.RainerScript</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E6%97%A5%E5%BF%97%E8%BD%AE%E8%BD%AC%E2%80%93Logrotate"><span class="toc-text">4.日志轮转–Logrotate</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1logrotate%E5%8F%82%E6%95%B0"><span class="toc-text">4.1logrotate参数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E4%B8%80%E4%BA%9B%E5%B8%B8%E8%A7%81%E5%9D%91"><span class="toc-text">5.一些常见坑</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E5%B8%B8%E8%A7%81rsyslog%E4%B8%8D%E8%AE%B0%E6%97%A5%E5%BF%97%E9%97%AE%E9%A2%98"><span class="toc-text">6.常见rsyslog不记日志问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E9%99%84%E5%BD%95A-%E7%94%A8python%E5%8F%91%E9%80%81%E6%97%A5%E5%BF%97%E5%88%B0syslog"><span class="toc-text">7.附录A:用python发送日志到syslog</span></a></li></ol>
  </aside>

        
          
  <aside class="toc-wrap">
    <h3 class="toc-title">文章目录：</h3>
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%AE%B0"><span class="toc-text">前记</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Linux%E4%B8%AD%E6%97%A5%E5%BF%97%E7%9A%84%E5%8F%91%E9%80%81%E6%B5%81%E7%A8%8B"><span class="toc-text">1.Linux中日志的发送流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-journald%E7%9A%84%E9%85%8D%E7%BD%AE"><span class="toc-text">2.journald的配置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-rsyslog%E9%85%8D%E7%BD%AE"><span class="toc-text">3.rsyslog配置</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="toc-text">3.1过滤器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-4-%E5%8A%A8%E4%BD%9C"><span class="toc-text">3.1.4.动作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-5-%E8%BE%93%E5%87%BA"><span class="toc-text">3.1.5.输出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E5%90%84%E4%B8%AA%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6%E7%AE%80%E4%BB%8B"><span class="toc-text">3.2.各个日志文件简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E9%98%9F%E5%88%97"><span class="toc-text">3.3.队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4Ruleset"><span class="toc-text">3.4Ruleset</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-RainerScript"><span class="toc-text">3.5.RainerScript</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E6%97%A5%E5%BF%97%E8%BD%AE%E8%BD%AC%E2%80%93Logrotate"><span class="toc-text">4.日志轮转–Logrotate</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1logrotate%E5%8F%82%E6%95%B0"><span class="toc-text">4.1logrotate参数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E4%B8%80%E4%BA%9B%E5%B8%B8%E8%A7%81%E5%9D%91"><span class="toc-text">5.一些常见坑</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E5%B8%B8%E8%A7%81rsyslog%E4%B8%8D%E8%AE%B0%E6%97%A5%E5%BF%97%E9%97%AE%E9%A2%98"><span class="toc-text">6.常见rsyslog不记日志问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E9%99%84%E5%BD%95A-%E7%94%A8python%E5%8F%91%E9%80%81%E6%97%A5%E5%BF%97%E5%88%B0syslog"><span class="toc-text">7.附录A:用python发送日志到syslog</span></a></li></ol>
  </aside>

        
      </div>
    </div>
  </div>
</main>

  <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js">
</script>


<footer class="footer">
  <div class="footer-social"><a 
        href="https://github.com/so1n "
        target="_blank"
        class="footer-social-item"
        onMouseOver="this.style.color= '#9f7be1'" 
        onMouseOut="this.style.color='#33333D'">
          <i class="iconfont  icongithub-fill "></i>
      </a></div>
  
    <div class="footer-copyright"><p>Powered by <a target="_blank" href="https://hexo.io">Hexo</a>  |  Theme - <a target="_blank" href="https://github.com/izhaoo/hexo-theme-zhaoo">zhaoo</a></p></div>
  
  <div class="footer-copyright">
    总访问量<span id="busuanzi_value_site_pv"></span>次
    访客数<span id="busuanzi_value_site_uv"></span>人次
  </div>

</footer>

  
      <div class="fab fab-plus">
    <i class="iconfont iconplus"></i>
  </div>
  
  
  <div class="fab fab-up">
    <i class="iconfont iconcaret-up"></i>
  </div>
  
  
    <div class="scrollbar j-scrollbar">
  <div class="scrollbar-current j-scrollbar-current"></div>
</div>
  
  
    
<script src="/js/color-mode.js"></script>

  
  
    <div class="search">
  <div class="search-container">
    <div class="search-close">
      <i class="iconfont iconbaseline-close-px"></i>
    </div>
    <div class="search-input-wrapper">
      <i class="search-input-icon iconfont iconsearch"></i>
      <input class="search-input" type="search" id="search-input" placeholder="Search..." autofocus autocomplete="off"
        autocorrect="off" autocapitalize="off">
    </div>
    <div class="search-output" id="search-output"></div>
  </div>
</div>
  
</body>

<script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script>



  
<script src="https://cdn.bootcdn.net/ajax/libs/jquery.lazyload/1.9.1/jquery.lazyload.min.js"></script>




  
<script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js"></script>






  
<script src="https://cdn.bootcdn.net/ajax/libs/jquery.qrcode/1.0/jquery.qrcode.min.js"></script>




<script src="/js/utils.js"></script>
<script src="/js/script.js"></script>







  <script>
    (function () {
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
      } else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>













</html>