<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>So1n blog</title>
  
  <subtitle>不写会忘</subtitle>
  <link href="http://so1n.me/atom.xml" rel="self"/>
  
  <link href="http://so1n.me/"/>
  <updated>2023-03-06T02:20:18.718Z</updated>
  <id>http://so1n.me/</id>
  
  <author>
    <name>So1n</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Python Asyncio 库之网络编程详解</title>
    <link href="http://so1n.me/2023/02/27/python_asyncio_lib_network/"/>
    <id>http://so1n.me/2023/02/27/python_asyncio_lib_network/</id>
    <published>2023-02-27T15:33:18.000Z</published>
    <updated>2023-03-06T02:20:18.718Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前记"><a href="#前记" class="headerlink" title="前记"></a>前记</h2><span id="more"></span><h2 id="待定内容"><a href="#待定内容" class="headerlink" title="待定内容"></a>待定内容</h2><p>stream类似于同步的用法，protocol类似于回调的用法<br>socket 相关用法: <code>sock_connect</code>, <code>sock_accept</code>, <code>sock_recv</code>, and <code>sock_sendall</code><br>stream相关用法：<br>    - 读取流的方法： reader.read,readline,readuntil,readexactly<br>    - 检查是否到达EOF reader.ateof<br>    - 控制写入的流程：writer.drain<br>易用性stream -&gt; protocol &amp; transport-&gt; socket<br>性能protocol&amp; transport-&gt;stram -&gt; socket</p><p>stream提供了一些针对TCP的封装<br>stream比protocol慢的相关issue：<a href="https://github.com/python/asyncio/issues/412%E3%80%82%E4%BD%86%E6%98%AFPython3.11%E5%8F%AF%E8%83%BD%E6%9C%89%E6%94%B9%E8%BF%9B">https://github.com/python/asyncio/issues/412。但是Python3.11可能有改进</a></p><p>protocol&amp;transport 之所以比socket性能高的原因是eventlopp更知道eventloop?来自于<a href="https://www.youtube.com/watch?v=WSq0S7UvI8E&amp;ab_channel=PyConCanada%E7%9A%8412%EF%BC%9A30">https://www.youtube.com/watch?v=WSq0S7UvI8E&amp;ab_channel=PyConCanada的12：30</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前记&quot;&gt;&lt;a href=&quot;#前记&quot; class=&quot;headerlink&quot; title=&quot;前记&quot;&gt;&lt;/a&gt;前记&lt;/h2&gt;</summary>
    
    
    <content src="https://fastly.jsdelivr.net/gh/so1n/so1n_blog_photo@master/blog_photo/16550442517731649661119526images.png" type="image"/>
    
    
    <category term="Python Asyncio" scheme="http://so1n.me/categories/Python-Asyncio/"/>
    
    
    <category term="Python" scheme="http://so1n.me/tags/Python/"/>
    
    <category term="Asyncio" scheme="http://so1n.me/tags/Asyncio/"/>
    
  </entry>
  
  <entry>
    <title>Python Asyncio 库之同步原语常用函数详解</title>
    <link href="http://so1n.me/2023/02/27/python_asyncio_lib_asycio_sync_introduction/"/>
    <id>http://so1n.me/2023/02/27/python_asyncio_lib_asycio_sync_introduction/</id>
    <published>2023-02-27T15:33:18.000Z</published>
    <updated>2023-03-02T14:07:01.440Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前记"><a href="#前记" class="headerlink" title="前记"></a>前记</h2><p><code>Asyncio</code>的同步原语可以简化我们编写资源竞争的代码和规避资源竞争导致的Bug的出现。<br>但是由于协程的特性，在大部分业务代码中并不需要去考虑资源竞争的出现，导致<code>Asyncio</code>同步原语被使用的频率比较低，但是如果想机遇<code>Asyncio</code>编写框架则需要学习同步原语的使用。</p><span id="more"></span><h2 id="0-基础"><a href="#0-基础" class="headerlink" title="0.基础"></a>0.基础</h2><p>同步原语都是适用于某些条件下对某个资源的争夺，在代码中大部分的资源都是属于一个代码块，而<code>Python</code>对于代码块的管理的最佳实践是使用<code>with</code>语法，<code>with</code>语法实际上是调用了一个类中的<code>__enter__</code>和<code>__exit__</code>方法，比如下面的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__enter__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> <br>    <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__exit__</span>(<span class="hljs-params">self, exc_type, exc_val, exc_tb</span>):</span><br>        <span class="hljs-keyword">return</span> <br>    <br><br><span class="hljs-keyword">with</span> Demo():<br>    <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure><p>代码中的<code>Demo</code>类实现了<code>__enter__</code>和<code>__exit__</code>方法后，就可以被<code>with</code>语法调用，其中<code>__enter__</code>方法是进入代码块执行的逻辑，<code>__enxi__</code>方法是用于退出代码块(包括异常退出)的逻辑。这两个方法符合同步原语中对资源的争夺和释放，但是<code>__enter__</code>和<code>__exit__</code>两个方法都是不支持<code>await</code>调用的，为了解决这个问题，<code>Python</code>引入了<code>async with</code>语法。</p><p><code>async with</code>语法和<code>with</code>语法类似 ，我们只要编写一个拥有<code>__aenter__</code>和<code>__aexit__</code>方法的类，那么这个类就支持<code>asyncio with</code>语法了，如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> asyncio<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__aenter__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span><br><br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__aexit__</span>(<span class="hljs-params">self, exc_type, exc_val, exc_tb</span>):</span><br>        <span class="hljs-keyword">return</span><br><br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> Demo():<br>        <span class="hljs-keyword">pass</span><br><br><br>asyncio.run(main())<br></code></pre></td></tr></table></figure><p>其中，类中的<code>__aenter__</code>方法是进入代码块时执行的方法，<code>__aexit__</code>是退出代码块时执行的方法。</p><p>有了<code>async with</code>语法的加持，<code>asyncio</code>的同步原语使用起来会比较方便，所以<code>asyncio</code>中对资源争夺的同步原语都会继承于<code>_ContextManagerMixin</code>类：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">_ContextManagerMixin</span>:</span><br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__aenter__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">await</span> self.acquire()<br>        <span class="hljs-comment"># We have no use for the &quot;as ...&quot;  clause in the with</span><br>        <span class="hljs-comment"># statement for locks.</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br><br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__aexit__</span>(<span class="hljs-params">self, exc_type, exc, tb</span>):</span><br>        self.release()<br></code></pre></td></tr></table></figure><p>并实现了<code>acquire</code>和<code>release</code>方法，供<code>__aenter__</code>和<code>__aexit__</code>方法调用，同时我们在使用同步原语的时候尽量用到<code>async with</code>语法防止忘记释放资源的占用。</p><h2 id="1-Lock"><a href="#1-Lock" class="headerlink" title="1.Lock"></a>1.Lock</h2><p>由于协程的特性，在编写协程代码时基本上可以不考虑到锁的情况，但在一些情况下我们还是需要用到锁，并通过锁来维护并发时的数据安全性，如下例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> asyncio<br><br><br>share_data = &#123;&#125;<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sub</span>(<span class="hljs-params">i</span>):</span><br>    <span class="hljs-comment"># 赋上相同的key和value</span><br>    share_data[i] = i<br>    <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">0</span>)<br>    print(i, share_data[i] == i)<br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sub_add</span>(<span class="hljs-params">i</span>):</span><br>    <span class="hljs-comment"># 赋上的value值是原来的+1</span><br>    share_data[i] = i + <span class="hljs-number">1</span><br>    <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">0</span>)<br>    print(i, share_data[i] == i + <span class="hljs-number">1</span>)<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    <span class="hljs-comment"># 创建并发任务</span><br>    task_list = []<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):<br>        task_list.append(sub(i))<br>        task_list.append(sub_add(i))<br>    <span class="hljs-comment"># 并发执行</span><br>    <span class="hljs-keyword">await</span> asyncio.gather(*task_list)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    asyncio.run(main())<br></code></pre></td></tr></table></figure><p>在这个例子中程序会并发的执行<code>sub</code>和<code>sub_add</code>函数，他们是由不同的<code>asyncio.Task</code>驱动的，这意味着会出现这样一个场景。<br>当负责执行<code>sub(1)</code>函数的<code>asyncio.Task</code>在执行完<code>share_data[i]=i</code>后就执行<code>await asyncio.sleep(0)</code>从而主动让出控制权并交还给事件循环，等待事件循环的下一次调度。<br>不过事件循环不会空下来，而是马上安排下一个<code>asyncio.Task</code>执行，此时会先执行到<code>sub_add(1)</code>函数的<code>share_data[i] = i + 1</code>，并同样的在执行到<code>await asyncio.sleep(0)</code>的时候把控制权交会给事件循环。<br>这时候控制权会由事件循环转移给原先执行<code>sub(1)</code>函数的<code>asyncio.Task</code>，获取到控制权l后<code>sub(1)</code>函数的逻辑会继续走，但由于<code>share_data[i]</code>的数据已经被<code>share_data[i] = i + 1</code>修改了，导致最后执行<code>print</code>时，<code>share_data[i]</code>的数据已经变为脏数据，而不是原本想要的数据了。 </p><p>为了解决这个问题，我们可以使用<code>asyncio.Lock</code>来解决资源的冲突，如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> asyncio<br><br><br>share_data = &#123;&#125;<br><span class="hljs-comment"># 存放对应资源的锁</span><br>lock_dict = &#123;&#125;<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sub</span>(<span class="hljs-params">i</span>):</span><br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> lock_dict[i]:  <span class="hljs-comment"># &lt;-- 通过async with语句来控制锁的粒度</span><br>        share_data[i] = i<br>        <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">0</span>)<br>        print(i, share_data[i] == i)<br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sub_add</span>(<span class="hljs-params">i</span>):</span><br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> lock_dict[i]:<br>        share_data[i] = i + <span class="hljs-number">1</span><br>        <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">0</span>)<br>        print(i, share_data[i] == i + <span class="hljs-number">1</span>)<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    task_list = []<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):<br>        lock_dict[i] = asyncio.Lock()<br>        task_list.append(sub(i))<br>        task_list.append(sub_add(i))<br>    <span class="hljs-keyword">await</span> asyncio.gather(*task_list)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    asyncio.run(main())<br></code></pre></td></tr></table></figure><p>从例子可以看到<code>asyncio.Lock</code>的使用方法跟多线程的<code>Lock</code>差不多，通过<code>async with</code>语法来获取和释放锁，它的原理也很简单，主要做了如下几件事：</p><ul><li>1.确保某一协程获取锁后的执行期间，别的协程在获取锁时需要一直等待，直到执行完成并释放锁。</li><li>2.当有协程持有锁的时候，其他协程必须等待，直到持有锁的协程释放了锁。</li><li>2.确保所有协程能够按照获取的顺序获取到锁。</li></ul><p>这意味着需要有一个数据结构来维护当前持有锁的协程的和下一个获取锁协程的关系，同时也需要一个队列来维护多个获取锁的协程的唤醒顺序。</p><p><code>asyncio.Lock</code>跟其它<code>asyncio</code>功能的用法一样，使用<code>asyncio.Future</code>来同步协程之间锁的状态，使用<code>deque</code>维护协程间的唤醒顺序，源码如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Lockl</span>(<span class="hljs-params">_ContextManagerMixin, mixins._LoopBoundMixin</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        self._waiters = <span class="hljs-literal">None</span><br>        self._locked = <span class="hljs-literal">False</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">locked</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> self._locked<br><br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">acquire</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">not</span> self._locked <span class="hljs-keyword">and</span> (self._waiters <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">or</span> <span class="hljs-built_in">all</span>(w.cancelled() <span class="hljs-keyword">for</span> w <span class="hljs-keyword">in</span> self._waiters))):<br>            <span class="hljs-comment"># 目前没有其他协程持有锁，当前协程可以运行</span><br>            self._locked = <span class="hljs-literal">True</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br><br>        <span class="hljs-keyword">if</span> self._waiters <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            self._waiters = collections.deque()<br>        <span class="hljs-comment"># 创建属于自己的容器，并推送到`_waiters`这个双端队列中</span><br>        fut = self._get_loop().create_future()<br>        self._waiters.append(fut)<br><br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-keyword">try</span>:<br>                <span class="hljs-keyword">await</span> fut<br>            <span class="hljs-keyword">finally</span>:<br>                <span class="hljs-comment"># 如果执行完毕，需要把自己移除，防止被`wake_up_first`调用</span><br>                self._waiters.remove(fut)<br>        <span class="hljs-keyword">except</span> exceptions.CancelledError:<br>            <span class="hljs-comment"># 如果是等待的过程中被取消了，需要唤醒下一个调用`acquire`</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self._locked:<br>                self._wake_up_first()<br>            <span class="hljs-keyword">raise</span><br>        <span class="hljs-comment"># 持有锁</span><br>        self._locked = <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">release</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">if</span> self._locked:<br>            <span class="hljs-comment"># 释放锁</span><br>            self._locked = <span class="hljs-literal">False</span><br>            self._wake_up_first()<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">raise</span> RuntimeError(<span class="hljs-string">&#x27;Lock is not acquired.&#x27;</span>)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_wake_up_first</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self._waiters:<br>            <span class="hljs-keyword">return</span><br>        <span class="hljs-comment"># 获取还处于锁状态协程对应的容器</span><br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-comment"># 获取下一个等待获取锁的waiter</span><br>            fut = <span class="hljs-built_in">next</span>(<span class="hljs-built_in">iter</span>(self._waiters))<br>        <span class="hljs-keyword">except</span> StopIteration:<br>            <span class="hljs-keyword">return</span><br>        <span class="hljs-comment"># 设置容器为True,这样对应协程就可以继续运行了。</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> fut.done():<br>            fut.set_result(<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure><p>通过源码可以知道，锁主要提供了获取和释放的功能，对于获取锁需要区分两种情况：</p><ul><li>1:当有协程想要获取锁时会先判断锁是否被持有，如果当前锁没有被持有就直接返回，使协程能够正常运行。</li><li>2:如果协程获取锁时，锁发现自己已经被其他协程持有则创建一个属于当前协程的<code>asyncio.Future</code>，用来同步状态，并添加到<code>deque</code>中。</li></ul><p>而对于释放锁就比较简单，只要获取<code>deque</code>中的第一个<code>asyncio.Future</code>，并通过<code>fut.set_result(True)</code>进行标记，使<code>asyncio.Future</code>从<code>peding</code>状态变为<code>done</code>状态，这样一来，持有该<code>asyncio.Future</code>的协程就能继续运行，从而持有锁。</p><p>不过需要注意源码中<code>acquire</code>方法中对<code>CancelledError</code>异常进行捕获，再唤醒下一个锁，这是为了解决<code>acquire</code>方法执行异常导致锁一直被卡住的场景，通常情况下这能解决大部分的问题，但是如果遇到错误的封装时，我们需要亲自处理异常，并执行锁的唤醒。比如在通过继承<code>asyncio.Lock</code>编写一个超时锁时，最简单的实现代码如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> asyncio<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TimeoutLock</span>(<span class="hljs-params">asyncio.Lock</span>):</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, timeout, *, loop=<span class="hljs-literal">None</span></span>):</span><br>        self.timeout = timeout<br>        <span class="hljs-built_in">super</span>().__init__(loop=loop)<br>        <br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">acquire</span>(<span class="hljs-params">self</span>) -&gt; bool:</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> asyncio.wait_for(<span class="hljs-built_in">super</span>().acquire(), self.timeout)<br></code></pre></td></tr></table></figure><p>这份代码非常简单，他只需要在<code>__init__</code>方法传入<code>timeout</code>参数，并在<code>acuiqre</code>方法中通过<code>wait_for</code>来实现锁超时即可，现在假设<code>wait_for</code>方法是一个无法传递协程<code>cancel</code>的方法，且编写的<code>acquire</code>没有进行捕获异常再释放锁的操作，当异常发生的时候会导致锁一直被卡住。<br>为了解决这个问题，只需要对<code>TimeoutLock</code>的<code>acquire</code>方法添加异常捕获，并在捕获到异常时释放锁即可，代码如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TimeoutLock</span>(<span class="hljs-params">asyncio.Lock</span>):</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, timeout, *, loop=<span class="hljs-literal">None</span></span>):</span><br>        self.timeout = timeout<br>        <span class="hljs-built_in">super</span>().__init__(loop=loop)<br><br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">acquire</span>(<span class="hljs-params">self</span>) -&gt; bool:</span><br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> asyncio.wait_for(<span class="hljs-built_in">super</span>().acquire(), self.timeout)<br>        <span class="hljs-keyword">except</span> Exception:<br>            self._wake_up_first()<br>            <span class="hljs-keyword">raise</span><br></code></pre></td></tr></table></figure><h3 id="1-1-什么时候要使用锁"><a href="#1-1-什么时候要使用锁" class="headerlink" title="1.1.什么时候要使用锁"></a>1.1.什么时候要使用锁</h3><p>在<code>async</code>中判断是否需要使用<code>asyncio.Lock</code>很简单，就是判断这个资源会不会被多个协程使用，最简单的就是这个资源是否被多个协程使用，如下代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> asyncio <br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">demo</span>():</span><br>    cache = &#123;&#125;<br>    <span class="hljs-comment"># some code</span><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    asyncio.create_task(demo())<br>    asyncio.create_task(demo())<br>    <span class="hljs-comment"># some code</span><br><br><br>asyncio.run(main())<br></code></pre></td></tr></table></figure><p>这段代码的资源是<code>demo</code>函数的<code>cache</code>，由于他归属于<code>demo</code>函数，只能被<code>demo</code>函数中的其他代码读写，后面只要确保<code>demo</code>函数的逻辑只会被一个协程完整的执行，那么就不需要锁了，即使<code>demo</code>函数被两个<code>asyncio.Task</code>并发驱动。<br>但是如果<code>demo</code>函数被改为如下代码就不一样了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">demo</span>():</span><br>    cache = &#123;&#125;<br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_update</span>(<span class="hljs-params">key, value</span>):</span><br>        cache[key] = value<br>    asyncio.create(_update(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>))<br>    asyncio.create(_update(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>))<br></code></pre></td></tr></table></figure><p>这时候出现了两个<code>asyncio.Task</code>并发驱动到修改<code>cache</code>的<code>_update</code>函数，会出现资源冲突的情况，这时候就需要锁了。</p><p>所以判断资源需不需要锁的规则很简单，就是这个资源是否被多个<code>asyncio.Task</code>并发驱动，如果是则需要加锁。</p><h2 id="2-Event"><a href="#2-Event" class="headerlink" title="2.Event"></a>2.Event</h2><p><code>asyncio.Event</code>也是一个简单的同步原语，但它跟<code>asyncio.Lock</code>不一样，<code>asyncio.Lock</code>是确保每个资源只能被一个协程操作，而<code>asyncio.Event</code>是确保某个资源何时可以被协程操作，可以认为<code>asyncio.Lock</code>锁的是资源，<code>asyncio.Event</code>锁的是协程，所以<code>asyncio.Event</code>并不需要<code>acquire</code>来锁资源，<code>release</code>释放资源，所以也用不到<code>async with</code>语法。</p><p><code>asyncio.Event</code>的简单使用示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> asyncio<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sub</span>(<span class="hljs-params">event: asyncio.Event</span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>    <span class="hljs-keyword">await</span> event.wait()<br>    print(<span class="hljs-string">&quot;I&#x27;m Done&quot;</span>)<br><br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>() -&gt; <span class="hljs-keyword">None</span>:</span><br>    event = asyncio.Event()<br>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):<br>        asyncio.create_task(sub(event))<br>    <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">1</span>)<br>    event.<span class="hljs-built_in">set</span>()<br><br>asyncio.run(main())<br></code></pre></td></tr></table></figure><p>在这个例子中会先创建10个<code>asyncio.Task</code>来执行<code>sub</code>函数，但是所有<code>sub</code>函数都会在<code>event.wait</code>处等待，直到<code>main</code>函数中调用<code>event.set</code>后，所有的<code>sub</code>函数的<code>event.wait</code>会放行，使<code>sub</code>函数能继续执行。</p><p>可以看到<code>asyncio.Event</code>功能比较简单，它的源码实现也很简单，源码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Event</span>(<span class="hljs-params">mixins._LoopBoundMixin</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        self._waiters = collections.deque()<br>        self._value = <span class="hljs-literal">False</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">is_set</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> self._value<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">set</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self._value:<br>            <span class="hljs-comment"># 确保每次只能set一次</span><br>            self._value = <span class="hljs-literal">True</span><br>            <span class="hljs-comment"># 设置每个协程存放的容器为True，这样对应的协程就可以运行了</span><br>            <span class="hljs-keyword">for</span> fut <span class="hljs-keyword">in</span> self._waiters:<br>                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> fut.done():<br>                    fut.set_result(<span class="hljs-literal">True</span>)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">clear</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-comment"># 清理上一次的set</span><br>        self._value = <span class="hljs-literal">False</span><br><br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">wait</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">if</span> self._value:<br>            <span class="hljs-comment"># 如果设置了，就不需要等待了</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>        <span class="hljs-comment"># 否则需要创建一个容器，并需要等待容器完成</span><br>        fut = self._get_loop().create_future()<br>        self._waiters.append(fut)<br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-keyword">await</span> fut<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">finally</span>:<br>            self._waiters.remove(fut)<br></code></pre></td></tr></table></figure><p>通过源码可以看到<code>wait</code>方法主要是创建了一个<code>asyncio.Future</code>，并把它加入到<code>deque</code>队列后就一直等待着，而<code>set</code>方法被调用时会遍历整个<code>deque</code>队列，并把处于<code>peding</code>状态的<code>asyncio.Future</code>设置为<code>done</code>，这时其他在调用<code>event.wait</code>方法的协程就会得到放行。</p><blockquote><p>通过源码也可以看出，<code>asyncio.Event</code>并没有继承于<code>_ContextManagerMixin</code>，这是因为它锁的是协程，而不是资源。</p></blockquote><p><code>asyncio.Event</code>的使用频率比<code>asyncio.Lock</code>多许多，不过通常都会让<code>asyncio.Event</code>和其他数据结构进行封装再使用，比如实现一个服务器的优雅关闭功能，这个功能会确保服务器在等待n秒后或者所有连接都关闭后才关闭服务器，这个功能就可以使用<code>set</code>与<code>asyncio.Event</code>结合，如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> asyncio<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SetEvent</span>(<span class="hljs-params">asyncio.Event</span>):</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, *, loop=<span class="hljs-literal">None</span></span>):</span><br>        self._set = <span class="hljs-built_in">set</span>()<br>        <span class="hljs-built_in">super</span>().__init__(loop=loop)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span>(<span class="hljs-params">self, value</span>):</span><br>        self._set.add(value)<br>        self.clear()<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">remove</span>(<span class="hljs-params">self, value</span>):</span><br>        self._set.remove(value)<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self._set:<br>            self.<span class="hljs-built_in">set</span>()<br></code></pre></td></tr></table></figure><p>这个<code>SetEvent</code>结合了<code>set</code>和<code>SetEvent</code>的功能，当<code>set</code>有数据的时候，会通过<code>clear</code>方法使<code>SetEvent</code>变为等待状态，而<code>set</code>没数据的时候，会通过<code>set</code>方法使<code>SetEvent</code>变为无需等待的状态，所有调用<code>wait</code>的协程都可以放行，通过这种结合，<code>SetEvent</code>拥有了等待资源为空的功能。<br>接下来就可以用于服务器的优雅退出功能：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">mock_conn_io</span>() -&gt; <span class="hljs-keyword">None</span>:</span><br>    <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">1</span>)<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">conn_handle</span>(<span class="hljs-params">set_event: SetEvent</span>):</span><br>    task: asyncio.Task = asyncio.create_task(mock_conn_io())<br>    set_event.add(task)<br>    task.add_done_callback(<span class="hljs-keyword">lambda</span> t: set_event.remove(t))<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    set_event: SetEvent = SetEvent()<br>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):<br>        conn_handle(set_event)<br><br>    <span class="hljs-comment"># 假设这里收到了退出信号</span><br>    <span class="hljs-keyword">await</span> asyncio.wait(set_event.wait(), timeout=<span class="hljs-number">9</span>)<br><br><br>asyncio.run(main())<br></code></pre></td></tr></table></figure><p>在这个演示功能中，<code>mock_conn_io</code>用于模拟服务器的连接正在处理中，而<code>conn_handle</code>用于创建服务器连接，<code>main</code>则是先创建10个连接，并模拟在收到退出信号后等待资源为空或者超时才退出服务。</p><blockquote><p>这只是简单的演示，实际上的优雅关闭功能要考虑的东西不仅仅是这些。</p></blockquote><h2 id="4-Condition"><a href="#4-Condition" class="headerlink" title="4.Condition"></a>4.Condition</h2><blockquote><p>condition只做简单介绍</p></blockquote><p><code>asyncio.Condition</code>是同步原语中使用最少的一种，因为他使用情况很奇怪，而且大部分场景可以被其他写法代替，比如下面这个<a href="https://superfastpython.com/asyncio-condition-variable/#Notify_All_Waiting_Coroutines">例子</a>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> asyncio<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">task</span>(<span class="hljs-params">condition, work_list</span>):</span><br>    <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">1</span>)<br>    work_list.append(<span class="hljs-number">33</span>)<br>    print(<span class="hljs-string">&#x27;Task sending notification...&#x27;</span>)<br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> condition:<br>        condition.notify()<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    condition = asyncio.Condition()<br>    work_list = <span class="hljs-built_in">list</span>()<br>    print(<span class="hljs-string">&#x27;Main waiting for data...&#x27;</span>)<br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> condition:<br>        _ = asyncio.create_task(task(condition, work_list))<br>        <span class="hljs-keyword">await</span> condition.wait()<br>    print(<span class="hljs-string">f&#x27;Got data: <span class="hljs-subst">&#123;work_list&#125;</span>&#x27;</span>)<br><br><br>asyncio.run(main())<br><span class="hljs-comment"># &gt;&gt;&gt; Main waiting for data...</span><br><span class="hljs-comment"># &gt;&gt;&gt; Task sending notification...</span><br><span class="hljs-comment"># &gt;&gt;&gt; Got data: [33]</span><br></code></pre></td></tr></table></figure><p>在这个例子中可以看到，<code>notify</code>和<code>wait</code>方法只能在<code>async with condition</code>中可以使用，如果没有在<code>async with condition</code>中使用则会报错，同时这个示例代码有点复杂，没办法一看就知道执行逻辑是什么，其实这个逻辑可以转变成一个更简单的写法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> asyncio<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">task</span>(<span class="hljs-params">work_list</span>):</span><br>    <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">1</span>)<br>    work_list.append(<span class="hljs-number">33</span>)<br>    print(<span class="hljs-string">&#x27;Task sending notification...&#x27;</span>)<br>    <span class="hljs-keyword">return</span><br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    work_list = <span class="hljs-built_in">list</span>()<br>    print(<span class="hljs-string">&#x27;Main waiting for data...&#x27;</span>)<br>    _task = asyncio.create_task(task(work_list))<br>    <span class="hljs-keyword">await</span> _task<br>    print(<span class="hljs-string">f&#x27;Got data: <span class="hljs-subst">&#123;work_list&#125;</span>&#x27;</span>)<br><br><br>asyncio.run(main())<br><br><span class="hljs-comment"># &gt;&gt;&gt; Main waiting for data...</span><br><span class="hljs-comment"># &gt;&gt;&gt; Task sending notification...</span><br><span class="hljs-comment"># &gt;&gt;&gt; Got data: [33]</span><br></code></pre></td></tr></table></figure><p>通过这个代码可以看到这个写法更简单一点，而且更有逻辑性，而<code>condition</code>的写法却更有点<code>Go</code>协程写法/或者回调函数写法的感觉。<br>所以建议在认为自己的代码可能会用到<code>asyncio.Conditon</code>时需要先考虑到是否需要<code>asyncio.Codition</code>？是否有别的方案代替，如果没有才考虑去使用<code>asyncio.Conditon</code>k。</p><h2 id="5-Semaphore"><a href="#5-Semaphore" class="headerlink" title="5.Semaphore"></a>5.Semaphore</h2><p><code>asyncio.Semaphore</code>–信号量是同步原语中被使用最频繁的，大多数都是用在限流场景中，比如用在爬虫中和客户端网关中限制请求频率。</p><p><code>asyncio.Semaphore</code>可以认为是一个延缓触发的<code>asyncio.Lock</code>，<code>asyncio.Semaphore</code>内部会维护一个计数器，无论何时进行获取或释放，它都会递增或者递减(但不会超过边界值)，当计数器归零时，就会进入到锁的逻辑，但是这个锁逻辑会在计数器大于0的时候释放j，它的用法如下：`</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> asyncio<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    semaphore = asyncio.Semaphore(<span class="hljs-number">10</span>):<br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> semaphore:<br>        <span class="hljs-keyword">pass</span><br>    <br>    <br>asyncio.run(main())<br></code></pre></td></tr></table></figure><p>示例中代码通过<code>async with</code>来指明一个代码块（代码用<code>pass</code>代替），这个代码块是被<code>asyncio.Semaphore</code>管理的，每次协程在进入代码块时，<code>asyncio.Semaphore</code>的内部计数器就会递减一，而离开代码块则<code>asyncio.Semaphore</code>的内部计数器会递增一。<br>当有一个协程进入代码块时<code>asyncio.Semaphore</code>发现计数器已经为0了，则会使当前协程进入等待状态，直到某个协程离开这个代码块时，计数器会递增一，并唤醒等待的协程，使其能够进入代码块中继续执行。</p><p><code>asyncio.Semaphore</code>的源码如下，需要注意的是由于<code>asyncio.Semaphore</code>是一个延缓的<code>asyncio.Lock</code>，所以当调用一次<code>release</code>后可能会导致被唤醒的协程和刚进入代码块的协程起冲突，所以在<code>acquire</code>方法中要通过一个<code>while</code>循环来解决这个问题：`</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Semaphore</span>(<span class="hljs-params">_ContextManagerMixin, mixins._LoopBoundMixin</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, value=<span class="hljs-number">1</span></span>):</span><br>        <span class="hljs-keyword">if</span> value &lt; <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&quot;Semaphore initial value must be &gt;= 0&quot;</span>)<br>        self._value = value<br>        self._waiters = collections.deque()<br>        self._wakeup_scheduled = <span class="hljs-literal">False</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_wake_up_next</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">while</span> self._waiters:<br>            <span class="hljs-comment"># 按照放置顺序依次弹出容器 </span><br>            waiter = self._waiters.popleft()<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> waiter.done():<br>                <span class="hljs-comment"># 设置容器状态，使对应的协程可以继续执行</span><br>                waiter.set_result(<span class="hljs-literal">None</span>)<br>                <span class="hljs-comment"># 设置标记 </span><br>                self._wakeup_scheduled = <span class="hljs-literal">True</span><br>                <span class="hljs-keyword">return</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">locked</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> self._value == <span class="hljs-number">0</span><br><br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">acquire</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-comment"># 如果`self._wakeup_scheduled`为True或者value小于0</span><br>        <span class="hljs-keyword">while</span> self._wakeup_scheduled <span class="hljs-keyword">or</span> self._value &lt;= <span class="hljs-number">0</span>:<br>            <span class="hljs-comment"># 创建容器并等待执行完成</span><br>            fut = self._get_loop().create_future()<br>            self._waiters.append(fut)<br>            <span class="hljs-keyword">try</span>:<br>                <span class="hljs-keyword">await</span> fut<br>                self._wakeup_scheduled = <span class="hljs-literal">False</span><br>            <span class="hljs-keyword">except</span> exceptions.CancelledError:<br>                <span class="hljs-comment"># 如果被取消了，也要唤醒下一个协程</span><br>                self._wake_up_next()<br>                <span class="hljs-keyword">raise</span><br>        self._value -= <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">release</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-comment"># 释放资源占用，唤醒下一个协程。</span><br>        self._value += <span class="hljs-number">1</span><br>        self._wake_up_next()<br></code></pre></td></tr></table></figure><p>针对<code>asyncio.Semaphore</code>进行修改可以实现很多功能，比如基于信号量可以实现一个简单的协程池，这个协程池可以限制创建协程的量，当协程池满的时候就无法继续创建协程，只有协程中的协程执行完毕后才能继续创建(当然无法控制在协程中创建新的协程)，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> asyncio<br><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> Coroutine<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pool</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, max_concurrency: <span class="hljs-built_in">int</span></span>):</span><br>        self._semaphore: asyncio.Semaphore = asyncio.Semaphore(max_concurrency)<br><br><br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">create_task</span>(<span class="hljs-params">self, coro: Coroutine</span>) -&gt; asyncio.Task:</span><br>        <span class="hljs-keyword">await</span>  self._semaphore.acquire()<br>        task: asyncio.Task = asyncio.create_task(coro)<br>        task.add_done_callback(<span class="hljs-keyword">lambda</span> t: self._semaphore.release())<br>        <span class="hljs-keyword">return</span> task<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">demo</span>(<span class="hljs-params">cnt: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>    print(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;<span class="hljs-built_in">int</span>(time.time())&#125;</span> create <span class="hljs-subst">&#123;cnt&#125;</span> task...&quot;</span>)<br>    <span class="hljs-keyword">await</span>  asyncio.sleep(cnt)<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>() -&gt; <span class="hljs-keyword">None</span>:</span><br>    pool: Pool = Pool(<span class="hljs-number">3</span>)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):<br>        <span class="hljs-keyword">await</span> pool.create_task(demo(i))<br><br><br>asyncio.run(main())<br><span class="hljs-comment"># &gt;&gt;&gt; 1677517996 create 0 task...</span><br><span class="hljs-comment"># &gt;&gt;&gt; 1677517996 create 1 task...</span><br><span class="hljs-comment"># &gt;&gt;&gt; 1677517996 create 2 task...</span><br><span class="hljs-comment"># &gt;&gt;&gt; 1677517996 create 3 task...</span><br><span class="hljs-comment"># &gt;&gt;&gt; 1677517997 create 4 task...</span><br><span class="hljs-comment"># &gt;&gt;&gt; 1677517998 create 5 task...</span><br><span class="hljs-comment"># &gt;&gt;&gt; 1677517999 create 6 task...</span><br><span class="hljs-comment"># &gt;&gt;&gt; 1677518001 create 7 task...</span><br><span class="hljs-comment"># &gt;&gt;&gt; 1677518003 create 8 task...</span><br><span class="hljs-comment"># &gt;&gt;&gt; 1677518005 create 9 task...</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前记&quot;&gt;&lt;a href=&quot;#前记&quot; class=&quot;headerlink&quot; title=&quot;前记&quot;&gt;&lt;/a&gt;前记&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Asyncio&lt;/code&gt;的同步原语可以简化我们编写资源竞争的代码和规避资源竞争导致的Bug的出现。&lt;br&gt;但是由于协程的特性，在大部分业务代码中并不需要去考虑资源竞争的出现，导致&lt;code&gt;Asyncio&lt;/code&gt;同步原语被使用的频率比较低，但是如果想机遇&lt;code&gt;Asyncio&lt;/code&gt;编写框架则需要学习同步原语的使用。&lt;/p&gt;</summary>
    
    
    <content src="https://fastly.jsdelivr.net/gh/so1n/so1n_blog_photo@master/blog_photo/16550442517731649661119526images.png" type="image"/>
    
    
    <category term="Python Asyncio" scheme="http://so1n.me/categories/Python-Asyncio/"/>
    
    
    <category term="Python" scheme="http://so1n.me/tags/Python/"/>
    
    <category term="Asyncio" scheme="http://so1n.me/tags/Asyncio/"/>
    
  </entry>
  
  <entry>
    <title>Python Asyncio 库之asyncio.task常用函数详解</title>
    <link href="http://so1n.me/2022/12/08/python_asyncio_lib_asyncio.task_introduction/"/>
    <id>http://so1n.me/2022/12/08/python_asyncio_lib_asyncio.task_introduction/</id>
    <published>2022-12-08T15:33:18.000Z</published>
    <updated>2023-02-26T16:18:25.943Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前记"><a href="#前记" class="headerlink" title="前记"></a>前记</h2><p><code>Asyncio</code>在经过一段时间的发展以及获取<code>Curio</code>等第三方库的经验来提供更多的功能，目前高级功能也基本完善，但是相对于其他语言，<code>Python</code>的<code>Asyncio</code>高级功能还是不够的，但好在<code>Asyncio</code>的低级API也比较完善，开发者可以通过参考<code>Asyncio</code>高级API的例子来自己实现一些功能，同时也可以通过这些功能更加了解<code>Asyncio</code>的原理和避免踩到高级API的坑。</p><h2 id="0-基础"><a href="#0-基础" class="headerlink" title="0.基础"></a>0.基础</h2><p>在<a href="https://so1n.me/2022/06/08/python_asyncio_schedule/">《Python Asyncio调度原理》</a>中介绍了<code>Asyncio</code>的两种调度基本单位，<code>Handler</code>和<code>TimeHandler</code>，他们只能被<code>loop.call_xx</code>函数调用，开发者从表面上不知道他们的存在，他们和<code>loop.call_xx</code>属于事件循环的基础功能，但是这些操作都属于单一操作，需要开发者自己编写代码把他们的操作给串联起来。<br>而在<a href="https://so1n.me/2022/04/11/python's_waitable_objects_in_asyncio/">《Python的可等待对象在Asyncio的作用》</a>中介绍了协程链的发起者<code>asyncio.Task</code>能通过<code>loop.call_soon</code>跟事件循环进行交互，并串联整个协程链中可等待对象以及安排可等待对象的运行。<br>不过对于<code>loop.call_at</code>和<code>loop.call_later</code>仍需要开发者通过<code>asyncio.Future</code>来把<code>Timehandler</code>的执行结果与<code>asyncio.Task</code>给串联起来，比如休眠一秒的代码实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> asyncio<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    loop = asyncio.get_event_loop()<br>    f = asyncio.Future()<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_on_complete</span>():</span><br>        f.set_result(<span class="hljs-literal">True</span>)<br><br>    loop.call_later(<span class="hljs-number">1</span>, _on_complete)<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> f<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    <span class="hljs-keyword">import</span> time<br>    s_t = time.time()<br>    asyncio.run(main())<br>    print(time.time() - s_t)<br></code></pre></td></tr></table></figure><p>这段代码中<code>asyncio.Future</code>执行的是类似容器的功能，自己本身会接受各种状态，并把自己的状态同步给管理当前协程链的<code>asyncio.Task</code>，使<code>asyncio.Task</code>能管理其他类型的操作。</p><p>在<code>asyncio.tasks</code>模块中的所有功能函数的原理也差不多，他们接受的参数基本是都是可等待对象，然后通过<code>asyncio.Futurte</code>作为容器来同步调用端和可等待对象间的状态，也可以通过其他的一些方法把<code>asyncio.Task</code>的状态同步给可等待对象。</p><h2 id="1-休眠–asyncio-sleep"><a href="#1-休眠–asyncio-sleep" class="headerlink" title="1.休眠–asyncio.sleep"></a>1.休眠–asyncio.sleep</h2><p><code>asyncio.sleep</code>是一个常用的方法，开发者通过它可以很方便的让协程休眠设定的时间，它本身也非常简单，它的源码如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-meta">@types.coroutine</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__sleep0</span>():</span><br>    <span class="hljs-keyword">yield</span><br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sleep</span>(<span class="hljs-params">delay, result=<span class="hljs-literal">None</span></span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;Coroutine that completes after a given time (in seconds).&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">if</span> delay &lt;= <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">await</span> __sleep0()<br>        <span class="hljs-keyword">return</span> result<br><br>    loop = events.get_running_loop()<br>    future = loop.create_future()<br>    h = loop.call_later(delay,<br>                        futures._set_result_unless_cancelled,<br>                        future, result)<br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> future<br>    <span class="hljs-keyword">finally</span>:<br>        h.cancel()<br></code></pre></td></tr></table></figure><p>通过源码可以发现当设置的休眠时间等于小于0的时候，<code>sleep</code>只执行了<code>yield</code>，并不会执行其他逻辑，而在值大于0时会创建一个<code>Future</code>对象，接着就一直等待，直到<code>Future</code>对象被<code>loop.call_later</code>控制结束时才返回结果值。</p><p>需要注意的是，当<code>asyncio.sleep</code>在值为0时，<code>sleep</code>执行<code>yield</code>可以让<code>Task.__step</code>感知而让出控制权，这是最小的让出当前协程控制权的方法，所以我们在编写涉及到CPU比较多的时候或者消耗时间较长的函数时可以通过<code>asyncio.sleep(0)</code>来主动让出控制权，如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> asyncio<br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">demo</span>() -&gt; <span class="hljs-keyword">None</span>:</span><br>    <span class="hljs-keyword">for</span> index, i <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(<span class="hljs-built_in">range</span>(<span class="hljs-number">10000</span>)):<br>        <span class="hljs-keyword">if</span> index % <span class="hljs-number">100</span> == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">0</span>)<br>        ...  <span class="hljs-comment"># 假设这里的代码占用过多的CPU时间</span><br></code></pre></td></tr></table></figure><p>在这个例子中每循环100次就让出控制权，以减少对其他协程的影响。</p><h2 id="2-屏蔽取消–asyncio-shield"><a href="#2-屏蔽取消–asyncio-shield" class="headerlink" title="2.屏蔽取消–asyncio.shield"></a>2.屏蔽取消–asyncio.shield</h2><p><code>asyncio.shield</code>可以保护一个可等待对象被取消，或者说是防止协程链上的取消传播到被<code>asyncio.shield</code>托管的可等待对象，但是调用可等待对象的<code>cancel</code>方法仍然可以取消可等待对象的运行，如下例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> asyncio<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sub</span>(<span class="hljs-params">f</span>):</span><br>    <span class="hljs-keyword">await</span> asyncio.shield(f)<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    f1 = asyncio.Future()<br>    f2 = asyncio.Future()<br>    sub1 = asyncio.create_task(sub(f1))<br>    sub2 = asyncio.create_task(sub(f2))<br>    f1.cancel()<br>    sub2.cancel()<br>    <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">0</span>)  <span class="hljs-comment"># 确保已经取消完成</span><br>    print(<span class="hljs-string">&quot;f1 future run success:&quot;</span>, f1.done())<br>    print(<span class="hljs-string">&quot;f2 future run success:&quot;</span>, f2.done())<br>    print(<span class="hljs-string">&quot;sub1 future run result:&quot;</span>, sub1.done())<br>    print(<span class="hljs-string">&quot;sub2 future run result:&quot;</span>, sub2.done())<br><br>asyncio.run(main())<br><br><span class="hljs-comment"># &gt;&gt;&gt; future run success: True</span><br><span class="hljs-comment"># &gt;&gt;&gt; future run success: False</span><br><span class="hljs-comment"># &gt;&gt;&gt; sub1 future run result: True</span><br><span class="hljs-comment"># &gt;&gt;&gt; sub2 future run result: True</span><br></code></pre></td></tr></table></figure><p>其中<code>f1</code>, <code>f2</code>都在<code>main</code>函数中创建， 然后同时被<code>sub</code>函数包裹，并通过<code>asyncio.create_task</code>在后台异步运行并分别返回<code>sub1</code>和<code>sub2</code>两个<code>Future</code>对应着<code>sub</code>函数的执行情况。<br>接着分别取消<code>f1</code>和<code>sub2</code>的执行，并把<code>f1</code>,<code>f2</code>,<code>sub1</code>,<code>sub2</code>是否为<code>done</code>打印出来，可以发现<code>f1</code>,<code>sub1</code>,<code>sub2</code>的状态都为<code>done</code>（被取消也认为是done)，而<code>f2</code>则还在运行中。</p><p>在文章<a href="https://so1n.me/2022/04/11/python's_waitable_objects_in_asyncio/">《Python的可等待对象在Asyncio的作用》</a>中说过，一条协程链是由<code>asyncio.Task</code>牵头组成的，后续的所有成功和异常都会在这条链上传播，而取消本质上就是一种异常，所以也可以在协程链上传播。<br>而<code>shield</code>为了杜绝运行的可等待对象收到协程链的异常传播又能让协程链知道可等待对象的执行结果，会先让可等待对象在另外一条协程链运行，然后创建一个容器接到原来链上，并在可等待对象执行完成的时候把结果告诉容器，由容器把结果传播到原有的协程链上，对应的源码如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">shield</span>(<span class="hljs-params">arg</span>):</span><br>    <span class="hljs-comment"># 如果是Coro，则需要包装成future</span><br>    inner = _ensure_future(arg)<br>    <span class="hljs-keyword">if</span> inner.done():<br>        <span class="hljs-comment"># 如果已经完成，就不需要被处理了</span><br>        <span class="hljs-keyword">return</span> inner<br>    loop = futures._get_loop(inner)<br>    <span class="hljs-comment"># 创建一个future容器</span><br>    outer = loop.create_future()<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_inner_done_callback</span>(<span class="hljs-params">inner</span>):</span><br>        <span class="hljs-keyword">if</span> outer.cancelled():<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> inner.cancelled():<br>                <span class="hljs-comment"># 如果容器已经被取消，而自己没被取消且已经完成，则手动获取下结果，方便被回收</span><br>                inner.exception()<br>            <span class="hljs-keyword">return</span><br><br>        <span class="hljs-keyword">if</span> inner.cancelled():<br>            <span class="hljs-comment"># 如果自己被取消，则把取消通过容器传播到协程链上</span><br>            outer.cancel()<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-comment"># 自己已经完成且容器未完成，把自己的结果或者异常通过替身传播到协程链上</span><br>            exc = inner.exception()<br>            <span class="hljs-keyword">if</span> exc <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>                outer.set_exception(exc)<br>            <span class="hljs-keyword">else</span>:<br>                outer.set_result(inner.result())<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_outer_done_callback</span>(<span class="hljs-params">outer</span>):</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> inner.done():<br>            inner.remove_done_callback(_inner_done_callback)<br><br>    <span class="hljs-comment"># 添加回调，在执行成功或被取消时通知对方</span><br>    inner.add_done_callback(_inner_done_callback)<br>    outer.add_done_callback(_outer_done_callback)<br>    <span class="hljs-keyword">return</span> outer<br></code></pre></td></tr></table></figure><p>通过源码可以发现<code>shield</code>被调用的时候(假设驱动调用<code>shield</code>的<code>Task</code>名为<code>main.Task</code>)，会先通过<code>_ensure_future</code>辅助函数创建一个<code>Task</code>(<code>other.Task</code>)在后台异步运行可等待对象，驱动可等待对象的运行，由于是新的<code>Task</code>驱动着可等待对象的执行，所以<code>main.Task</code>的任何状态不会传播到当前的可等待对象。<br>接着创建一个<code>Future</code>容器，并在<code>other.Task</code>和<code>Future</code>容器挂上完成的回调使他们在完成的时候都能通知到对方，最后返回<code>Future</code>容器给<code>main.Task</code>，使<code>main.Task</code>能够间接的知道可等待对象的运行结果，如下图：<br><img   class="lazyload" data-original="https://fastly.jsdelivr.net/gh/so1n/so1n_blog_photo@master/blog_photo/16703080357051670308034840.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" ></p><p>不过<code>Future</code>容器完成的回调只是把托管可等待对象的<code>other.Task</code>回调给移除了，导致<code>main.Task</code>的状态不会同步到<code>other.Task</code>中(图中<code>Future</code>通知可等待对象<code>aws</code>的通道是不通的)，进而不会影响到托管的可等待对象。<br>而<code>other.Task</code>完成的回调会把任何状态同步到<code>Future</code>中，进而影响到<code>main.Task</code>。</p><h2 id="3-超时–asyncio-wait-for"><a href="#3-超时–asyncio-wait-for" class="headerlink" title="3.超时–asyncio.wait_for"></a>3.超时–asyncio.wait_for</h2><p><code>asyncio.wait_for</code>可以托管可等待对象，直到可等待对象完成，不过可等待对象在设定的时间内还没执行完成时会被直接取消执行并抛出<code>asyncio.TimeoutError</code>异常。<br>它的运行原理综合了上面的<code>asyncio.shield</code>和<code>asyncio.sleep</code>，它一样会为可等待对象创建一个<code>Future</code>容器,并在容器上挂了一个超时的回调和可等待对象执行结束的回调，接着就等待容器执行结束。<br>不过在了解<code>asyncio.wait_for</code>之前，先了解他用到的两个辅助函数<code>_cancel_and_wait</code>和<code>_release_waiter</code>，他们的源码如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_release_waiter</span>(<span class="hljs-params">waiter, *args</span>):</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> waiter.done():<br>        waiter.set_result(<span class="hljs-literal">None</span>)<br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_cancel_and_wait</span>(<span class="hljs-params">fut, loop</span>):</span><br>    waiter = loop.create_future()<br>    cb = functools.partial(_release_waiter, waiter)<br>    fut.add_done_callback(cb)<br><br>    <span class="hljs-keyword">try</span>:<br>        fut.cancel()<br>        <span class="hljs-keyword">await</span> waiter<br>    <span class="hljs-keyword">finally</span>:<br>        fut.remove_done_callback(cb)<br></code></pre></td></tr></table></figure><p>可以看出源码比较简单，他们的作用都是为了确保可等待对象能完全执行结束才返回，其中<code>_release_waiter</code>是确保可等待对象一定被设置为执行结束，而<code>_cancel_and_wait</code>是为了确保能等到可等待对象被取消且完整结束时才返回。</p><blockquote><p>可等待对象的<code>cancel</code>方法可以认为是异步的，调用后需要等事件循环再次调用可等待对象时，可等待对象才会被取消。而<code>_cancel_and_wait</code>通过一个容器来规避这个问题，使取消这个操作变为同步的，这个方法在某些开发场景经常被使用，如果不是私有API就更好了。</p></blockquote><p>接下来就可以通过<code>wait_for</code>的源码了解他的执行逻辑了，源码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">wait_for</span>(<span class="hljs-params">fut, timeout</span>):</span><br>    loop = events.get_running_loop()<br><br>    <span class="hljs-keyword">if</span> timeout <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> fut<br><br>    <span class="hljs-keyword">if</span> timeout &lt;= <span class="hljs-number">0</span>:<br>        <span class="hljs-comment"># 当超时的值小于等于0时就意味着想马上得到结果</span><br>        <br>        fut = ensure_future(fut, loop=loop)<br><br>        <span class="hljs-keyword">if</span> fut.done():<br>            <span class="hljs-comment"># 如果执行完成就返回可等待对象的数据</span><br>            <span class="hljs-keyword">return</span> fut.result()<br>        <span class="hljs-comment"># 取消可等待对象并等待</span><br>        <span class="hljs-keyword">await</span> _cancel_and_wait(fut, loop=loop)<br>        <span class="hljs-comment"># 如果被_cancel_and_wait取消，那么会抛出CancelledError异常，这时候把它转为超时异常</span><br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-keyword">return</span> fut.result()<br>        <span class="hljs-keyword">except</span> exceptions.CancelledError <span class="hljs-keyword">as</span> exc:<br>            <span class="hljs-keyword">raise</span> exceptions.TimeoutError() <span class="hljs-keyword">from</span> exc<br><br>    <span class="hljs-comment"># 初始化一个Future,只有在超时和完成时才会变为done</span><br>    waiter = loop.create_future()<br>    timeout_handle = loop.call_later(timeout, _release_waiter, waiter)<br>    cb = functools.partial(_release_waiter, waiter)<br><br>    fut = ensure_future(fut, loop=loop)<br>    fut.add_done_callback(cb)<br><br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-keyword">await</span> waiter<br>        <span class="hljs-keyword">except</span> exceptions.CancelledError:<br>            <span class="hljs-comment"># 此时是asyncio.Task被取消，并把取消传播到waiter</span><br>            <span class="hljs-keyword">if</span> fut.done():<br>                <span class="hljs-keyword">return</span> fut.result()<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-comment"># 如果任务被取消了，那么需要确保任务没有被执行才返回</span><br>                fut.remove_done_callback(cb)<br>                <span class="hljs-keyword">await</span> _cancel_and_wait(fut, loop=loop)<br>                <span class="hljs-keyword">raise</span><br>        <span class="hljs-comment"># 计时结束或者是执行完毕的情况</span><br>        <span class="hljs-keyword">if</span> fut.done():<br>            <span class="hljs-comment"># 执行完毕，返回对应的值</span><br>            <span class="hljs-keyword">return</span> fut.result()<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-comment"># 计时结束，清理资源，并抛出异常</span><br>            fut.remove_done_callback(cb)<br>            <span class="hljs-comment"># 如果任务被取消了，那么需要确保任务没有被执行才返回</span><br>            <span class="hljs-keyword">await</span> _cancel_and_wait(fut, loop=loop)<br>            <span class="hljs-comment"># 如果被_cancel_and_wait取消，那么会抛出CancelledError异常，这时候把它转为超时异常</span><br>            <span class="hljs-keyword">try</span>:<br>                <span class="hljs-keyword">return</span> fut.result()<br>            <span class="hljs-keyword">except</span> exceptions.CancelledError <span class="hljs-keyword">as</span> exc:<br>                <span class="hljs-keyword">raise</span> exceptions.TimeoutError() <span class="hljs-keyword">from</span> exc<br>    <span class="hljs-keyword">finally</span>:<br>        timeout_handle.cancel()<br></code></pre></td></tr></table></figure><p><code>wait_for</code>的源码为了兼容各种情况，代码复杂度比较高，同时超时参数小于等于0跟大于0的逻辑是一样的，分开写只是为了避免在小于等于0时创建了一些额外的对象，在精简了一些<code>asyncio.Task</code>传播异常给<code>waiter</code>的逻辑后，<code>wait_for</code>的执行逻辑如下图：<br><img   class="lazyload" data-original="https://fastly.jsdelivr.net/gh/so1n/so1n_blog_photo@master/blog_photo/16703111707771670311170743.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" ></p><blockquote><p>fut为可等待对象，timeout为超时时间</p></blockquote><p>可以看到<code>wait_for</code>的主要逻辑是先创建一个名为<code>waiter</code>的容器，接着通过<code>loop.call_later</code>指定在多少时间后释放容器，然后再通过<code>ensure_future</code>使另一个<code>asyncio.Task</code>来托管可等待对象，并安排执行完毕的时候释放容器，再等待<code>waiter</code>容器的执行直到被释放。当容器被释放的时候再判断可等待对象是否执行完毕，如果执行完毕了就直接返回，否则抛出超时异常。</p><h2 id="4-简单的等待–wait"><a href="#4-简单的等待–wait" class="headerlink" title="4.简单的等待–wait"></a>4.简单的等待–wait</h2><p><code>asyncio.wait</code>用于等待一批可等待对象，当有一个可等待对象执行完成或者出现异常的时候才会返回数据(具体还是要看<code>return_when</code>指定的条件，默认为所有等待对象结束或取消时才返回)，需要注意的是<code>wait</code>虽然支持<code>timeout</code>参数，但是在超时的试试不会取消可等待对象，也不会抛出超时的异常，只会把完成的可等待对象放在完成的集合，把未完成的可等待对象放在未完成的集合并返回，如下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> asyncio<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> asyncio.wait(<br>        &#123;asyncio.create_task(asyncio.sleep(<span class="hljs-number">1</span>))&#125;,<br>        timeout=<span class="hljs-number">0.5</span><br>    )<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    asyncio.run(main())<br></code></pre></td></tr></table></figure><p>这段代码可以正常的运作，不会抛出超时错，不过还要注意的是在后续版本中<code>asyncio.wait</code>只支持<code>Task</code>对象，如果想要传入的是<code>coro</code>和<code>Future</code>对象，则需要开发者自己手动转换。<br><code>wait</code>的逻辑与<code>wait_for</code>类似，源码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_wait</span>(<span class="hljs-params">fs, timeout, return_when, loop</span>):</span><br>    <span class="hljs-keyword">assert</span> fs, <span class="hljs-string">&#x27;Set of Futures is empty.&#x27;</span><br>    waiter = loop.create_future()<br>    timeout_handle = <span class="hljs-literal">None</span><br>    <span class="hljs-keyword">if</span> timeout <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>        <span class="hljs-comment"># 定义一个time handler,在timeout秒后通过`_release_waiter`完成.</span><br>        timeout_handle = loop.call_later(timeout, _release_waiter, waiter)<br>    counter = <span class="hljs-built_in">len</span>(fs)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_on_completion</span>(<span class="hljs-params">f</span>):</span><br>        <span class="hljs-comment"># 每个可等待对象执行完成的回调</span><br>        <span class="hljs-keyword">nonlocal</span> counter<br>        counter -= <span class="hljs-number">1</span><br>        <span class="hljs-keyword">if</span> (counter &lt;= <span class="hljs-number">0</span> <span class="hljs-keyword">or</span><br>            return_when == FIRST_COMPLETED <span class="hljs-keyword">or</span><br>            return_when == FIRST_EXCEPTION <span class="hljs-keyword">and</span><br>             (<span class="hljs-keyword">not</span> f.cancelled() <span class="hljs-keyword">and</span> f.exception() <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>)<br>        ):<br>            <span class="hljs-comment"># 如果所有任务执行完成，或者是第一个完成或者是第一个抛出异常时，</span><br>            <span class="hljs-comment"># 意味着执行完成，需要取消time handler,并标记为完成</span><br>            <span class="hljs-keyword">if</span> timeout_handle <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>                timeout_handle.cancel()<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> waiter.done():<br>                waiter.set_result(<span class="hljs-literal">None</span>)<br>    <span class="hljs-comment"># 为每个可等待对象添加回调</span><br>    <span class="hljs-keyword">for</span> f <span class="hljs-keyword">in</span> fs:<br>        f.add_done_callback(_on_completion)<br><br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-comment"># 等待替身执行完成</span><br>        <span class="hljs-keyword">await</span> waiter<br>    <span class="hljs-keyword">finally</span>:<br>        <span class="hljs-comment"># 取消time handler并移除回调(因为cancel是异步的)</span><br>        <span class="hljs-keyword">if</span> timeout_handle <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            timeout_handle.cancel()<br>        <span class="hljs-keyword">for</span> f <span class="hljs-keyword">in</span> fs:<br>            f.remove_done_callback(_on_completion)<br><br>    <span class="hljs-comment"># 处理并返回done和pending，其中done代表完成，pending代表执行中。</span><br>    done, pending = <span class="hljs-built_in">set</span>(), <span class="hljs-built_in">set</span>()<br>    <span class="hljs-keyword">for</span> f <span class="hljs-keyword">in</span> fs:<br>        <span class="hljs-keyword">if</span> f.done():<br>            done.add(f)<br>        <span class="hljs-keyword">else</span>:<br>            pending.add(f)<br>    <span class="hljs-keyword">return</span> done, pending<br></code></pre></td></tr></table></figure><p>可以看到<code>wait_for</code>的复杂度没有<code>wait</code>高，而且可以看到<code>asyncio.wait</code>是等<code>waiter</code>这个容器执行完并移除可等待对象上面的<code>_on_completion</code>回调后才把可等待对象按照是否完成区分到<code>done</code>和<code>pending</code>两个集合，这样的准确度比在<code>_on_completion</code>高一些，但是如果开发者在处理集合时触发一些异步操作也可能导致<code>pending</code>集合中的部分可等待对象变为完成的，如下代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> asyncio<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    f_list = [asyncio.Future() <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>)]<br>    done, pending = <span class="hljs-keyword">await</span> asyncio.wait(f_list, timeout=<span class="hljs-number">1</span>)<br>    print(<span class="hljs-built_in">len</span>(done), <span class="hljs-built_in">len</span>(pending))<br>    print([i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> pending <span class="hljs-keyword">if</span> i.done()])<br>    f_list[<span class="hljs-number">1</span>].set_result(<span class="hljs-literal">True</span>)<br>    print([i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> pending <span class="hljs-keyword">if</span> i.done()])<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    asyncio.run(main())<br><span class="hljs-comment"># &gt;&gt;&gt; 0 10</span><br><span class="hljs-comment"># &gt;&gt;&gt; []</span><br><span class="hljs-comment"># &gt;&gt;&gt; [&lt;Future finished result=True&gt;]</span><br></code></pre></td></tr></table></figure><p>通过输出可以发现，在<code>asyncio.wait</code>执行完毕后，<code>pending</code>中的完成的元素只有0个，而在后续强制为其中的一个<code>Future</code>设置数据后，<code>pending</code>中完成的元素有1个了。</p><h2 id="5-迭代可等待对象的完成–asyncio-as-completed"><a href="#5-迭代可等待对象的完成–asyncio-as-completed" class="headerlink" title="5.迭代可等待对象的完成–asyncio.as_completed"></a>5.迭代可等待对象的完成–asyncio.as_completed</h2><p><code>asyncio.wait</code>的机制是只要被触发就会返回，其他尚未完成的可等待对象需要开发者自己在处理，而<code>asyncio.as_completed</code>可以确保每个可等待对象完成返回数据或者超时时抛出异常，使用方法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> asyncio<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sub</span>(<span class="hljs-params">i</span>):</span><br>    <span class="hljs-keyword">await</span> asyncio.sleep(i)<br>    <span class="hljs-keyword">return</span> i<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    <span class="hljs-keyword">for</span> f <span class="hljs-keyword">in</span> asyncio.as_completed([sub(i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>)], timeout=<span class="hljs-number">3</span>):<br>        print(<span class="hljs-keyword">await</span> f)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    asyncio.run(main())<br><span class="hljs-comment"># &gt;&gt;&gt; 0</span><br><span class="hljs-comment"># &gt;&gt;&gt; 1</span><br><span class="hljs-comment"># &gt;&gt;&gt; 2</span><br><span class="hljs-comment"># &gt;&gt;&gt; Traceback (most recent call last):</span><br><span class="hljs-comment">#       File &quot;/home/so1n/github/demo_project/demo.py&quot;, line 18, in &lt;module&gt;</span><br><span class="hljs-comment">#         asyncio.run(main())</span><br><span class="hljs-comment">#       File &quot;/usr/lib/python3.7/asyncio/runners.py&quot;, line 43, in run</span><br><span class="hljs-comment">#         return loop.run_until_complete(main)</span><br><span class="hljs-comment">#       File &quot;/usr/lib/python3.7/asyncio/base_events.py&quot;, line 584, in run_until_complete</span><br><span class="hljs-comment">#         return future.result()</span><br><span class="hljs-comment">#       File &quot;/home/so1n/github/demo_project/demo.py&quot;, line 14, in main</span><br><span class="hljs-comment">#         print(await f)</span><br><span class="hljs-comment">#       File &quot;/usr/lib/python3.7/asyncio/tasks.py&quot;, line 532, in _wait_for_one</span><br><span class="hljs-comment">#         raise futures.TimeoutError</span><br><span class="hljs-comment">#     concurrent.futures._base.TimeoutError</span><br></code></pre></td></tr></table></figure><p>该程序并发执行5个协程，其中执行最久的时间是5秒，而<code>as_completed</code>设置的超时为3秒。通过输出可以发现，每当一个可等待对象执行结束时就会把数据抛出来，当超时则会抛出超时错误。为了能达每有一个可等待对象就返回一次数据的效果，<code>as_completed</code>通过一个队列来维护数据的返回，它的源码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">as_completed</span>(<span class="hljs-params">fs, *, timeout=<span class="hljs-literal">None</span></span>):</span><br>    <span class="hljs-keyword">from</span> .queues <span class="hljs-keyword">import</span> Queue  <span class="hljs-comment"># Import here to avoid circular import problem.</span><br>    done = Queue()<br><br>    loop = events._get_event_loop()<br>    todo = &#123;ensure_future(f, loop=loop) <span class="hljs-keyword">for</span> f <span class="hljs-keyword">in</span> <span class="hljs-built_in">set</span>(fs)&#125;<br>    timeout_handle = <span class="hljs-literal">None</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_on_timeout</span>():</span><br>        <span class="hljs-comment"># 超时时调用，需要注意的是，失败时结果为空，所以要推送一个空的数据到队列中</span><br>        <span class="hljs-comment"># 在消费者发现元素为空时抛出错误</span><br>        <span class="hljs-keyword">for</span> f <span class="hljs-keyword">in</span> todo:<br>            f.remove_done_callback(_on_completion)<br>            done.put_nowait(<span class="hljs-literal">None</span>)  <span class="hljs-comment"># Queue a dummy value for _wait_for_one().</span><br>        todo.clear()  <span class="hljs-comment"># Can&#x27;t do todo.remove(f) in the loop.</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_on_completion</span>(<span class="hljs-params">f</span>):</span><br>        <span class="hljs-comment"># 如果成功，就把Future推送到队列中，消费者可以通过Future获取到结果</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> todo:<br>            <span class="hljs-keyword">return</span>  <span class="hljs-comment"># _on_timeout() was here first.</span><br>        todo.remove(f)<br>        done.put_nowait(f)<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> todo <span class="hljs-keyword">and</span> timeout_handle <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            timeout_handle.cancel()<br><br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_wait_for_one</span>():</span><br>        f = <span class="hljs-keyword">await</span> done.get()<br>        <span class="hljs-keyword">if</span> f <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-comment"># 如果元素为空，则证明已经超时了，要抛出异常</span><br>            <span class="hljs-keyword">raise</span> exceptions.TimeoutError<br>        <span class="hljs-keyword">return</span> f.result()<br><br>    <span class="hljs-keyword">for</span> f <span class="hljs-keyword">in</span> todo:<br>        f.add_done_callback(_on_completion)<br>    <span class="hljs-keyword">if</span> todo <span class="hljs-keyword">and</span> timeout <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>        timeout_handle = loop.call_later(timeout, _on_timeout)<br>    <span class="hljs-comment"># 通过生成器语法返回协程函数，该协程函数可以获取最近完成的可等待对象的结果</span><br>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(todo)):<br>        <span class="hljs-keyword">yield</span> _wait_for_one()<br><br></code></pre></td></tr></table></figure><p>通过源码可以发现可等待对象就像生产者一样，执行结束的时候就会把结果投递给队列，同时<code>as_completed</code>会迭代跟可等待对象的数量一样的<code>_wait_for_one</code>协程函数，供开发者消费数据。不过需要注意的是<code>as_completed</code>在超时的时候，并不会取消尚未完成的可等待对象，他们会变为不可控的状态，在某些时候会造成内存溢出，如下示例代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> asyncio<br><span class="hljs-keyword">import</span> random<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sub</span>():</span><br>    <span class="hljs-comment"># 一半的几率会被set一个值并返回，一半的几率会卡死</span><br>    f = asyncio.Future()<br>    <span class="hljs-keyword">if</span> random.choice([<span class="hljs-number">0</span>, <span class="hljs-number">1</span>]) == <span class="hljs-number">0</span>:<br>        f.set_result(<span class="hljs-literal">None</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> f<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-keyword">for</span> f <span class="hljs-keyword">in</span> asyncio.as_completed([sub() <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>)], timeout=<span class="hljs-number">1</span>):<br>            print(<span class="hljs-keyword">await</span> f)<br>    <span class="hljs-keyword">except</span> asyncio.TimeoutError:<br>        <span class="hljs-comment"># 忽略超时</span><br>        <span class="hljs-keyword">pass</span><br>    <span class="hljs-comment"># 统计未完成的sub任务</span><br>    cnt = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> asyncio.all_tasks():<br>        <span class="hljs-keyword">if</span> i._coro.__name__ == sub.__name__:<br>            cnt += <span class="hljs-number">1</span><br>    print(<span class="hljs-string">&quot;runing task by name sub:&quot;</span>, cnt)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    asyncio.run(main())<br><span class="hljs-comment"># &gt;&gt;&gt; None</span><br><span class="hljs-comment"># &gt;&gt;&gt; None</span><br><span class="hljs-comment"># &gt;&gt;&gt; None</span><br><span class="hljs-comment"># &gt;&gt;&gt; runing task by name sub: 2</span><br></code></pre></td></tr></table></figure><p>通过结果(由于采用随机，结果可能不一样)可以发现，<code>sub</code>成功执行完成的数量有3个(输出<code>None</code>)，而在<code>as_completed</code>触发超时后仍有两个<code>sub</code>在执行中，这时的两个<code>sub</code>成为无人管理的可等待对象，除非开发者通过<code>asyncio.all_tasks</code>去找到他并清理掉，否则这几个可等待对象会一直伴随着程序运行，这很容易造成内存溢出。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前记&quot;&gt;&lt;a href=&quot;#前记&quot; class=&quot;headerlink&quot; title=&quot;前记&quot;&gt;&lt;/a&gt;前记&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Asyncio&lt;/code&gt;在经过一段时间的发展以及获取&lt;code&gt;Curio&lt;/code&gt;等第三方库的经验来提供更多的功能，目</summary>
      
    
    
    <content src="https://fastly.jsdelivr.net/gh/so1n/so1n_blog_photo@master/blog_photo/16550442517731649661119526images.png" type="image"/>
    
    
    <category term="Python Asyncio" scheme="http://so1n.me/categories/Python-Asyncio/"/>
    
    
    <category term="Python" scheme="http://so1n.me/tags/Python/"/>
    
    <category term="Asyncio" scheme="http://so1n.me/tags/Asyncio/"/>
    
  </entry>
  
  <entry>
    <title>Python-gRPC实践(9)--gRPC在gevent与asyncio的简单使用对比.md</title>
    <link href="http://so1n.me/2022/11/25/Python-gRPC%E5%AE%9E%E8%B7%B5(9)--gRPC%E5%9C%A8gevent%E4%B8%8Easyncio%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%E5%92%8C%E5%AF%B9%E6%AF%94/"/>
    <id>http://so1n.me/2022/11/25/Python-gRPC%E5%AE%9E%E8%B7%B5(9)--gRPC%E5%9C%A8gevent%E4%B8%8Easyncio%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%E5%92%8C%E5%AF%B9%E6%AF%94/</id>
    <published>2022-11-25T12:35:24.000Z</published>
    <updated>2022-11-29T09:55:59.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前在<a href="https://so1n.me/categories/Python-gRPC%E5%AE%9E%E8%B7%B5/">Python-gRPC实践</a>系列文章中都是在多线程模式中介绍如何使用<code>gRPC</code>，但是在<code>Python</code>生态中更偏好通过协程的方式来运行服务，而<code>Python</code>的协程运行方式却有多种，虽然他们的原理类似，但是使用上却有区别，本文主要是对在<code>gevent</code>和<code>asyncio</code>中对<code>gRPC</code>的使用进行对比。</p><h2 id="1-简单的例子"><a href="#1-简单的例子" class="headerlink" title="1.简单的例子"></a>1.简单的例子</h2><p>本章以官方中的<a href="https://github.com/grpc/grpc/blob/master/examples/protos/helloworld.proto">helloworld</a> <code>Protobuf</code>文件为例子，介绍在不同协程中如何运行服务，该<code>Protobuf</code>文件内容如下:</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs protobuf"><span class="hljs-class"><span class="hljs-keyword">service</span> <span class="hljs-title">Greeter</span> </span>&#123;<br>  <span class="hljs-comment">// Sends a greeting</span><br>  <span class="hljs-function"><span class="hljs-keyword">rpc</span> SayHello (HelloRequest) <span class="hljs-keyword">returns</span> (HelloReply) </span>&#123;&#125;<br>&#125;<br><br><span class="hljs-comment">// The request message containing the user&#x27;s name.</span><br><span class="hljs-class"><span class="hljs-keyword">message</span> <span class="hljs-title">HelloRequest</span> </span>&#123;<br>  <span class="hljs-built_in">string</span> name = <span class="hljs-number">1</span>;<br>  <span class="hljs-built_in">int32</span> sleep_millisecond = <span class="hljs-number">2</span>;<br>&#125;<br><br><span class="hljs-comment">// The response message containing the greetings</span><br><span class="hljs-class"><span class="hljs-keyword">message</span> <span class="hljs-title">HelloReply</span> </span>&#123;<br>  <span class="hljs-built_in">string</span> <span class="hljs-class"><span class="hljs-keyword">message</span> = 1;</span><br><span class="hljs-class">&#125;</span><br></code></pre></td></tr></table></figure><p>其中<code>HelloRequest</code>和<code>HelloReply</code>是<code>Message</code>，<code>Gretter</code>为<code>service</code>，它们生成的对应代码位于<code>grpc_asyncio_example/protos</code>目录下面，而对应的客户端代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> logging<br><span class="hljs-keyword">import</span> grpc<br><span class="hljs-keyword">from</span> grpc_asyncio_example.protos <span class="hljs-keyword">import</span> helloworld_pb2, helloworld_pb2_grpc<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">client</span>(<span class="hljs-params">target: <span class="hljs-built_in">str</span> = <span class="hljs-string">&quot;localhost:9999&quot;</span></span>):</span><br>    <span class="hljs-keyword">with</span> grpc.insecure_channel(target=target) <span class="hljs-keyword">as</span> channel:<br>        stub: helloworld_pb2_grpc.GreeterStub = helloworld_pb2_grpc.GreeterStub(channel)<br>        response: helloworld_pb2.HelloReply = stub.SayHello(helloworld_pb2.HelloRequest(name=<span class="hljs-string">&#x27;you&#x27;</span>), timeout=<span class="hljs-number">10</span>)<br>    logging.info(<span class="hljs-string">&quot;Greeter client received: &quot;</span> + response.message)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    logging.basicConfig()<br>    client()<br></code></pre></td></tr></table></figure><p>服务端代码如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">from</span> concurrent <span class="hljs-keyword">import</span> futures<br><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> logging<br><br><span class="hljs-keyword">import</span> grpc<br><span class="hljs-keyword">from</span> grpc_asyncio_example.protos <span class="hljs-keyword">import</span> helloworld_pb2, helloworld_pb2_grpc<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Greeter</span>(<span class="hljs-params">helloworld_pb2_grpc.GreeterServicer</span>):</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">SayHello</span>(<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">        self, request: helloworld_pb2.HelloRequest, context: grpc.ServicerContext</span></span><br><span class="hljs-function"><span class="hljs-params">    </span>) -&gt; helloworld_pb2.HelloReply:</span><br>        time.sleep(request.sleep_millisecond / <span class="hljs-number">1000</span>)  <span class="hljs-comment"># 模拟IO</span><br>        <span class="hljs-keyword">return</span> helloworld_pb2.HelloReply(message=<span class="hljs-string">&#x27;Hello, %s!&#x27;</span> % request.name)<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">serve</span>(<span class="hljs-params">target: <span class="hljs-built_in">str</span> = <span class="hljs-string">&quot;localhost:9999&quot;</span></span>) -&gt; grpc.server:</span><br>    server: grpc.server = grpc.server(futures.ThreadPoolExecutor(max_workers=<span class="hljs-number">100</span>))<br>    helloworld_pb2_grpc.add_GreeterServicer_to_server(Greeter(), server)<br>    server.add_insecure_port(target)<br>    server.start()<br>    <span class="hljs-keyword">return</span> server<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    logging.basicConfig()<br>    serve().wait_for_termination()<br></code></pre></td></tr></table></figure><p>客户端与服务端的代码都非常简单，客户端主要是发送一个请求，该请求参数为<code>name=you</code>，而服务端则是解析参数，并把<code>Hello &#123;name&#125;</code>返回给客户端，最终由客户端把服务端返回的消息打印出来。<br>这份代码只可以用于<code>Python</code>的多线程中，无法在协程环境中运行，接下来讲分别介绍<code>Python gRPC</code>在<code>gevent</code>和<code>asyncio</code>中的使用和原理分析。</p><blockquote><p>只介绍<code>UNARY_UNARY</code>请求方式，其他方式不同可以通过对应的文档了解如何使用。</p></blockquote><h2 id="2-Gevent"><a href="#2-Gevent" class="headerlink" title="2.Gevent"></a>2.Gevent</h2><p><code>gevent </code>是一个基于协程的<code>Python</code>网络库，它通过<code>greenlet</code>在<code>libev</code>或<code>libuv</code>事件循环之上提供高级同步API，在<code>Python</code>程序使用<code>gevent</code>很简单，只要在代码引入如下猴子补丁语法:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> gevent.monkey<br>gevent.monkey.patch_all()<br></code></pre></td></tr></table></figure><p>那么整个程序的<code>Python</code>代码都支持<code>gevent</code>了，程序也可以通过<code>gevent</code>来运行。</p><p>不过<code>Python gRPC</code>是个例外，因为<code>Python gRPC</code>的核心是由<code>C</code>语言编写的，而<code>gevent</code>应用的猴子补丁只能涉及到用<code>Python</code>语言编写的代码，所以单靠应用<code>gevent</code>的猴子补丁是没办法使<code>Python gRPC</code>在<code>gevent</code>中运行的，可能还会导致调用<code>gRPC</code>客户端方法时出现卡死的情况。</p><p>好在<code>Python gRPC</code>提供了一个用法，使<code>Python gRPC</code>能够在<code>gevent</code>中兼容运行，代码如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-comment"># 先应用猴子补丁</span><br><span class="hljs-keyword">import</span> gevent.monkey<br>gevent.monkey.patch_all()<br><br><span class="hljs-comment"># 再为gRPC启用gevent兼容模式</span><br><span class="hljs-keyword">import</span> grpc.experimental.gevent<br>grpc.experimental.gevent.init_gevent()<br><br><span class="hljs-comment"># gRPC客户端或服务端的代码</span><br>...<br><br></code></pre></td></tr></table></figure><p>这份代码通过调用<code>grpc.experimental.gevent.init_gevent</code>，使<code>gRPC</code>能在<code>gevent</code>中运行，而且在<code>gevent</code>模式下<code>gRPC</code>的所有模块和方法的使用方式都不需要改变。 但是<code>gRPC</code>在通过<code>gevent</code>的兼容模式运行的时候，性能会大打折扣，比如通过下面的命令:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">ghz -c 100 -n 10000 \<br>    --insecure \<br>    --proto ../protos/grpc_asyncio_example/protos/helloworld.proto \<br>    --call helloworld.Greeter.SayHello \<br>    -d <span class="hljs-string">&#x27;&#123;&quot;name&quot;:&quot;Joe&quot;, &quot;sleep_millisecond&quot;: 10&#125;&#x27;</span> \<br>    localhost:9999<br></code></pre></td></tr></table></figure><p>对<code>gevent</code>模式下的<code>Python gRPC</code>服务进行压测，其中<code>c</code>是指并发数，<code>n</code>为最大请求数，而<code>-d</code>是请求的参数，里面的<code>sleep_millisecond</code>代表服务端收到请求后会休眠10毫秒来模拟IO处理，他们的压测结果如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 多线程模式</span><br>Summary:<br>  Count:10000<br>  Total:2.67 s<br>  Slowest:45.01 ms<br>  Fastest:12.04 ms<br>  Average:26.34 ms<br>  Requests/sec:3746.87<br><span class="hljs-comment"># gevent兼容模式</span><br>Summary:<br>  Count:10000<br>  Total:5.23 s<br>  Slowest:69.31 ms<br>  Fastest:13.43 ms<br>  Average:51.83 ms<br>  Requests/sec:1913.44<br></code></pre></td></tr></table></figure><p>通过压测结果可以发现，<code>gevent</code>兼容模式的性能只有多线程模式下的一半(以<code>Requests/sec</code>对比)，会有这样的结果是因为<code>Python gRPC</code>的异步请求是在多线程上执行，同时<code>Python gRPC</code>是一个基于<code>C</code>的库，它可以绕过<code>Python</code>的<code>GIL</code>，从而获得了CPU多核的并发能力，而在启用了<code>gevent</code>兼容模式后<code>gevent</code>可能会导致多线程无法绕过<code>Python</code>的<code>GIL</code>，从而失去了上面提到的并发性。</p><p>此外<code>Python gRPC</code>目前只做到了兼容<code>gevent</code>的运行，通过<a href="https://github.com/grpc/grpc/blob/master/src/python/grpcio_tests/commands.py">commands.py</a>中<code>TestGevent</code>的注释可以看出<code>Python gRPC</code>尚未对<code>gevent</code>模式的性能做出优化，所以建议不要在<code>Python gRPC</code>的服务端启用<code>gevent</code>兼容模式，在<code>Python gRPC</code>的客户端可以根据实际情况决定是否启用(比如在<code>gunicorn</code> + <code>gevent</code> + <code>Flask</code>运行的服务中的<code>Python gRPC</code>客户端)。</p><blockquote><p>通过下列文件可以看出<code>gevent</code>兼容模式是把线程池替换为<code>gevent</code>的线程池:</p><ul><li>客户端调用到<code>gevent</code>的代码<a href="https://github.com/grpc/grpc/blob/2d4f3c56001cd1e1f85734b2f7c5ce5f2797c38a/src/python/grpcio/grpc/_cython/_cygrpc/credentials.pyx.pxi#L27">credentials.pyx.pxi</a></li><li>服务端调用到<code>gevent</code>的代码<a href="https://github.com/grpc/grpc/blob/b8c2818c6b5b9013adfe3f02a49dcc93675a7787/src/python/grpcio/grpc/_cython/_cygrpc/completion_queue.pyx.pxi#L111">completion_queue.pyx.pxi</a></li><li>启用<code>gevent</code>兼容模式的代码<a href="https://github.com/grpc/grpc/blob/066a310df1fe9d68a00f346bd36e6c965d62e528/src/python/grpcio/grpc/_cython/_cygrpc/grpc_gevent.pyx.pxi">grpc_gevent.pyx.pxi</a></li></ul></blockquote><h2 id="3-Asyncio"><a href="#3-Asyncio" class="headerlink" title="3.Asyncio"></a>3.Asyncio</h2><p><code>Python gRPC</code>一开始是不支持在<code>Asyncio</code>中运行的，所以社区出现了一个名为<a href="https://github.com/vmagamedov/grpclib">grpclib</a>的库来解决这一问题，而官方的<code>Python gRPC</code>在后面的迭代后诞生了<code>grpc.aio</code>模块以支持<code>grpc</code>在<code>Asyncio</code>中运行。</p><h3 id="3-1-grpclib"><a href="#3-1-grpclib" class="headerlink" title="3.1.grpclib"></a>3.1.grpclib</h3><p><a href="https://github.com/vmagamedov/grpclib">grpclib</a>这个库提供了纯<code>Python</code>的实现，这意味着能按自己的需求对它进行拓展，可塑性强。<br>所以诞生了基于<a href="https://github.com/vmagamedov/grpclib">grpclib</a>和<a href="https://github.com/eigenein/protobuf/">pure-protobuf</a>封装的另一个库–<a href="https://github.com/danielgtaylor/python-betterproto/tree/master">python-betterproto</a>。该库可以使开发者编写<code>grpc</code>代码更加的方便，比如<a href="https://github.com/grpc/grpc/blob/master/examples/protos/helloworld.proto">helloworld</a>生成对应的<code>Message</code>代码如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-meta">@dataclass(<span class="hljs-params">eq=<span class="hljs-literal">False</span>, <span class="hljs-built_in">repr</span>=<span class="hljs-literal">False</span></span>)</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloRequest</span>(<span class="hljs-params">betterproto.Message</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;The request message containing the user&#x27;s name.&quot;&quot;&quot;</span><br><br>    name: <span class="hljs-built_in">str</span> = betterproto.string_field(<span class="hljs-number">1</span>)<br>    sleep_millisecond: <span class="hljs-built_in">int</span> = betterproto.int32_field(<span class="hljs-number">2</span>)<br><br><br><span class="hljs-meta">@dataclass(<span class="hljs-params">eq=<span class="hljs-literal">False</span>, <span class="hljs-built_in">repr</span>=<span class="hljs-literal">False</span></span>)</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloReply</span>(<span class="hljs-params">betterproto.Message</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;The response message containing the greetings&quot;&quot;&quot;</span><br><br>    message: <span class="hljs-built_in">str</span> = betterproto.string_field(<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p>可以看到这段代码打可读性比起官方的<code>Python gRPC</code>要高很多，这样开发者在查阅<code>message</code>的用法时会非常的方便，而客户端和服务端的用法则与官方的<code>Python gRPC</code>类似，比如客户端的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> asyncio<br><span class="hljs-keyword">import</span> logging<br><br><span class="hljs-keyword">from</span> grpclib.client <span class="hljs-keyword">import</span> Channel<br><br><span class="hljs-keyword">from</span> grpc_asyncio_example.protos <span class="hljs-keyword">import</span> helloworld<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">client</span>() -&gt; <span class="hljs-keyword">None</span>:</span><br>    channel: Channel = Channel(host=<span class="hljs-string">&quot;localhost&quot;</span>, port=<span class="hljs-number">9999</span>)<br>    response: helloworld.HelloReply = <span class="hljs-keyword">await</span> helloworld.GreeterStub(channel).say_hello(<br>        hello_request=helloworld.HelloRequest(name=<span class="hljs-string">&quot;you&quot;</span>)<br>    )<br>    logging.info(response)<br><br>    <span class="hljs-comment"># don&#x27;t forget to close the channel when done!</span><br>    channel.close()<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    asyncio.run(client())<br></code></pre></td></tr></table></figure><p>可以看出与多线程的<code>Python gRPC</code>代码类似，而服务端的代码如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> asyncio<br><br><span class="hljs-keyword">from</span> grpclib.server <span class="hljs-keyword">import</span> Server<br><br><span class="hljs-keyword">from</span> grpc_asyncio_example.protos <span class="hljs-keyword">import</span> helloworld<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloWorldService</span>(<span class="hljs-params">helloworld.GreeterBase</span>):</span><br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">say_hello</span>(<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">        self, request: <span class="hljs-string">&quot;helloworld.HelloRequest&quot;</span></span></span><br><span class="hljs-function"><span class="hljs-params">    </span>) -&gt; &quot;helloworld.HelloReply&quot;:</span><br>        <span class="hljs-keyword">await</span> asyncio.sleep(request.sleep_millisecond / <span class="hljs-number">1000</span>)<br>        <span class="hljs-keyword">return</span> helloworld.HelloReply(message=<span class="hljs-string">&quot;Hello, %s!&quot;</span> % request.name)<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">serve</span>() -&gt; Server:</span><br>    server: Server = Server([HelloWorldService()])<br>    <span class="hljs-keyword">await</span> server.start(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">9999</span>)<br>    <span class="hljs-keyword">return</span> server<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br><br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>() -&gt; <span class="hljs-keyword">None</span>:</span><br>        <span class="hljs-keyword">await</span> (<span class="hljs-keyword">await</span> serve()).wait_closed()<br><br>    asyncio.run(main())<br></code></pre></td></tr></table></figure><p>可以看出服务端的代码与多线程的<code>Python gRPC</code>也类似，但是缺少<code>Context</code>的参数，如果跳进去<code>helloworld.GretterBase</code>查看源码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GreeterBase</span>(<span class="hljs-params">ServiceBase</span>):</span><br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">say_hello</span>(<span class="hljs-params">self, hello_request: <span class="hljs-string">&quot;HelloRequest&quot;</span></span>) -&gt; &quot;HelloReply&quot;:</span><br>        <span class="hljs-keyword">raise</span> grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)<br><br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__rpc_say_hello</span>(<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">        self, stream: <span class="hljs-string">&quot;grpclib.server.Stream[HelloRequest, HelloReply]&quot;</span></span></span><br><span class="hljs-function"><span class="hljs-params">    </span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        request = <span class="hljs-keyword">await</span> stream.recv_message()<br>        response = <span class="hljs-keyword">await</span> self.say_hello(request)<br>        <span class="hljs-keyword">await</span> stream.send_message(response)<br></code></pre></td></tr></table></figure><p>则可以发现在<code>__rpc_say_hellp</code>方法中的<code>stream</code>对象是类似于官方<code>Python gRPC</code>中的<code>Context</code>，这意味着如果要使用<code>Context</code>方法时需要自己新增一个方法去处理，好在该库是纯<code>Python</code>编写的，<code>grpclib</code>对应客户端的<code>Channel</code>和服务端对应的<code>Server</code>代码也封装得很好，不像官方<code>Python gRPC</code>一样跳进源代码后就不知道它的代码在哪里，所以处理起来比较方便。</p><p>不过它也因此拥有了纯<code>Python</code>编写库的缺点–性能较低， 在经过与<code>gevent</code>一样的命令进行压测后得出如下数据:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># grpclib</span><br>Summary:<br>  Count:10000<br>  Total:6.37 s<br>  Slowest:96.38 ms<br>  Fastest:31.54 ms<br>  Average:63.33 ms<br>  Requests/sec:1571.05<br><br><span class="hljs-comment"># grpclib &amp;&amp; uvloop</span><br>Summary:<br>  Count:10000<br>  Total:5.44 s<br>  Slowest:90.97 ms<br>  Fastest:38.18 ms<br>  Average:53.13 ms<br>  Requests/sec:1839.73<br></code></pre></td></tr></table></figure><p>通过数据可以发现，<code>betterproto</code>的性能基本是多线程模式性能的3成，而这部分性能的差距主要来自于对<code>HTTP2</code>的解析，如果能把解析<code>HTTP2</code>的实现进行替换为高性能的版本，那么它的性能就能够接近<code>Python gRPC</code>官方实现的<code>grpc.aio</code>了。</p><p>此外，<a href="https://github.com/vmagamedov/grpclib">grpclib</a>的功能比官方<code>Python gRPC</code>比较少，需要开发能力比较强以及对<code>gRPC</code>了解得比较深的开发者对其进行二次开发，才能使它发挥更好的作用。</p><h3 id="3-2-grpc-aio"><a href="#3-2-grpc-aio" class="headerlink" title="3.2.grpc.aio"></a>3.2.grpc.aio</h3><p>官方的<code>Python gRPC</code>现在通过<code>grpc.aio</code>模块对<code>Asyncio</code>提供了支持，它的用法与线程版本一致，只是涉及到IO相关的模块是存在于<code>grpc.aio</code>包中，对于使用者来说，需要把用到的<code>grpc.XXX</code>模块需要变为<code>grpc.aio.XXX</code>模块,同时要确保调用代码一处异步，处处异步，比如客户端的代码如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> asyncio<br><span class="hljs-keyword">import</span> logging<br><br><span class="hljs-keyword">import</span> grpc<br><span class="hljs-keyword">from</span> grpc_asyncio_example.protos <span class="hljs-keyword">import</span> helloworld_pb2, helloworld_pb2_grpc<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">client</span>(<span class="hljs-params">target: <span class="hljs-built_in">str</span> = <span class="hljs-string">&quot;localhost:9999&quot;</span></span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> grpc.aio.insecure_channel(target) <span class="hljs-keyword">as</span> channel:<br>        stub: helloworld_pb2_grpc.GreeterStub = helloworld_pb2_grpc.GreeterStub(channel)<br>        response: helloworld_pb2.HelloRequest = <span class="hljs-keyword">await</span> stub.SayHello(helloworld_pb2.HelloRequest(name=<span class="hljs-string">&#x27;you&#x27;</span>))<br>    logging.info(<span class="hljs-string">&quot;Greeter client received: &quot;</span> + response.message)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    logging.basicConfig()<br>    asyncio.run(client())<br></code></pre></td></tr></table></figure><p>通过代码可以看出初始化<code>Channel</code>的代码不是<code>grpc.insecure_channel</code>而是<code>grpc.aio.insecure_channel</code>，而且在<code>helloworld_pb2_grpc.GreeterStub</code>没有发生变化的情况下，调用<code>stub.SayHello</code>时仍然需要加上<code>await</code>语法，这是因为<code>Python gRPC</code>中<code>Stub</code>的设计模式类似于<a href="https://sans-io.readthedocs.io/">sans-io</a>，是否要添加<code>await</code>语法则是取决于核心IO处理的实现，在这里处理IO的是<code>Channel</code>，所以开发者在调用<code>stub.SayHello</code>时最终会由<code>stub</code>的<code>channel</code>来发送请求，而<code>channel</code>发送请求是一个异步IO实现，所以需要添加<code>await</code>语法。</p><p>而对于服务端的改动也是类似的，对应的代码如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> asyncio<br><span class="hljs-keyword">import</span> logging<br><br><span class="hljs-keyword">import</span> grpc<br><span class="hljs-keyword">from</span> grpc_asyncio_example.protos <span class="hljs-keyword">import</span> helloworld_pb2, helloworld_pb2_grpc<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Greeter</span>(<span class="hljs-params">helloworld_pb2_grpc.GreeterServicer</span>):</span><br><br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">SayHello</span>(<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">        self, request: helloworld_pb2.HelloRequest, context: grpc.aio.ServicerContext</span></span><br><span class="hljs-function"><span class="hljs-params">    </span>) -&gt; helloworld_pb2.HelloReply:</span><br>        <span class="hljs-keyword">await</span> asyncio.sleep(request.sleep_millisecond / <span class="hljs-number">1000</span>)<br>        <span class="hljs-keyword">return</span> helloworld_pb2.HelloReply(message=<span class="hljs-string">&#x27;Hello, %s!&#x27;</span> % request.name)<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">serve</span>(<span class="hljs-params">target: <span class="hljs-built_in">str</span> = <span class="hljs-string">&quot;localhost:9999&quot;</span></span>) -&gt; grpc.aio.Server:</span><br>    server: grpc.aio.Server = grpc.aio.server()<br>    helloworld_pb2_grpc.add_GreeterServicer_to_server(Greeter(), server)<br>    server.add_insecure_port(target)<br>    logging.info(<span class="hljs-string">&quot;Starting server on %s&quot;</span>, target)<br>    <span class="hljs-keyword">await</span> server.start()<br>    <span class="hljs-keyword">return</span> server<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    logging.basicConfig(level=logging.INFO)<br><br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>() -&gt; <span class="hljs-keyword">None</span>:</span><br>        <span class="hljs-keyword">await</span> (<span class="hljs-keyword">await</span> serve()).wait_for_termination()<br><br>    asyncio.run(main())<br></code></pre></td></tr></table></figure><p>可以看到代码中IO相关语法都需要添加<code>await</code>语句，同时<code>SayHello</code>方法添加了<code>async</code>语法，这样就可以在<code>SayHello</code>函数里面编写<code>await</code>语句了。<br>需要注意的是，由于<code>Python gRPC</code>是通过<code>ServicerContext</code>来传输数据的，导致<code>ServicerContext</code>中有些方法是与IO相关的，所以这里用到的<code>ServicerContext</code>是<code>grpc.aio.ServicerContext</code>。</p><p>对于IO相关的用法可能有一些区别，但是对于其他跟IO无关的功能，则保持跟多线程模式的一致，比如客户端在启用时填写的参数如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">with</span> grpc.insecure_channel(target=<span class="hljs-string">&#x27;localhost:50051&#x27;</span>,<br>                           options=[(<span class="hljs-string">&#x27;grpc.lb_policy_name&#x27;</span>, <span class="hljs-string">&#x27;pick_first&#x27;</span>),<br>                                    (<span class="hljs-string">&#x27;grpc.enable_retries&#x27;</span>, <span class="hljs-number">0</span>),<br>                                    (<span class="hljs-string">&#x27;grpc.keepalive_timeout_ms&#x27;</span>, <span class="hljs-number">10000</span>)<br>                                   ]) <span class="hljs-keyword">as</span> channel:<br></code></pre></td></tr></table></figure><p>而在<code>grpc.aio</code>中代码如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> grpc.aio.insecure_channel(target=<span class="hljs-string">&#x27;localhost:50051&#x27;</span>,<br>                           options=[(<span class="hljs-string">&#x27;grpc.lb_policy_name&#x27;</span>, <span class="hljs-string">&#x27;pick_first&#x27;</span>),<br>                                    (<span class="hljs-string">&#x27;grpc.enable_retries&#x27;</span>, <span class="hljs-number">0</span>),<br>                                    (<span class="hljs-string">&#x27;grpc.keepalive_timeout_ms&#x27;</span>, <span class="hljs-number">10000</span>)<br>                                   ]) <span class="hljs-keyword">as</span> channel:<br></code></pre></td></tr></table></figure><p>可以看到填写的参数Key名和值都是一样的，没有发生变化。</p><p>这里只是以一些常见的功能举例，简述不同模式<code>Python gRPC</code>的使用，详细的<code>grpc.aio</code>功能见<a href="https://grpc.github.io/grpc/python/grpc_asyncio.html#">grpc_asyncio文档</a>，如果熟悉多线程模式下<code>Python gRPC</code>和<code>Python Asyncio</code>的用法，那么上手<code>grpc.aio</code>是非常容易的。</p><h4 id="3-2-1-grpc-aio的事件循环"><a href="#3-2-1-grpc-aio的事件循环" class="headerlink" title="3.2.1.grpc.aio的事件循环"></a>3.2.1.grpc.aio的事件循环</h4><p>在<code>Python gRPC</code>的<code>grpc.aio</code>中使用到了<code>asyncio</code>的事件循环，所以可以通过<code>uvloop</code>来提高<code>grpc.aio</code>的性能，使用<code>uvloop</code>非常简单，只要在代码最前面添加如下代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> uvloop<br>uvloop.install()<br></code></pre></td></tr></table></figure><p>就可以使程序获得<code>uvloop</code>带来的性能加成，在对使用<code>asyncio.loop</code>和<code>uvloop.loop</code>的服务端代码进行压测后结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># asyncio.loop</span><br>Summary:<br>  Count:10000<br>  Total:2.15 s<br>  Slowest:30.56 ms<br>  Fastest:11.09 ms<br>  Average:21.19 ms<br>  Requests/sec:4643.73<br><br><span class="hljs-comment"># uvloop.loop</span><br>Summary:<br>  Count:10000<br>  Total:1.45 s<br>  Slowest:25.14 ms<br>  Fastest:9.41 ms<br>  Average:14.08 ms<br>  Requests/sec:6885.81<br></code></pre></td></tr></table></figure><p>可以发现<code>grpc.aio</code>的性能比多线程模式稍好一些，同时在使用了<code>uvloop</code>后性能提升了50%(以<code>Requests/sec</code>对比)。</p><p>不过在与用<code>uvicorn</code>运行的服务中使用<code>gRPC</code>客户端时，需要确保在<code>uvicorn</code>启动后才初始化<code>grpc.aio.Channel</code>，因为在初始化<code>grpc.aio.Channel</code>时会获取到一个事件循环，如果当前没有事件循环时则会自动创建一个事件循环，而<code>uvicorn</code>在启动是会单独创建一个新的事件循环，这会导致<code>grpc.aio.Channel</code>与<code>uvicorn</code>不在同一个事件循环运行导致运行出错。不过这个问题也很好解决，解决代码如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> Any<br><span class="hljs-keyword">import</span> grpc<br><span class="hljs-keyword">from</span> starlette.applications <span class="hljs-keyword">import</span> Starlette<br><span class="hljs-keyword">from</span> grpc_asyncio_example.protos <span class="hljs-keyword">import</span> helloworld_pb2, helloworld_pb2_grpc<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">create_app</span>() -&gt; Starlette:</span><br>    app: Starlette = Starlette()<br><br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_before_server_start</span>(<span class="hljs-params">*_: Any</span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        app.state.channel = grpc.aio.insecure_channel(<span class="hljs-string">&quot;localhost:9999&quot;</span>)<br><br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_after_server_stop</span>(<span class="hljs-params">*_: Any</span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        <span class="hljs-keyword">await</span> app.state.channel.close()<br><br>    app.add_event_handler(<span class="hljs-string">&quot;startup&quot;</span>, _before_server_start)<br>    app.add_event_handler(<span class="hljs-string">&quot;shutdown&quot;</span>, _after_server_stop)<br>    <span class="hljs-keyword">return</span> app<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br><br>    <span class="hljs-keyword">import</span> uvicorn  <span class="hljs-comment"># type: ignore</span><br>    starlette_app: Starlette = create_app()<br>    uvicorn.run(starlette_app)<br></code></pre></td></tr></table></figure><p>在所示的代码中，<code>grpc.aio.channel</code>在<code>startup</code>事件时才进行初始化，在<code>shutdown</code>事件关闭，由于触发<code>startup</code>事件时，<code>uvicorn</code>已经初始化了一个事件循环，所以初始化<code>grpc.aio.Channel</code>时获取到的事件循环与<code>uvicorn</code>一致。</p><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h2><p>如果为了能跟上社区的脚步，以及为了跨语言能够很好的合作，建议还是根据服务所在场景来使用多线程默认的<code>gRPC</code>或者<code>grpc.aio</code>，这是最好的选择;<br>对于类似<code>gunicorn</code> + <code>gevnet</code> + 类似于<code>Flask</code>框架的服务通过<code>gRPC</code>客户端发送请求时可以使用<code>gevent</code>兼容模式；<br>对于开发能力比较强，本身也是追求<code>Pythonic</code>的开发者且是基于<code>Asyncio</code>生态编写服务以及有比较强的定制需求的，则可以考虑使用<code>betterproto</code>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;之前在&lt;a href=&quot;https://so1n.me/categories/Python-gRPC%E5%AE%9E%E8%B7%B5/&quot;</summary>
      
    
    
    <content src="https://ftp.bmp.ovh/imgs/2022/02/bd67e15aa8d46101.png" type="image"/>
    
    
    <category term="Python-gRPC实践" scheme="http://so1n.me/categories/Python-gRPC%E5%AE%9E%E8%B7%B5/"/>
    
    
    <category term="Python" scheme="http://so1n.me/tags/Python/"/>
    
    <category term="gRPC" scheme="http://so1n.me/tags/gRPC/"/>
    
    <category term="Protobuf" scheme="http://so1n.me/tags/Protobuf/"/>
    
  </entry>
  
  <entry>
    <title>如何使用Poetry(1.2+)管理Python虚拟环境</title>
    <link href="http://so1n.me/2022/11/23/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Poetry(1.2+)%E7%AE%A1%E7%90%86Python%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/"/>
    <id>http://so1n.me/2022/11/23/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Poetry(1.2+)%E7%AE%A1%E7%90%86Python%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/</id>
    <published>2022-11-23T12:35:24.000Z</published>
    <updated>2022-11-24T08:19:03.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前记"><a href="#前记" class="headerlink" title="前记"></a>前记</h2><p>一个项目最重要的就是跑起来， 大家基本会同时在本地开发多个项目， 而每个项目用到的环境都是不一样的， 如果这些项目都共用一份依赖那么会导致多个项目的依赖发生冲突以及导致线上服务不稳定，所以就需要用到虚拟环境隔离。在<code>Python</code>中提供了名为<code>venv</code>的虚拟环境管理包用于做多个项目的环境隔离，它提供了很多基础的功能，但是还有很多功能都需要开发者手动操作非常不方便，这时候就可以用到<code>Poetry</code>啦。</p><span id="more"></span><p>本文是<a href="https://so1n.me/2021/08/10/%E4%BF%9D%E9%9A%9CPython%E9%A1%B9%E7%9B%AE%E8%B4%A8%E9%87%8F%E7%9A%84%E5%B7%A5%E5%85%B7/">保障Python项目质量的工具</a>文章中<code>项目环境管理-Poetry</code>的拓展版，由于<code>Poetry</code>在1.2后发生了一些大变化，所以本文的内容不保证能支持<code>Poetry</code>1.2以下的版本。</p><h2 id="1-最初的开始"><a href="#1-最初的开始" class="headerlink" title="1.最初的开始"></a>1.最初的开始</h2><p>在未依赖任何外部工具时，通常都会使用自带的工具来初始化项目的环境，如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  ~ <span class="hljs-built_in">cd</span> demo<br>➜  demo  <br>➜  demo  python3 -m venv .venv<br>➜  demo  <span class="hljs-built_in">source</span> .venv/bin/activate<br>➜  demo  python3 -m pip install --upgrade pip setuptools wheel<br>➜  demo  python3 -m pip install -r requirements.dev.txt<br></code></pre></td></tr></table></figure><p>这几个命令中，由<code>venv</code>完成初始化和使用虚拟环境，再由<code>pip</code>命令来安装包含测试环境的依赖。<br>这些工具都能正常的使用，但是却有几个弊端：</p><ul><li>直接使用<code>python3</code>命令，无法确定准确的<code>Python</code>的版本，导致本地的<code>Python</code>版本与其他人或者服务器的版本不同步。</li><li>每次都要显式的进入和切换虚拟换(<code>Pycharm</code>会默认读取到虚拟环境)。</li><li>通过<code>pip</code>来管理依赖，无法完成依赖管理，也无法自动的对依赖进行分组，如区分测试依赖和正式依赖等。</li></ul><p>此外对于打包，推送包之类的功能还需要开发者去手动编辑文件再通过繁杂的命令去处理，这是非常麻烦的，而<code>Poetry</code>对很多重复且需要开发者手动操作都步骤都统一起来，提供一些命令方便开发者去操作。</p><blockquote><p><code>Poetry</code>的安装非常简单，一条命令就可以搞定了，不同系统的安装教程官方已经说得很详细，具体见<a href="https://python-poetry.org/docs/#installation">官方安装文档</a></p></blockquote><h2 id="2-如何使用Poetry初始化项目环境"><a href="#2-如何使用Poetry初始化项目环境" class="headerlink" title="2.如何使用Poetry初始化项目环境"></a>2.如何使用Poetry初始化项目环境</h2><p>如果这是第一个项目，那么可以使用<code>poetry new &#123;项目名&#125;</code>的命令来创建项目，如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  ~ poetry new demo<br>Created package demo <span class="hljs-keyword">in</span> demo<br></code></pre></td></tr></table></figure><p>这时<code>Poetry</code>会在当前目录创建一个<code>demo</code>目录，<code>demo</code>目录里面的结构如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  ~ <span class="hljs-built_in">cd</span> demo<br>➜  demo tree<br>.<br>├── demo<br>│   └── __init__.py<br>├── pyproject.toml<br>├── README.md<br>└── tests<br>    └── __init__.py<br><br>2 directories, 4 files<br></code></pre></td></tr></table></figure><p>可以看到<code>Poetry</code>会帮忙创建一个最小项目的结构，其中<code>demo</code>是我们本次要开发的目录，<code>README.md</code>是一个项目描述文档，但它是空的，等着我们去填写，<code>tests</code>则是一个测试用例的目录，而<code>pyproject.toml</code>是<code>Python</code>项目相关的一些配置，<code>poetry</code>会预写一些项目的最小信息，如下:</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs toml"><span class="hljs-section">[tool.poetry]</span><br><span class="hljs-attr">name</span> = <span class="hljs-string">&quot;demo&quot;</span><br><span class="hljs-attr">version</span> = <span class="hljs-string">&quot;0.1.0&quot;</span><br><span class="hljs-attr">description</span> = <span class="hljs-string">&quot;&quot;</span><br><span class="hljs-attr">authors</span> = [<span class="hljs-string">&quot;so1n &lt;qaz6803609@163.com&gt;&quot;</span>]<br><span class="hljs-attr">readme</span> = <span class="hljs-string">&quot;README.md&quot;</span><br><br><span class="hljs-section">[tool.poetry.dependencies]</span><br><span class="hljs-attr">python</span> = <span class="hljs-string">&quot;^3.7&quot;</span><br><br><br><span class="hljs-section">[build-system]</span><br><span class="hljs-attr">requires</span> = [<span class="hljs-string">&quot;poetry-core&quot;</span>]<br><span class="hljs-attr">build-backend</span> = <span class="hljs-string">&quot;poetry.core.masonry.api&quot;</span><br></code></pre></td></tr></table></figure><p>其中作者信息是通过<code>git config</code>里面的配置获取的。</p><p>如果是在已有项目下使用<code>Poetry</code>则可以通过<code>poetry init</code>命令，这样<code>Poetry</code>就会通过一个交互式命令行来协助开发者创建项目信息和虚拟环境，不过在创建之前要先确保系统上拥有自己想要的<code>Python</code>版本，<code>Poetry</code>是不会负责<code>Python</code>版本的管理的，需要开发者通过手动处理,<code>pyenv</code>,<code>conda</code>等命令来完成这一步操作，具体的<code>poetry init</code>操作如动图:<br><img   class="lazyload" data-original="https://files.catbox.moe/hvev5v.gif" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" ><br>可以看到如果没有填写值得话，<code>Poetry</code>会默认为你填写一些值，我在某些选项中填入了一些自己的值，最后<code>pyproject.toml</code>会生成如下内容：</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs toml"><span class="hljs-section">[tool.poetry]</span><br><span class="hljs-attr">name</span> = <span class="hljs-string">&quot;demo&quot;</span><br><span class="hljs-attr">version</span> = <span class="hljs-string">&quot;0.0.1&quot;</span><br><span class="hljs-attr">description</span> = <span class="hljs-string">&quot;My demo project&quot;</span><br><span class="hljs-attr">authors</span> = [<span class="hljs-string">&quot;so1n &lt;qaz6803609@163.com&gt;&quot;</span>]<br><span class="hljs-attr">license</span> = <span class="hljs-string">&quot;Apache&quot;</span><br><span class="hljs-attr">readme</span> = <span class="hljs-string">&quot;README.md&quot;</span><br><br><span class="hljs-section">[tool.poetry.dependencies]</span><br><span class="hljs-attr">python</span> = <span class="hljs-string">&quot;^3.9.10&quot;</span><br><br><br><span class="hljs-section">[build-system]</span><br><span class="hljs-attr">requires</span> = [<span class="hljs-string">&quot;poetry-core&quot;</span>]<br><span class="hljs-attr">build-backend</span> = <span class="hljs-string">&quot;poetry.core.masonry.api&quot;</span><br></code></pre></td></tr></table></figure><p>至此，项目初始化完毕，可以开始编写我们的项目了，但是当用<code>PyCharm</code>打开项目的时候会发现有如图的提醒:<br><img   class="lazyload" data-original="https://files.catbox.moe/9ocxnn.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" ></p><p>这个提醒是<code>PyCharm</code>找不到<code>Poetry</code>的可执行文件，需要通过我们指定<code>Poetry</code>的路径才可以执行，这时候可以通过命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">which</span> poetry<br></code></pre></td></tr></table></figure><p>来获取<code>Poetry</code>的可执行路径并填写到弹窗里面，之后<code>PyCharm</code>就会调用<code>Poetry</code>进行虚拟环境初始化，并在当前路径创建<code>.venv</code>文件夹，通过<code>poetry env info</code>获取当前项目的虚拟环境:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  demo poetry env info <br>Virtualenv<br>Python:         3.9.10<br>Implementation: CPython<br>Path:           /home/so1n/demo/.venv<br>Executable:     /home/so1n/demo/.venv/bin/python<br>Valid:          True<br><br>System<br>Platform:   linux<br>OS:         posix<br>Python:     3.9.10<br>Path:       /usr/<span class="hljs-built_in">local</span><br>Executable: /usr/<span class="hljs-built_in">local</span>/bin/python3.9<br></code></pre></td></tr></table></figure><blockquote><ul><li>1.如果想在已有的项目下使用<code>Poetry</code>则需要先删除当前的虚拟环境，并通过命令<code>poetry env use 3.9.10</code></li><li>2.如果创建的虚拟环境版本不是自己想要的，且是通过<code>pyenv</code>管理<code>Python</code>版本，那么可以通过<a href="https://python-poetry.org/blog/announcing-poetry-1.2.0/#detection-of-the-currently-active-python-experimental%E4%BA%86%E8%A7%A3%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3">https://python-poetry.org/blog/announcing-poetry-1.2.0/#detection-of-the-currently-active-python-experimental了解如何解决</a></li><li>3.如果第二点仍然无法解决问题，可以采用如下命令显示的指导<code>Poetry</code>使用到正确的<code>Python</code>版本:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">pyenv <span class="hljs-built_in">local</span> 3.9.10<br>poetry env use $(pyenv <span class="hljs-built_in">which</span> python)<br></code></pre></td></tr></table></figure></li></ul></blockquote><h2 id="3-编写与运行项目"><a href="#3-编写与运行项目" class="headerlink" title="3.编写与运行项目"></a>3.编写与运行项目</h2><p>虚拟环境初始化完成后就可以开始编写项目了，这个<code>demo</code>项目很简单，就是获取一个网站当前的状态，需要用到一个名为<code>httpx</code>的包，这时可以通过命令:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">poetry add httpx<br></code></pre></td></tr></table></figure><p>来安装这个包，当命令执行完毕后，可以发现<code>pyproject.toml</code>文件新增了一行关于<code>httpx</code>包的版本描述：</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs toml"><span class="hljs-section">[tool.poetry.dependencies]</span><br><span class="hljs-attr">python</span> = <span class="hljs-string">&quot;^3.9.10&quot;</span><br><span class="hljs-attr">poetry</span> = <span class="hljs-string">&quot;^1.2.2&quot;</span><br><span class="hljs-attr">httpx</span> = <span class="hljs-string">&quot;^0.23.1&quot;</span>   <span class="hljs-comment"># &lt;------ 新增</span><br></code></pre></td></tr></table></figure><p>这段描述意味着<code>httpx</code>的版本会锁定在<code>0.23.1</code>这个版本中。</p><p>安装好依赖后，在<code>demo/__init__.py</code>编写如下代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> httpx<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_status_code</span>() -&gt; int:</span><br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> httpx.AsyncClient() <span class="hljs-keyword">as</span> client:<br>        resp: httpx.Response = <span class="hljs-keyword">await</span> client.get(<span class="hljs-string">&quot;https://so1n.me&quot;</span>)<br>        <span class="hljs-keyword">return</span> resp.status_code<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    <span class="hljs-keyword">import</span> asyncio<br>    print(asyncio.run(get_status_code()))<br>    <br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    main()<br></code></pre></td></tr></table></figure><p>这段代码非常简单，就是请求<code>https://so1n.me</code>并打印对应的HTTP状态码，接着可以在终端通过命令直接运行，不用再通激活虚拟环境，运行结果如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  demo poetry run python demo/__init__.py<br>200<br></code></pre></td></tr></table></figure><p>不过这段命令比较长，经常这样输入会比较麻烦，这时可以采用<code>Poetry</code>的脚本功能，只需要向<code>pyproject.toml</code>文件追加如下内容:</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs toml"><span class="hljs-section">[tool.poetry.scripts]</span><br><span class="hljs-attr">demo</span> = <span class="hljs-string">&#x27;demo.__init__:main&#x27;</span><br></code></pre></td></tr></table></figure><p>这段内容中的<code>demo = &#39;demo.__init__:main&#39;</code>以等号分成两边，左边的<code>demo</code>是脚本key，这意味着在<code>tool.poetry.scripts</code>中不能出现相同的Key，而等号右边的<code>demo.__init__:main</code>则代表要执行<code>demo</code>目录下的<code>__init__.py</code>的<code>main</code>函数。<br>接下来可以通过<code>poetry run &#123;脚本key&#125;</code>语法来执行我们想要跑的代码，执行效果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  demo poetry run demo<br>200<br></code></pre></td></tr></table></figure><p>除此之外，还可以通过<code>poetry install</code>的方式来让<code>Poetry</code>创建我们的<code>demo</code>脚本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  demo poetry install<br>Installing dependencies from lock file<br><br>No dependencies to install or update<br><br>Installing the current project: demo (0.0.1)<br>➜  demo poetry run <span class="hljs-built_in">which</span> demo<br>/home/so1n/demo/.venv/bin/demo<br>➜  demo cat /home/so1n/demo/.venv/bin/demo<br><span class="hljs-meta">#!/home/so1n/demo/.venv/bin/python</span><br>import sys<br>from demo.__init__ import main<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    sys.exit(main())<br></code></pre></td></tr></table></figure><p>可以看到<code>Poetry</code>在<code>/home/so1n/demo/.venv/bin/demo</code>路径下创建了一个脚本文件，如果这时候如果通过<code>poetry shell</code>进入带有当前虚拟环境的交互<code>shell</code>，则可以通过<code>demo</code>直接执行我们的代码，如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  demo poetry shell<br>Spawning shell within /home/so1n/demo/.venv<br>➜  demo . /home/so1n/demo/.venv/bin/activate<br>(demo-py3.9.10) ➜  demo <span class="hljs-built_in">pwd</span><br>/home/so1n/demo/demo<br>(demo-py3.9.10) ➜  demo demo  <br>200<br></code></pre></td></tr></table></figure><h2 id="4-运行测试用例"><a href="#4-运行测试用例" class="headerlink" title="4.运行测试用例"></a>4.运行测试用例</h2><p>项目编写完成后需要确保我们的代码符合规范以及需要补充对应的测试用例，这是一个良好的习惯，在<code>Python</code>生态中，常用的测试框架是<code>pytest</code>，常用的检查代码规范则是通过<code>pre-commit</code>去执行的。</p><blockquote><p>可以通过<a href="https://so1n.me/2021/08/10/%E4%BF%9D%E9%9A%9CPython%E9%A1%B9%E7%9B%AE%E8%B4%A8%E9%87%8F%E7%9A%84%E5%B7%A5%E5%85%B7/#1-%E9%A1%B9%E7%9B%AE%E7%8E%AF%E5%A2%83%E7%AE%A1%E7%90%86-Poetry">保障Python项目质量的工具</a>了解有什么提升代码质量的工具以及如何使用<code>pre-commit</code>。</p></blockquote><p>在<code>poetry</code>可以通过如下方式安装<code>pytest</code>, <code>pytest-asyncio</code>和<code>pre-commit</code>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">poetry add --group=dev pre-commit pytest pytest-asyncio<br></code></pre></td></tr></table></figure><p>执行完命令后可以发现<code>pyproject.toml</code>新增了如下内容:</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs toml"><span class="hljs-section">[tool.poetry.group.dev.dependencies]</span><br><span class="hljs-attr">pytest</span> = <span class="hljs-string">&quot;^7.2.0&quot;</span><br><span class="hljs-attr">pre-commit</span> = <span class="hljs-string">&quot;^2.20.0&quot;</span><br><span class="hljs-attr">pytest-asyncio</span> = <span class="hljs-string">&quot;^0.20.2&quot;</span><br></code></pre></td></tr></table></figure><p>这块内容表示<code>Poetry</code>托管的虚拟环境安装了<code>pytest</code>和<code>pre-commit</code>的依赖，但是他们是属于<code>dev</code>组的，在正式情况下不会被使用，这对于导出依赖时非常有作用。</p><p>接下来先检查项目的代码格式，首先创建<code>.pre-commit-config.yaml</code>文件，并输入如下内容</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">repos:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">repo:</span> <span class="hljs-string">https://github.com/pre-commit/mirrors-mypy</span><br>    <span class="hljs-attr">rev:</span> <span class="hljs-string">v0.910</span><br>    <span class="hljs-attr">hooks:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">mypy</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">repo:</span> <span class="hljs-string">https://github.com/PyCQA/isort</span><br>    <span class="hljs-attr">rev:</span> <span class="hljs-number">5.9</span><span class="hljs-number">.3</span><br>    <span class="hljs-attr">hooks:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">isort</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">repo:</span> <span class="hljs-string">https://github.com/psf/black</span><br>    <span class="hljs-attr">rev:</span> <span class="hljs-number">21.</span><span class="hljs-string">7b0</span><br>    <span class="hljs-attr">hooks:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">black</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">repo:</span> <span class="hljs-string">https://github.com/PyCQA/flake8</span><br>    <span class="hljs-attr">rev:</span> <span class="hljs-number">3.9</span><span class="hljs-number">.2</span><br>    <span class="hljs-attr">hooks:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">flake8</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">repo:</span> <span class="hljs-string">https://github.com/myint/autoflake</span><br>    <span class="hljs-attr">rev:</span> <span class="hljs-string">v1.4</span><br>    <span class="hljs-attr">hooks:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">autoflake</span><br>        <span class="hljs-attr">args:</span> [<span class="hljs-string">&#x27;--in-place&#x27;</span>, <span class="hljs-string">&#x27;--remove-all-unused-imports&#x27;</span>, <span class="hljs-string">&#x27;--remove-unused-variable&#x27;</span>, <span class="hljs-string">&#x27;--ignore-init-module-imports&#x27;</span>]<br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">repo:</span> <span class="hljs-string">https://github.com/pre-commit/pre-commit-hooks</span><br>    <span class="hljs-attr">rev:</span> <span class="hljs-string">v3.2.0</span><br>    <span class="hljs-attr">hooks:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">check-ast</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">check-byte-order-marker</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">check-case-conflict</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">check-docstring-first</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">check-executables-have-shebangs</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">check-json</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">check-yaml</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">debug-statements</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">detect-private-key</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">end-of-file-fixer</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">trailing-whitespace</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">mixed-line-ending</span><br><br></code></pre></td></tr></table></figure><p>然后执行如下命令:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  demo git init<br>➜  demo git:(master) ✗ poetry run pre-commit run --all-file<br></code></pre></td></tr></table></figure><p>其中第一个命令是为项目进行git初始化，第二个命令是执行代码检查。</p><blockquote><p>如果出现<code>ModuleNotFoundError: No module named &#39;_sqlite3&#39;</code>错误，可以访问<a href="https://stackoverflow.com/questions/1210664/no-module-named-sqlite3">No module named _sqlite3</a>了解如何解决。</p></blockquote><p>执行完代码检查后，在<code>tests</code>目录里面创建一个名为<code>test_demo.py</code>文件，并输入如下内容:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> pytest<br><span class="hljs-keyword">from</span> demo <span class="hljs-keyword">import</span> get_status_code<br><br><br>pytestmark = pytest.mark.asyncio<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestDemo</span>:</span><br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_demo</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">assert</span> <span class="hljs-number">200</span> == <span class="hljs-keyword">await</span> get_status_code()<br></code></pre></td></tr></table></figure><p>接着运行<code>poetry run pytest --capture=no -v</code>执行测试结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  demo git:(master) ✗ poetry run pytest --capture=no -v<br>============================ <span class="hljs-built_in">test</span> session starts =============================<br>platform linux -- Python 3.9.10, pytest-7.2.0, pluggy-1.0.0 -- /home/so1n/demo/.venv/bin/python<br>cachedir: .pytest_cache<br>rootdir: /home/so1n/demo<br>plugins: anyio-3.6.2, asyncio-0.20.2<br>asyncio: mode=strict<br>collected 1 item                                                             <br><br>tests/test_demo.py::TestDemo::test_demo PASSED<br><br>============================= 1 passed <span class="hljs-keyword">in</span> 0.32s ==============================<br></code></pre></td></tr></table></figure><p>发现测试正常，接下来可以生成项目的依赖，使其他没有使用<code>Poetry</code>的环境也可以读取到项目的依赖，对应的命令如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">poetry <span class="hljs-built_in">export</span> -o requirements.txt --without-hashes --with-credentials<br>poetry <span class="hljs-built_in">export</span> -o requirements-dev.txt --without-hashes --with-credentials --with dev<br></code></pre></td></tr></table></figure><p>其中第一条命令是生成正常使用下的依赖，第二条命令是包含测试环境的依赖。</p><h2 id="5-打包与发布"><a href="#5-打包与发布" class="headerlink" title="5.打包与发布"></a>5.打包与发布</h2><p>如果这个项目想发到<code>PyPi</code>供别人使用，那么可以先打包项目再发布到<code>PyPi</code>中，这时候需要先修改<code>pyproject.toml</code>中<code>version</code>的值，比如把它改为<code>0.0.2</code>，再通过<code>poetry builld</code>和<code>poetry publish</code>命令发布。<br>当然，除了发布到<code>PyPi</code>外，还可能把项目的代码发布到<code>Github</code>中，同时为了让开发者快速的找到对应的版本，往往会给当前的<code>commit</code>打上对应的tag，这就代表着我们必须保证<code>version</code>中的值与<code>tag</code>是一致的，此外，项目中<code>demo/__init__.py</code>也需要添加如下内容:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">__version__ = <span class="hljs-string">&quot;0.0.2&quot;</span><br></code></pre></td></tr></table></figure><p>使得别人在引用这个项目时知道项目的版本号是多少，这样一来每次做项目升级的时候需要同时修改三处地方的版本号，非常折腾，为了省心省力，可以采用<code>Poetry</code>的一个插件–<a href="https://github.com/mtkennerly/poetry-dynamic-versioning">poetry-dynamic-versioning</a>来解决这个问题。</p><p>首先是通过命令:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">poetry self add <span class="hljs-string">&quot;poetry-dynamic-versioning[plugin]&quot;</span><br></code></pre></td></tr></table></figure><p>向<code>Poetry</code>安装插件，然后向<code>pyproject.toml</code>添加如下内容:</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs toml"><span class="hljs-section">[tool.poetry-dynamic-versioning]</span><br><span class="hljs-attr">enable</span> = <span class="hljs-literal">true</span>       <span class="hljs-comment"># 代表启用该插件</span><br><span class="hljs-attr">metadata</span>=<span class="hljs-literal">false</span>      <span class="hljs-comment"># 生成的版本号不带上其他数据</span><br><span class="hljs-attr">vcs</span> = <span class="hljs-string">&quot;git&quot;</span>         <span class="hljs-comment"># 指定的版本控制系统为git</span><br><span class="hljs-attr">format</span> = <span class="hljs-string">&quot;v&#123;base&#125;&quot;</span>  <span class="hljs-comment"># 指定版本号的生成规则</span><br></code></pre></td></tr></table></figure><p>接着把<code>pyproject.toml</code>文件中的<code>build-system</code>块替换为如下内容:</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs toml"><span class="hljs-section">[build-system]</span><br><span class="hljs-attr">requires</span> = [<span class="hljs-string">&quot;poetry-core&gt;=1.0.0&quot;</span>, <span class="hljs-string">&quot;poetry-dynamic-versioning&quot;</span>]<br><span class="hljs-attr">build-backend</span> = <span class="hljs-string">&quot;poetry_dynamic_versioning.backend&quot;</span><br></code></pre></td></tr></table></figure><p>最后把<code>pyproject.toml</code>和<code>demo/__init__.py</code>中的版本号改为<code>&quot;0.0.0&quot;</code>（这是<code>poetry-dynamic-versioning</code>的一个动态版本号占位符）</p><p>一切准备就绪后可以执行如下命令进行代码提交以及打上对应的版本tag:</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">➜  demo git:(<span class="hljs-literal">master</span>) ✗ git add *<br>➜  demo git:(<span class="hljs-literal">master</span>) ✗ git commit -m<span class="hljs-string">&quot;Add, First commit&quot;</span><br>➜  demo git:(<span class="hljs-literal">master</span>) ✗ git <span class="hljs-keyword">tag</span> <span class="hljs-title">v0</span>.<span class="hljs-number">0.2</span><br></code></pre></td></tr></table></figure><p>接下来执行<code>poetry build</code>对项目打包:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  demo git:(master) ✗ poetry build<br>Building demo (v0.0.2)<br>  - Building sdist<br>  - Built demo-0.0.2.tar.gz<br>  - Building wheel<br>  - Built demo-0.0.2-py3-none-any.whl<br></code></pre></td></tr></table></figure><p>通过命令可以发现包的版本正好是我们提交的tag<code>v0.0.2</code>中的<code>0.0.2</code>，如果找到包里面的<code>demo/__init__.py</code>的文件，可以发现文件中存在如下一行代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">__version__ = <span class="hljs-string">&quot;v0.0.2&quot;</span><br></code></pre></td></tr></table></figure><p>其中<code>__version__</code>的值与<code>tag</code>一样。</p><p>打包完成后就可以把包传到<code>PyPi</code>了，不过在第一次上传之前需要通过如下命令配置自己的<code>PyPi</code>账户信息:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># my-token可以在`pypi.org`网站中设置</span><br>poetry config pypi-token.pypi my-token<br><span class="hljs-comment"># 或者通过如下命令配置自己的账号密码</span><br>poetry config http-basic.pypi &lt;username&gt; &lt;password&gt;<br></code></pre></td></tr></table></figure><p>最后通过<code>poetry publish</code>命令即可把包传到<code>PyPi</code>中</p><h2 id="6-Poetry的pre-commit"><a href="#6-Poetry的pre-commit" class="headerlink" title="6.Poetry的pre-commit"></a>6.Poetry的pre-commit</h2><p>从上面的流程可以发现<code>Poetry</code>为我们带来方便的虚拟环境管理和依赖管理，但有些时候仍然需要我们调用<code>poetry update</code>来确定依赖有及时更新以及通过<code>poetry export</code>来导出依赖，这时可以通过<code>pre-commit-config</code>来确保提交代码的时候能执行自动执行<code>poetry update</code>和<code>poetry export</code>等语法。</p><p>第一步先向<code>.pre-commit-config.yaml</code>追加如下内容:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs toml">- repo: https://github.com/python-poetry/poetry<br>  rev: &#x27;&#x27;  # add version here<br>  hooks:<br>    - id: poetry-check<br>    - id: poetry-lock<br>    - id: poetry-export<br>      args: [ &quot;-f&quot;, &quot;requirements.txt&quot;, &quot;-o&quot;, &quot;requirements.txt&quot;, &quot;--without-hashes&quot;, &quot;--with-credentials&quot;]<br>    - id: poetry-export<br>      args: [ &quot;-f&quot;, &quot;requirements.txt&quot;, &quot;-o&quot;, &quot;requirements-dev.txt&quot;, &quot;--without-hashes&quot;, &quot;--with-credentials&quot;, &quot;--with&quot;, &quot;dev&quot;]<br></code></pre></td></tr></table></figure><p>并执行如下命令:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">poetry run pre-commit install<br>poetry run pre-commit run --all-file<br></code></pre></td></tr></table></figure><p>验证<code>pre-commit</code>是否正常执行。</p><h2 id="7-总结"><a href="#7-总结" class="headerlink" title="7.总结"></a>7.总结</h2><p>至此就可以享受<code>Poetry</code>为我们带来的便利，只要简单几部操作就可以完成虚拟环境的使用和依赖管理，但是本文还有一些内容没有介绍，可以通过<a href="https://python-poetry.org/docs/">官方文档</a>了解<code>Poetry</code>的更多功能。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">demo</span>(<span class="hljs-params">**kwargs</span>):</span><br>    print(kwargs)<br><br>demo(**&#123;<span class="hljs-string">&quot;a&quot;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&quot;b&quot;</span>: <span class="hljs-number">2</span>&#125;)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前记&quot;&gt;&lt;a href=&quot;#前记&quot; class=&quot;headerlink&quot; title=&quot;前记&quot;&gt;&lt;/a&gt;前记&lt;/h2&gt;&lt;p&gt;一个项目最重要的就是跑起来， 大家基本会同时在本地开发多个项目， 而每个项目用到的环境都是不一样的， 如果这些项目都共用一份依赖那么会导致多个项目的依赖发生冲突以及导致线上服务不稳定，所以就需要用到虚拟环境隔离。在&lt;code&gt;Python&lt;/code&gt;中提供了名为&lt;code&gt;venv&lt;/code&gt;的虚拟环境管理包用于做多个项目的环境隔离，它提供了很多基础的功能，但是还有很多功能都需要开发者手动操作非常不方便，这时候就可以用到&lt;code&gt;Poetry&lt;/code&gt;啦。&lt;/p&gt;</summary>
    
    
    <content src="https://files.catbox.moe/66hvqo.png" type="image"/>
    
    
    <category term="Python" scheme="http://so1n.me/categories/Python/"/>
    
    
    <category term="Python" scheme="http://so1n.me/tags/Python/"/>
    
    <category term="Poetry" scheme="http://so1n.me/tags/Poetry/"/>
    
  </entry>
  
  <entry>
    <title>Python-gRPC实践(8)--Protobuf插件</title>
    <link href="http://so1n.me/2022/11/22/Python-gRPC%E5%AE%9E%E8%B7%B5(8)--Protobuf%E6%8F%92%E4%BB%B6%20copy/"/>
    <id>http://so1n.me/2022/11/22/Python-gRPC%E5%AE%9E%E8%B7%B5(8)--Protobuf%E6%8F%92%E4%BB%B6%20copy/</id>
    <published>2022-11-22T12:35:24.000Z</published>
    <updated>2022-11-25T12:32:51.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近在完善一个<code>Protobuf</code>中的<code>Message</code>转为<code>pydantic.BaseModel</code>对象的库–<a href="https://github.com/so1n/protobuf_to_pydantic">protobuf_to_pydantic</a>，想为它增加一个从原生<code>Protobuf</code>文件直接生成对应<code>pydantic.BaseModel</code>对象源代码的功能，在通过了解后发现可以通过<code>Protobuf</code>插件的形式来实现</p><p>但是搜索了大量的资源后才发现大多数的<code>Protobuf</code>插件都是由<code>Go</code>编写的，并且没有(或者很少)关于<code>Python</code>插件的编写教程以及在<a href="https://googleapis.dev/python/protobuf/latest/">Python Protobuf官方文档</a>中找不到任何关于<code>Plugin</code>的介绍，所以踩了很多坑，而本文也就成了我编写<code>Protobuf</code>插件的踩坑总结</p><span id="more"></span><p>如果不知道如何编写<code>Protobuf</code>文件以及如何生成对应的<code>Python</code>代码，可以先阅读<a href="https://so1n.me/2022/04/07/Python-gRPC%E5%AE%9E%E8%B7%B5(3)--%E4%BD%BF%E7%94%A8Python%E5%AE%9E%E7%8E%B0gRPC%E6%9C%8D%E5%8A%A1/">Python-gRPC实践(3)–使用Python实现gRPC服务</a></p><h2 id="1-什么是Protobuf插件"><a href="#1-什么是Protobuf插件" class="headerlink" title="1.什么是Protobuf插件"></a>1.什么是Protobuf插件</h2><p>在官方的介绍中，<code>Protobuf</code>插件是一个标准的程序，它会从标准输入读取协议缓冲区并写入到<code>CodeGeneratorRequest</code>对象中，然后将<code>CodeGeneratorResponse</code>序列化后通过协议缓冲区写进标准输出，其中这些消息类型是在<a href="https://developers.google.com/protocol-buffers/docs/reference/cpp/google.protobuf.compiler.plugin.pb">plugin.proto</a>中定义的。</p><p>同时，在使用的过程中可以通过<code>CodeGeneratorRequest</code>获取到<code>Protobuf</code>文件所描述的对象(在<code>Protobuf</code>中称为<code>FileDescriptorProto</code>)，通过这个<code>FileDescriptorProto</code>对象可以得到文件中的所有信息，比如<a href="https://github.com/nipunn1313/mypy-protobuf">mypy-protobuf</a>就是通过<code>CodeGeneratorRequest</code>对象来生成对应的<code>pyi</code>文件内容，最后再通过<code>CodeGeneratorResponse</code>对象把内容写入到对应的文件中。</p><p>如果熟悉<code>Linux</code>的管道，就能知道<code>Protobuf</code>插件的原理与<code>Linux</code>的管道类似，比如下面的例子，首先现在有一个文本文件名为<code>demo.txt</code>,它的内容如下:</p><figure class="highlight mercury"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mercury">This <span class="hljs-keyword">is</span> line <span class="hljs-number">1</span>.<br>This <span class="hljs-keyword">is</span> line <span class="hljs-number">2</span>.<br></code></pre></td></tr></table></figure><p>而在调用命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cat demo.txt| sed -e 2a\n<span class="hljs-string">&#x27;wahaha&#x27;</span> &gt; new_demo.txt<br></code></pre></td></tr></table></figure><p>后就可以发现新增了一个名为<code>new_demo.txt</code>的文件，且内容如下：</p><figure class="highlight mercury"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mercury">This <span class="hljs-keyword">is</span> line <span class="hljs-number">1</span>.<br>This <span class="hljs-keyword">is</span> line <span class="hljs-number">2</span>.<br>wahaha<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>demo.txt</code>可以比喻为原来的<code>Protobuf</code>文件，<code>cat</code>命令是加载<code>Protobuf</code>文件的<code>protoc</code>命令，而<code>|</code>就是一个管道，通过<code>|</code>把数据流传到下一个命令中，而<code>sed</code>命令可以认为是一个插件，其中<code>2a\n&#39;wahaha&#39;</code>就是插件要修改的内容，这里的意思就是在第二行后追加一段指定的文本，最后<code>&gt;</code>就是像<code>CodeGeneratorResponse</code>对象一样把管道的数据写入指定的文件中。</p><blockquote><p><code>Linux</code>管道只允许一个输出流(在不算错误的管道的情况下)，而<code>Protoc</code>命令生成的代码输出不会被插件影响，插件间的输出也不会互相影响。</p></blockquote><p>简单的了解了<code>Protobuf</code>插件后，接下来以<a href="https://github.com/so1n/grpc-example-common/tree/master">grpc-example-common</a>项目为例，介绍如何制作<code>Protobuf</code>插件。</p><h2 id="2-制作一个Protobuf插件"><a href="#2-制作一个Protobuf插件" class="headerlink" title="2.制作一个Protobuf插件"></a>2.制作一个Protobuf插件</h2><p>首先是确保已经安装了<code>gRPC</code>和<code>Protobuf</code>的依赖，接着在根目录创建一个名为<code>example_plugin.py</code>的文件，该文件的代码和注释如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> logging<br><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> Set, Iterator, Tuple<br><span class="hljs-keyword">from</span> contextlib <span class="hljs-keyword">import</span> contextmanager<br><br><span class="hljs-keyword">from</span> google.protobuf.compiler.plugin_pb2 <span class="hljs-keyword">import</span> CodeGeneratorRequest, CodeGeneratorResponse<br><br><span class="hljs-comment"># 初始化logger</span><br>logger = logging.getLogger(__name__)<br>logging.basicConfig(<br>    <span class="hljs-built_in">format</span>=<span class="hljs-string">&quot;[%(asctime)s %(levelname)s] %(message)s&quot;</span>, datefmt=<span class="hljs-string">&quot;%y-%m-%d %H:%M:%S&quot;</span>, level=logging.INFO<br>)<br><br><span class="hljs-meta">@contextmanager</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">code_generation</span>() -&gt; Iterator[Tuple[CodeGeneratorRequest, CodeGeneratorResponse]]:</span><br>    <span class="hljs-string">&quot;&quot;&quot;模仿mypy-protobuf的代码&quot;&quot;&quot;</span><br>    <span class="hljs-comment"># 从程序的标准输入读取对应的数据到 CodeGeneratorRequest对象中</span><br>    request: CodeGeneratorResponse = CodeGeneratorRequest.FromString(sys.stdin.buffer.read())<br>    <span class="hljs-comment"># 初始化 CodeGeneratorResponse 对象 </span><br>    response: CodeGeneratorResponse = CodeGeneratorResponse()<br><br>    <span class="hljs-comment"># 声明插件是支持版本为3的protobuf文件也可以使用`OPTIONAL`语法。</span><br>    <span class="hljs-comment"># protoc程序默认是支持的，而插件则是默认不支持的，所以需要开启，避免执行出错。</span><br>    response.supported_features |= CodeGeneratorResponse.FEATURE_PROTO3_OPTIONAL<br><br>    <span class="hljs-keyword">yield</span> request, response<br><br>    <span class="hljs-comment"># 序列化response对象，并写入到标准输出中 </span><br>    sys.stdout.buffer.write(response.SerializeToString())<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>() -&gt; <span class="hljs-keyword">None</span>:</span><br>    <span class="hljs-keyword">with</span> code_generation() <span class="hljs-keyword">as</span> (request, response):<br>        <span class="hljs-comment"># 获取protoc命令中指定的proto路径，也就是开发者编写proto文件的集合</span><br>        file_name_set: Set[<span class="hljs-built_in">str</span>] = &#123;i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> request.file_to_generate&#125;<br>        <span class="hljs-keyword">for</span> proto_file <span class="hljs-keyword">in</span> request.proto_file:<br>            <span class="hljs-keyword">if</span> proto_file.name <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> file_name_set:<br>                <span class="hljs-comment"># 排除非开发者编写的proto文件，不做多余的解析 </span><br>                <span class="hljs-keyword">continue</span><br>            <span class="hljs-comment"># 打印protobuf文件名</span><br>            logger.info(proto_file.name)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    main()<br></code></pre></td></tr></table></figure><p>通过代码可以发现，这个插件只是一个雏形，它非常简单，只是通过<code>logger</code>打印出插件加载到的<code>Protobuf</code>文件名。</p><p>在编写完插件后就可以尝试运行插件了，<code>Protobuf</code>插件是通过<code>protoc</code>命令运行的，在还没使用插件之前，先看看执行生成<code>Python</code>文件的命令长啥样：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">python -m grpc_tools.protoc \<br>  --python_out=./ \<br>  --grpc_python_out=./ \<br>  -I protos $(find ./protos -name <span class="hljs-string">&#x27;*.proto&#x27;</span>)<br></code></pre></td></tr></table></figure><p><code>protoc</code>命令会加载<code>-I</code>指定的<code>Protobuf</code>文件路径，也就是当前路径下<code>protos</code>目录里面的所有后缀为<code>.proto</code>的文件，而<code>python_out</code>和<code>grpc_python_out</code>是指定生成<code>Python</code>代码的路径，由于定义它们的路径都为<code>.</code>，那么命令会在类似的路径下生成对应的<code>Python</code>代码，比如<code>Protobuf</code>文件所在的目录结构如下：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs armasm">.  # 也就是项目的根目录grpc-example-<span class="hljs-meta">common</span><br>└── protos<br>    └── grpc_example_common<br>        └── protos<br>            ├── book<br>            ├── <span class="hljs-meta">common</span><br>            └── user<br></code></pre></td></tr></table></figure><p>其中<code>Protobuf</code>文件分别位于<code>book</code>, <code>common</code>, <code>user</code>这三个目录中，那么该命令会在项目的根目录下生成对应的<code>Python</code>代码文件，生成文件后的项目目录如下：</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs clean">.  # 也就是项目的根目录grpc-example-common<br>├── grpc_example_common # 这里本来是grpc-example-common，但生成的时候会自动专为grpc_example_common <br>│   └── protos<br>│       └── grpc_example_common<br>│           └── protos<br>│               ├── book   # &lt;--- book的Protobuf文件生成的`Python`代码文件下这里<br>│               ├── common # &lt;--- common的Protobuf文件生成的`Python`代码文件下这里<br>│               └── user   # &lt;--- user的Protobuf文件生成的`Python`代码文件下这里<br>└── protos<br>    └── grpc_example_common<br>        └── protos<br>            ├── book<br>            ├── common<br>            └── user<br></code></pre></td></tr></table></figure><p>现在为了向<code>protoc</code>命令引入我们刚才编写的插件，需要对命令进行修改，如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">python -m grpc_tools.protoc \<br>  --plugin=protoc-gen-custom-plugin=./example_plugin.py --custom-plugin_out=. \<br>  --mypy_grpc_out=./ \<br>  --mypy_out=./ \<br>  --python_out=./ \<br>  --grpc_python_out=./ \<br>  -I protos $(find ./protos -name <span class="hljs-string">&#x27;*.proto&#x27;</span>)<br></code></pre></td></tr></table></figure><p>这条命令多了一行内容为<code>--plugin=protoc-gen-custom-plugin=./example_plugin.py --custom-plugin_out=.</code>的文本，其中<code>--plugin</code>指定的值永远要以<code>protoc-gen-</code>开头，后面跟着的<code>custom-plugin</code>则是本次插件的名，<code>=./example_plugin.py</code>则是定义<code>custome-plugin</code>插件的路径。至于后面的<code>--custom-plugin_out=.</code>则是用来定义插件<code>custom-plugin</code>的输出路径为<code>.</code>，也就是插件处理每一个<code>Protobuf</code>文件后输出的文件与<code>protoc</code>命令是同一个目录的。</p><blockquote><p>为了保证插件正确加载，需要确保<code>--plugin=protoc-gen-custom-plugin</code>中的<code>custom-plugin</code>与<code>--custom-plugin_out</code>中的<code>custom-plugin</code>一致。<br>同时需要注意<code>--plugin=protoc-gen-custom-plugin=./example_plugin.py --custom-plugin_out=. \</code>中最后的文本是<code>. \</code>而不是<code>.\</code>，如果是<code>.\</code>则会导致<code>protoc</code>命令执行出错。</p></blockquote><p>再执行完这个命令后可以在终端看到如下输出:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">[22-11-22 20:39:25 INFO] grpc_example_common/protos/book/manager.proto<br>[22-11-22 20:39:25 INFO] grpc_example_common/protos/book/social.proto<br>[22-11-22 20:39:25 INFO] grpc_example_common/protos/common/p2p_validate.proto<br>[22-11-22 20:39:25 INFO] grpc_example_common/protos/common/exce.proto<br></code></pre></td></tr></table></figure><p>不过除了生成<code>Python</code>代码外并没有其他文件生成，这是因为现在编写的插件还没有向<code>CodeGeneratorResponse</code>写入任何内容。</p><p>为了让插件能够输出内容，现在先编写一个接收文件对象<code>FileDescriptorProto</code>并生成对应Json文件的处理函数<code>process_file</code>，代码如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">process_file</span>(<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">    proto_file: FileDescriptorProto, response: CodeGeneratorResponse</span></span><br><span class="hljs-function"><span class="hljs-params"></span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>    options = <span class="hljs-built_in">str</span>(proto_file.options).strip().replace(<span class="hljs-string">&quot;\n&quot;</span>, <span class="hljs-string">&quot;, &quot;</span>).replace(<span class="hljs-string">&#x27;&quot;&#x27;</span>, <span class="hljs-string">&quot;&quot;</span>)<br>    file = response.file.add()  <span class="hljs-comment"># 向响应对象添加并返回一个输出的文件对象</span><br>    file.name = proto_file.name + <span class="hljs-string">&quot;.json&quot;</span>  <span class="hljs-comment"># 指定输出文件的名字</span><br>    <span class="hljs-comment"># 指定输出文件的内容</span><br>    file.content = json.dumps(<br>        &#123;<br>            <span class="hljs-string">&quot;package&quot;</span>: <span class="hljs-string">f&quot;<span class="hljs-subst">&#123;proto_file.package&#125;</span>&quot;</span>,  <span class="hljs-comment"># protobuf 包名</span><br>            <span class="hljs-string">&quot;filename&quot;</span>: <span class="hljs-string">f&quot;<span class="hljs-subst">&#123;proto_file.name&#125;</span>&quot;</span>,    <span class="hljs-comment"># protobuf 文件名</span><br>            <span class="hljs-string">&quot;dependencies&quot;</span>: <span class="hljs-built_in">list</span>(proto_file.dependency),  <span class="hljs-comment"># protobuf依赖</span><br>            <span class="hljs-string">&quot;message_type&quot;</span>: [MessageToDict(i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> proto_file.message_type],  <span class="hljs-comment"># protobuf 定义的message</span><br>            <span class="hljs-string">&quot;service&quot;</span>: [MessageToDict(i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> proto_file.service],  <span class="hljs-comment"># protobuf定义的service</span><br>            <span class="hljs-string">&quot;public_dependency&quot;</span>: <span class="hljs-built_in">list</span>(proto_file.public_dependency),    <span class="hljs-comment"># protobuf定义的依赖</span><br>            <span class="hljs-string">&quot;enum_type&quot;</span>: [MessageToDict(i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> proto_file.enum_type],  <span class="hljs-comment"># protobuf定义的枚举值</span><br>            <span class="hljs-string">&quot;extension&quot;</span>: [MessageToDict(i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> proto_file.extension],  <span class="hljs-comment"># protobuf定义的拓展</span><br>            <span class="hljs-string">&quot;options&quot;</span>: <span class="hljs-built_in">dict</span>(item.split(<span class="hljs-string">&quot;: &quot;</span>) <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> options.split(<span class="hljs-string">&quot;, &quot;</span>) <span class="hljs-keyword">if</span> options),  <span class="hljs-comment"># protobuf定义的options</span><br>        &#125;,<br>        indent=<span class="hljs-number">2</span><br>    ) + <span class="hljs-string">&quot;\r\n&quot;</span><br><br></code></pre></td></tr></table></figure><p>接着更改插件中<code>main</code>函数:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>() -&gt; <span class="hljs-keyword">None</span>:</span><br>    <span class="hljs-keyword">with</span> code_generation() <span class="hljs-keyword">as</span> (request, response):<br>        <span class="hljs-comment"># 获取protoc命令中指定的proto路径</span><br>        file_name_set: Set[<span class="hljs-built_in">str</span>] = &#123;i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> request.file_to_generate&#125;<br>        <span class="hljs-keyword">for</span> proto_file <span class="hljs-keyword">in</span> request.proto_file:<br>            <span class="hljs-keyword">if</span> proto_file.name <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> file_name_set:<br>                <span class="hljs-comment"># 排除非开发者编写的proto文件，不做多余的解析 </span><br>                <span class="hljs-keyword">continue</span><br>            process_file(proto_file, response)  <span class="hljs-comment"># &lt;----修改这里</span><br></code></pre></td></tr></table></figure><p>然后再运行<code>protoc</code>命令即可看到对应的输出结果了，比如对于<code>user.proto</code>,生成的json内容如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;package&quot;</span>: <span class="hljs-string">&quot;user&quot;</span>,<br>  <span class="hljs-attr">&quot;filename&quot;</span>: <span class="hljs-string">&quot;grpc_example_common/protos/user/user.proto&quot;</span>,<br>  <span class="hljs-attr">&quot;dependencies&quot;</span>: [<span class="hljs-string">&quot;google/protobuf/empty.proto&quot;</span>],<br>  <span class="hljs-attr">&quot;message_type&quot;</span>: [<br>    &#123;<br>      <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;CreateUserRequest&quot;</span>,<br>      <span class="hljs-attr">&quot;field&quot;</span>: [<br>        &#123; <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;uid&quot;</span>, <span class="hljs-attr">&quot;number&quot;</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">&quot;label&quot;</span>: <span class="hljs-string">&quot;LABEL_OPTIONAL&quot;</span>, <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;TYPE_STRING&quot;</span>, <span class="hljs-attr">&quot;jsonName&quot;</span>: <span class="hljs-string">&quot;uid&quot;</span> &#125;,<br>        &#123; <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;user_name&quot;</span>, <span class="hljs-attr">&quot;number&quot;</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">&quot;label&quot;</span>: <span class="hljs-string">&quot;LABEL_OPTIONAL&quot;</span>, <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;TYPE_STRING&quot;</span>, <span class="hljs-attr">&quot;jsonName&quot;</span>: <span class="hljs-string">&quot;userName&quot;</span> &#125;,<br>        &#123; <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;password&quot;</span>, <span class="hljs-attr">&quot;number&quot;</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">&quot;label&quot;</span>: <span class="hljs-string">&quot;LABEL_OPTIONAL&quot;</span>, <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;TYPE_STRING&quot;</span>, <span class="hljs-attr">&quot;jsonName&quot;</span>: <span class="hljs-string">&quot;password&quot;</span> &#125;<br>      ]<br>    &#125;,<br>  ],<br>  <span class="hljs-attr">&quot;service&quot;</span>: [<br>    &#123;<br>      <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;User&quot;</span>,<br>      <span class="hljs-attr">&quot;method&quot;</span>: [<br>        &#123; <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;get_uid_by_token&quot;</span>, <span class="hljs-attr">&quot;inputType&quot;</span>: <span class="hljs-string">&quot;.user.GetUidByTokenRequest&quot;</span>, <span class="hljs-attr">&quot;outputType&quot;</span>: <span class="hljs-string">&quot;.user.GetUidByTokenResult&quot;</span> &#125;,<br>        &#123; <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;logout_user&quot;</span>, <span class="hljs-attr">&quot;inputType&quot;</span>: <span class="hljs-string">&quot;.user.LogoutUserRequest&quot;</span>, <span class="hljs-attr">&quot;outputType&quot;</span>: <span class="hljs-string">&quot;.google.protobuf.Empty&quot;</span> &#125;,<br>        &#123; <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;login_user&quot;</span>, <span class="hljs-attr">&quot;inputType&quot;</span>: <span class="hljs-string">&quot;.user.LoginUserRequest&quot;</span>, <span class="hljs-attr">&quot;outputType&quot;</span>: <span class="hljs-string">&quot;.user.LoginUserResult&quot;</span> &#125;,<br>        &#123; <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;create_user&quot;</span>, <span class="hljs-attr">&quot;inputType&quot;</span>: <span class="hljs-string">&quot;.user.CreateUserRequest&quot;</span>, <span class="hljs-attr">&quot;outputType&quot;</span>: <span class="hljs-string">&quot;.google.protobuf.Empty&quot;</span> &#125;,<br>        &#123; <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;delete_user&quot;</span>, <span class="hljs-attr">&quot;inputType&quot;</span>: <span class="hljs-string">&quot;.user.DeleteUserRequest&quot;</span>, <span class="hljs-attr">&quot;outputType&quot;</span>: <span class="hljs-string">&quot;.google.protobuf.Empty&quot;</span> &#125;<br>      ]<br>    &#125;<br>  ],<br>  <span class="hljs-attr">&quot;public_dependency&quot;</span>: [],<br>  <span class="hljs-attr">&quot;enum_type&quot;</span>: [],<br>  <span class="hljs-attr">&quot;extension&quot;</span>: [],<br>  <span class="hljs-attr">&quot;options&quot;</span>: &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过输出的内容可以看出通过插件的方式可以获得到<code>Protobuf</code>文件中的很多输出，而且除了这些数据外，还能提供对应<code>Message</code>的<code>Option</code>数据以及通过<code>proto_file.source_code_info</code>获得到完整的源码信息。</p><blockquote><p>json文件中的<code>message_type</code>内容比较多，所以省略的一些输出，详细的输出可以通过<a href="https://github.com/so1n/grpc-example-common/tree/grpc-plugin/grpc_example_common/protos">grpc_example_common/protos</a>查看每个<code>Protobuf</code>文件的输出。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;最近在完善一个&lt;code&gt;Protobuf&lt;/code&gt;中的&lt;code&gt;Message&lt;/code&gt;转为&lt;code&gt;pydantic.BaseModel&lt;/code&gt;对象的库–&lt;a href=&quot;https://github.com/so1n/protobuf_to_pydantic&quot;&gt;protobuf_to_pydantic&lt;/a&gt;，想为它增加一个从原生&lt;code&gt;Protobuf&lt;/code&gt;文件直接生成对应&lt;code&gt;pydantic.BaseModel&lt;/code&gt;对象源代码的功能，在通过了解后发现可以通过&lt;code&gt;Protobuf&lt;/code&gt;插件的形式来实现&lt;/p&gt;
&lt;p&gt;但是搜索了大量的资源后才发现大多数的&lt;code&gt;Protobuf&lt;/code&gt;插件都是由&lt;code&gt;Go&lt;/code&gt;编写的，并且没有(或者很少)关于&lt;code&gt;Python&lt;/code&gt;插件的编写教程以及在&lt;a href=&quot;https://googleapis.dev/python/protobuf/latest/&quot;&gt;Python Protobuf官方文档&lt;/a&gt;中找不到任何关于&lt;code&gt;Plugin&lt;/code&gt;的介绍，所以踩了很多坑，而本文也就成了我编写&lt;code&gt;Protobuf&lt;/code&gt;插件的踩坑总结&lt;/p&gt;</summary>
    
    
    <content src="https://ftp.bmp.ovh/imgs/2022/02/bd67e15aa8d46101.png" type="image"/>
    
    
    <category term="Python-gRPC实践" scheme="http://so1n.me/categories/Python-gRPC%E5%AE%9E%E8%B7%B5/"/>
    
    
    <category term="Python" scheme="http://so1n.me/tags/Python/"/>
    
    <category term="gRPC" scheme="http://so1n.me/tags/gRPC/"/>
    
    <category term="Protobuf" scheme="http://so1n.me/tags/Protobuf/"/>
    
  </entry>
  
  <entry>
    <title>使用Pait快速构建gRPC Json网关</title>
    <link href="http://so1n.me/2022/10/29/%E4%BD%BF%E7%94%A8Pait%E6%9E%84%E5%BB%BAgRPC%20Json%E7%BD%91%E5%85%B3/"/>
    <id>http://so1n.me/2022/10/29/%E4%BD%BF%E7%94%A8Pait%E6%9E%84%E5%BB%BAgRPC%20Json%E7%BD%91%E5%85%B3/</id>
    <published>2022-10-29T12:31:18.000Z</published>
    <updated>2022-11-22T06:14:46.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前记"><a href="#前记" class="headerlink" title="前记"></a>前记</h2><p><code>gRPC</code>已经是一个大多数开发者使用微服务时选择的通信协议，大多数公司的内部服务都会通过<code>gRPC</code>来通信，但是服务端和客户端使用的通信协议还是<code>HTTP</code>，这就意味着需要在客户端和内部服务之间架起一个可以转换<code>HTTP</code>与<code>gRPC</code>协议的网关。<br><a href="https://github.com/so1n/pait">pait</a>的<code>gRPC Gateway</code>模块就是实现了这样的一个功能，<code>gRPC Gateway</code>模块通过<code>pait</code>能快速的把<code>Python</code>Web框架和<code>gRPC</code>连接起来，并自动处理和转发请求。</p><blockquote><p>目前只支持<code>Flask</code>, <code>Starlite</code>, <code>Sanic</code>, <code>Tornado</code></p></blockquote><h2 id="1-一个简单的例子"><a href="#1-一个简单的例子" class="headerlink" title="1.一个简单的例子"></a>1.一个简单的例子</h2><p>在介绍如何使用<code>Pait</code>快速构建<code>gRPC Json</code>网关之前先以一个简单的示例项目为例子来介绍没用网关前的局限性。</p><blockquote><p>例子项目代码见附录一链接</p></blockquote><p>在这个例子中存在一个客户端和三个后端服务，其中<code>gRPC</code>服务有两个，一个是负责用户的创建、注销、登录、登出，token校验五个功能的<code>User</code>服务;另外一个是负责书本的信息获取和书本评论和点赞等功能的<code>book</code>服务。而剩下的后端服务是使用<code>Flask</code>框架构建的API服务，它负责暴露出HTTP接口供客户端调用，当被客户端调用时会把请求进行处理并通过<code>gRPC</code>客户端转发给另外两个<code>gRPC</code>服务，他们的关系图如下：<br><img   class="lazyload" data-original="https://files.catbox.moe/s5e3hf.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" ><br>通过关系图可以发现客户端只与<code>Flask</code>应用通过HTTP通信，<code>Flask</code>应用通过<code>gRPC</code>客户端与其它机器的<code>gRPC</code>服务通过<code>gRPC</code>进行通信，客户端无法直接访问到<code>gRPC</code>服务所在的机器<code>node2</code>和<code>node3</code>。</p><p>这个设计简单又实用，挺不错的，但是在编写代码时却有点烦恼，以用户服务为例子，编写<code>gRPC</code>服务的第一步是编写好<code>Protobuf文件</code>，其中用户服务的<code>Protobuf</code>文件描述的<code>Service</code>如下：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Protobuf"><span class="hljs-comment">// 省略其它protobuf 代码</span><br><span class="hljs-class"><span class="hljs-keyword">service</span> <span class="hljs-title">User</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">rpc</span> get_uid_by_token (GetUidByTokenRequest) <span class="hljs-keyword">returns</span> (GetUidByTokenResult)</span>;<br>  <span class="hljs-function"><span class="hljs-keyword">rpc</span> logout_user (LogoutUserRequest) <span class="hljs-keyword">returns</span> (google.protobuf.Empty)</span>;<br>  <span class="hljs-function"><span class="hljs-keyword">rpc</span> login_user(LoginUserRequest) <span class="hljs-keyword">returns</span> (LoginUserResult)</span>;<br>  <span class="hljs-function"><span class="hljs-keyword">rpc</span> create_user(CreateUserRequest) <span class="hljs-keyword">returns</span> (google.protobuf.Empty)</span>;<br>  <span class="hljs-function"><span class="hljs-keyword">rpc</span> delete_user(DeleteUserRequest) <span class="hljs-keyword">returns</span> (google.protobuf.Empty)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>第二步是根据<code>Protobuf</code>文件生成的接口代码来编写对应的代码逻辑，然后把代码部署在<code>node2</code>机器上运行。</p><p>接下来就是麻烦的第三步了，首先是根据<code>Protobuf</code>文件生成客户端代码，然后编写调用<code>gRPC</code>客户端的路由函数，代码如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Response, request<br><span class="hljs-comment"># 生成的Python文件都存放在gRPC公有包里面</span><br><span class="hljs-keyword">from</span> grpc_example_common.protos.user <span class="hljs-keyword">import</span> user_pb2 <span class="hljs-keyword">as</span> user_message<br><br><span class="hljs-keyword">from</span> app_service.utils <span class="hljs-keyword">import</span> g, get_uid_by_token, make_response<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">create_user</span>() -&gt; Response:</span><br>    request_dict: <span class="hljs-built_in">dict</span> = request.json<br>    g.user_grpc_service.create_user(<br>        uid=request_dict[<span class="hljs-string">&quot;uid&quot;</span>], user_name=request_dict[<span class="hljs-string">&quot;user_name&quot;</span>], password=request_dict[<span class="hljs-string">&quot;password&quot;</span>]<br>    )<br>    <span class="hljs-keyword">return</span> make_response()<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">delete_user</span>() -&gt; Response:</span><br>    request_dict: <span class="hljs-built_in">dict</span> = request.json<br>    g.user_grpc_service.delete_user(uid=request_dict[<span class="hljs-string">&quot;uid&quot;</span>])<br>    <span class="hljs-keyword">return</span> make_response()<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">login_route</span>() -&gt; Response:</span><br>    request_dict: <span class="hljs-built_in">dict</span> = request.json<br>    login_result: user_message.LoginUserResult = g.user_grpc_service.login_user(<br>        uid=request_dict[<span class="hljs-string">&quot;uid&quot;</span>], password=request_dict[<span class="hljs-string">&quot;password&quot;</span>]<br>    )<br>    <span class="hljs-keyword">return</span> make_response(&#123;<span class="hljs-string">&quot;token&quot;</span>: login_result.token, <span class="hljs-string">&quot;uid&quot;</span>: login_result.uid&#125;)<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">logout_route</span>() -&gt; Response:</span><br>    request_dict: <span class="hljs-built_in">dict</span> = request.json<br>    <span class="hljs-keyword">if</span> get_uid_by_token() == request_dict[<span class="hljs-string">&quot;uid&quot;</span>]:<br>        token: <span class="hljs-built_in">str</span> = request.headers.get(<span class="hljs-string">&quot;token&quot;</span>, <span class="hljs-string">&quot;&quot;</span>)<br>        g.user_grpc_service.logout_user(uid=request_dict[<span class="hljs-string">&quot;uid&quot;</span>], token=token)<br>        <span class="hljs-keyword">return</span> make_response()<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">raise</span> RuntimeError(<span class="hljs-string">&quot;Uid ERROR&quot;</span>)<br></code></pre></td></tr></table></figure><p>可以看到示例代码中的几个路由函数都是重复的获取请求参数，再把参数逐一的传给<code>gRPC</code>客户端，通过<code>gRPC</code>客户端调用得到结果后对结果反序列化再返回给客户端。</p><p>当路由函数编写完成后就需要把路由函数注册到<code>Flask</code>应用中，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">from</span> flask.blueprints <span class="hljs-keyword">import</span> Blueprint<br><br><span class="hljs-keyword">from</span> app_service <span class="hljs-keyword">import</span> user_route<br><br>user_bp: Blueprint = Blueprint(<span class="hljs-string">&quot;user_bp&quot;</span>, __name__, url_prefix=<span class="hljs-string">&quot;/api/user&quot;</span>)<br>user_bp.add_url_rule(<span class="hljs-string">&quot;/create&quot;</span>, view_func=user_route.create_user, methods=[<span class="hljs-string">&quot;POST&quot;</span>])<br>user_bp.add_url_rule(<span class="hljs-string">&quot;/delete&quot;</span>, view_func=user_route.delete_user, methods=[<span class="hljs-string">&quot;POST&quot;</span>])<br>user_bp.add_url_rule(<span class="hljs-string">&quot;/login&quot;</span>, view_func=user_route.login_route, methods=[<span class="hljs-string">&quot;POST&quot;</span>])<br>user_bp.add_url_rule(<span class="hljs-string">&quot;/logout&quot;</span>, view_func=user_route.logout_route, methods=[<span class="hljs-string">&quot;POST&quot;</span>])<br></code></pre></td></tr></table></figure><p>在把代码中的<code>blueprint</code>注册到<code>Flask</code>应用后，<code>api</code>服务也编写完成了，接着就可以部署到<code>node1</code>机器上并供客户端调用了。</p><p>可以看到这一切都非常简单，但是手动编写的重复代码比较多，通过示例代码可以看出路由函数名和url名都差别不大，每个路由代码逻辑也很像。<br>而且当想要修改<code>gRPC</code>服务的调用名称，会发现除了修改<code>Protobuf</code>文件外，<code>api</code>服务的代码也要跟着手动修改，这太麻烦了，也容易出错。</p><p>同时可以发现在上述例子中编写的转发路由代码跟<code>Protobuf</code>很像，这意味着也可以通过<code>Protobuf</code>文件生成对应的路由代码，这也是<a href="https://github.com/so1n/pait">pait</a>的实现思路，同时<a href="https://github.com/so1n/pait">pait</a><br>参照了<a href="https://github.com/googleapis/googleapis/blob/master/google/api/http.proto">google.api.http</a>来补充<code>Protobuf</code>缺少的HTTP信息，参照<a href="https://github.com/bufbuild/protoc-gen-validate">protoc-gen-validate</a>补充了请求体的信息，使<code>Protobuf</code>文件能表示<code>OpenAPI</code>的所有字段数据。</p><h2 id="2-使用Pait构建gRPC-Json网关"><a href="#2-使用Pait构建gRPC-Json网关" class="headerlink" title="2.使用Pait构建gRPC Json网关"></a>2.使用Pait构建gRPC Json网关</h2><p>了解完后，现在开始以<code>User</code>服务为例构建<code>gRPC Json</code>网关，主要涉及到API服务和Protobuf文件的修改。</p><blockquote><p>完整代码见附录二</p></blockquote><h3 id="2-1-修改Protobuf文件"><a href="#2-1-修改Protobuf文件" class="headerlink" title="2.1.修改Protobuf文件"></a>2.1.修改Protobuf文件</h3><p>使用<code>Pait</code>构建gRPC Json网关的第一步是在<code>gRPC</code>公有包中更改<code>Protobuf</code>文件, <code>gRPC</code>公有包项目结构如下:</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">.<br>├── grpc_example_common<br>│   ├── helper                  <span class="hljs-comment"># gRPC通用封装</span><br>│   ├── interceptor<br>│   │   ├── client_interceptor  <span class="hljs-comment"># gRPC客户端拦截器</span><br>│   │   └── server_interceptor  <span class="hljs-comment"># gRPC服务端拦截器</span><br>│   └── protos  <span class="hljs-comment"># 存放Protobuf文件生成的对应Python代码</span><br>│       ├── book<br>│       ├── common<br>│       └── user<br>└── protos      <span class="hljs-comment"># 存放Protobuf文件</span><br>    └── grpc_example_common<br>        └── protos<br>            ├── book    <span class="hljs-comment"># 存放书籍相关的Protobuf文件</span><br>            ├── common  <span class="hljs-comment"># 存放公有的Protobuf文件</span><br>            └── <span class="hljs-keyword">user</span>    <span class="hljs-title"># 存放用户相关的Protobuf</span>文件<br></code></pre></td></tr></table></figure><p>更改<code>Protobuf</code>文件的第一步是通过<a href="https://github.com/so1n/pait/blob/master/pait/http/api.proto">api.proto</a>和<a href="https://github.com/so1n/protobuf_to_pydantic/blob/master/p2p_validate/p2p_validate.proto">p2p_validate.proto</a>下载Protobuf文件到<code>./protos/grpc_example_common/protos/common</code>目录中，其中<code>api.proto</code>提供的是对<code>gRPC</code>接口(也就是service.rpc)的描述，<code>p2p_validate.proto</code>提供的是对<code>Message</code>的描述，下载完成后<code>./protos/grpc_example_common/protos/common</code>目录存放的<code>Protobuf</code>文件有如下3个：</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs pf">.<br>├── grpc_example_common<br>└── protos      <span class="hljs-comment"># 存放Protobuf文件</span><br>    └── grpc_example_common<br>        └── protos<br>           ├── book<br>           ├── common<br>           │   ├── api.<span class="hljs-keyword">proto</span>             <span class="hljs-comment"># &lt;-- new</span><br>           │   ├── exce.<span class="hljs-keyword">proto</span>            <span class="hljs-comment"># &lt;-- new</span><br>           │   └── p2p_validate.<span class="hljs-keyword">proto</span>    <span class="hljs-comment"># &lt;-- new</span><br>           └── <span class="hljs-keyword">user</span><br></code></pre></td></tr></table></figure><p>第二步是更改对应的Protobuf文件，以<code>User</code>服务为例子，首先是引入<code>api.proto</code>和<code>p2p_validate.proto</code>:</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Protobuf"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;grpc_example_common/protos/common/api.proto&quot;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;grpc_example_common/protos/common/p2p_validate.proto&quot;</span>;<br></code></pre></td></tr></table></figure><p>如果是使用<code>Pycharm</code>且出现如下提示:<br><img   class="lazyload" data-original="https://fastly.jsdelivr.net/gh/so1n/so1n_blog_photo@master/blog_photo/16682806984141668280697552.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" ><br>那么可以通过点击<code>Add import path to plugin settings</code>解决，如果还没办法解决而弹出一个项目文件结构的窗KPI，则点击窗口中<code>proto</code>对应的文件即可解决。</p><p>在完成头文件的引入后，就可以修改Protobuf的其他代码了，首先是修改<code>service</code>的代码，为<code>service</code>中的每一个<code>rpc</code>方法附上对应的OpenAPI信息，如下:</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs Protobuf"><span class="hljs-class"><span class="hljs-keyword">service</span> <span class="hljs-title">User</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">rpc</span> get_uid_by_token (GetUidByTokenRequest) <span class="hljs-keyword">returns</span> (GetUidByTokenResult) </span>&#123;<br>    <span class="hljs-keyword">option</span> (pait.api.http) = &#123;<br>      not_enable: <span class="hljs-literal">true</span>,   <span class="hljs-comment">// 定义Pait不解析该函数，这样Pait就不会为该函数映射到接口路由中</span><br>    &#125;;<br>  &#125;;<br>  <span class="hljs-function"><span class="hljs-keyword">rpc</span> logout_user (LogoutUserRequest) <span class="hljs-keyword">returns</span> (google.protobuf.Empty) </span>&#123;<br>    <span class="hljs-keyword">option</span> (pait.api.http) = &#123;<br>      summary: <span class="hljs-string">&quot;User exit from the system&quot;</span>,  <span class="hljs-comment">// 定义函数对应接口的简介</span><br>      <span class="hljs-comment">// url定义函数对应接口的url是&quot;/user/logout&quot;,如果不定义，则会被`Pait`自动绑定为`/User/logout_user`</span><br>      <span class="hljs-comment">// any代表具体的HTTP方法由GrpcGateway方法定义，如果要指定HTTP方法为DELETE,那么需要把any替换为delete</span><br>      any: &#123;url: <span class="hljs-string">&quot;/user/logout&quot;</span>&#125;,<br>      <span class="hljs-comment">// 定义函数接口对应的OpenAPI标签</span><br>      tag: [&#123;name: <span class="hljs-string">&quot;grpc-user&quot;</span>, desc: <span class="hljs-string">&quot;grpc_user_service&quot;</span>&#125;, &#123;name: <span class="hljs-string">&quot;user-action&quot;</span>, desc: <span class="hljs-string">&quot;User Operating Interface&quot;</span>&#125;],<br><br>      <span class="hljs-comment">// 为该函数映射一个新的接口，该接口只有如下属性不一样，其余的功能还是相同的，毕竟User服务的`logout_user`函数没有实现删除用户的功能</span><br>      additional_bindings: &#123;<br>        desc: <span class="hljs-string">&quot;This interface performs a logical delete, not a physical delete&quot;</span>,<br>        summary: <span class="hljs-string">&quot;Like delete_user&quot;</span>,<br>        delete: &#123;url: <span class="hljs-string">&quot;/user/logout&quot;</span>&#125;,<br>        tag: [<br>          &#123;name: <span class="hljs-string">&quot;grpc-user&quot;</span>, desc: <span class="hljs-string">&quot;grpc_user_service&quot;</span>&#125;,<br>          &#123;name: <span class="hljs-string">&quot;grpc-user-system&quot;</span>, desc: <span class="hljs-string">&quot;grpc_user_service&quot;</span>&#125;<br>        ]<br>      &#125;<br>    &#125;;<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>接着再修改<code>gRPC</code>函数对应的<code>Message</code>，以<code>CreateUserRequest</code>和<code>LogoutUserRequest</code>为例子,修改如下:</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs Protobuf"><span class="hljs-comment">// create user</span><br><span class="hljs-class"><span class="hljs-keyword">message</span> <span class="hljs-title">CreateUserRequest</span> </span>&#123;<br>  <span class="hljs-built_in">string</span> uid = <span class="hljs-number">1</span> [<br>    (p2p_validate.rules).<span class="hljs-built_in">string</span>.miss_default = <span class="hljs-literal">true</span>, <span class="hljs-comment">// 定义生成的字段不带有默认值</span><br>    (p2p_validate.rules).<span class="hljs-built_in">string</span>.example = <span class="hljs-string">&quot;10086&quot;</span>,  <span class="hljs-comment">// 定义生成的字段的示例值为10086</span><br>    (p2p_validate.rules).<span class="hljs-built_in">string</span>.title = <span class="hljs-string">&quot;UID&quot;</span>,  <span class="hljs-comment">// 定义生成的字段OpenAPI的Title为UId</span><br>    (p2p_validate.rules).<span class="hljs-built_in">string</span>.description = <span class="hljs-string">&quot;user union id&quot;</span>  <span class="hljs-comment">// 定义生成的字段的描述</span><br>  ];<br>  <span class="hljs-built_in">string</span> user_name = <span class="hljs-number">2</span> [<br>    (p2p_validate.rules).<span class="hljs-built_in">string</span>.description = <span class="hljs-string">&quot;user name&quot;</span>,<br>    (p2p_validate.rules).<span class="hljs-built_in">string</span>.min_length = <span class="hljs-number">1</span>, <span class="hljs-comment">// 定义字段的最小长度</span><br>    (p2p_validate.rules).<span class="hljs-built_in">string</span>.max_length = <span class="hljs-number">10</span>, <span class="hljs-comment">// 定义字段的最大长度</span><br>    (p2p_validate.rules).<span class="hljs-built_in">string</span>.example = <span class="hljs-string">&quot;so1n&quot;</span><br>  ];<br>  <span class="hljs-built_in">string</span> password = <span class="hljs-number">3</span> [<br>    (p2p_validate.rules).<span class="hljs-built_in">string</span>.description = <span class="hljs-string">&quot;user password&quot;</span>,<br>    (p2p_validate.rules).<span class="hljs-built_in">string</span>.alias = <span class="hljs-string">&quot;pw&quot;</span>,  <span class="hljs-comment">// 定义字段的别名</span><br>    (p2p_validate.rules).<span class="hljs-built_in">string</span>.min_length = <span class="hljs-number">6</span>,<br>    (p2p_validate.rules).<span class="hljs-built_in">string</span>.max_length = <span class="hljs-number">18</span>,<br>    (p2p_validate.rules).<span class="hljs-built_in">string</span>.example = <span class="hljs-string">&quot;123456&quot;</span>,<br>    <span class="hljs-comment">// 定义字段的类型，该类型是来自于`pydantic`</span><br>    <span class="hljs-comment">// 参考 https://pydantic-docs.helpmanual.io/usage/types/#secret-types</span><br>    (p2p_validate.rules).<span class="hljs-built_in">string</span>.pydantic_type = <span class="hljs-string">&quot;SecretStr&quot;</span><br>  ];<br>&#125;<br><span class="hljs-comment">// logout user</span><br><span class="hljs-class"><span class="hljs-keyword">message</span> <span class="hljs-title">LogoutUserRequest</span> </span>&#123;<br>  <span class="hljs-built_in">string</span> uid = <span class="hljs-number">1</span> [<br>    (p2p_validate.rules).<span class="hljs-built_in">string</span>.example = <span class="hljs-string">&quot;10086&quot;</span>,<br>    (p2p_validate.rules).<span class="hljs-built_in">string</span>.title = <span class="hljs-string">&quot;UID&quot;</span>,<br>    (p2p_validate.rules).<span class="hljs-built_in">string</span>.description = <span class="hljs-string">&quot;user union id&quot;</span><br>  ];<br>  <span class="hljs-built_in">string</span> token = <span class="hljs-number">2</span> [<br>    (p2p_validate.rules).<span class="hljs-built_in">string</span>.description = <span class="hljs-string">&quot;user token&quot;</span>,<br>    (p2p_validate.rules).<span class="hljs-built_in">string</span>.enable = <span class="hljs-literal">false</span> <span class="hljs-comment">// 定义不要把该值映射到model中</span><br>  ];<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><ul><li>详细的user.proto文件见：<a href="https://github.com/so1n/grpc-example-common/blob/pait-example/protos/user/user.proto">https://github.com/so1n/grpc-example-common/blob/pait-example/protos/user/user.proto</a> </li><li>这里只是做简单的介绍，更多使用方法见<a href="https://so1n.me/pait-zh-doc/7_gRPC_gateway/">Pait-gRPC-gateway文档</a></li></ul></blockquote><p>修改完成后记得通过<code>Protobuf</code>文件生成对应的<code>Python</code>代码并打包,再传到代码仓库中，具体流程见文章:<a href="https://so1n.me/2022/04/07/Python-gRPC%E5%AE%9E%E8%B7%B5(3)--%E4%BD%BF%E7%94%A8Python%E5%AE%9E%E7%8E%B0gRPC%E6%9C%8D%E5%8A%A1/">Python-gRPC实践(3)–使用Python实现gRPC服务</a></p><h3 id="2-2-修改Flask应用"><a href="#2-2-修改Flask应用" class="headerlink" title="2.2.修改Flask应用"></a>2.2.修改Flask应用</h3><p>Protobuf文件修改完后可以开始修改<code>Flask</code>服务，<code>Flask</code>应用的项目结构如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs css">├── <span class="hljs-selector-tag">app</span><span class="hljs-selector-class">.py</span><br>├── <span class="hljs-selector-tag">app_service</span><br>│   ├── __<span class="hljs-selector-tag">init__</span><span class="hljs-selector-class">.py</span><br>│   ├── <span class="hljs-selector-tag">manager_book_route</span><span class="hljs-selector-class">.py</span><br>│   ├── <span class="hljs-selector-tag">route</span><span class="hljs-selector-class">.py</span><br>│   ├── <span class="hljs-selector-tag">social_book_route</span><span class="hljs-selector-class">.py</span><br>│   ├── <span class="hljs-selector-tag">user_route</span><span class="hljs-selector-class">.py</span><br>│   └── <span class="hljs-selector-tag">utils</span><span class="hljs-selector-class">.py</span><br>├── <span class="hljs-selector-tag">grpc_service</span><br>│   ├── <span class="hljs-selector-tag">book_service</span><span class="hljs-selector-class">.py</span><br>│   ├── __<span class="hljs-selector-tag">init__</span><span class="hljs-selector-class">.py</span><br>│   └── <span class="hljs-selector-tag">user_service</span><span class="hljs-selector-class">.py</span><br>└── <span class="hljs-selector-tag">gunicorn</span><span class="hljs-selector-class">.conf</span><span class="hljs-selector-class">.py</span><br></code></pre></td></tr></table></figure><p>为了区分两种不同的调用，会在<code>app_service</code>文件夹新建一个名为<code>user_gateway_route.py</code>的文件，并编写如下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> Type<br><span class="hljs-keyword">import</span> grpc<br><br><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Flask, jsonify, Response<br><span class="hljs-keyword">from</span> pydantic <span class="hljs-keyword">import</span> BaseModel, Field<br><br><span class="hljs-keyword">from</span> pait.app.flask.grpc_route <span class="hljs-keyword">import</span> GrpcGatewayRoute<br><span class="hljs-keyword">from</span> pait.app <span class="hljs-keyword">import</span> set_app_attribute<br><span class="hljs-keyword">from</span> pait.model.response <span class="hljs-keyword">import</span> PaitBaseResponseModel, PaitJsonResponseModel<br><span class="hljs-keyword">from</span> pait.util.grpc_inspect.stub <span class="hljs-keyword">import</span> GrpcModel<br><span class="hljs-keyword">from</span> protobuf_to_pydantic <span class="hljs-keyword">import</span> msg_to_pydantic_model<br><br><span class="hljs-keyword">from</span> grpc_example_common.protos.user <span class="hljs-keyword">import</span> user_pb2_grpc<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">gen_response_model_handle</span>(<span class="hljs-params">grpc_model: GrpcModel</span>) -&gt; Type[PaitBaseResponseModel]:</span><br>    <span class="hljs-comment"># 动态生成对应的响应模型</span><br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomerJsonResponseModel</span>(<span class="hljs-params">PaitJsonResponseModel</span>):</span><br>        <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomerJsonResponseRespModel</span>(<span class="hljs-params">BaseModel</span>):</span><br>            code: <span class="hljs-built_in">int</span> = Field(<span class="hljs-number">0</span>, description=<span class="hljs-string">&quot;api code&quot;</span>)<br>            msg: <span class="hljs-built_in">str</span> = Field(<span class="hljs-string">&quot;success&quot;</span>, description=<span class="hljs-string">&quot;api status msg&quot;</span>)<br>            data: msg_to_pydantic_model(grpc_model.response) = Field(description=<span class="hljs-string">&quot;api response data&quot;</span>)  <span class="hljs-comment"># type: ignore</span><br><br>        name: <span class="hljs-built_in">str</span> = grpc_model.response.DESCRIPTOR.name<br>        response_data: Type[BaseModel] = CustomerJsonResponseRespModel<br><br>    <span class="hljs-keyword">return</span> CustomerJsonResponseModel<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add_grpc_gateway_route</span>(<span class="hljs-params">app: Flask</span>) -&gt; <span class="hljs-keyword">None</span>:</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_make_response</span>(<span class="hljs-params">resp_dict: <span class="hljs-built_in">dict</span></span>) -&gt; Response:</span><br>        <span class="hljs-keyword">return</span> jsonify(&#123;<span class="hljs-string">&quot;code&quot;</span>: <span class="hljs-number">0</span>, <span class="hljs-string">&quot;msg&quot;</span>: <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;data&quot;</span>: resp_dict&#125;)<br>    <br>    <span class="hljs-comment"># 定义一个网关路由，该路由已经把gRPC的方法映射到指定的Flask应用中</span><br>    grpc_gateway_route: GrpcGatewayRoute = GrpcGatewayRoute(<br>        app,<br>        <span class="hljs-comment"># 通过User.proto生成的Python代码中的`UserStub`类,Pait可以通过该类解析出User.proto对应的方法</span><br>        user_pb2_grpc.UserStub,<br>        <span class="hljs-comment"># 指定对应路由的前缀</span><br>        prefix=<span class="hljs-string">&quot;/api/gateway&quot;</span>,<br>        title=<span class="hljs-string">&quot;UserGrpc&quot;</span>,<br>        gen_response_model_handle=gen_response_model_handle,  <span class="hljs-comment"># 定义返回响应的OpenAPI模型，方便生成OpenAPI文档</span><br>        make_response=_make_response,   <span class="hljs-comment"># 定义返回的响应格式</span><br>    )<br>    <span class="hljs-comment"># 初始化gRPC的channel并传入`grpc_gateway_route`中</span><br>    grpc_gateway_route.init_channel(grpc.intercept_channel(grpc.insecure_channel(<span class="hljs-string">&quot;0.0.0.0:9001&quot;</span>)))<br></code></pre></td></tr></table></figure><p>这样一来<code>Pait</code>就能把<code>User</code>的服务映射到对应的<code>Flask</code>应用实例了， 但是User服务的部分接口并没有要求用户验证，需要我们先在<code>Flask</code>实例进行校验后才可以调用<code>gRPC</code>服务，而对于<code>logout_user</code>方法则需要token参数。<br>对于这两个需求，可以通过对<code>GrpcGatewayRoute</code>的生成路由方法进行改写来达到我们的目的，改写代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomerGrpcGatewayRoute</span>(<span class="hljs-params">GrpcGatewayRoute</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">gen_route</span>(<span class="hljs-params">self, grpc_model: GrpcModel, request_pydantic_model_class: Type[BaseModel]</span>) -&gt; Callable:</span><br><br>        <span class="hljs-comment"># 对于登录和创建用户接口不需要Token，所以采用原生的方法</span><br>        <span class="hljs-keyword">if</span> grpc_model.method <span class="hljs-keyword">in</span> (<span class="hljs-string">&quot;/user.User/login_user&quot;</span>, <span class="hljs-string">&quot;/user.User/create_user&quot;</span>):<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>().gen_route(grpc_model, request_pydantic_model_class)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_route</span>(<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">                <span class="hljs-comment"># 通过对应的grpc message生成的pydantic.BaseModel对象</span></span></span><br><span class="hljs-function"><span class="hljs-params">                request_pydantic_model: request_pydantic_model_class,  <span class="hljs-comment"># type: ignore</span></span></span><br><span class="hljs-function"><span class="hljs-params">                <span class="hljs-comment"># 添加token参数</span></span></span><br><span class="hljs-function"><span class="hljs-params">                token: <span class="hljs-built_in">str</span> = Header.i(<span class="hljs-params">description=<span class="hljs-string">&quot;User Token&quot;</span></span>),</span></span><br><span class="hljs-function"><span class="hljs-params">                <span class="hljs-comment"># 添加请求id参数，与需求无关</span></span></span><br><span class="hljs-function"><span class="hljs-params">                req_id: <span class="hljs-built_in">str</span> = Header.i(<span class="hljs-params">alias=<span class="hljs-string">&quot;X-Request-Id&quot;</span>, default_factory=<span class="hljs-keyword">lambda</span>: <span class="hljs-built_in">str</span>(<span class="hljs-params">uuid4(<span class="hljs-params"></span>)</span>)</span>),</span></span><br><span class="hljs-function"><span class="hljs-params">            </span>) -&gt; Any:</span><br>                func: Callable = self.get_grpc_func(grpc_model.method)<br>                request_dict: <span class="hljs-built_in">dict</span> = request_pydantic_model.<span class="hljs-built_in">dict</span>()  <span class="hljs-comment"># type: ignore</span><br>                <span class="hljs-keyword">if</span> grpc_model.method == <span class="hljs-string">&quot;/user.User/logout_user&quot;</span>:<br>                    <span class="hljs-comment"># 退出登陆接口需要token</span><br>                    request_dict[<span class="hljs-string">&quot;token&quot;</span>] = token<br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-comment"># 其他接口不需要token参数，只需要校验token是否合法，如果不合法则抛出异常</span><br>                    result: user_pb2.GetUidByTokenResult = user_pb2_grpc.UserStub(self.channel).get_uid_by_token(<br>                        user_pb2.GetUidByTokenRequest(token=token)<br>                    )<br>                    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> result.uid:<br>                        <span class="hljs-keyword">raise</span> RuntimeError(<span class="hljs-string">f&quot;Not found user by token:<span class="hljs-subst">&#123;token&#125;</span>&quot;</span>)<br>                <span class="hljs-comment"># 生成调用参数后再调用gRPC方法，并把gRPC方法返回的数据返回给调用端</span><br>                request_msg: Message = self.get_msg_from_dict(grpc_model.request, request_dict)<br>                grpc_msg: Message = func(request_msg, metadata=[(<span class="hljs-string">&quot;req_id&quot;</span>, req_id)])<br>                <span class="hljs-keyword">return</span> self._make_response(self.get_dict_from_msg(grpc_msg))<br><br>            <span class="hljs-keyword">return</span> _route<br></code></pre></td></tr></table></figure><p>这样一来业务逻辑就跟原本的逻辑一样了，可以进行最后一步操作–往<code>Flask</code>应用注入对应的路由，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">create_app</span>() -&gt; Flask:</span><br>    app: Flask = Flask(__name__)<br>    app.json_encoder = CustomJSONEncoder<br>    app.register_blueprint(manager_book_bp)<br>    app.register_blueprint(social_book_bp)<br>    app.register_blueprint(user_bp)<br><br>    book_grpc_service: BookGrpcService = BookGrpcService(<span class="hljs-string">&quot;0.0.0.0&quot;</span>, <span class="hljs-number">9000</span>)<br>    book_grpc_service.channel_ready_future(timeout=<span class="hljs-number">3</span>)<br>    user_grpc_service: UserGrpcService = UserGrpcService(<span class="hljs-string">&quot;0.0.0.0&quot;</span>, <span class="hljs-number">9001</span>)<br>    user_grpc_service.channel_ready_future(timeout=<span class="hljs-number">3</span>)<br>    ContextMiddleware(app=app, book_grpc_service=book_grpc_service, user_grpc_service=user_grpc_service)<br><br>    <span class="hljs-comment"># 映射gRPC服务对应的接口到app</span><br>    add_grpc_gateway_route(app)<br>    <span class="hljs-comment"># 添加一个OpenAPI文档路由，从而可以查看被Pait托管路由的接口文档</span><br>    add_doc_route(app)<br>    app.errorhandler(Exception)(api_exception)<br>    <span class="hljs-keyword">return</span> app<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    <span class="hljs-comment"># 屏蔽接口文档中`OPTIONS`和`HEAD`方法接口的展示</span><br>    config.init_config(apply_func_list=[apply_block_http_method_set(&#123;<span class="hljs-string">&quot;OPTIONS&quot;</span>, <span class="hljs-string">&quot;HEAD&quot;</span>&#125;)])<br>    create_app().run(<span class="hljs-string">&quot;localhost&quot;</span>, port=<span class="hljs-number">8000</span>)<br><br></code></pre></td></tr></table></figure><p>代码修改完毕后，分别先启动User和Book服务，再启动Flask应用，并在浏览器输入<code>http://127.0.0.1:8000/swagger</code>即可看到通过<code>Pait Json</code>网关生成的接口的接口文档页面：<br><img   class="lazyload" data-original="https://fastly.jsdelivr.net/gh/so1n/so1n_blog_photo@master/blog_photo/16683504910421668350490672.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" ></p><p>在检查文档展示的接口与Protobuf文件描述的是一致后，可以通过接口文档页面来尝试生成的<code>gRPC Json</code>网关是否可以正常使用，如下动图，其中左上图为<code>User</code>服务，左下图为<code>Flask</code>应用，而右半边的图是<code>Swagger</code>页面:<br><img   class="lazyload" data-original="https://fastly.jsdelivr.net/gh/so1n/so1n_blog_photo@master/blog_photo/1668352148437%E5%BD%95%E5%B1%8F_%E9%80%89%E6%8B%A9%E5%8C%BA%E5%9F%9F_20221113230819.gif" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" ></p><p>除了动图的操作外，还可以尝试修改<code>uid</code>等字段的长度在执行，会发现<code>Flask</code>应用由于我们传过来的值不满足校验规则而抛出错误。</p><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p>示例代码只是为了演示，并无任何实际意义，也不适用于生产环境：</p><h3 id="附录一，简单的gRPC示例项目代码"><a href="#附录一，简单的gRPC示例项目代码" class="headerlink" title="附录一，简单的gRPC示例项目代码"></a>附录一，简单的gRPC示例项目代码</h3><p>api服务：<a href="https://github.com/so1n/grpc-example-api-backend-service">https://github.com/so1n/grpc-example-api-backend-service</a><br>用户服务: <a href="https://github.com/so1n/grpc-example-user-grpc-service">https://github.com/so1n/grpc-example-user-grpc-service</a><br>书籍管理服务：<a href="https://github.com/so1n/grpc-example-book-grpc-service">https://github.com/so1n/grpc-example-book-grpc-service</a><br><code>gRPC</code>公有包（包括<code>gRPC</code>调用封装和protobuf文件）：<a href="https://github.com/so1n/grpc-example-common">https://github.com/so1n/grpc-example-common</a></p><h3 id="附录二，使用Pait快速构建gRPC-Json网关代码"><a href="#附录二，使用Pait快速构建gRPC-Json网关代码" class="headerlink" title="附录二，使用Pait快速构建gRPC Json网关代码"></a>附录二，使用Pait快速构建gRPC Json网关代码</h3><p>api服务:<a href="https://github.com/so1n/grpc-example-api-backend-service">https://github.com/so1n/grpc-example-api-backend-service</a><br><code>gRPC</code>公有包：<a href="https://github.com/so1n/grpc-example-common/tree/pait-example">https://github.com/so1n/grpc-example-common/tree/pait-example</a></p><blockquote><p>其他服务只需要把<code>gRPC</code>公有包依赖更新到<code>pait-example</code>分支即可</p></blockquote><h3 id="服务三，使用文档"><a href="#服务三，使用文档" class="headerlink" title="服务三，使用文档"></a>服务三，使用文档</h3><p><code>Pait Json</code>网关文档: <a href="https://so1n.me/pait-zh-doc/7_gRPC_gateway/">https://so1n.me/pait-zh-doc/7_gRPC_gateway/</a><br><a href="https://github.com/so1n/protobuf_to_pydantic">protobuf_to_pydantic文档</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前记&quot;&gt;&lt;a href=&quot;#前记&quot; class=&quot;headerlink&quot; title=&quot;前记&quot;&gt;&lt;/a&gt;前记&lt;/h2&gt;&lt;p&gt;&lt;code&gt;gRPC&lt;/code&gt;已经是一个大多数开发者使用微服务时选择的通信协议，大多数公司的内部服务都会通过&lt;code&gt;gRPC&lt;/co</summary>
      
    
    
    <content src="https://fastly.jsdelivr.net/gh/so1n/so1n_blog_photo@master/blog_photo/1668428052290logo_transparent.png" type="image"/>
    
    
    <category term="pait" scheme="http://so1n.me/categories/pait/"/>
    
    
    <category term="gRPC,pait" scheme="http://so1n.me/tags/gRPC-pait/"/>
    
  </entry>
  
  <entry>
    <title>为何在Python生态很少听说到依赖注入</title>
    <link href="http://so1n.me/2022/10/15/%E4%B8%BA%E4%BD%95%E5%9C%A8Python%E7%94%9F%E6%80%81%E5%BE%88%E5%B0%91%E5%90%AC%E8%AF%B4%E5%88%B0%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/"/>
    <id>http://so1n.me/2022/10/15/%E4%B8%BA%E4%BD%95%E5%9C%A8Python%E7%94%9F%E6%80%81%E5%BE%88%E5%B0%91%E5%90%AC%E8%AF%B4%E5%88%B0%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/</id>
    <published>2022-10-15T12:31:18.000Z</published>
    <updated>2022-10-25T16:15:54.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前记"><a href="#前记" class="headerlink" title="前记"></a>前记</h2><p>由于使用的主要编程语言是<code>Python</code>，所以对于依赖注入这个概念并不是很清楚或者不知道自己已经在代码中运用了依赖注入的用法，在接触了DDD后才开始真正的了解什么是依赖注入以及依赖注入的重要性，同时也很好奇为何在<code>Python</code> 生态中依赖注入的出现率较低。</p><h2 id="1-控制反转与依赖注入"><a href="#1-控制反转与依赖注入" class="headerlink" title="1.控制反转与依赖注入"></a>1.控制反转与依赖注入</h2><p>在查找依赖注入的相关资料时发现依赖注入与控制反转这两个词是成对出现的，这是因为控制反转并不是一种技术，而是一种编程思想，这种思想能指导我们如何设计出松耦合优良的程序，而依赖注入是一个具体的设计模式，它是控制反转的一种具体实现。</p><p>控制反转这个概念有点模糊，但后端开发者来说却是经常接触到的，比如在对框架与库的使用时，分别接触到他们的反向控制和正向控制，而框架的反向控制正是控制反转的体现。<br>大多数人很少去区分在项目中使用的包是属于框架还是库，也不会很清晰的去区分它们属于哪一种，我也是这样的，在经过了一段编程生涯后我才可以简单的把主动调用的包归类为库，只能被动调用的包归类为框架。</p><p>不过最近在翻阅依赖注入与控制反转的相关文章<a href="https://martinfowler.com/bliki/InversionOfControl.html">InversionOfControl</a>时发现，控制反转也可以是框架和库的关键区别点。因为对于一个库来说，程序员使用的方式是主动的调用它，如下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> httpx<br><br>response = httpx.get(<span class="hljs-string">&quot;https://so1n.me&quot;</span>)<br>print(response.status_code)<br></code></pre></td></tr></table></figure><p>这段代码主动的调用<code>httpx</code>包的<code>get</code>方法发起一个请求以获取网站对应的状态码，由于这种调用方法属于开发者去主动调用库，所以属于正向的控制。</p><p>而框架就不一样了，框架一般都会提供一些注册的方法将我们编写的代码注册到框架中，最后由框架来调用程序员编写的代码，如下例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">from</span> starlette.applications <span class="hljs-keyword">import</span> Starlette<br><span class="hljs-keyword">from</span> starlette.requests <span class="hljs-keyword">import</span> Request<br><span class="hljs-keyword">from</span> starlette.responses <span class="hljs-keyword">import</span> PlainTextResponse<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">demo</span>(<span class="hljs-params">request: Request</span>) -&gt; PlainTextResponse:</span><br>    <span class="hljs-keyword">return</span> PlainTextResponse(<span class="hljs-string">f&quot;Hello <span class="hljs-subst">&#123;request.query_params.get(<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>)&#125;</span>!&quot;</span>)<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">create_app</span>() -&gt; Starlette:</span><br>    app: Starlette = Starlette()<br>    app.add_route(<span class="hljs-string">&quot;/&quot;</span>, demo, methods=[<span class="hljs-string">&quot;GET&quot;</span>])<br>    <span class="hljs-keyword">return</span> app<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    <span class="hljs-keyword">import</span> uvicorn<br><br>    app: Starlette = create_app()<br>    uvicorn.run(app)<br></code></pre></td></tr></table></figure><p>这段代码中先是声明一个路由函数<code>demo</code>，这个路由函数是按照框架要求的方式编写的，这个要求是路由函数必须接收一个<code>Request</code>参数以及返回一个<code>Response</code>类；接着在实例化框架时通过<code>add_route</code>方法以<code>path=/</code>，<code>method=GET</code>的形式注册到框架中以及在调用<code>uvicorn.run(app)</code>的时候把控制权转移给了框架，并由框架在后续完成对<code>demo</code>路由函数的调用，这种调用方式属于反向控制。</p><blockquote><p>Note: 对于流式客户端封装的库可能包含着主动调用与被动调用，使其不像框架也不像库。</p></blockquote><p>此外，从例子中可以看到，创建的<code>demo</code>路由函数是交给了框架控制的，不再由开发者控制，而且<code>demo</code>路由函数接收的<code>Request</code>类参数是在运行时由框架管理创建和注销并注入给路由函数供路由函数使用的，这就是控制反转的主体思想，通过这种思想能公减少工程项目不同层次代码打耦合。</p><p>依赖注入则是控制反转的一种具体实现方式，这种方式能让一个对象接收它所依赖的其他对象。其中“依赖”是指接收方所需的对象，“注入”是指将“依赖”传递给接收方的过程。在“注入”之后，接收方才会调用该“依赖”。<br>而依赖注入框架则是一种根据对象的依赖关系的在运行时进行绑定的技术，通常它都会带有一个容器，这个容器托管着许多对象，并在运行时根据对象的依赖关系把对象传递给被控制的其它对象中。比如例子中的<code>starlette</code>框架在运行时就是一个容器，它可以根据不同的请求创建不同的请求对象并在根据请求规则匹配到对应的路由函数后把请求对象注入给路由函数使用。</p><h2 id="2-为什么需要控制反转与依赖注入"><a href="#2-为什么需要控制反转与依赖注入" class="headerlink" title="2.为什么需要控制反转与依赖注入"></a>2.为什么需要控制反转与依赖注入</h2><p>以一个客户端的设计为例，通常一个客户端会分为调用层，协议层和连接层3层，通常情况下都会这样去实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> Any<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Connection</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, host: <span class="hljs-built_in">str</span>, port: <span class="hljs-built_in">int</span></span>):</span><br>        self._host: <span class="hljs-built_in">str</span> = host<br>        self._port: <span class="hljs-built_in">int</span> = port<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">send</span>(<span class="hljs-params">self, data: Any</span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        <span class="hljs-string">&quot;&quot;&quot;发送数据到服务端&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">pass</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">read</span>(<span class="hljs-params">self</span>) -&gt; Any:</span><br>        <span class="hljs-string">&quot;&quot;&quot;从服务端接收数据&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">pass</span><br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Protocol</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, host: <span class="hljs-built_in">str</span>, port: <span class="hljs-built_in">int</span></span>):</span><br>        self._conn: Connection = Connection(host, port)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">request</span>(<span class="hljs-params">self, *args: Any, **kwargs: Any</span>) -&gt; Any:</span><br>        <span class="hljs-string">&quot;&quot;&quot;发送请求并等待响应&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">pass</span><br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, host: <span class="hljs-built_in">str</span>, port: <span class="hljs-built_in">int</span></span>):</span><br>        self._protocol: Protocol = Protocol(host, port)<br></code></pre></td></tr></table></figure><p>这段代码中分别包括了客户端的连接层的<code>Connection</code>，协议层的<code>Protocol</code>以及调用层的<code>Client</code>，对于使用者来说，他们不用去过于了解<code>Connection</code>和<code>Protocol</code>的实现，只需要知道<code>host</code>和<code>port</code>的参数要填什么以及<code>Client</code>该如何使用即可。</p><p>不过这段代码却出现了一条依赖链（<code>Client</code>依赖于<code>Protocol</code>，<code>Protocol</code>依赖于<code>Connection</code>)，同时客户端里面的不同层都把控了对下层对象的创建主动权，创建主动时机以及使用权，这样会造成上下层对象有很强的耦合，导致代码比较难维护。<br>比如要在<code>Connection</code>增加一个SSL功能，这个功能需要一些SSL参数，那么三层都要进行更改，使用者才可以把SSL参数传给<code>Connection</code>，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> Any<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Connection</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, host: <span class="hljs-built_in">str</span>, port: <span class="hljs-built_in">int</span>, ssl: Any</span>):</span>  <span class="hljs-comment"># &lt;--</span><br>        self._host: <span class="hljs-built_in">str</span> = host<br>        self._port: <span class="hljs-built_in">int</span> = port<br>        self._ssl: Any = ssl<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">send</span>(<span class="hljs-params">self, data: Any</span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        <span class="hljs-string">&quot;&quot;&quot;发送数据到服务端&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">pass</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">read</span>(<span class="hljs-params">self</span>) -&gt; Any:</span><br>        <span class="hljs-string">&quot;&quot;&quot;从服务端接收数据&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">pass</span><br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Protocol</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, host: <span class="hljs-built_in">str</span>, port: <span class="hljs-built_in">int</span>, ssl: Any</span>):</span>  <span class="hljs-comment"># &lt;--</span><br>        self._conn: Connection = Connection(host, port, ssl)  <span class="hljs-comment"># &lt;--</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">request</span>(<span class="hljs-params">self, *args: Any, **kwargs: Any</span>) -&gt; Any:</span><br>        <span class="hljs-string">&quot;&quot;&quot;发送请求并等待响应&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">pass</span><br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, host: <span class="hljs-built_in">str</span>, port: <span class="hljs-built_in">int</span>, ssl: Any</span>):</span>  <span class="hljs-comment"># &lt;--</span><br>        self._protocol: Protocol = Protocol(host, port, Any)  <span class="hljs-comment"># &lt;--</span><br><br></code></pre></td></tr></table></figure><p>通过这段代码可以看到，为了让连接层支持SSL功能，需要从<code>Client</code>开始一层一层的把SSL功能的参数传递下去，这还好只是分了三层，比较容易操作，如果分的层次比较多，将会非常的难受，而且在工程项目中，一个类可能会被不同的类所依赖的，这意味着为一个基础类增减某些功能会导致其它依赖它的类也要进行修改，这会浪费大量的开发时间和测试时间，同时使依赖它的类都需要发生变动，这会增加系统出现BUG的风险。</p><p>为了解决这个问题，可以根据控制反转的思想，把上层对象创建下层对象的权利和创建时机转移给第三方来控制，仅保留上层对象对下层对象的使用权，修改完的代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> Any<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Connection</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, host: <span class="hljs-built_in">str</span>, port: <span class="hljs-built_in">int</span>, ssl: Any</span>):</span>  <span class="hljs-comment"># &lt;--</span><br>        self._host: <span class="hljs-built_in">str</span> = host<br>        self._port: <span class="hljs-built_in">int</span> = port<br>        self._ssl: Any = ssl<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">send</span>(<span class="hljs-params">self, data: Any</span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        <span class="hljs-string">&quot;&quot;&quot;发送数据到服务端&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">pass</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">read</span>(<span class="hljs-params">self</span>) -&gt; Any:</span><br>        <span class="hljs-string">&quot;&quot;&quot;从服务端接收数据&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">pass</span><br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Protocol</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, connection: Connection</span>):</span>  <span class="hljs-comment"># &lt;--</span><br>        self._conn: Connection = connection  <span class="hljs-comment"># &lt;--</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">request</span>(<span class="hljs-params">self, *args: Any, **kwargs: Any</span>) -&gt; Any:</span><br>        <span class="hljs-string">&quot;&quot;&quot;发送请求并等待响应&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">pass</span><br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, protocol: Protocol</span>):</span>  <span class="hljs-comment"># &lt;--</span><br>        self._protocol: Protocol = protocol   <span class="hljs-comment"># &lt;--</span><br></code></pre></td></tr></table></figure><p>可以发现，这段代码经过变更后，每一层只接收自己需要依赖的对象，在这种设计下可以在<code>Client</code>和<code>Protocol</code>代码没变动的情况下同时接收实现SSL功能和没实现SSL功能等实现了<code>send</code>和<code>read</code>方法的<code>Connection</code>对象。</p><p>接下来只要通过第三方来创建对象即可，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Python">client: Client = Client(<br>    protocol=Protocol(<br>        connection=Connection(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">8000</span>, <span class="hljs-built_in">object</span>())<br>    )<br>)<br><br>no_ssl_client: Client = Client(<br>    protocol=Protocol(<br>        connection=NoSslConnection(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">8000</span>)<br>    )<br>)<br></code></pre></td></tr></table></figure><p>这段代码中管理依赖对象的生命周期以及对象的关系全靠手动编写代码，使其在运行时完成对象绑定的，如果项目中分了很多层或者依赖关系比较复杂的话，手动处理会比较麻烦，也不方便后续的迭代。<br>这时就需要通过依赖注入框架来帮忙自动整理依赖关系以及注入到需要的对象中，比如在使用<code>dependency-injector</code>这个依赖注入框架后，代码就可以变为如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">from</span> dependency_injector <span class="hljs-keyword">import</span> containers, providers<br><span class="hljs-keyword">from</span> dependency_injector.wiring <span class="hljs-keyword">import</span> Provide, inject<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Container</span>(<span class="hljs-params">containers.DeclarativeContainer</span>):</span><br>    <span class="hljs-comment"># 依赖注入框架提供的容器，该容器会管理对象的创建</span><br><br>    <span class="hljs-comment"># 用于加载配置</span><br>    config = providers.Configuration()<br><br>    <span class="hljs-comment"># 通过`providers.Singleton`创建的对象在整个生命周期中会保持唯一(单例)</span><br>    conn = providers.Singleton(<br>        Connection ,<br>        host=config.host,<br>        port=config.port,<br>    )<br>    <span class="hljs-comment"># 创建protocol层的工厂函数</span><br>    protocol = providers.Factory(<br>        Protocol,<br>        connection=Connection,<br>    )<br><br>    <span class="hljs-comment"># 创建client层的工厂函数</span><br>    client = providers.Factory(<br>        Client,<br>        protocol=protocol,<br>    )<br><br><span class="hljs-comment"># 注入装饰器，可以自动的把对应的值注入到被装饰的函数中</span><br><span class="hljs-meta">@inject</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>(<span class="hljs-params">client: Client = Provide[Container.client]</span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>    ...<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    <span class="hljs-comment"># 初始化容器</span><br>    container = Container()<br>    <span class="hljs-comment"># 通过env加载配置</span><br>    container.config.api_key.from_env(<span class="hljs-string">&quot;host&quot;</span>, required=<span class="hljs-literal">True</span>)<br>    container.config.timeout.from_env(<span class="hljs-string">&quot;port&quot;</span>, as_=<span class="hljs-built_in">int</span>, default=<span class="hljs-number">4</span>)<br>    <span class="hljs-comment"># 通过wire把容器与模块连接起来，这样该模块的`inject`装饰器可以读到对应的容器</span><br>    container.wire(modules=[__name__])<br><br>    main()  <span class="hljs-comment"># 通过带有SSL功能的Connection运行代码</span><br><br>    <span class="hljs-keyword">with</span> container.conn.override(NoSslConnection(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">8000</span>)):<br>        main()  <span class="hljs-comment"># 通过没有SSL功能的Connection运行代码</span><br></code></pre></td></tr></table></figure><p>通过这段代码可以发现，每个对象都存在于容器<code>Container</code>中，并通过<code>inject</code>装饰器就可以自动的把依赖对象进行绑定，不再需要手动处理，在依赖层级比较深的时候能缓解开发者的心智负担，同时通过<code>override</code>语法可以很方便的在新的作用域替换其中的一个依赖对象。</p><h2 id="3-为何在Python生态中很少听到依赖注入"><a href="#3-为何在Python生态中很少听到依赖注入" class="headerlink" title="3.为何在Python生态中很少听到依赖注入"></a>3.为何在Python生态中很少听到依赖注入</h2><p>了解了依赖注入与控制反转后可以发现，在<code>Python</code>生态也会通过控制反转的方式去进行解耦，但是很少有人会直接说自己用了依赖注入来解决上述的问题。</p><p>会这样的第一个原因是大部分被依赖注入容器托管的对象都被要求是单例的，而<code>Python</code>的每个模块中的对象也都是单例的，这样一来实现工程项目就会比较方便，比如下面一个Web项目的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-comment"># orm.py</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Orm</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-keyword">pass</span><br><br><br>orm: Orm = Orm()<br><br><span class="hljs-comment"># route.py</span><br><span class="hljs-keyword">from</span> starlette.requests <span class="hljs-keyword">import</span> Request<br><span class="hljs-keyword">from</span> starlette.responses <span class="hljs-keyword">import</span> PlainTextResponse<br><span class="hljs-keyword">from</span> orm <span class="hljs-keyword">import</span> orm<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">demo</span>(<span class="hljs-params">request: Request</span>) -&gt; PlainTextResponse:</span><br>    name: <span class="hljs-built_in">str</span> = request.query_params.get(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;&quot;</span>)<br>    _id: <span class="hljs-built_in">int</span> = orm.user.get(name)<br>    <span class="hljs-keyword">return</span> PlainTextResponse(<span class="hljs-string">f&quot;Hello <span class="hljs-subst">&#123;_id&#125;</span>!&quot;</span>)<br></code></pre></td></tr></table></figure><p>这个例子是<code>Python</code>开发者常用的开发模式，在这个例子中有<code>orm</code>和<code>route</code>两个模块，这时如果把<code>Python</code>的运行时环境认为是一个大的依赖注入容器，把<code>orm</code>模块和<code>route</code>模块认为是容器的托管的对象，把<code>route</code>模块引用到了<code>orm</code>模块则认为是依赖注入容器把orm注入到了<code>route</code>模块中时可以发现，<code>Python</code>开发者在不经意间就实现类似于静态语言的依赖注入了。</p><p>除此之外，还有重要的一点是在静态语言中，编译期，装载期和运行时期都是严格分离的，无法在运行期执行装载期的工作，这样就需要依赖注入容器通过反射来进行处理，比如<code>Java</code>的<code>Spring</code>框架，而<code>Python</code>是一门动态语言，它的运行时环境可以认为是一个大的依赖注入容器，所以<code>Python</code>可以在运行时替换某个对象，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs Python">  <br><span class="hljs-keyword">import</span> requests  <br><span class="hljs-keyword">import</span> httpx  <br>  <br>  <br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span>  <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span>  <br>        self._get = requests.get  <br>  <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__call__</span>(<span class="hljs-params">self, *args, **kwargs</span>) -&gt; Any:</span>  <br>        <span class="hljs-keyword">return</span> self._get(*args, **kwargs)  <br>  <br>print(<span class="hljs-built_in">type</span>(Demo()(<span class="hljs-string">&quot;https://so1n.me&quot;</span>)))<br><span class="hljs-comment"># &gt;&gt;&gt; &lt;class &#x27;requests.models.Response&#x27;&gt;</span><br>requests.get = httpx.get  <br>print(<span class="hljs-built_in">type</span>(Demo()(<span class="hljs-string">&quot;https://so1n.me&quot;</span>)))<br><span class="hljs-comment"># &gt;&gt;&gt; &lt;class &#x27;httpx.Response&#x27;&gt;</span><br></code></pre></td></tr></table></figure><p>在这段代码中，由于<code>httpx</code>库采用了类似<code>requests</code>库的实现，所以在使用上差别不大，在<code>Python</code>中可以简单的对依赖对象进行替换，通过输出结果可以看出，没替换前返回的响应结果类型是<code>requests.model.Respnose</code>而替换后响应结果类型是<code>httpx.Response</code>，证明已经替换成功了。</p><p>所以<code>Python</code>开发者可以通过<code>Python</code>的语法特性快速的实现静态语言中依赖注入容器的相关功能了，可以认为在<code>Python</code>中依赖注入是很常见的，但是因为太常见了，而且只需要用到<code>Python</code>的语言特性就可以实现依赖注入容器的功能，导致没有那么多人知道自己已经使用了依赖注入，也没必要用到依赖注入框架，所以讨论的热度会比较低，这可能就是在<code>Python</code>生态中很少听到依赖注入的原因吧。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>可以看出通过控制反转可以很方便的把对象之中的依赖进行解耦，方便项目的迭代开发，而依赖注入是控制反转的具体实现，在静态语言中通过依赖注入可以将对象的索取从编译期和装载期移到了运行期。而<code>Python</code>由于本身是动态语言以及自己的语言特性，开发者会通过常见的开发模式来达到静态语言依赖注入的类似需求，所以在<code>Python</code>生态中很少听到依赖注入，不过对于DDD领域设计开发则是一个例外。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前记&quot;&gt;&lt;a href=&quot;#前记&quot; class=&quot;headerlink&quot; title=&quot;前记&quot;&gt;&lt;/a&gt;前记&lt;/h2&gt;&lt;p&gt;由于使用的主要编程语言是&lt;code&gt;Python&lt;/code&gt;，所以对于依赖注入这个概念并不是很清楚或者不知道自己已经在代码中运用了依赖注入</summary>
      
    
    
    <content src="https://fastly.jsdelivr.net/gh/so1n/so1n_blog_photo@master/blog_photo/16667142993131666714298611.png" type="image"/>
    
    
    <category term="依赖注入" scheme="http://so1n.me/categories/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/"/>
    
    
    <category term="依赖注入，控制反转" scheme="http://so1n.me/tags/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%EF%BC%8C%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC/"/>
    
  </entry>
  
  <entry>
    <title>Python-gRPC实践(7)--gRPC的错误传递</title>
    <link href="http://so1n.me/2022/06/23/Python-gRPC%E5%AE%9E%E8%B7%B5(7)--gRPC%E9%94%99%E8%AF%AF%E4%BC%A0%E9%80%92%20copy/"/>
    <id>http://so1n.me/2022/06/23/Python-gRPC%E5%AE%9E%E8%B7%B5(7)--gRPC%E9%94%99%E8%AF%AF%E4%BC%A0%E9%80%92%20copy/</id>
    <published>2022-06-23T12:35:24.000Z</published>
    <updated>2022-11-22T06:16:10.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前在文章<a href="https://so1n.me/2022/04/07/Python-gRPC%E5%AE%9E%E8%B7%B5(3)--%E4%BD%BF%E7%94%A8Python%E5%AE%9E%E7%8E%B0gRPC%E6%9C%8D%E5%8A%A1/">《Python-gRPC实践(3)–使用Python实现gRPC服务》</a>介绍的实现<code>gRPC</code>服务中使用了一套自定义的协议来传递错误，但这并不是一个优雅的解决方案，因为这种方案的兼容性很差，好在官方定义了一种解决方案，通过这种方案可以使不同的服务都能传递错误。</p><h2 id="1-自定义的错误传递"><a href="#1-自定义的错误传递" class="headerlink" title="1.自定义的错误传递"></a>1.自定义的错误传递</h2><p>在编写普通的HTTP/1.1接口时，我们都会定制一套业务相关的错误来与HTTP标注的错误区分开，比如通常都会返回这样一个结构体：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>    <span class="hljs-attr">&quot;code&quot;</span>: <span class="hljs-string">&quot;0&quot;</span>,<br>    <span class="hljs-attr">&quot;msg&quot;</span>: <span class="hljs-string">&quot;success&quot;</span>,<br>    <span class="hljs-attr">&quot;data&quot;</span>: &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个结构体包含了<code>code</code>,<code>msg</code>和<code>data</code>三个字段，他们分别是错误码，错误信息，和要返回的结构。<br>客户端在收到响应后，会判断<code>code</code>的值是什么，如果属于定义的成功状态码则通过<code>data</code>提取数据，否则把<code>msg</code>信息通过异常抛出来。</p><p>在使用<code>gRPC</code>中更不例外，因为我们在使用<code>gRPC</code>调用时，就像调用一个普通函数一样，不过<code>gRPC</code>服务间是通过传递message数据来进行交互的，每个调用的请求message和响应message都已经被固定了，如果我们想返回一个错误信息，那么必定会跟响应结构体不一样，所以错误的信息的结构体一定要跟响应体匹配，否则只能另寻它路，比如在每个响应体嵌入错误信息的字段，如下:</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs protobuf"><span class="hljs-class"><span class="hljs-keyword">message</span> <span class="hljs-title">Demo</span> </span>&#123;<br>    <span class="hljs-built_in">string</span> a=<span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">int32</span> b=<span class="hljs-number">2</span>;<br><br>    <span class="hljs-built_in">int32</span> err_code=<span class="hljs-number">3</span>;<br>    <span class="hljs-built_in">string</span> err_msg=<span class="hljs-number">4</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后服务端判断调用执行出错就把错误转换为对应的<code>err_code</code>和<code>err_msg</code>再塞入到message中传给客户端，而客户端每收到调用响应就判断<code>err_code</code>是否有值，有则代表是异常请求，只把<code>err_code</code>和<code>err_msg</code>提取出来生成一个异常并抛给调用者，否则就正常返回数据。</p><p>采用这种方法可以兼容每一种调用，但是并不是十分的优雅，如果能通过别的协议容器把数据传给客户端，客户端通过对应的协议解析到错误信息并生产异常就好，在之前介绍的<code>gRPC</code>服务中，就是采用<code>gRPC.metadata</code>来传输数据。同时为了能自动处理服务端异常的捕获和客户端的异常生成，会分别在客户端和服务端设置一个顶层的拦截器，服务端的顶层拦截器代码如下(因为其它的拦截器可能会抛错，所以捕获错误的拦截器一定要放置在最顶层)：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-comment"># code url: https://github.com/so1n/grpc-example-common/blob/v0.1.5/grpc_example_common/interceptor/server_interceptor/customer_top.py</span><br><span class="hljs-keyword">import</span> logging<br><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> Any, Callable, List, Tuple<br><br><span class="hljs-keyword">import</span> grpc<br><br><span class="hljs-keyword">from</span> grpc_example_common.helper.context <span class="hljs-keyword">import</span> context_proxy<br><br><span class="hljs-keyword">from</span> .base <span class="hljs-keyword">import</span> BaseInterceptor<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomerTopInterceptor</span>(<span class="hljs-params">BaseInterceptor</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">intercept</span>(<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">        self,</span></span><br><span class="hljs-function"><span class="hljs-params">        next_handler_method: Callable,</span></span><br><span class="hljs-function"><span class="hljs-params">        request_proto_message: Any,</span></span><br><span class="hljs-function"><span class="hljs-params">        context: grpc.ServicerContext,</span></span><br><span class="hljs-function"><span class="hljs-params">    </span>) -&gt; Any:</span><br>        return_initial_metadata: List[Tuple] = [(<span class="hljs-string">&quot;customer-user-agent&quot;</span>, <span class="hljs-string">&quot;Python3&quot;</span>)]<br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-comment"># 执行gRPC的调用</span><br>            <span class="hljs-keyword">return</span> next_handler_method(request_proto_message, context)<br>        <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>            <span class="hljs-comment"># 限定客户端带有如下Key-Value的才设置错误信息</span><br>            <span class="hljs-keyword">if</span> self.metadata_dict.get(<span class="hljs-string">&quot;customer-user-agent&quot;</span>, <span class="hljs-string">&quot;&quot;</span>) == <span class="hljs-string">&quot;Python3&quot;</span>:<br>                return_initial_metadata.append((<span class="hljs-string">&quot;exc_name&quot;</span>, e.__class__.__name__))<br>                return_initial_metadata.append((<span class="hljs-string">&quot;exc_info&quot;</span>, <span class="hljs-built_in">str</span>(e)))<br>            <span class="hljs-comment"># 抛出异常，这样gRPC服务端就能捕获到对应的异常，方便服务端进行后续的处理</span><br>            <span class="hljs-keyword">raise</span> e<br>        <span class="hljs-keyword">finally</span>:<br>            <span class="hljs-comment"># 发送结束metadata流到客户端</span><br>            context.send_initial_metadata(return_initial_metadata)<br></code></pre></td></tr></table></figure><p>该拦截器会捕获调用的异常，然后把异常的方法名和异常信息存在metedata中，这里之所以把值设置到metadata中，而不通过<code>context.set_code</code>,<code>context.set_details</code>来设置错误码和错误信息是有原因的。</p><p>首先是<code>code</code>，<code>gRPC</code>限制了只能设置它允许的<code>code</code>，所以这会限制我们去自定义<code>code</code>，同时我们也不应该把业务的错误码设置到响应的错误码中，所以不在这里使用<code>context.set_code</code>；而对于<code>set_details</code>,则是因为<code>gRPC</code>服务端在捕获到异常后会解析对应的异常，然后把异常数据通过<code>context.set_details</code>设置到<code>details</code>中，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_call_behavior</span>(<span class="hljs-params">rpc_event,</span></span><br><span class="hljs-function"><span class="hljs-params">                   state,</span></span><br><span class="hljs-function"><span class="hljs-params">                   behavior,</span></span><br><span class="hljs-function"><span class="hljs-params">                   argument,</span></span><br><span class="hljs-function"><span class="hljs-params">                   request_deserializer,</span></span><br><span class="hljs-function"><span class="hljs-params">                   send_response_callback=<span class="hljs-literal">None</span></span>):</span><br>    <span class="hljs-keyword">from</span> grpc <span class="hljs-keyword">import</span> _create_servicer_context<br>    <span class="hljs-keyword">with</span> _create_servicer_context(rpc_event, state,<br>                                  request_deserializer) <span class="hljs-keyword">as</span> context:<br>        <span class="hljs-keyword">try</span>:<br>            response_or_iterator = <span class="hljs-literal">None</span><br>            <span class="hljs-comment"># 调用请求</span><br>            <span class="hljs-keyword">if</span> send_response_callback <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>                response_or_iterator = behavior(argument, context,<br>                                                send_response_callback)<br>            <span class="hljs-keyword">else</span>:<br>                response_or_iterator = behavior(argument, context)<br>            <span class="hljs-keyword">return</span> response_or_iterator, <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> exception:  <span class="hljs-comment"># pylint: disable=broad-except</span><br>            <span class="hljs-keyword">with</span> state.condition:<br>                <span class="hljs-keyword">if</span> state.aborted:<br>                    _abort(state, rpc_event.call, cygrpc.StatusCode.unknown,<br>                           <span class="hljs-string">b&#x27;RPC Aborted&#x27;</span>)<br>                <span class="hljs-keyword">elif</span> exception <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> state.rpc_errors:<br>                    <span class="hljs-comment"># 这里判断并不属于grpc的错误，则会把错误信息设置到details</span><br>                    details = <span class="hljs-string">&#x27;Exception calling application: &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(<br>                        exception)<br>                    _LOGGER.exception(details)<br>                    _abort(state, rpc_event.call, cygrpc.StatusCode.unknown,<br>                           _common.encode(details))<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>, <span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><p>这就意味着我们即使在拦截器设置了<code>details</code>，但是由于抛出来的异常并不属于<code>gRPC</code>的异常，所以<code>details</code>最终被异常信息覆盖了。</p><p>了解完了服务端的拦截器实现，接下来看看客户端的拦截器实现，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># code url: https://github.com/so1n/grpc-example-common/blob/v0.1.5/grpc_example_common/interceptor/client_interceptor/customer_top.py</span><br><span class="hljs-keyword">import</span> inspect<br><span class="hljs-keyword">import</span> logging<br><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> Any, Callable, Dict, List, Optional, Type<br><br><br><span class="hljs-keyword">from</span> .base <span class="hljs-keyword">import</span> GRPC_RESPONSE, BaseInterceptor, ClientCallDetailsType<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomerTopInterceptor</span>(<span class="hljs-params">BaseInterceptor</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, exc_list: Optional[List[Type[Exception]]] = <span class="hljs-literal">None</span></span>):</span><br>        self.exc_dict: Dict[<span class="hljs-built_in">str</span>, Type[Exception]] = &#123;&#125;<br>        <span class="hljs-keyword">for</span> key, exc <span class="hljs-keyword">in</span> <span class="hljs-built_in">globals</span>()[<span class="hljs-string">&quot;__builtins__&quot;</span>].items():<br>            <span class="hljs-comment"># 注册Python自带的异常</span><br>            <span class="hljs-keyword">if</span> inspect.isclass(exc) <span class="hljs-keyword">and</span> <span class="hljs-built_in">issubclass</span>(exc, Exception):<br>                self.exc_dict[key] = exc<br><br>        <span class="hljs-keyword">if</span> exc_list:<br>            <span class="hljs-comment"># 注册用户指定的异常</span><br>            <span class="hljs-keyword">for</span> exc <span class="hljs-keyword">in</span> exc_list:<br>                <span class="hljs-keyword">if</span> <span class="hljs-built_in">issubclass</span>(exc, Exception):<br>                    self.exc_dict[exc.__name__] = exc<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">intercept</span>(<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">        self,</span></span><br><span class="hljs-function"><span class="hljs-params">        method: Callable,</span></span><br><span class="hljs-function"><span class="hljs-params">        request_or_iterator: Any,</span></span><br><span class="hljs-function"><span class="hljs-params">        call_details: ClientCallDetailsType,</span></span><br><span class="hljs-function"><span class="hljs-params">    </span>) -&gt; GRPC_RESPONSE:</span><br>        <span class="hljs-keyword">if</span> call_details.metadata <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-comment"># 添加协定的信息 </span><br>            call_details.metadata.append((<span class="hljs-string">&quot;customer-user-agent&quot;</span>, <span class="hljs-string">&quot;Python3&quot;</span>))  <span class="hljs-comment"># type: ignore</span><br>        response: GRPC_RESPONSE = method(call_details, request_or_iterator)<br>        metadata_dict: <span class="hljs-built_in">dict</span> = &#123;item.key: item.value <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> response.initial_metadata()&#125;<br>        <span class="hljs-keyword">if</span> metadata_dict.get(<span class="hljs-string">&quot;customer-user-agent&quot;</span>) == <span class="hljs-string">&quot;Python3&quot;</span>:<br>            <span class="hljs-comment"># 提取异常信息</span><br>            exc_name: <span class="hljs-built_in">str</span> = metadata_dict.get(<span class="hljs-string">&quot;exc_name&quot;</span>, <span class="hljs-string">&quot;&quot;</span>)<br>            exc_info: <span class="hljs-built_in">str</span> = metadata_dict.get(<span class="hljs-string">&quot;exc_info&quot;</span>, <span class="hljs-string">&quot;&quot;</span>)<br>            <span class="hljs-comment"># 通过exc_name查找异常</span><br>            exc: Optional[Type[Exception]] = self.exc_dict.get(exc_name)<br>            <span class="hljs-keyword">if</span> exc:<br>                <span class="hljs-comment"># 抛出异常</span><br>                <span class="hljs-keyword">raise</span> exc(exc_info)<br>        <span class="hljs-keyword">return</span> response<br></code></pre></td></tr></table></figure><p>可以看出客户端拦截器通过获取服务端返回的metada来判断是否有异常信息，如果有就提取出并抛出错误，否则就正常返回响应。这样一来只要客户端服务端都设置了正确的拦截器，客户端就能获得到服务端的错误信息并抛出异常，不过这种实现方式是依赖<code>gRPC.metadata</code>传输数据的，而<code>gRPC.metadata</code>的值必须是ASCII或者规范的字节，不然就不给传输甚至还会卡住请求，这就意味着我们需要对错误信息进行一些序列化。</p><h2 id="2-基于官方协定的错误传输实现"><a href="#2-基于官方协定的错误传输实现" class="headerlink" title="2.基于官方协定的错误传输实现"></a>2.基于官方协定的错误传输实现</h2><p>由于上面的实现不是很优雅，于是就上网冲浪寻找一个官方的实现，后面终于在<code>Github</code>中找到了<a href="https://github.com/grpc/grpc/tree/master/examples/python/errors">官方的错误传输示例</a>，其中官方的服务端示例代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">create_greet_limit_exceed_error_status</span>(<span class="hljs-params">name</span>):</span><br>    <span class="hljs-comment"># 创建一个Message对象</span><br>    detail = any_pb2.Any()<br>    <span class="hljs-comment"># 把一个自定义的错误转为一个Any的对象，这样收发消息时就不会出现校验不通过的情况了</span><br>    detail.Pack(<br>        error_details_pb2.QuotaFailure(violations=[<br>            error_details_pb2.QuotaFailure.Violation(<br>                subject=<span class="hljs-string">&quot;name: %s&quot;</span> % name,<br>                description=<span class="hljs-string">&quot;Limit one greeting per person&quot;</span>,<br>            )<br>        ],))<br>    <span class="hljs-comment"># 生成一个Status对象，这个对象包括了code,message,details三个字段</span><br>    <span class="hljs-keyword">return</span> status_pb2.Status(<br>        code=code_pb2.RESOURCE_EXHAUSTED,<br>        message=<span class="hljs-string">&#x27;Request limit exceeded.&#x27;</span>,<br>        <span class="hljs-comment"># 错误对象数组</span><br>        details=[detail],<br>    )<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LimitedGreeter</span>(<span class="hljs-params">helloworld_pb2_grpc.GreeterServicer</span>):</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        self._lock = threading.RLock()<br>        self._greeted = <span class="hljs-built_in">set</span>()<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">SayHello</span>(<span class="hljs-params">self, request, context</span>):</span><br>        <span class="hljs-comment"># 对应的gRPC调用</span><br>        <span class="hljs-keyword">with</span> self._lock:<br>            <span class="hljs-keyword">if</span> request.name <span class="hljs-keyword">in</span> self._greeted:<br>                rich_status = create_greet_limit_exceed_error_status(<br>                    request.name)<br>                context.abort_with_status(rpc_status.to_status(rich_status))<br>            <span class="hljs-keyword">else</span>:<br>                self._greeted.add(request.name)<br>        <span class="hljs-keyword">return</span> helloworld_pb2.HelloReply(message=<span class="hljs-string">&#x27;Hello, %s!&#x27;</span> % request.name)<br></code></pre></td></tr></table></figure><p>该示例代码中的<code>SayHello</code>方法逻辑非常简单，它判断如果<code>name</code>不存在，就把<code>name</code>添加到集合中，并正常返回，如果已经存在，则先生成一个<code>Status</code>对象，再通过<code>to_status</code>方法生成 一个<code>_Status</code>对象， 最后通过<code>abort_with_stauts</code>方法把<code>_Status</code>对象传进去，这样就把错误数据传输到了客户端。</p><p>其中<code>abort_with_stauts</code>方法会使请求引发异常并以非正常状态终止，再把用户指定的<code>Status</code>对象传给客户端，而<code>to_status</code>的源码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">to_status</span>(<span class="hljs-params">status</span>):</span><br>    <span class="hljs-keyword">return</span> _Status(code=code_to_grpc_status_code(status.code),<br>                   details=status.message,<br>                   trailing_metadata=((GRPC_DETAILS_METADATA_KEY,<br>                                       status.SerializeToString()),))<br></code></pre></td></tr></table></figure><p>通过源码可以看出这个函数就是把<code>status.code</code>转为<code>gRPC</code>响应的<code>code</code>，把<code>status.message</code>转为<code>gRPC</code>的<code>details</code>，最后把<code>status</code>转为合法的字符串，并通过<code>GRPC_DETAILS_METADATA_KEY</code>把字符串设置到metadata中。</p><p>而对于客户端则比较简单，源码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">process</span>(<span class="hljs-params">stub</span>):</span><br>    <span class="hljs-keyword">try</span>:<br>        response = stub.SayHello(helloworld_pb2.HelloRequest(name=<span class="hljs-string">&#x27;Alice&#x27;</span>))<br>        _LOGGER.info(<span class="hljs-string">&#x27;Call success: %s&#x27;</span>, response.message)<br>    <span class="hljs-keyword">except</span> grpc.RpcError <span class="hljs-keyword">as</span> rpc_error:<br>        _LOGGER.error(<span class="hljs-string">&#x27;Call failure: %s&#x27;</span>, rpc_error)<br>        <span class="hljs-comment"># 通过`grpc.RpcError`提取Status对象</span><br>        status = rpc_status.from_call(rpc_error)<br>        <span class="hljs-keyword">for</span> detail <span class="hljs-keyword">in</span> status.details:<br>            <span class="hljs-comment"># 读取detail里面的对象，并判断是不是对应的message，如果是则打印一条错误日志，如果不是则抛错</span><br>            <span class="hljs-keyword">if</span> detail.Is(error_details_pb2.QuotaFailure.DESCRIPTOR):<br>                info = error_details_pb2.QuotaFailure()<br>                detail.Unpack(info)<br>                _LOGGER.error(<span class="hljs-string">&#x27;Quota failure: %s&#x27;</span>, info)<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">raise</span> RuntimeError(<span class="hljs-string">&#x27;Unexpected failure: %s&#x27;</span> % detail)<br></code></pre></td></tr></table></figure><p>这段代码中，如果是正常响应，则打印响应体，而如果是异常，客户端会发现响应体的<code>code</code>并不是正常的状态码，所以会抛出一个<code>grpc.RpcError</code>异常，然后通过<code>rpc_status.from_call</code>函数提取异常, 这个函数的逻辑非常简单，源码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">from_call</span>(<span class="hljs-params">call</span>):</span><br>    <span class="hljs-comment"># 如果没有metadata数据就直接返回空</span><br>    <span class="hljs-keyword">if</span> call.trailing_metadata() <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>    <span class="hljs-comment"># 有数据就遍历数据</span><br>    <span class="hljs-keyword">for</span> key, value <span class="hljs-keyword">in</span> call.trailing_metadata():<br>        <span class="hljs-comment"># 如果Key为官方指定的Key，就进入提取数据逻辑</span><br>        <span class="hljs-keyword">if</span> key == GRPC_DETAILS_METADATA_KEY:<br>            <span class="hljs-comment"># 把数据反序列化成一个message对象</span><br>            rich_status = status_pb2.Status.FromString(value)<br>            <span class="hljs-comment"># 校验对象数据是否跟响应体一样</span><br>            <span class="hljs-keyword">if</span> call.code().value[<span class="hljs-number">0</span>] != rich_status.code:<br>                <span class="hljs-keyword">raise</span> ValueError(<br>                    <span class="hljs-string">&#x27;Code in Status proto (%s) doesn\&#x27;t match status code (%s)&#x27;</span><br>                    % (code_to_grpc_status_code(rich_status.code), call.code()))<br>            <span class="hljs-keyword">if</span> call.details() != rich_status.message:<br>                <span class="hljs-keyword">raise</span> ValueError(<br>                    <span class="hljs-string">&#x27;Message in Status proto (%s) doesn\&#x27;t match status details (%s)&#x27;</span><br>                    % (rich_status.message, call.details()))<br>            <span class="hljs-keyword">return</span> rich_status<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br></code></pre></td></tr></table></figure><p>通过源码看出这个逻辑和自定义的错误传递一样，也是通过<code>metadata</code>提取数据然后拼成一个异常对象。不过，需要注意的是<code>from_call</code>的<code>call</code>参数不仅支持<code>grpc.RpcError</code>，它还支持客户端拦截器中得到的<code>response</code>对象，因为<code>call</code>参数在<code>form_call</code>中用到了<code>trailing_metadata</code>，<code>code</code>和<code>details</code>方法都是<code>grpc.RpcError</code>和<code>response</code>对象共同拥有的方法。</p><p>在简单的了解了<code>gRPC</code>的错误传递示例后可以发现，官方的方法与自定义的错误传递很类似，只不过它定义了一个规范的Key，这样一来大家都会认为这个Key对应的值是一个<code>Status</code>对象的序列化成的字符串（由于序列化了，就不用担心存在非ASCII字符的问题）。而这个<code>Status</code>对象中包含了<code>code</code>,<code>message</code>和<code>detail</code>三个字段，分别对应着上面所说的错误结构体:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>    <span class="hljs-attr">&quot;code&quot;</span>: <span class="hljs-string">&quot;0&quot;</span>,<br>    <span class="hljs-attr">&quot;msg&quot;</span>: <span class="hljs-string">&quot;success&quot;</span>,<br>    <span class="hljs-attr">&quot;data&quot;</span>: &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>中的<code>code</code>,<code>msg</code>和<code>data</code>，不过需要注意的是<code>detail</code>是一个数组，它可以存放多个自定义的<code>Message</code>对象。</p><h2 id="3-重新设计错误传递实现"><a href="#3-重新设计错误传递实现" class="headerlink" title="3.重新设计错误传递实现"></a>3.重新设计错误传递实现</h2><p>通过官方的错误传输实现可以发现，这个例子需要服务端的业务逻辑主动通过<code>context.abort_with_status</code>逻辑来主动把错误信息设置到<code>metadata</code>中，同时也需要客户端捕获<code>grpc.RpcError</code>异常再打印出来，这样对业务层来说是非常啰嗦的，于是就尝试把官方协定的错误传输实现与自定义的错误传递结合起来。</p><p>首先是定义一个内部统一的<code>message</code>：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs protobuf"><span class="hljs-class"><span class="hljs-keyword">message</span> <span class="hljs-title">Exec</span></span>&#123;<br>  <span class="hljs-built_in">string</span> name = <span class="hljs-number">1</span>; <span class="hljs-comment">// 异常名</span><br>  <span class="hljs-built_in">string</span> msg = <span class="hljs-number">2</span>;  <span class="hljs-comment">// 异常信息</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这个Message只用于内部业务服务，如果该服务端有开发给其它部门使用，且他们没有兼容这个<code>message</code>，他们也可以通过<code>code</code>和<code>detail</code>知道大概是什么样的错误。</p><p>然后就开始折腾服务端的顶层拦截器，这个拦截器只要改造捕获异常部分的代码即可，源码如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-comment"># code url: https://github.com/so1n/grpc-example-common/blob/v0.1.7/grpc_example_common/interceptor/server_interceptor/customer_top.py</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomerTopInterceptor</span>(<span class="hljs-params">BaseInterceptor</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">intercept</span>(<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">        self,</span></span><br><span class="hljs-function"><span class="hljs-params">        next_handler_method: Callable,</span></span><br><span class="hljs-function"><span class="hljs-params">        request_proto_message: Any,</span></span><br><span class="hljs-function"><span class="hljs-params">        context: grpc.ServicerContext,</span></span><br><span class="hljs-function"><span class="hljs-params">    </span>) -&gt; Any:</span><br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-comment"># 服务调用</span><br>            <span class="hljs-keyword">return</span> next_handler_method(request_proto_message, context)<br>        <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>            <span class="hljs-comment"># 创建一个Message对象</span><br>            detail = any_pb2.Any()<br>            <span class="hljs-comment"># 把一个自定义的错误转为一个Any的对象，这样收发消息时就不会出现校验不通过的情况了</span><br>            <span class="hljs-comment"># 需要注意的是，这里是我们自己定义的message.Exec</span><br>            detail.Pack(<br>                Exec(<br>                    name=e.__class__.__name__,<br>                    msg=<span class="hljs-built_in">str</span>(e)<br>                )<br>            )<br>            <span class="hljs-comment"># 通过abort_with_status把数据通过metadata传给客户端</span><br>            context.abort_with_status(<br>                rpc_status.to_status(<br>                    status_pb2.Status(<br>                        code=code_pb2.RESOURCE_EXHAUSTED,  <span class="hljs-comment"># 这里只允许填写gRPC的错误码，就像我们定义了业务的错误码为2001，但是HTTP的状态码还是200一样</span><br>                        message=<span class="hljs-built_in">str</span>(e),<br>                        details=[detail], <span class="hljs-comment"># 这里是一个数组，所以这里可以定义多套异常的对象去兼容不同的系统，不过在内部调用中尽量统一只有一套方法</span><br>                    )<br>                )<br>            )<br>            <span class="hljs-comment"># 抛出异常，不过gRPC服务端判断该调用已经被标记为abort，不会继续处理</span><br>            <span class="hljs-comment"># 但是对于其它的功能却是有用的，比如opentelemetry的官方实现是在channel外再套用一个channel，所以它需要捕获异常并生成对应的Event</span><br>            <span class="hljs-keyword">raise</span> e<br></code></pre></td></tr></table></figure><p>接着就折腾客户端的顶层拦截器，同样的它只需要改一下数据的获取就可以了，源码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-comment"># code url: https://github.com/so1n/grpc-example-common/blob/v0.1.7/grpc_example_common/interceptor/client_interceptor/customer_top.py</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomerTopInterceptor</span>(<span class="hljs-params">BaseInterceptor</span>):</span><br><br>    <span class="hljs-comment"># 注册异常的带按摩略</span><br>    ...<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">intercept</span>(<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">        self,</span></span><br><span class="hljs-function"><span class="hljs-params">        method: Callable,</span></span><br><span class="hljs-function"><span class="hljs-params">        request_or_iterator: Any,</span></span><br><span class="hljs-function"><span class="hljs-params">        call_details: ClientCallDetailsType,</span></span><br><span class="hljs-function"><span class="hljs-params">    </span>) -&gt; GRPC_RESPONSE:</span><br>        response: GRPC_RESPONSE = method(call_details, request_or_iterator)<br>        <span class="hljs-comment"># 前面说到`from_call`也支持客户端拦截器里通过`method`方法得到的response对象</span><br>        status: Optional[status_pb2.Status] = rpc_status.from_call(response)<br>        <span class="hljs-comment"># 如果不为None,则证明得到了异常数据</span><br>        <span class="hljs-keyword">if</span> status:<br>            <span class="hljs-keyword">for</span> detail <span class="hljs-keyword">in</span> status.details:<br>                <span class="hljs-comment"># 判断这个detail是不是我们要的Message</span><br>                <span class="hljs-keyword">if</span> detail.Is(Exec.DESCRIPTOR):<br>                    <span class="hljs-comment"># 通过反序列化获取数据</span><br>                    exec_instance: Exec = Exec()<br>                    detail.Unpack(exec_instance)<br>                    <span class="hljs-comment"># 生成异常并抛出</span><br>                    exec_class: Type[Exception] = self.exc_dict.get(exec_instance.name) <span class="hljs-keyword">or</span> RuntimeError<br>                    <span class="hljs-keyword">raise</span> exec_class(exec_instance.msg)<br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-keyword">raise</span> RuntimeError(<span class="hljs-string">&#x27;Unexpected failure: %s&#x27;</span> % detail)<br>        <span class="hljs-keyword">return</span> response<br></code></pre></td></tr></table></figure><p>这样一来，新的错误传递实现已经完成了，现在通过一个简单的demo来验证成果，demo代码如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-comment"># grpc_example_common url:https://github.com/so1n/grpc-example-common/tree/v0.1.7</span><br><span class="hljs-comment"># 服务端代码</span><br><span class="hljs-keyword">from</span> concurrent <span class="hljs-keyword">import</span> futures<br><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> List<br><br><span class="hljs-keyword">import</span> grpc<br><span class="hljs-keyword">from</span> grpc_example_common.interceptor.server_interceptor.base <span class="hljs-keyword">import</span> BaseInterceptor<br><span class="hljs-keyword">from</span> google.protobuf.empty_pb2 <span class="hljs-keyword">import</span> Empty  <span class="hljs-comment"># type: ignore</span><br><span class="hljs-keyword">from</span> grpc_example_common.protos.user <span class="hljs-keyword">import</span> user_pb2 <span class="hljs-keyword">as</span> user_message<br><span class="hljs-keyword">from</span> grpc_example_common.interceptor.server_interceptor.customer_top <span class="hljs-keyword">import</span> CustomerTopInterceptor<br><br><span class="hljs-keyword">from</span> grpc_example_common.protos.user <span class="hljs-keyword">import</span> user_pb2_grpc <span class="hljs-keyword">as</span> user_service<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserService</span>(<span class="hljs-params">user_service.UserServicer</span>):</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">delete_user</span>(<span class="hljs-params">self, request: user_message.DeleteUserRequest,</span></span><br><span class="hljs-function"><span class="hljs-params">                    context: grpc.ServicerContext</span>) -&gt; Empty:</span><br>        uid: <span class="hljs-built_in">str</span> = request.uid<br>        <span class="hljs-keyword">if</span> uid == <span class="hljs-string">&quot;123&quot;</span>:<br>            <span class="hljs-keyword">return</span> Empty()<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">f&quot;Not found user:<span class="hljs-subst">&#123;uid&#125;</span>&quot;</span>)<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>(<span class="hljs-params">host: <span class="hljs-built_in">str</span> = <span class="hljs-string">&quot;127.0.0.1&quot;</span>, port: <span class="hljs-built_in">str</span> = <span class="hljs-string">&quot;9000&quot;</span></span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>    interceptor_list: List[BaseInterceptor] = [CustomerTopInterceptor()]<br>    server: grpc.server = grpc.server(<br>        futures.ThreadPoolExecutor(max_workers=<span class="hljs-number">10</span>),<br>        interceptors=interceptor_list,<br>    )<br>    user_service.add_UserServicer_to_server(UserService(), server)<br>    server.add_insecure_port(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;host&#125;</span>:<span class="hljs-subst">&#123;port&#125;</span>&quot;</span>)<br>    server.start()<br>    <span class="hljs-keyword">try</span>:<br>        server.wait_for_termination()<br>    <span class="hljs-keyword">except</span> KeyboardInterrupt:<br>        server.stop(<span class="hljs-number">0</span>)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    main()<br><br><span class="hljs-comment"># 客户端代码</span><br><span class="hljs-keyword">import</span> grpc<br><span class="hljs-keyword">from</span> grpc_example_common.protos.user <span class="hljs-keyword">import</span> user_pb2 <span class="hljs-keyword">as</span> user_message<br><span class="hljs-keyword">from</span> grpc_example_common.protos.user <span class="hljs-keyword">import</span> user_pb2_grpc <span class="hljs-keyword">as</span> user_service<br><span class="hljs-keyword">from</span> grpc_example_common.interceptor.client_interceptor.customer_top <span class="hljs-keyword">import</span> CustomerTopInterceptor<br><br>channel: grpc.Channel = grpc.intercept_channel(<br>    grpc.insecure_channel(<span class="hljs-string">&quot;127.0.0.1:9000&quot;</span>), CustomerTopInterceptor()<br>)<br>user_stub: user_service.UserStub = user_service.UserStub(channel)<br>user_stub.delete_user(user_message.DeleteUserRequest(uid=<span class="hljs-string">&quot;123&quot;</span>))<br>user_stub.delete_user(user_message.DeleteUserRequest(uid=<span class="hljs-string">&quot;456&quot;</span>))<br></code></pre></td></tr></table></figure><p>编写完demo后开始运行，运行后客户端抛出如下错误信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">Traceback (most recent call last):<br>  File <span class="hljs-string">&quot;/home/so1n/github/grpc-example-project/grpc-example-api-backend-service/demo.py&quot;</span>, line 11, <span class="hljs-keyword">in</span> &lt;module&gt;<br>    user_stub.delete_user(user_message.DeleteUserRequest(uid=<span class="hljs-string">&quot;456&quot;</span>))<br>  File <span class="hljs-string">&quot;/home/so1n/github/grpc-example-project/grpc-example-api-backend-service/.venv/lib/python3.8/site-packages/grpc/_interceptor.py&quot;</span>, line 216, <span class="hljs-keyword">in</span> __call__<br>    response, ignored_call = self._with_call(request,<br>  File <span class="hljs-string">&quot;/home/so1n/github/grpc-example-project/grpc-example-api-backend-service/.venv/lib/python3.8/site-packages/grpc/_interceptor.py&quot;</span>, line 254, <span class="hljs-keyword">in</span> _with_call<br>    call = self._interceptor.intercept_unary_unary(continuation,<br>  File <span class="hljs-string">&quot;/home/so1n/github/grpc-example-project/grpc-example-api-backend-service/.venv/lib/python3.8/site-packages/grpc_example_common/interceptor/client_interceptor/base.py&quot;</span>, line 74, <span class="hljs-keyword">in</span> intercept_unary_unary<br>    <span class="hljs-built_in">return</span> self.intercept(continuation, request, call_details)<br>  File <span class="hljs-string">&quot;/home/so1n/github/grpc-example-project/grpc-example-api-backend-service/.venv/lib/python3.8/site-packages/grpc_example_common/interceptor/client_interceptor/customer_top.py&quot;</span>, line 44, <span class="hljs-keyword">in</span> intercept<br>    raise exec_class(exec_instance.msg)<br>ValueError: Not found user:456<br></code></pre></td></tr></table></figure><p>通过信息可以发现，重新设计的错误传递实现完美运行。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;之前在文章&lt;a href=&quot;https://so1n.me/2022/04/07/Python-gRPC%E5%AE%9E%E8%B7%B5</summary>
      
    
    
    <content src="https://ftp.bmp.ovh/imgs/2022/02/bd67e15aa8d46101.png" type="image"/>
    
    
    <category term="Python-gRPC实践" scheme="http://so1n.me/categories/Python-gRPC%E5%AE%9E%E8%B7%B5/"/>
    
    
    <category term="Python" scheme="http://so1n.me/tags/Python/"/>
    
    <category term="gRPC" scheme="http://so1n.me/tags/gRPC/"/>
    
  </entry>
  
  <entry>
    <title>Python 3.11 Asyncio新增的两个高级类</title>
    <link href="http://so1n.me/2022/06/13/two_functional_implementations_based_on_asyncio.Task_extensions/"/>
    <id>http://so1n.me/2022/06/13/two_functional_implementations_based_on_asyncio.Task_extensions/</id>
    <published>2022-06-13T15:33:18.000Z</published>
    <updated>2022-06-24T14:40:56.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前记"><a href="#前记" class="headerlink" title="前记"></a>前记</h2><p><code>Python Asyncio</code>提供了很多基础的API以及对应的对象，如果只用于编写简单的HTTP API处理函数，那么这些<code>Python Asyncio</code>是足够的，但在面对一些复杂点多的需求或者编写网络相关框架时，就需要基于<code>Python Asyncio</code>的基础API封装成高级对象。目前比较常用的高级对象有两个，一个是用于管理代码域超时的<code>timeout</code>以及一个用于结构化并发的<code>TaskGroup</code>，它们最先出现在<a href="https://github.com/python-trio/trio">Trio</a>这个协程库中，后来<a href="https://github.com/agronholm/anyio">Anyio</a>库也支持这两个对象，现在，准备发布Python 3.11中<code>Asyncio</code>库也包括这两个功能。</p><span id="more"></span><blockquote><p>注： 正常情况下，调用经过封装的高级对象的耗时肯定会大于直接调用基础API的耗时，但是高级对象能使代码结构更加优美。比如<code>starlette</code>框架在集成<code>anyio</code>后，性能降低了4.5%，具体见:<a href="https://github.com/encode/starlette/pull/1157">https://github.com/encode/starlette/pull/1157</a></p></blockquote><h2 id="1-人性化的超时"><a href="#1-人性化的超时" class="headerlink" title="1.人性化的超时"></a>1.人性化的超时</h2><p>通常情况下，我们的代码调用结果只有成功或者是失败，但是对于客户端的网络调用来说还存在另外一种情况，就是网络调用可能会永远挂起，不会响应成功或者失败，然后就一直占用着文件描述符等系统资源。所以大多数的客户端都会实现超时机制来解决这个问题，但是客户端支持的超时API都是只针对自己的对应调用，比如<code>httpx</code>这个库，它的对应调用如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-comment"># 使用get方法请求， 超时时间为9秒</span><br><span class="hljs-keyword">import</span> asyncio<br><span class="hljs-keyword">import</span> httpx<br><br>asyncio.run(httpx.AsyncClient().get(url=<span class="hljs-string">&quot;http://so1n.me&quot;</span>, timeout=<span class="hljs-number">9</span>))<br></code></pre></td></tr></table></figure><p>这个调用会请求到<code>http://so1n.me</code>，然后等待响应，如果该网站超过9秒仍未返回响应或者由于网络原因导致该调用没有返回响应，那么就会抛出一个超时错误。<br>这种设计的非常OK的，使用起来非常简单，但如果现在要求的更改为在9秒内请求两次<code>http://so1n.me</code>后还按照上面的写法，就会变得很糟糕，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> asyncio<br><span class="hljs-keyword">import</span> httpx<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">demo</span>() -&gt; <span class="hljs-keyword">None</span>:</span><br>    <span class="hljs-keyword">await</span> httpx.AsyncClient().get(url=<span class="hljs-string">&quot;http://so1n.me&quot;</span>, timeout=<span class="hljs-number">9</span>)<br>    <span class="hljs-keyword">await</span> httpx.AsyncClient().get(url=<span class="hljs-string">&quot;http://so1n.me&quot;</span>, timeout=<span class="hljs-number">9</span>)<br></code></pre></td></tr></table></figure><p>这种情况下假设该方法的每个请求时长为8秒， 那么他的总请求时长为16秒， 已经超出总的超时时长为9秒的要求的, 但每个请求都没有触发超时机制，所以并不会抛出异常。<br>不过这时我们可以换个思路， 因为超时的原本意思是在n秒后中断此次请求, 也就是在某个时刻时终止请求， 那么我们只要在调用时计算出距离超时时刻还有多少时间差，并设置到timeout参数中，就可以使<code>demo</code>调用符合我们的要求了，代码改写后如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> asyncio<br><span class="hljs-keyword">import</span> httpx<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">demo</span>(<span class="hljs-params">timeout: <span class="hljs-built_in">int</span> = <span class="hljs-number">9</span></span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>    deadline: <span class="hljs-built_in">float</span> = time.time() + <span class="hljs-number">9</span><br>    <span class="hljs-keyword">await</span> httpx.AsyncClient().get(url=<span class="hljs-string">&quot;http://so1n.me&quot;</span>, timeout=time.time() - deadline)<br>    <span class="hljs-keyword">await</span> httpx.AsyncClient().get(url=<span class="hljs-string">&quot;http://so1n.me&quot;</span>, timeout=time.time() - deadline)<br></code></pre></td></tr></table></figure><p>这段代码可以完美的工作， 假设第一个请求的时长为5秒， 那么第二次请求的超时参数的值会是4秒， 这是非常ok， 代码也依然保持简单。 不过目前还是有个缺点， 就是每次都计算一次超时时间， 然后再显示传进去, 这个超时是不可传递的， 如果有一个抽象能方便的使用， 那是非常好的，比如像使用<code>wait_for</code>后的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> asyncio<br><span class="hljs-keyword">import</span> httpx<br><span class="hljs-keyword">import</span> time<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sub_demo</span>() -&gt; <span class="hljs-keyword">None</span>:</span><br>    <span class="hljs-keyword">await</span> httpx.AsyncClient().get(url=<span class="hljs-string">&quot;http://so1n.me&quot;</span>)<br>    <span class="hljs-keyword">await</span> httpx.AsyncClient().get(url=<span class="hljs-string">&quot;http://so1n.me&quot;</span>)<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">demo</span>() -&gt; <span class="hljs-keyword">None</span>:</span><br>    <span class="hljs-keyword">await</span> asyncio.wait_for(sub_demo(), timeout=<span class="hljs-number">9</span>)<br><br><br>asyncio.run(demo())<br></code></pre></td></tr></table></figure><p>这段代码通过<code>wait_for</code>使一个函数内的调用共享一个截止时间，当抵达截止时间时， 无论执行当前已经执行到哪个函数， 都会触发超时异常。不过这样的实现会差点意思， 因为每有一个共享截止时间的代码范围， 就需要把对应的逻辑独立出来成一个新的函数, 这样的代码不是特别的优雅， 而且当需要传的参数比较多时， 这简直就是灾难了(当然也可以写成闭包的形式)。</p><p>好在<code>Python</code>通过<code>with</code>语句提供了一个代码范围的管理，所以我们可以尝试通过<code>with</code>语句来管理这片代码范围的执行超时，那该如何实现呢？熟悉<code>with</code>语句的开发者都知道，<code>with</code>语句实际上是一个带有<code>__enter__</code>方法和<code>__exit__</code>方法的类，这两个方法分别提供了进入代码范围和退出代码范围的调用，对于超时这个需求在结合<code>with</code>语句后，只需要在进入代码范围初始化一个计时器，退出时关闭计时器，如果计时器数完（也就是超时了）且尚未被退出逻辑关闭，则会引发超时，并取消代码范围的协程，大概的伪逻辑如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">demo</span>() -&gt; <span class="hljs-keyword">None</span>:</span><br>    <span class="hljs-comment"># 该代码只为了演示逻辑，实际上无法正常运行</span><br>    timer = Timer(<span class="hljs-number">9</span>)<br>    <span class="hljs-keyword">await</span> httpx.AsyncClient().get(url=<span class="hljs-string">&quot;http://so1n.me&quot;</span>)<br>    <span class="hljs-keyword">await</span> httpx.AsyncClient().get(url=<span class="hljs-string">&quot;http://so1n.me&quot;</span>)<br>    timer.close()<br></code></pre></td></tr></table></figure><p>通过伪代码逻辑可以看出两个运行的协程并跟timer并没有任何联系，timer无法管理到这两个协程的，所以timer超时时，两个协程还能正常运行，那该如何与他们建立联系呢？文章<a href="https://so1n.me/2022/04/11/python's_waitable_objects_in_asyncio">《Python的可等待对象在Asyncio的作用》</a>中讲到在一个协程函数中通过<code>await</code>执行的子协程，是交给执行该协程函数对应的<code>task</code>对象管理的，也就是我们对执行协程函数的<code>task</code>对象进行的任何操作都是会传播到对应的子协程的，所以我们只要在进入代码范围时捕获到当前的<code>task</code>，然后通过<code>loop.call_at</code>方法在指定时间调用<code>task.cancel</code>取消<code>task</code>对象，并由<code>task</code>对象传播到被调用的子协程，如下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> asyncio<br><span class="hljs-keyword">import</span> httpx<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">demo</span>() -&gt; <span class="hljs-keyword">None</span>:</span><br>    current_task: asyncio.Task = asyncio.Task.current_task()<br>    loop: asyncio.AbstractEventLoop = asyncio.get_event_loop()<br>    <span class="hljs-comment"># 设置9秒后超时</span><br>    timer: asyncio.events.TimerHandle = loop.call_at(loop.time() + <span class="hljs-number">9</span>, <span class="hljs-keyword">lambda</span>: current_task.cancel())持续创作，加速成长！这是我参与「掘金日新计划 · <span class="hljs-number">6</span> 月更文挑战」的第<span class="hljs-number">2</span>天，点击查看活动详情<br><br><br>    <span class="hljs-keyword">await</span> httpx.AsyncClient().get(url=<span class="hljs-string">&quot;http://so1n.me&quot;</span>)<br>    <span class="hljs-keyword">await</span> httpx.AsyncClient().get(url=<span class="hljs-string">&quot;http://so1n.me&quot;</span>)<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> timer.cancelled():<br>        timer.cancel()<br>    <br></code></pre></td></tr></table></figure><p>这段是可以正常运行的，接下来我们就需要把这段逻辑封装到一个类里面，这样调用者只需要简单的调用就可以实现整块代码域的超时管理，对应的代码如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-comment"># 这是一个简化版本的伪代码, 存在一些逻辑漏洞, 但是都包含了主要流程了，</span><br><br><span class="hljs-keyword">import</span> asyncio<br><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> Optional, Type<br><span class="hljs-keyword">from</span> types <span class="hljs-keyword">import</span> TracebackType<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Deadline</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">        self,</span></span><br><span class="hljs-function"><span class="hljs-params">        delay: Optional[<span class="hljs-built_in">float</span>],</span></span><br><span class="hljs-function"><span class="hljs-params">        loop: Optional[asyncio.AbstractEventLoop] = <span class="hljs-literal">None</span>,</span></span><br><span class="hljs-function"><span class="hljs-params">        timeout_exc: Optional[Exception] = <span class="hljs-literal">None</span>,</span></span><br><span class="hljs-function"><span class="hljs-params">    </span>):</span><br>        <span class="hljs-comment"># 代表多少秒后超时</span><br>        self._delay: Optional[<span class="hljs-built_in">float</span>] = delay<br>        <span class="hljs-comment"># asyncio需要的事件循环</span><br>        self._loop = loop <span class="hljs-keyword">or</span> asyncio.get_event_loop()<br>        <span class="hljs-comment"># 当超时时，如何抛异常</span><br>        self._timeout_exc: Exception = timeout_exc <span class="hljs-keyword">or</span> asyncio.TimeoutError()<br><br>        <span class="hljs-comment"># 控制结束的future</span><br>        self._deadline_future: asyncio.Future = asyncio.Future()<br>        <span class="hljs-comment"># 注册with语句捕获的future</span><br>        self._with_scope_future: Optional[asyncio.Future] = <span class="hljs-literal">None</span> <br>        <span class="hljs-keyword">if</span> self._delay <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-comment"># 计算截止时间和注册截止时间回调，通知event loop在截止时间执行超时机制</span><br>            self._loop.call_at(self._loop.time() + self._delay, self._set_deadline_future_result)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_set_deadline_future_result</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        <span class="hljs-comment"># 当到截止时间时， 设置执行结束， 并对还在执行的with future进行cancel操作</span><br>        self._deadline_future.set_result(<span class="hljs-literal">True</span>)<br>        <span class="hljs-keyword">if</span> self._with_scope_future <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> self._with_scope_future.cancelled():<br>            self._with_scope_future.cancel()<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__enter__</span>(<span class="hljs-params">self</span>) -&gt; &quot;Deadline&quot;:</span><br>        <span class="hljs-comment"># 进入with语句范围</span><br>        <span class="hljs-keyword">if</span> self._with_scope_future:<br>            <span class="hljs-comment"># 一个实例同时只能调用一次， 多次调用会出错</span><br>            <span class="hljs-keyword">raise</span> RuntimeError(<span class="hljs-string">&quot;`with` can only be called once&quot;</span>)<br>        <span class="hljs-keyword">if</span> self._delay <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-comment"># 启动了超时机制</span><br><br>            <span class="hljs-comment"># 获取当前运行的task</span><br>            main_task: Optional[asyncio.Task] = asyncio.Task.current_task(self._loop)<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> main_task:<br>                <span class="hljs-keyword">raise</span> RuntimeError(<span class="hljs-string">&quot;Can not found current task&quot;</span>)<br>            <span class="hljs-comment"># 注册with语句所在的future</span><br>            self._with_scope_future = main_task<br>        <span class="hljs-keyword">return</span> self<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__exit__</span>(<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">        self,</span></span><br><span class="hljs-function"><span class="hljs-params">        exc_type: Optional[Type[BaseException]],</span></span><br><span class="hljs-function"><span class="hljs-params">        exc_val: Optional[BaseException],</span></span><br><span class="hljs-function"><span class="hljs-params">        exc_tb: Optional[TracebackType],</span></span><br><span class="hljs-function"><span class="hljs-params">    </span>) -&gt; Optional[bool]:</span><br>        <span class="hljs-comment"># 由于执行完成或者是异常退出with语句范围</span><br>        <span class="hljs-keyword">if</span> self._with_scope_future:<br>            self._with_scope_future = <span class="hljs-literal">None</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br><br>        <span class="hljs-keyword">if</span> self._deadline_future.done():<br>            <span class="hljs-comment"># 如果控制结束的future已经结束， 代表此次with语句范围的代码执行超时了</span><br>            <span class="hljs-keyword">raise</span> self._timeout_exc<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br></code></pre></td></tr></table></figure><p>现在超时类编写完成，它的使用方法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> asyncio<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">demo</span>() -&gt; <span class="hljs-keyword">None</span>:</span><br>    <span class="hljs-keyword">with</span> Deadline(delay=<span class="hljs-number">9</span>):<br>        <span class="hljs-keyword">await</span> httpx.AsyncClient().get(url=<span class="hljs-string">&quot;http://so1n.me&quot;</span>)<br>        <span class="hljs-keyword">await</span> httpx.AsyncClient().get(url=<span class="hljs-string">&quot;http://so1n.me&quot;</span>)<br><br><br>asyncio.run(demo())<br></code></pre></td></tr></table></figure><p>可以看到，这样的使用方法非常方便，不过这个功能在<code>Python</code>3.11已经提供了，可以通过<a href="https://github.com/python/cpython/blob/v3.11.0b3/Lib/asyncio/timeouts.py%E4%BA%86%E8%A7%A3Python%E6%8F%90%E4%BE%9B%E7%9A%84timeout%E5%AE%9E%E7%8E%B0%E3%80%82">https://github.com/python/cpython/blob/v3.11.0b3/Lib/asyncio/timeouts.py了解Python提供的timeout实现。</a></p><h2 id="2-结构化并发"><a href="#2-结构化并发" class="headerlink" title="2.结构化并发"></a>2.结构化并发</h2><p>结构化并发借鉴了结构化编程这一名词，它的作用就是确保调用者进行了一个调用后还能控制这个调用过程，或者是得到调用结果，具体的结构化并发描述见<a href="https://vorpus.org/blog/notes-on-structured-concurrency-or-go-statement-considered-harmful/">Notes on structured concurrency, or: Go statement considered harmful</a>或者译文<a href="https://juejin.cn/post/6844904146424823816">【译】「结构化并发」简析，或：有害的go语句</a>。</p><p>在使用<code>Python Asyncio</code>编写代码时，会为了提高并发能力而通过<code>asyncio.create</code>创建很多Task运行，这种情况下可能导致调用者无法得到协程的运行结果，比如一个服务端为了提高并发能力，在接收到请求时通常都会分发给其它协程去处理，这时就可能导致代码不属于结构化并发， 下面通过一个生产消费者来模拟这一个行为，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> asyncio<br><span class="hljs-keyword">import</span> random<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">request_handle</span>(<span class="hljs-params">data</span>):</span><br>    <span class="hljs-comment"># 处理请求</span><br>    print(data)<br>    <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">1</span>)<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">recv_request</span>(<span class="hljs-params">queue: asyncio.Queue</span>):</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        <span class="hljs-comment"># 接收请求</span><br>        data = <span class="hljs-keyword">await</span> queue.get()<br>        <span class="hljs-comment"># 分发给其它协程处理</span><br>        asyncio.create_task(request_handle(data))<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">send_request</span>(<span class="hljs-params">queue: asyncio.Queue</span>):</span><br>    <span class="hljs-comment"># 发送请求</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        <span class="hljs-keyword">await</span> queue.put(random.randint(<span class="hljs-number">0</span>, <span class="hljs-number">100</span>))<br>        <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">0.01</span>)<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    queue: asyncio.Queue = asyncio.Queue()<br>    asyncio.create_task(recv_request(queue))<br>    <span class="hljs-keyword">await</span> (send_request(queue))<br><br>asyncio.run(main())<br><br></code></pre></td></tr></table></figure><p>这段代码首先是通过<code>asyncio.create_task</code>创建一个发送者在后台运行着，然后通过<code>await</code>等待<code>send_request</code>调用运行结束，不过<code>send_request</code>是不会结束的，它会一直运行下去，并且每隔0.01秒就会发送一个数据到queue里面。同时在后台运行的<code>recv_request</code>就会从queue获取到数据，并且为了不阻塞自己的处理逻辑，会通过<code>create_task</code>创建一个请求处理者来处理这个请求。</p><p>这段程序可以一直运行着，但是调用者不知道后台运行的任务是否一直在正常的运行着，而且可能需要他们在运行出错时捕获到对应的错误，并把错误抛出来，于是需要对<code>main</code>函数进行一些改造：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    queue: asyncio.Queue = asyncio.Queue()<br>    recv_coro = recv_request(queue)<br>    send_coro = send_request(queue)<br>    <span class="hljs-keyword">await</span> asyncio.gather(recv_coro, send_coro)<br></code></pre></td></tr></table></figure><p>这样就能捕获到发送消息的协程和接收消息的协程的异常，并把错误抛出来了，不过对于接收消息并分发给其它协程这段逻辑却无法通过<code>asyncio.gather</code>来管理，因为该逻辑是收到消息就会创建一个协程来处理的，这是实时创建的，而<code>asyncio.gather</code>只能管理已经创建的Corotinue。</p><p>如果有一个类，可以像<code>timeout</code>管理这个作用域的所有派生出来的协程，捕获派送协程的异常，那就很棒了。而在<code>Python</code>3.11或者是<code>Anyio</code>中可以通过<code>TaskGroup</code>解决这个问题，在使用<code>TaskGroup</code>后，<code>recv_request</code>代码改写为如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> asyncio<br><span class="hljs-keyword">import</span> random<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">request_handle</span>(<span class="hljs-params">data</span>):</span><br>    <span class="hljs-comment"># 处理请求</span><br>    print(data)<br>    <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">1</span>)<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">recv_request</span>(<span class="hljs-params">queue: asyncio.Queue</span>):</span><br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> asyncio.task_group.TaskGroup() <span class="hljs-keyword">as</span> tg:<br>        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>            <span class="hljs-comment"># 接收请求</span><br>            data = <span class="hljs-keyword">await</span> queue.get()<br>            <span class="hljs-comment"># 分发给其它协程处理</span><br>            tg.create_task(request_handle(data))<br></code></pre></td></tr></table></figure><p>可以看到这个代码改动不大，首先是通过<code>asyncio.task_group.TaskGroup</code>创建一个对象并开启一个代码域，然后通过<code>tg</code>这个对象的<code>create_task</code>方法派生一个协程来处理数据，这个用法跟<code>asyncio.create_task</code>很像，但是通过<code>tg.create_task</code>创建的协程是会被<code>tg</code>管理的。<br>这时，如果<code>request_handle</code>对应的协程抛出来异常，<code>tg</code>对象也会退出并抛出对应的异常，同时这个代码域执行完毕后，也不会退出这片代码域，而是需要等所有通过<code>tg.create_task</code>创建的协程执行完毕后才会退出。</p><p>通过上面的<code>timeout</code>可以猜到<code>TaskGroup</code>也是在<code>__aenter__</code>时获取当前<code>task</code>对象并在后续使用着，现在通过<a href="https://github.com/python/cpython/blob/v3.11.0b3/Lib/asyncio/taskgroups.py">taskgroups.py</a>了解<code>TaskGroup</code>是如何执行的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">from</span> asycnio <span class="hljs-keyword">import</span> events<br><span class="hljs-keyword">from</span> asycnio <span class="hljs-keyword">import</span> exceptions<br><span class="hljs-keyword">from</span> asycnio <span class="hljs-keyword">import</span> tasks<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TaskGroup</span>:</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        self._entered = <span class="hljs-literal">False</span><br>        self._exiting = <span class="hljs-literal">False</span><br>        self._aborting = <span class="hljs-literal">False</span><br>        self._loop = <span class="hljs-literal">None</span><br>        self._parent_task = <span class="hljs-literal">None</span><br>        self._parent_cancel_requested = <span class="hljs-literal">False</span><br>        self._tasks = <span class="hljs-built_in">set</span>()<br>        self._errors = []<br>        self._base_error = <span class="hljs-literal">None</span><br>        self._on_completed_fut = <span class="hljs-literal">None</span><br><br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__aenter__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-comment"># 限制只能调用一次</span><br>        <span class="hljs-keyword">if</span> self._entered:<br>            <span class="hljs-keyword">raise</span> RuntimeError(<br>                <span class="hljs-string">f&quot;TaskGroup <span class="hljs-subst">&#123;self!r&#125;</span> has been already entered&quot;</span>)<br>        self._entered = <span class="hljs-literal">True</span><br><br>        <span class="hljs-keyword">if</span> self._loop <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            self._loop = events.get_running_loop()<br><br>        <span class="hljs-comment"># 获取当前的task</span><br>        self._parent_task = tasks.current_task(self._loop)<br>        <span class="hljs-keyword">if</span> self._parent_task <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">raise</span> RuntimeError(<br>                <span class="hljs-string">f&#x27;TaskGroup <span class="hljs-subst">&#123;self!r&#125;</span> cannot determine the parent task&#x27;</span>)<br><br>        <span class="hljs-keyword">return</span> self<br><br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__aexit__</span>(<span class="hljs-params">self, et, exc, tb</span>):</span><br>        self._exiting = <span class="hljs-literal">True</span><br>        propagate_cancellation_error = <span class="hljs-literal">None</span><br><br>        <span class="hljs-keyword">if</span> (exc <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span><br>                self._is_base_error(exc) <span class="hljs-keyword">and</span><br>                self._base_error <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>):<br>            self._base_error = exc<br><br>        <span class="hljs-keyword">if</span> et <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">if</span> et <span class="hljs-keyword">is</span> exceptions.CancelledError:<br>                <span class="hljs-keyword">if</span> self._parent_cancel_requested <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> self._parent_task.uncancel():<br>                    <span class="hljs-comment"># Do nothing, i.e. swallow the error.</span><br>                    <span class="hljs-keyword">pass</span><br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-comment"># 如果有一个协程已经取消了，就设置取消的exc</span><br>                    propagate_cancellation_error = exc<br><br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self._aborting:<br>                <span class="hljs-comment"># 取消所有的task</span><br>                self._abort()<br><br>        <span class="hljs-comment"># 如果还有派生的协程来运行，就陷在这个逻辑中</span><br>        <span class="hljs-keyword">while</span> self._tasks:<br>            <span class="hljs-keyword">if</span> self._on_completed_fut <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>                self._on_completed_fut = self._loop.create_future()<br><br>            <span class="hljs-keyword">try</span>:<br>                <span class="hljs-comment"># 创建一个中间future来捕获所有派生协程的异常，并等待协程运行完毕</span><br>                <span class="hljs-keyword">await</span> self._on_completed_fut<br>            <span class="hljs-keyword">except</span> exceptions.CancelledError <span class="hljs-keyword">as</span> ex:<br>                <span class="hljs-comment"># TaskGroup不会使_on_completed_fut抛出取消异常，但是如果main_task被取消时，会传播到_on_completed_fut</span><br>                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self._aborting:<br>                    <span class="hljs-comment"># 与上面一样设置错误，并取消所有协程</span><br>                    propagate_cancellation_error = ex<br>                    self._abort()<br><br>            self._on_completed_fut = <span class="hljs-literal">None</span><br><br>        <span class="hljs-keyword">assert</span> <span class="hljs-keyword">not</span> self._tasks<br><br>        <span class="hljs-comment"># 如果有异常，则抛出</span><br>        <span class="hljs-keyword">if</span> self._base_error <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">raise</span> self._base_error<br><br>        <span class="hljs-keyword">if</span> propagate_cancellation_error <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">raise</span> propagate_cancellation_error<br><br>        <span class="hljs-keyword">if</span> et <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> et <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> exceptions.CancelledError:<br>            self._errors.append(exc)<br><br>        <span class="hljs-comment"># 抛出所有运行期间的异常</span><br>        <span class="hljs-keyword">if</span> self._errors:<br>            errors = self._errors<br>            self._errors = <span class="hljs-literal">None</span><br><br>            me = BaseExceptionGroup(<span class="hljs-string">&#x27;unhandled errors in a TaskGroup&#x27;</span>, errors)<br>            <span class="hljs-keyword">raise</span> me <span class="hljs-keyword">from</span> <span class="hljs-literal">None</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">create_task</span>(<span class="hljs-params">self, coro, *, name=<span class="hljs-literal">None</span>, context=<span class="hljs-literal">None</span></span>):</span><br>        <span class="hljs-comment"># 判断目前是否生效，如果不生效就无法派生协程</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self._entered:<br>            <span class="hljs-keyword">raise</span> RuntimeError(<span class="hljs-string">f&quot;TaskGroup <span class="hljs-subst">&#123;self!r&#125;</span> has not been entered&quot;</span>)<br>        <span class="hljs-keyword">if</span> self._exiting <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> self._tasks:<br>            <span class="hljs-keyword">raise</span> RuntimeError(<span class="hljs-string">f&quot;TaskGroup <span class="hljs-subst">&#123;self!r&#125;</span> is finished&quot;</span>)<br>        <span class="hljs-comment"># 通过事件循环创建协程</span><br>        <span class="hljs-keyword">if</span> context <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            task = self._loop.create_task(coro)<br>        <span class="hljs-keyword">else</span>:<br>            task = self._loop.create_task(coro, context=context)<br>        tasks._set_task_name(task, name)<br>        <span class="hljs-comment"># 添加task执行结果回调</span><br>        task.add_done_callback(self._on_task_done)<br>        <span class="hljs-comment"># 把task添加到对应的self._task，这样其它方法就会判断协程是否运行完毕了</span><br>        self._tasks.add(task)<br>        <span class="hljs-keyword">return</span> task<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_is_base_error</span>(<span class="hljs-params">self, exc: BaseException</span>) -&gt; bool:</span><br>        <span class="hljs-keyword">assert</span> <span class="hljs-built_in">isinstance</span>(exc, BaseException)<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">isinstance</span>(exc, (SystemExit, KeyboardInterrupt))<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_abort</span>(<span class="hljs-params">self</span>):</span><br>        self._aborting = <span class="hljs-literal">True</span><br><br>        <span class="hljs-comment"># 取消所有派生的协程</span><br>        <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> self._tasks:<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> t.done():<br>                t.cancel()<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_on_task_done</span>(<span class="hljs-params">self, task</span>):</span><br>        <span class="hljs-comment"># 安全的删除对应的task</span><br>        self._tasks.discard(task)<br><br>        <span class="hljs-keyword">if</span> self._on_completed_fut <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> self._tasks:<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self._on_completed_fut.done():<br>                <span class="hljs-comment"># 如果最后一个派生的协程运行结束，则设置中间future,这样TaskGroup.__aexit__的while循环就能继续执行了</span><br>                self._on_completed_fut.set_result(<span class="hljs-literal">True</span>)<br><br>        <span class="hljs-comment"># 如果task已经取消或者没有异常，则不走下面的逻辑</span><br>        <span class="hljs-keyword">if</span> task.cancelled():<br>            <span class="hljs-keyword">return</span><br>        exc = task.exception()<br>        <span class="hljs-keyword">if</span> exc <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">return</span><br><br>        <span class="hljs-comment"># 把异常添加到类中</span><br>        self._errors.append(exc)<br>        <span class="hljs-keyword">if</span> self._is_base_error(exc) <span class="hljs-keyword">and</span> self._base_error <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            self._base_error = exc<br><br>        <span class="hljs-comment"># 最后处理下当前task</span><br>        <span class="hljs-keyword">if</span> self._parent_task.done():<br>            <span class="hljs-comment"># Not sure if this case is possible, but we want to handle</span><br>            <span class="hljs-comment"># it anyways.</span><br>            self._loop.call_exception_handler(&#123;<br>                <span class="hljs-string">&#x27;message&#x27;</span>: <span class="hljs-string">f&#x27;Task <span class="hljs-subst">&#123;task!r&#125;</span> has errored out but its parent &#x27;</span><br>                           <span class="hljs-string">f&#x27;task <span class="hljs-subst">&#123;self._parent_task&#125;</span> is already completed&#x27;</span>,<br>                <span class="hljs-string">&#x27;exception&#x27;</span>: exc,<br>                <span class="hljs-string">&#x27;task&#x27;</span>: task,<br>            &#125;)<br>            <span class="hljs-keyword">return</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self._aborting <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> self._parent_cancel_requested:<br>            self._abort()<br>            self._parent_cancel_requested = <span class="hljs-literal">True</span><br>            self._parent_task.cancel()<br></code></pre></td></tr></table></figure><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3.总结"></a>3.总结</h2><p>可以看到，这两个功能都是通过<code>task</code>把我们的调用向子协程进行传播，这样一来就可以通过<code>task</code>方便的控制对应的协程，但是这也有一个缺点，就是一处函数为<code>async</code>，则处处函数都是<code>async</code>（对于需要IO调用的函数来说），而<code>Go</code>语言的协程就没有这种担忧，但是<code>Go</code>语言创建的协程是无法被管理的，除非创建协程的时候把<code>Context</code>对象传进去，并在对应的协程中通过<code>channel</code>来捕获<code>Context</code>对象的方法，这就要求开发<code>Go</code>库的开发者需要有良好的开发能力，能考虑到使用者在调用时是否需要考虑到超时，结构化并发等需求。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前记&quot;&gt;&lt;a href=&quot;#前记&quot; class=&quot;headerlink&quot; title=&quot;前记&quot;&gt;&lt;/a&gt;前记&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Python Asyncio&lt;/code&gt;提供了很多基础的API以及对应的对象，如果只用于编写简单的HTTP API处理函数，那么这些&lt;code&gt;Python Asyncio&lt;/code&gt;是足够的，但在面对一些复杂点多的需求或者编写网络相关框架时，就需要基于&lt;code&gt;Python Asyncio&lt;/code&gt;的基础API封装成高级对象。目前比较常用的高级对象有两个，一个是用于管理代码域超时的&lt;code&gt;timeout&lt;/code&gt;以及一个用于结构化并发的&lt;code&gt;TaskGroup&lt;/code&gt;，它们最先出现在&lt;a href=&quot;https://github.com/python-trio/trio&quot;&gt;Trio&lt;/a&gt;这个协程库中，后来&lt;a href=&quot;https://github.com/agronholm/anyio&quot;&gt;Anyio&lt;/a&gt;库也支持这两个对象，现在，准备发布Python 3.11中&lt;code&gt;Asyncio&lt;/code&gt;库也包括这两个功能。&lt;/p&gt;</summary>
    
    
    <content src="https://fastly.jsdelivr.net/gh/so1n/so1n_blog_photo@master/blog_photo/16550442517731649661119526images.png" type="image"/>
    
    
    <category term="Python Asyncio" scheme="http://so1n.me/categories/Python-Asyncio/"/>
    
    
    <category term="Python" scheme="http://so1n.me/tags/Python/"/>
    
    <category term="Asyncio" scheme="http://so1n.me/tags/Asyncio/"/>
    
  </entry>
  
  <entry>
    <title>Python Asyncio调度原理</title>
    <link href="http://so1n.me/2022/06/08/python_asyncio_schedule/"/>
    <id>http://so1n.me/2022/06/08/python_asyncio_schedule/</id>
    <published>2022-06-08T15:33:18.000Z</published>
    <updated>2022-06-12T15:08:22.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前记"><a href="#前记" class="headerlink" title="前记"></a>前记</h2><p>在文章<a href="https://so1n.me/2022/04/11/python's_waitable_objects_in_asyncio/">《Python的可等待对象在Asyncio的作用》</a>中介绍了<code>Python</code>的可等待对象作用，特别是<code>Task</code>对象在启动的时候可以自我驱动，但是一个<code>Task</code>对象只能驱动一条执行链，如果要多条链执行（并发），还是需要<code>EventLoop</code>来安排驱动，接下来将通过<code>Python.Asyncio</code>库的源码来了解<code>EventLoop</code>是如何运作的。</p><span id="more"></span><h2 id="1-基本介绍"><a href="#1-基本介绍" class="headerlink" title="1.基本介绍"></a>1.基本介绍</h2><p><code>Python.Asyncio</code>是一个大而全的库，它包括很多功能，而跟核心调度相关的逻辑除了三种可等待对象外，还有其它一些功能，它们分别位于<code>runners.py</code>，<code>base_event.py</code>，<code>event.py</code>三个文件中。</p><p><code>runners.py</code>文件有一个主要的类–<code>Runner</code>，它的主要职责是做好进入协程模式的事件循环等到初始化工作，以及在退出协程模式时清理还在内存的协程，生成器等对象。</p><blockquote><p>协程模式只是为了能方便理解，对于计算机而言，并没有这样区分</p></blockquote><p><code>event.py</code>文件除了存放着<code>EventLoop</code>对象的接口以及获取和设置<code>EventLoop</code>的函数外，还有两个<code>EventLoop</code>可调度的对象，分别为<code>Handler</code>和<code>TimerHandler</code>，它们可以认为是<code>EvnetLoop</code>调用其它对象的容器，用于连接待调度对象和事件循环的关系，不过它们的实现非常简单，对于<code>Handler</code>，它的源码如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-comment"># 已经移除了一些不想关的代码</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Handle</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, callback, args, loop, context=<span class="hljs-literal">None</span></span>):</span><br>        <span class="hljs-comment"># 初始化上下文，确保执行的时候能找到Handle所在的上下文</span><br>        <span class="hljs-keyword">if</span> context <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            context = contextvars.copy_context()<br>        self._context = context<br>        self._loop = loop<br>        self._callback = callback<br>        self._args = args<br>        self._cancelled = <span class="hljs-literal">False</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">cancel</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-comment"># 设置当前Handle为取消状态</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self._cancelled:<br>            self._cancelled = <span class="hljs-literal">True</span><br>            self._callback = <span class="hljs-literal">None</span><br>            self._args = <span class="hljs-literal">None</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">cancelled</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> self._cancelled<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_run</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-comment"># 用于执行真正的函数，且通过context.run方法来确保在自己的上下文内执行。</span><br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-comment"># 保持在自己持有的上下文中执行对应的回调</span><br>            self._context.run(self._callback, *self._args)<br>        <span class="hljs-keyword">except</span> (SystemExit, KeyboardInterrupt):<br>            <span class="hljs-keyword">raise</span><br>        <span class="hljs-keyword">except</span> BaseException <span class="hljs-keyword">as</span> exc:<br>            cb = format_helpers._format_callback_source(<br>                self._callback, self._args)<br>            msg = <span class="hljs-string">f&#x27;Exception in callback <span class="hljs-subst">&#123;cb&#125;</span>&#x27;</span><br>            context = &#123;<br>                <span class="hljs-string">&#x27;message&#x27;</span>: msg,<br>                <span class="hljs-string">&#x27;exception&#x27;</span>: exc,<br>                <span class="hljs-string">&#x27;handle&#x27;</span>: self,<br>            &#125;<br>            self._loop.call_exception_handler(context)<br></code></pre></td></tr></table></figure><p>通过源码可以发现，<code>Handle</code>功能十分简单，提供了可以被取消以及可以在自己所处的上下文执行的功能，而<code>TimerHandle</code>继承于<code>Handle</code>比<code>Handle</code>多了一些和时间以及排序相关的参数，源码如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TimerHandle</span>(<span class="hljs-params">Handle</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, when, callback, args, loop, context=<span class="hljs-literal">None</span></span>):</span><br>        <span class="hljs-built_in">super</span>().__init__(callback, args, loop, context)<br>        self._when = when<br>        self._scheduled = <span class="hljs-literal">False</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__hash__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">hash</span>(self._when)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__lt__</span>(<span class="hljs-params">self, other</span>):</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(other, TimerHandle):<br>            <span class="hljs-keyword">return</span> self._when &lt; other._when<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NotImplemented</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__le__</span>(<span class="hljs-params">self, other</span>):</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(other, TimerHandle):<br>            <span class="hljs-keyword">return</span> self._when &lt; other._when <span class="hljs-keyword">or</span> self.__eq__(other)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NotImplemented</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__gt__</span>(<span class="hljs-params">self, other</span>):</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(other, TimerHandle):<br>            <span class="hljs-keyword">return</span> self._when &gt; other._when<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NotImplemented</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__ge__</span>(<span class="hljs-params">self, other</span>):</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(other, TimerHandle):<br>            <span class="hljs-keyword">return</span> self._when &gt; other._when <span class="hljs-keyword">or</span> self.__eq__(other)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NotImplemented</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__eq__</span>(<span class="hljs-params">self, other</span>):</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(other, TimerHandle):<br>            <span class="hljs-keyword">return</span> (self._when == other._when <span class="hljs-keyword">and</span><br>                    self._callback == other._callback <span class="hljs-keyword">and</span><br>                    self._args == other._args <span class="hljs-keyword">and</span><br>                    self._cancelled == other._cancelled)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NotImplemented</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">cancel</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self._cancelled:<br>            <span class="hljs-comment"># 用于通知事件循环当前Handle已经退出了</span><br>            self._loop._timer_handle_cancelled(self)<br>        <span class="hljs-built_in">super</span>().cancel()<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">when</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> self._when<br></code></pre></td></tr></table></figure><p>通过代码可以发现，这两个对象十分简单，而我们在使用<code>Python.Asyncio</code>时并不会直接使用到这两个对象，而是通过<code>loop.call_xxx</code>系列方法来把调用封装成<code>Handle</code>对象，然后等待<code>EventLoop</code>执行。<br>所以<code>loop.call_xxx</code>系列方法可以认为是<code>EventLoop</code>的注册操作，基本上所有非IO的异步操作都需要通过<code>loop.call_xxx</code>方法来把自己的调用注册到<code>EventLoop</code>中，比如<code>Task</code>对象就在初始化后通过调用<code>loop.call_soon</code>方法来注册到<code>EventLoop</code>中，<code>loop.call_sonn</code>的实现很简单，它的源码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseEventLoop</span>:</span><br>    ...<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">call_soon</span>(<span class="hljs-params">self, callback, *args, context=<span class="hljs-literal">None</span></span>):</span><br>        <span class="hljs-comment"># 检查是否事件循环是否关闭，如果是则直接抛出异常</span><br>        self._check_closed()<br>        handle = self._call_soon(callback, args, context)<br>        <span class="hljs-keyword">return</span> handle<br><br>   <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_call_soon</span>(<span class="hljs-params">self, callback, args, context</span>):</span><br>        <span class="hljs-comment"># 把调用封装成一个handle，这样方便被事件循环调用</span><br>        handle = events.Handle(callback, args, self, context)<br>        <span class="hljs-comment"># 添加一个handle到_ready，等待被调用</span><br>        self._ready.append(handle)<br>        <span class="hljs-keyword">return</span> handle<br></code></pre></td></tr></table></figure><p>可以看到<code>call_soon</code>真正相关的代码只有10几行，它负责把一个调用封装成一个<code>Handle</code>，并添加到<code>self._reday</code>中，从而实现把调用注册到事件循环之中。</p><p><code>loop.call_xxx</code>系列函数除了<code>loop.call_soon</code>系列函数外，还有另外两个方法–<code>loop.call_at</code>和<code>loop.call_later</code>，它们类似于<code>loop.call_soon</code>，不过多了一个时间参数，来告诉<code>EventLoop</code>在什么时间后才可以调用，同时通过<code>loop.call_at</code>和<code>loop.call_later</code>注册的调用会通过<code>Python</code>的堆排序模块<code>headpq</code>注册到<code>self._scheduled</code>变量中，具体代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseEventLoop</span>:</span><br>    ...<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">call_later</span>(<span class="hljs-params">self, delay, callback, *args, context=<span class="hljs-literal">None</span></span>):</span><br>        <span class="hljs-keyword">if</span> delay <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">raise</span> TypeError(<span class="hljs-string">&#x27;delay must not be None&#x27;</span>)<br>        timer = self.call_at(self.time() + delay, callback, *args, context=context)<br>        <span class="hljs-keyword">return</span> timer<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">call_at</span>(<span class="hljs-params">self, when, callback, *args, context=<span class="hljs-literal">None</span></span>):</span><br>        <span class="hljs-keyword">if</span> when <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">raise</span> TypeError(<span class="hljs-string">&quot;when cannot be None&quot;</span>)<br>        self._check_closed()<br>        <span class="hljs-comment"># 创建一个timer handle，然后添加到事件循环的_scheduled中，等待被调用</span><br>        timer = events.TimerHandle(when, callback, args, self, context)<br>        heapq.heappush(self._scheduled, timer)<br>        timer._scheduled = <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">return</span> timer<br></code></pre></td></tr></table></figure><h2 id="2-EventLoop的调度实现"><a href="#2-EventLoop的调度实现" class="headerlink" title="2.EventLoop的调度实现"></a>2.EventLoop的调度实现</h2><p>在文章<a href="https://so1n.me/2022/04/11/python's_waitable_objects_in_asyncio/">《Python的可等待对象在Asyncio的作用》</a>中已经分析到了<code>runner</code>会通过<code>loop.run_until_complete</code>来调用<code>main</code>Task从而开启<code>EventLoop</code>的调度，所以在分析<code>EventLoop</code>的调度时，应该先从<code>loop.run_until_complete</code>入手，对应的源码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseEventLoop</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run_until_complete</span>(<span class="hljs-params">self, future</span>):</span><br>        ...<br><br>        new_task = <span class="hljs-keyword">not</span> futures.isfuture(future)<br>        <span class="hljs-comment"># 把coroutine转换成task，这样事件循环就可以调度了，事件循环的最小调度单位为task</span><br>        <span class="hljs-comment"># 需要注意的是此时事件循环并没注册到全局变量中，所以需要显示的传进去，</span><br>        <span class="hljs-comment"># 同时Task对象注册的时候，已经通过loop.call_soon把自己注册到事件循环中，等待调度</span><br>        future = tasks.ensure_future(future, loop=self)<br>        <span class="hljs-keyword">if</span> new_task:<br>            <span class="hljs-comment"># An exception is raised if the future didn&#x27;t complete, so there</span><br>            <span class="hljs-comment"># is no need to log the &quot;destroy pending task&quot; message</span><br>            future._log_destroy_pending = <span class="hljs-literal">False</span><br><br>        <span class="hljs-comment"># 当该task完成时，意味着当前事件循环失去了调度对象，无法继续调度，所以需要关闭当前事件循环，程序会由协程模式返回到线程模式</span><br>        future.add_done_callback(_run_until_complete_cb)<br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-comment"># 事件循环开始运行</span><br>            self.run_forever()<br>        <span class="hljs-keyword">except</span>:<br>            <span class="hljs-keyword">if</span> new_task <span class="hljs-keyword">and</span> future.done() <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> future.cancelled():<br>                <span class="hljs-comment"># The coroutine raised a BaseException. Consume the exception</span><br>                <span class="hljs-comment"># to not log a warning, the caller doesn&#x27;t have access to the</span><br>                <span class="hljs-comment"># local task.</span><br>                future.exception()<br>            <span class="hljs-keyword">raise</span><br>        <span class="hljs-keyword">finally</span>:<br>            future.remove_done_callback(_run_until_complete_cb)<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> future.done():<br>            <span class="hljs-keyword">raise</span> RuntimeError(<span class="hljs-string">&#x27;Event loop stopped before Future completed.&#x27;</span>)<br><br>        <span class="hljs-keyword">return</span> future.result()<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run_forever</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-comment"># 进行一些初始化工作</span><br>        self._check_closed()<br>        self._check_running()<br>        self._set_coroutine_origin_tracking(self._debug)<br>        self._thread_id = threading.get_ident()<br><br>        old_agen_hooks = sys.get_asyncgen_hooks()<br>        <span class="hljs-comment"># 通过asyncgen钩子来自动关闭asyncgen函数，这样可以提醒用户生成器还未关闭</span><br>        sys.set_asyncgen_hooks(firstiter=self._asyncgen_firstiter_hook,<br>                               finalizer=self._asyncgen_finalizer_hook)<br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-comment"># 设置当前在运行的事件循环到全局变量中，这样就可以在任一阶段获取到当前的事件循环了</span><br>            events._set_running_loop(self)<br>            <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>                <span class="hljs-comment"># 正真执行任务的逻辑</span><br>                self._run_once()<br>                <span class="hljs-keyword">if</span> self._stopping:<br>                    <span class="hljs-keyword">break</span><br>        <span class="hljs-keyword">finally</span>:<br>            <span class="hljs-comment"># 关闭循环, 并且清理一些资源</span><br>            self._stopping = <span class="hljs-literal">False</span><br>            self._thread_id = <span class="hljs-literal">None</span><br>            events._set_running_loop(<span class="hljs-literal">None</span>)<br>            self._set_coroutine_origin_tracking(<span class="hljs-literal">False</span>)<br>            sys.set_asyncgen_hooks(*old_agen_hooks)<br></code></pre></td></tr></table></figure><p>这段源码并不复杂，它的主要逻辑是通过把<code>Corotinue</code>转为一个<code>Task</code>对象，然后通过<code>Task</code>对象初始化时调用<code>loop.call_sonn</code>方法把自己注册到<code>EventLoop</code>中，最后再通过<code>loop.run_forever</code>中的循环代码一直运行着，直到<code>_stopping</code>被标记为<code>True</code>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    <span class="hljs-comment"># 正真执行任务的逻辑</span><br>    self._run_once()<br>    <span class="hljs-keyword">if</span> self._stopping:<br>        <span class="hljs-keyword">break</span><br></code></pre></td></tr></table></figure><p>可以看出，这段代码是确保事件循环能一直执行着，自动循环结束，而真正调度的核心是<code>_run_once</code>函数，它的源码如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseEventLoop</span>:</span><br>    ...<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_run_once</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-comment"># self._scheduled是一个列表，它只存放TimerHandle</span><br>        sched_count = <span class="hljs-built_in">len</span>(self._scheduled)<br>        <span class="hljs-comment">###############################</span><br>        <span class="hljs-comment"># 第一阶段，整理self._scheduled #</span><br>        <span class="hljs-comment">###############################</span><br>        <span class="hljs-keyword">if</span> (sched_count &gt; _MIN_SCHEDULED_TIMER_HANDLES <span class="hljs-keyword">and</span><br>            self._timer_cancelled_count / sched_count &gt; _MIN_CANCELLED_TIMER_HANDLES_FRACTION):<br>            <span class="hljs-comment"># 当待调度的任务数量超过100且待取消的任务占总任务的50%时，才进入这个逻辑</span><br>            <span class="hljs-comment"># 把需要取消的任务移除</span><br>            new_scheduled = []<br>            <span class="hljs-keyword">for</span> handle <span class="hljs-keyword">in</span> self._scheduled:<br>                <span class="hljs-keyword">if</span> handle._cancelled:<br>                    <span class="hljs-comment"># 设置handle的_cancelled为True，并且把handle从_scheduled中移除</span><br>                    handle._scheduled = <span class="hljs-literal">False</span><br>                <span class="hljs-keyword">else</span>:<br>                    new_scheduled.append(handle)<br><br>            <span class="hljs-comment"># 重新排列堆</span><br>            heapq.heapify(new_scheduled)<br>            self._scheduled = new_scheduled<br>            self._timer_cancelled_count = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-comment"># 需要取消的handle不多，则只会走这个逻辑，这里会把堆顶的handle弹出，并标记为不可调度，但不会访问整个堆</span><br>            <span class="hljs-keyword">while</span> self._scheduled <span class="hljs-keyword">and</span> self._scheduled[<span class="hljs-number">0</span>]._cancelled:<br>                self._timer_cancelled_count -= <span class="hljs-number">1</span><br>                handle = heapq.heappop(self._scheduled)<br>                handle._scheduled = <span class="hljs-literal">False</span><br><br>        <span class="hljs-comment">#################################</span><br>        <span class="hljs-comment"># 第二阶段，计算超时值以及等待事件IO #</span><br>        <span class="hljs-comment">#################################</span><br>        timeout = <span class="hljs-literal">None</span><br>        <span class="hljs-comment"># 当有准备调度的handle或者是正在关闭时，不等待，方便尽快的调度</span><br>        <span class="hljs-keyword">if</span> self._ready <span class="hljs-keyword">or</span> self._stopping:<br>            timeout = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">elif</span> self._scheduled:<br>            <span class="hljs-comment"># Compute the desired timeout.</span><br>            <span class="hljs-comment"># 如果堆有数据时，通过堆顶的handle计算最短的超时时间，但是最多不能超过MAXIMUM_SELECT_TIMEOUT，以免超过系统限制</span><br>            when = self._scheduled[<span class="hljs-number">0</span>]._when<br>            timeout = <span class="hljs-built_in">min</span>(<span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, when - self.time()), MAXIMUM_SELECT_TIMEOUT)<br><br>        <span class="hljs-comment"># 事件循环等待事件，直到有事件或者超时</span><br>        event_list = self._selector.select(timeout)<br><br>        <span class="hljs-comment">##################################################</span><br>        <span class="hljs-comment"># 第三阶段，把满足条件的TimeHandle放入到self._ready中 #</span><br>        <span class="hljs-comment">##################################################</span><br>        <span class="hljs-comment"># 获取得到的事件的回调，然后装填到_ready</span><br>        self._process_events(event_list)<br><br>        <span class="hljs-comment"># 把一些在self._scheduled且满足调度条件的handle放到_ready中，比如TimerHandle。</span><br>        <span class="hljs-comment"># end_time为当前时间+一个时间单位，猜测是能多处理一些这段时间内产生的事件</span><br>        end_time = self.time() + self._clock_resolution<br>        <span class="hljs-keyword">while</span> self._scheduled:<br>            handle = self._scheduled[<span class="hljs-number">0</span>]<br>            <span class="hljs-keyword">if</span> handle._when &gt;= end_time:<br>                <span class="hljs-keyword">break</span><br>            handle = heapq.heappop(self._scheduled)<br>            handle._scheduled = <span class="hljs-literal">False</span><br>            self._ready.append(handle)<br><br>        <span class="hljs-comment">################################################################################</span><br>        <span class="hljs-comment"># 第四阶段，遍历所有准备调度的handle，并且通过handle的context来执行handle对应的callback #</span><br>        <span class="hljs-comment">################################################################################</span><br>        ntodo = <span class="hljs-built_in">len</span>(self._ready)<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(ntodo):<br>            handle = self._ready.popleft()<br>            <span class="hljs-comment"># 如果handle已经被取消，则不调用</span><br>            <span class="hljs-keyword">if</span> handle._cancelled:<br>                <span class="hljs-keyword">continue</span><br>            <span class="hljs-keyword">if</span> self._debug:<br>                <span class="hljs-keyword">try</span>:<br>                    self._current_handle = handle<br>                    t0 = self.time()<br>                    handle._run()<br>                    dt = self.time() - t0<br>                    <span class="hljs-keyword">if</span> dt &gt;= self.slow_callback_duration:<br>                        <span class="hljs-comment"># 执行太久的回调，记录下来，这些需要开发者自己优化</span><br>                        logger.warning(<span class="hljs-string">&#x27;Executing %s took %.3f seconds&#x27;</span>,<br>                                       _format_handle(handle), dt)<br>                <span class="hljs-keyword">finally</span>:<br>                    self._current_handle = <span class="hljs-literal">None</span><br>            <span class="hljs-keyword">else</span>:<br>                handle._run()<br>        handle = <span class="hljs-literal">None</span>  <span class="hljs-comment"># Needed to break cycles when an exception occurs.</span><br></code></pre></td></tr></table></figure><p>通过源码分析，可以很明确的知道调度逻辑中第一步是先规整<code>self._scheduled</code>，在规整的过程是使用堆排序来进行的，因为堆排序在调度的场景下效率是非常高的，不过这段规整代码分成两种，我猜测是当需要取消的数量过多时直接遍历的效率会更高。<br>在规整<code>self._scheduled</code>后，就进入第二步，该步骤开始等待系统事件循环返回对应的事件，如果<code>self._ready</code>中有数据，就不做等待了，需要马上到下一步骤，以便能赶紧安排调度。<br>在得到系统事件循环得到的事件后，就进入到了第三步，该步骤会通过<code>self._process_events</code>方法处理对应的事件，并把事件对应的回调存放到了<code>self._ready</code>中，最后再遍历<code>self._ready</code>中的所有<code>Handle</code>并逐一执行(执行时可以认为<code>EventLoop</code>把控制权返回给对应的调用逻辑)，至此一个完整的调度逻辑就结束了，并进入下一个调度逻辑。</p><h2 id="3-网络IO事件的处理"><a href="#3-网络IO事件的处理" class="headerlink" title="3.网络IO事件的处理"></a>3.网络IO事件的处理</h2><blockquote><p>注：由于系统事件循环的限制，所以文件IO一般还是使用多线程来执行，具体见：<a href="https://github.com/python/asyncio/wiki/ThirdParty#filesystem">https://github.com/python/asyncio/wiki/ThirdParty#filesystem</a></p></blockquote><p>在分析<code>EventLoop</code>调度实现的时候忽略了<code>self._process_events</code>的具体实现逻辑，因为<code>_process_events</code>方法所在<code>asyncio.base_event.py</code>文件中的<code>BaseEventLoop</code>类并未有具体实现的，因为网络IO相关的需要系统的事件循环来帮忙处理，所以与系统事件循环相关的逻辑都在<code>asyncio.selector_events.py</code>中的<code>BaseSelectorEventLoop</code>类中。<code>BaseSelectorEventLoop</code>类封装了<code>selector</code>模块与系统事件循环交互，使调用者不需要去考虑sock的创建以及sock产生的文件描述符的监听与注销等操作，下面以<code>BaseSelectorEventLoop</code>中自带的pipe为例子，分析<code>BaseSelectorEventLoop</code>是如何进行网络IO事件处理的。</p><p>在分析之前，先看一个例子，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> asyncio<br><span class="hljs-keyword">import</span> threading<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">task</span>():</span><br>    print(<span class="hljs-string">&quot;task&quot;</span>)<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run_loop_inside_thread</span>(<span class="hljs-params">loop</span>):</span><br>    loop.run_forever()<br><br><br>loop = asyncio.get_event_loop()<br>threading.Thread(target=run_loop_inside_thread, args=(loop,)).start()<br>loop.call_soon(task)<br></code></pre></td></tr></table></figure><p>如果直接运行这个例子，它并不会输出<code>task</code>（不过在IDE使用DEBUG模式下线程启动会慢一点，所以会输出的），因为在调用<code>loop.run_forever</code>后<code>EventLoop</code>会一直卡在这段逻辑中:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Python">event_list = self._selector.select(timeout)<br></code></pre></td></tr></table></figure><p>所以调用<code>loop.call_soon</code>并不会使<code>EventLoop</code>马上安排调度，而如果把<code>call_soon</code>换成<code>call_soon_threadsafe</code>则可以正常输出，这是因为<code>call_soon_threadsafe</code>中多了一个<code>self._write_to_self</code>的调用，它的源码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseEventLoop</span>:</span><br>    ...<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">call_soon_threadsafe</span>(<span class="hljs-params">self, callback, *args, context=<span class="hljs-literal">None</span></span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;Like call_soon(), but thread-safe.&quot;&quot;&quot;</span><br>        self._check_closed()<br>        handle = self._call_soon(callback, args, context)<br>        self._write_to_self()<br>        <span class="hljs-keyword">return</span> handle<br></code></pre></td></tr></table></figure><p>由于这个调用是涉及到IO相关的，所以需要到<code>BaseSelectorEventLoop</code>类查看，接下来以pipe相关的网络IO操作来分析<code>EventLoop</code>是如何处理IO事件的(只演示reader对象，writer对象操作与reader类似)，对应的源码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseSelectorEventLoop</span>(<span class="hljs-params">base_events.BaseEventLoop</span>):</span><br><br>    <span class="hljs-comment">#######</span><br>    <span class="hljs-comment"># 创建 #</span><br>    <span class="hljs-comment">#######</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, selector=<span class="hljs-literal">None</span></span>):</span><br>        <span class="hljs-built_in">super</span>().__init__()<br><br>        <span class="hljs-keyword">if</span> selector <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-comment"># 获取最优的selector</span><br>            selector = selectors.DefaultSelector()<br>        self._selector = selector<br>        <span class="hljs-comment"># 创建pipe</span><br>        self._make_self_pipe()<br>        self._transports = weakref.WeakValueDictionary()<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_make_self_pipe</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-comment"># 创建Pipe对应的sock </span><br>        self._ssock, self._csock = socket.socketpair()<br>        <span class="hljs-comment"># 设置sock为非阻塞</span><br>        self._ssock.setblocking(<span class="hljs-literal">False</span>)<br>        self._csock.setblocking(<span class="hljs-literal">False</span>)<br>        self._internal_fds += <span class="hljs-number">1</span><br>        <span class="hljs-comment"># 阻塞服务端sock读事件对应的回调</span><br>        self._add_reader(self._ssock.fileno(), self._read_from_self)<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_add_reader</span>(<span class="hljs-params">self, fd, callback, *args</span>):</span><br>        <span class="hljs-comment"># 检查事件循环是否关闭</span><br>        self._check_closed()<br>        <span class="hljs-comment"># 封装回调为handle对象</span><br>        handle = events.Handle(callback, args, self, <span class="hljs-literal">None</span>)<br>        <span class="hljs-keyword">try</span>:<br>            key = self._selector.get_key(fd)<br>        <span class="hljs-keyword">except</span> KeyError:<br>            <span class="hljs-comment"># 如果没有注册到系统的事件循环，则注册</span><br>            self._selector.register(fd, selectors.EVENT_READ,<br>                                    (handle, <span class="hljs-literal">None</span>))<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-comment"># 如果已经注册过，则更新</span><br>            mask, (reader, writer) = key.events, key.data<br>            self._selector.modify(fd, mask | selectors.EVENT_READ,<br>                                  (handle, writer))<br>            <span class="hljs-keyword">if</span> reader <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>                reader.cancel()<br>        <span class="hljs-keyword">return</span> handle<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_read_from_self</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-comment"># 负责消费sock数据</span><br>        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>            <span class="hljs-keyword">try</span>:<br>                data = self._ssock.recv(<span class="hljs-number">4096</span>)<br>                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> data:<br>                    <span class="hljs-keyword">break</span><br>                self._process_self_data(data)<br>            <span class="hljs-keyword">except</span> InterruptedError:<br>                <span class="hljs-keyword">continue</span><br>            <span class="hljs-keyword">except</span> BlockingIOError:<br>                <span class="hljs-keyword">break</span><br><br>    <span class="hljs-comment">#######</span><br>    <span class="hljs-comment"># 删除 #</span><br>    <span class="hljs-comment">#######</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_close_self_pipe</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-comment"># 注销Pipe对应的描述符 </span><br>        self._remove_reader(self._ssock.fileno())<br>        <span class="hljs-comment"># 关闭sock</span><br>        self._ssock.close()<br>        self._ssock = <span class="hljs-literal">None</span><br>        self._csock.close()<br>        self._csock = <span class="hljs-literal">None</span><br>        self._internal_fds -= <span class="hljs-number">1</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_remove_reader</span>(<span class="hljs-params">self, fd</span>):</span><br>        <span class="hljs-comment"># 如果事件循环已经关闭了，就不用操作了</span><br>        <span class="hljs-keyword">if</span> self.is_closed():<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-comment"># 查询文件描述符是否在selector中</span><br>            key = self._selector.get_key(fd)<br>        <span class="hljs-keyword">except</span> KeyError:<br>            <span class="hljs-comment"># 不存在则返回</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-comment"># 存在则进入移除的工作</span><br>            mask, (reader, writer) = key.events, key.data<br>            <span class="hljs-comment"># 通过事件掩码判断是否有其它事件</span><br>            mask &amp;= ~selectors.EVENT_READ<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> mask:<br>                <span class="hljs-comment"># 移除已经注册到selector的文件描述符</span><br>                self._selector.unregister(fd)<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-comment"># 移除已经注册到selector的文件描述符，并注册新的事件</span><br>                self._selector.modify(fd, mask, (<span class="hljs-literal">None</span>, writer))<br><br>            <span class="hljs-comment"># 如果reader不为空，则取消reader</span><br>            <span class="hljs-keyword">if</span> reader <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>                reader.cancel()<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><p>通过源码中的创建部分可以看到，<code>EventLoop</code>在启动的时候会创建一对建立通信的sock，并设置为非阻塞，然后把对应的回调封装成一个<code>Handle</code>对象并注册到系统事件循环中（删除则进行对应的反向操作），之后系统事件循环就会一直监听对应的事件，也就是<code>EventLoop</code>的执行逻辑会阻塞在下面的调用中，等待事件响应：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Python">event_list = self._selector.select(timeout)<br></code></pre></td></tr></table></figure><p>这时如果执行<code>loop.call_soon_threadsafe</code>，那么会通过<code>write_to_self</code>写入一点信息：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_write_to_self</span>(<span class="hljs-params">self</span>):</span><br>    csock = self._csock<br>    <span class="hljs-keyword">if</span> csock <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>        <span class="hljs-keyword">return</span><br><br>    <span class="hljs-keyword">try</span>:<br>        csock.send(<span class="hljs-string">b&#x27;\0&#x27;</span>)<br>    <span class="hljs-keyword">except</span> OSError:<br>        <span class="hljs-keyword">if</span> self._debug:<br>            logger.debug(<span class="hljs-string">&quot;Fail to write a null byte into the self-pipe socket&quot;</span>, exc_info=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure><p>由于<code>csock</code>被写入了数据，那么它对应的<code>ssock</code>就会收到一个读事件，系统事件循环在收到这个事件通知后就会把数据返回，然后<code>EventLoop</code>就会获得到对应的数据，并交给<code>process_events</code>方法进行处理，它的相关代码如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseSelectorEventLoop</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_process_events</span>(<span class="hljs-params">self, event_list</span>):</span><br>        <span class="hljs-keyword">for</span> key, mask <span class="hljs-keyword">in</span> event_list:<br>            <span class="hljs-comment"># 从回调事件中获取到对应的数据，key.data在注册时是一个元祖，所以这里要对元祖进行解包</span><br>            fileobj, (reader, writer) = key.fileobj, key.data<br>            <span class="hljs-keyword">if</span> mask &amp; selectors.EVENT_READ <span class="hljs-keyword">and</span> reader <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>                <span class="hljs-comment"># 得到reader handle，如果是被标记为取消，就移除对应的文件描述符</span><br>                <span class="hljs-keyword">if</span> reader._cancelled:<br>                    self._remove_reader(fileobj)<br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-comment"># 如果没被标记为取消，则安排到self._ready中</span><br>                    self._add_callback(reader)<br>            <span class="hljs-keyword">if</span> mask &amp; selectors.EVENT_WRITE <span class="hljs-keyword">and</span> writer <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>                <span class="hljs-comment"># 对于写对象，也是同样的道理。</span><br>                <span class="hljs-keyword">if</span> writer._cancelled:<br>                    self._remove_writer(fileobj)<br>                <span class="hljs-keyword">else</span>:<br>                    self._add_callback(writer)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_add_callback</span>(<span class="hljs-params">self, handle</span>):</span><br>        <span class="hljs-comment"># 把回调的handle添加到_ready中</span><br>        <span class="hljs-keyword">assert</span> <span class="hljs-built_in">isinstance</span>(handle, events.Handle), <span class="hljs-string">&#x27;A Handle is required here&#x27;</span><br>        <span class="hljs-keyword">if</span> handle._cancelled:<br>            <span class="hljs-keyword">return</span><br>        <span class="hljs-keyword">assert</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">isinstance</span>(handle, events.TimerHandle)<br>        self._ready.append(handle)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_remove_reader</span>(<span class="hljs-params">self, fd</span>):</span><br>        <span class="hljs-comment"># 如果事件循环已经关闭了，就不用操作了</span><br>        <span class="hljs-keyword">if</span> self.is_closed():<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-comment"># 查询文件描述符是否在selector中</span><br>            key = self._selector.get_key(fd)<br>        <span class="hljs-keyword">except</span> KeyError:<br>            <span class="hljs-comment"># 不存在则返回</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-comment"># 存在则进入移除的工作</span><br>            mask, (reader, writer) = key.events, key.data<br>            mask &amp;= ~selectors.EVENT_READ<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> mask:<br>                <span class="hljs-comment"># 移除已经注册到selector的文件描述符</span><br>                self._selector.unregister(fd)<br>            <span class="hljs-keyword">else</span>:<br>                self._selector.modify(fd, mask, (<span class="hljs-literal">None</span>, writer))<br><br>            <span class="hljs-keyword">if</span> reader <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>                reader.cancel()<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><p>从代码中可以看出<code>_process_events</code>会对事件对应的文件描述符进行处理，并从事件回调中获取到对应的<code>Handle</code>对象添加到<code>self._ready</code>中，由<code>EventLoop</code>在接下来遍历<code>self._ready</code>并执行。</p><p>可以看到网络IO事件的处理并不复杂，因为系统事件循环已经为我们做了很多工作了，但是用户所有与网络IO相关的操作都需要有一个类似的操作，这样是非常的繁琐的，幸好<code>asyncio</code>库已经为我们做了封装，我们只要调用就可以了，方便了很多。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前记&quot;&gt;&lt;a href=&quot;#前记&quot; class=&quot;headerlink&quot; title=&quot;前记&quot;&gt;&lt;/a&gt;前记&lt;/h2&gt;&lt;p&gt;在文章&lt;a href=&quot;https://so1n.me/2022/04/11/python&#39;s_waitable_objects_in_asyncio/&quot;&gt;《Python的可等待对象在Asyncio的作用》&lt;/a&gt;中介绍了&lt;code&gt;Python&lt;/code&gt;的可等待对象作用，特别是&lt;code&gt;Task&lt;/code&gt;对象在启动的时候可以自我驱动，但是一个&lt;code&gt;Task&lt;/code&gt;对象只能驱动一条执行链，如果要多条链执行（并发），还是需要&lt;code&gt;EventLoop&lt;/code&gt;来安排驱动，接下来将通过&lt;code&gt;Python.Asyncio&lt;/code&gt;库的源码来了解&lt;code&gt;EventLoop&lt;/code&gt;是如何运作的。&lt;/p&gt;</summary>
    
    
    <content src="https://fastly.jsdelivr.net/gh/so1n/so1n_blog_photo@master/blog_photo/16550442517731649661119526images.png" type="image"/>
    
    
    <category term="Python Asyncio" scheme="http://so1n.me/categories/Python-Asyncio/"/>
    
    
    <category term="Python" scheme="http://so1n.me/tags/Python/"/>
    
    <category term="Asyncio" scheme="http://so1n.me/tags/Asyncio/"/>
    
  </entry>
  
  <entry>
    <title>Python-gRPC实践(6)--编写gRPC网关</title>
    <link href="http://so1n.me/2022/05/23/Python-gRPC%E5%AE%9E%E8%B7%B5(6)--%E7%BC%96%E5%86%99gRPC%E7%BD%91%E5%85%B3%20copy/"/>
    <id>http://so1n.me/2022/05/23/Python-gRPC%E5%AE%9E%E8%B7%B5(6)--%E7%BC%96%E5%86%99gRPC%E7%BD%91%E5%85%B3%20copy/</id>
    <published>2022-05-23T12:35:24.000Z</published>
    <updated>2022-06-24T11:27:05.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>就目前而言，在大多数场景中，用户侧的客户端和服务端还是通过HTTP进行交互，然后服务端内部各种服务再通过过各种协议进行交互，所以在采用了gRPC做内部服务的交互协议后，就需要一个网关来把gRPC的调用自动映射到HTTP应用上，方便客户端调用。</p><blockquote><p>注：本文只针对一对一的gRPC服务。</p><p>之前原本想当做一个简单的实现，后面发现可以与我编写的<a href="https://github.com/so1n/pait">pait</a>框架可以嵌到一起，这样也可以对多个Web框架提供Gateway功能，于是就把这个功能的实现嵌入到<a href="https://github.com/so1n/pait">pait</a>框架中，所以下面有些代码来自于我编写的<a href="https://github.com/so1n/pait">pait</a>框架，对应的gRPC网关文档使用说明见:<a href="https://so1n.me/pait-zh-doc/7_gRPC_gateway/">Pait gRPC Gateway</a></p></blockquote><h2 id="1-网关的基础实现思路"><a href="#1-网关的基础实现思路" class="headerlink" title="1.网关的基础实现思路"></a>1.网关的基础实现思路</h2><p>网关的思路很简单，就是把HTTP请求转发到了对应的gRPC服务，在<code>Go</code>生态中，已经出现了一个类似的框架–<a href="https://github.com/grpc-ecosystem/grpc-gateway">grpc-gateway</a>，它负责grpc服务自动的映射到HTTP服务中，同时它通过让HTTP服务和gRPC服务监听同一个端口来降低使用者的疑惑。</p><p>通过前面的文章我们了解到，gRPC采用的是HTTP/2做传输协议，而HTTP/2是对于HTTP/1.1的一个升级，这样的话服务端在接收socket的数据且转为HTTP数据后就可以判断Header中<code>Upgrade</code>字段对应的值来把数据分别分发到HTTP服务和gRPC服务。</p><p>但是，<code>Python</code>的gRPC是通过gRPC-C转译的，也就是它的底层是C实现的，所以<code>Python</code>的gRPC无法传socket来启动服务，而是只能通过指定ip:port的形式来启动服务，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> grpc<br><span class="hljs-keyword">from</span> concurrent <span class="hljs-keyword">import</span> futures<br><br>grpc.server(<br>    futures.ThreadPoolExecutor(max_workers=<span class="hljs-number">10</span>),<br>).add_insecure_port(<span class="hljs-string">&quot;127.0.0.1:9000&quot;</span>)<br></code></pre></td></tr></table></figure><p>这样上述的做法就无法实现了，只能让HTTP服务和gRPC服务分别监听不同的端口，无法做到像<a href="https://github.com/grpc-ecosystem/grpc-gateway">Go grpc-gateway</a>那样，毕竟Go才是亲儿子。</p><p>最终只能以下面的方式实现：<br><img   class="lazyload" data-original="https://cdn.jsdelivr.net/gh/so1n/so1n_blog_photo@master/blog_photo/1653363969391gRPC-Gateway.jpg" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" ><br>图中客户端发起的请求会先发送到HTTP服务绑定的端口，HTTP服务收到请求后，会转发到gRPC客户端，交由gRPC客户端发送到gRPC服务端，这样一系列服务就串起来了。</p><blockquote><p>图中的示例HTTP服务与gRPC客户端在同一个进程，而gRPC服务在同台机器的另外一个进程，但是他们也可以在同一个进程内。</p></blockquote><h2 id="2-如何编写转发路由"><a href="#2-如何编写转发路由" class="headerlink" title="2.如何编写转发路由"></a>2.如何编写转发路由</h2><p>总体思路决定后，就开始细究路由的实现了，路由只负责转发，不做其它功能，通过前面文章<a href="https://so1n.me/2022/01/05/Python-gRPC%E5%AE%9E%E8%B7%B5(1)--%E7%AE%80%E4%BB%8B/">Python-gRPC实践（1）–gRPC简介</a>的捉包可以知道，gRPC传输数据时，采用的是HTTP/2来传输请求，用的是POST方法，同时使用Body传输数据，那么我们可以采用尽量相似的方法来接收请求，再通过gRPC客户端传到对应的服务端，如下的Proto文件:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs proto">syntax &#x3D; &quot;proto3&quot;;<br>package example;<br><br><br>message LoginUserRequest &#123;<br>  string uid &#x3D; 1;<br>  string password &#x3D; 2;<br>&#125;<br>message LoginUserResult &#123;<br>  string uid &#x3D; 1;<br>  string user_name &#x3D; 2;<br>  string token &#x3D; 3;<br>&#125;<br><br><br>service User &#123;<br>    rpc login_user(LoginUserRequest) returns (LoginUserResult);<br>&#125;<br></code></pre></td></tr></table></figure><p>接着，以这种方法来创建一个路由来映射这个Proto文件的请求，这个路由采用POST方法然后解析对应的数据并通过对应的gRPC客户端传递到服务端，为了尽量的跟gRPC一致，所以HTTP服务与客户端通过Json进行交互，映射的路由代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> grpc<br><span class="hljs-keyword">from</span> starlette.applications <span class="hljs-keyword">import</span> Starlette<br><span class="hljs-keyword">from</span> starlette.routing <span class="hljs-keyword">import</span> Route<br><span class="hljs-keyword">from</span> starlette.requests <span class="hljs-keyword">import</span> Request<br><span class="hljs-keyword">from</span> starlette.responses <span class="hljs-keyword">import</span> JSONResponse<br><br><span class="hljs-comment"># pait项目的演示代码，由Proto文件生产的</span><br><span class="hljs-keyword">from</span> example.example_grpc.python_example_proto_code.example_proto.user <span class="hljs-keyword">import</span> user_pb2<br><span class="hljs-keyword">from</span> example.example_grpc.python_example_proto_code.example_proto.user <span class="hljs-keyword">import</span> user_pb2_grpc<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">login_route</span>(<span class="hljs-params">request: Request</span>) -&gt; JSONResponse:</span><br>    <span class="hljs-comment"># 接收请求</span><br>    request_dict: <span class="hljs-built_in">dict</span> = <span class="hljs-keyword">await</span> request.json()<br>    user_service: user_pb2_grpc.UserStub = request.app.state.user_service<br>    <span class="hljs-comment"># 发送请求到对应的gRPC服务端</span><br>    result: user_pb2.LoginUserResult = user_service.login_user(<br>        user_pb2.LoginUserRequest(uid=request_dict[<span class="hljs-string">&quot;uid&quot;</span>], password=request_dict[<span class="hljs-string">&quot;password&quot;</span>])<br>    )<br>    <span class="hljs-comment"># 返回对应的响应</span><br>    <span class="hljs-keyword">return</span> JSONResponse(<br>        &#123;<br>            <span class="hljs-string">&quot;uid&quot;</span>: result.uid,<br>            <span class="hljs-string">&quot;user_name&quot;</span>: result.user_name,<br>            <span class="hljs-string">&quot;token&quot;</span>: result.token,<br>        &#125;<br>    )<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">create_app</span>() -&gt; Starlette:</span><br>    <span class="hljs-comment"># 绑定路由</span><br>    app: Starlette = Starlette(routes=[Route(<span class="hljs-string">&quot;/api/login&quot;</span>, login_route, methods=[<span class="hljs-string">&quot;POST&quot;</span>])])<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_before_server_start</span>() -&gt; <span class="hljs-keyword">None</span>:</span><br>        <span class="hljs-comment"># 启动时绑定gRPC客户端到对应的实例</span><br>        app.state.user_service = user_pb2_grpc.UserStub(grpc.aio.insecure_channel(<span class="hljs-string">&quot;0.0.0.0:9000&quot;</span>))<br>    <br>    app.add_event_handler(<span class="hljs-string">&quot;startup&quot;</span>, _before_server_start)<br>    <span class="hljs-keyword">return</span> app<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    <span class="hljs-keyword">import</span> uvicorn  <span class="hljs-comment"># type: ignore</span><br><br>    uvicorn.run(create_app(), log_level=<span class="hljs-string">&quot;debug&quot;</span>)<br></code></pre></td></tr></table></figure><p>这样一个简单的转发就编写完毕了，但是目前是手动编写的代码，意味着每新增一个接口，我们就需有编写一个对应的路由函数，同时如果Protobuf文件发生了变更，那么我们需要定位到对应的代码再修改，非常麻烦，特别是我们在定义Protobuf文件时，已经很像在定义一个接口了，结果还要再编写路由函数，效率非常低，所以一个网关最关键的是需要通过Protobuf文件或者通过Protobuf的产物来自动生成路由函数并映射到对应的服务，这样一来，其它使用者后续只要修改Protobuf文件即可。</p><h2 id="3-提取路由需要的数据"><a href="#3-提取路由需要的数据" class="headerlink" title="3.提取路由需要的数据"></a>3.提取路由需要的数据</h2><p>为了自动生成路由，还需要一些数据，通过编写的转发路由可以发现，我们只需要收到用户的请求，解析数据，然后通过对应的gRPC客户端方法来发送数据即可，所以需要通过这个gRPC客户端的方法来找到所有需要的数据（尝试了多种方法，目前这种是最优的）。</p><p>以上面的Protobuf文件自动生成的<code>Python</code>代码中的<code>user_pb2_grpc.UserStub</code>为例子(可以通过<a href="https://github.com/so1n/pait/tree/master/example/example_grpc">pait/example/example_grpc</a>了解)，它的代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> grpc<br><br><span class="hljs-keyword">from</span> example.example_grpc.python_example_proto_code.example_proto.user <span class="hljs-keyword">import</span> user_pb2 <span class="hljs-keyword">as</span> example__proto_dot_user_dot_user__pb2<br><span class="hljs-keyword">from</span> google.protobuf <span class="hljs-keyword">import</span> empty_pb2 <span class="hljs-keyword">as</span> google_dot_protobuf_dot_empty__pb2<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserStub</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, channel</span>):</span><br>        self.get_uid_by_token = channel.unary_unary(<br>                <span class="hljs-string">&#x27;/user.User/get_uid_by_token&#x27;</span>,<br>                request_serializer=example__proto_dot_user_dot_user__pb2.GetUidByTokenRequest.SerializeToString,<br>                response_deserializer=example__proto_dot_user_dot_user__pb2.GetUidByTokenResult.FromString,<br>                )<br>        self.logout_user = channel.unary_unary(<br>                <span class="hljs-string">&#x27;/user.User/logout_user&#x27;</span>,<br>                request_serializer=example__proto_dot_user_dot_user__pb2.LogoutUserRequest.SerializeToString,<br>                response_deserializer=google_dot_protobuf_dot_empty__pb2.Empty.FromString,<br>                )<br>        self.login_user = channel.unary_unary(<br>                <span class="hljs-string">&#x27;/user.User/login_user&#x27;</span>,<br>                request_serializer=example__proto_dot_user_dot_user__pb2.LoginUserRequest.SerializeToString,<br>                response_deserializer=example__proto_dot_user_dot_user__pb2.LoginUserResult.FromString,<br>                )<br>        self.create_user = channel.unary_unary(<br>                <span class="hljs-string">&#x27;/user.User/create_user&#x27;</span>,<br>                request_serializer=example__proto_dot_user_dot_user__pb2.CreateUserRequest.SerializeToString,<br>                response_deserializer=google_dot_protobuf_dot_empty__pb2.Empty.FromString,<br>                )<br>        self.delete_user = channel.unary_unary(<br>                <span class="hljs-string">&#x27;/user.User/delete_user&#x27;</span>,<br>                request_serializer=example__proto_dot_user_dot_user__pb2.DeleteUserRequest.SerializeToString,<br>                response_deserializer=google_dot_protobuf_dot_empty__pb2.Empty.FromString,<br>                )<br></code></pre></td></tr></table></figure><p>通过这份生成的代码可以发现，这个对象类中包括了每个调用的url，请求体和响应体，这样再加上上面说了gRPC是以POST方法进行请求的，那么构成一个最小路由的条件都已经满足了。<br>但是，要通过这份代码提取数据却比较麻烦，由于都是在<code>__init__</code>方法后才初始化各个gRPC的调用方法，所以没办法通过<code>dir(UserStub)</code>获取到对应的gRPC调用方法，只能通过<code>UserStub(channel).__dict__</code>来获取gRPC的调用方法，不过<code>channel</code>最好需要在对应的HTTP服务启动时再初始化，特别是对于uvicorn来说，如果grpc.aio.channel提前初始化，那么他们使用的不是同一个事件循环，这意味着就必须在Web实例启动后再注册路由，但由于<code>Sanic</code>等框架是不支持实例启动后再注册路由的，所以这个方法行不通。此外，示例代码中的请求体，响应体都是调用对应的方法再加载到<code>channel.unary_unary</code>中，之后我们没办法在运行时通过<code>UserStub</code>的实例来直接获取。</p><p>幸运的是，由Proto文件生成的<code>UserStub</code>对象是有规则的，所以可以在程序运行时获取到<code>UserStub</code>的源码，然后通过一定的规则把数据提取出来，分析上面的源码，可以发现有如下几个规则：</p><ul><li>1.<code>self.xxx</code>中是gRPC调用的方法名，同时<code>channel.unary_unary</code>代表了这是一对一的请求。</li><li>2.<code>self.xxx</code>的下面第一行是gRPC方法对应的url</li><li>3.<code>self.xxx</code>的下面第二行出现了gRPC方法的请求对象，这一行是以<code>request_serializer=</code>开头，以<code>.SerializeToString</code>结尾，可以通过正则提取中间的对象字符串，然后可以在运行时通过解析字符串从<code>UserStub</code>所在的模块中提取到正确的请求对象。</li><li>4.<code>self.xxx</code>的下面第三行则是gRPC方法的响应对象，处理方法跟请求对象类似。</li></ul><p>发现了规则后就可以通过规则提取对应的数据，具体代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> inspect<br><span class="hljs-keyword">import</span> re<br><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> Any, List, Generator, Optional, Type<br><span class="hljs-keyword">from</span> types <span class="hljs-keyword">import</span> ModuleType<br><span class="hljs-keyword">from</span> google.protobuf.message <span class="hljs-keyword">import</span> Message<br><br><span class="hljs-keyword">from</span> example.example_grpc.python_example_proto_code.example_proto.user <span class="hljs-keyword">import</span> user_pb2_grpc<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_gen_message</span>(<span class="hljs-params">class_module: ModuleType, line: <span class="hljs-built_in">str</span>, match_str: <span class="hljs-built_in">str</span></span>) -&gt; Type[Message]:</span><br>    <span class="hljs-comment"># 通过正则提取对应的字符串</span><br>    module_path_find_list = re.findall(match_str, line)<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(module_path_find_list) != <span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&quot;module path not found&quot;</span>)<br>    module_path: <span class="hljs-built_in">str</span> = module_path_find_list[<span class="hljs-number">0</span>]<br>    module_path_list: List[<span class="hljs-built_in">str</span>] = module_path.split(<span class="hljs-string">&quot;.&quot;</span>)<br>    <span class="hljs-comment"># 通过UserStub模块获取到消息体对应的模块</span><br>    message_module: ModuleType = <span class="hljs-built_in">getattr</span>(class_module, module_path_list[<span class="hljs-number">0</span>])<br>    <span class="hljs-comment"># 从模块提取到对应的对象</span><br>    message_model: Type[Message] = <span class="hljs-built_in">getattr</span>(message_module, module_path_list[<span class="hljs-number">1</span>])<br><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">issubclass</span>(message_model, Message):<br>        <span class="hljs-keyword">raise</span> RuntimeError(<span class="hljs-string">&quot;Can not found message&quot;</span>)<br>    <span class="hljs-keyword">return</span> message_model<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">parse</span>(<span class="hljs-params">stub: Any</span>) -&gt; Generator[tuple, <span class="hljs-keyword">None</span>, <span class="hljs-keyword">None</span>]:</span><br>    <span class="hljs-comment"># 提取对应对象的源码，以`\n`切分成每一行</span><br>    line_list: List[<span class="hljs-built_in">str</span>] = inspect.getsource(stub).split(<span class="hljs-string">&quot;\n&quot;</span>)<br><br>    <span class="hljs-comment"># 获取对象的模块，这样就能知道这个模块引用了什么包，方便后面提取请求和响应对象</span><br>    class_module: Optional[ModuleType] = inspect.getmodule(stub)<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> class_module:<br>        <span class="hljs-keyword">raise</span> RuntimeError(<span class="hljs-string">f&quot;Can not found <span class="hljs-subst">&#123;stub&#125;</span> module&quot;</span>)<br>    <span class="hljs-comment"># 通过enumerate，可以获取到行数对应的索引</span><br>    <span class="hljs-keyword">for</span> index, line <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(line_list):<br>        <span class="hljs-comment"># 不是self.所在的行，就跳过</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;self.&quot;</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> line:<br>            <span class="hljs-keyword">continue</span><br>        <span class="hljs-comment"># 只映射一对一的gRPC请求，其它gRPC请求则忽略</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;channel.unary_unary&quot;</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> line:<br>            <span class="hljs-keyword">continue</span><br><br>        <span class="hljs-comment"># 通过这一行提取gRPC调用端方法名</span><br>        invoke_name: <span class="hljs-built_in">str</span> = line.split(<span class="hljs-string">&quot;=&quot;</span>)[<span class="hljs-number">0</span>].replace(<span class="hljs-string">&quot;self.&quot;</span>, <span class="hljs-string">&quot;&quot;</span>).strip()<br>        <span class="hljs-comment"># 从下一行提取url</span><br>        method: <span class="hljs-built_in">str</span> = line_list[index + <span class="hljs-number">1</span>].strip()[<span class="hljs-number">1</span>:-<span class="hljs-number">2</span>]<br>        <span class="hljs-comment"># 从下两行提取请求对象</span><br>        request: Type[Message] = _gen_message(<br>            class_module, line_list[index + <span class="hljs-number">2</span>], <span class="hljs-string">r&quot;request_serializer=(.+).SerializeToString&quot;</span><br>        )<br>        <span class="hljs-comment"># 从下三行提取响应对象</span><br>        response: Type[Message] = _gen_message(<br>            class_module, line_list[index + <span class="hljs-number">3</span>], <span class="hljs-string">r&quot;response_deserializer=(.+).FromString&quot;</span><br>        )<br>        <span class="hljs-comment"># 返回提取的数据</span><br>        <span class="hljs-keyword">yield</span> invoke_name, method, request, response<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> parse(user_pb2_grpc.UserStub):<br>        print(i)<br><br><br></code></pre></td></tr></table></figure><p>这段代码执行后就会输出以下结果，可以发现，这段代码正常的从<code>UserStub</code>中提取到了我们想要的数据。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">(<span class="hljs-string">&#x27;get_uid_by_token&#x27;</span>, <span class="hljs-string">&#x27;/user.User/get_uid_by_token&#x27;</span>, &lt;class <span class="hljs-string">&#x27;example_proto.user.user_pb2.GetUidByTokenRequest&#x27;</span>&gt;, &lt;class <span class="hljs-string">&#x27;example_proto.user.user_pb2.GetUidByTokenResult&#x27;</span>&gt;)<br>(<span class="hljs-string">&#x27;logout_user&#x27;</span>, <span class="hljs-string">&#x27;/user.User/logout_user&#x27;</span>, &lt;class <span class="hljs-string">&#x27;example_proto.user.user_pb2.LogoutUserRequest&#x27;</span>&gt;, &lt;class <span class="hljs-string">&#x27;google.protobuf.empty_pb2.Empty&#x27;</span>&gt;)<br>(<span class="hljs-string">&#x27;login_user&#x27;</span>, <span class="hljs-string">&#x27;/user.User/login_user&#x27;</span>, &lt;class <span class="hljs-string">&#x27;example_proto.user.user_pb2.LoginUserRequest&#x27;</span>&gt;, &lt;class <span class="hljs-string">&#x27;example_proto.user.user_pb2.LoginUserResult&#x27;</span>&gt;)<br>(<span class="hljs-string">&#x27;create_user&#x27;</span>, <span class="hljs-string">&#x27;/user.User/create_user&#x27;</span>, &lt;class <span class="hljs-string">&#x27;example_proto.user.user_pb2.CreateUserRequest&#x27;</span>&gt;, &lt;class <span class="hljs-string">&#x27;google.protobuf.empty_pb2.Empty&#x27;</span>&gt;)<br>(<span class="hljs-string">&#x27;delete_user&#x27;</span>, <span class="hljs-string">&#x27;/user.User/delete_user&#x27;</span>, &lt;class <span class="hljs-string">&#x27;example_proto.user.user_pb2.DeleteUserRequest&#x27;</span>&gt;, &lt;class <span class="hljs-string">&#x27;google.protobuf.empty_pb2.Empty&#x27;</span>&gt;)<br></code></pre></td></tr></table></figure><p>不过这还不够，比如使用者可能想自定义这个请求映射的URL，或者是控制这个gRPC请求方法是否要映射等等，这些功能是无法通过Proto文件来控制的，如果写在另一个文件配置又非常麻烦，最后决定通过Proto文件的注释来实现这些功能，比如下面的Proto代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs proto">service User &#123;<br>  &#x2F;&#x2F; The interface should not be exposed for external use<br>  &#x2F;&#x2F; pait: &#123;&quot;enable&quot;: false&#125;<br>  rpc get_uid_by_token (GetUidByTokenRequest) returns (GetUidByTokenResult);<br>  &#x2F;&#x2F; pait: &#123;&quot;tag&quot;: [[&quot;grpc-user&quot;, &quot;grpc_user_service&quot;], [&quot;grpc-user-system&quot;, &quot;grpc_user_service&quot;]]&#125;<br>  &#x2F;&#x2F; pait: &#123;&quot;summary&quot;: &quot;Create users through the system&quot;, &quot;url&quot;: &quot;&#x2F;user&#x2F;create&quot;&#125;<br>  rpc create_user(CreateUserRequest) returns (google.protobuf.Empty);<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码有一个标准的<code>pait:</code>开头，这样在解析时，就可以知道这一行是需要解析的文本，然后就会去解析后面跟着的一串Json字符串，就可以知道<code>get_uid_by_token</code>设置了<code>enable</code>为<code>false</code>，而<code>create_user</code>设置了url为<code>/user/create</code>。不过，默认生成的代码中，客户端对象是没有携带Proto文件的注释信息的，只有他们对应的服务端对象才有携带，比如<code>UserStub</code>没有携带注释信息，而<code>UserStub</code>对应的<code>User</code>对象则携带，所以需要从<code>User</code>中提取数据。</p><p>此外，对于请求对象和响应对象也可以采用这样的思路，但是<code>Python</code>的gRPC库通过Proto文件生成<code>Python</code>代码时，Proto文件中为Message编写的注释是不会一起跟过来的，需要自己编写一个插件，或者通过<code>mypy-proto</code>插件生成的文件来获取。由于这部分的代码比较长且繁杂，这里只做简单说明，具体源码见<a href="https://github.com/so1n/pait/blob/master/pait/util/grpc_inspect/stub.py">pait.util.groc_inspect.stub.py</a></p><h2 id="4-自动映射路由"><a href="#4-自动映射路由" class="headerlink" title="4.自动映射路由"></a>4.自动映射路由</h2><p>至此，url，请求方法，请求体和响应体都获取到了，现在可以自动映射路由了，还是以<code>starlette</code>框架为例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> grpc<br><span class="hljs-keyword">from</span> starlette.applications <span class="hljs-keyword">import</span> Starlette<br><span class="hljs-keyword">from</span> starlette.requests <span class="hljs-keyword">import</span> Request<br><span class="hljs-keyword">from</span> starlette.responses <span class="hljs-keyword">import</span> JSONResponse<br><span class="hljs-keyword">from</span> google.protobuf.message <span class="hljs-keyword">import</span> Message<br><span class="hljs-keyword">from</span> google.protobuf.json_format <span class="hljs-keyword">import</span> MessageToDict<br><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> Any, Callable<br><br><span class="hljs-comment"># pait项目的演示代码，由Proto文件生产的</span><br><span class="hljs-keyword">from</span> example.example_grpc.python_example_proto_code.example_proto.user <span class="hljs-keyword">import</span> user_pb2<br><span class="hljs-keyword">from</span> example.example_grpc.python_example_proto_code.example_proto.user <span class="hljs-keyword">import</span> user_pb2_grpc<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">gen_route</span>(<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">    app: Starlette,</span></span><br><span class="hljs-function"><span class="hljs-params">    stub: Any,</span></span><br><span class="hljs-function"><span class="hljs-params">    url: <span class="hljs-built_in">str</span>,</span></span><br><span class="hljs-function"><span class="hljs-params">    invoke_name: <span class="hljs-built_in">str</span>,</span></span><br><span class="hljs-function"><span class="hljs-params">    grpc_request: Message,</span></span><br><span class="hljs-function"><span class="hljs-params">    grpc_response: Message,</span></span><br><span class="hljs-function"><span class="hljs-params"></span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    :param app: Starlette实例</span><br><span class="hljs-string">    :param stub: gRPC客户端对应的类</span><br><span class="hljs-string">    :param url: url</span><br><span class="hljs-string">    :param invoke_name: gRPC调用的方法名</span><br><span class="hljs-string">    :param grpc_request: gRPC请求体</span><br><span class="hljs-string">    :param grpc_response: gRPC响应体，可以发现它没有被使用</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_route</span>(<span class="hljs-params">request: Request</span>) -&gt; JSONResponse:</span><br>        resp_dict: <span class="hljs-built_in">dict</span> = <span class="hljs-keyword">await</span> request.json()<br>        <span class="hljs-comment"># 通过app实例携带的channel来调用gRPC服务</span><br>        func: Callable = <span class="hljs-built_in">getattr</span>(stub(app.state.channel), invoke_name)<br>        <span class="hljs-comment"># 把gRPC响应数据专为json响应</span><br>        <span class="hljs-keyword">return</span> JSONResponse(MessageToDict(<span class="hljs-keyword">await</span> func(grpc_request(**resp_dict))))<br><br>    <span class="hljs-comment"># 注册路由</span><br>    app.add_route(url, _route, methods=[<span class="hljs-string">&quot;POST&quot;</span>])<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">create_app</span>() -&gt; Starlette:</span><br>    <span class="hljs-comment"># 绑定路由</span><br>    app: Starlette = Starlette()<br><br>    <span class="hljs-comment"># 通过调用上面段parse函数得到了gRPC对应的数据再通过gen_route来自动注册路由</span><br>    <span class="hljs-keyword">for</span> parse_result_list <span class="hljs-keyword">in</span> parse(user_pb2_grpc.UserStub):<br>        gen_route(<br>            app,<br>            user_pb2_grpc.UserStub,<br>            *parse_result_list,<br>        )<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_before_server_start</span>() -&gt; <span class="hljs-keyword">None</span>:</span><br>        <span class="hljs-comment"># 启动时绑定gRPC客户端对应的channel</span><br>        app.state.channel = grpc.aio.insecure_channel(<span class="hljs-string">&quot;0.0.0.0:9000&quot;</span>)<br><br>    app.add_event_handler(<span class="hljs-string">&quot;startup&quot;</span>, _before_server_start)<br>    <span class="hljs-keyword">return</span> app<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    <span class="hljs-keyword">import</span> uvicorn  <span class="hljs-comment"># type: ignore</span><br><br>    uvicorn.run(create_app(), log_level=<span class="hljs-string">&quot;debug&quot;</span>)<br></code></pre></td></tr></table></figure><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5.总结"></a>5.总结</h2><p>至此，gRPC网关的最核心的实现已经编写完成了，不过可以发现gRPC的响应体并没有被使用，同时这个实现非常简单，不容易拓展，可以通过<a href="https://so1n.me/pait-zh-doc/7_gRPC_gateway/#6gateway-route">自定义Gateway Route路由函数</a>了解更多的拓展。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;就目前而言，在大多数场景中，用户侧的客户端和服务端还是通过HTTP进行交互，然后服务端内部各种服务再通过过各种协议进行交互，所以在采用了gR</summary>
      
    
    
    <content src="https://ftp.bmp.ovh/imgs/2022/02/bd67e15aa8d46101.png" type="image"/>
    
    
    <category term="Python-gRPC实践" scheme="http://so1n.me/categories/Python-gRPC%E5%AE%9E%E8%B7%B5/"/>
    
    
    <category term="Python" scheme="http://so1n.me/tags/Python/"/>
    
    <category term="gRPC" scheme="http://so1n.me/tags/gRPC/"/>
    
  </entry>
  
  <entry>
    <title>Python-gRPC实践(5)--简述gRPC的高级用法</title>
    <link href="http://so1n.me/2022/04/16/Python-gRPC%E5%AE%9E%E8%B7%B5(5)--%E7%AE%80%E8%BF%B0gRPC%E7%9A%84%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95/"/>
    <id>http://so1n.me/2022/04/16/Python-gRPC%E5%AE%9E%E8%B7%B5(5)--%E7%AE%80%E8%BF%B0gRPC%E7%9A%84%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95/</id>
    <published>2022-04-16T12:35:24.000Z</published>
    <updated>2022-04-20T15:57:59.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><a href="https://so1n.me/2022/04/07/Python-gRPC%E5%AE%9E%E8%B7%B5(3)--%E4%BD%BF%E7%94%A8Python%E5%AE%9E%E7%8E%B0gRPC%E6%9C%8D%E5%8A%A1/">Python-gRPC实践(3)–使用Python实现gRPC服务</a><br>讲述了如何编写和使用gRPC服务，而本文主要讲述一些业务之外的gRPC用法。</p><h2 id="1-优雅的重启服务"><a href="#1-优雅的重启服务" class="headerlink" title="1.优雅的重启服务"></a>1.优雅的重启服务</h2><p>线上运行的服务永远都不会一尘不变的，特别是对于微服务，服务的更新频率越来越快，需要重启的次数也就变多了，而每次重启都会导致服务正在处理的请求被强行关闭，所以我们需要优雅的重启服务，确保在滚动更新服务的时候不会影响到客户端，好在gRPC自带了一个类似的功能，代码例子如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">from</span> signal <span class="hljs-keyword">import</span> signal, SIGTERM<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">serve</span>():</span><br>    <span class="hljs-comment"># 启动端口配置，默认为启用</span><br>    options = [(<span class="hljs-string">&quot;grpc.so_reuseport&quot;</span>, <span class="hljs-number">1</span>)]<br>    <span class="hljs-comment"># 正常的运行服务</span><br>    server = grpc.server(futures.ThreadPoolExecutor(max_workers=<span class="hljs-number">10</span>), options=options)<br>    ...<br>    server.add_insecure_port(<span class="hljs-string">&quot;0.0.0.0:9000&quot;</span>)<br>    server.start()<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sig_handle</span>(<span class="hljs-params">*args</span>):</span><br>        <span class="hljs-comment"># 调用server.stop函数，调用stop(30)后，该服务会拒绝客户端新的请求，并返回一个threading.Event</span><br>        event = server.stop(<span class="hljs-number">30</span>)<br>        <span class="hljs-comment"># 调用event.wait()后，服务会一直等着，直到30秒后服务才会关闭，关闭之前服务还是能正常处理请求</span><br>        event.wait()<br>    <br>    <span class="hljs-comment"># 接收一个SIGTERM信号的注册</span><br>    signal(SIGTERM, sig_handle)<br>    <span class="hljs-comment"># 等待服务停止</span><br>    server.wait_for_termination()<br></code></pre></td></tr></table></figure><p>这个代码假设gRPC服务以端口复用模式运行(默认启用), 代码通过加上<code>SIGTERM</code>信号的对应回调后，我们的更新服务的逻辑就可以进行一些调整。首先是运行一个全新的gRPC服务在9000端口，这时候请求会分流到新和旧的gRPC服务，然后我们主动向旧的服务进程发送<code>SIGTERM</code>信号，这时旧服务就能开始拒绝新的请求，请求只会流向新的gRPC服务，之后我们只需要等服务自动关闭即可。</p><p>不过光这种方法还是不够，还需要注册中心等，具体实现逻辑可以通过<a href="https://so1n.me/2021/08/28/RPC%E6%A1%86%E6%9E%B6%E7%BC%96%E5%86%99%E5%AE%9E%E8%B7%B5--%E4%BC%98%E9%9B%85%E7%9A%84%E9%87%8D%E5%90%AF/">RPC框架编写实践–服务的优雅的重启</a>了解。</p><blockquote><p>代码中的options是用于配置gRPC服务的一些功能，可以从gRPC c源码中获悉<a href="https://github.com/grpc/grpc/blob/v1.38.x/include/grpc/impl/codegen/grpc_types.h">grpc_types.h</a>,也可以通过代码生成的页面获取比较容易看到的<a href="https://grpc.github.io/grpc/core/group__grpc__arg__keys.html#gaa3f69f6e1e789e36d2d9c6083fec0257">说明文档</a>。此外还有一些配置是需要传入一个Dict对象，可以参考<a href="https://github.com/grpc/grpc-proto/blob/master/grpc/service_config/service_config.proto">service_config.proto</a></p></blockquote><blockquote><p>更多优雅的重启说明见<a href="https://github.com/grpc/proposal/blob/master/L54-python-server-wait.md">gRPC Python Server Wait API</a></p></blockquote><h2 id="2-重试机制"><a href="#2-重试机制" class="headerlink" title="2.重试机制"></a>2.重试机制</h2><p>gRPC服务是通过网络来传输请求的，所以可能会因为网络波动等原因造成请求失败，这时候就需要重试机制来使请求能成功通信了，但是引入重试机制后可能会带来一些负面的问题：</p><ul><li>比如服务端已经扛不住了，而客户端还一直重试，造成持续的增加服务端压力</li><li>接口不是幂等，某个请求实际上已经处理完了，但是由于网络问题导致客户端认为服务端返回了错误，从而客户端进行了重试，最后导致服务端又再次处理请求，导致对应的数据发生了改变。</li></ul><p>于是，gRPC抽象出一套重试机制，使用户可以灵活为自己想要的方法应用对应的重试机制，这个重试机制包括的最大重试次数，指数退避，可重试状态码等等，比如下面的代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BookGrpcService</span>(<span class="hljs-params">BookSocialGrpcServiceMixin, BookManagerGrpcServiceMixin</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, host: <span class="hljs-built_in">str</span>, port: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        service_config_json = json.dumps(&#123;<br>            <span class="hljs-string">&quot;methodConfig&quot;</span>: [&#123;<br>                <span class="hljs-string">&quot;name&quot;</span>: [<br>                    &#123;<br>                        <span class="hljs-string">&quot;service&quot;</span>: <span class="hljs-string">&quot;book_manager.BookManager&quot;</span>,<br>                        <span class="hljs-string">&quot;method&quot;</span>: <span class="hljs-string">&quot;create_book&quot;</span><br>                    &#125;,<br>                    &#123;<br>                        <span class="hljs-string">&quot;service&quot;</span>: <span class="hljs-string">&quot;book_manager.BookManager&quot;</span>,<br>                        <span class="hljs-string">&quot;method&quot;</span>: <span class="hljs-string">&quot;delete_book&quot;</span><br>                    &#125;,<br>                ],<br>                <span class="hljs-string">&quot;retryPolicy&quot;</span>: &#123;<br>                    <span class="hljs-string">&quot;maxAttempts&quot;</span>: <span class="hljs-number">5</span>,<br>                    <span class="hljs-string">&quot;initialBackoff&quot;</span>: <span class="hljs-string">&quot;0.1s&quot;</span>,<br>                    <span class="hljs-string">&quot;maxBackoff&quot;</span>: <span class="hljs-string">&quot;1s&quot;</span>,<br>                    <span class="hljs-string">&quot;backoffMultiplier&quot;</span>: <span class="hljs-number">2</span>,<br>                    <span class="hljs-string">&quot;retryableStatusCodes&quot;</span>: [<span class="hljs-string">&quot;UNAVAILABLE&quot;</span>],<br>                &#125;,<br>            &#125;]<br>        &#125;)<br>        options = []<br>        <span class="hljs-comment"># <span class="hljs-doctag">NOTE:</span> 启动重试模式， 默认在v1.40.0后自动启用</span><br>        options.append((<span class="hljs-string">&quot;grpc.enable_retries&quot;</span>, <span class="hljs-number">1</span>))<br>        <span class="hljs-comment"># 重试的一些参数配置</span><br>        options.append((<span class="hljs-string">&quot;grpc.service_config&quot;</span>, service_config_json))<br><br><br>        self.channel: grpc.Channel = grpc.intercept_channel(<br>            grpc.insecure_channel(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;host&#125;</span>:<span class="hljs-subst">&#123;port&#125;</span>&quot;</span>), CustomerTopInterceptor(), options=options<br>        )<br>        BookSocialGrpcServiceMixin.__init__(self, self.channel)<br>        BookManagerGrpcServiceMixin.__init__(self, self.channel)<br></code></pre></td></tr></table></figure><p>该代码复制于<a href="https://github.com/so1n/grpc-example-api-backend-service/blob/part-1/grpc_service/book_service.py#L68">grpc-example-api-backend-service</a>，并进行一点拓展，可以看到在调用<code>grpc.intercept_channel</code>进行初始化时，传入了一个options参数，这样在创建channel时会自动应用到对应的配置。</p><p>这个配置中，<code>grpc.enable_retries</code>为1代表启用了重试，而<code>grpc.service_config</code>接收到的是一个服务配置方法，具体可以访问<a href="https://github.com/grpc/grpc-proto/blob/ec886024c2f7b7f597ba89d5b7d60c3f94627b17/grpc/service_config/service_config.proto#L38">service_config.proto</a>了解，不过需要注意的是，在传入<code>grpc.service_config</code>时，传的是一个Dict的对应json序列化字符串。</p><p>接下来就在<code>grpc.service_config</code>的<code>methodConfig</code>中，我们传入了一个数组，这个数组里面只有一个Dict，这个Dict通过<code>name</code>指定了只有<code>book_manager.BookManager</code>的<code>create_book</code>方法和<code>delete_book</code>方法会应用到重试的规则，如果这个配置为:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>    <span class="hljs-attr">&quot;methodConfig&quot;</span>: [&#123;<br>        <span class="hljs-attr">&quot;name&quot;</span>: [&#123;&#125;],<br>        <span class="hljs-attr">&quot;retryPolicy&quot;</span>: &#123;<br>            <span class="hljs-attr">&quot;maxAttempts&quot;</span>: <span class="hljs-number">5</span>,<br>            <span class="hljs-attr">&quot;initialBackoff&quot;</span>: <span class="hljs-string">&quot;0.1s&quot;</span>,<br>            <span class="hljs-attr">&quot;maxBackoff&quot;</span>: <span class="hljs-string">&quot;1s&quot;</span>,<br>            <span class="hljs-attr">&quot;backoffMultiplier&quot;</span>: <span class="hljs-number">2</span>,<br>            <span class="hljs-attr">&quot;retryableStatusCodes&quot;</span>: [<span class="hljs-string">&quot;UNAVAILABLE&quot;</span>],<br>        &#125;,<br>    &#125;]<br>&#125;<br></code></pre></td></tr></table></figure><p>则会应用到所有的方法中。<br>在这个配置中，<code>name</code>负责指定应用范围，而<code>retryPolicy</code>负责指定应用规则，方便用户调整重试逻辑，他们的含义如下:</p><ul><li>maxAttempts: 最大的重试次数，必须大于，如果大于5则他的值为5</li><li>Backoff系列: 指数退避参数，第一次重试是在random(0, initalBackoff)秒后进行的，而后续的重试间隔计算为min(initial_backoff*backoff_multiplier**(n-1), max_backoff)).</li><li>retryableStatusCodes: 指定什么样的响应状态码才需要重试，具体参照gRPC状态码文档。</li></ul><p>开发者只要合理的进行配置，那么就能简单的应用重试机制，但是光看这点配置还是没办法解决重试导致机器过载的问题，所以gRPC还包含另外一组参数重试限流策略–<a href="https://github.com/grpc/grpc-proto/blob/ec886024c2f7b7f597ba89d5b7d60c3f94627b17/grpc/service_config/service_config.proto#L436">retryThrottling</a>来解决这个问题，这个配置的含义是当客户端的失败和成功超过某个阈值时，gRPC会通过金庸重试策略来防止由于重试导致服务器过载，使用方法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BookGrpcService</span>(<span class="hljs-params">BookSocialGrpcServiceMixin, BookManagerGrpcServiceMixin</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, host: <span class="hljs-built_in">str</span>, port: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        service_config_json = json.dumps(&#123;<br>            <span class="hljs-string">&quot;methodConfig&quot;</span>: [&#123;<br>                <span class="hljs-string">&quot;name&quot;</span>: [<br>                    &#123;<br>                        <span class="hljs-string">&quot;service&quot;</span>: <span class="hljs-string">&quot;book_manager.BookManager&quot;</span>,<br>                        <span class="hljs-string">&quot;method&quot;</span>: <span class="hljs-string">&quot;create_book&quot;</span><br>                    &#125;,<br>                    &#123;<br>                        <span class="hljs-string">&quot;service&quot;</span>: <span class="hljs-string">&quot;book_manager.BookManager&quot;</span>,<br>                        <span class="hljs-string">&quot;method&quot;</span>: <span class="hljs-string">&quot;delete_book&quot;</span><br>                    &#125;,<br>                ],<br>                <span class="hljs-string">&quot;retryPolicy&quot;</span>: &#123;<br>                    <span class="hljs-string">&quot;maxAttempts&quot;</span>: <span class="hljs-number">5</span>,<br>                    <span class="hljs-string">&quot;initialBackoff&quot;</span>: <span class="hljs-string">&quot;0.1s&quot;</span>,<br>                    <span class="hljs-string">&quot;maxBackoff&quot;</span>: <span class="hljs-string">&quot;1s&quot;</span>,<br>                    <span class="hljs-string">&quot;backoffMultiplier&quot;</span>: <span class="hljs-number">2</span>,<br>                    <span class="hljs-string">&quot;retryableStatusCodes&quot;</span>: [<span class="hljs-string">&quot;UNAVAILABLE&quot;</span>],<br>                &#125;,<br>            &#125;],<br>            <span class="hljs-string">&quot;retryThrottling&quot;</span>: &#123;<br>                <span class="hljs-string">&quot;maxTokens&quot;</span>: <span class="hljs-number">10</span>,<br>                <span class="hljs-string">&quot;tokenRatio&quot;</span>: <span class="hljs-number">0.1</span><br>            &#125;<br>        &#125;)<br>        options = []<br>        <span class="hljs-comment"># <span class="hljs-doctag">NOTE:</span> 启动重试模式， 默认在v1.40.0后自动启用</span><br>        options.append((<span class="hljs-string">&quot;grpc.enable_retries&quot;</span>, <span class="hljs-number">1</span>))<br>        <span class="hljs-comment"># 重试的一些参数配置</span><br>        options.append((<span class="hljs-string">&quot;grpc.service_config&quot;</span>, service_config_json))<br><br><br>        self.channel: grpc.Channel = grpc.intercept_channel(<br>            grpc.insecure_channel(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;host&#125;</span>:<span class="hljs-subst">&#123;port&#125;</span>&quot;</span>), CustomerTopInterceptor(), options=options<br>        )<br>        BookSocialGrpcServiceMixin.__init__(self, self.channel)<br>        BookManagerGrpcServiceMixin.__init__(self, self.channel)<br></code></pre></td></tr></table></figure><p>在这段代码中，通过引入与<code>methodConfig</code>同级的<code>retryThrottling</code>配置，之后gRPC客户端会维护一个tokenCount的变量，它的初始值为maxToken,值得范围在0-maxToken波动，之后每一次请求成功时，tokenCount都会递增<code>tokenRatio</code>的值，每次请求失败时，tokenCount都会递减1，之后在重试之前如果发现tokaneCount小于或等于maxToken/2时，gRPC客户端不会进行重试且不会进行对冲。需要注意的是<code>tokenRatio</code>的设定范围只能在0-1之间，且只支持小数点后3位，如0.5466将为视为0.546，而MmaxTOkens的取值范围为0-1000的整数值。</p><blockquote><p>目前Python gRPC不支持对冲，更多gRPC重试内容和设计见<a href="https://github.com/grpc/proposal/blob/master/A6-client-retries.md">A6-client-retries</a></p></blockquote><h2 id="3-调用时参数"><a href="#3-调用时参数" class="headerlink" title="3.调用时参数"></a>3.调用时参数</h2><h2 id="3-1-超时"><a href="#3-1-超时" class="headerlink" title="3.1.超时"></a>3.1.超时</h2><p>超时机制， 是一个简单又方便的控制网络请求异常的一种方法， 它可以保证服务稳定(本质是快速失败)， 良好的超时控制策略可以尽快的释放高延迟的请求，避免请求堆积。对于一般的HTTP请求，只需要在客户端添加一个超时参数，然后客户端检查在超时时间范围内还没收到对应的网络请求时，就会单方面关闭请求，这种处理方法在大多数情况下是没问题的，但在遇到阻塞性调用等情况时，客户端单方面关闭了请求，但服务端还在继续处理请求，并做出响应，不过客户端已经关闭了连接了，它无法收到该响应，这样就造成了服务端都性能浪费了。要解决这个问题，就需要引入一个超时传递的机制，使服务端能获取到本次请求的指定超时时间，并做出响应的操作。</p><p>好在gRPC已经自带了超时和超时传递的功能了，只需要在调用时添加timeout参数即可，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserGrpcServiceMixin</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, channel: grpc.Channel</span>):</span><br>        self.user_stub: user_service.UserStub = user_service.UserStub(channel)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">create_user</span>(<span class="hljs-params">self, *, uid: <span class="hljs-built_in">str</span>, user_name: <span class="hljs-built_in">str</span>, password: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        self.user_stub.create_user(user_message.CreateUserRequest(uid=uid, user_name=user_name, password=password), timeout=<span class="hljs-number">10</span>)<br></code></pre></td></tr></table></figure><p>这样一来，客户端在调用的时候，就会进行倒计时，如果10秒内任然没有收到响应，那么它就会抛出超时异常，而服务端可以通过<code>context.time_remaining()</code>获取到还有多少剩余时间，并在主要逻辑代码使用，如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserService</span>(<span class="hljs-params">user_service.UserServicer</span>):</span><br><span class="hljs-meta">    @conn_proxy()</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">create_user</span>(<span class="hljs-params">self, request: user_message.CreateUserRequest, context: grpc.ServicerContext</span>) -&gt; Empty:</span><br>        <span class="hljs-keyword">with</span> TimeoutContext(context.time_remaining()):<br>            user_dal.create_user(uid=request.uid, user_name=request.user_name, password=request.password)<br>        <span class="hljs-keyword">return</span> Empty()<br></code></pre></td></tr></table></figure><p>该代码引入一个TimeoutContext对象，这个对象会托管该作用域，如果该作用域的运行时长超多指定的时间，则会直接抛出错误，具体见<a href="https://so1n.me/2021/10/22/RPC%E6%A1%86%E6%9E%B6%E7%BC%96%E5%86%99%E5%AE%9E%E8%B7%B5--%E8%B6%85%E6%97%B6%E4%B8%8E%E8%B6%85%E6%97%B6%E4%BC%A0%E9%80%92">RPC框架编写实践–超时与超时传递</a></p><h2 id="3-2-等待服务就绪"><a href="#3-2-等待服务就绪" class="headerlink" title="3.2.等待服务就绪"></a>3.2.等待服务就绪</h2><p>一般的gRPC客户端在请求服务端都时候，如果发现服务端无法及时传输数据，比如channel处于<code>TRANSIENT_FAILURE</code>或<code>SHUTDOWN</code>状态时，客户端应该马上响应失败，这种方法被称为快速失败，但是服务端还有其它的状态如<code>CONNECTING</code>、<code>READY</code>或<code>IDLE</code>，这时候channel处于准备状态，还无法提供服务，但是在稍后将可以提供服务，比如客户端服务端同时启动，但因为短暂的网络故障导致服务端不可用等场景。这时候就可以使用<code>wait-for-ready</code>功能，使用<code>wait-for-ready</code>的调用将自动等待，直到服务器准备好接受请求时再发送，如下例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserGrpcServiceMixin</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, channel: grpc.Channel</span>):</span><br>        self.user_stub: user_service.UserStub = user_service.UserStub(channel)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">create_user</span>(<span class="hljs-params">self, *, uid: <span class="hljs-built_in">str</span>, user_name: <span class="hljs-built_in">str</span>, password: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        self.user_stub.create_user(user_message.CreateUserRequest(uid=uid, user_name=user_name, password=password), wait_for_ready=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure><p>这样一来在调用<code>create_user</code>时，如果服务端还处于准备阶段，那么他会一直等待，直到服务端处于运行状态，需要注意的是，等待时间不会超过timeout指定的时间。</p><h2 id="4-数据类型的转换"><a href="#4-数据类型的转换" class="headerlink" title="4.数据类型的转换"></a>4.数据类型的转换</h2><p>在演示的代码<a href="https://github.com/so1n/grpc-example-common/blob/part-1/grpc_example_common/helper/field.py">grpc_example_common.helper.field</a>中，我编写了几个参数，用于做Protobuf文件的数据类型转换，这些实现是非常简陋的，有些类型并没有考虑到，不过官方提供好了数据类型的转换，这些功能都位于<a href="https://googleapis.dev/python/protobuf/latest/google/protobuf/json_format.html">google.protobuf.json_format</a>之中，大多数我们只要用<code>json_format.ParseDict</code>或者是<code>json_format.MessageToDict</code>即可，不过有些时候我们需要进行一些定制化，但是json_format并没有开放出对应的接口，我们只能使用一些奇怪的方法来定制化，比如<code>json_format.ParseDict</code>，我们只要重置<code>json_format._ConvertScalarFieldValue</code>方法即可，用法如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">from</span> decimal <span class="hljs-keyword">import</span> Decimal<br><span class="hljs-keyword">from</span> google.protobuf <span class="hljs-keyword">import</span> json_format<br><span class="hljs-keyword">from</span> grpc_example_common.protos.book.social_pb2 <span class="hljs-keyword">import</span> GetBookLikesResult<br><br><br><span class="hljs-comment"># 获取到原来的用法</span><br>_ConvertScalarFieldValue = json_format._ConvertScalarFieldValue<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">ConvertScalarFieldValue</span>(<span class="hljs-params">value, field, path, require_str=<span class="hljs-literal">False</span></span>):</span><br>    <span class="hljs-comment"># 制定我们的规则</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(value, <span class="hljs-built_in">str</span>):<br>        <span class="hljs-comment"># 字符串添加一个faker</span><br>        value = <span class="hljs-string">&quot;faker&quot;</span> + value<br>    <span class="hljs-keyword">elif</span> <span class="hljs-built_in">isinstance</span>(value, Decimal):<br>        <span class="hljs-comment"># Decimal就+10</span><br>        value = <span class="hljs-built_in">int</span>(value) + <span class="hljs-number">10</span><br>    <span class="hljs-comment"># 最后再交给原来的方法处理</span><br>    <span class="hljs-keyword">return</span> _ConvertScalarFieldValue(value, field, path, require_str)<br><br><span class="hljs-built_in">setattr</span>(json_format, <span class="hljs-string">&#x27;_ConvertScalarFieldValue&#x27;</span>, ConvertScalarFieldValue)<br><br><br>parse_message = json_format.ParseDict(&#123;<span class="hljs-string">&quot;isbn&quot;</span>: <span class="hljs-string">&quot;xxx&quot;</span>, <span class="hljs-string">&quot;book_like&quot;</span>: Decimal(<span class="hljs-string">&quot;2.0&quot;</span>)&#125;, GetBookLikesResult)<br><span class="hljs-comment"># 输出符合我们的预期</span><br>print(parse_message.book_like)<br><span class="hljs-comment"># --&gt; 12</span><br>print(parse_message.isbn)<br><span class="hljs-comment"># --&gt; fakerxxx</span><br></code></pre></td></tr></table></figure><p>可以看到输出与符合我们定义的规则，而对于<code>json_format.MessageToDict</code>，可以直接修改它使用的<code>_Printer</code>中的<code>_FieldToJsonObject</code>方法，并创建一个全新的<code>MessageToDict</code>来调用到我们编写的<code>Printer</code>的类，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">from</span> google.protobuf <span class="hljs-keyword">import</span> json_format<br><span class="hljs-keyword">from</span> grpc_example_common.protos.book.social_pb2 <span class="hljs-keyword">import</span> GetBookLikesResult<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Printer</span>(<span class="hljs-params">json_format._Printer</span>):</span>  <span class="hljs-comment"># noqa</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_FieldToJsonObject</span>(<span class="hljs-params">self, field, value</span>):</span><br>        <span class="hljs-comment"># 如果是int类型，就加10</span><br>        <span class="hljs-keyword">if</span> field.cpp_type <span class="hljs-keyword">in</span> json_format._INT_TYPES:<br>            <span class="hljs-keyword">return</span> value+<span class="hljs-number">10</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>()._FieldToJsonObject(field, value)<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">MessageToDict</span>(<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">    message,</span></span><br><span class="hljs-function"><span class="hljs-params">    including_default_value_fields=<span class="hljs-literal">False</span>,</span></span><br><span class="hljs-function"><span class="hljs-params">    preserving_proto_field_name=<span class="hljs-literal">False</span>,</span></span><br><span class="hljs-function"><span class="hljs-params">    use_integers_for_enums=<span class="hljs-literal">False</span>,</span></span><br><span class="hljs-function"><span class="hljs-params">    descriptor_pool=<span class="hljs-literal">None</span>,</span></span><br><span class="hljs-function"><span class="hljs-params">    float_precision=<span class="hljs-literal">None</span></span>):</span><br>    printer = Printer(<br>        including_default_value_fields,<br>        preserving_proto_field_name,<br>        use_integers_for_enums,<br>        descriptor_pool,<br>        float_precision=float_precision)<br>    <span class="hljs-comment"># pylint: disable=protected-access</span><br>    <span class="hljs-keyword">return</span> printer._MessageToJsonObject(message)<br><br><br>print(MessageToDict(GetBookLikesResult(book_like=<span class="hljs-number">10</span>)))<br><span class="hljs-comment"># --&gt; 20</span><br></code></pre></td></tr></table></figure><p>通过输出后可以发现，输出的结果是20，符合我们的定义的规则。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://so1n.me/2022/04/07/Python-gRPC%E5%AE%9E%E8%B7%B5(3)--</summary>
      
    
    
    <content src="https://ftp.bmp.ovh/imgs/2022/02/bd67e15aa8d46101.png" type="image"/>
    
    
    <category term="Python-gRPC实践" scheme="http://so1n.me/categories/Python-gRPC%E5%AE%9E%E8%B7%B5/"/>
    
    
    <category term="Python" scheme="http://so1n.me/tags/Python/"/>
    
    <category term="gRPC" scheme="http://so1n.me/tags/gRPC/"/>
    
  </entry>
  
  <entry>
    <title>Python-gRPC实践(4)--简述gRPC拦截器</title>
    <link href="http://so1n.me/2022/04/13/Python-gRPC%E5%AE%9E%E8%B7%B5(4)--gRPC%E6%8B%A6%E6%88%AA%E5%99%A8/"/>
    <id>http://so1n.me/2022/04/13/Python-gRPC%E5%AE%9E%E8%B7%B5(4)--gRPC%E6%8B%A6%E6%88%AA%E5%99%A8/</id>
    <published>2022-04-13T12:35:24.000Z</published>
    <updated>2022-04-13T17:09:17.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>世界上没有百分之百不会挂的服务，只能人为的去增加服务的可用性，为了能让服务的可用性增加，需要为服务添加服务治理的功能，而在gRPC中，可以通过拦截器实现一些服务治理的功能。</p><span id="more"></span><h2 id="1-什么是拦截器"><a href="#1-什么是拦截器" class="headerlink" title="1.什么是拦截器"></a>1.什么是拦截器</h2><p>在<code>Python</code>中，很少有框架把自己的功能称为拦截器，反而都称为中间件或者是钩子，gRPC的拦截器功能与<code>Python</code>Web框架常用的中间件基本一样，它主要的功能是可以在调用函数之前，之后已经发生异常时能够捕获到对应的数据，比如如下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">demo_rpc_method</span>():</span><br>    <span class="hljs-comment"># run before code</span><br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-keyword">pass</span>  <span class="hljs-comment"># rpc logic</span><br>    <span class="hljs-keyword">except</span> Exception:<br>        <span class="hljs-keyword">pass</span>  <span class="hljs-comment"># exc code</span><br>    <span class="hljs-keyword">finally</span>:<br>        <span class="hljs-comment"># run after code</span><br></code></pre></td></tr></table></figure><p>这段代码提现了拦截器的主要特点：</p><ul><li>1.裹住了一个RPC调用逻辑</li><li>2.能够在裹住的逻辑调用之前，之后以及调用异常的时候自定义数据</li></ul><p>对于<code>Python</code>开发人员来说，看到这思路后脑子里的第一个想法就是可以通过<code>Python</code>的装饰器轻松的实现<code>gRPC</code>拦截器的逻辑。</p><p>所以在官方尚未敲定拦截器实现的时候，大家也都是使用装饰器来实现拦截器的，比如下面这段代码（源码见<a href="https://github.com/so1n/grpc-example-common/blob/part-1/grpc_example_common/helper/grpc_wrapper.py#L25">grpc_example_common/helper/grpc_wrapper.py</a>）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">grpc_client_func_wrapper</span>(<span class="hljs-params">*args: Any, **kwargs: Any</span>) -&gt; Callable:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">wrapper</span>(<span class="hljs-params">func: Callable</span>) -&gt; Callable:</span><br>        <span class="hljs-comment"># func是装饰器装饰的一个方法</span><br><span class="hljs-meta">        @wraps(<span class="hljs-params">func</span>)</span><br>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_wrapper</span>(<span class="hljs-params">*_args: Any, **_kwargs: Any</span>) -&gt; Any:</span><br>            <span class="hljs-comment"># 查看调用段方法是否有指定metadata参数，如果没有就定义一个</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;metadata&quot;</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> _kwargs:<br>                _kwargs[<span class="hljs-string">&quot;metadata&quot;</span>] = []<br>            <span class="hljs-keyword">return</span> func(*_args, **_kwargs)<br><br>        <span class="hljs-keyword">return</span> _wrapper<br><br>    <span class="hljs-keyword">return</span> wrapper<br></code></pre></td></tr></table></figure><p>这是我目前还在用的一个通过装饰器实现的拦截器，因为目前gRPC的客户端在调用方法没定义<code>metadata</code>参数时，<code>gRPC</code>客户端拦截器是没办法去更改<code>metadata</code>参数的，强行修改还会报错，而<code>meatdata</code>参数类似于HTTP的Header参数，很多通过拦截器实现的功能如链路追踪，身份校验等功能的实现都需要通过拦截器更改或写入<code>metadata</code>参数来实现，所以这个装饰器一直保留着。</p><p>既然有了装饰器，那为什么gRPC最终还是选择拦截器这个方案呢，原因是装饰器虽然很灵活，但是本身有很多缺点：</p><ul><li>0.装饰器只能用于方法上，如果遇到一个无法调用到指定的方法的请求，那么这个请求就无法没监控到。</li><li>1.需要显式的为每个方法添加装饰器。</li><li>2.过多的装饰器会变得非常混乱。</li><li>3.上篇文章提到的由于装饰器导致需要延后声明才能使方法mock生效。</li></ul><blockquote><p>Note： 可以通过<a href="https://github.com/so1n/grpc-example-common/blob/part-1/grpc_example_common/helper/grpc_wrapper.py#L38">grpc_example_common/helper/grpc_wrapper.py</a>函数自动应用装饰器，使用方法见<a href="https://github.com/so1n/grpc-example-api-backend-service/blob/master/grpc_service/book_service.py#L19">grpc_service/book_service.py</a></p></blockquote><h2 id="2-如何使用拦截器"><a href="#2-如何使用拦截器" class="headerlink" title="2.如何使用拦截器"></a>2.如何使用拦截器</h2><p>由于装饰器自己带有一些缺点，所以<code>gRPC</code>最后自己定义了一个拦截器方案，不过<code>Python</code>实现gRPC拦截器API非常复杂，按照官方文档的指引，我们需要为每种请求类型定义一个拦截器，但是他们的代码却是相同的，这对开发人员来说非常的不友好，不过好在有一个<a href="https://github.com/d5h-foss/grpc-interceptor">grpc-interceptor</a>包进行了统一，使用起来非常方便，只用继承他提供的类，再覆盖intercept方法就可以同时为一对一，多对一，一对多的请求套上拦截器，比如我定义了一个可以把错误类型在不同基于<code>Python</code>实现的gRPC服务传播的拦截器：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-comment">##############</span><br><span class="hljs-comment"># 服务端拦截器 #</span><br><span class="hljs-comment">##############</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ServerCustomerTopInterceptor</span>(<span class="hljs-params">BaseInterceptor</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">intercept</span>(<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">        self,</span></span><br><span class="hljs-function"><span class="hljs-params">        next_handler_method: Callable,</span></span><br><span class="hljs-function"><span class="hljs-params">        request_proto_message: Any,</span></span><br><span class="hljs-function"><span class="hljs-params">        context: grpc.ServicerContext,</span></span><br><span class="hljs-function"><span class="hljs-params">    </span>) -&gt; Any:</span><br>        <span class="hljs-comment"># 在这个区域实现未调用方法的代码</span><br>        start_time: <span class="hljs-built_in">float</span> = time.time()<br>        return_initial_metadata: List[Tuple] = [(<span class="hljs-string">&quot;customer-user-agent&quot;</span>, <span class="hljs-string">&quot;Python3&quot;</span>)]<br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-comment"># 调用下一个拦截器或者是方法 </span><br>            <span class="hljs-keyword">return</span> next_handler_method(request_proto_message, context)<br>        <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>            <span class="hljs-comment"># 发生错误的处理，解析错误 </span><br>            <span class="hljs-keyword">if</span> self.metadata_dict.get(<span class="hljs-string">&quot;customer-user-agent&quot;</span>, <span class="hljs-string">&quot;&quot;</span>) == <span class="hljs-string">&quot;Python3&quot;</span>:<br>                return_initial_metadata.append((<span class="hljs-string">&quot;exc_name&quot;</span>, e.__class__.__name__))<br>                return_initial_metadata.append((<span class="hljs-string">&quot;exc_info&quot;</span>, <span class="hljs-built_in">str</span>(e)))<br>            logging.exception(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;context_proxy.method&#125;</span> request exc:<span class="hljs-subst">&#123;e.__class__.__name__&#125;</span> error:<span class="hljs-subst">&#123;e&#125;</span>&quot;</span>)<br>            <span class="hljs-comment"># 记住一定要把异常抛出来，这样才能走grpc的异常逻辑，否则客户端那边会解析到错误的body</span><br>            <span class="hljs-keyword">raise</span> e<br>        <span class="hljs-keyword">finally</span>:<br>            <span class="hljs-comment"># 调用方法后的逻辑，这里把metadata插入到context中</span><br>            context.send_initial_metadata(return_initial_metadata)<br>            <span class="hljs-comment"># 打印access log</span><br>            logging.info(<br>                <span class="hljs-string">f&quot;Got Request. method:<span class="hljs-subst">&#123;self.method&#125;</span>, code:<span class="hljs-subst">&#123;context.code()&#125;</span>, detail:<span class="hljs-subst">&#123;context.details()&#125;</span>, duration:<span class="hljs-subst">&#123;time.time() - start_time&#125;</span>&quot;</span><br>            )<br><span class="hljs-comment">##############</span><br><span class="hljs-comment"># 客户端拦截器 #</span><br><span class="hljs-comment">##############</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClientCustomerTopInterceptor</span>(<span class="hljs-params">BaseInterceptor</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, exc_list: Optional[List[Type[Exception]]] = <span class="hljs-literal">None</span></span>):</span><br>        <span class="hljs-comment"># 注入可用的异常</span><br>        self.exc_dict: Dict[<span class="hljs-built_in">str</span>, Type[Exception]] = &#123;&#125;<br>        <span class="hljs-keyword">for</span> key, exc <span class="hljs-keyword">in</span> <span class="hljs-built_in">globals</span>()[<span class="hljs-string">&quot;__builtins__&quot;</span>].items():<br>            <span class="hljs-keyword">if</span> inspect.isclass(exc) <span class="hljs-keyword">and</span> <span class="hljs-built_in">issubclass</span>(exc, Exception):<br>                self.exc_dict[key] = exc<br><br>        <span class="hljs-keyword">if</span> exc_list:<br>            <span class="hljs-keyword">for</span> exc <span class="hljs-keyword">in</span> exc_list:<br>                <span class="hljs-keyword">if</span> <span class="hljs-built_in">issubclass</span>(exc, Exception):<br>                    self.exc_dict[exc.__name__] = exc<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">intercept</span>(<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">        self,</span></span><br><span class="hljs-function"><span class="hljs-params">        method: Callable,</span></span><br><span class="hljs-function"><span class="hljs-params">        request_or_iterator: Any,</span></span><br><span class="hljs-function"><span class="hljs-params">        call_details: ClientCallDetailsType,</span></span><br><span class="hljs-function"><span class="hljs-params">    </span>) -&gt; GRPC_RESPONSE:</span><br>        <span class="hljs-comment"># 调用方法之前的操作，注意一定要判断metadata是否为空，如果是的话，metadata是不可写的，强行写入会报错</span><br>        <span class="hljs-keyword">if</span> call_details.metadata <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            call_details.metadata.append((<span class="hljs-string">&quot;customer-user-agent&quot;</span>, <span class="hljs-string">&quot;Python3&quot;</span>))  <span class="hljs-comment"># type: ignore</span><br>            call_details.metadata.append((<span class="hljs-string">&quot;request_id&quot;</span>, context_proxy.request_id))<br>        <span class="hljs-comment"># 调用方法</span><br>        response: GRPC_RESPONSE = method(call_details, request_or_iterator)<br>        <span class="hljs-comment"># 调用完方法的对应操作</span><br>        metadata_dict: <span class="hljs-built_in">dict</span> = &#123;item.key: item.value <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> response.initial_metadata()&#125;<br>        <span class="hljs-keyword">if</span> metadata_dict.get(<span class="hljs-string">&quot;customer-user-agent&quot;</span>) == <span class="hljs-string">&quot;Python3&quot;</span>:<br>            exc_name: <span class="hljs-built_in">str</span> = metadata_dict.get(<span class="hljs-string">&quot;exc_name&quot;</span>, <span class="hljs-string">&quot;&quot;</span>)<br>            exc_info: <span class="hljs-built_in">str</span> = metadata_dict.get(<span class="hljs-string">&quot;exc_info&quot;</span>, <span class="hljs-string">&quot;&quot;</span>)<br>            exc: Optional[Type[Exception]] = self.exc_dict.get(exc_name)<br>            <span class="hljs-keyword">if</span> exc:<br>                <span class="hljs-keyword">raise</span> exc(exc_info)<br>        <span class="hljs-keyword">return</span> response<br></code></pre></td></tr></table></figure><p>可以看到源码中的拦截器都有调用之前，调用中，调用后三大逻辑，与我们前面说的一样，给予开发者极强的自定义能力，这样一来就可以通过拦截器来实现一些服务治理的功能，对于如何实现可见<a href="https://so1n.me/categories/RPC%E6%A1%86%E6%9E%B6%E7%BC%96%E5%86%99%E5%AE%9E%E8%B7%B5/">RPC框架编写实践系列</a></p><p>实现完拦截器后就需要应用到gRPC服务中，由于<a href="https://github.com/d5h-foss/grpc-interceptor">grpc-interceptor</a>是对官方拦截器的简单安装，所以可以像官方拦截器一样应用到服务中，服务端应用拦截器可参考<a href="https://github.com/so1n/grpc-example-book-grpc-service/blob/part-1/app.py#L21">grpc-example-book-grpc-service项目</a>在<code>grpc.Server</code>初始化时通过<code>interceptors</code>参数把拦截器列表传进去，简要代码如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>(<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">    host: <span class="hljs-built_in">str</span> = <span class="hljs-string">&quot;0.0.0.0&quot;</span>, port: <span class="hljs-built_in">str</span> = <span class="hljs-string">&quot;9000&quot;</span>, ssl_port: Optional[<span class="hljs-built_in">str</span>] = <span class="hljs-literal">None</span></span></span><br><span class="hljs-function"><span class="hljs-params"></span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>    interceptor_list: List[BaseInterceptor] = [CustomerTopInterceptor()]<br>    server: grpc.server = grpc.server(<br>        futures.ThreadPoolExecutor(max_workers=<span class="hljs-number">10</span>),<br>        interceptors=interceptor_list,<br>    )<br>    manager_service.add_BookManagerServicer_to_server(ManagerService(), server)<br>    social_service.add_BookSocialServicer_to_server(SocialService(), server)<br></code></pre></td></tr></table></figure><p>而对于客户端可以参考<a href="https://github.com/so1n/grpc-example-api-backend-service/blob/master/grpc_service/book_service.py#L68">grpc-example-api-backend-service项目</a>在通过生成<code>channel</code>时，把拦截器通过参数传进去</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BookGrpcService</span>(<span class="hljs-params">BookSocialGrpcServiceMixin, BookManagerGrpcServiceMixin</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, host: <span class="hljs-built_in">str</span>, port: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        self.channel: grpc.Channel = grpc.intercept_channel(<br>            grpc.insecure_channel(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;host&#125;</span>:<span class="hljs-subst">&#123;port&#125;</span>&quot;</span>), CustomerTopInterceptor()<br>        )<br>        BookSocialGrpcServiceMixin.__init__(self, self.channel)<br>        BookManagerGrpcServiceMixin.__init__(self, self.channel)<br></code></pre></td></tr></table></figure><p>拦截器编写完成后应该去测试它，但是大多数都拦截器都依赖于一些特定的服务，如Prometheus监控依赖Prometheus，链路追踪可能依赖到的jaeger等，所以很多时候都会在测试环境或者预发布环境进行测试，但是对于其它无服务依赖的拦截器则可以使用<code>grpc_interceptor</code>包实现的测试模块来进行测试，如官方的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">from</span> grpc_interceptor <span class="hljs-keyword">import</span> ExceptionToStatusInterceptor<br><span class="hljs-keyword">from</span> grpc_interceptor.exceptions <span class="hljs-keyword">import</span> NotFound<br><span class="hljs-keyword">from</span> grpc_interceptor.testing <span class="hljs-keyword">import</span> dummy_client, DummyRequest, raises<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_exception</span>():</span><br>    special_cases = &#123;<span class="hljs-string">&quot;error&quot;</span>: raises(NotFound())&#125;<br>    <span class="hljs-comment"># 指定的拦截器</span><br>    interceptors = [ExceptionToStatusInterceptor()]<br>    <span class="hljs-comment"># 模拟一个客户端发起请求，该客户端响应的数据等于input时指定的数据</span><br>    <span class="hljs-comment"># 不过也可以通过special_cases来指定input数据对应的异常响应</span><br>    <span class="hljs-keyword">with</span> dummy_client(special_cases=special_cases, interceptors=interceptors) <span class="hljs-keyword">as</span> client:<br>        <span class="hljs-comment"># 输入input时必定会响应一个output</span><br>        <span class="hljs-keyword">assert</span> client.Execute(DummyRequest(<span class="hljs-built_in">input</span>=<span class="hljs-string">&quot;foo&quot;</span>)).output == <span class="hljs-string">&quot;foo&quot;</span><br>        <span class="hljs-comment"># 输入error时，会抛出一个对应的响应</span><br>        <span class="hljs-keyword">with</span> pytest.raises(grpc.RpcError) <span class="hljs-keyword">as</span> e:<br>            client.Execute(DummyRequest(<span class="hljs-built_in">input</span>=<span class="hljs-string">&quot;error&quot;</span>))<br>        <span class="hljs-keyword">assert</span> e.value.code() == grpc.StatusCode.NOT_FOUND<br></code></pre></td></tr></table></figure><p>通过该例子可以方便的实现一个正常请求和错误请求来测试拦截器的返回，但是对于一些内在逻辑最好通过pytest-mock或者是官方的unitest-mock来判断是否有调用到，调用几次，调用时的内容是否符合标准等等。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;世界上没有百分之百不会挂的服务，只能人为的去增加服务的可用性，为了能让服务的可用性增加，需要为服务添加服务治理的功能，而在gRPC中，可以通过拦截器实现一些服务治理的功能。&lt;/p&gt;</summary>
    
    
    <content src="https://ftp.bmp.ovh/imgs/2022/02/bd67e15aa8d46101.png" type="image"/>
    
    
    <category term="Python-gRPC实践" scheme="http://so1n.me/categories/Python-gRPC%E5%AE%9E%E8%B7%B5/"/>
    
    
    <category term="Python" scheme="http://so1n.me/tags/Python/"/>
    
    <category term="gRPC" scheme="http://so1n.me/tags/gRPC/"/>
    
  </entry>
  
  <entry>
    <title>Python的可等待对象在Asyncio的作用</title>
    <link href="http://so1n.me/2022/04/11/python&#39;s_waitable_objects_in_asyncio/"/>
    <id>http://so1n.me/2022/04/11/python&#39;s_waitable_objects_in_asyncio/</id>
    <published>2022-04-11T15:33:18.000Z</published>
    <updated>2022-06-12T14:32:22.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前记"><a href="#前记" class="headerlink" title="前记"></a>前记</h2><p>上一遍文章<a href="https://so1n.me/2021/11/08/%E5%88%9D%E8%AF%86Python%20Async%E7%9A%84%E5%AE%9E%E7%8E%B0/#3-%E5%9F%BA%E4%BA%8E%E7%94%9F%E6%88%90%E5%99%A8%E7%9A%84%E5%8D%8F%E7%A8%8B">《初识Python协程的实现》</a><br>介绍了Python是如何以生成器来实现协程的以及Python Asyncio通过Future和Task的封装来实现协程的调度，而在Python Asyncio之中Coroutines, Tasks和Future都属于可等待对象，在使用的Asyncio的过程中，经常涉及到三者的转换和调度，开发者容易在概念和作用上犯迷糊，本文主要阐述的是三者之间的关系以及他们的作用。</p><span id="more"></span><h2 id="1-Asyncio的入口"><a href="#1-Asyncio的入口" class="headerlink" title="1.Asyncio的入口"></a>1.Asyncio的入口</h2><p>协程是线程中的一种特例，协程的入口和切换都是靠事件循环来调度的，在新版的<code>Python</code>中协程的入口是<code>Asyncio.run</code>，当程序运行到<code>Asyncio.run</code>后，可以简单的理解为程序由线程模式切换为协程模式(只是方便理解，对于计算机而言，并没有这样区分)，以下是一个最小的协程例子代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> asyncio<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">0</span>)<br><br>asyncio.run(main())<br></code></pre></td></tr></table></figure><p>在这段代码中，<code>main</code>函数和<code>asyncio.sleep</code>都属于Coroutine，<code>main</code>是通过<code>asyncio.run</code>进行调用的，接下来程序也进入一个协程模式，<code>asyncio.run</code>的核心调用是<code>Runner.run</code>，它的代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Runner</span>:</span><br>    ...<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span>(<span class="hljs-params">self, coro, *, context=<span class="hljs-literal">None</span></span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;Run a coroutine inside the embedded event loop.&quot;&quot;&quot;</span><br>        <span class="hljs-comment"># 省略代码</span><br>        ...<br><br>        <span class="hljs-comment"># 把coroutine转为task</span><br>        task = self._loop.create_task(coro, context=context)<br><br>        <span class="hljs-comment"># 省略代码</span><br>        ...<br><br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-comment"># 如果传入的是Future或者coroutine，也会专为task</span><br>            <span class="hljs-keyword">return</span> self._loop.run_until_complete(task)<br>        <span class="hljs-keyword">except</span> exceptions.CancelledError:<br>        <br>        <span class="hljs-comment"># 省略代码</span><br>        ...<br></code></pre></td></tr></table></figure><p>这段代码中删去了部分其它功能和初始化的代码，可以看到这段函数的主要功能是通过<code>loop.create_task</code>方法把一个Coroutine对象转为一个Task对象，然后通过<code>loop.run_until_complete</code>等待这个Task运行结束。</p><blockquote><p>在<code>Python3.5</code>之后，<code>asycnio</code>改为C语言实现，所以本文的<code>asyncio</code>源码都来源于最后一个以<code>Python</code>实现的asycnio版本<a href="https://github.com/python/cpython/tree/v3.4.10/Lib/asyncio">Python3.4.10/Lib/asyncio</a></p></blockquote><p>可以看到，<code>Asycnio</code>并不会直接去调度Coroutine，而是把它转为Task再进行调度，这是因为在<code>Asyncio</code>中事件循环的最小调度对象就是Task。不过在<code>Asyncio</code>中并不是所有的Coroutine的调用都会先被转为Task对象再等待，比如示例代码中的<code>asyncio.sleep</code>，由于它是在<code>main</code>函数中直接await的，所以它不会被进行转换，而是直接等待，通过调用工具分析展示的图如下：<br><img   class="lazyload" data-original="https://cdn.jsdelivr.net/gh/so1n/so1n_blog_photo@master/blog_photo/16495805125721649580511667.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" ><br>在这个图示中，从<code>main</code>函数到<code>asyncio.sleep</code>函数中没有明显的<code>loop.create_task</code>等把Coroutine转为Task调用，这里之所以不用进行转换的原因不是做了一些特殊优化，而是本因如此， 这个<code>await asyncio.sleep</code>函数实际上还是会被<code>main</code>这个Coroutine转换成的<code>Task</code>继续调度到。</p><h2 id="2-两种Coroutine调用方法的区别"><a href="#2-两种Coroutine调用方法的区别" class="headerlink" title="2.两种Coroutine调用方法的区别"></a>2.两种Coroutine调用方法的区别</h2><p>在了解<code>Task</code>的调度原理之前，还是先回到最初的调用示例，看看直接用Task调用和直接用Coroutine调用的区别是什么。如下代码，我们显示的执行一个Coroutine转为Task的操作再等待，那么代码会变成下面这样:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> asyncio<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    <span class="hljs-keyword">await</span> asyncio.create_task(asyncio.sleep(<span class="hljs-number">0</span>))<br><br>asyncio.run(main())<br></code></pre></td></tr></table></figure><p>这样的代码看起来跟最初的调用示例很像，没啥区别，但是如果进行一些改变，比如增加一些休眠时间和Coroutine的调用，就能看出Task对象的作用了，现在编写两份文件，他们的代码如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-comment"># demo_coro.py</span><br><span class="hljs-keyword">import</span> asyncio<br><span class="hljs-keyword">import</span> time<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">2</span>)<br><br>s_t = time.time()<br>asyncio.run(main())<br>print(time.time() - s_t)<br><span class="hljs-comment"># // Output: 3.0028765201568604</span><br><br><span class="hljs-comment"># demo_task.py</span><br><span class="hljs-keyword">import</span> asyncio<br><span class="hljs-keyword">import</span> time<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    task_1 = asyncio.create_task(asyncio.sleep(<span class="hljs-number">1</span>))<br>    task_2 = asyncio.create_task(asyncio.sleep(<span class="hljs-number">2</span>))<br>    <span class="hljs-keyword">await</span> task_1<br>    <span class="hljs-keyword">await</span> task_2<br><br>s_t = time.time()<br>asyncio.run(main())<br>print(time.time() - s_t)<br><span class="hljs-comment"># // Output: 2.0027475357055664</span><br></code></pre></td></tr></table></figure><p>其中<code>demo_coro.py</code>进行了两次<code>await</code>调用，程序的运行总时长为3秒，而<code>demo_task.py</code>则是先把两个Coroutine对象转为Task对象，然后再进行两次<code>await</code>调用，程序的运行总时长为2秒。可以发现，<code>demo_task.py</code>的运行时长近似于其中运行最久的Task对象时长，而<code>demo_coro.py</code>的运行时长则是近似于两个Coroutine对象的总运行时长。</p><p>之所以会是这样的结果，是因为直接<code>await</code>Coroutine对象时，这段程序会一直等待，直到Coroutine对象执行完毕再继续往下走，而Task对象的不同之处就是在创建的那一刻，就已经把自己注册到事件循环之中等待被安排运行了，然后返回一个task对象供开发者等待，由于<code>asyncio.sleep</code>是一个纯IO类型的调用，所以在这个程序中，两个<code>asyncio.sleep</code>Coroutine被转为Task从而实现了并发调用。</p><h2 id="3-Task与Future"><a href="#3-Task与Future" class="headerlink" title="3.Task与Future"></a>3.Task与Future</h2><p>上述的代码之所以通过Task能实现并发调用，是因为Task中出现了一些与事件循环交互的函数，正是这些函数架起了Coroutine并发调用的可能， 不过Task是Future的一个子对象，所以在了解Task之前，需要先了解Future。</p><h2 id="3-1-Future"><a href="#3-1-Future" class="headerlink" title="3.1.Future"></a>3.1.Future</h2><p>与Coroutine只有让步和接收结果不同的是Future除了让步和接收结果功能外，它还是一个只会被动进行事件调用且带有状态的容器，它在初始化时就是<code>Pending</code>状态，这时可以被取消，被设置结果和设置异常。而在被设定对应的操作后，Future会被转化到一个不可逆的对应状态，并通过<code>loop.call_sonn</code>来调用所有注册到本身上的回调函数，同时它带有<code>__iter__</code>和<code>__await__</code>方法使其可以被<code>await</code>和<code>yield from</code>调用，它的主要代码如下： </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Future</span>:</span><br>    ...<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">set_result</span>(<span class="hljs-params">self, result</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;设置结果，并安排下一个调用&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> self._state != _PENDING:<br>            <span class="hljs-keyword">raise</span> exceptions.InvalidStateError(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;self._state&#125;</span>: <span class="hljs-subst">&#123;self!r&#125;</span>&#x27;</span>)<br>        self._result = result<br>        self._state = _FINISHED<br>        self.__schedule_callbacks()<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">set_exception</span>(<span class="hljs-params">self, exception</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;设置异常，并安排下一个调用&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> self._state != _PENDING:<br>            <span class="hljs-keyword">raise</span> exceptions.InvalidStateError(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;self._state&#125;</span>: <span class="hljs-subst">&#123;self!r&#125;</span>&#x27;</span>)<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(exception, <span class="hljs-built_in">type</span>):<br>            exception = exception()<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">type</span>(exception) <span class="hljs-keyword">is</span> StopIteration:<br>            <span class="hljs-keyword">raise</span> TypeError(<span class="hljs-string">&quot;StopIteration interacts badly with generators &quot;</span><br>                            <span class="hljs-string">&quot;and cannot be raised into a Future&quot;</span>)<br>        self._exception = exception<br>        self._state = _FINISHED<br>        self.__schedule_callbacks()<br>        self.__log_traceback = <span class="hljs-literal">True</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__await__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;设置为blocking，并接受await或者yield from调用&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self.done():<br>            self._asyncio_future_blocking = <span class="hljs-literal">True</span><br>            <span class="hljs-keyword">yield</span> self  <span class="hljs-comment"># This tells Task to wait for completion.</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self.done():<br>            <span class="hljs-keyword">raise</span> RuntimeError(<span class="hljs-string">&quot;await wasn&#x27;t used with future&quot;</span>)<br>        <span class="hljs-keyword">return</span> self.result()  <span class="hljs-comment"># May raise too.</span><br><br>    __iter__ = __await__  <span class="hljs-comment"># make compatible with &#x27;yield from&#x27;.</span><br></code></pre></td></tr></table></figure><p>单看这段代码是很难理解为什么下面这个future被调用<code>set_result</code>后就能继续往下走:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">demo</span>(<span class="hljs-params">future: asyncio.Future</span>):</span><br>    <span class="hljs-keyword">await</span> future<br>    print(<span class="hljs-string">&quot;aha&quot;</span>)<br></code></pre></td></tr></table></figure><p>这是因为Future跟Coroutine一样，没有主动调度的能力，只能通过Task和事件循环联手被调度。</p><h2 id="3-2-Task"><a href="#3-2-Task" class="headerlink" title="3.2.Task"></a>3.2.Task</h2><p>Task是Future的子类，除了继承了Future的所有方法，它还多了两个重要的方法<code>__step</code>和<code>__wakeup</code>，通过这两个方法赋予了Task调度能力，这是Coroutine和Future没有的，Task的涉及到调度的主要代码如下(说明见注释):</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Task</span>(<span class="hljs-params">futures._PyFuture</span>):</span>  <span class="hljs-comment"># Inherit Python Task implementation</span><br>                                <span class="hljs-comment"># from a Python Future implementation.</span><br><br>    _log_destroy_pending = <span class="hljs-literal">True</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, coro, *, loop=<span class="hljs-literal">None</span>, name=<span class="hljs-literal">None</span>, context=<span class="hljs-literal">None</span></span>):</span><br>        <span class="hljs-built_in">super</span>().__init__(loop=loop)<br>        <span class="hljs-comment"># 省略部分初始化代码</span><br>        ...<br><br>        <span class="hljs-comment"># 托管的coroutine</span><br>        self._coro = coro<br>        <span class="hljs-keyword">if</span> context <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            self._context = contextvars.copy_context()<br>        <span class="hljs-keyword">else</span>:<br>            self._context = context<br><br>        <span class="hljs-comment"># 通过loop.call_sonn，在Task初始化后马上就通知事件循环在下次有空的时候执行自己的__step函数</span><br>        self._loop.call_soon(self.__step, context=self._context)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__step</span>(<span class="hljs-params">self, exc=<span class="hljs-literal">None</span></span>):</span><br>        coro = self._coro<br>        <span class="hljs-comment"># 方便asyncio自省</span><br>        _enter_task(self._loop, self)<br>        <span class="hljs-comment"># Call either coro.throw(exc) or coro.send(None).</span><br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-keyword">if</span> exc <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>                <span class="hljs-comment"># 通过send预激托管的coroutine</span><br>                <span class="hljs-comment"># 这时候只会得到coroutine yield回来的数据或者收到一个StopIteration的异常</span><br>                <span class="hljs-comment"># 对于Future或者Task返回的是Self</span><br>                result = coro.send(<span class="hljs-literal">None</span>)<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-comment"># 发送异常给coroutine </span><br>                result = coro.throw(exc)<br>        <span class="hljs-keyword">except</span> StopIteration <span class="hljs-keyword">as</span> exc:<br>            <span class="hljs-comment"># StopIteration代表Coroutine运行完毕</span><br>            <span class="hljs-keyword">if</span> self._must_cancel:<br>                <span class="hljs-comment"># coroutine在停止之前被执行了取消操作，则需要显示的执行取消操作</span><br>                self._must_cancel = <span class="hljs-literal">False</span><br>                <span class="hljs-built_in">super</span>().cancel(msg=self._cancel_message)<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-comment"># 把运行完毕的值发送到结果值中</span><br>                <span class="hljs-built_in">super</span>().set_result(exc.value)<br>        <span class="hljs-comment"># 省略其它异常封装</span><br>        ...<br><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-comment"># 如果没有异常抛出</span><br>            blocking = <span class="hljs-built_in">getattr</span>(result, <span class="hljs-string">&#x27;_asyncio_future_blocking&#x27;</span>, <span class="hljs-literal">None</span>)<br>            <span class="hljs-keyword">if</span> blocking <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>                <span class="hljs-comment"># 通过Future代码可以判断，如果带有_asyncio_future_blocking属性，则代表当前result是Future或者是Task</span><br>                <span class="hljs-comment"># 意味着这个Task里面裹着另外一个的Future或者Task</span><br>                <span class="hljs-comment"># 省略Future判断</span><br>                ...<br><br>                <span class="hljs-keyword">if</span> blocking:<br>                    <span class="hljs-comment"># 代表这这个Future或者Task处于卡住的状态，</span><br>                    <span class="hljs-comment"># 此时的Task放弃了自己对事件循环的控制权，等待这个卡住的Future或者Task执行完成时唤醒一下自己</span><br>                    result._asyncio_future_blocking = <span class="hljs-literal">False</span><br>                    result.add_done_callback(self.__wakeup, context=self._context)<br>                    self._fut_waiter = result<br>                    <span class="hljs-keyword">if</span> self._must_cancel:<br>                        <span class="hljs-keyword">if</span> self._fut_waiter.cancel(msg=self._cancel_message):<br>                            self._must_cancel = <span class="hljs-literal">False</span><br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-comment"># 不能被await两次</span><br>                    new_exc = RuntimeError(<br>                        <span class="hljs-string">f&#x27;yield was used instead of yield from &#x27;</span><br>                        <span class="hljs-string">f&#x27;in task <span class="hljs-subst">&#123;self!r&#125;</span> with <span class="hljs-subst">&#123;result!r&#125;</span>&#x27;</span>)<br>                    self._loop.call_soon(<br>                        self.__step, new_exc, context=self._context)<br><br>            <span class="hljs-keyword">elif</span> result <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>                <span class="hljs-comment"># 放弃了对事件循环的控制权，代表自己托管的coroutine可能有个coroutine在运行，接下来会把控制权交给他和事件循环 </span><br>                <span class="hljs-comment"># 当前的coroutine里面即使没有Future或者Task,但是子Future可能有</span><br>                self._loop.call_soon(self.__step, context=self._context)<br>        <span class="hljs-keyword">finally</span>:<br>            _leave_task(self._loop, self)<br>            self = <span class="hljs-literal">None</span>  <span class="hljs-comment"># Needed to break cycles when an exception occurs.</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__wakeup</span>(<span class="hljs-params">self, future</span>):</span><br>        <span class="hljs-comment"># 其它Task和Future完成后会调用到该函数，接下来进行一些处理</span><br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-comment"># 回收Future的状态，如果Future发生了异常，则把异常传回给自己</span><br>            future.result()<br>        <span class="hljs-keyword">except</span> BaseException <span class="hljs-keyword">as</span> exc:<br>            <span class="hljs-comment"># This may also be a cancellation.</span><br>            self.__step(exc)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-comment"># Task并不需要自己托管的Future的结果值，而且如下注释，这样能使调度变得更快</span><br><br>            <span class="hljs-comment"># Don&#x27;t pass the value of `future.result()` explicitly,</span><br>            <span class="hljs-comment"># as `Future.__iter__` and `Future.__await__` don&#x27;t need it.</span><br>            <span class="hljs-comment"># If we call `_step(value, None)` instead of `_step()`,</span><br>            <span class="hljs-comment"># Python eval loop would use `.send(value)` method call,</span><br>            <span class="hljs-comment"># instead of `__next__()`, which is slower for futures</span><br>            <span class="hljs-comment"># that return non-generator iterators from their `__iter__`.</span><br>            self.__step()<br>        self = <span class="hljs-literal">None</span>  <span class="hljs-comment"># Needed to break cycles when an exception occurs.</span><br></code></pre></td></tr></table></figure><p>这份源码的Task对象中的<code>__setp</code>方法比较长，经过精简后可以发现他主要做的工作有三个：</p><ul><li>1.通过<code>send</code>或者<code>throw</code>来驱动Coroutine进行下一步</li><li>2.通过给被自己托管的Future或者Task添加回调来获得完成的通知并重新获取控制权</li><li>3.通过<code>loop.call_soon</code>来让步，把控制权交给事件循环</li></ul><p>单通过源码分析可能很难明白， 以下是以<code>两种Coroutine</code>的代码为例子，简单的阐述Task与事件循环调度的过程，首先是<code>demo_coro</code>，这个例子中只有一个Task：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-comment"># demo_coro.py</span><br><span class="hljs-keyword">import</span> asyncio<br><span class="hljs-keyword">import</span> time<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">2</span>)<br><br>s_t = time.time()<br>asyncio.run(main())<br>print(time.time() - s_t)<br><span class="hljs-comment"># // Output: 3.0028765201568604</span><br></code></pre></td></tr></table></figure><p>这个例子中第一步是把<code>main</code>转为一个Task，然后调用到了对应的<code>__step</code>方法，这时候<code>__step</code>方法会会调用<code>main()</code>这个Coroutine的<code>send(None)</code>方法。<br>之后整个程序的逻辑会直接转到<code>main</code>函数中的<code>await asyncio.sleep(1)</code>这个Coroutine中，<code>await asyncio.sleep(1)</code>会先生成一个Future对象，并通过<code>loop.call_at</code>告诉事件循环在1秒后激活这个Future对象，然后把对象返回。这时候逻辑会重新回到Task的<code>__step</code>方法中，<code>__step</code>发现<code>send</code>调用得到的是一个Future对象，所以就在这个Future添加一个回调，让Future完成的时候来激活自己，然后放弃了对事件循环的控制权。接着就是事件循环在一秒后激活了这个Future对象，这时程序逻辑就会执行到Future的回调，也就是Task的<code>__wakeup</code>方法，于是Task的<code>__step</code>又被调用到了，而这次遇到的是后面的<code>await asyncio.sleep(2)</code>，于是又走了一遍上面的流程。当两个<code>asyncio.sleep</code>都执行完成后，Task的<code>__step</code>方法里在对Coroutine发送一个<code>send(None)</code>后就捕获到了<code>StopIteration</code>异常，这时候Task就会通过<code>set_result</code>设置结果，并结束自己的调度流程。</p><p>可以看到<code>demo_core.py</code>中只有一个Task在负责和事件循环一起调度，事件循环的开始一定是一个Task，并通过Task来调起一个Coroutine，通过<code>__step</code>方法把后续的Future，Task,Coroutine都当成一条链来运行，而<code>demo_task.py</code>则不一样了，它有两个Task，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs Python"><br><span class="hljs-comment"># demo_task.py</span><br><span class="hljs-keyword">import</span> asyncio<br><span class="hljs-keyword">import</span> time<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    task_1 = asyncio.create_task(asyncio.sleep(<span class="hljs-number">1</span>))<br>    task_2 = asyncio.create_task(asyncio.sleep(<span class="hljs-number">2</span>))<br>    <span class="hljs-keyword">await</span> task_1<br>    <span class="hljs-keyword">await</span> task_2<br><br>s_t = time.time()<br>asyncio.run(main())<br>print(time.time() - s_t)<br><span class="hljs-comment"># // Output: 2.0027475357055664</span><br></code></pre></td></tr></table></figure><p>这个例子中第一步还是跟<code>demo_coro</code>一样，但跳转到<code>main</code>函数后就开始有区别了，首先在这函数中创建了task1和task2两个Task，他们分别都会通过<code>__step</code>方法中的<code>send</code>激活对应的<code>asyncio.sleep</code>Coroutine，然后等待对应的Future来通知自己已经完成了。而对于创建了这两个Task的main Task来说，通过<code>main</code>函数的<code>awati task_1</code>和<code>await task_2</code>来获取到他们的“控制权“。首先是通过<code>await task_1</code>语句，main Task中的<code>__step</code>方法里在调用<code>send</code>后得到的是task_1对应的Future，这时候就可以为这个Future添加一个回调，让他完成时通知自己，自己再走下一步，对于task_2也是如此。 直到最后两个task都执行完成，main Task也捕获到了<code>StopIteration</code>异常，通过<code>set_result</code>设置结果，并结束自己的调度流程。</p><p>可以看到<code>demo_task.py</code>与<code>demo_coro.py</code>有个明显的区别在于main Task在运行的生命周期中创建了两个Task，并通过<code>await</code>托管了两个Task，同时两个Task又能实现两个协程的并发，所以可以发现事件循环运行期间，当前协程的并发数永远小于事件循环中注册的Task数量。此外，如果在main Task中如果没有显式的进行<code>await</code>，那么子Task就会逃逸，不受main Task管理，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs Python"><br><span class="hljs-comment"># demo_task.py</span><br><span class="hljs-keyword">import</span> asyncio<br><span class="hljs-keyword">import</span> time<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">mutli_task</span>():</span><br>    task_1 = asyncio.create_task(asyncio.sleep(<span class="hljs-number">1</span>))<br>    task_2 = asyncio.create_task(asyncio.sleep(<span class="hljs-number">2</span>))<br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    mutli_task()<br>    <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">1.5</span>) <br><br>s_t = time.time()<br>asyncio.run(main())<br>print(time.time() - s_t)<br><span class="hljs-comment"># // Output: 1.5027475357055664 </span><br></code></pre></td></tr></table></figure><p>在这段代码中，main Task在执行到<code>mutli_task</code>时，会创建出两个task，但是在<code>__step</code>中的<code>coro.send(None)</code>调用得到的结果却是<code>await asyncio.sleep(1.5)</code>返回的Future，所以main Task只能调用到这个Future的<code>add_don_callback</code>来装载自己的<code>__wakeup</code>方法，最终导致到main Task只能托管到<code>await asyncio.sleep(1.5)</code>的Future，而<code>mutli_task</code>创建的task则逃逸了，成为另一条链的顶点Task。</p><p>不过这个程序的事件循环只管理到了<code>main Task</code>所以事件循环会一直运行，直到<code>main Task</code>运行结束的时候才退出，这时程序会跟着一起退出，所以程序的运行时间只有1.5秒左右。<br>此外由于另外的Task也是注册到这个事件循环上面，所以事件循环会帮忙把task_1执行完毕，而task_2定义的休眠时间是2秒，程序退出之前事件循环会发现有个Task尚未执行完毕，于是会对这个Task进行清理并打印一条警报。</p><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h2><p>在深入了Task，Future的源码了解后，了解了Task和Future在<code>Asyncio</code>的作用，同时也发现Task和Future都跟loop有一定的耦合，而loop也可以通过一定的方法来创建Task和Future，所以如果要真正的理解到<code>Asyncio</code>的调度原理，还需要更进入一步，通过<code>Asyncio</code>的源码来了解整个<code>Asyncio</code>的设计。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前记&quot;&gt;&lt;a href=&quot;#前记&quot; class=&quot;headerlink&quot; title=&quot;前记&quot;&gt;&lt;/a&gt;前记&lt;/h2&gt;&lt;p&gt;上一遍文章&lt;a href=&quot;https://so1n.me/2021/11/08/%E5%88%9D%E8%AF%86Python%20Async%E7%9A%84%E5%AE%9E%E7%8E%B0/#3-%E5%9F%BA%E4%BA%8E%E7%94%9F%E6%88%90%E5%99%A8%E7%9A%84%E5%8D%8F%E7%A8%8B&quot;&gt;《初识Python协程的实现》&lt;/a&gt;&lt;br&gt;介绍了Python是如何以生成器来实现协程的以及Python Asyncio通过Future和Task的封装来实现协程的调度，而在Python Asyncio之中Coroutines, Tasks和Future都属于可等待对象，在使用的Asyncio的过程中，经常涉及到三者的转换和调度，开发者容易在概念和作用上犯迷糊，本文主要阐述的是三者之间的关系以及他们的作用。&lt;/p&gt;</summary>
    
    
    <content src="https://fastly.jsdelivr.net/gh/so1n/so1n_blog_photo@master/blog_photo/16550442517731649661119526images.png" type="image"/>
    
    
    <category term="Python Asyncio" scheme="http://so1n.me/categories/Python-Asyncio/"/>
    
    
    <category term="Python" scheme="http://so1n.me/tags/Python/"/>
    
    <category term="Asyncio" scheme="http://so1n.me/tags/Asyncio/"/>
    
  </entry>
  
  <entry>
    <title>Python-gRPC实践(3)--使用Python实现gRPC服务</title>
    <link href="http://so1n.me/2022/04/07/Python-gRPC%E5%AE%9E%E8%B7%B5(3)--%E4%BD%BF%E7%94%A8Python%E5%AE%9E%E7%8E%B0gRPC%E6%9C%8D%E5%8A%A1/"/>
    <id>http://so1n.me/2022/04/07/Python-gRPC%E5%AE%9E%E8%B7%B5(3)--%E4%BD%BF%E7%94%A8Python%E5%AE%9E%E7%8E%B0gRPC%E6%9C%8D%E5%8A%A1/</id>
    <published>2022-04-07T12:35:24.000Z</published>
    <updated>2022-04-07T08:40:36.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>通过前面的文章了解到了<code>gRPC</code>是什么，以及清楚使用它的优缺点，现在终于可以开始实现一个<code>gRPC</code>服务了。</p><span id="more"></span><p>这里演示的是一个用户与书互动的项目，用户可以通过该项目进行注册，登录，注销等操作，同时也可以上传，查看和评论对应的书籍，通常情况下我们会由一个简单的Web应用来提供这些服务，现在，我们假设这个服务非常庞大，需要把他们按照功能拆分成不同的微服务了，这些服务与Web应用通过<code>gRPC</code>进行通信。</p><blockquote><p>注：由于篇幅原因，不会夹杂大量的源代码，需要跳转到<code>Github</code>中查看，同时对于业务逻辑也不会详细的介绍，所以可能需要一些接口开发经验才容易阅读懂。</p></blockquote><h2 id="1-初始化准备"><a href="#1-初始化准备" class="headerlink" title="1.初始化准备"></a>1.初始化准备</h2><p>在创建项目之前，我们需要确定我们的需求是什么，就像开发API接口一样，先了解需求，然后多方根据需求定义好接口，最后才为每个接口编写对应的代码，在这个项目中，我假定了拆分了两个服务，一个是与用户有关， 一个是与书籍有关，书籍部分又细分为书籍管理，书籍社交两部分。为此，先编写了Protobuf文件，之前在<a href="https://so1n.me/2022/02/05/Python-gRPC%E5%AE%9E%E8%B7%B5(2)--Protocol%20buffer/">Python-gRPC实践（2）–Protocol Buffer</a>中说过，我们创建<code>gRPC</code>对应的Protobuf文件应该放在一个公有的仓库中，这样就方便后续的Protobuf文件升级以及不同语言都能共享同一份Protobuf文件。</p><p>所以创建一个<code>gRPC</code>服务的第一步就是先创建一个包含Protobuf文件的仓库，我把它命名为<code>grpc-example-common</code>，具体源码可以通过<a href="https://github.com/so1n/grpc-example-common/tree/part-1">grpc-example-common</a>获取。</p><p>这个仓库中<code>pyproject.toml</code>文件的<code>tool.poetry.dependencies</code>部分如下:</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs toml"><span class="hljs-section">[tool.poetry.dependencies]</span><br><span class="hljs-attr">python</span> = <span class="hljs-string">&quot;^3.8&quot;</span><br><span class="hljs-attr">grpcio</span> = <span class="hljs-string">&quot;^1.43.0&quot;</span><br><span class="hljs-attr">grpcio-tools</span> = <span class="hljs-string">&quot;^1.43.0&quot;</span><br></code></pre></td></tr></table></figure><p>通过这部分文件可以知道这个项目是基于<code>Python3.8</code>版本的，然后用到了2个依赖分别是<code>grpcio</code>以及<code>grpcio-tools</code>，其中<code>grpcio</code>是<code>Python</code>的<code>gRPC</code>实现，它是通过c语言翻译的，所以很多底层都是c实现的，如果在使用gRPC框架的过程中找不到对应的使用方法说明，那可以直接到gRPC的c项目中找到对应的函数并查看它的函数说明进而了解该函数的作用；而另一个库<code>grpcio-tools</code>的作用是把<code>proto</code>文件转译为<code>Python</code>代码，不过单靠<code>grpcio-tools</code>转译的代码很难使用，比如是这段代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">from</span> grpc_example_common.protos.user.user_pb2 <span class="hljs-keyword">import</span> LoginUserResult <br><br><br>login_user_result: LoginUserResult = LoginUserResult()<br></code></pre></td></tr></table></figure><p>这段代码引入了由<code>grpcio-tools</code>通过用户Protobuf文件生成的<code>LoginUserResult</code>对象，开发者在后续想要使用这个对象的时候，IDE是没办法提示你这个对象有什么属性的，只能凭自己的记忆进行填写，或者回到对应的Protobuf文件查看该对象的定义：</p><figure class="highlight plain"><figcaption><span>buffer</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Protocol">message LoginUserResult &#123;<br>  string uid &#x3D; 1;<br>  string user_name &#x3D; 2;<br>  string token &#x3D; 3;<br>&#125;<br></code></pre></td></tr></table></figure><p>发现它有<code>uid</code>，<code>user_name</code>，<code>token</code>三个属性，然后才会在代码填写<code>LoginUserResult</code>对象的属性进行调用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">from</span> grpc_example_common.protos.user.user_pb2 <span class="hljs-keyword">import</span> LoginUserResult <br><br><br>login_user_result: LoginUserResult = LoginUserResult(<br>    uid=<span class="hljs-string">&quot;123&quot;</span>,<br>    user_name=<span class="hljs-string">&quot;so1n&quot;</span>,<br>    token=<span class="hljs-string">&quot;aaa&quot;</span><br>)<br>print(login_user_result.uid)<br><span class="hljs-comment"># 123</span><br></code></pre></td></tr></table></figure><p>这时即使填错了，比如<code>uid</code>写为<code>uid1</code>IDE也不会提示有错误，我们需要等到运行时报错才知道是填错了。</p><p>这样一个场景是会让开发者非常难受的，明明都定义了一个Protobuf文件，文件中已经写了这个消息有什么属性了，结果生成对应的类却无法让IDE了解它有什么属性(跳进去源码也无法知道)，这时就需要通过<a href="https://github.com/nipunn1313/mypy-protobuf">mypy-protobuf</a>来解决这一个问题。<code>mypy-protobuf</code>会生成的一份独立的<code>.pyi</code>文件，这样一来IDE就可以帮忙提示这个对象有什么属性了，如图：<br><img    class="lazyload" data-original="https://cdn.jsdelivr.net/gh/so1n/so1n_blog_photo@master/blog_photo/16471860867391647186085970.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">IDE提醒</span><br>此外，通过<code>.pyi</code>文件可以使<code>mypy</code>等工具校验我们的代码类型是否正确，这样在运行前就能知道代码是否有问题。</p><p><code>mypy-protobuf</code>的使用方法十分的简单，它以<code>grpcio-tools</code>的一个插件来运行，具体的使用方法如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 定义生产文件的存放目录，通常都会在指定的目录下生成一个proto的文件夹</span><br>target_p = <span class="hljs-string">&quot;xxx&quot;</span><br><span class="hljs-comment"># 定义proto文件的目录</span><br>sourct_p = <span class="hljs-string">&quot;xxx&quot;</span><br>python -m grpc_tools.protoc \<br>    <span class="hljs-comment"># 指定xxx_pb2文件和xxx_pb2_grpc文件生成位置，通常我们都让他们在同一个文件夹生产</span><br>    --python_out=./<span class="hljs-variable">$target_p</span> \<br>    --grpc_python_out=./<span class="hljs-variable">$target_p</span> \<br>    <span class="hljs-comment"># 指定proto文件的位置</span><br>    -I. \<br>    <span class="hljs-variable">$source_p</span>/user/*.proto<br><span class="hljs-comment"># 上面是标准的grpcio-tools执行的标准语句</span><br>    <span class="hljs-comment"># 指定`mypy-protobuf`生成xxx_pb2和xxx_pb2_grpc对应的pyi文件的位置，必须与xxx_pb2和xxx_pb2_grpc位置保持一致</span><br>    --mypy_grpc_out=./<span class="hljs-variable">$target_p</span> \<br>    --mypy_out=./<span class="hljs-variable">$target_p</span> \<br></code></pre></td></tr></table></figure><p>只要运行了这段命令，<code>grpc_tools</code>就能在对应的路径下生成Protobuf对应的代码和对应的<code>pyi</code>文件，不过当前的<code>grpcio-tools</code>默认生成的代码所在的目录名是<code>protos</code>，它认为这个目录是在项目对应的根目录下生成的，如果我们指定在某个子目录下生产对应的代码，那么在运行程序时会直接报错，因为生成的代码文件中有一个大概长成这样的语句:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-comment"># xxx为proto文件的名</span><br><span class="hljs-keyword">from</span> protos.xxx <span class="hljs-keyword">import</span><br></code></pre></td></tr></table></figure><p>这意味着它永远都是从项目的根目录开始引入的<code>protos</code>包，但我们根目录却没有这个包，所以就会报错，这时就需要手动把生成的语句替换为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-comment"># xxx为proto文件的名</span><br><span class="hljs-keyword">from</span> .xxx <span class="hljs-keyword">import</span><br></code></pre></td></tr></table></figure><p>这样就可以完美运行了，但是每个文件手动改一下会非常的麻烦，因为每次生成代码后都要手动更改代码，同时由于项目存在多个Protobuf文件，每个文件都需要执行一次命令才能生成对应的代码。对于一个开发者来说，最讨厌的就是一直执行重复的工作，这种工作是非常烦心的， 所以需要编写了一个脚本来自动的把所有Protobuf文件转为<code>Python</code>代码(也就是项目中的<code>gen_rpc.sh</code>文件)，该脚本如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 设置脚本运行的Python环境 </span><br><span class="hljs-built_in">export</span> VENV_PREFIX=<span class="hljs-string">&quot;&quot;</span><br><span class="hljs-keyword">if</span> [ -d <span class="hljs-string">&#x27;venv&#x27;</span> ] ; <span class="hljs-keyword">then</span><br>    <span class="hljs-built_in">export</span> VENV_PREFIX=<span class="hljs-string">&quot;venv/bin/&quot;</span><br><span class="hljs-keyword">fi</span><br><span class="hljs-keyword">if</span> [ -d <span class="hljs-string">&#x27;.venv&#x27;</span> ] ; <span class="hljs-keyword">then</span><br>    <span class="hljs-built_in">export</span> VENV_PREFIX=<span class="hljs-string">&quot;.venv/bin/&quot;</span><br><span class="hljs-keyword">fi</span><br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;use venv path:&#x27;</span> <span class="hljs-variable">$&#123;VENV_PREFIX&#125;</span><br><br><span class="hljs-comment"># 设置生成的存放Python代码的proto文件夹的目录 </span><br>target_p=<span class="hljs-string">&#x27;grpc_example_common&#x27;</span><br><span class="hljs-comment"># 设置Proyobuf文件所在位置</span><br>source_p=<span class="hljs-string">&#x27;protos&#x27;</span><br><span class="hljs-comment"># 设置生成protobuf代码文件的文件名 </span><br>service_list=(<span class="hljs-string">&quot;book&quot;</span> <span class="hljs-string">&quot;user&quot;</span>)<br><br><span class="hljs-comment"># 清理之前生成的代码</span><br>rm -r <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;target_p:?&#125;</span>/<span class="hljs-variable">$&#123;source_p:?&#125;</span>&quot;</span>*<br><span class="hljs-comment"># 创建对应的文件夹</span><br>mkdir -p <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;target_p:?&#125;</span>/<span class="hljs-variable">$&#123;source_p:?&#125;</span>&quot;</span><br><br><span class="hljs-comment"># 批处理</span><br><span class="hljs-keyword">for</span> service <span class="hljs-keyword">in</span> <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;service_list[@]&#125;</span>&quot;</span><br><span class="hljs-keyword">do</span><br>  <span class="hljs-comment"># 生成proto文件对应的Python代码逻辑，每个proto文件执行一次</span><br>  mkdir -p <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;target_p:?&#125;</span>/<span class="hljs-variable">$&#123;source_p:?&#125;</span>/<span class="hljs-variable">$&#123;service:?&#125;</span>&quot;</span><br>  <span class="hljs-built_in">echo</span>  <span class="hljs-string">&quot;from proto file:&quot;</span> <span class="hljs-variable">$source_p</span>/<span class="hljs-string">&quot;<span class="hljs-variable">$service</span>&quot;</span>/*.proto <span class="hljs-string">&quot;gen proto py file to&quot;</span> <span class="hljs-variable">$target_p</span>/<span class="hljs-variable">$source_p</span><br>  <span class="hljs-variable">$&#123;VENV_PREFIX&#125;</span>python -m grpc_tools.protoc \<br>    --mypy_grpc_out=./<span class="hljs-variable">$target_p</span> \<br>    --mypy_out=./<span class="hljs-variable">$target_p</span> \<br>    --python_out=./<span class="hljs-variable">$target_p</span> \<br>    --grpc_python_out=./<span class="hljs-variable">$target_p</span> \<br>    -I. \<br>    <span class="hljs-variable">$source_p</span>/<span class="hljs-string">&quot;<span class="hljs-variable">$service</span>&quot;</span>/*.proto<br><br>  <span class="hljs-comment"># 创建一个__init__文件，这样一来这个文件夹就是一个包了，下面转换为from . import语句才能生效</span><br>  touch <span class="hljs-variable">$target_p</span>/<span class="hljs-variable">$source_p</span>/<span class="hljs-string">&quot;<span class="hljs-variable">$service</span>&quot;</span>/__init__.py<br>  <span class="hljs-comment"># fix grpc tools bug</span><br>  sed -i <span class="hljs-string">&quot;s/from protos.<span class="hljs-variable">$service</span> import/from . import/&quot;</span> <span class="hljs-variable">$target_p</span>/<span class="hljs-variable">$source_p</span>/<span class="hljs-variable">$service</span>/*.py<br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure><p>这样一来，我们通过Protobuf文件生成<code>Python</code>代码的操作就非常省心了，不管Protobuf文件有何改动，只要通过调用命令后就能在<code>grpc_example_common.protos</code>目录下看到已经生成的最新的<code>Python</code>代码，目前<code>grpc_example_common</code>的项目结构如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash">├── grpc_example_common    <span class="hljs-comment"># Python与gRPC相关的调用</span><br>│   ├── helper<br>│   ├── __init__.py<br>│   ├── interceptor<br>│   └── protos             <span class="hljs-comment"># 生成的对应Python代码</span><br>├── protos                 <span class="hljs-comment"># Protobuf文件</span><br>│   ├── book<br>│   └── user<br>├──.flake8                 <span class="hljs-comment"># 格式化工具的配置</span><br>├──.pre-commit-config.yaml <span class="hljs-comment"># 格式化工具的配置</span><br>├── gen_rpc.sh             <span class="hljs-comment"># 通过proto文件生成Python gRPC调用代码的脚本</span><br>├── mypy.ini               <span class="hljs-comment"># 格式化工具的配置</span><br>├── pyproject.toml         <span class="hljs-comment"># Python项目配置文件</span><br>├── README.md<br>├── requirements-dev.txt   <span class="hljs-comment"># 测试环境的依赖文件</span><br>├── requirements.txt       <span class="hljs-comment"># 正式环境的依赖文件</span><br>└── setup.py <br></code></pre></td></tr></table></figure><p>通过项目结构可以看出还有其它的东西，这是我为了方便，我还在这个项目中添加一些<code>Python</code>与<code>gRPC</code>相关的调用封装，把它当做一个<code>Python</code>的自定义包。</p><p>需要注意的是，每修改一次Protobuf文件应该视为一次版本发布，当生成完Protobuf文件的对应代码后，我们需要提交代码并打上对应的tag，这样其它项目才能引用到对应的版本代码。</p><blockquote><p>对于格式化工具以及poetry包管理工具不了解的可以通过文章<a href="https://so1n.me/2021/08/10/%E4%BF%9D%E9%9A%9CPython%E9%A1%B9%E7%9B%AE%E8%B4%A8%E9%87%8F%E7%9A%84%E5%B7%A5%E5%85%B7/">保障Python项目质量的工具</a>了解。</p></blockquote><blockquote><p><code>grpc_example_common</code>目录下还有其它常用的封装，将会在后续章节介绍。</p></blockquote><h2 id="2-编写gRPC服务项目"><a href="#2-编写gRPC服务项目" class="headerlink" title="2.编写gRPC服务项目"></a>2.编写gRPC服务项目</h2><p>目前这个演示的项目有两个子gRPC项目，分别为<a href="https://github.com/so1n/grpc-example-book-grpc-service">grpc-example-book-grpc-service</a>和<a href="https://github.com/so1n/grpc-example-user-grpc-service">grpc-example-user-grpc-service</a>，他们的结构很像，所以这一节以<a href="https://github.com/so1n/grpc-example-user-grpc-service">grpc-example-user-grpc-service</a>来阐述如何创建一个gRPC服务。</p><p>该项目的代码结构如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">├── tests                 <span class="hljs-comment"># 存放测试用例</span><br>│   ├── __init__.py<br>│   └── test_user.py<br>├── user_grpc_service     <span class="hljs-comment"># 项目代码真正所在的位置</span><br>│   ├── dal               <span class="hljs-comment">#   service代码，一般用于查询Mysql,Redis的逻辑</span><br>│   ├── handler           <span class="hljs-comment">#   业务逻辑代码，继承对应Protobuf文件生成的类</span><br>│   ├── helper            <span class="hljs-comment">#   其它代码封装。</span><br>│   └── __init__.py<br>├── app.py                <span class="hljs-comment"># 项目代码入口</span><br>├── mypy.ini              <span class="hljs-comment"># mypy配置文件</span><br>├── pyproject.toml        <span class="hljs-comment"># 项目配置文件</span><br>└── user.sql              <span class="hljs-comment"># 项目初始化SQL</span><br></code></pre></td></tr></table></figure><p>首先，该项目会通过如下配置引入一些依赖：</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs toml"><span class="hljs-section">[tool.poetry.dependencies]</span><br><span class="hljs-attr">python</span> = <span class="hljs-string">&quot;^3.8&quot;</span><br><span class="hljs-attr">DBUtils</span> = <span class="hljs-string">&quot;^3.0.0&quot;</span><br><span class="hljs-attr">PyMySQL</span> = <span class="hljs-string">&quot;^1.0.2&quot;</span><br><span class="hljs-attr">cryptography</span> = <span class="hljs-string">&quot;^36.0.1&quot;</span><br><span class="hljs-attr">grpc_example_common</span> = &#123; git = <span class="hljs-string">&quot;git@github.com:so1n/grpc-example-common.git&quot;</span>, tag=<span class="hljs-string">&quot;v0.1.2&quot;</span>&#125;<br></code></pre></td></tr></table></figure><p>其中<code>grpc_example_common</code>项目就是包括我们上面通过Protobuf生成的文件生产的代码，以及一些自定义的封装，通过引入依赖后，可以很方便的引用Protobuf文件生成的代码。</p><p>安装依赖后，就可以在项目中编写对应的gRPC服务了， 在这个项目里有一个比较简单的分层，所有的gRPC服务接口处理的函数都在放在<code>user_grpc_service.handler</code>目录中，而与数据库交互的则放在<code>user_grpc_service.dal</code>中。</p><p>编写服务的第一步，就是在<code>user_grpc_service.handler</code>编写对应的代码，先创建一个名为<code>user.py</code>的文件，该文件的代码值负责对User服务的调用，由于对于User服务只有一个子服务，里面只需要创建一个名为<code>UserServicer</code>的类，这个类似继承于Protobuf生成的<code>user_pb2_grpc.UserServicer</code>类，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-comment"># 通过common包引入对应Protobuf文件生成的代码</span><br><span class="hljs-keyword">from</span> grpc_example_common.protos.user <span class="hljs-keyword">import</span> user_pb2_grpc <span class="hljs-keyword">as</span> user_service<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserServicer</span>(<span class="hljs-params">user_service.UserServicer</span>):</span><br>    <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure><p>这时候IDE会在<code>UserServicer</code>上显示波浪线，如果鼠标移到波浪线位置上，IDE会提示<code>类 User 必须实现所有 abstract 方法</code>，于是点击<code>实现abstract方法</code>后，就会自动生成类似于下面的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">from</span> google.protobuf.empty_pb2 <span class="hljs-keyword">import</span> Empty  <span class="hljs-comment"># type: ignore</span><br><span class="hljs-keyword">from</span> grpc_example_common.protos.user <span class="hljs-keyword">import</span> user_pb2 <span class="hljs-keyword">as</span> user_message<br><span class="hljs-keyword">from</span> grpc_example_common.protos.user <span class="hljs-keyword">import</span> user_pb2_grpc <span class="hljs-keyword">as</span> user_service<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserServicer</span>(<span class="hljs-params">user_service.UserServicer</span>):</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">logout_user</span>(<span class="hljs-params">self, request: user_message.LogoutUserRequest,</span></span><br><span class="hljs-function"><span class="hljs-params">                    context: grpc.ServicerContext</span>) -&gt; Empty:</span><br>        <span class="hljs-keyword">pass</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">login_user</span>(<span class="hljs-params">self, request: user_message.LoginUserRequest,</span></span><br><span class="hljs-function"><span class="hljs-params">                   context: grpc.ServicerContext</span>) -&gt; user_message.LoginUserResult:</span><br>        <span class="hljs-keyword">pass</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">create_user</span>(<span class="hljs-params">self, request: user_message.CreateUserRequest,</span></span><br><span class="hljs-function"><span class="hljs-params">                    context: grpc.ServicerContext</span>) -&gt; Empty:</span><br>        <span class="hljs-keyword">pass</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">delete_user</span>(<span class="hljs-params">self, request: user_message.DeleteUserRequest,</span></span><br><span class="hljs-function"><span class="hljs-params">                    context: grpc.ServicerContext</span>) -&gt; Empty:</span><br>        <span class="hljs-keyword">pass</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">check_user_login</span>(<span class="hljs-params">self, request: user_message.LogoutUserRequest,</span></span><br><span class="hljs-function"><span class="hljs-params">                         context: grpc.ServicerContext</span>) -&gt; user_message.CheckLoginResult:</span><br>        <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure><p>这段代码就是<a href="https://github.com/so1n/grpc-example-common/blob/part-1/protos/user/user.proto">protos/user/user.proto</a>对应的<code>Python</code>代码表达，当客户端调用<code>UserServicer.logout_user</code>方法时，服务端就会自动转到该方法执行对应的逻辑，并返回结果给客户端，所以对于开发者来说只要专心完成好这几个接口的实现即可。开发者编写此处的业务逻辑代码与平时编写的API代码基本没什么差别，这里不多做阐述，具体的业务逻辑可见<a href="https://github.com/so1n/grpc-example-user-grpc-service/blob/part-1/user_grpc_service/handler/user.py">user_grpc_service/handler/user.py</a></p><p>不过需要注意的是从<code>request</code>中得到的数据对象并不是<code>Python</code>中常见的对象，而是gRPC封装的且类似于<code>Python</code>常见的对象，如果直接用于<code>pymysql</code>的类似代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">with</span> conn.cursor() <span class="hljs-keyword">as</span> cursor:<br>    cursor.execute(sql, param)<br></code></pre></td></tr></table></figure><p>那么execute可能会转码失败，导致拼接不了正确的SQL，这时候可以把<code>request</code>中得到的对象转为<code>Python</code>中场见的对象，比如<code>gRPC</code>的时间类型<code>Timestamp</code>与<code>Python</code>时间类型<code>datetime</code>转换如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> datetime<br><span class="hljs-keyword">from</span> dataclasses <span class="hljs-keyword">import</span> MISSING<br><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> Any, Optional<br><br><span class="hljs-keyword">from</span> google.protobuf.timestamp_pb2 <span class="hljs-keyword">import</span> Timestamp  <span class="hljs-comment"># type: ignore</span><br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">timestamp_to_datetime</span>(<span class="hljs-params">t: Timestamp, default: Any = MISSING</span>) -&gt; datetime.datetime:</span><br>    <span class="hljs-string">&quot;&quot;&quot;replace proto.timestamp to python datetime.datetime&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">if</span> t.seconds == <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> t.nanos == <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> default != MISSING:<br>        <span class="hljs-keyword">return</span> default<br>    <span class="hljs-keyword">return</span> t.ToDatetime()<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">datetime_to_timestamp</span>(<span class="hljs-params">d: Optional[datetime.datetime]</span>) -&gt; Timestamp:</span><br>    <span class="hljs-string">&quot;&quot;&quot;replace python datetime.datetime to proto.timestamp&quot;&quot;&quot;</span><br>    t: Timestamp = Timestamp()<br>    <span class="hljs-keyword">if</span> d:<br>        t.FromDatetime(d)<br>    <span class="hljs-keyword">return</span> t<br></code></pre></td></tr></table></figure><p>通过封装好的<code>timestamp_to_datetime</code>和<code>datetime_to_timestamp</code>可以方便的在业务逻辑中对<code>gRPC</code>和<code>Python</code>对象进行转换，更多类型转换见<a href="https://github.com/so1n/grpc-example-common/blob/part-1/grpc_example_common/helper/field.py">grpc_example_common/helper/field.py</a>，不过这种转换的实现是非常简单的，性能也不是很好，如果为了追求性能，可以尝试使用<a href="https://github.com/eigenein/protobuf">pure-protobuf</a>，它会带来一点复杂性，但是使用感受会非常好，性能也非常棒。</p><p>业务代码编写完后，需要绑定到对应的<code>Server</code>上面才能正常的提供服务，于是我们需要像创建<code>Flask Server</code>一样，先创建一个服务，然后把路由注册进去，对于<code>gRPC</code>的实现代码如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> logging<br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">from</span> concurrent <span class="hljs-keyword">import</span> futures<br><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> List, Optional<br><br><span class="hljs-keyword">import</span> grpc<br><span class="hljs-keyword">from</span> grpc_example_common.interceptor.server_interceptor.base <span class="hljs-keyword">import</span> BaseInterceptor<br><span class="hljs-keyword">from</span> grpc_example_common.interceptor.server_interceptor.customer_top <span class="hljs-keyword">import</span> CustomerTopInterceptor<br><br><span class="hljs-keyword">from</span> user_grpc_service.handler.user <span class="hljs-keyword">import</span> UserService, user_service<br><br>logging.basicConfig(<br>    <span class="hljs-built_in">format</span>=<span class="hljs-string">&quot;[%(asctime)s %(levelname)s] %(message)s&quot;</span>,<br>    datefmt=<span class="hljs-string">&quot;%y-%m-%d %H:%M:%S&quot;</span>,<br>    level=logging.DEBUG,<br>)<br>logger: logging.Logger = logging.getLogger()<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>(<span class="hljs-params">host: <span class="hljs-built_in">str</span> = <span class="hljs-string">&quot;127.0.0.1&quot;</span>, port: <span class="hljs-built_in">str</span> = <span class="hljs-string">&quot;9000&quot;</span>, ssl_port: Optional[<span class="hljs-built_in">str</span>] = <span class="hljs-literal">None</span></span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>    <span class="hljs-comment"># 拦截器列表</span><br>    interceptor_list: List[BaseInterceptor] = [CustomerTopInterceptor()]<br>    <span class="hljs-comment"># 创建一个gRPC服务</span><br>    server: grpc.server = grpc.server(<br>        futures.ThreadPoolExecutor(max_workers=<span class="hljs-number">10</span>),<br>        interceptors=interceptor_list,<br>    )<br>    <span class="hljs-comment"># 绑定我们的业务实现到服务上</span><br>    user_service.add_UserServicer_to_server(UserService(), server)<br><br>    <span class="hljs-keyword">if</span> ssl_port:<br>        <span class="hljs-comment"># 如果是启用了ssl,则读取文件，然后建立一个安全的连接</span><br>        port = ssl_port<br>        <span class="hljs-comment"># read in key and certificate</span><br>        <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(os.path.join(os.path.split(__file__)[<span class="hljs-number">0</span>], <span class="hljs-string">&quot;server.key&quot;</span>)) <span class="hljs-keyword">as</span> f:<br>            private_key = f.read().encode()<br>        <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(os.path.join(os.path.split(__file__)[<span class="hljs-number">0</span>], <span class="hljs-string">&quot;server.crt&quot;</span>)) <span class="hljs-keyword">as</span> f:<br>            certificate_chain = f.read().encode()<br>        <span class="hljs-comment"># create server credentials</span><br>        server_creds = grpc.ssl_server_credentials(<br>            (<br>                (<br>                    private_key,<br>                    certificate_chain,<br>                ),<br>            )<br>        )<br>        server.add_secure_port(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;host&#125;</span>:<span class="hljs-subst">&#123;port&#125;</span>&quot;</span>, server_creds)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-comment"># 否则建立一个普通的连接</span><br>        server.add_insecure_port(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;host&#125;</span>:<span class="hljs-subst">&#123;port&#125;</span>&quot;</span>)<br>    <span class="hljs-comment"># 启动服务</span><br>    server.start()<br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-comment"># 打印我们挂载了多少个子服务(也就是上面注册的服务)</span><br>        <span class="hljs-keyword">for</span> generic_handler <span class="hljs-keyword">in</span> server._state.generic_handlers:<br>            logger.info(<br>                <span class="hljs-string">f&quot;add service name:<span class="hljs-subst">&#123;generic_handler.service_name()&#125;</span> cnt:<span class="hljs-subst">&#123;<span class="hljs-built_in">len</span>(generic_handler._method_handlers)&#125;</span>&quot;</span><br>            )<br>        logger.info(<span class="hljs-string">f&quot;server run in <span class="hljs-subst">&#123;host&#125;</span>:<span class="hljs-subst">&#123;port&#125;</span>&quot;</span>)<br>        <span class="hljs-comment"># 一直运行，直到被关闭</span><br>        server.wait_for_termination()<br>    <span class="hljs-keyword">except</span> KeyboardInterrupt:<br>        <span class="hljs-comment"># 收到退出的信号，关闭服务</span><br>        server.stop(<span class="hljs-number">0</span>)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    main()<br></code></pre></td></tr></table></figure><p>可以看到这段代码非常简单， 但是他肩负了很多请求和连接的健康维护，会在后续的章节中详细介绍。</p><h2 id="3-测试编写的gRPC服务"><a href="#3-测试编写的gRPC服务" class="headerlink" title="3.测试编写的gRPC服务"></a>3.测试编写的gRPC服务</h2><p>代码编写完成后就应该发起请求，看看这个服务是否能正常运行，但是<code>gRPC</code>服务不像<code>HTTP</code>服务一样可以在浏览器等地方输入一个URL就能发起一个请求，所以为了能验证我们的服务能否正常的运行，我们应该编写一个测试用例。</p><p>在官方文档<a href="https://grpc.github.io/grpc/python/grpc_testing.html">gRPC Testing</a>中介绍了<code>gRPC</code>的测试用例编写方法，但是这个只覆盖到了业务代码，无法覆盖到拦截器，参数调优等逻辑，而我目前使用到了一个名为<code>CustomerTopInterceptor</code>的拦截器，它在发现业务代码有异常的时候会把异常通过<code>meta_data</code>传给客户端，然后客户端进行解析并抛出对应的异常(这种实现可能不是最优雅的，但是符合需求)，如果采用了官方的<code>gRPC Testing</code>，那在测试用例中山无法捕获到对应的异常的，所以只能采取其它的测试方法来编写一个覆盖范围更广的测试用例–<a href="https://pypi.org/project/pytest-grpc/">pytest-grpc</a>。</p><p>首先是安装好<a href="https://pypi.org/project/pytest-grpc/">pytest-grpc</a>，然后按照标准的测试用例编写习惯，在项目根目录创建一个名为<code>tests</code>的目录，(当然，我也在<code>pyproject.toml</code>指定了<code>pytest</code>的执行目录为<code>tests</code>)，然后在里面编写每个子服务的测试代码，一般来说一个子服务对应一个<code>Python</code>文件，接着在这个文件的最前面编写服务<a href="https://pypi.org/project/pytest-grpc/">pytest-grpc</a>要求的代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> Callable, List<br><br><span class="hljs-keyword">import</span> grpc<br><span class="hljs-keyword">from</span> grpc_example_common.interceptor.client_interceptor.customer_top <span class="hljs-keyword">import</span> (<br>    CustomerTopInterceptor <span class="hljs-keyword">as</span> ClientCustomerTopInterceptor,<br>)<br><span class="hljs-keyword">from</span> grpc_example_common.interceptor.server_interceptor.customer_top <span class="hljs-keyword">import</span> CustomerTopInterceptor<br><span class="hljs-keyword">from</span> grpc_example_common.protos.user <span class="hljs-keyword">import</span> user_pb2, user_pb2_grpc<br><br><span class="hljs-keyword">from</span> user_grpc_service.handler.user <span class="hljs-keyword">import</span> UserService<br><span class="hljs-keyword">from</span> user_grpc_service.helper.conn_proxy <span class="hljs-keyword">import</span> SteadyDBConnection, g_db_pool<br><br><span class="hljs-comment"># 应用的是整个文件的测试用例， 所以都需要写上@pytest.fixture(scope=&quot;module&quot;)</span><br><br><br><span class="hljs-meta">@pytest.fixture(<span class="hljs-params">scope=<span class="hljs-string">&quot;module&quot;</span></span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">grpc_add_to_server</span>() -&gt; Callable:</span><br>    <span class="hljs-comment"># 指定该子服务对应的添加服务接口</span><br>    <span class="hljs-keyword">return</span> user_pb2_grpc.add_UserServicer_to_server<br><br><br><span class="hljs-meta">@pytest.fixture(<span class="hljs-params">scope=<span class="hljs-string">&quot;module&quot;</span></span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">grpc_servicer</span>() -&gt; UserService:</span><br>    <span class="hljs-comment"># 指定我们编写该子服务的类</span><br>    <span class="hljs-keyword">return</span> UserService()<br><br><br><span class="hljs-meta">@pytest.fixture(<span class="hljs-params">scope=<span class="hljs-string">&quot;module&quot;</span></span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">grpc_interceptors</span>() -&gt; List[grpc.ServerInterceptor]:</span><br>    <span class="hljs-comment"># 指定服务端对应的拦截器</span><br>    <span class="hljs-keyword">return</span> [CustomerTopInterceptor()]<br><br><br><span class="hljs-meta">@pytest.fixture(<span class="hljs-params">scope=<span class="hljs-string">&quot;module&quot;</span></span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">grpc_stub</span>(<span class="hljs-params">grpc_channel: grpc.Channel</span>) -&gt; user_pb2_grpc.UserStub:</span><br>    <span class="hljs-comment"># 指定子服务对应的客户端</span><br>    <span class="hljs-comment"># 这里会先生成一个channel，该channel用于跟服务端通信，</span><br>    <span class="hljs-comment"># 同时它也有一个与服务端拦截器CustomerTopInterceptor对应的拦截器ClientCustomerTopInterceptor</span><br>    <span class="hljs-comment"># 最后把channel应用到对应的子服务Stub上面</span><br>    channel: grpc.Channel = grpc.intercept_channel(grpc_channel, ClientCustomerTopInterceptor())<br>    <span class="hljs-keyword">return</span> user_pb2_grpc.UserStub(channel)<br></code></pre></td></tr></table></figure><p>创建完成后我们就可以继续在该文件编写对应的测试用例代码了，这样在运行的时候都会自动加载上面代码，然后我们可以在每个测试用例都使用上面代码创建的客户端<code>grpc_stub</code>来发起请求进行测试。以创建用户和删除用户两个接口为例子，创建用户接口调用后会在数据库生成一条对应的数据，而删除用户接口会从数据库删除一条对应的数据，如果数据不存在于数据库，则会抛出<code>RuntimeError</code>异常（具体代码逻辑可见<a href="https://github.com/so1n/grpc-example-user-grpc-service/blob/part-1/user_grpc_service/handler/user.py">user_grpc_service/handler/user.py</a>），他们的测试用例代码如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">from</span> contextlib <span class="hljs-keyword">import</span> contextmanager<br><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> Callable, Generator, List<br><br><span class="hljs-meta">@contextmanager</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">mock_user</span>(<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">    uid: <span class="hljs-built_in">str</span> = <span class="hljs-string">&quot;666666&quot;</span>, </span></span><br><span class="hljs-function"><span class="hljs-params">    user_name: <span class="hljs-built_in">str</span> = <span class="hljs-string">&quot;so1n&quot;</span>, </span></span><br><span class="hljs-function"><span class="hljs-params">    password: <span class="hljs-built_in">str</span> = <span class="hljs-string">&quot;123456&quot;</span></span></span><br><span class="hljs-function"><span class="hljs-params"></span>) -&gt; Generator[<span class="hljs-keyword">None</span>, <span class="hljs-keyword">None</span>, <span class="hljs-keyword">None</span>]:</span><br>    <span class="hljs-string">&quot;&quot;&quot;通过contextmanager可以在对应的代码逻辑创建一个用户，并在结束时自动清除该用户信息&quot;&quot;&quot;</span><br>    conn: SteadyDBConnection = g_db_pool.connection()<br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-keyword">with</span> conn.cursor() <span class="hljs-keyword">as</span> cursor:<br>            cursor.execute(<br>                <span class="hljs-string">&quot;INSERT INTO user (uid, user_name, password) VALUES (%s, %s, %s)&quot;</span>,<br>                (uid, user_name, password),<br>            )<br>            conn.commit()<br>        <span class="hljs-keyword">yield</span><br>    <span class="hljs-keyword">finally</span>:<br>        <span class="hljs-keyword">with</span> conn.cursor() <span class="hljs-keyword">as</span> cursor:<br>            cursor.execute(<span class="hljs-string">&quot;DELETE FROM user WHERE uid=%s&quot;</span>, (uid,))<br>            conn.commit()<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestUser</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_create_user</span>(<span class="hljs-params">self, grpc_stub: user_pb2_grpc.UserStub</span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        <span class="hljs-string">&quot;&quot;&quot;创建用户调用的测试用例&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">try</span>:<br>            request: user_pb2.CreateUserRequest = user_pb2.CreateUserRequest(<br>                uid=<span class="hljs-string">&quot;666666&quot;</span>, user_name=<span class="hljs-string">&quot;so1n&quot;</span>, password=<span class="hljs-string">&quot;123456&quot;</span><br>            )<br>            <span class="hljs-comment"># 通过客户端带有的create_user方法发起请求，他会请求到我们的服务端代码</span><br>            <span class="hljs-comment"># 之后服务端的业务代码会在数据库创建一条对应的用户数据</span><br>            grpc_stub.create_user(request, metadata=[])<br>        <span class="hljs-keyword">finally</span>:<br>            conn: SteadyDBConnection = g_db_pool.connection()<br>            conn.begin()<br>            <span class="hljs-keyword">with</span> conn.cursor() <span class="hljs-keyword">as</span> cursor:<br>                <span class="hljs-comment"># 删除刚才创建的用户数据，返回删除的条目数量</span><br>                ret: <span class="hljs-built_in">int</span> = cursor.execute(<span class="hljs-string">&quot;DELETE FROM user WHERE uid=%s&quot;</span>, (<span class="hljs-string">&quot;666666&quot;</span>,))<br>            conn.commit()<br>            <span class="hljs-comment"># 判断是否成功删除一条用户数据，如果是，则代表刚才创建成功。 </span><br>            <span class="hljs-keyword">assert</span> ret == <span class="hljs-number">1</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_delete_user</span>(<span class="hljs-params">self, grpc_stub: user_pb2_grpc.UserStub</span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        <span class="hljs-string">&quot;&quot;&quot;删除用户调用的测试用例&quot;&quot;&quot;</span><br>        uid: <span class="hljs-built_in">str</span> = <span class="hljs-string">&quot;666666&quot;</span><br>        <span class="hljs-comment"># 创建delete_user对应的请求对象</span><br>        request: user_pb2.DeleteUserRequest = user_pb2.DeleteUserRequest(uid=uid)<br>        <span class="hljs-comment"># user not found</span><br>        <span class="hljs-keyword">with</span> pytest.raises(RuntimeError):<br>            <span class="hljs-comment"># 当前数据库没有对应的用户数据，会抛出RuntimeError异常，如果pytest能够捕获到这个异常，则证明拦截器生效了。</span><br>            grpc_stub.delete_user(request, metadata=[])<br>        <span class="hljs-keyword">with</span> mock_user(uid=uid):<br>            <span class="hljs-comment"># 在数据库存在对应的用户数据下，能正常删除数据，并不抛错</span><br>            grpc_stub.delete_user(request, metadata=[])<br></code></pre></td></tr></table></figure><p>运行测试用例可以发现测试通过了，接下来就可以编写我们的API服务，在API服务中调用我们的gRPC服务。</p><h2 id="4-编写API服务"><a href="#4-编写API服务" class="headerlink" title="4.编写API服务"></a>4.编写API服务</h2><p><code>gRPC</code>服务搭建完毕后，终于可以来编写API服务了，有了API服务后，才能把功能提供给了用户，API服务的项目结构如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs bash">├── app_service                   <span class="hljs-comment"># API接口的服务，包括路由和调用封装</span><br>│   ├── social_book_route.py<br>│   ├── manager_book_route.py<br>│   ├── utils.py<br>│   ├── route.py<br>│   ├── user_route.py<br>│   └── __init__.py<br>├── grpc_service                  <span class="hljs-comment"># 调用gRPC的服务</span><br>│   ├── __init__.py<br>│   ├── user_service.py<br>│   └── book_service.py<br>├── tests                         <span class="hljs-comment"># 测试用例</span><br>│   ├── test_route<br>│   ├── __init__.py<br>│   └── conftest.py<br>├── app.py                        <span class="hljs-comment"># app代码</span><br>├── gunicorn.conf.py              <span class="hljs-comment"># gunicorn的配置文件</span><br>├── pyproject.toml<br>├── README.md<br>└── mypy.ini<br></code></pre></td></tr></table></figure><p>API服务与<code>gRPC</code>服务一样，通过<code>pyproject.toml</code>的配置:</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs toml"><span class="hljs-section">[tool.poetry.dependencies]</span><br><span class="hljs-attr">python</span> = <span class="hljs-string">&quot;^3.8&quot;</span><br><span class="hljs-attr">grpc_example_common</span> = &#123; git = <span class="hljs-string">&quot;git@github.com:so1n/grpc-example-common.git&quot;</span>, tag=<span class="hljs-string">&quot;v0.1.4&quot;</span> &#125;<br><span class="hljs-attr">Flask</span> = <span class="hljs-string">&quot;^2.0.3&quot;</span><br></code></pre></td></tr></table></figure><p>引用了<code>grpc_example_common</code>的库， 然后在<code>grpc_service</code>中用到了该库，还是以用户服务为例子，用户服务的代码位于项目的<code>grpc_service.user_service.py</code>中，这个代码首先是创建一个<code>Mixin</code>的类：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserGrpcServiceMixin</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, channel: grpc.Channel</span>):</span><br>        self.user_stub: user_service.UserStub = user_service.UserStub(channel)<br>        <span class="hljs-comment"># 通过grpc_wrapper.grpc_client_func_wrapper为所有的请求带上matedate参数</span><br>        grpc_wrapper.auto_load_wrapper_by_stub(self.user_stub, grpc_wrapper.grpc_client_func_wrapper)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">create_user</span>(<span class="hljs-params">self, *, uid: <span class="hljs-built_in">str</span>, user_name: <span class="hljs-built_in">str</span>, password: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        self.user_stub.create_user(user_message.CreateUserRequest(uid=uid, user_name=user_name, password=password))<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">delete_user</span>(<span class="hljs-params">self, *, uid: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        self.user_stub.delete_user(user_message.DeleteUserRequest(uid=uid))<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">login_user</span>(<span class="hljs-params">self, *, uid: <span class="hljs-built_in">str</span>, password: <span class="hljs-built_in">str</span></span>) -&gt; user_message.LoginUserResult:</span><br>        <span class="hljs-keyword">return</span> self.user_stub.login_user(user_message.LoginUserRequest(uid=uid, password=password))<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">logout_user</span>(<span class="hljs-params">self, *, uid: <span class="hljs-built_in">str</span>, token: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        self.user_stub.logout_user(user_message.LogoutUserRequest(uid=uid, token=token))<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_uid_by_token</span>(<span class="hljs-params">self, *, token: <span class="hljs-built_in">str</span></span>) -&gt; str:</span><br>        result: user_message.GetUidByTokenResult = self.user_stub.get_uid_by_token(<br>            user_message.GetUidByTokenRequest(token=token)<br>        )<br>        <span class="hljs-keyword">return</span> result.uid<br></code></pre></td></tr></table></figure><p>这个类就是对<code>user_service.UserStub</code>的简单封装，可以看到方法名和参数与Protobuf保持一致，它只是接受一个负责通信的channel，然后传入到<code>user_stub</code>中，方便后续的方法对<code>user_stub</code>调用，同时这个类还负责一些数据的转换，如上面提到的<code>Protobuf</code>的<code>Timestamps</code>对象转为<code>Python</code>的<code>datetime</code>对象。</p><p>接着创建一个负责子服务管理的<code>UserGrpcSerevice</code>类，这个类负责建立通信和维护通信段稳定：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserGrpcService</span>(<span class="hljs-params">UserGrpcServiceMixin</span>):</span><br>    <span class="hljs-comment"># 如果有多个，则在这里继承多个mixin</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, host: <span class="hljs-built_in">str</span>, port: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        <span class="hljs-comment"># 初始化与服务端的通信</span><br>        self.channel: grpc.Channel = grpc.intercept_channel(<br>            grpc.insecure_channel(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;host&#125;</span>:<span class="hljs-subst">&#123;port&#125;</span>&quot;</span>), CustomerTopInterceptor()<br>        )<br>        <span class="hljs-comment"># 传入到对应的服务里</span><br>        UserGrpcServiceMixin.__init__(self, self.channel)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">channel_ready_future</span>(<span class="hljs-params">self, timeout: <span class="hljs-built_in">int</span> = <span class="hljs-number">10</span></span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        <span class="hljs-comment"># 用于检查是否与服务端建立起连接</span><br>        target: <span class="hljs-built_in">str</span> = (<br>            <span class="hljs-string">f&quot;<span class="hljs-subst">&#123;self.__class__.__name__&#125;</span>&quot;</span><br>            <span class="hljs-string">f&quot; <span class="hljs-subst">&#123;self.channel._channel._connectivity_state.channel.target().decode()&#125;</span>&quot;</span>  <span class="hljs-comment"># type: ignore</span><br>        )  <span class="hljs-comment"># type: ignore</span><br>        <span class="hljs-keyword">try</span>:<br>            grpc.channel_ready_future(self.channel).result(timeout=timeout)<br>        <span class="hljs-keyword">except</span> grpc.FutureTimeoutError:<br>            logger.exception(<span class="hljs-string">f&quot;channel:<span class="hljs-subst">&#123;target&#125;</span> connect timeout&quot;</span>)<br>            <span class="hljs-keyword">raise</span> RuntimeError(<span class="hljs-string">f&quot;channel:<span class="hljs-subst">&#123;target&#125;</span> connect timeout&quot;</span>)<br>        <span class="hljs-keyword">else</span>:<br>            logger.info(<span class="hljs-string">f&quot;channel:<span class="hljs-subst">&#123;target&#125;</span> connect success&quot;</span>)<br></code></pre></td></tr></table></figure><p>创建完毕后对于gRPC客户端调用服务端的逻辑已经封装完成了，接下来就是在路由函数中进行使用了，一般情况下都是使用单例的模式创建一个<code>UserGrpcService</code>的实例，但是我不太喜欢这样做，于是创建了一个中间件，然后通过<code>flask.g</code>传递创建app时初始化的<code>gRPC</code>服务示例，对应的中间件处理代码如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> Any, Union<br><br><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Blueprint, Flask, Response<br><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> g <span class="hljs-keyword">as</span> flask_g<br><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> jsonify, request<br><br><span class="hljs-keyword">from</span> grpc_service.book_service <span class="hljs-keyword">import</span> BookGrpcService<br><span class="hljs-keyword">from</span> grpc_service.user_service <span class="hljs-keyword">import</span> UserGrpcService<br><br>APP_TYPE = Union[Blueprint, Flask]<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomerGType</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;基于flasg.g的封装，这样就可以无忧的使用IDE的提示和重构功能了&quot;&quot;&quot;</span><br>    book_grpc_service: BookGrpcService<br>    user_grpc_service: UserGrpcService<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__getattr__</span>(<span class="hljs-params">self, key: <span class="hljs-built_in">str</span></span>) -&gt; Any:</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">getattr</span>(flask_g, key)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__setattr__</span>(<span class="hljs-params">self, key: <span class="hljs-built_in">str</span>, value: Any</span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        <span class="hljs-built_in">setattr</span>(flask_g, key, value)<br><br><br>g: CustomerGType = CustomerGType()<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ContextMiddleware</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;基于flask的before_request和after_request钩子创建的一个中间件类&quot;&quot;&quot;</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">        self, *, app: APP_TYPE, book_grpc_service: BookGrpcService, user_grpc_service: UserGrpcService</span></span><br><span class="hljs-function"><span class="hljs-params">    </span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        self._app = app<br>        self._app.before_request(self._before_requests)<br>        self._app.after_request(self._after_requests)<br><br>        self._book_grpc_service: BookGrpcService = book_grpc_service<br>        self._user_grpc_service: UserGrpcService = user_grpc_service<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_before_requests</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        <span class="hljs-comment"># 收到请求点时候把gRPC服务传到指定的变量中</span><br>        g.book_grpc_service = self._book_grpc_service<br>        g.user_grpc_service = self._user_grpc_service<br>        <span class="hljs-keyword">return</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_after_requests</span>(<span class="hljs-params">self, response: Response</span>) -&gt; Response:</span><br>        <span class="hljs-keyword">return</span> response<br></code></pre></td></tr></table></figure><p>中间件创建完成后，就可以在<code>create_app</code>工厂函数中创建对应的<code>gRPC</code>服务，然后赋值到对应的中间件中:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">from</span> flask.app <span class="hljs-keyword">import</span> Flask<br><br><span class="hljs-keyword">from</span> app_service.route <span class="hljs-keyword">import</span> manager_book_bp, social_book_bp, user_bp<br><span class="hljs-keyword">from</span> app_service.utils <span class="hljs-keyword">import</span> ContextMiddleware, api_exception<br><span class="hljs-keyword">from</span> grpc_service.book_service <span class="hljs-keyword">import</span> BookGrpcService<br><span class="hljs-keyword">from</span> grpc_service.user_service <span class="hljs-keyword">import</span> UserGrpcService<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">create_app</span>() -&gt; Flask:</span><br>    app: Flask = Flask(__name__)<br>    <span class="hljs-comment"># 注册对应的路由</span><br>    app.register_blueprint(manager_book_bp)<br>    app.register_blueprint(social_book_bp)<br>    app.register_blueprint(user_bp)<br><br>    <span class="hljs-comment"># 初始化对应的gRPC服务，并等待建立连接</span><br>    book_grpc_service: BookGrpcService = BookGrpcService(<span class="hljs-string">&quot;0.0.0.0&quot;</span>, <span class="hljs-number">9000</span>)<br>    book_grpc_service.channel_ready_future(timeout=<span class="hljs-number">3</span>)<br>    user_grpc_service: UserGrpcService = UserGrpcService(<span class="hljs-string">&quot;0.0.0.0&quot;</span>, <span class="hljs-number">9001</span>)<br>    user_grpc_service.channel_ready_future(timeout=<span class="hljs-number">3</span>)<br>    <span class="hljs-comment"># 把gRPC服务注入到中间件中</span><br>    ContextMiddleware(app=app, book_grpc_service=book_grpc_service, user_grpc_service=user_grpc_service)<br><br>    app.errorhandler(Exception)(api_exception)<br>    <span class="hljs-keyword">return</span> app<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    create_app().run(<span class="hljs-string">&quot;localhost&quot;</span>, port=<span class="hljs-number">8000</span>)<br><br></code></pre></td></tr></table></figure><p>最后，就可以在路由函数中使用对应的<code>gRPC</code>服务了，还是以创建用户和删除用户为例子:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Response, request<br><span class="hljs-keyword">from</span> grpc_example_common.protos.user <span class="hljs-keyword">import</span> user_pb2 <span class="hljs-keyword">as</span> user_message<br><br><span class="hljs-keyword">from</span> app_service.utils <span class="hljs-keyword">import</span> g, get_uid_by_token, make_response<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">create_user</span>() -&gt; Response:</span><br>    request_dict: <span class="hljs-built_in">dict</span> = request.json()<br>    g.user_grpc_service.create_user(<br>        uid=request_dict[<span class="hljs-string">&quot;uid&quot;</span>], user_name=request_dict[<span class="hljs-string">&quot;user_name&quot;</span>], password=request_dict[<span class="hljs-string">&quot;password&quot;</span>]<br>    )<br>    <span class="hljs-keyword">return</span> make_response()<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">delete_user</span>() -&gt; Response:</span><br>    request_dict: <span class="hljs-built_in">dict</span> = request.json()<br>    g.user_grpc_service.delete_user(uid=request_dict[<span class="hljs-string">&quot;uid&quot;</span>])<br>    <span class="hljs-keyword">return</span> make_response()<br></code></pre></td></tr></table></figure><p>这两个接口都是在收到请求后，再调用<code>gRPC</code>服务对应的方法来传递请求，其它服务调用的代码与创建用户和删除用户的例子相同，具体可以访问<a href="https://github.com/so1n/grpc-example-api-backend-service/tree/part-1/app_service">app_service</a>了解</p><p>需要注意的是，通常我们不会在生产环境直接运行<code>Flask</code>，而是采用<code>gunicorn</code>+<code>gevnet</code>来运行我们的API服务，从而增强服务的稳定性和性能，但是<code>gevent</code>是修改<code>Python</code>代码来达到全局代码都不阻塞的，而<code>gRPC</code>本身的调用是包含C代码，<code>gevent</code>无法修改到<code>gRPC</code>调用到的C代码，所以<code>gRPC</code>提供一个名为<code>grpc.experimental.gevent.init_gevent</code>的方法来解决这个问题，如下代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> socket<br><br><span class="hljs-keyword">try</span>:<br>    <span class="hljs-keyword">import</span> gevent<br><span class="hljs-keyword">except</span> ImportError:<br>    <span class="hljs-keyword">pass</span><br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-keyword">if</span> socket.socket <span class="hljs-keyword">is</span> gevent.socket.socket:<br>        <span class="hljs-keyword">import</span> grpc.experimental.gevent<br><br>        grpc.experimental.gevent.init_gevent()<br></code></pre></td></tr></table></figure><p>这段代码在初始化时可以通过判断是否启用<code>gevnet</code>来启用<code>grpc.experimental.gevent.init_gevent</code>，通常建议放在gunicorn的配置文件里，具体见<a href="https://github.com/so1n/grpc-example-api-backend-service/blob/part-1/gunicorn.conf.py">gunicorn.conf.py</a></p><p>至此，一个API服务就搭建完毕，可以直接运行后在浏览器进行测试。</p><h2 id="5-测试编写的API服务"><a href="#5-测试编写的API服务" class="headerlink" title="5.测试编写的API服务"></a>5.测试编写的API服务</h2><p>截止到目前，对于包含gRPC的API服务接口测试没有一个比较好的方法，因为单例测试是不考虑别的服务的，意味着需要对gRPC调用段响应进行Mock，然而用于调用段<code>Stub</code>类只有属性而没有方法，这样会导致mock不成功，所以需要先创建一个gRPC Stub的函数签名，以<code>UserStub</code>为例子，将会创建一个类似于gRPC UserStub的类：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> Any<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserStub</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, channel: Any</span>):</span><br>        <span class="hljs-keyword">pass</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_uid_by_token</span>(<span class="hljs-params">self, *args: Any, **kwargs: Any</span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        <span class="hljs-keyword">pass</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">logout_user</span>(<span class="hljs-params">self, *args: Any, **kwargs: Any</span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        <span class="hljs-keyword">pass</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">login_user</span>(<span class="hljs-params">self, *args: Any, **kwargs: Any</span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        <span class="hljs-keyword">pass</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">create_user</span>(<span class="hljs-params">self, *args: Any, **kwargs: Any</span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        <span class="hljs-keyword">pass</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">delete_user</span>(<span class="hljs-params">self, *args: Any, **kwargs: Any</span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure><blockquote><p>其它的见:<a href="https://github.com/so1n/grpc-example-api-backend-service/blob/part-1/tests/grpc_abc_stub.py">tests/grpc_abc_stub.py</a></p></blockquote><p>然后在<a href="https://github.com/so1n/grpc-example-api-backend-service/blob/part-1/tests/conftest.py">tests/conftest.py</a>编写一个全局的初始化，该初始化会把gRPC的检查连接方法屏蔽以及把对应的Stub类进行替换：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> pytest<br><span class="hljs-keyword">from</span> grpc <span class="hljs-keyword">import</span> _utilities<br><span class="hljs-keyword">from</span> grpc_example_common.protos.book <span class="hljs-keyword">import</span> manager_pb2_grpc, social_pb2_grpc<br><span class="hljs-keyword">from</span> grpc_example_common.protos.user <span class="hljs-keyword">import</span> user_pb2_grpc<br><br><span class="hljs-keyword">from</span> tests.grpc_abc_stub <span class="hljs-keyword">import</span> BookManagerStub, BookSocialStub, UserStub<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">result</span>(<span class="hljs-params">self: Any, timeout: Any = <span class="hljs-literal">None</span></span>) -&gt; Any:</span><br>    <span class="hljs-keyword">pass</span><br><br><br><span class="hljs-comment"># Blocking the start check of grpc service</span><br>_utilities._ChannelReadyFuture.result = result<br><br>user_pb2_grpc.UserStub = UserStub<br>user_pb2_grpc.UserStub = UserStub<br>social_pb2_grpc.BookSocialStub = BookSocialStub<br>manager_pb2_grpc.BookManagerStub = BookManagerStub<br></code></pre></td></tr></table></figure><p>这样就为测试用例初始化完成了， 但是我为每个Stub包装了一个功能，使他们永远会传递<code>metadata</code>变量：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserGrpcServiceMixin</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, channel: grpc.Channel</span>):</span><br>        self.user_stub: user_service.UserStub = user_service.UserStub(channel)<br>        grpc_wrapper.auto_load_wrapper_by_stub(self.user_stub, grpc_wrapper.grpc_client_func_wrapper)<br></code></pre></td></tr></table></figure><p>该方法会初始化一定要放在mock之后，否则mock无效，这意味着初始化<code>Flask.TestClient</code>的逻辑必须在测试代码里，于是先创建一个类似于<code>pytest.fixture</code>的初始化<code>Flask.TestClient</code>函数:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-meta">@contextmanager</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">customer_app</span>() -&gt; Generator[FlaskClient, <span class="hljs-keyword">None</span>, <span class="hljs-keyword">None</span>]:</span><br>    flask_app: Flask = create_app()<br>    <span class="hljs-comment"># Flask provides a way to test your application by exposing the Werkzeug test Client</span><br>    <span class="hljs-comment"># and handling the context locals for you.</span><br>    client: FlaskClient = flask_app.test_client()<br>    <span class="hljs-comment"># Establish an application context before running the tests.</span><br>    ctx: AppContext = flask_app.app_context()<br>    ctx.push()<br>    <span class="hljs-keyword">yield</span> client  <span class="hljs-comment"># this is where the testing happens!</span><br>    ctx.pop()<br></code></pre></td></tr></table></figure><p>为了偷懒，我把他放到了<code>conftest</code>文件。</p><blockquote><p>如果没有包装过stub的方法，则可以不用采用该步骤</p></blockquote><p>现在，所有初始化都编写完毕了，可以编写测试用例，以用户调用路由为例子(说明见注释):</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">from</span> google.protobuf.empty_pb2 <span class="hljs-keyword">import</span> Empty  <span class="hljs-comment"># type: ignore</span><br><span class="hljs-keyword">from</span> grpc_example_common.protos.user <span class="hljs-keyword">import</span> user_pb2 <span class="hljs-keyword">as</span> user_message<br><span class="hljs-keyword">from</span> pytest_mock <span class="hljs-keyword">import</span> MockFixture<br><span class="hljs-keyword">from</span> werkzeug.test <span class="hljs-keyword">import</span> TestResponse<br><br><span class="hljs-keyword">from</span> tests.conftest <span class="hljs-keyword">import</span> customer_app<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestUser</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_create_user</span>(<span class="hljs-params">self, mocker: MockFixture</span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        <span class="hljs-comment"># 该接口会调用到UserStub.create_user，我们把他mock掉，返回的是Empty</span><br>        mocker.patch(<span class="hljs-string">&quot;grpc_example_common.protos.user.user_pb2_grpc.UserStub.create_user&quot;</span>).return_value = Empty()<br>        <span class="hljs-keyword">with</span> customer_app() <span class="hljs-keyword">as</span> client:<br>            resp: TestResponse = client.post(<br>                <span class="hljs-string">&quot;/api/user/create&quot;</span>, json=&#123;<span class="hljs-string">&quot;uid&quot;</span>: <span class="hljs-string">&quot;123&quot;</span>, <span class="hljs-string">&quot;user_name&quot;</span>: <span class="hljs-string">&quot;so1n&quot;</span>, <span class="hljs-string">&quot;password&quot;</span>: <span class="hljs-string">&quot;aha&quot;</span>&#125;<br>            )<br>            <span class="hljs-keyword">assert</span> resp.json[<span class="hljs-string">&quot;code&quot;</span>] == <span class="hljs-number">0</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_delete_user</span>(<span class="hljs-params">self, mocker: MockFixture</span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        <span class="hljs-comment"># 该接口会调用到UserStub.delete_user，我们把他mock掉，返回的是Empty</span><br>        mocker.patch(<span class="hljs-string">&quot;grpc_example_common.protos.user.user_pb2_grpc.UserStub.delete_user&quot;</span>).return_value = Empty()<br>        <span class="hljs-keyword">with</span> customer_app() <span class="hljs-keyword">as</span> client:<br>            resp: TestResponse = client.post(<span class="hljs-string">&quot;/api/user/delete&quot;</span>, json=&#123;<span class="hljs-string">&quot;uid&quot;</span>: <span class="hljs-string">&quot;123&quot;</span>&#125;)<br>            <span class="hljs-keyword">assert</span> resp.json[<span class="hljs-string">&quot;code&quot;</span>] == <span class="hljs-number">0</span><br>        <span class="hljs-comment"># User.Stub.delete_user还有一个会抛错的方法,我们通过mock满足这个条件</span><br>        mocker.patch(<span class="hljs-string">&quot;grpc_example_common.protos.user.user_pb2_grpc.UserStub.delete_user&quot;</span>).side_effect = RuntimeError(<br>            <span class="hljs-string">&quot;test error&quot;</span><br>        )<br>        <span class="hljs-keyword">with</span> customer_app() <span class="hljs-keyword">as</span> client:<br>            resp = client.post(<span class="hljs-string">&quot;/api/user/delete&quot;</span>, json=&#123;<span class="hljs-string">&quot;uid&quot;</span>: <span class="hljs-string">&quot;123&quot;</span>&#125;)<br>            <span class="hljs-keyword">assert</span> resp.json[<span class="hljs-string">&quot;data&quot;</span>] == <span class="hljs-string">&quot;test error&quot;</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_login_user</span>(<span class="hljs-params">self, mocker: MockFixture</span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        <span class="hljs-comment"># 通过mock指定具体的返回数据，返回的数据类型一定要跟Protobuf生成的代码一致</span><br>        mocker.patch(<br>            <span class="hljs-string">&quot;grpc_example_common.protos.user.user_pb2_grpc.UserStub.login_user&quot;</span><br>        ).return_value = user_message.LoginUserResult(uid=<span class="hljs-string">&quot;123&quot;</span>, token=<span class="hljs-string">&quot;66666&quot;</span>)<br>        <span class="hljs-keyword">with</span> customer_app() <span class="hljs-keyword">as</span> client:<br>            resp: TestResponse = client.post(<span class="hljs-string">&quot;/api/user/login&quot;</span>, json=&#123;<span class="hljs-string">&quot;uid&quot;</span>: <span class="hljs-string">&quot;123&quot;</span>, <span class="hljs-string">&quot;password&quot;</span>: <span class="hljs-string">&quot;pw&quot;</span>&#125;)<br>            <span class="hljs-keyword">assert</span> resp.json[<span class="hljs-string">&quot;data&quot;</span>] == &#123;<span class="hljs-string">&quot;uid&quot;</span>: <span class="hljs-string">&quot;123&quot;</span>, <span class="hljs-string">&quot;token&quot;</span>: <span class="hljs-string">&quot;66666&quot;</span>&#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_logout</span>(<span class="hljs-params">self, mocker: MockFixture</span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        mocker.patch(<span class="hljs-string">&quot;grpc_example_common.protos.user.user_pb2_grpc.UserStub.logout_user&quot;</span>).return_value = Empty()<br>        mocker.patch(<br>            <span class="hljs-string">&quot;grpc_example_common.protos.user.user_pb2_grpc.UserStub.get_uid_by_token&quot;</span><br>        ).return_value = user_message.GetUidByTokenResult(uid=<span class="hljs-string">&quot;123&quot;</span>)<br>        <span class="hljs-keyword">with</span> customer_app() <span class="hljs-keyword">as</span> client:<br>            resp: TestResponse = client.post(<span class="hljs-string">&quot;/api/user/logout&quot;</span>, json=&#123;<span class="hljs-string">&quot;uid&quot;</span>: <span class="hljs-string">&quot;123&quot;</span>&#125;, headers=&#123;<span class="hljs-string">&quot;token&quot;</span>: <span class="hljs-string">&quot;666666&quot;</span>&#125;)<br>            <span class="hljs-keyword">assert</span> resp.json[<span class="hljs-string">&quot;code&quot;</span>] == <span class="hljs-number">0</span><br><br>        mocker.patch(<br>            <span class="hljs-string">&quot;grpc_example_common.protos.user.user_pb2_grpc.UserStub.get_uid_by_token&quot;</span><br>        ).return_value = user_message.GetUidByTokenResult(uid=<span class="hljs-string">&quot;1234&quot;</span>)<br>        <span class="hljs-keyword">with</span> customer_app() <span class="hljs-keyword">as</span> client:<br>            resp = client.post(<span class="hljs-string">&quot;/api/user/logout&quot;</span>, json=&#123;<span class="hljs-string">&quot;uid&quot;</span>: <span class="hljs-string">&quot;123&quot;</span>&#125;, headers=&#123;<span class="hljs-string">&quot;token&quot;</span>: <span class="hljs-string">&quot;666666&quot;</span>&#125;)<br>            <span class="hljs-keyword">assert</span> resp.json[<span class="hljs-string">&quot;data&quot;</span>] == <span class="hljs-string">&quot;Uid ERROR&quot;</span><br></code></pre></td></tr></table></figure><p>至此，已经实现了一个可以简单使用的gRPC服务，可以在电脑上起不同的进程并观察他们的调用情况，但是这只是一个开始，随着服务的扩大，服务间的维护和调优会变得十分麻烦，要想服务能够健壮的运行，我们需要继续深入。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;通过前面的文章了解到了&lt;code&gt;gRPC&lt;/code&gt;是什么，以及清楚使用它的优缺点，现在终于可以开始实现一个&lt;code&gt;gRPC&lt;/code&gt;服务了。&lt;/p&gt;</summary>
    
    
    <content src="https://ftp.bmp.ovh/imgs/2022/02/bd67e15aa8d46101.png" type="image"/>
    
    
    <category term="Python-gRPC实践" scheme="http://so1n.me/categories/Python-gRPC%E5%AE%9E%E8%B7%B5/"/>
    
    
    <category term="Python" scheme="http://so1n.me/tags/Python/"/>
    
    <category term="gRPC" scheme="http://so1n.me/tags/gRPC/"/>
    
  </entry>
  
  <entry>
    <title>在Python运行时修改业务代码的SQL</title>
    <link href="http://so1n.me/2022/03/11/modify-sql-in-python-runtime/"/>
    <id>http://so1n.me/2022/03/11/modify-sql-in-python-runtime/</id>
    <published>2022-03-11T15:33:18.000Z</published>
    <updated>2022-03-13T03:22:27.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前记"><a href="#前记" class="headerlink" title="前记"></a>前记</h2><p>在项目的演变过程中，有时可能会诞生一些需要奇怪的临时需求，这些需求会涉及到所有的SQL，但开发时间上却不允许整个项目的所有SQL进行重写，比如控制不同的人访问表的权限，或者是我面对的SASS化需求，这时就需要在运行时根据对应的条件来修改SQL语句。</p><span id="more"></span><h2 id="1-缘起"><a href="#1-缘起" class="headerlink" title="1.缘起"></a>1.缘起</h2><p>最近项目在准备搞SASS化，SASS化有一个特点就是多租户，且每个租户之间的数据都要隔离，对于数据库的隔离方案常见的有数据库隔离，表隔离，字段隔离，目前我只用到表隔离和字段隔离（数据库隔离的原理也是差不多）。<br>对于字段隔离比较简单，就是查询条件不同而已，比如像下面的SQL查询：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t_demo <span class="hljs-keyword">WHERE</span> tenant_id<span class="hljs-operator">=</span><span class="hljs-string">&#x27;xxx&#x27;</span> <span class="hljs-keyword">AND</span> is_del<span class="hljs-operator">=</span><span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>但是为了严谨，需求上需要在执行SQL之前检查对应的表是否带上<code>tenant_id</code>的查询字段。</p><p>对于表隔离就麻烦了一些，他需要做到在运行的时候根据对应的租户ID来处理某个数据表，举个例子，假如有下面这样的一条SQL查询:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t_demo <span class="hljs-keyword">WHERE</span> is_del<span class="hljs-operator">=</span><span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>在遇到租户A时，SQL查询将变为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t_demo_a <span class="hljs-keyword">WHERE</span> is_del<span class="hljs-operator">=</span><span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>在遇到租户B时，SQL查询将变为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t_demo_b <span class="hljs-keyword">WHERE</span> is_del<span class="hljs-operator">=</span><span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>如果商户数量固定时，一般在代码里编写<code>if-else</code>来判断就可以了，但是常见的SASS化应用的商户是会一直新增的，那么对于这个SQL逻辑就会变成这样:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sql_handle</span>(<span class="hljs-params">tenant_id: <span class="hljs-built_in">str</span></span>):</span><br>    table_name: <span class="hljs-built_in">str</span> = <span class="hljs-string">f&quot;t_demo_<span class="hljs-subst">&#123;tenant_id&#125;</span>&quot;</span><br>    sql: <span class="hljs-built_in">str</span> = <span class="hljs-string">f&quot;SELECT * FROM <span class="hljs-subst">&#123;table_name&#125;</span> WHERE is_del=0&quot;</span><br></code></pre></td></tr></table></figure><p>但是这有几个问题，对于ORM来说，一开始只创建一个<code>t_demo</code>对应的表对象就可以了，现在却要根据多个商户创建多个表对象，这是不现实的，其次如果是裸写SQL，一般会使用IDE的检查，而对于这样的SQL：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Python">sql: <span class="hljs-built_in">str</span> = <span class="hljs-string">f&quot;SELECT * FROM <span class="hljs-subst">&#123;table_name&#125;</span> WHERE is_del=0&quot;</span><br></code></pre></td></tr></table></figure><p>IDE是没办法进行检查的，当然还有一个最为严重的问题，就是当前的项目已经非常庞大了，如果每个相关表的调用都进行适配更改的话，那工程量就非常庞大了，所以最好的方案就是在引擎库得到用户传过来的SQL语句后且还没发送到<code>MySQL</code>服务器之前自动的根据商户ID更改SQL, 而要达到这样的效果，就必须侵入到我们使用的<code>MySQL</code>的引擎库，修改里面的方法来兼容我们的需求。</p><blockquote><p>不管是使用<code>dbutils</code>还是<code>sqlalchemy</code>，都可以指定一个引擎库，目前常用的引擎库是<code>pymysql</code>，所以下文都将以<code>pymysql</code>为例进行阐述。</p></blockquote><h2 id="2-侵入库"><a href="#2-侵入库" class="headerlink" title="2.侵入库"></a>2.侵入库</h2><p>由于必须侵入到我们使用的引擎库，所以我们应该先判断我们需要修改引擎库的哪个方法，在经过源码阅读后，我判定只要更改<code>pymysql.cursors.Cursor</code>的<code>mogrify</code>方法:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">mogrify</span>(<span class="hljs-params">self, query, args=<span class="hljs-literal">None</span></span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    Returns the exact string that is sent to the database by calling the</span><br><span class="hljs-string">    execute() method.</span><br><span class="hljs-string"></span><br><span class="hljs-string">    This method follows the extension to the DB API 2.0 followed by Psycopg.</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    conn = self._get_db()<br><br>    <span class="hljs-keyword">if</span> args <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>        query = query % self._escape_args(args, conn)<br><br>    <span class="hljs-keyword">return</span> query<br></code></pre></td></tr></table></figure><p>这个方法的作用就是把用户传过来的SQL和参数进行整合，生成一个最终的SQL,刚好符合我们的需求，于是可以通过继承的思路来创建一个新的属于我们自己的<code>Cursor</code>类：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> pymysql<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cursor</span>(<span class="hljs-params">pymysql.cursors.Cursor</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">mogrify</span>(<span class="hljs-params">self, query: <span class="hljs-built_in">str</span>, args: Union[<span class="hljs-literal">None</span>, <span class="hljs-built_in">list</span>, <span class="hljs-built_in">dict</span>, <span class="hljs-built_in">tuple</span>] = <span class="hljs-literal">None</span></span>) -&gt; str:</span><br>        <span class="hljs-comment"># 在此可以编写处理还合成的SQL逻辑</span><br>        mogrify_sql: <span class="hljs-built_in">str</span> = <span class="hljs-built_in">super</span>().mogrify(query, args)<br>        <span class="hljs-comment"># 在此可以编写处理合成后的SQL逻辑</span><br>        <span class="hljs-keyword">return</span> mogrify_sql<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DictCursor</span>(<span class="hljs-params">pymysql.cursors.DictCursorMixin, Cursor</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;A cursor which returns results as a dictionary&quot;&quot;&quot;</span><br>    <span class="hljs-comment"># 直接修改Cursor类的`mogrify`方法并不会影响到`DictCursor`类，所以我们也要创建一个新的`Cursor`类。</span><br></code></pre></td></tr></table></figure><p>创建好了<code>Cursor</code>类后，就需要考虑如何在<code>pymysql</code>中应用我们自定义的<code>Cursor</code>类了，一般的<code>Mysql</code>连接库都支持我们传入自定义的<code>Cursor</code>类，比如<code>pymysql</code>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> pymysql.cursors<br><br><span class="hljs-comment"># Connect to the database</span><br>connection = pymysql.connect(<br>    host=<span class="hljs-string">&#x27;localhost&#x27;</span>,<br>    user=<span class="hljs-string">&#x27;user&#x27;</span>,<br>    password=<span class="hljs-string">&#x27;passwd&#x27;</span>,<br>    database=<span class="hljs-string">&#x27;db&#x27;</span>,<br>    charset=<span class="hljs-string">&#x27;utf8mb4&#x27;</span>,<br>    cursorclass=pymysql.cursors.DictCursor<br>)<br></code></pre></td></tr></table></figure><p>我们可以通过<code>cursorclass</code>来指定我们的<code>Cursor</code>类,如果使用的库不支持或者是其它原因则需要使用猴子补丁的方法，具体的使用方法见<a href="https://so1n.me/2020/11/18/%E5%9F%BA%E4%BA%8EPython%E6%8E%A2%E9%92%88%E5%AE%8C%E6%88%90%E8%B0%83%E7%94%A8%E5%BA%93%E7%9A%84%E6%95%B0%E6%8D%AE%E6%8F%90%E5%8F%96/">基于Python探针完成调用库的数据提取</a>。</p><h2 id="3-获取商户ID"><a href="#3-获取商户ID" class="headerlink" title="3.获取商户ID"></a>3.获取商户ID</h2><p>现在我们已经搞定了在何处修改SQL的问题了，接下来就要思考如何在<code>mogrify</code>方法获取到商户ID以及那些表要进行替换，一般我们在进行一段代码调用时，有两种传参数的方法， 一种是传数组类型的参数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">with</span> conn.cursor() <span class="hljs-keyword">as</span> cursor:<br>    cursor.execute(<span class="hljs-string">&quot;SELECT * FROM t_demo WHERE is_del=%s&quot;</span>, (<span class="hljs-number">0</span>, ))<br></code></pre></td></tr></table></figure><p>一种是传字典类型的参数:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">with</span> conn.cursor() <span class="hljs-keyword">as</span> cursor:<br>    cursor.execute(<span class="hljs-string">&quot;SELECT * FROM t_demo WHERE is_del=%(is_del)s&quot;</span>, &#123;<span class="hljs-string">&quot;is_del&quot;</span>: <span class="hljs-number">0</span>&#125;)<br></code></pre></td></tr></table></figure><p>目前大多数的项目都存在这两种类型的编写习惯，而引擎库在执行<code>execute</code>时会经过处理后才把参数<code>sql</code>和<code>args</code>传给了<code>mogrify</code>，如果我们是使用字典类型的参数，那么可以在里面嵌入我们需要的参数，并在<code>mogrify</code>里面提取出来，但是使用了数组类型的参数或者是ORM库的话就比较难传递参数给<code>mogrify</code>方法了，这时可以通过<code>context</code>隐式的把参数传给<code>mogrify</code>方法，具体的分析和原理可见:<a href="https://so1n.me/2019/06/13/contextvars%E6%A8%A1%E5%9D%97/#3-%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E4%BD%BF%E7%94%A8contextvars">如何使用contextvars模块和源码分析</a>。</p><p><code>context</code>的使用方法很简单， 首先是创建一个<code>context</code>封装的类:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">from</span> contextvars <span class="hljs-keyword">import</span> ContextVar, Token<br><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> Any, Dict, Optional, Set<br><br>context: ContextVar[Dict[<span class="hljs-built_in">str</span>, Any]] = ContextVar(<span class="hljs-string">&quot;context&quot;</span>, default=&#123;&#125;)<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Context</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;基础的context调用，支持Type Hints检查&quot;&quot;&quot;</span><br>    tenant_id: <span class="hljs-built_in">str</span><br>    replace_table_set: Set[<span class="hljs-built_in">str</span>]<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__getattr__</span>(<span class="hljs-params">self, key: <span class="hljs-built_in">str</span></span>) -&gt; Any:</span><br>        value: Any = context.get().get(key)<br>        <span class="hljs-keyword">return</span> value<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__setattr__</span>(<span class="hljs-params">self, key: <span class="hljs-built_in">str</span>, value: Any</span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        context.get()[key] = value<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WithContext</span>(<span class="hljs-params">Context</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;简单的处理reset token逻辑，和context管理，只用在业务代码&quot;&quot;&quot;</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        self._token: Optional[Token] = <span class="hljs-literal">None</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__enter__</span>(<span class="hljs-params">self</span>) -&gt; &quot;WithContext&quot;:</span><br>        self._token = context.<span class="hljs-built_in">set</span>(&#123;&#125;)<br>        <span class="hljs-keyword">return</span> self<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__exit__</span>(<span class="hljs-params">self, exc_type: Any, exc_val: Any, exc_tb: Any</span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        <span class="hljs-keyword">if</span> self._token:<br>            context.reset(self._token)<br>            self._token = <span class="hljs-literal">None</span><br></code></pre></td></tr></table></figure><p>接下来在业务代码中，通过context传入当前业务对应的参数:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">with</span> WithContext <span class="hljs-keyword">as</span> context:<br>    context.tenant_id = <span class="hljs-string">&quot;xxx&quot;</span><br>    context.replace_table_set = &#123;<span class="hljs-string">&quot;t_demo&quot;</span>&#125;<br>    <span class="hljs-keyword">with</span> conn.cursor() <span class="hljs-keyword">as</span> cursor:<br>        cursor.execute(<span class="hljs-string">&quot;SELECT * FROM t_demo WHERE is_del=%s&quot;</span>, (<span class="hljs-number">0</span>, ))<br></code></pre></td></tr></table></figure><p>然后在<code>mogrify</code>中通过调用<code>context</code>即可获得对应的参数了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> pymysql<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cursor</span>(<span class="hljs-params">pymysql.cursors.Cursor</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">mogrify</span>(<span class="hljs-params">self, query: <span class="hljs-built_in">str</span>, args: Union[<span class="hljs-literal">None</span>, <span class="hljs-built_in">list</span>, <span class="hljs-built_in">dict</span>, <span class="hljs-built_in">tuple</span>] = <span class="hljs-literal">None</span></span>) -&gt; str:</span><br>        tenant_id: <span class="hljs-built_in">str</span> = context.tenant_id<br>        replace_table_set: Set[<span class="hljs-built_in">str</span>] = context.replace_table_set<br>        <span class="hljs-comment"># 在此可以编写处理还合成的SQL逻辑</span><br>        mogrify_sql: <span class="hljs-built_in">str</span> = <span class="hljs-built_in">super</span>().mogrify(query, args)<br>        <span class="hljs-comment"># 在此可以编写处理合成后的SQL逻辑</span><br>        <span class="hljs-keyword">return</span> mogrify_sql<br></code></pre></td></tr></table></figure><h2 id="4-修改SQL"><a href="#4-修改SQL" class="headerlink" title="4.修改SQL"></a>4.修改SQL</h2><p>现在，万事俱备，只剩下修改SQL的逻辑，之前在做别的项目的时候，建的表都是十分的规范，它们是以<code>t_xxx</code>的格式给表命名，这样一来替换表名十分方便，只要进行两次替换就可以兼容大多数情况了，代码如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> pymysql<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cursor</span>(<span class="hljs-params">pymysql.cursors.Cursor</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">mogrify</span>(<span class="hljs-params">self, query: <span class="hljs-built_in">str</span>, args: Union[<span class="hljs-literal">None</span>, <span class="hljs-built_in">list</span>, <span class="hljs-built_in">dict</span>, <span class="hljs-built_in">tuple</span>] = <span class="hljs-literal">None</span></span>) -&gt; str:</span><br>        tenant_id: <span class="hljs-built_in">str</span> = context.tenant_id<br>        replace_table_set: Set[<span class="hljs-built_in">str</span>] = context.replace_table_set<br>        <span class="hljs-comment"># 简单示例，实际上正则的效率会更好</span><br>        <span class="hljs-keyword">for</span> replace_table <span class="hljs-keyword">in</span> replace_table_set:<br>            <span class="hljs-keyword">if</span> replace_table <span class="hljs-keyword">in</span> query:<br>                <span class="hljs-comment"># 替换表名</span><br>                query = query.replace(<span class="hljs-string">f&quot; <span class="hljs-subst">&#123;replace_table&#125;</span> &quot;</span>, <span class="hljs-string">f&quot; <span class="hljs-subst">&#123;replace_table&#125;</span>_<span class="hljs-subst">&#123;tenant_id&#125;</span> &quot;</span>)<br>                <span class="hljs-comment"># 替换查询条件中带有表名的</span><br>                query = query.replace(<span class="hljs-string">f&quot; <span class="hljs-subst">&#123;replace_table&#125;</span>.&quot;</span>, <span class="hljs-string">f&quot; <span class="hljs-subst">&#123;replace_table&#125;</span>_<span class="hljs-subst">&#123;tenant_id&#125;</span>.&quot;</span>)<br>        mogrify_sql: <span class="hljs-built_in">str</span> = <span class="hljs-built_in">super</span>().mogrify(query, args)<br>        <span class="hljs-comment"># 在此可以编写处理合成后的SQL逻辑</span><br>        <span class="hljs-keyword">return</span> mogrify_sql<br></code></pre></td></tr></table></figure><p>但是现在项目的SQL规范并不是很好，有些表名还是<code>MySQL</code>的关键字，所以靠简单的替换是行不通的，同时这个需求中，一些表只需要字段隔离，需要确保有带上对应的字段查询，这就意味着必须有一个库可以来解析<code>SQL</code>，并返回一些数据使我们可以比较方便的知道<code>SQL</code>中哪些是表名，哪些是查询字段了。</p><p>目前在Python中有一个比较知名的<code>SQL</code>解析库–<a href="https://github.com/andialbrecht/sqlparse">sqlparse</a>，它可以通过解析引擎把SQL解析成一个<code>Python对象</code>,之后我们就可以通过一些语法来判断哪些是<code>SQL</code>关键字， 哪些是表名，哪些是查询条件等等。但是这个库只实现一些底层的API，我们需要对他和SQL比较了解之后才能实现一些比较完备的功能，比如下面3种常见的SQL:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t_demo<br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t_demo <span class="hljs-keyword">as</span> demo<br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t_other <span class="hljs-keyword">as</span> other <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> t_demo demo <span class="hljs-keyword">on</span> demo.xxx<span class="hljs-operator">=</span><span class="hljs-operator">=</span>other.xxx<br></code></pre></td></tr></table></figure><p>如果我们要通过<code>sqlparse</code>来提取表名的话就需要处理这3种情况，而我们如果要每一个情况都编写出来的话，那将会非常费心费力，同时也可能存在遗漏的情况，这时就需要用到另外一个库–<a href="https://github.com/macbre/sql-metadata">sql_metadata</a>，这个库是基于<code>sqlparse</code>和正则的解析库，同时提供了大量的常见使用方法的封装，我们通过直接调用对应的函数就能知道<code>SQL</code>中有哪些表名，查询字段是什么了。</p><blockquote><p>目前已知这个库有一个缺陷，就是会自动去掉字段的符号， 比如表名为关键字时，我们需要使用`符号把它包起来：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> `<span class="hljs-keyword">case</span>`<br></code></pre></td></tr></table></figure><p>但在经过<code>sql_metadata</code>解析后得到的表名是<code>case</code>而不是`case`，需要人为的处理，但是我并不觉得这是一个BUG，自己不按规范创建表，能怪谁呢。</p></blockquote><p>接下来就可以通过<code>sql_metadata</code>的方法来实现我需要的功能了，在根据需求修改后，代码长这样(说明见注释)：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> Dict, Set, Tuple, Union<br><span class="hljs-keyword">import</span> pymysql<br><span class="hljs-keyword">import</span> sql_metadata<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cursor</span>(<span class="hljs-params">pymysql.cursors.Cursor</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">mogrify</span>(<span class="hljs-params">self, query: <span class="hljs-built_in">str</span>, args: Union[<span class="hljs-literal">None</span>, <span class="hljs-built_in">list</span>, <span class="hljs-built_in">dict</span>, <span class="hljs-built_in">tuple</span>] = <span class="hljs-literal">None</span></span>) -&gt; str:</span><br>        tenant_id: <span class="hljs-built_in">str</span> = context.tenant_id<br>        <span class="hljs-comment"># 生成一个解析完成的SQL对象</span><br>        sql_parse: sql_metadata.Parser = sql_metadata.Parser(query)<br><br>        <span class="hljs-comment"># 新加的一个属性，这里存下需要校验查询条件的表名</span><br>        check_flag = <span class="hljs-literal">False</span> <br>        where_table_set: Set[<span class="hljs-built_in">str</span>] = context.where_table_set<br>        <span class="hljs-comment"># 该方法会获取到SQL对应的table，返回的是一个table的数组</span><br>        <span class="hljs-keyword">for</span> table_name <span class="hljs-keyword">in</span> sql_parse.tables:<br>            <span class="hljs-keyword">if</span> table_name <span class="hljs-keyword">in</span> where_table_set:<br>                <span class="hljs-keyword">if</span> sql_parse.columns_dict:<br>                    <span class="hljs-comment"># 该方法会返回SQL对应的字段，其中分为select, join, where等，这里只用到了where</span><br>                    <span class="hljs-keyword">for</span> where_column <span class="hljs-keyword">in</span> sql_parse.columns_dict.get(<span class="hljs-string">&quot;where&quot;</span>, []):<br>                        <span class="hljs-comment"># 如果连表，里面存的是类似于t_demo.tenant_id，所以要兼容这一个情况</span><br>                        <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;tenant_id&quot;</span> <span class="hljs-keyword">in</span> where_column.lower().split(<span class="hljs-string">&quot;.&quot;</span>):<br>                            check_flag = <span class="hljs-literal">True</span><br>                            <span class="hljs-keyword">break</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> check_flag:<br>            <span class="hljs-comment"># 检查不通过就抛错</span><br>            <span class="hljs-keyword">raise</span> RuntimeError()<br><br><br>        <span class="hljs-comment"># 更换表名的逻辑</span><br>        replace_table_set: Set[<span class="hljs-built_in">str</span>] = context.replace_table_set<br>        new_query: <span class="hljs-built_in">str</span> = query<br>        <span class="hljs-keyword">for</span> table_name <span class="hljs-keyword">in</span> sql_parse.tables:<br>            <span class="hljs-keyword">if</span> table_name <span class="hljs-keyword">in</span> replace_table_set:<br>                new_query = <span class="hljs-string">&quot;&quot;</span><br>                <span class="hljs-comment"># tokens存放着解析完的数据，比如SELECT * FROM t_demo解析后是</span><br>                <span class="hljs-comment"># [SELECT, *, FROM, t_demo]四个token</span><br>                <span class="hljs-keyword">for</span> token <span class="hljs-keyword">in</span> sql_parse.tokens:<br>                    <span class="hljs-comment"># 判断token是否是表名  </span><br>                    <span class="hljs-keyword">if</span> token.is_potential_table_name:<br>                        <span class="hljs-comment"># 提取规范的表名</span><br>                        parse_table_name: <span class="hljs-built_in">str</span> = token.stringified_token.strip()<br>                        <span class="hljs-keyword">if</span> parse_table_name <span class="hljs-keyword">in</span> replace_table_set:<br>                            new_table_name: <span class="hljs-built_in">str</span> = <span class="hljs-string">f&quot; <span class="hljs-subst">&#123;parse_table_name&#125;</span>_<span class="hljs-subst">&#123;tenant_id&#125;</span>&quot;</span><br>                            <span class="hljs-comment"># next_token代表SQL的下一个字段</span><br>                            <span class="hljs-keyword">if</span> token.next_token.normalized != <span class="hljs-string">&quot;AS&quot;</span>:<br>                                <span class="hljs-comment"># 如果当前表没有设置别名</span><br>                                <span class="hljs-comment"># 通过AS把替换前的表名设置为新表名的别名，这样一来后面的表名即使没进行更改，也是能读到对应商户ID的表</span><br>                                new_table_name += <span class="hljs-string">f&quot; AS <span class="hljs-subst">&#123;parse_table_name&#125;</span>&quot;</span><br>                            query += new_table_name<br>                            <span class="hljs-keyword">continue</span><br>                    <span class="hljs-comment"># 通过stringified_token获取的数据会自动带空格，比如`FROM`得到的会是` FROM`，这样拼接的时候就不用考虑是否加空格了</span><br>                    new_query += token.stringified_token<br>        <br>        mogrify_sql: <span class="hljs-built_in">str</span> = <span class="hljs-built_in">super</span>().mogrify(new_query, args)<br>        <span class="hljs-comment"># 在此可以编写处理合成后的SQL逻辑</span><br>        <span class="hljs-keyword">return</span> mogrify_sql<br></code></pre></td></tr></table></figure><p>这份代码十分简单，它只做简单介绍，事实上这段逻辑会应用到所有的<code>SQL</code>查询中，我们应该要保证这段代码是没问题的，同时不要有太多的性能浪费，所以在使用的时候要考虑到代码拆分和优化。<br>比如在使用的过程中可以发现，我们的<code>SQL</code>转换和检查都是在父类的<code>Cursor.mogrify</code>之前进行的，这就意味着不管我们代码逻辑里<code>cursor.execute</code>传的参数是什么，对于同一个代码逻辑来说，传过来的<code>query</code>值是保持不变的，比如下面的代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_user_info</span>(<span class="hljs-params">uid: <span class="hljs-built_in">str</span></span>) -&gt; Dict[str, Any]:</span><br>    <span class="hljs-keyword">with</span> conn.cursor() <span class="hljs-keyword">as</span> cursor:<br>        cursor.execute(<span class="hljs-string">&quot;SELECT * FROM t_user WHERE uid=%(uid)s&quot;</span>, &#123;<span class="hljs-string">&quot;uid&quot;</span>: uid&#125;)<br>        <span class="hljs-keyword">return</span> cursor.fetchone() <span class="hljs-keyword">or</span> &#123;&#125;<br></code></pre></td></tr></table></figure><p>这段代码中传到<code>Cursor.mogrify</code>的query永远为<code>SELECT * FROM t_user WHERE uid=%(uid)s</code>，有变化的只是args中uid的不同。<br>有了这样的一个前提条件，那么我们就可以把<code>query</code>的校验结果和转换结果缓存下来，减少每次都需要解析<code>SQL</code>再校验造成的性能浪费。至于如何实现缓存则需要根据自己的项目来决定，比如项目中只有几百个<code>SQL</code>执行，那么直接用<code>Python</code>的<code>dict</code>来存放就可以了，如果项目中执行的<code>SQL</code>很多，同时有些执行的频率非常的高，有些执行的频率非常的低，那么可以考虑使用<code>LRU</code>来缓存。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前记&quot;&gt;&lt;a href=&quot;#前记&quot; class=&quot;headerlink&quot; title=&quot;前记&quot;&gt;&lt;/a&gt;前记&lt;/h2&gt;&lt;p&gt;在项目的演变过程中，有时可能会诞生一些需要奇怪的临时需求，这些需求会涉及到所有的SQL，但开发时间上却不允许整个项目的所有SQL进行重写，比如控制不同的人访问表的权限，或者是我面对的SASS化需求，这时就需要在运行时根据对应的条件来修改SQL语句。&lt;/p&gt;</summary>
    
    
    <content src="https://cdn.jsdelivr.net/gh/so1n/so1n_blog_photo@master/blog_photo/1646990753600sql.png" type="image"/>
    
    
    <category term="SQL" scheme="http://so1n.me/categories/SQL/"/>
    
    
    <category term="Python" scheme="http://so1n.me/tags/Python/"/>
    
    <category term="SQL" scheme="http://so1n.me/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>Pre-Worker服务模型问题的思考</title>
    <link href="http://so1n.me/2022/03/07/Pre-Worker%E6%9C%8D%E5%8A%A1%E6%A8%A1%E5%9E%8B%E9%97%AE%E9%A2%98%E7%9A%84%E6%80%9D%E8%80%83/"/>
    <id>http://so1n.me/2022/03/07/Pre-Worker%E6%9C%8D%E5%8A%A1%E6%A8%A1%E5%9E%8B%E9%97%AE%E9%A2%98%E7%9A%84%E6%80%9D%E8%80%83/</id>
    <published>2022-03-07T15:33:18.000Z</published>
    <updated>2022-03-10T03:37:23.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前记"><a href="#前记" class="headerlink" title="前记"></a>前记</h2><p>目前TCP服务的工作模型有三种，但是开源的服务器基本上都是使用<code>Pre-Worker</code>模型，比如<code>Nginx</code>和<code>Gunicorn</code>。在阅读<code>Gunicorn</code>源码后我对<code>Gunicorn</code>为啥要采用这个模型感兴趣，所以查阅了一番资料并了解常见TCP服务工作模型的优缺点。</p><h2 id="1-TCP服务的请求处理模式"><a href="#1-TCP服务的请求处理模式" class="headerlink" title="1.TCP服务的请求处理模式"></a>1.TCP服务的请求处理模式</h2><p>大多数的TCP服务部署都是从单进程开始的，当请求数量逐渐变多后，单进程工作模型的服务就开始扛不住了， 这时就会想通过添加更多的进程来帮忙处理请求，于是就会诞生出另外两种基于多进程的工作模型， 这三种工作模型的特点如下（其中监听可以认为是调用<code>socket.listen</code>，处理可以认为调用<code>socket.accept</code>）：</p><ul><li><p>1.单个进程监听和处理<code>socket</code>。</p><p>  这是最简单的工作模型， 只有单个进程同时监听和执行同一个<code>socket.accpet</code>调用来接受新连接以及处理请求。</p></li><li><p>2.单个进程监听<code>socket</code>，多个工作进程处理<code>socket</code>（<code>Nginx</code>和<code>Gunicorn</code>的工作模式）。</p><p>  这是最常用的工作模式，整个进程组中有且只有一个<code>socket</code>，主进程负责监听<code>socket</code>，工作进程负责执行<code>socket.accept</code>调用来接受新连接和处理请求。（工作进程的负载均衡由系统决定）</p></li><li><p>3.多个工作进程，每个工作进程都有单独监听和处理的<code>socket</code>。</p><p>  每个工作进程都有一个独立的<code>socket</code>，并且通过<code>SO_REUSEPORT</code>标记使这类<code>socket</code>都能监听和处理相同的ip端口的请求。(工作进程的负负载均衡是由每个请求的hash决定)</p></li></ul><p>上面三种工作模式的主要不同点是监听和处理的方式不同，这是因为<code>Linux</code>采用<code>socket</code>对TCP， UDP进行了封装，并产生了一套独立的调用过程，而开发者在使用<code>socket</code>进行TCP的网络编程时一般有几个步骤：</p><ul><li><p>1.调用<code>socket.bind</code>，给该<code>socket</code>实例绑定一个IP和端口，这样后续内核会把收到该IP端口的网络流量转发给该<code>socket</code>。</p></li><li><p>2.调用<code>socket.listen</code>，该调用对应着TCP的<code>listen</code>状态，当调用这个函数后，服务端就会进入到这个状态，意味着可以开始处理客户端的请求了。</p><p>  调用<code>socket.listen</code>函数后，内核为该<code>socket</code>维护两个队列，一个是已经建立连接的队列，代表客户端与服务端的连接已经三次握手完毕；另外一个是还没有完全建立连接的队列，代表客户端已经与服务端开始尝试连接，但三次握手还没完成。</p></li><li><p>3.调用<code>socket.accept</code>，从已经建立连接的队列获取连接来处理，如果获取不到连接，则会一直等待直到内核把建立的连接返回给该进程调用，需要注意的是这时候返回的是另外一个<code>socket</code>，也就是监听的是一个<code>socket</code>，<code>accept</code>后是另一个<code>socket</code>，然后服务端就会通过调用新返回的<code>socket</code>的<code>socket.read</code>和<code>socket.write</code>方法来与客户端进行交互。</p></li></ul><p>其中第二第三交互步骤如图：<br><img    class="lazyload" data-original="https://cdn.jsdelivr.net/gh/so1n/so1n_blog_photo@master/blog_photo/1646586321755Pre-Worker%E6%9C%8D%E5%8A%A1%E6%A8%A1%E5%9E%8B%E9%97%AE%E9%A2%98%E7%9A%84%E6%80%9D%E8%80%83-socket%E4%BA%A4%E4%BA%92.jpg" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">Pre-Worker服务模型问题的思考-socket交互</span></p><p>了解完了<code>socket</code>的交互步骤后再回顾上面的三种工作模式可以发现，第一种工作模式是一个进程包了3个调用步骤，第二种工作模式则是主进程包了前面两个调用，工作进程包了第三个调用。之所以这样区分是因为第二种工作模式一般都是采用主进程来管理工作进程，通过拓展多个工作进程来处理更多的请求数量，但是<code>socket.accept</code>是一个阻塞操作，而且每个请求进来的时候，服务端都会<code>accept</code>一次， 如果把<code>socket.accept</code>调用放在主进程，那么<code>socket.accept</code>的阻塞操作就会成为服务的处理请求瓶颈，拓展再多的工作进程也无法提升服务端的处理性能。</p><p>但是第二种工作模式也无法一味的通过提升进程来提升服务端的处理性能，因为这种工作模式会出现惊群效应。</p><h2 id="2-惊群效应"><a href="#2-惊群效应" class="headerlink" title="2.惊群效应"></a>2.惊群效应</h2><p>对于<code>Pre-Worker</code>模型， 有一个最典型的问题就是惊群效应，惊群效应产生的原因是由于系统不知道网络数据包是何时到来，所以系统中对于网络数据包的接收都是采用异步进行的。</p><p>当服务端的<code>socket</code>处于listen状态之后就可以开始处理客户端的请求了，这时所有<code>Worker</code>进程都处于调用<code>socket.accept</code>后睡眠的状态中。而客户端发出的数据包会先抵达到网卡上，网卡就会通知内核数据包已经到了，内核就会开始将数据包填充到对应的<code>socket</code>队列并通知持有该<code>socket</code>的进程，由于目前没有进程来处理该请求，所以内核就会把所有持有该<code>socket</code>的进程全部都唤醒，但是最后只有一个进程能收到这个请求并执行后续的处理，其它的进程被唤醒后发现并没有数据可以接收则会继续睡眠。这些进程虽然被唤醒后没有执行任何操作，但是内核已经执行了对进程的调度和上下文的切换， 当并发量很大的时候，这几个步骤就会十分的影响服务性能，进而降低服务的并发能力。</p><p>可以看出，惊群效应就是多个进程抢夺一个资源而产生的问题，要解决这个问题，就需要解决资源的竞争，所以<code>Linux</code>内核通过引入一个名为<code>WQ_FLAG_EXCLUSIVE</code>的标记位来解决这个问题，当<code>Worker</code>进程调用<code>socket.accept</code>时，内核会发现这个操作带有<code>WQ_FLAG_EXCLUSIVE</code>的标记，就把他加入到一个<code>accept</code>队列的尾部， 每当有一个请求进来的时候，内核只会从这个队列的头部取出一个进程来处理请求，进程处理完成后内核再把它加入到队列的尾部，等待下次的请求到达。通过这样的设计，<code>Pre-Worker</code>就能避免了一个请求唤醒一片进程的情况。</p><h3 id="2-1-Event-Loop的惊群效应"><a href="#2-1-Event-Loop的惊群效应" class="headerlink" title="2.1.Event Loop的惊群效应"></a>2.1.Event Loop的惊群效应</h3><p>通过查阅资料发现<code>Linux</code>通过<code>WQ_FLAG_EXCLUSIVE</code>标记解决了<code>socket.accept</code>的惊群问题， 但是现在很多服务通过基于事件循环的方法来提供更高的并发能力。比如我线上运行的服务就是用到了<code>Gevent</code>，而<code>Gevent</code>用到的核心事件循环则是<code>Epoll</code>，它与<code>Select</code>, <code>Poll</code>并称为<code>Event Loop</code>。</p><p>对于任何工作模式来说， 使用<code>Event Loop</code>后，进程调用<code>socket.accept</code>后的行为逻辑就不一样了，具体的逻辑步骤如下：</p><ul><li>1.进程在调用<code>socket.accept</code>时，<code>Event Loop</code>会把进程挂在<code>socket</code>对应的文件描述符的等待队列上。</li><li>2.当<code>socket</code>的文件描述符有事件产生时，对应的驱动就会将等待队列上对应的进程进行唤醒。</li><li>3.被唤醒的进程会通过<code>Event Loop</code>检查事件是否就绪，如果事件就绪就会返回对应的事件给刚才的进程。</li><li>4.检查<code>accept</code>事件是否可调用， 如果可以就执行<code>accept</code>操作，并取得该四元组的对应<code>socket</code>。</li></ul><p>可以看到，之前进程是挂在网络驱动上等着被内核唤醒，而在使用<code>Event Loop</code>后进程是挂在对应文件描述符的等待队列上等待被<code>Event Loop</code>唤醒，对于<code>Pre-Worker</code>模型下的每个工作进程虽然都有自己专属的<code>Event Loop</code>，但是他们都是等待着同样的资源，于是当该文件描述符有事件产生时，就会唤醒所有工作进程对应的<code>Event Loop</code>来检查事件以及判断是否可以返回事件给工作进程, 而且由于是通过<code>Event Loop</code>的逻辑来执行<code>socket.accept</code>，这样会绕过上面所说的<code>WQ_FLAG_EXCLUSIVE</code>标记的限制，从而又产生了惊群效应。</p><p>可以看到，<code>Event Loop</code>产生惊群效应的原因跟进程直接调用<code>sock.accept</code>十分的像，所以他们的解决思路也很像，首先是给<code>Event Loop</code>增加一个名为<code>EPOLLEXCLUSIVE</code>的标记， 然后开发者在编程时可以在<code>Event Loop</code>实例化后注册对应的标记,当进程在调用<code>sock.accept</code>且系统检到<code>Event Loop</code>带有该标记时，就会把进程挂在文件描述符的队列尾部，等到事件产生时，内核会只唤醒该队列的第一个进程来处理对应的事件。</p><blockquote><p>关于标记<code>EPOLLEXCLUSIVE</code>的具体内容可见:<a href="https://lwn.net/Articles/632590/">Add epoll round robin wakeup mode</a>， 通过内容还可以知道还有一个标记<code>EPOLLROUNDROBIN</code>用来解决唤醒不均衡的情况，但是在<code>Python</code>中似乎没办法使用。</p></blockquote><h2 id="3-负载不均衡问题"><a href="#3-负载不均衡问题" class="headerlink" title="3.负载不均衡问题"></a>3.负载不均衡问题</h2><h3 id="3-1-一次线上日志的分析"><a href="#3-1-一次线上日志的分析" class="headerlink" title="3.1.一次线上日志的分析"></a>3.1.一次线上日志的分析</h3><p>目前线上其中一个服务的运行架构简化为下图：<br><img    class="lazyload" data-original="https://cdn.jsdelivr.net/gh/so1n/so1n_blog_photo@master/blog_photo/1646412224744Gunicorn%E8%BF%9B%E7%A8%8B%E9%A5%A5%E9%A5%BF%E7%9A%84%E6%80%9D%E8%80%83-%E7%BA%BF%E4%B8%8A%E6%9C%8D%E5%8A%A1%E6%A8%A1%E5%9E%8B.jpg" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">线上服务运行架构</span></p><p>这个服务前置了一台<code>Nginx</code>，并由<code>Nginx</code>均衡地转发给后面的两个<code>Gunicorn</code>绑定的端口，这两个<code>Gunicorn</code>的<code>Worker</code>都采用<code>Gevent Worker</code>，同时<code>Worker</code>设置的数量是10个。<br>另外服务的应用程序每收到一条请求都会打印一条请求日志，该日志带有<code>Worker</code>的<code>Pid</code>，于是通过请求日志中<code>Pid</code>出现的次数就可以知道该<code>Worker</code>接受的请求数量有多少，在进行分析后得到的数据如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 数据经过简单的人为排序</span><br><span class="hljs-comment"># 两个字段分别是处理数量  PID</span><br> 311245 2042<br> 311909 2034<br>  77711 2025<br>  78707 2041<br>  25023 2001<br>  25062 2022<br>  10017 2019<br>   9546 2020<br>   4239 2009<br>   4475 2010<br>   2629 2005<br>   2544 2033<br>   1077 2006<br>   1174 2026<br>   1608 1974<br>   1705 2003<br>    238 1898<br>    249 1977<br>    262 1896<br>    296 1897<br>    329 1928<br>    333 1994<br>    342 1903<br>    371 1915<br>    373 1950<br>    386 1917<br>    458 1909<br>    467 1934<br>    485 1972<br>    516 1927<br>    599 1963<br>    679 1916<br>    917 2008<br>    923 2004<br></code></pre></td></tr></table></figure><p>通过数据可以发现，每个<code>Worker</code>处理的请求数量都是不一致的，且每2个<code>Worker</code>处理的数量是接近的，在经过上面的服务运行架构可以发现有个数据特点：</p><ul><li>1.不同的实例下的<code>Worker</code>处理请求数量分布十分的接近。如PID 2042属于<code>Gunicorn</code>实例1的<code>Worker</code>, PID 2034属于<code>Gunicorn</code>实例2的<code>Worker</code>，他们处理的请求数量分别为311245和311909，相差不大，且远远超过了同实例下的其它<code>Worker</code>处理的请求数量。</li><li>2.不同的<code>Worker</code>处理的请求数量差别很大，处理请求数量最多的<code>Worker</code>比其它<code>Worker</code>处理请求的数量还多(同一实例情况下)</li></ul><p>通过第一点可以发现<code>Nginx</code>的负载均衡是生效的，因为每个实例接收到请求是相近的，且每个实例的<code>Worker</code>接收请求数量的分布十分的接近。。通过第二点可以发现不同<code>Worker</code>的请求数量差别非常的大，它们之间相差的最大倍数达到了100倍，这极有可能是<code>Gunicorn</code>导致分发给<code>Worker</code>的请求不均衡。</p><p>这样的数据标明了服务存在部分进程饿死的现象，即使加再多的<code>Worker</code>也很难去分担之前<code>Worker</code>的请求，反而会因为进程过多导致服务器上下文切换次数变多而性能下降。</p><p>由于之前一直在使用<code>Asyncio</code>，所以我知道<code>Event Loop</code>在收到对应文件描述符的事件时，它不是以雨露均沾的方式去唤醒进程/线程/协程，而是会优先唤醒第一个注册的进程/线程/协程，只有第一个进程/线程/协程繁忙的情况下才会去唤醒后面的进程/线程/协程，造成了唤醒倾斜的问题，所以我猜测是这个规则引发了负载不均衡的问题。以下是一个验证<code>Event Loop</code>唤醒规则的demo代码以及注释如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> asyncio<br><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> Counter<br><br><br><span class="hljs-comment"># 统计是协程对应的消费次数</span><br>cnt: Counter = Counter()<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">consumer</span>(<span class="hljs-params">aid: <span class="hljs-built_in">int</span>, queue: asyncio.Queue</span>):</span><br>    <span class="hljs-comment"># 消费者，用于消费队列的数据</span><br>    print(aid, <span class="hljs-string">&quot;init&quot;</span>)<br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        <span class="hljs-keyword">await</span> queue.get()<br>        cnt[aid] += <span class="hljs-number">1</span><br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sleep_consumer</span>(<span class="hljs-params">aid: <span class="hljs-built_in">int</span>, queue: asyncio.Queue</span>):</span><br>    <span class="hljs-comment"># 消费者，用于消费队列的数据</span><br>    print(aid, <span class="hljs-string">&quot;init&quot;</span>)<br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        <span class="hljs-keyword">await</span> queue.get()<br>        <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">0.1</span>)<br>        cnt[aid] += <span class="hljs-number">1</span><br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    <span class="hljs-comment"># 创建队列以及消费者协程</span><br>    a_queue: asyncio.Queue = asyncio.Queue()<br>    b_queue: asyncio.Queue = asyncio.Queue()<br>    <span class="hljs-keyword">for</span> a_id <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):<br>        <span class="hljs-keyword">if</span> a_id // <span class="hljs-number">2</span> == a_id / <span class="hljs-number">2</span>:<br>            asyncio.ensure_future(consumer(a_id, a_queue))<br>        <span class="hljs-keyword">else</span>:<br>            asyncio.ensure_future(sleep_consumer(a_id, b_queue))<br><br>    <span class="hljs-comment"># 等待所有消费者协程创建完成</span><br>    <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">0.01</span>)<br><br>    <span class="hljs-comment"># 推送数据到队列</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):<br>        <span class="hljs-keyword">if</span> i // <span class="hljs-number">2</span> == i / <span class="hljs-number">2</span>:<br>            a_queue.put_nowait(i)<br>        <span class="hljs-keyword">else</span>:<br>            b_queue.put_nowait(i)<br><br>    <span class="hljs-comment"># 等待都消费了才退出</span><br>    <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">1</span>)<br><br><br>asyncio.run(main())<br>print(cnt)<br></code></pre></td></tr></table></figure><p>该程序的消费者注册到<code>Event Loop</code>的先后顺序与他们的ID有关，该程序中有两个队列，它们对应着两种类型的消费者， 第一种消费者只做消费（序号为偶数的消费者），第二种消费者除了消费外还休眠了0.1秒(序号为奇数的消费者)， 在运行程序后，程序的输出结果如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">0 init<br>1 init<br>2 init<br>3 init<br>4 init<br>5 init<br>6 init<br>7 init<br>8 init<br>9 init<br>Counter(&#123;0: 5, 1: 1, 3: 1, 5: 1, 7: 1, 9: 1&#125;)<br></code></pre></td></tr></table></figure><p>通过输出结果可以发现，10个消费者协程已经创建了，<br>对于带有休眠的消费者(序号1,3,5,7,9)他们都消费了一条数据，但对于普通的消费者(0,2,4,6,8)，只有0号消费者有消费，这是因为在普通的消费者中，0号消费者是最早注册的，且这类型的消费者从队列获取数据所花费的CPU时间非常的少，所以0号消费者消费一次数据后又立即收到了<code>Event Loop</code>的调度继续消费，而带有休眠的消费者因为他们的休眠占用了一些时间，<code>Event Loop</code>调度了最先注册的消费者后想继续调度却发现它处于繁忙状态，这时就会调度下一个注册的消费者， 最终达到均匀的调度到每一个消费者。</p><p>不过这个例子只是单进程下跑出来的结果， 为了更更贴生产服务，我把<code>Gunicorn</code>的<code>Sync Worker</code>和<code>Gevent Worker</code>抽象为下面两个简单的TCP模型，他们的代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-comment">############################</span><br><span class="hljs-comment"># 模仿Sync Work工作模式的代码 #</span><br><span class="hljs-comment">############################</span><br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> socket<br><span class="hljs-keyword">import</span> time<br><br><span class="hljs-comment"># 初始化sock</span><br>sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)<br>sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, <span class="hljs-number">1</span>)<br>sock.bind((<span class="hljs-string">&#x27;127.0.0.1&#x27;</span>, <span class="hljs-number">8000</span>))<br>sock.listen()<br><span class="hljs-keyword">try</span>:<br>    <span class="hljs-comment"># fork 出3个进程</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>):<br>        pid = os.fork()<br>        <span class="hljs-keyword">if</span> pid == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>                <span class="hljs-comment"># 该循环是接收请求并把自己的pid发送给客户端</span><br>                cs_sock, _ = sock.accept()<br>                <span class="hljs-comment"># send方法不会阻塞</span><br>                cs_sock.send(<span class="hljs-built_in">str</span>(os.getpid()).encode())<br>                cs_sock.close()<br>                <span class="hljs-comment"># 模仿IO</span><br>                time.sleep(<span class="hljs-number">0.001</span>)<br>    os.wait()<br><span class="hljs-keyword">finally</span>:<br>    sock.close()<br><br><span class="hljs-comment">##############################</span><br><span class="hljs-comment"># 模仿Gevent Work工作模式的代码 #</span><br><span class="hljs-comment">##############################</span><br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> select<br><span class="hljs-keyword">import</span> socket<br><br><span class="hljs-comment"># 用于模仿IO的文件描述符</span><br>r, _ = os.pipe()<br><br><span class="hljs-comment"># 初始化sock</span><br>sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)<br>sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, <span class="hljs-number">1</span>)<br>sock.bind((<span class="hljs-string">&#x27;127.0.0.1&#x27;</span>, <span class="hljs-number">8000</span>))<br>sock.listen()<br>sock.setblocking(<span class="hljs-literal">False</span>)<br><span class="hljs-keyword">try</span>:<br>    <span class="hljs-comment"># fork 出3个进程</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>):<br>        pid = os.fork()<br>        <span class="hljs-keyword">if</span> pid == <span class="hljs-number">0</span>:<br>            <span class="hljs-comment"># 初始化两个epoll,一个用来处理请求一个用于模仿阻塞</span><br>            epoll = select.epoll()<br>            epoll.register(sock, select.EPOLLIN | select.EPOLLEXCLUSIVE)<br>            sleep_epoll = select.epoll()<br>            sleep_epoll.register(r, select.EPOLLIN | select.EPOLLEXCLUSIVE)<br>            <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>                <span class="hljs-keyword">try</span>:<br>                    <span class="hljs-comment"># 等待事件</span><br>                    epoll.poll()<br>                <span class="hljs-keyword">except</span> IOError:<br>                    <span class="hljs-keyword">continue</span><br><br>                <span class="hljs-comment"># 事件循环下调用`sock.accept`会报错</span><br>                <span class="hljs-keyword">try</span>:<br>                    cs_sock, _ = sock.accept()<br>                <span class="hljs-keyword">except</span> socket.error:<br>                    <span class="hljs-keyword">continue</span><br>                <span class="hljs-comment"># send方法不会阻塞</span><br>                cs_sock.send(<span class="hljs-built_in">str</span>(os.getpid()).encode())<br>                cs_sock.close()<br>                <span class="hljs-comment"># 模仿IO</span><br>                sleep_epoll.poll(timeout=<span class="hljs-number">0.001</span>)<br><br>    os.wait()<br><span class="hljs-keyword">finally</span>:<br>    sock.close()<br></code></pre></td></tr></table></figure><p>服务端代码创建完成了， 接下来可以使用客户端代码来进行测试并统计， 代码如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> asyncio<br><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> Counter<br><br><br><span class="hljs-comment"># 统计pid</span><br>cnt = Counter()<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">tcp_echo_client</span>():</span><br>    <span class="hljs-string">&quot;&quot;&quot;从Asyncio文档复制过来的最小TCP Client代码&quot;&quot;&quot;</span><br>    reader, writer = <span class="hljs-keyword">await</span> asyncio.open_connection(<span class="hljs-string">&#x27;127.0.0.1&#x27;</span>, <span class="hljs-number">8000</span>)<br>    data = <span class="hljs-keyword">await</span> reader.read(<span class="hljs-number">1024</span>)<br>    <span class="hljs-comment"># 获取服务端返回的Pid来统计数据</span><br>    cnt[data.decode()] += <span class="hljs-number">1</span><br>    writer.close()<br><br><span class="hljs-comment"># 模拟5000个并发</span><br>asyncio.get_event_loop().run_until_complete(<br>    asyncio.gather(*[tcp_echo_client() <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5000</span>)])<br>)<br>print(cnt)<br></code></pre></td></tr></table></figure><p>一切准备就绪，分别对两个模式的代码进行测试，结果如下:</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-meta"># Sync Worker模型下测试的结果</span><br>Counter(&#123;&#x27;<span class="hljs-number">2410</span>2&#x27;: <span class="hljs-number">1668</span>, &#x27;<span class="hljs-number">2410</span>1&#x27;: <span class="hljs-number">1667</span>, &#x27;<span class="hljs-number">2410</span>3&#x27;: <span class="hljs-number">1665</span>&#125;)<br><span class="hljs-meta"># Gevent Worker模型下测试的结果</span><br>Counter(&#123;&#x27;<span class="hljs-number">2440</span>3&#x27;: <span class="hljs-number">1774</span>, &#x27;<span class="hljs-number">2440</span>4&#x27;: <span class="hljs-number">1738</span>, &#x27;<span class="hljs-number">2441</span>0&#x27;: <span class="hljs-number">1488</span>&#125;)<br></code></pre></td></tr></table></figure><p>通过结果可以看出<code>Sync Worker</code>的输出结果是三个工作进程得到请求的数量是相近的，而<code>Gevent Worker</code>的三个工作进程得到请求的数量是不均衡的，特别是第三个工作进程得到请求点数量比前两个还少（如果去掉模仿IO的代码，<code>Gevent Worker</code>模型下测试的结果只有一个工作进程得到了所有请求点数量）。</p><h2 id="4-两种问题的共同解决方案–SO-REUSEPORT"><a href="#4-两种问题的共同解决方案–SO-REUSEPORT" class="headerlink" title="4.两种问题的共同解决方案–SO_REUSEPORT"></a>4.两种问题的共同解决方案–SO_REUSEPORT</h2><p>现在回顾下这两种问题，他们的核心都是围绕着对同一个资源（文件描述符/事件）进行争夺，如果能解决这一点，那么两个问题都能得到解决。而之所以需要对同一个资源进行争夺是因为<code>Pre-Worker</code>模型下是由<code>Master</code>进程创建了用户指定IP端口的<code>socket</code>并在调用监听操作后才分给工作进程的，如果这些<code>socket</code>都能由工作进程创建，那就能解决问题了。<br>可是在进行网络编程时，经常能发现端口被占用导致服务无法启动的情况，这就意味着工作进程不能创建监听相同IP端口的<code>socket</code>，这时就需要<code>SO_REUSEPORT</code>了。</p><p>通过<code>SO_REUSEPORT</code>，操作系统允许多个工作进程的<code>socket</code>绑定到同一个端口，这时候服务的工作模式就变为上面所说的第三种，既多个工作进程，每个工作进程都有单独监听和处理的<code>socket</code>，这种工作模式下每个工作进程持有的文件描述符都是自己专有的，没人一起争夺,这样无论是<code>Synv Worker</code>调用<code>socket.accept</code>还是<code>Gevent Worker</code>调用的<code>socket.accept</code>,他们都不会出现争夺的问题而产生惊群效应，他们的交互变化如图:<br><img    class="lazyload" data-original="https://cdn.jsdelivr.net/gh/so1n/so1n_blog_photo@master/blog_photo/1646586327619Pre-Worker%E6%9C%8D%E5%8A%A1%E6%A8%A1%E5%9E%8B%E9%97%AE%E9%A2%98%E7%9A%84%E6%80%9D%E8%80%83-%E4%B8%8D%E5%90%8C%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F%E4%BA%A4%E4%BA%92%E5%9B%BE.jpg" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">Pre-Worker服务模型问题的思考-不同工作模式交互图</span><br>通过图可以看出，在使用<code>SO_REUSEPORT</code>后，对于同一个IP端口从单个Accept队列变为多个Accept队列，每个队列对于工作进程来说都是独有的，并且<code>Linux</code>会通过对四元组把请求hash到不同的Accept队列，最后使得每个<code>Worker</code>都能获得相同的连接数量，从而实现负载均衡。<br>为了验证<code>SO_REUSEPORT</code>是否发挥作用，现在基于上面<code>Gevent Workrt</code>模型的简易代码进行修改:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> select<br><span class="hljs-keyword">import</span> socket<br><br><span class="hljs-comment"># 用于模仿阻塞的文件描述符</span><br>r, w = os.pipe()<br><br><br><span class="hljs-keyword">try</span>:<br>    <span class="hljs-comment"># fork 出3个进程</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>):<br>        pid = os.fork()<br>        <span class="hljs-keyword">if</span> pid == <span class="hljs-number">0</span>:<br>            <span class="hljs-comment"># 把初始化sock挪到fork之后</span><br>            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)<br>            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, <span class="hljs-number">1</span>)<br>            <span class="hljs-comment"># 设置端口复用</span><br>            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEPORT, <span class="hljs-number">1</span>)<br>            sock.bind((<span class="hljs-string">&#x27;127.0.0.1&#x27;</span>, <span class="hljs-number">8000</span>))<br>            sock.listen()<br>            sock.setblocking(<span class="hljs-literal">False</span>)<br>            <span class="hljs-comment"># 初始化两个epoll,一个用来处理请求一个用于模仿阻塞</span><br>            epoll = select.epoll()<br>            epoll.register(sock, select.EPOLLIN | select.EPOLLEXCLUSIVE)<br>            sleep_epoll = select.epoll()<br>            sleep_epoll.register(r, select.EPOLLIN | select.EPOLLEXCLUSIVE)<br>            <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>                <span class="hljs-keyword">try</span>:<br>                    epoll.poll()<br>                <span class="hljs-keyword">except</span> IOError:<br>                    <span class="hljs-keyword">continue</span><br><br>                <span class="hljs-comment"># 事件循环下调用`sock.accept`会报错</span><br>                <span class="hljs-keyword">try</span>:<br>                    cs_sock, _ = sock.accept()<br>                <span class="hljs-keyword">except</span> socket.error:<br>                    <span class="hljs-keyword">continue</span><br>                <span class="hljs-comment"># send方法不会阻塞</span><br>                cs_sock.send(<span class="hljs-built_in">str</span>(os.getpid()).encode())<br>                cs_sock.close()<br>                <span class="hljs-comment"># 模仿阻塞</span><br>                sleep_epoll.poll(timeout=<span class="hljs-number">0.001</span>)<br><br>    os.wait()<br><span class="hljs-keyword">finally</span>:<br>    sock.close()<br></code></pre></td></tr></table></figure><p>修改完成后，再运行刚才的客户端测试脚本， 得到输出如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Python">Counter(&#123;<span class="hljs-string">&#x27;16070&#x27;</span>: <span class="hljs-number">1686</span>, <span class="hljs-string">&#x27;16069&#x27;</span>: <span class="hljs-number">1682</span>, <span class="hljs-string">&#x27;16071&#x27;</span>: <span class="hljs-number">1632</span>&#125;)<br></code></pre></td></tr></table></figure><p>通过结果可以看出虽然第一个工作进程得到的数量还是最多的，但是三个工作进程之间的差距已经是非常的小了。</p><blockquote><p>Gunicorn虽然支持设置<code>SO_REUSEPORT</code>但是他自带的<code>Worker</code>类型仍然是以第二种工作模式运行着，所以我们需要去修改它的<code>Worker</code>，才能以第三种工作模式运行。</p></blockquote><p>不过，使用了<code>SO_REUSEPORT</code>后会带来两个新的问题，第一个也就是官方自己说的(如下)，如果绑定到同一个端口的<code>socket</code>数量发生变化时，hash就会有变动，这个时候如果有个请求处于三次握手期间，那么它将会被丢弃，这种情况下客户端会重置请求，但服务端仍然会留下一个孤独的请求结构。</p><blockquote><p><a href="https://lwn.net/Articles/542629/">The SO_REUSEPORT socket option</a>:</p><p>The other noteworthy point is that there is a defect in the current implementation of TCP SO_REUSEPORT. If the number of listening sockets bound to a port changes because new servers are started or existing servers terminate, it is possible that incoming connections can be dropped during the three-way handshake. The problem is that connection requests are tied to a specific listening socket when the initial SYN packet is received during the handshake. If the number of servers bound to the port changes, then the SO_REUSEPORT logic might not route the final ACK of the handshake to the correct listening socket. In this case, the client connection will be reset, and the server is left with an orphaned request structure. A solution to the problem is still being worked on, and may consist of implementing a connection request table that can be shared among multiple listening sockets.</p></blockquote><p>第二个问题则是请求延迟，在第二种工作模式下，所有请求都会进到同一个Accept队列，等待工作进程来从队列拉取数据，这种情况下所有请求都是先到先被处理；而在第三种工作模式下，请求会被hash到不同进程的Accept队列，等待被持有该队列的进程拉取数据，如果这时候有个进程发生了阻塞情况，那么该进程上的Accept队列的所有请求都会一直等待，直到进程阻塞结束，这种情况下该队列的请求可能比别的队列的请求先到，但是却比别的队列的请求晚处理， 这就是请求延迟到现象。</p><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5.总结"></a>5.总结</h2><p>目前对于<code>Pre-Worker</code>问题都有了解决方案， 但是这些方案并不一定是完美的，他们可能存在着一些问题等待被解决，而我们可以根据自己的使用情况来选择不同的工作模型，在性能允许范围下规避一些已知的问题。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前记&quot;&gt;&lt;a href=&quot;#前记&quot; class=&quot;headerlink&quot; title=&quot;前记&quot;&gt;&lt;/a&gt;前记&lt;/h2&gt;&lt;p&gt;目前TCP服务的工作模型有三种，但是开源的服务器基本上都是使用&lt;code&gt;Pre-Worker&lt;/code&gt;模型，比如&lt;code&gt;Nginx</summary>
      
    
    
    <content src="https://cdn.jsdelivr.net/gh/so1n/so1n_blog_photo@master/blog_photo/1646584864565Pre-Worker%E6%9C%8D%E5%8A%A1%E6%A8%A1%E5%9E%8B%E9%97%AE%E9%A2%98%E7%9A%84%E6%80%9D%E8%80%83-%E6%94%B6%E9%93%B6%E5%8F%B0.jpg" type="image"/>
    
    
    <category term="计算机网络" scheme="http://so1n.me/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="http://so1n.me/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>gunicorn源码分析</title>
    <link href="http://so1n.me/2022/02/22/gunicorn/"/>
    <id>http://so1n.me/2022/02/22/gunicorn/</id>
    <published>2022-02-22T15:33:18.000Z</published>
    <updated>2022-03-01T17:15:33.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前记"><a href="#前记" class="headerlink" title="前记"></a>前记</h2><p><code>Gunicorn</code>是一个基于<code>Python</code>实现的动态Web服务器，它通过Pre-Worker模型来实现并发，本身带有多种工作模式，基本上可以与所有基于<code>Python</code>的Web框架集成，并为他们带来一个多功能又稳定的服务器托管核心。</p><p>从学习<code>Python</code> Web的第一天就开始接触了<code>Gunicorn</code>,那时候还不知道他具体的作用是什么， 只知道在项目中使用他运行之后可以变得十分的稳定，高性能，从未研究它是如何实现的。随着使用时间的增长，越来越想知道它的运行原理是什么，特别是它性能为何会高，跟类Unix有什么特殊结合，<code>Pre-Worker</code>模型是如何通信的，如何设计一个比较好的<code>Pre-Worker</code>模型服务器？<br>于是，本文就是阅读源码之后的产物。</p><h2 id="1-简单了解"><a href="#1-简单了解" class="headerlink" title="1.简单了解"></a>1.简单了解</h2><p>通过<a href="https://github.com/benoitc/gunicorn/tree/20.x">Gunicorn代码仓库</a>把代码拉到本地，使用<code>Tree</code>命令可以简单的看到<code>Gunicorn</code>的代码结构，可以看出文件数量并不是很多，以下是<code>Gunicorn</code>的代码结构以及他们每个文件夹或者每个文件的说明:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs bash">├── app             <span class="hljs-comment"># Gunicorn的运行实例,由该示例来运行arbiter，但在重启或者重新加载配置时，会由arbiter重新运行一个新的app实例</span><br>├── http            <span class="hljs-comment"># 用于Worker中处理客户端发送的HTTP请求</span><br>├── instrument      <span class="hljs-comment"># 使用statsd协议把自身信息发送到Statsd服务</span><br>├── workers         <span class="hljs-comment"># Pre-Worker模型中的Worker， 负责运行Web应用， 这些worker大部分都是基于WSGI协议封装的，但可以通过自定义协议封装来支持TCP传输</span><br>├── __init__.py<br>├── __main__.py<br>├── arbiter.py      <span class="hljs-comment"># Pre-Worker模型中的Master， 负责管理Worker, 配置重载，重新启动新的进程等。 </span><br>├── config.py       <span class="hljs-comment"># 加载配置相关</span><br>├── debug.py        <span class="hljs-comment"># 基于sys.settrace钩子实现的debug信息输出 </span><br>├── errors.py       <span class="hljs-comment"># Master错误的封装</span><br>├── glogging.py     <span class="hljs-comment"># 日志输出</span><br>├── pidfile.py      <span class="hljs-comment"># 进程PID文件管理 </span><br>├── reloader.py     <span class="hljs-comment"># 文件自动重载功能</span><br>├── sock.py         <span class="hljs-comment"># 对不同类型的socket做统一的封装</span><br>├── systemd.py      <span class="hljs-comment"># 激活systemd的socket，通过systemd文档即可知道如何交互，所以不做分析</span><br>└── util.py         <span class="hljs-comment"># 常用代码封装</span><br></code></pre></td></tr></table></figure><h2 id="2-开始入手"><a href="#2-开始入手" class="headerlink" title="2.开始入手"></a>2.开始入手</h2><p>了解完代码结构后接着从官方文档的示例开始入手：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ pip install gunicorn<br>$ cat myapp.py<br>  def app(environ, start_response):<br>      data = b<span class="hljs-string">&quot;Hello, World!\n&quot;</span><br>      start_response(<span class="hljs-string">&quot;200 OK&quot;</span>, [<br>          (<span class="hljs-string">&quot;Content-Type&quot;</span>, <span class="hljs-string">&quot;text/plain&quot;</span>),<br>          (<span class="hljs-string">&quot;Content-Length&quot;</span>, str(len(data)))<br>      ])<br>      <span class="hljs-built_in">return</span> iter([data])<br>$ gunicorn -w 4 myapp:app<br>[2014-09-10 10:22:28 +0000] [30869] [INFO] Listening at: http://127.0.0.1:8000 (30869)<br>[2014-09-10 10:22:28 +0000] [30869] [INFO] Using worker: sync<br>[2014-09-10 10:22:28 +0000] [30874] [INFO] Booting worker with pid: 30874<br>[2014-09-10 10:22:28 +0000] [30875] [INFO] Booting worker with pid: 30875<br>[2014-09-10 10:22:28 +0000] [30876] [INFO] Booting worker with pid: 30876<br>[2014-09-10 10:22:28 +0000] [30877] [INFO] Booting worker with pid: 30877<br></code></pre></td></tr></table></figure><p>这个示例演示了如何通过命令行来使<code>Gunicorn</code>来运行一个最小的<code>WSGI</code>Web应用，如果熟悉<code>Python</code>的打包规则的话，可以知道这个命令中的<code>gunicorn</code>实际上是在<code>setup.py</code>文件中定义好的， 重新打开仓库，找到<code>setup.py</code>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">from</span> setuptools <span class="hljs-keyword">import</span> setup, find_packages<br><br><br>setup(<br>    entry_points=<span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    [console_scripts]</span><br><span class="hljs-string">    gunicorn=gunicorn.app.wsgiapp:run</span><br><span class="hljs-string">    &quot;&quot;&quot;</span>,<br>)<br></code></pre></td></tr></table></figure><p>这里移除了其它部分的代码，只保留了相关的代码，在这段代码中，指定了<code>gunicorn</code>的命令是命令<code>gunicorn.app.wsgiapp:run</code>的别名，所以这段代码实际上执行了<code>gunicorn.app.wsgiapp</code>文件中的<code>run</code>函数:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span>():</span><br>    <span class="hljs-keyword">from</span> gunicorn.app.wsgiapp <span class="hljs-keyword">import</span> WSGIApplication<br>    WSGIApplication(<span class="hljs-string">&quot;%(prog)s [OPTIONS] [APP_MODULE]&quot;</span>).run()<br></code></pre></td></tr></table></figure><p>而<code>run</code>函数的运行逻辑也是很简单， 它是直接实例化一个承于<code>gunicorn.app.base</code>文件的<code>BaseApplication</code>的<code>WSGIApplication</code>类， 这个类在实例化时会执行它的<code>do_load_config</code>方法，也就是在这时候会初始化实例的<code>cfg</code>变量，并调用<code>cfg.parse</code>，其中这个实例是<code>config.Config</code>的实例化，而<code>parse</code>方法是用来解析用户传入的参数并供后续的<code>Arbiter</code>以及<code>Worker</code>使用。</p><h2 id="3-加载配置"><a href="#3-加载配置" class="headerlink" title="3.加载配置"></a>3.加载配置</h2><p>一般项目中的加载配置是没有什么可以说的， 但是<code>Gunicorn</code>比较特殊， 在<code>config</code>文件中除了<code>Config</code>这个类和一些校验方法外，还存在大量类似于：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WorkerConnections</span>(<span class="hljs-params">Setting</span>):</span><br>    name = <span class="hljs-string">&quot;worker_connections&quot;</span><br>    section = <span class="hljs-string">&quot;Worker Processes&quot;</span><br>    cli = [<span class="hljs-string">&quot;--worker-connections&quot;</span>]<br>    meta = <span class="hljs-string">&quot;INT&quot;</span><br>    validator = validate_pos_int<br>    <span class="hljs-built_in">type</span> = <span class="hljs-built_in">int</span><br>    default = <span class="hljs-number">1000</span><br>    desc = <span class="hljs-string">&quot;&quot;&quot;\</span><br><span class="hljs-string">        The maximum number of simultaneous clients.</span><br><span class="hljs-string"></span><br><span class="hljs-string">        This setting only affects the Eventlet and Gevent worker types.</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br></code></pre></td></tr></table></figure><p>的类， 这些类就是<code>Gunicorn</code>支持的参数或配置值以及它对应的类型，校验规则，默认值和帮助文档等，这些类都按照一定的规范进行编写，同时又继承于<code>Setting</code>这个类，而<code>Setting</code>这个类又继承了<code>SettingMeta</code>,而<code>SettingMeta</code>的作用就是在程序运行的时候，把所有继承于<code>Setting</code>的类加入到<code>config</code>文件的<code>local</code>变量中，供<code>Gunicorn</code>来使用。</p><blockquote><p><code>Gunicorn</code>在启动时通过<code>config</code>模块把用户传入的命令进行初始化, 再通过环境变量来初始化配置，此时的配置会覆盖掉用户传入命令初始化时的配置，接着在判断用户是否有指定配置文件，如果有就加载配置文件的配置，再覆盖已经存在的配置。<br>也就是说，配置的优先级是配置文件最高，然后环境变量次之，用户通过命令行传入的配置最后会被配置文件的配置所覆盖，<br>但是读取配置文件路径的优先级是命令行最高，然后才是环境变量。</p></blockquote><h2 id="4-Gunicorn的核心–Arbiter-run"><a href="#4-Gunicorn的核心–Arbiter-run" class="headerlink" title="4.Gunicorn的核心–Arbiter.run"></a>4.Gunicorn的核心–Arbiter.run</h2><p><code>Application</code>实例化完成后，会调用<code>BaseApplication.run</code>方法, 该方法如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span>(<span class="hljs-params">self</span>):</span><br>    <span class="hljs-keyword">try</span>:<br>        Arbiter(self).run()<br>    <span class="hljs-keyword">except</span> RuntimeError <span class="hljs-keyword">as</span> e:<br>        print(<span class="hljs-string">&quot;\nError: %s\n&quot;</span> % e, file=sys.stderr)<br>        sys.stderr.flush()<br>        sys.exit(<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p>该方法会执行<code>gunicorn.arbiter</code>文件的<code>Arbiter</code>类，这个类是<code>gunicorn</code>的核心类，负责启动和管理所有运行的worker，而<code>Arbiter</code>的<code>run</code>方法则是核心中的核心，负责着整个服务的运行管理，同时又跟<code>Arbiter</code>的其它方法有交互，所以可以通过分析<code>run</code>方法进行分析，进而纵观整个<code>Arbiter</code>类, <code>run</code>的方法如下（具体说明见注释,其它具体分析见小章节）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span>(<span class="hljs-params">self</span>):</span><br>    <span class="hljs-string">&quot;Main master loop.&quot;</span><br>    <span class="hljs-comment"># 1.初始化实例，并信号监听以及sock</span><br>    self.start()<br>    util._setproctitle(<span class="hljs-string">&quot;master [%s]&quot;</span> % self.proc_name)<br><br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-comment"># 2.创建worker直到worker数量满足用户的指定条件，如果当前worker数量超过用户指定的条件，则会杀掉创建时间比较长的worker</span><br>        self.manage_workers()<br><br>        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>            <span class="hljs-comment"># 3.负责判断该进程是否是正真的master，如果是则提升为正真的master(这一块放在最后一部分进行分析)</span><br>            self.maybe_promote_master()<br><br>            <span class="hljs-comment"># 4.获取信号</span><br>            sig = self.SIG_QUEUE.pop(<span class="hljs-number">0</span>) <span class="hljs-keyword">if</span> self.SIG_QUEUE <span class="hljs-keyword">else</span> <span class="hljs-literal">None</span><br>            <span class="hljs-keyword">if</span> sig <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>                <span class="hljs-comment"># 5.利用select休眠1小时</span><br>                self.sleep()<br>                <span class="hljs-comment"># 6.判断worker是否超时，如果是则杀掉worker(将在Worker章节进行分析) </span><br>                self.murder_workers()<br>                self.manage_workers()<br>                <span class="hljs-keyword">continue</span><br><br>            <span class="hljs-keyword">if</span> sig <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> self.SIG_NAMES:<br>                self.log.info(<span class="hljs-string">&quot;Ignoring unknown signal: %s&quot;</span>, sig)<br>                <span class="hljs-keyword">continue</span><br><br>            signame = self.SIG_NAMES.get(sig)<br>            <span class="hljs-comment"># 调用对应的信号处理</span><br>            handler = <span class="hljs-built_in">getattr</span>(self, <span class="hljs-string">&quot;handle_%s&quot;</span> % signame, <span class="hljs-literal">None</span>)<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> handler:<br>                self.log.error(<span class="hljs-string">&quot;Unhandled signal: %s&quot;</span>, signame)<br>                <span class="hljs-keyword">continue</span><br>            self.log.info(<span class="hljs-string">&quot;Handling signal: %s&quot;</span>, signame)<br>            handler()<br>            <span class="hljs-comment"># 7.这样下次循环就不会等待一秒了</span><br>            self.wakeup()<br>    <span class="hljs-comment"># 8.服务异常，进行退出处理</span><br>    <span class="hljs-keyword">except</span> (StopIteration, KeyboardInterrupt):<br>        <span class="hljs-comment"># 收到用户的退出信号(按下CTRL+C) </span><br>        self.halt()<br>    <span class="hljs-keyword">except</span> HaltServer <span class="hljs-keyword">as</span> inst:<br>        <span class="hljs-comment"># Worker运行异常的时候</span><br>        self.halt(reason=inst.reason, exit_status=inst.exit_status)<br>    <span class="hljs-keyword">except</span> SystemExit:<br>        <span class="hljs-keyword">raise</span><br>    <span class="hljs-keyword">except</span> Exception:<br>        <span class="hljs-comment"># 其它的运行异常</span><br>        self.log.info(<span class="hljs-string">&quot;Unhandled exception in main loop&quot;</span>,<br>                      exc_info=<span class="hljs-literal">True</span>)<br>        self.stop(<span class="hljs-literal">False</span>)<br>        <span class="hljs-keyword">if</span> self.pidfile <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            self.pidfile.unlink()<br>        sys.exit(-<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><h3 id="4-1初始化–Arbiter-start"><a href="#4-1初始化–Arbiter-start" class="headerlink" title="4.1初始化–Arbiter.start"></a>4.1初始化–Arbiter.start</h3><p><code>Arbiter.start</code>方法的第一步是进行初始化，首先是判断该进程是否是另一个进程启动的，这里是<code>Gunicorn</code>的<a href="https://docs.gunicorn.org/en/stable/signals.html#upgrading-to-a-new-binary-on-the-fly">Upgrading to a new binary on the fly</a>功能，将在后面统一说明，然后他通过<code>init_signals</code>方法初始化信号的回调, <code>init_signals</code>的源码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">init_signals</span>(<span class="hljs-params">self</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;\</span><br><span class="hljs-string">    Initialize master signal handling. Most of the signals</span><br><span class="hljs-string">    are queued. Child signals only wake up the master.</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-comment"># close old PIPE</span><br>    <span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> self.PIPE:<br>        os.close(p)<br><br>    <span class="hljs-comment"># initialize the pipe</span><br>    self.PIPE = pair = os.pipe()<br>    <span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> pair:<br>        util.set_non_blocking(p)<br>        util.close_on_exec(p)<br><br>    self.log.close_on_exec()<br><br>    <span class="hljs-comment"># initialize all signals</span><br>    <span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> self.SIGNALS:<br>        signal.signal(s, self.signal)<br>    <span class="hljs-comment"># 捕获子进程exit前发出的sigchld信号,然后函数里面通过waitpid来收拾，避免僵尸进程的存在</span><br>    signal.signal(signal.SIGCHLD, self.handle_chld)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">signal</span>(<span class="hljs-params">self, sig, frame</span>):</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(self.SIG_QUEUE) &lt; <span class="hljs-number">5</span>:<br>        self.SIG_QUEUE.append(sig)<br>        self.wakeup()<br><br></code></pre></td></tr></table></figure><p>这个方法做了两件事:</p><ul><li><p>1.首先是初始化<code>PIPE</code>, <code>Gunicorn</code>的<code>Master</code>是一个一直在循环的单进程，每次循环会<code>sleep</code>一秒防止空转，通过<code>PIPE</code>可以使<code>Master</code>进程从<code>sleep</code>阶段提前唤醒。<code>PIPE</code>在初始化时会先通过<code>util.set_non_blocking</code>方法来设置不阻塞来防止<code>PIPE</code>收到信号时，阻塞到<code>Master</code>进程的主流程。 </p><p>  然后通过<code>util.close_on_exec</code>来关闭子进程无用的描述符，之所以要这样处理是因为<code>Gunicorn</code>采用了<code>Pre-Worker</code>的模型，在运行的时候<code>Master</code>进程会通过<code>fork</code>的方法来创建<code>worker</code>进程，<code>fork</code>出来的子进程是通过写时复制来获得父进程的数据的，当子进程在<code>exec</code>阶段时就会创建一份新的资源引用，此时保存原来文件描述符的变量当然也不存在了，也就无法关闭无用的文件描述符了， 这意味着对于某个文件描述符多了一个引用，而<code>Linux</code>的文件描述符是等到都没有引用的时候才会删掉， 所以我们在使用的时候都会期望在<code>fork</code>阶段后，<code>exec</code>阶段之前直接关掉无用的物件描述符，这时候就可以用到<code>Linux</code>的<code>close-on-exec</code>功能。 </p><p>  在初始化文件描述符后， 通过直接对文件描述符设置<code>FD_CLOEXEC</code>标记， 这样在<code>fork</code>阶段后<code>exec</code>阶段前，<code>Linux</code>会自动关掉无用的文件描述符， 在<code>Gunicorn</code>中，会对所有文件描述符都调用<code>util.close_on_exec</code>。</p></li><li><p>2.初始化真正的信号监听， 注册了<code>Gunicortn</code>所有会用到的信号回调，该回调会把信息注册到一个名为<code>SIG_QUEUE</code>的队列中，同时会执行<code>wakeup</code>来唤醒<code>worker</code>的循环(将在run中的sleep介绍这个机制是怎么实现的)</p></li></ul><p>在完成了信号监听的注册后， 会开始创建<code>sock</code>,<code>Gunicorn</code>为各种类型的<code>sock</code>做了统一的封装， 它会判断用户配置要监听的<code>IP</code>端口来挑选一个合适的<code>sock</code>,然后进行初始化，其中最重要的初始化方法就是<code>BaseCocket</code>的<code>set_options</code>方法， 它的源码如下: </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseSocket</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, address, conf, log, fd=<span class="hljs-literal">None</span></span>):</span><br>        ...<br>        <span class="hljs-comment"># 初始化sock</span><br>        self.sock = self.set_options(sock, bound=bound)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">set_options</span>(<span class="hljs-params">self, sock, bound=<span class="hljs-literal">False</span></span>):</span><br>        <span class="hljs-comment"># 设置sock的功能</span><br>        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">if</span> (self.conf.reuse_port<br>            <span class="hljs-keyword">and</span> <span class="hljs-built_in">hasattr</span>(socket, <span class="hljs-string">&#x27;SO_REUSEPORT&#x27;</span>)):  <span class="hljs-comment"># pragma: no cover</span><br>            <span class="hljs-keyword">try</span>:<br>                sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEPORT, <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">except</span> socket.error <span class="hljs-keyword">as</span> err:<br>                <span class="hljs-keyword">if</span> err.errno <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> (errno.ENOPROTOOPT, errno.EINVAL):<br>                    <span class="hljs-keyword">raise</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> bound:<br>            self.bind(sock)<br>        <span class="hljs-comment"># 设置不阻塞</span><br>        sock.setblocking(<span class="hljs-number">0</span>)<br><br>        <span class="hljs-comment"># make sure that the socket can be inherited</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">hasattr</span>(sock, <span class="hljs-string">&quot;set_inheritable&quot;</span>):<br>            sock.set_inheritable(<span class="hljs-literal">True</span>)<br>        <br>        <span class="hljs-comment"># 开始监听</span><br>        sock.listen(self.conf.backlog)<br>        <span class="hljs-keyword">return</span> sock<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">bind</span>(<span class="hljs-params">self, sock</span>):</span><br>        sock.bind(self.cfg_addr)<br></code></pre></td></tr></table></figure><p>在<code>Gunicorn</code>中，它创建的所有<code>Scoket</code>都是继承于<code>gunicorn.sock.BaseSocket</code>,所以<code>Gunicorn</code>在创建<code>scoket</code>后会调用<code>set_options</code>方法，这个方法默认会设置<code>SO_REUSEADDR</code>标记，然后再依赖配置设置<code>SO_REUSEPORT</code>标记， 设置<code>SO_REUSEPORT</code>标记可以解决部分惊群问题，同时也能解决不同进程收到请求的负载均衡问题，但是会带来响应请求的延迟，所以<code>Gunicorn</code>将这个配置设置为可选项（关于这几个参数以及惊群问题会另开文章说明）。 接着<code>Gunicorn</code>会调用<code>sock.bind</code>且设置<code>scoket</code>是不阻塞的，再进行监听，并返回给<code>Master</code>。 </p><p><code>Gunicorn</code>之所以这样做是因为<code>Gunicorn</code>是<code>Pre-Worker</code>模型的，在这个模型中， 所有的<code>scoket</code>都是由<code>Master</code>进程创建并监听，然后在通过<code>fork</code>子进程的时候把<code>scoket</code>传递给子进程，然后子进程可以通过该<code>scoket</code>可以进行<code>accept</code>获取到对应的请求。</p><h3 id="4-2-管理woeker数量–manage-workers"><a href="#4-2-管理woeker数量–manage-workers" class="headerlink" title="4.2.管理woeker数量–manage_workers"></a>4.2.管理woeker数量–manage_workers</h3><p>在<code>Gunicorn</code>的<code>Arbiter</code>中，通过<code>manage_workers</code>方法对<code>Worker</code>进行管理， 当前运行的<code>Worker</code>数量不满足与用户指定的数量时，会通过<code>spawn_workers</code>来调用<code>spawn_worker</code>创建<code>Worker</code>，<code>spawn_workers</code>是批量创建一批<code>Worker</code>，而<code>spawn_worker</code>是每次调用创建一个<code>Worker</code>,他们的代码十分简单, 具体说明见注释:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">spawn_worker</span>(<span class="hljs-params">self</span>):</span><br>    <span class="hljs-comment"># 每个新创建的Worker, age都加1, Worker越大，则代表越新</span><br>    self.worker_age += <span class="hljs-number">1</span><br>    <span class="hljs-comment"># 把一些参数传给worker</span><br>    worker = self.worker_class(self.worker_age, self.pid, self.LISTENERS,<br>                               self.app, self.timeout / <span class="hljs-number">2.0</span>,<br>                               self.cfg, self.log)<br>    self.cfg.pre_fork(self, worker)<br>    <span class="hljs-comment"># 开始Fork</span><br>    pid = os.fork()<br>    <span class="hljs-keyword">if</span> pid != <span class="hljs-number">0</span>:<br>        <span class="hljs-comment"># 对于主进程，记录创建的worker</span><br>        worker.pid = pid<br>        self.WORKERS[pid] = worker<br>        <span class="hljs-keyword">return</span> pid<br><br>    <span class="hljs-comment"># 对于创建的子进程</span><br>    <br>    <span class="hljs-comment"># 不继承其它worker的tmp文件</span><br>    <span class="hljs-keyword">for</span> sibling <span class="hljs-keyword">in</span> self.WORKERS.values():<br>        sibling.tmp.close()<br><br>    worker.pid = os.getpid()<br>    <span class="hljs-keyword">try</span>:<br>        util._setproctitle(<span class="hljs-string">&quot;worker [%s]&quot;</span> % self.proc_name)<br>        self.log.info(<span class="hljs-string">&quot;Booting worker with pid: %s&quot;</span>, worker.pid)<br>        self.cfg.post_fork(self, worker)<br>        <span class="hljs-comment"># 开始运行，在init_process方法编写worker的方法，因为__init__方法属于在主进程运行</span><br>        worker.init_process()<br>        <span class="hljs-comment"># exit 0 代表进程常退出</span><br>        sys.exit(<span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">except</span> SystemExit:<br>        <span class="hljs-keyword">raise</span><br>    <span class="hljs-keyword">except</span> AppImportError <span class="hljs-keyword">as</span> e:<br>        <span class="hljs-comment"># 初始化实例失败</span><br>        self.log.debug(<span class="hljs-string">&quot;Exception while loading the application&quot;</span>,<br>                       exc_info=<span class="hljs-literal">True</span>)<br>        print(<span class="hljs-string">&quot;%s&quot;</span> % e, file=sys.stderr)<br>        sys.stderr.flush()<br>        sys.exit(self.APP_LOAD_ERROR)<br>    <span class="hljs-keyword">except</span> Exception:<br>        <span class="hljs-comment"># 其它失败方法</span><br>        self.log.exception(<span class="hljs-string">&quot;Exception in worker process&quot;</span>)<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> worker.booted:<br>            sys.exit(self.WORKER_BOOT_ERROR)<br>        sys.exit(-<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">finally</span>:<br>        self.log.info(<span class="hljs-string">&quot;Worker exiting (pid: %s)&quot;</span>, worker.pid)<br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-comment"># 不管如何，都要关闭临时文件</span><br>            worker.tmp.close()<br>            self.cfg.worker_exit(self, worker)<br>        <span class="hljs-keyword">except</span> Exception:<br>            self.log.warning(<span class="hljs-string">&quot;Exception during worker exit:\n%s&quot;</span>,<br>                             traceback.format_exc())<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">spawn_workers</span>(<span class="hljs-params">self</span>):</span><br>    <span class="hljs-comment"># 判断现在还需要多少个worker, 并创建</span><br>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(self.num_workers - <span class="hljs-built_in">len</span>(self.WORKERS)):<br>        self.spawn_worker()<br>        <span class="hljs-comment"># 随机休息一段时间， 防止同时创建多个worker</span><br>        time.sleep(<span class="hljs-number">0.1</span> * random.random())<br></code></pre></td></tr></table></figure><p>在这里面中有两个注意点，第一个点是在<code>spawn_worker</code>中，会先初始化<code>worker</code>,接着在<code>fork</code>出子进程运行代码部分会先执行<code>worker.init_process</code>最后调用<code>sys.exit(0)</code>退出，所以我们最好不要在<code>worker.__init__</code>里面初始化数据，因为这部分是在<code>Master</code>进程中执行的。我们应该在<code>worker.init_process</code>中执行初始化,并在初始化代码执行后调用<code>super().init_process()</code>,如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">init_process</span>(<span class="hljs-params">self</span>):</span><br>    <span class="hljs-comment"># 初始化代码</span><br>    <span class="hljs-built_in">super</span>().init_process()<br></code></pre></td></tr></table></figure><p>这样做是因为<code>BaseWorker</code>会在自己的<code>init_process</code>方法中执行一些通用的初始化功能，然后再调用<code>BaseWorker.run</code>来运行<code>Worker</code>。</p><h3 id="4-3-核心循环与信号处理"><a href="#4-3-核心循环与信号处理" class="headerlink" title="4.3.核心循环与信号处理"></a>4.3.核心循环与信号处理</h3><p>在经过<code>manage_workers</code>后，<code>Worker</code>都已经以子进程的形式在运行了，但是<code>Master</code>进程还需要处理一些家务事，比如管理<code>Worker</code>进程是否存活以及用户在运行时指派给<code>Master</code>的一些工作等，而这些将通过信号来进行交互。</p><p>这个阶段的<code>Master</code>以一个循环不断的跑着， 如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    <span class="hljs-comment"># 3.负责判断该进程是否是正真的master，如果是则提升为正真的master(这一块放在最后一部分进行分析)</span><br>    self.maybe_promote_master()<br><br>    <span class="hljs-comment"># 4.获取信号</span><br>    sig = self.SIG_QUEUE.pop(<span class="hljs-number">0</span>) <span class="hljs-keyword">if</span> self.SIG_QUEUE <span class="hljs-keyword">else</span> <span class="hljs-literal">None</span><br>    <span class="hljs-keyword">if</span> sig <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>        <span class="hljs-comment"># 5.利用select休眠1小时</span><br>        self.sleep()<br>        <span class="hljs-comment"># 6.判断worker是否超时，如果是则杀掉worker(将在Worker章节进行分析) </span><br>        self.murder_workers()<br>        self.manage_workers()<br>        <span class="hljs-keyword">continue</span><br><br>    <span class="hljs-keyword">if</span> sig <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> self.SIG_NAMES:<br>        self.log.info(<span class="hljs-string">&quot;Ignoring unknown signal: %s&quot;</span>, sig)<br>        <span class="hljs-keyword">continue</span><br><br>    signame = self.SIG_NAMES.get(sig)<br>    <span class="hljs-comment"># 调用对应的信号处理</span><br>    handler = <span class="hljs-built_in">getattr</span>(self, <span class="hljs-string">&quot;handle_%s&quot;</span> % signame, <span class="hljs-literal">None</span>)<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> handler:<br>        self.log.error(<span class="hljs-string">&quot;Unhandled signal: %s&quot;</span>, signame)<br>        <span class="hljs-keyword">continue</span><br>    self.log.info(<span class="hljs-string">&quot;Handling signal: %s&quot;</span>, signame)<br>    handler()<br>    <span class="hljs-comment"># 7.这样下次循环就不会等待一秒了</span><br>    self.wakeup()<br></code></pre></td></tr></table></figure><p>它的运行逻辑很简单，首先是判断当前进程是不是真的主进程，如果是将晋升为主进程，然后就是获取信号，如果当前信号队列有信号存在就取最前的一个并执行对应的信号对用以及调用<code>wakeup</code>方法，防止下次循环还在睡眠；如果获取不到信号，就先休眠1秒，然后清除超时的<code>Worker</code>最后执行<code>manage_worker</code>并进入下个循环。</p><p>在<code>Gunicorn</code>中，它确保每个循环只执行一次操作，确保该循环要不就执行信号回调，要不就执行<code>Worker</code>管理，同时它还确保执行信号回调的优先级是最高的，但是<code>Gunicorn</code>对传入的信号的数量也有限制，通过<code>4.1.初始化--Arbiter.start</code>的源码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">signal</span>(<span class="hljs-params">self, sig, frame</span>):</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(self.SIG_QUEUE) &lt; <span class="hljs-number">5</span>:<br>        self.SIG_QUEUE.append(sig)<br>        self.wakeup()<br></code></pre></td></tr></table></figure><p>中可以知道，<code>Gunicorn</code>只允许最多有5个信号在队列中，防止同一时刻执行太多了信号处理，同时可以看到在正常接收信号后会执行<code>wakeup</code>函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">wakeup</span>(<span class="hljs-params">self</span>):</span><br>    <span class="hljs-keyword">try</span>:<br>        os.write(self.PIPE[<span class="hljs-number">1</span>], <span class="hljs-string">b&#x27;.&#x27;</span>)<br>    <span class="hljs-keyword">except</span> IOError <span class="hljs-keyword">as</span> e:<br>        <span class="hljs-keyword">if</span> e.errno <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> [errno.EAGAIN, errno.EINTR]:<br>            <span class="hljs-keyword">raise</span><br></code></pre></td></tr></table></figure><p>这个函数十分简单，就是往管道<code>PIPE</code>写入了一个字节，这样就能快速唤醒<code>Gunicorn</code>继续运行循环，不会停留在<code>sleep</code>阶段。<br>单看<code>wakeup</code>函数是无法理解它为啥能唤醒<code>Gunicorn</code>的主循环的， 需要结合<code>Arbiter.sleep</code>源码来了解<code>Gunicorn</code>为何这样设计。</p><p>通常情况下，我们都会使用<code>Python</code>的标准函数<code>time.sleep</code>来实现进程睡眠，但是该函数是阻塞的，意味着该函数运行期间是没办法通过其它方法来进行打断，所以<code>Gunicorn</code>采用了事件循环的思路实现<code>Arbiter.sleep</code>，该通过使用<code>select.select</code>来读取<code>PIPE</code>,同时设置超时为1秒，<code>sleep</code>源码如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sleep</span>(<span class="hljs-params">self</span>):</span><br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-comment"># 等待事件返回</span><br>        ready = select.select([self.PIPE[<span class="hljs-number">0</span>]], [], [], <span class="hljs-number">1.0</span>)<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> ready[<span class="hljs-number">0</span>]:<br>            <span class="hljs-comment"># 没有事件代表超时了</span><br>            <span class="hljs-keyword">return</span><br>        <span class="hljs-comment"># 获取剩余的事件，不然下次的sleep是无效的</span><br>        <span class="hljs-keyword">while</span> os.read(self.PIPE[<span class="hljs-number">0</span>], <span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">pass</span><br>    <span class="hljs-keyword">except</span> (select.error, OSError) <span class="hljs-keyword">as</span> e:<br>        <span class="hljs-comment"># <span class="hljs-doctag">TODO:</span> select.error is a subclass of OSError since Python 3.3.</span><br>        error_number = <span class="hljs-built_in">getattr</span>(e, <span class="hljs-string">&#x27;errno&#x27;</span>, e.args[<span class="hljs-number">0</span>])<br>        <span class="hljs-comment"># 如果是中断或者重试错误，则直接return</span><br>        <span class="hljs-keyword">if</span> error_number <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> [errno.EAGAIN, errno.EINTR]:<br>            <span class="hljs-keyword">raise</span><br>    <span class="hljs-keyword">except</span> KeyboardInterrupt:<br>        sys.exit()<br></code></pre></td></tr></table></figure><p>在这段逻辑中，会把<code>PIPE</code>的读文件描述符传给<code>select.select</code>中,这样<code>select.select</code>会等待<code>PIPE</code>的事件再返回，同时它的最大等待时间为1秒，之后这段运行逻辑会停留在这里，但并不会阻塞当前进程，如果这时候进程有收到信号，进程还是可以正常接收信号, 并通过<code>wakeup</code>函数往<code>PIPE</code>写入一个字节，接着<code>select.select</code>就能通过<code>PIPE</code>捕获到事件并返回，这时候上面停留的代码逻辑就会继续执行，等于<code>sleep</code>函数可以提前结束等待，<code>Gunicorn</code>的主循环能继续转了。</p><blockquote><p>这一段主要是依赖于事件循环相关来防止主进程被阻塞，可以通过搜索<code>事件循环</code>，<code>epoll</code>来了解更多相关的。<br>如果想知道如何在阻塞代码中实现一个协程，可以通过文章–<a href="https://so1n.me/2021/11/08/%E5%88%9D%E8%AF%86Python%20Async%E7%9A%84%E5%AE%9E%E7%8E%B0/">初识Python协程的实现</a>了解</p></blockquote><h2 id="5-无感切换实例"><a href="#5-无感切换实例" class="headerlink" title="5.无感切换实例"></a>5.无感切换实例</h2><p>在分析<code>Arbiter</code>，有几处都是先忽略跳过不分析，这部分的功能我把他称为无感切换新实例，这里的无感是指与<code>Gunicorn</code>绑定的scoket交互的应用程序，如<code>Nginx</code>或者客户端等。<br>这个功能可以使<code>Gunicorn</code>的实例在运行的时候，重新开一个新的<code>Gunicorn</code>实例来运行我们指定的代码，这时候读取的代码和配置都是最新的，与我们当前正在运行的旧实例不一样，但是他们都能针对同一批socket处理请求(可用于滚动发布以及灰度发布)。</p><blockquote><p>为了方便阐述，我把一个<code>Master</code>进程与它fork出来的<code>Worker</code>进程统称为一个实例。</p></blockquote><p>实际上官方把这个功能称为：<a href="https://docs.gunicorn.org/en/stable/signals.html#upgrading-to-a-new-binary-on-the-fly">Upgrading to a new binary on the fly</a>，这个功能是大多数<code>Pre-Worker</code>模型的服务器都会支持的，不过这个功能需要多块不同生命周期的代码来结合才可以完成，所以单独拎出来分析。</p><p>根据文档：</p><blockquote><p>First, replace the old binary with a new one, then send a USR2 signal to the current master process. It executes a new binary whose PID file is postfixed with .2 (e.g. /var/run/gunicorn.pid.2), which in turn starts a new master process and new worker processes</p></blockquote><p>可以知道，<code>Master</code>进程在收到<code>USR2</code>的信号后，会创建一个新的实例，这部分的源代码如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">handle_usr2</span>(<span class="hljs-params">self</span>):</span><br>    <span class="hljs-comment"># 收到信号，执行对应的函数 </span><br>    self.reexec()<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reexec</span>(<span class="hljs-params">self</span>):</span><br>    <span class="hljs-comment"># 防止多个信号同时处理</span><br>    <span class="hljs-keyword">if</span> self.reexec_pid != <span class="hljs-number">0</span>:<br>        self.log.warning(<span class="hljs-string">&quot;USR2 signal ignored. Child exists.&quot;</span>)<br>        <span class="hljs-keyword">return</span><br><br>    <span class="hljs-keyword">if</span> self.master_pid != <span class="hljs-number">0</span>:<br>        self.log.warning(<span class="hljs-string">&quot;USR2 signal ignored. Parent exists.&quot;</span>)<br>        <span class="hljs-keyword">return</span><br><br>    master_pid = os.getpid()<br>    self.reexec_pid = os.fork()<br>    <span class="hljs-keyword">if</span> self.reexec_pid != <span class="hljs-number">0</span>:<br>        <span class="hljs-comment"># 对于主进程，不用再执行对应的代码</span><br>        <span class="hljs-keyword">return</span><br><br>    <span class="hljs-comment"># 对于fork出来的子进程，执行的代码逻辑</span><br>    self.cfg.pre_exec(self)<br><br>    <span class="hljs-comment"># 复制当前Master进程初始化时的环境变量（不被后面运行时的变量影响）</span><br>    environ = self.cfg.env_orig.copy()<br>    <span class="hljs-comment"># 设置当前Master进程的PID</span><br>    environ[<span class="hljs-string">&#x27;GUNICORN_PID&#x27;</span>] = <span class="hljs-built_in">str</span>(master_pid)<br><br>    <span class="hljs-comment"># 设置文件描述符地址到环境变量</span><br>    <span class="hljs-keyword">if</span> self.systemd:<br>        environ[<span class="hljs-string">&#x27;LISTEN_PID&#x27;</span>] = <span class="hljs-built_in">str</span>(os.getpid())<br>        environ[<span class="hljs-string">&#x27;LISTEN_FDS&#x27;</span>] = <span class="hljs-built_in">str</span>(<span class="hljs-built_in">len</span>(self.LISTENERS))<br>    <span class="hljs-keyword">else</span>:<br>        environ[<span class="hljs-string">&#x27;GUNICORN_FD&#x27;</span>] = <span class="hljs-string">&#x27;,&#x27;</span>.join(<br>            <span class="hljs-built_in">str</span>(l.fileno()) <span class="hljs-keyword">for</span> l <span class="hljs-keyword">in</span> self.LISTENERS)<br><br>    <span class="hljs-comment"># 更改cwd</span><br>    os.chdir(self.START_CTX[<span class="hljs-string">&#x27;cwd&#x27;</span>])<br><br>    <span class="hljs-comment"># exec the process using the original environment</span><br>    <span class="hljs-comment"># Gunicorn通过os.execvpe来运行一个新的Master进程</span><br>    <span class="hljs-comment"># execvpe会通过PATH环境变量来查找用户指定的程序，并用当前的Python运行环境来运行程序，同时使用的是指定的环境变量</span><br>    <span class="hljs-comment"># 其中用到的参数分别是：</span><br>    <span class="hljs-comment">#   0是当前的Python运行环境</span><br>    <span class="hljs-comment">#   args是参数</span><br>    <span class="hljs-comment">#   environ是环境变量</span><br>    os.execvpe(self.START_CTX[<span class="hljs-number">0</span>], self.START_CTX[<span class="hljs-string">&#x27;args&#x27;</span>], environ)<br></code></pre></td></tr></table></figure><p>按官方文档的示例，当<code>Gunicorn</code>执行完这段逻辑后，就有一个新的<code>Gunicorn</code>实例开始运行了，由于这个实例的环境变量中存在一个<code>GUNICORN_PID</code>的变量， 所以在运行时会有一些不一样， 比如在<code>Arbiter.start</code>进行初始化时会设置不一样的属性:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">start</span>(<span class="hljs-params">self</span>):</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;GUNICORN_PID&#x27;</span> <span class="hljs-keyword">in</span> os.environ:<br>        <span class="hljs-comment"># 代表这是一个被一个master进程创建的master进程</span><br>        self.master_pid = <span class="hljs-built_in">int</span>(os.environ.get(<span class="hljs-string">&#x27;GUNICORN_PID&#x27;</span>))<br>        self.proc_name = self.proc_name + <span class="hljs-string">&quot;.2&quot;</span><br>        self.master_name = <span class="hljs-string">&quot;Master.2&quot;</span><br><br>    self.pid = os.getpid()<br>    <span class="hljs-keyword">if</span> self.cfg.pidfile <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>        pidname = self.cfg.pidfile<br>        <span class="hljs-keyword">if</span> self.master_pid != <span class="hljs-number">0</span>:<br>            pidname += <span class="hljs-string">&quot;.2&quot;</span><br>            <span class="hljs-comment"># 重新启动时创建新的pidfile</span><br>        self.pidfile = Pidfile(pidname)<br>        self.pidfile.create(self.pid)<br></code></pre></td></tr></table></figure><p>同时，在初始化scoket时，还会沿用环境变量中名为<code>GUNICORN_FD</code>的值，这个值是创建这个实例的<code>Master</code>进程用到的文件描述符，新创建的实例通过复用相同的文件描述符，使其它也能读取到相同端口的网络请求数据：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">start</span>(<span class="hljs-params">self</span>):</span><br>    ...<br>    <span class="hljs-comment"># 省去之前的代码</span><br>    <span class="hljs-keyword">elif</span> self.master_pid:<br>        <span class="hljs-comment"># 获取之前进程的fd</span><br>        fds = []<br>        <span class="hljs-keyword">for</span> fd <span class="hljs-keyword">in</span> os.environ.pop(<span class="hljs-string">&#x27;GUNICORN_FD&#x27;</span>).split(<span class="hljs-string">&#x27;,&#x27;</span>):<br>            fds.append(<span class="hljs-built_in">int</span>(fd))<br><br>    self.LISTENERS = sock.create_sockets(self.cfg, self.log, fds)<br></code></pre></td></tr></table></figure><p>在新创建的实例运行后， 机器上的<code>Gunicorn</code>进程列表将变为这样子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-comment"># 来自官方文档</span><br>  PID USER      PR  NI  VIRT  RES  SHR S  %CPU %MEM    TIME+  COMMAND<br><span class="hljs-number">20844</span> benoitc   <span class="hljs-number">20</span>   <span class="hljs-number">0</span> <span class="hljs-number">54808</span>  11m <span class="hljs-number">3352</span> S   <span class="hljs-number">0.0</span>  <span class="hljs-number">0.1</span>   <span class="hljs-number">0</span>:<span class="hljs-number">00.36</span> gunicorn: master [test:app]<br><span class="hljs-number">20849</span> benoitc   <span class="hljs-number">20</span>   <span class="hljs-number">0</span> <span class="hljs-number">54808</span> <span class="hljs-number">9.9</span>m <span class="hljs-number">1500</span> S   <span class="hljs-number">0.0</span>  <span class="hljs-number">0.1</span>   <span class="hljs-number">0</span>:<span class="hljs-number">00.02</span> gunicorn: worker [test:app]<br><span class="hljs-number">20850</span> benoitc   <span class="hljs-number">20</span>   <span class="hljs-number">0</span> <span class="hljs-number">54808</span> <span class="hljs-number">9.9</span>m <span class="hljs-number">1500</span> S   <span class="hljs-number">0.0</span>  <span class="hljs-number">0.1</span>   <span class="hljs-number">0</span>:<span class="hljs-number">00.01</span> gunicorn: worker [test:app]<br><span class="hljs-number">20851</span> benoitc   <span class="hljs-number">20</span>   <span class="hljs-number">0</span> <span class="hljs-number">54808</span> <span class="hljs-number">9.9</span>m <span class="hljs-number">1500</span> S   <span class="hljs-number">0.0</span>  <span class="hljs-number">0.1</span>   <span class="hljs-number">0</span>:<span class="hljs-number">00.01</span> gunicorn: worker [test:app]<br><span class="hljs-number">20854</span> benoitc   <span class="hljs-number">20</span>   <span class="hljs-number">0</span> <span class="hljs-number">55748</span>  12m <span class="hljs-number">3348</span> S   <span class="hljs-number">0.0</span>  <span class="hljs-number">0.2</span>   <span class="hljs-number">0</span>:<span class="hljs-number">00.35</span> gunicorn: master [test:app]<br><span class="hljs-number">20859</span> benoitc   <span class="hljs-number">20</span>   <span class="hljs-number">0</span> <span class="hljs-number">55748</span>  11m <span class="hljs-number">1500</span> S   <span class="hljs-number">0.0</span>  <span class="hljs-number">0.1</span>   <span class="hljs-number">0</span>:<span class="hljs-number">00.01</span> gunicorn: worker [test:app]<br><span class="hljs-number">20860</span> benoitc   <span class="hljs-number">20</span>   <span class="hljs-number">0</span> <span class="hljs-number">55748</span>  11m <span class="hljs-number">1500</span> S   <span class="hljs-number">0.0</span>  <span class="hljs-number">0.1</span>   <span class="hljs-number">0</span>:<span class="hljs-number">00.00</span> gunicorn: worker [test:app]<br><span class="hljs-number">20861</span> benoitc   <span class="hljs-number">20</span>   <span class="hljs-number">0</span> <span class="hljs-number">55748</span>  11m <span class="hljs-number">1500</span> S   <span class="hljs-number">0.0</span>  <span class="hljs-number">0.1</span>   <span class="hljs-number">0</span>:<span class="hljs-number">00.01</span> gunicorn: worker [test:app]<br></code></pre></td></tr></table></figure><p>从这个进程列表可以发现目前有两个<code>Master</code>进程，他们分别有3个<code>Worker</code>子进程，这时候两个实例是一起运行的，如果指定的代码文件没有进行修改，指定的配置也没变，那么这两个实例的逻辑可以认为是等效的。</p><p>当用户判断新的实例能正常处理请求后， 可以发送信号<code>TERM</code>给旧实例的<code>Master</code>，让它开始优雅的关闭<code>Worker</code>并退出，然后新创建的实例的<code>Master</code>进程会在核心循环中发现创建自己的父进程已经退出了， 就让自己晋升为真正名义上的<code>Master</code>进程，源码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">maybe_promote_master</span>(<span class="hljs-params">self</span>):</span><br>    <span class="hljs-keyword">if</span> self.master_pid == <span class="hljs-number">0</span>:<br>        <span class="hljs-comment"># 已经是真正的`Master`进程，直接返回</span><br>        <span class="hljs-keyword">return</span><br><br>    <span class="hljs-keyword">if</span> self.master_pid != os.getppid():<br>        <span class="hljs-comment"># 该进程是从之前的主进程派生的，获取不到父进程id证明父进程被kill了  这时自己将晋升为主进程</span><br>        self.log.info(<span class="hljs-string">&quot;Master has been promoted.&quot;</span>)<br>        <span class="hljs-comment"># 设置属性，标明自己是正真的Master</span><br>        <span class="hljs-comment"># reset master infos</span><br>        self.master_name = <span class="hljs-string">&quot;Master&quot;</span><br>        self.master_pid = <span class="hljs-number">0</span><br>        self.proc_name = self.cfg.proc_name<br>        <span class="hljs-keyword">del</span> os.environ[<span class="hljs-string">&#x27;GUNICORN_PID&#x27;</span>]<br>        <span class="hljs-comment"># rename the pidfile</span><br>        <span class="hljs-keyword">if</span> self.pidfile <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            self.pidfile.rename(self.cfg.pidfile)<br>        <span class="hljs-comment"># reset proctitle</span><br>        util._setproctitle(<span class="hljs-string">&quot;master [%s]&quot;</span> % self.proc_name)<br></code></pre></td></tr></table></figure><p>通过源码可以发现，无论新实例有没有通过<code>may_be_promote_master</code>晋升为名义上的<code>Master</code>进程， 总体上的逻辑跟原先的<code>Master</code>进程是一样的，只不过是没办法通过接受<code>USR2</code>信号来创建新的实例。</p><blockquote><p>通过这种方式可以无感的升级应用代码，结合其它的信号，在升级失败时也能关闭新创建的实例，切回到旧实例，具体可以通过<a href="https://docs.gunicorn.org/en/stable/signals.html#upgrading-to-a-new-binary-on-the-fly">Upgrading to a new binary on the fly</a>了解。</p></blockquote><h2 id="6-Worker与Master的交互"><a href="#6-Worker与Master的交互" class="headerlink" title="6.Worker与Master的交互"></a>6.Worker与Master的交互</h2><p>分析完了<code>Arbiter</code>后，整个<code>Gunicorn</code>的核心还剩下<code>Worker</code>尚未分析，<code>Gunicorn</code>中带了多种<code>Worker</code>，比如用在<code>gevent</code>场景的<code>Worker.ggevent.GeventWorker</code>，用在<code>Tornado</code>的<code>Worker.gtornado.TornadoWorker</code>。这些<code>Worker</code>除了一些与<code>Arbiter</code>交互的方法外， 还有一些方法用来通过读取<code>scoket</code>的数据并转化为<code>WSGI</code>协议发给挂在后面的<code>WSGI</code>应用，这意味着<code>Gunicorn</code>不仅用于<code>WSGI</code>场景，还可以通过自己编写<code>Worker</code>来对接其它的场景，比如<code>Uvicorn.Worker</code>就是对接<code>ASGI</code>应用等。</p><blockquote><p>由于我在分析<code>Gunicorn</code>时，我是抱着使用<code>Gunicorn</code>来托管我的TCP服务的，所以我是着重了解<code>Worker</code>与<code>Arbiter</code>的交互，对于自带的其它<code>Worker</code>,则不多做说明(通过了解<code>WSGI</code>协议也能了解它们的执行逻辑)。</p></blockquote><p><code>Worker</code>与<code>Arbiter</code>的交互可以简化为如下图:</p><p><img    class="lazyload" data-original="https://s2.loli.net/2022/03/01/arnM8u2DIfjxHU7.jpg" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">Gunicorn源码分析-Worker与Arbiter交互</span></p><p>图中蓝色和绿色线条代表两种类型的信号交互，黑色代表其它的<code>Master</code>进程与<code>Worker</code>进程的交互。</p><h3 id="6-1-基于信号的交互"><a href="#6-1-基于信号的交互" class="headerlink" title="6.1.基于信号的交互"></a>6.1.基于信号的交互</h3><p>在图中见到了已经在<code>4.2.管理worker数量--manager-workers</code>说过的<code>manage_workers</code>，它除了在<code>Arbiter</code>中会调用<code>manage_workers</code>进行<code>Worker</code>初始化，之后会在接收到用户发起信号的时候调用<code>manage_worker</code>来进行增减。这类型信号更改<code>Worker</code>数量有两种， 一种是修改配置的<code>Worker</code>数量， 然后通过信号<code>HUP</code>重载配置:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">handle_hup</span>(<span class="hljs-params">self</span>):</span><br>    self.log.info(<span class="hljs-string">&quot;Hang up: %s&quot;</span>, self.master_name)<br>    self.reload()<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reload</span>(<span class="hljs-params">self</span>):</span><br>    ...<br>    <span class="hljs-comment"># 省略其它代码</span><br><br>    <span class="hljs-comment"># spawn new workers</span><br>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(self.cfg.workers):<br>        self.spawn_worker()<br><br>    <span class="hljs-comment"># manage workers</span><br>    self.manage_workers()<br></code></pre></td></tr></table></figure><p>另外一种就是通过信号<code>TTIN</code>和<code>TTOU</code>来更改数量的加减：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">handle_ttin</span>(<span class="hljs-params">self</span>):</span><br>    self.num_workers += <span class="hljs-number">1</span><br>    self.manage_workers()<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">handle_ttou</span>(<span class="hljs-params">self</span>):</span><br>    <span class="hljs-keyword">if</span> self.num_workers &lt;= <span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">return</span><br>    self.num_workers -= <span class="hljs-number">1</span><br>    self.manage_workers()<br></code></pre></td></tr></table></figure><p>此外，<code>Master</code>除了接收用户的信号外，还接收自己创建的<code>Worker</code>进程的信号，当<code>Worker</code>进程退出时，会发送信号<code>CHLD</code>给<code>Master</code>进程，<code>Master</code>进程会调用<code>reap_worker</code>来回收对应<code>Worker</code>的进程资源, <code>reap_worker</code>源码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reap_workers</span>(<span class="hljs-params">self</span>):</span><br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-comment"># 注意信号不排队的问题，你可以循环检查waitpid()子进程的状态. </span><br>        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>            <span class="hljs-comment"># 获取僵死子进程的信息</span><br>            wpid, status = os.waitpid(-<span class="hljs-number">1</span>, os.WNOHANG)<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> wpid:<br>                <span class="hljs-keyword">break</span><br>            <span class="hljs-keyword">if</span> self.reexec_pid == wpid:<br>                self.reexec_pid = <span class="hljs-number">0</span><br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-comment"># A worker was terminated. If the termination reason was</span><br>                <span class="hljs-comment"># that it could not boot, we&#x27;ll shut it down to avoid</span><br>                <span class="hljs-comment"># infinite start/stop cycles.</span><br>                exitcode = status &gt;&gt; <span class="hljs-number">8</span><br>                <span class="hljs-keyword">if</span> exitcode == self.WORKER_BOOT_ERROR:<br>                    reason = <span class="hljs-string">&quot;Worker failed to boot.&quot;</span><br>                    <span class="hljs-keyword">raise</span> HaltServer(reason, self.WORKER_BOOT_ERROR)<br>                <span class="hljs-keyword">if</span> exitcode == self.APP_LOAD_ERROR:<br>                    reason = <span class="hljs-string">&quot;App failed to load.&quot;</span><br>                    <span class="hljs-keyword">raise</span> HaltServer(reason, self.APP_LOAD_ERROR)<br>                <span class="hljs-comment"># WIFSIGNALED(status)为非0表明进程异常终止，记录异常信息。 </span><br>                <span class="hljs-keyword">if</span> os.WIFSIGNALED(status):<br>                    self.log.warning(<br>                        <span class="hljs-string">&quot;Worker with pid %s was terminated due to signal %s&quot;</span>,<br>                        wpid,<br>                        os.WTERMSIG(status)<br>                    )<br><br>                <span class="hljs-comment"># 清除Master进程的数据</span><br>                worker = self.WORKERS.pop(wpid, <span class="hljs-literal">None</span>)<br>                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> worker:<br>                    <span class="hljs-keyword">continue</span><br>                <span class="hljs-comment"># 关闭临时文件</span><br>                worker.tmp.close()<br>                self.cfg.child_exit(self, worker)<br>    <span class="hljs-keyword">except</span> OSError <span class="hljs-keyword">as</span> e:<br>        <span class="hljs-comment"># errno.ECHILD代表调用进程没有任何子进程，该类型的错误不应该报错</span><br>        <span class="hljs-keyword">if</span> e.errno != errno.ECHILD:<br>            <span class="hljs-keyword">raise</span><br></code></pre></td></tr></table></figure><p>这段代码实际上是为了解决一个类Unix系统等待终止子进程的问题， 该问题是如果子进程在终止过程中，子进程完全消失了，就没有给父进程留下任何可以来了解子进程的东西,父进程没办法清理与子进程相关的数据，所以类Unix系统有这样一个设计：如果子进程在父进程之前结束会先发送信号给父进程，然后内核会把子进程设置为一个特殊的状态，处于这个状态的进程叫做僵尸进程，这类进程只保留最小的概要信息并等待分进程来查询自己的信息，只要父进程获取了子进程的信息后，子进程就会消失，否则会一直保持僵死状态(zombie)。其中父进程获取子进程的信息有多种方式，在<code>Gunicorn</code>是采用<code>waitpid</code>来获取子进程的信息，而<code>reap_workers</code>的主要责任就是通过<code>waitpid</code>获取子进程信息并做出响应。</p><p>在<code>Gunicorn</code>中，采用<code>waitpid</code>来获取僵死进程的状态和信息，但是直接使用<code>waitpid</code>会暂时停止目前进程的执行，直到有信号来到或者有子进程结束，所以使用了<code>WHOHANG</code>标记，该标记表示如果没有任何已经结束的子进程也马上返回结果，不等待。<code>Gunicorn</code>通过使用该标记以及循环的方式来解决可能同时出现多个进程变为僵死状态的问题。</p><p>此外<code>Gunicorn</code>在<code>waitpid</code>中传了一个参数值<code>-1</code>,这个参数的名为<code>pid</code>，输入不同的值有不同的意义：</p><ul><li>pid&gt;0时，只等待进程ID等于pid的子进程，不管其它已经有多少子进程运行结束退出了，只要指定的子进程还没有结束，waitpid就会一直等下去。</li><li>pid=-1时，等待任何一个子进程退出，没有任何限制，此时waitpid和wait的作用一模一样。</li><li>pid=0时，等待同一个进程组中的任何子进程，如果子进程已经加入了别的进程组，waitpid不会处理它。</li><li>pid&lt;-1时，等待一个指定进程组中的任何子进程，这个进程组的ID等于pid的绝对值。</li></ul><p><code>Gunicorn</code>在通过<code>waitpid</code>获取到的返回信息中第一个pid代表退出进程的pid, 如果为空就代表没有子进程退出，应该直接退出逻辑返回到循环中，第二个status它包含了一些子进程的附加信息，该参数的高8位记录进程调用exit退出的状态，低8位记录进程接收到的信号，如果是正常退出，高8位数为退出状态，低8位数为0,如果是非正常退出，高8位数为0，低8位数为信号id，所以<code>Gunicorn</code>会通过<code>status &gt;&gt; 8</code>来获取低8位的数据，且当它不为0时就判断是否是自己定义的特殊信号，如果是则按照信号进行抛异常。</p><h3 id="6-2-Master进程主动检测"><a href="#6-2-Master进程主动检测" class="headerlink" title="6.2.Master进程主动检测"></a>6.2.Master进程主动检测</h3><p>上面说到<code>Master</code>进程虽然可以收到子进程退出时发出的<code>CHLD</code>信号，但是并不是所有子进程退出时都能发出<code>CHLD</code>信号，所以<code>Master</code>进程还需要做到主动检测，<code>Gunicorn</code>在主动检查中用到了一个比较奇特的方法–临时文件的最后修改时间，该方法是通过<code>Worker</code>进程每隔一段时间更新临时文件的最后修改时间，<code>Master</code>进程每隔一段时间就去检测最后修改时间是否在一段范围内， 如果不合法就剔除这个<code>Worker</code>进程。</p><blockquote><p>这种方式挺让人困惑的，同时容易引起性能问题，具体见<a href="https://docs.gunicorn.org/en/stable/faq.html#how-do-i-avoid-gunicorn-excessively-blocking-in-os-fchmod">How do I avoid Gunicorn excessively blocking in os.fchmod?</a>，目前官方表示可能会进行改进， 见<code>Gunicorn</code>中的一条<a href="https://github.com/benoitc/gunicorn/issues/1305">issue</a></p></blockquote><p>这个检测是思路通过<code>WorkerTmp</code>类来实现，它的源码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WorkerTmp</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, cfg</span>):</span><br>        ...<br>        <span class="hljs-comment"># 省略代码，这一步只是做初始化 </span><br>        self.spinner = <span class="hljs-number">0</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">notify</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-comment"># 通过更改权限的方式更新修改时间</span><br>        self.spinner = (self.spinner + <span class="hljs-number">1</span>) % <span class="hljs-number">2</span><br>        os.fchmod(self._tmp.fileno(), self.spinner)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">last_update</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-comment"># 获取文件描述符的修改时间</span><br>        <span class="hljs-keyword">return</span> os.fstat(self._tmp.fileno()).st_ctime<br></code></pre></td></tr></table></figure><p>它会在<code>Worker</code>初始化时实例化为<code>Worker.tmp</code>属性，对于<code>Worker</code>进程，必须在<code>self.timeout / 2</code>的时间间隔调用<code>tmp.notify</code>来更新修改文件的更新时间；对于<code>Master</code>则通过<code>tmp.last_update</code>来获取临时文件的最后修改时间，以此判断<code>Worker</code>是否还存活，这部分就是示例图中的<code>murder_workers</code>,它的源码如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">murder_workers</span>(<span class="hljs-params">self</span>):</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self.timeout:<br>        <span class="hljs-keyword">return</span><br>    workers = <span class="hljs-built_in">list</span>(self.WORKERS.items())<br>    <span class="hljs-keyword">for</span> (pid, worker) <span class="hljs-keyword">in</span> workers:<br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-comment"># 通过临时文件的最后更新时间判断是否合法</span><br>            <span class="hljs-keyword">if</span> time.time() - worker.tmp.last_update() &lt;= self.timeout:<br>                <span class="hljs-keyword">continue</span><br>        <span class="hljs-keyword">except</span> (OSError, ValueError):<br>            <span class="hljs-keyword">continue</span><br><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> worker.aborted:<br>            <span class="hljs-comment"># 第一次发现不合法，发送警告指令</span><br>            self.log.critical(<span class="hljs-string">&quot;WORKER TIMEOUT (pid:%s)&quot;</span>, pid)<br>            worker.aborted = <span class="hljs-literal">True</span><br>            <span class="hljs-comment"># 发送ABRT信号</span><br>            self.kill_worker(pid, signal.SIGABRT)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-comment"># 第二次发现不合法，关闭进程</span><br>            self.kill_worker(pid, signal.SIGKILL)<br></code></pre></td></tr></table></figure><h2 id="7-总结"><a href="#7-总结" class="headerlink" title="7.总结"></a>7.总结</h2><p>至此，<code>Gunicorn</code>的主核心逻辑源码分析已经分析完毕了，可以发现<code>Gunicorn</code>就是一个大管家，会把获取网络请求的功能下放给下面工作的<code>Worker</code>，自己只负责一些<code>Worker</code>的管理等功能。 同时可以发现<code>Gunicorn</code>并不只是<code>WSGI</code>服务，通过自定义<code>Worker</code>，它也可以挂载TCP之类的应用。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前记&quot;&gt;&lt;a href=&quot;#前记&quot; class=&quot;headerlink&quot; title=&quot;前记&quot;&gt;&lt;/a&gt;前记&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Gunicorn&lt;/code&gt;是一个基于&lt;code&gt;Python&lt;/code&gt;实现的动态Web服务器，它通过Pre-Worker</summary>
      
    
    
    <content src="https://cdn.jsdelivr.net/gh/so1n/so1n_blog_photo@master/1646123474839enabling-the-flask-interactive-debugger-in-development-with-gunicorn-f6927cf4d1c653c36832549bafbfd1227ab2bd879c6e17c6082fec284651f7e4.jpg" type="image"/>
    
    
    <category term="源码分析" scheme="http://so1n.me/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
    <category term="Python" scheme="http://so1n.me/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python-gRPC实践（2）--Protocol Buffer</title>
    <link href="http://so1n.me/2022/02/05/Python-gRPC%E5%AE%9E%E8%B7%B5(2)--Protocol%20buffer/"/>
    <id>http://so1n.me/2022/02/05/Python-gRPC%E5%AE%9E%E8%B7%B5(2)--Protocol%20buffer/</id>
    <published>2022-02-05T12:35:24.000Z</published>
    <updated>2022-02-15T05:12:21.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在上一文<a href="https://so1n.me/2022/01/05/Python-gRPC%E5%AE%9E%E8%B7%B5(1)--%E7%AE%80%E4%BB%8B/">Python-gRPC实践（1）–gRPC简介</a>简单的介绍了<code>gRPC</code>采用了<code>HTTP2</code>作为它的传输协议，以及<code>gRPC</code>是如何通过<code>HTTP2</code>传输数据的，而本文则着重介绍<code>gRPC</code>所采用的序列化协议–<code>Protocol Buffer</code>。</p><span id="more"></span><h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.介绍"></a>1.介绍</h2><h3 id="1-1-什么是Protocol-Buffer"><a href="#1-1-什么是Protocol-Buffer" class="headerlink" title="1.1.什么是Protocol Buffer"></a>1.1.什么是Protocol Buffer</h3><p>Protobuf(Google Protocol Buffers)是Google开发的跨语言，跨平台，可扩展，用于序列化结构化数据的数据传输协议，目前已经被广泛用于服务端和客户端间的数据传输，要在项目中把<code>gRPC</code>用得好就必须先清晰理解Protocol Buffer的使用以及语法。</p><blockquote><p>NOTE: Protobuf就像Json一样可以独立使用,不局限于<code>gRPC</code>这个场景之中，我们可以基于Protobuf实现自己的数据序列化/反序列化。</p></blockquote><h3 id="1-2-gRPC为什么要采用Protocol-Buffer做序列化协议"><a href="#1-2-gRPC为什么要采用Protocol-Buffer做序列化协议" class="headerlink" title="1.2.gRPC为什么要采用Protocol Buffer做序列化协议"></a>1.2.gRPC为什么要采用Protocol Buffer做序列化协议</h3><p><code>gRPC</code>早期只支持Protobuf，最新的版本已经开始支持Json了，但是没有多少人使用。为什么<code>gRPC</code>一开始要选择Protobuf呢，有一个很重要的原因是Protobuf同样也是谷歌自己的产品，这样<code>gRPC</code>在进行功能升级的时候，Protobuf也能及时的迭代， 目前Protobuf的版本已经迭代到第3版，但是大家能接触到的只有第二版和第三版，因为第一版是谷歌之前内部使用的。<br>不过<code>gRPC</code>采用Protobuf的重要的原因是在常见的场景下，<code>gRPC</code>的效率要比现在大家用到的Json高一些，Protobuf的效率为什么会高呢？天下是没有免费的午餐的，有得既有失，在理解Protobuf之前我们先来看一段Json数据:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs Json">&#123;<br>  <span class="hljs-attr">&quot;project&quot;</span>: <span class="hljs-string">&quot;Test&quot;</span>, <br>  <span class="hljs-attr">&quot;timestamp&quot;</span>: <span class="hljs-number">1600000000</span>, <br>  <span class="hljs-attr">&quot;status&quot;</span>: <span class="hljs-literal">true</span>,<br>  <span class="hljs-attr">&quot;data&quot;</span>: [<br>    &#123;<br>      <span class="hljs-attr">&quot;demo_key&quot;</span>: <span class="hljs-string">&quot;fake_value&quot;</span>,<br>    &#125;,<br>    &#123;<br>      <span class="hljs-attr">&quot;demo_key&quot;</span>: <span class="hljs-string">&quot;fake_value&quot;</span>,<br>    &#125;,<br>    &#123;<br>      <span class="hljs-attr">&quot;demo_key&quot;</span>: <span class="hljs-string">&quot;fake_value&quot;</span>,<br>    &#125;<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure><p>这段Json数据是一段文本， 这就是Json效率低下的第一个点–编码低效。比如字段<code>status</code>对应的值<code>true</code>在内存中只占用1个字节，但在这个数据中却占用了4个字节, 再比如字段<code>timestamp</code>的值是int类型，int类型在内存中占用的空间并不大，但是在Json数据中却是以字符串呈现会占用更多的空间。<br>此外我们可以很快的通过这段数据看得出里面有什么内容，这是Json的一个优点，但也带来了另一个缺点–信息冗余。比如字段<code>data</code>的数据是一个数组，但是里面的结构是一致的，这样就会重复多传了n次的字段名。</p><p>Protobuf为了解决这些问题，首先引进了一些带有优化的编码方案，解决了编码低效的问题， 比如针对数字引入了VarInts对数字进行编码解码， 这个方案能节省数字的空间占用，同时使用的是位运算来编码解码，效率非常的高，具体可以通过<a href="https://segmentfault.com/a/1190000020500985">详解varint编码原理</a>进行了解。<br>而另一方面的改进则是去掉字段名了，改用字段编号代替，传输的时候只传输编号，这样就可以解决了冗余问题，但是这时候需要双方有一个记录编号的翻译本从而可以通过字段编号来得到真实的字段名，就像莫斯电码通信一样，而在Protobuf中proto文件就是这样的一个密码本，它记录了字段和编号的关系以及这个请求是属于哪个调用的接口和服务。<br>以上文<a href="https://so1n.me/2022/01/05/Python-gRPC%E5%AE%9E%E8%B7%B5(1)--%E7%AE%80%E4%BB%8B/">Python-gRPC实践（1）–gRPC简介</a>中的捉包结果<img    class="lazyload" data-original="https://ftp.bmp.ovh/imgs/2022/01/0adf7176d3f129a9.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">images</span><br>为例子，图中展示的是与proto文件:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs proto">syntax &#x3D; &quot;proto3&quot;;<br>package user;<br>import &quot;google&#x2F;protobuf&#x2F;empty.proto&quot;;<br><br>&#x2F;&#x2F; delete user<br>message DeleteUserRequest &#123;<br>  string uid &#x3D; 1;<br>&#125;<br><br><br>service User &#123;<br>  rpc delete_user(DeleteUserRequest) returns (google.protobuf.Empty);<br>&#125;<br></code></pre></td></tr></table></figure><p>有关的请求，请求中表明<code>Field</code>为1，值为999, 接受端收到请求后就会先从proto文件查数据， 通过URL得出这个请求是service为<code>User</code>， rpc为<code>delete_user</code>的请求， 那么请求的message就是<code>DeleteUserRequest</code>，接下来就能知道<code>Field</code>为1实际的字段名是<code>uid</code>。</p><h2 id="2-使用Protocol-Buffer"><a href="#2-使用Protocol-Buffer" class="headerlink" title="2.使用Protocol Buffer"></a>2.使用Protocol Buffer</h2><p>Protobuf的编码原理是值得一看的，目前网上资料有很多，这里就先略过直接到如何使用Protobuf(实际上我目前对Protobuf的编码了解的也不是很多- -)。</p><p>从上面的示例可以看出<code>gRPC</code>在运行的时候需要proto文件来反查得出真正的字段数据，而<code>gRPC</code>是支持多语言的，那么每个语言的<code>gRPC</code>是如何通过proto文件来查出数据呢。</p><p>我们在编写项目时，大多都会通过一份接口代码就来生成对应的OpenAPI文件，然后其它工具如Swagger就能通过读取该文件渲染出一个API文档。而proto文件的作用也跟OpenAPI文件类似，只不过不是代码生成，而是由开发者编写的，然后开发者再通过不同的工具来根据proto文件生成不同语言的代码并放到项目工程中使用，所以要用好<code>gRPC</code>需要先知道如何编写proto文件(通常在使用gRPC时，也是基于Protobuf文件生成对应的调用代码)。</p><h3 id="2-1-Protobuf语法"><a href="#2-1-Protobuf语法" class="headerlink" title="2.1.Protobuf语法"></a>2.1.Protobuf语法</h3><p>在介绍语法之前，先看看proto文件都内容有什么，首先我们再回头看一看上面说的proto文件:</p><figure class="highlight plain"><figcaption><span>Buffer</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs Protocol">syntax &#x3D; &quot;proto3&quot;;<br>package user;<br>import &quot;google&#x2F;protobuf&#x2F;empty.proto&quot;;<br><br>&#x2F;&#x2F; delete user<br>message DeleteUserRequest &#123;<br>  string uid &#x3D; 1;<br>&#125;<br><br><br>service User &#123;<br>  rpc delete_user(DeleteUserRequest) returns (google.protobuf.Empty);<br>&#125;<br></code></pre></td></tr></table></figure><p>标准的proto文件就像这份示例文件一样可以分为三部分， 第一部分是前三行，这部分是proto文件的声明区，其中第一行标明当前proto文件的语法是proto3(没有特别说明，本文所介绍的语法都是proto3)，第二行表示该文件的包名为user，这样会方便别的文件引入这个文件的定义，第三行表示导入<code>empty.proto</code>文件，接下来在这个文件都可以使用<code>empty.proto</code>文件定义的东西。</p><p>第二部分是5-8行， 这部分是消息体区， 这里定义了一个名为<code>DeleteUserRequest</code>的消息体，这个消息体中定义了一个名为uid的字段，且它的类型是<code>string</code>，字段排序是1。在实际开发中，大部分的变动都是在这一部分中发生， 且需要关注的点比较多。</p><p>第三部分是11-13行，这部分是服务定义区， 这里定义了一个名为<code>User</code>的服务，该服务中有一个名为<code>delete_user</code>的方法，且该方法接受的请求是<code>DeleteUserRequest</code>消息体，响应的是<code>Empty</code>消息体。可以简单的理解为这部分是定义一个类， 同时为每个类定义一些方法，而这些方法只拥有函数签名，没有具体实现。</p><p>了解完了Proto文件结构后，可以开始了解Protobuf语法。</p><h4 id="2-1-1-字段编号"><a href="#2-1-1-字段编号" class="headerlink" title="2.1.1.字段编号"></a>2.1.1.字段编号</h4><p>在编写消息体时， 最重要的一点就是字段编号， 从前面的说明可以看出， Protobuf的序列化是通过字段编号进行翻译的，所以我们要保证字段编号和字段是一一对应的， 一般的情况下我们都要遵循字段编号从1开始逐渐递增， 比如下面这个消息体:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs proto">message DemoRequest &#123;<br>  string uid &#x3D; 1;<br>  string mobile &#x3D; 2;<br>  int32 age &#x3D; 3;<br>&#125;<br></code></pre></td></tr></table></figure><p>它的字段编号都是逐渐递增的，后面在新增字段时也要按照递增的方法指定字段编号，绝不能复用之前曾经存在的字段编号，即使是把某个字段进行重构，比如把上述的消息体进行更改:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs proto">&#x2F;&#x2F; 通常不删除已经使用的字段， 这里只做演示<br>message DemoRequest &#123;<br>  string uid &#x3D; 1;<br>  string mobile &#x3D; 2;<br>  int32 brithday &#x3D; 4; &#x2F;&#x2F; 统一使用时间戳表示日期<br>&#125;<br></code></pre></td></tr></table></figure><p>虽然更改后的消息体里面的age字段被brithday替换了， 但是brithday的字段编号还是递增了1，这样做是可以防止旧版本客户端在没更随服务端变动时造成数据解析异常。</p><p>不过使用字段编号递增的方法可以让开发者知道之前的编号用到哪里，但这些都是需要依赖团队的规范去实现才不会出现问题，为此Protobuf提供了<code>reserved</code>字段，供我们来屏蔽一些后续不能再使用的字段编号，使用例子如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs proto">message DemoRequest &#123;<br>  string uid &#x3D; 1;<br>  string mobile &#x3D; 2;<br>  reserved 3;<br>  int32 brithday &#x3D; 4; &#x2F;&#x2F; 统一使用时间戳表示日期<br>  reserved 5, 6, 10 to 15 &#x2F;&#x2F; reserved也可以一下子限制多个字段编号，他们以&#96;,&#96;分开， 也可以使用&#96;xx to xx&#96;来限制一段连续的字段编号。<br>&#125;<br></code></pre></td></tr></table></figure><p>该例子可以避免后续的字段用到了字段编号3, 即使用到了Protobuf编译器也会报错，在源头防止问题的发生。</p><blockquote><p>NOTE<br>之所以要求字段编号从1开始递增是因为Protobuf从message编码成二进制消息体时，字段编号1-15将会占用1个字节，16-2047将占用两个字节，优先使用1-15的字段编号将会减少数据的传输， 如果在一开始消息体的字段就比较多时， 则需要把常用的字段的字段编号安排在1-15之间。此外，19000到19999是给protocol buffers实现保留的字段标号，定义message时不能使用，如果使用了这些编号，Protobuf编译器将会报错。</p></blockquote><h4 id="2-1-2-如何使用"><a href="#2-1-2-如何使用" class="headerlink" title="2.1.2.如何使用"></a>2.1.2.如何使用</h4><p>在Protobuf的消息体中，每个字段的类型都是固定的， 因为传输固定的类型才能减少传输资源的占用，所以我们在定义消息体的字段时，一定要结合业务需求来定义字段的类型， 以下是一个常见的Protobuf基础字段类型与Python类型的对照表:<br>|Protobuf类型|Python类型|Protobuf类型说明|<br>|–|–|–|<br>|double|float||<br>|float|float||<br>|int32|int|使用变长编码,该类型不擅长处理负值的数字，需要使用sint32代替|<br>|int64|int|使用变长编码,该类型不擅长处理负值的数字，需要使用sint64代替|<br>|unit32|int|使用变长编码|<br>|unit64|int|使用变长编码|<br>|snit32|int|擅长处理负值的数字，当该字段可能出现负值数字时，需要把int32改为该类型|<br>|snit64|int|擅长处理负值的数字，当该字段可能出现负值数字时，需要把int64改为该类型|<br>|fixed32|int|总是4个字节，如果数值总是比总是比228大的话，这个类型会比uint32高效，它等于int32,uint32,float的并集|<br>|fixed64|int|总是8个字节，如果数值总是比总是比256大的话，这个类型会比uint64高效，它等于int64,uint64,double的并集|<br>|bool|bool||<br>|string|str||<br>|bytes|bytes|</p><p>需要注意的是，我们虽然声明的字段没有标明他的值是多少，但是他们都有默认值：</p><ul><li>字符串类型：空字符串</li><li>字节类型：空字节</li><li>数字类型： 0</li><li>enum: 默认值的第一个元素，且值必须为0</li></ul><p>同时，定义的消息体也是Protobuf中的一个类型，这种类型称为<code>Message</code>，它可以嵌套在别的<code>Message</code>中， Protobuf语法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs proto">message DemoSubRequest &#123;<br>  string a &#x3D; 1;<br>  int32 b &#x3D; 2;<br>&#125;<br>message DemoRequest &#123;<br>  DemoRequest result &#x3D; 1;<br>&#125; <br></code></pre></td></tr></table></figure><p>它也可以通过import的语法，从a文件引入消息体到b文件，并被b文件使用， 比如在文件夹下<code>project</code>有a文件和b文件， 其中a文件如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs proto">&#x2F;&#x2F; 声明包名为demo_a<br>package demo_a;<br><br>&#x2F;&#x2F; 定义一个消息体<br>message DemoRequest &#123;<br>  DemoRequest result &#x3D; 1;<br>&#125;<br></code></pre></td></tr></table></figure><p>而b文件引用了a文件的消息体，具体代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs proto">&#x2F;&#x2F; 声明包名为demo_b<br>package demo_b<br>import &quot;project&#x2F;demo_a.proto&quot;;<br><br>message DemoRequest &#123;<br>  &#x2F;&#x2F; 引用a文件的消息体<br>  project.demo_a.DemoRequest result &#x3D; 1;<br>&#125;<br></code></pre></td></tr></table></figure><p>此外， Protobuf还支持定义其它类型，这些类型具有跟Python等价类型的用法，但是在使用的时候还是有些区别：</p><h4 id="Timestamp"><a href="#Timestamp" class="headerlink" title="Timestamp:"></a>Timestamp:</h4><p>Timestamp是Protobuf中的时间类型，Protobuf使用语法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs proto">import &quot;google&#x2F;protobuf&#x2F;timestamp.proto&quot;;<br><br>message DemoRequest &#123;<br>  google.protobuf.Timestamp timestamp &#x3D; 1;<br>&#125; <br></code></pre></td></tr></table></figure><p>该类型实际上是timestamp的封装，它的默认值是timestamp=0（对应到的日期是1970-01-01），在Python代码中，可以通过语法<code>ToDatetime</code>转为datetime，也可以通过语法<code>FormDatetime</code>把datetime转为Protobuf的Timestamp:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">from</span> google.protobuf.timestamp_pb2 <span class="hljs-keyword">import</span> Timestamp<br><br>Timestamp().ToDatetime()<br><br><span class="hljs-keyword">from</span> datetime <span class="hljs-keyword">import</span> datetime<br><br>Timestamp().FormDatetime(datetime.now())<br></code></pre></td></tr></table></figure><h4 id="Repeated："><a href="#Repeated：" class="headerlink" title="Repeated："></a>Repeated：</h4><p>Repeated 可以使该字段表重复任意次数，就像Python的Sequence对象，但是实际上可以认为是Python的List对象，Protobuf使用Repeated语法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs proto">message DemoRequest &#123;<br>  repeated int32 demo_list &#x3D; 1;<br>&#125; <br><br>&#x2F;&#x2F; demo_list value like json<br>&#x2F;&#x2F; [1, 2, 3, 4, 5, 6] <br></code></pre></td></tr></table></figure><p>该消息体定义了一个<code>demo_list</code>字段， 该字段是repeated且内部类型是int32，在Python中使用Repeated字段的方法跟使用List方法一样，但是它不是继承于List的，在部分库可能需要转换为List才能使用，比如<code>pymysql</code>。</p><h4 id="Map："><a href="#Map：" class="headerlink" title="Map："></a>Map：</h4><p>虽然我们大多数都是以明确的Key-Value来定义消息体， 但是Protobuf也提供了一个类似于dict的Map，Protobuf使用Map语法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs proto">message DemoRequest &#123;<br>  map&lt;string, int32&gt; demo_map &#x3D; 1;<br>&#125; <br><br>&#x2F;&#x2F; demo_map value like json<br>&#x2F;&#x2F; &#123;<br>&#x2F;&#x2F;    &quot;aaa&quot;: 123,<br>&#x2F;&#x2F;    &quot;bbb&quot;: 456 <br>&#x2F;&#x2F; &#125;<br></code></pre></td></tr></table></figure><p>该消息体定义了一个<code>demo_map</code>字段， 该字段是map类型且key类型为字符串，value类型为int32，在Python中使用Map的方法跟使用dict方法一样，但是它不是继承于dict的，在部分库可能需要转换为dict才能使用，比如<code>pymysql</code>。</p><blockquote><p>NOTE: </p><ul><li>Map类型的字段不能是Repeated， 因为Repeated是可变的，就像Python中Dict的Key不能是List一样。</li><li>Map的字段是无序的。</li><li>如果有重复的字段，则使用最后都有一个。</li></ul></blockquote><h4 id="Empty："><a href="#Empty：" class="headerlink" title="Empty："></a>Empty：</h4><p>Empty是Protobuf中代表空的类型，跟Python中的None一样, 一般不用在消息体中， 而是用来标明某个rpc方法返回了空，Protobuf语法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs proto">import &quot;google&#x2F;protobuf&#x2F;empty.proto&quot;;<br><br>service Demo &#123;<br>  rpc demo (DemoRequest) returns (google.protobuf.Empty);<br>&#125;<br></code></pre></td></tr></table></figure><p>在Python中可以通过<code>from google.protobuf.empty_pb2 import Empty</code>导入<code>Empty</code>对象并使用，不过在Python代码中最好不要把<code>Empty</code>转为Python的None对象, 因为<code>Empty</code>只是用来代表该请求点响应为空。</p><h4 id="Enum："><a href="#Enum：" class="headerlink" title="Enum："></a>Enum：</h4><p>在定义消息类型时， 可能希望其中一个字段只有一个预定义的值，这时就会用到枚举类型，Protobuf使用Enum语法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs proto">message DemoRequest &#123;<br>  enum Status &#123;<br>    open &#x3D; 0;<br>    half_open &#x3D; 1;<br>    close &#x3D; 2;<br>  &#125;<br>  Status status &#x3D; 1;<br>&#125;<br></code></pre></td></tr></table></figure><p>如语法所示， 首先在消息体创建一个名称为<code>Status</code>的枚举类型，然后定义类型为<code>Status</code>的字段<code>status</code>， 值得注意的是枚举定义都需要包含一个常量映射到0并且作为定义的首行，这是因为Protobuf要求定义的枚举值中必须有字段的值为0，当引用到这个类型的字段没有定义默认值时，它的默认值就是枚举类型中值为0的字段。</p><h3 id="2-2-Proto文件管理与使用规范"><a href="#2-2-Proto文件管理与使用规范" class="headerlink" title="2.2.Proto文件管理与使用规范"></a>2.2.Proto文件管理与使用规范</h3><p>实际使用gRPC来串联服务时，这些服务并不是只用一门编程语言，可能有的服务是用Python写的，有的服务是Java写的，有的服务则是用Go写的。<br>同时，我们在发布功能时也不是所有服务都需有更新，有的服务只需要用老接口就可以了， 比如一个服务端接口进行了更新， 这个服务端对应了很多个客户端，如果没有规范管理proto文件的话，就可能所有客户端都要进行升级，而不是只升级需要升级的客户端， 所以我们需要根据规范来管理proto文件，减少管理上带来的负担。</p><h4 id="2-2-1-方案选择"><a href="#2-2-1-方案选择" class="headerlink" title="2.2.1.方案选择"></a>2.2.1.方案选择</h4><p>在一开始的时候，我选用的方案是最简单的文件拷贝，这也是大多数人入门时的使用方法，它使用起来非常简单，但是代码复用率很低，项目多了之后复制文件会成为负担， 有时还需要用diff工具去对比，十分麻烦。</p><p>于是，在后续就开始考虑用版本管理工具来进行管理，由于proto文件是项目的子集，在选择方案的时候就会先联想到Git Submodul, 但是这种方案存在回滚故障点风险，同时需要为每个项目各自生产对应的proto，比较麻烦。</p><p>最后确定的方案是新建一个git仓库来存放proto文件，并以tag来区分不同的版本。<br>使用git仓库还有一个优势就可以利用CI/CD来自动根据proto文件生成对应语言的代码以及打包，省去的一些手动的步骤。</p><h4 id="2-2-2-使用"><a href="#2-2-2-使用" class="headerlink" title="2.2.2.使用"></a>2.2.2.使用</h4><p>首先我们需要创建一个Git仓库，把每个服务端项目的Proto文件移出来独立成一个仓库，接着就根据<a href="https://danielkummer.github.io/git-flow-cheatsheet/index.zh_CN.html">git flow</a>流程来更新proto文件，不过在更新Proto文件时需要遵循下面几条规范：</p><ul><li>proto文件只增不减</li><li>proto文件的接口只增不减</li><li>proto文件的message字段只增不减</li><li>proto文件中的message字段类型和序号不得修改</li></ul><p>这几条规范的共性就是不对源文件进行删除，每次都只做到新增，从而保证即使proto文件发生了更改， 旧的服务在不更新的情况下也还能正常的使用。</p><p>更新完后就可以给其它项目使用了， 比如这个库当前的版本为1.0.0，我们根据<a href="https://danielkummer.github.io/git-flow-cheatsheet/index.zh_CN.html">git flow</a>流程来更新proto文件并生成对应语言的代码或者release包，最后打上了对应的tag标签， 对于Python可以使用该方法来安装或更新依赖：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pip install https://gitlab.xxx.com/proto/aaa@v1.0.0<br></code></pre></td></tr></table></figure><p>而对于Java这类的则可以使用打包成一个release版本交给maven使用。</p><h2 id="3-最后"><a href="#3-最后" class="headerlink" title="3.最后"></a>3.最后</h2><p>现在已经初步的了解了<code>gRPC</code>以及Protobuf的使用方法，接下来将通过一个简单的项目来演示如何使用<code>gRPC</code></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在上一文&lt;a href=&quot;https://so1n.me/2022/01/05/Python-gRPC%E5%AE%9E%E8%B7%B5(1)--%E7%AE%80%E4%BB%8B/&quot;&gt;Python-gRPC实践（1）–gRPC简介&lt;/a&gt;简单的介绍了&lt;code&gt;gRPC&lt;/code&gt;采用了&lt;code&gt;HTTP2&lt;/code&gt;作为它的传输协议，以及&lt;code&gt;gRPC&lt;/code&gt;是如何通过&lt;code&gt;HTTP2&lt;/code&gt;传输数据的，而本文则着重介绍&lt;code&gt;gRPC&lt;/code&gt;所采用的序列化协议–&lt;code&gt;Protocol Buffer&lt;/code&gt;。&lt;/p&gt;</summary>
    
    
    <content src="https://ftp.bmp.ovh/imgs/2022/02/bd67e15aa8d46101.png" type="image"/>
    
    
    <category term="Python-gRPC实践" scheme="http://so1n.me/categories/Python-gRPC%E5%AE%9E%E8%B7%B5/"/>
    
    
    <category term="Python" scheme="http://so1n.me/tags/Python/"/>
    
    <category term="gRPC" scheme="http://so1n.me/tags/gRPC/"/>
    
  </entry>
  
</feed>
