<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>So1n blog</title>
  
  <subtitle>不写会忘</subtitle>
  <link href="http://so1n.me/atom.xml" rel="self"/>
  
  <link href="http://so1n.me/"/>
  <updated>2023-08-29T17:16:56.633Z</updated>
  <id>http://so1n.me/</id>
  
  <author>
    <name>So1n</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Python Asyncio 之网络编程方法详解</title>
    <link href="http://so1n.me/2023/08/29/python_asyncio_lib_network/"/>
    <id>http://so1n.me/2023/08/29/python_asyncio_lib_network/</id>
    <published>2023-08-29T15:33:18.000Z</published>
    <updated>2023-08-29T17:16:56.633Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前记"><a href="#前记" class="headerlink" title="前记"></a>前记</h2><p><code>Python Asyncio</code>不仅提供了简单的<code>Socket</code>接口，还基于<code>Asyncio.Socket</code>提供了<code>Protocol</code>&amp;<code>Transport</code>接口以及更高级的<code>Stream</code>接口，这些接口大大的减轻了开发者进行网络编程的心理负担。<br>本文主要介绍了<code>Asyncio</code>这些接口的简单使用以及对应的原理分析。</p><span id="more"></span><h2 id="1-简单介绍"><a href="#1-简单介绍" class="headerlink" title="1.简单介绍"></a>1.简单介绍</h2><p><code>Python Asyncio</code>提供了一套完整的高性能网络编程接口，它包括了兼容位于网络编程最底层的<code>Socket</code>–<code>Asyncio.Socket</code>，以及在<code>Asyncio.Socket</code>上层封装的<code>Protocol</code>&amp;<code>Transport</code>接口，还有在<code>Protocol</code>&amp;<code>Transport</code>上层封装的<code>Stream</code>接口。<br>这三套接口各有特色，开发者可以根据自己的需求选择其中一套接口来使用，进而减少网络编程的一些心理负担。</p><p><code>Python Asyncio</code>三套接口的关系就跟套娃一样，<code>Stream</code> 套在<code>Protocol</code>&amp;<code>Transport</code>上面 ，而<code>Protocol</code>&amp;<code>Transport</code>套在<code>Socket</code>上面，由于<code>Stream</code>是最上层的封装，所以它的易用性最高，不过适用范围最少，其次是<code>Protocol</code>&amp;<code>Transport</code>，最后是<code>Socket</code>，它的易用性最差，但是适用范围最广，不过它们的性能却跟套娃顺序无关。<br>根据<code>uvloop</code>的性能比较得出他们的性能关系为<code>Protocol</code>&amp;<code>Transport</code> &gt; <code>Stream</code> &gt; <code>Socket</code>，具体结果如图：</p><p><img   class="lazyload" data-original="https://raw.githubusercontent.com/MagicStack/uvloop/master/performance.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" ></p><p>在第一次见到这个性能的比较结果时我觉得是非常神奇的，因为对于一些分层架构来说，越上层的封装越多，易用性越好，而性能反而越低，但在性能比较结果中性能最好的却是处于中间的<code>Protocol</code>&amp;<code>Transport</code>，然后是<code>Stream</code>，最后才是<code>Asycnio Socket</code>。为了了解这个原因，需要通过网络编程接口的使用方法和源码一起分析。</p><h3 id="1-1-Socket的简单介绍"><a href="#1-1-Socket的简单介绍" class="headerlink" title="1.1.Socket的简单介绍"></a>1.1.Socket的简单介绍</h3><p>无论<code>Asyncio</code>的网络编程接口是怎么封装，如果要了解它是怎么实现的，那么需要对<code>Socket</code>有一定的了解。<br>不过本文只对<code>Socket</code>进行简单的介绍，并不会对<code>Socket</code>的原理进行详细的描述，同时<code>Python Asyncio</code>的<code>Stream</code>接口只支持流传输，所以本文只采用<code>Socket</code>进行TCP传输的编程实例进行讲述，其他的编程方式和<code>Socket</code>介绍见下文:</p><ul><li><a href="https://gist.github.com/kevinkindom/108ffd675cb9253f8f71">Python Socket 编程详细介绍</a></li><li><a href="https://realpython.com/python-sockets/">Socket Programming in Python (Guide)</a></li></ul><p><code>Socket</code>是计算机之间进行通信的一种协议，通过<code>Socket</code>开发者可以在无需关心底层是如何实现的情况下在不同的计算机进行端到端之间的通信，<br><code>Socket</code>常见的交互流程如下图：<br><img    class="lazyload" data-original="https://fastly.jsdelivr.net/gh/so1n/so1n_blog_photo@master/blog_photo/1692807503149asyncio%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-socket.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">1692807503149asyncio网络编程-socket.png</span></p><p>在交互的流程的示例图中，<code>Socket</code>分为五个交互阶段，每个阶段的作用如下：</p><ul><li>创建<code>Socket</code>: 初始化一个<code>Socket</code>对象。</li><li>初始化<code>Socket</code>: 客户端无需任何操作，而服务端的<code>Socket</code>在初始化时比客户端的<code>Socket</code>多了两个方法–<code>bind</code>和<code>listen</code>，它们的作用分别是绑定一个端口，以及监听这个端口建立的新连接。</li><li>建立连接： 客户端<code>Socket</code>的专属方法为<code>connect</code>，这个方法会直接与服务端建立连接。而服务端的专属方法为<code>accept</code>，<code>accept</code>这个方法比较特殊，因为其他<code>socket</code>的方法都是针对于<code>socket</code>进行操作，而<code>accept</code>方法除了针对<code>socket</code>进行操作外还会额外返回一个新的<code>socket</code>。<br>同时服务端原先的<code>socket</code>只携带服务端的IP和地址信息，而新的<code>socket</code>携带的是客户端与服务端两个端点的四元组信息（客户端IP，客户端端口，服务端IP，服务端端口）。<br>这一点是非常重要的，因为这两个<code>socket</code>对应的文件描述符是不一样的，它们的责任也是不一样的，<br>原来的<code>socket</code>只用于跟客户端建立新的连接，而新的<code>socket</code>用于客户端与服务端进行数据交互，这意味着服务端的事件循环在处理的时候，对两个<code>socket</code>的读事件的触发时机也是不一样的。其中服务端原先<code>socket</code>的读事件被触发时意味着有新的连接可以被<code>accept</code>，而新<code>socket</code>的读事件被触发则是代表当前连接有新的数据可以被接收，这与客户端的<code>Socket</code>读事件的一样的，这意味着在<code>Socket</code>建立成功后，客户端和服务端的连接的读写逻辑都可以统一，不用进行区分了。</li><li>数据交互阶段：由于服务端<code>accept</code>方法返回的<code>Socket</code>与客户端的类似，所以这个阶段的客户端与服务端的逻辑是类似的，不过双端程序的数据只是与各自的<code>Socket</code>进行交互，而不是直接进行交互的。因为每个<code>Socket</code>都维护着读和写两个缓冲区，缓冲区的底层数据结构与队列类似，创建<code>Socket</code>的程序只能把数据投递到缓冲区或者从缓冲区获取数据，而无法触碰到网卡发送/接收数据的领域。<br>这也意味着在把<code>Socket</code>设置为非阻塞的情况下，当<code>Socket</code>的写缓冲区不满时，<code>Socket</code>的写操作是不会阻塞的，同样当<code>Socket</code>的读缓冲区拥有的量大于<code>Socket</code>读方法需要的量时，读操作也是不会阻塞的。</li><li>关闭阶段：由于<code>Socket</code>有两个缓冲区，所以关闭阶段分为<code>close</code>和<code>shutdowm</code>两个方法，其中<code>close</code>为关闭两个缓冲区，而<code>shuwdown</code>可以关闭指定的缓冲区(详细的流程见后文)。示例中的例子是服务端先调用了<code>close</code>方法，然后服务端会发送一个<code>EOF</code>事件给客户端，客户端从读缓冲区读到<code>EOF</code>事件后发现读通道已经关闭了，才调用<code>close</code>方法把整个<code>socket</code>一起关闭。</li></ul><h2 id="2-Asyncio-Socket"><a href="#2-Asyncio-Socket" class="headerlink" title="2.Asyncio Socket"></a>2.Asyncio Socket</h2><p>在文章<a href="https://so1n.me/2021/11/08/%E5%88%9D%E8%AF%86Python%20Async%E7%9A%84%E5%AE%9E%E7%8E%B0/">《初识Python协程的实现》</a>中介绍了如何把同步请求通过<code>selector</code>库和<code>yield</code>语法改造成一个简单的基于协程的异步请求，但是改造后的代码增加了很多监听和移除文件描述符的回调代码，编写起来比较麻烦，很不易懂。</p><p>不过在采用了<code>Asyncio</code>的思想并引入了<code>Task</code>和<code>Future</code>后，异步回调的代码都被消除了，但是大量的监听和移除文件描述符的代码还是存在，而<code>Asyncio.Socket</code>则封装了大量的读写事件的监听和移除的操作，只暴露了与<code>Socket</code>类似的方法，开发者通过这些方法可以简单快速的把同步请求改为基于协程的异步请求，比如<a href="https://so1n.me/2021/11/08/%E5%88%9D%E8%AF%86Python%20Async%E7%9A%84%E5%AE%9E%E7%8E%B0/">《初识Python协程的实现》</a>中的同步请求，它的源码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> socket<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">request</span>(<span class="hljs-params">host: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>    url: <span class="hljs-built_in">str</span> = <span class="hljs-string">f&quot;http://<span class="hljs-subst">&#123;host&#125;</span>&quot;</span><br>    sock: socket.SocketType = socket.socket()<br>    sock.connect((host, <span class="hljs-number">80</span>))<br>    sock.send(<span class="hljs-string">f&quot;GET <span class="hljs-subst">&#123;url&#125;</span> HTTP/1.0\r\nHost: <span class="hljs-subst">&#123;host&#125;</span>\r\n\r\n&quot;</span>.encode(<span class="hljs-string">&quot;ascii&quot;</span>))<br><br>    response_bytes: <span class="hljs-built_in">bytes</span> = <span class="hljs-string">b&quot;&quot;</span><br>    chunk: <span class="hljs-built_in">bytes</span> = sock.recv(<span class="hljs-number">4096</span>)<br>    <span class="hljs-keyword">while</span> chunk:<br>        response_bytes += chunk<br>        chunk = sock.recv(<span class="hljs-number">4096</span>)<br>    print(<span class="hljs-string">&quot;\n&quot;</span>.join([i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> response_bytes.decode().split(<span class="hljs-string">&quot;\r\n&quot;</span>)]))<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    request(<span class="hljs-string">&quot;so1n.me&quot;</span>)<br></code></pre></td></tr></table></figure><p>这份代码只对<code>Socket</code>进行简单的调用，其中涉及到<code>Socket</code>的调用方法有:</p><table><thead><tr><th>名称</th><th>作用</th><th>是否涉及到IO</th></tr></thead><tbody><tr><td>socket.socket</td><td>初始化socket</td><td>否</td></tr><tr><td>socket.connect</td><td>建立连接</td><td>是</td></tr><tr><td>socket.send</td><td>发送数据</td><td>是</td></tr><tr><td>socket.recv</td><td>接收数据</td><td>是</td></tr></tbody></table><p>在把它改为<code>Asyncio.Socket</code>时，只需要把涉及到IO的<code>Socket</code>方法以<code>loop.sock_xxx(sock, *param)</code>的形式进行修改，其中<code>xxx</code>是原来的方法名，<code>sock</code>则是通过<code>socket.socket</code>实例化的一个<code>sock</code>对象，而<code>param</code>则保持跟之前的一样的参数，更改后的代码如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> asyncio<br><span class="hljs-keyword">import</span> socket<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">request</span>(<span class="hljs-params">host: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>    url: <span class="hljs-built_in">str</span> = <span class="hljs-string">f&quot;http://<span class="hljs-subst">&#123;host&#125;</span>&quot;</span><br>    loop = asyncio.get_event_loop()<br>    sock: socket.SocketType = socket.socket()<br>    <span class="hljs-keyword">await</span> loop.sock_connect(sock, (host, <span class="hljs-number">80</span>))<br>    <span class="hljs-keyword">await</span> loop.sock_sendall(sock, <span class="hljs-string">f&quot;GET <span class="hljs-subst">&#123;url&#125;</span> HTTP/1.0\r\nHost: <span class="hljs-subst">&#123;host&#125;</span>\r\n\r\n&quot;</span>.encode(<span class="hljs-string">&quot;ascii&quot;</span>))<br><br>    response_bytes: <span class="hljs-built_in">bytes</span> = <span class="hljs-string">b&quot;&quot;</span><br>    chunk: <span class="hljs-built_in">bytes</span> = <span class="hljs-keyword">await</span> loop.sock_recv(sock, <span class="hljs-number">4096</span>)<br>    <span class="hljs-keyword">while</span> chunk:<br>        response_bytes += chunk<br>        chunk = <span class="hljs-keyword">await</span> loop.sock_recv(sock, <span class="hljs-number">4096</span>)<br>    print(<span class="hljs-string">&quot;\n&quot;</span>.join([i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> response_bytes.decode().split(<span class="hljs-string">&quot;\r\n&quot;</span>)]))<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    asyncio.run(request(<span class="hljs-string">&quot;so1n.me&quot;</span>))<br></code></pre></td></tr></table></figure><blockquote><p><code>Asyncio Socket</code>没有提供<code>send</code>方法，这里需要改为<code>sendall</code>。</p></blockquote><p>可以看到，代码的改动并没有很大，除了传染性的<code>async</code>和<code>await</code>语法外，其它逻辑并没有什么明显的变化，在运行代码之后可以看到程序运行成功，并输出如下响应结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs bash">HTTP/1.1 301 Moved Permanently<br>Connection: close<br>Content-Length: 162<br>Server: GitHub.com<br>Content-Type: text/html<br>Location: https://so1n.me/<br>X-GitHub-Request-Id: 9E20:2767:4FED3D:55C800:64E46CAF<br>Accept-Ranges: bytes<br>Date: Tue, 22 Aug 2023 08:11:04 GMT<br>Via: 1.1 varnish<br>Age: 233<br>X-Served-By: cache-hkg17935-HKG<br>X-Cache: HIT<br>X-Cache-Hits: 1<br>X-Timer: S1692691865.899948,VS0,VE1<br>Vary: Accept-Encoding<br>X-Fastly-Request-ID: 7180dce567d15eacaf44c9b93a2fb84bd67ab444<br><br>&lt;html&gt;<br>&lt;head&gt;&lt;title&gt;301 Moved Permanently&lt;/title&gt;&lt;/head&gt;<br>&lt;body&gt;<br>&lt;center&gt;&lt;h1&gt;301 Moved Permanently&lt;/h1&gt;&lt;/center&gt;<br>&lt;hr&gt;&lt;center&gt;nginx&lt;/center&gt;<br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><p>可以看到程序是正常运行的，为了了解<code>Asyncio.Socket</code>做了什么工作，接下来会翻阅源码，探究它的处理方法，首先是<code>loop.sock_connect</code>，它的源码如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-comment"># 位于:Lib/asyncio/selector_events.py</span><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sock_connect</span>(<span class="hljs-params">self, sock, address</span>):</span><br>    <span class="hljs-comment"># 检查ssl sock以及检查是否为阻塞的sock</span><br>    base_events._check_ssl_socket(sock)<br>    <span class="hljs-keyword">if</span> self._debug <span class="hljs-keyword">and</span> sock.gettimeout() != <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&quot;the socket must be non-blocking&quot;</span>)<br><br>    <span class="hljs-keyword">if</span> sock.family == socket.AF_INET <span class="hljs-keyword">or</span> (<br>            base_events._HAS_IPv6 <span class="hljs-keyword">and</span> sock.family == socket.AF_INET6):<br>        <span class="hljs-comment"># 通过dns将域名转为ip地址</span><br>        resolved = <span class="hljs-keyword">await</span> self._ensure_resolved(<br>            address, family=sock.family, <span class="hljs-built_in">type</span>=sock.<span class="hljs-built_in">type</span>, proto=sock.proto,<br>            loop=self,<br>        )<br>        _, _, _, _, address = resolved[<span class="hljs-number">0</span>]<br><br>    <span class="hljs-comment"># 创建一个future，这个future会等待soc连连接成功才返回数据。</span><br>    fut = self.create_future()<br>    self._sock_connect(fut, sock, address)<br>    <span class="hljs-comment"># 通过future等待soc床创建成功</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> fut<br></code></pre></td></tr></table></figure><p>这个方法分为三部分，首先是检查<code>Socket</code>的ssl并进行一些参数校验，然后通过<code>self._ensure_resolved</code>方法进行dns解析，最后才通过<code>self._sock_connect</code>方法进行真正建立连接。其中，dns解析方法<code>self._ensure_resolved</code>是<code>sock_connect</code>方法与其他<code>Socket</code>方法的不同点，它的源码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-comment"># 位于:Lib/asyncio/selector_events.py</span><br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_ensure_resolved</span>(<span class="hljs-params">self, address, *, family=<span class="hljs-number">0</span>, <span class="hljs-built_in">type</span>=socket.SOCK_STREAM, proto=<span class="hljs-number">0</span>, flags=<span class="hljs-number">0</span>, loop</span>):</span><br>        host, port = address[:<span class="hljs-number">2</span>]<br>    <span class="hljs-comment"># 判断是否已经解析，已经解析了就直接使用</span><br>        info = _ipaddr_info(host, port, family, <span class="hljs-built_in">type</span>, proto, *address[<span class="hljs-number">2</span>:])<br>        <span class="hljs-keyword">if</span> info <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-comment"># &quot;host&quot; is already a resolved IP.</span><br>            <span class="hljs-keyword">return</span> [info]<br>        <span class="hljs-keyword">else</span>:<br>    <span class="hljs-comment"># 没有解析则调用socket.getaddrinfo进行解析</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> loop.getaddrinfo(host, port, family=family, <span class="hljs-built_in">type</span>=<span class="hljs-built_in">type</span>, proto=proto, flags=flags)<br>    <br><span class="hljs-comment"># 位于:Lib/asyncio/base_events.py</span><br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getaddrinfo</span>(<span class="hljs-params">self, host, port, *, family=<span class="hljs-number">0</span>, <span class="hljs-built_in">type</span>=<span class="hljs-number">0</span>, proto=<span class="hljs-number">0</span>, flags=<span class="hljs-number">0</span></span>):</span><br>        <span class="hljs-keyword">if</span> self._debug:<br>            getaddr_func = self._getaddrinfo_debug<br>        <span class="hljs-keyword">else</span>:<br>            getaddr_func = socket.getaddrinfo<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> self.run_in_executor(<br>            <span class="hljs-literal">None</span>, getaddr_func, host, port, family, <span class="hljs-built_in">type</span>, proto, flags)<br></code></pre></td></tr></table></figure><p>通过源码发现，dns解析的逻辑中涉及到了<code>run_in_executor</code>方法，这个方法是把任务交给线程池进行处理。<br>在这里使用<code>run_in_executor</code>方法的原因是<code>POSIX</code>的DNS解析API是阻塞的，且没有提供异步选项，如果直接执行这个方法会卡住整个<code>Asyncio Event Loop</code>的运行，所以只能通过线程去调用这个API完成DNS解析，<br>不过<code>Asyncio</code>的默认线程池数量很小，如果是做爬虫类等需要频繁的进行DNS解析的项目，需要把默认的线程池改大一些。</p><blockquote><p>uvloop使用的libuv也选择了POSIX API，它的工作原理也是通过线程去执行DNS解析，详情见<a href="https://stackoverflow.com/questions/44603059/why-libuv-do-dns-request-by-multiple-thread">why libuv do DNS request by multiple thread</a></p></blockquote><p>在通过DNS进行地址解析后就拿到了真正的地址，这时可以开始进行真正的连接了，此时会调用<code>_sock_connect</code>方法去建立连接，它的源码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-comment"># 位于:Lib/asyncio/selector_events.py</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_sock_connect</span>(<span class="hljs-params">self, fut, sock, address</span>):</span><br>    fd = sock.fileno()<br>    <span class="hljs-keyword">try</span>:<br>        sock.connect(address)<br>    <span class="hljs-keyword">except</span> (BlockingIOError, InterruptedError):<br>        <span class="hljs-comment"># 检查对应的文件描述符对应的连接是否还在运行</span><br>        <span class="hljs-comment"># 如果还在运行则抛错</span><br>        self._ensure_fd_no_transport(fd)<br>        <span class="hljs-comment"># 注册文件描述符的读回调</span><br>        handle = self._add_writer(fd, self._sock_connect_cb, fut, sock, address)<br>        <span class="hljs-comment"># 通过fut添加fut完成时移除监听的回调</span><br>        fut.add_done_callback(functools.partial(self._sock_write_done, fd, handle=handle))<br>    <span class="hljs-keyword">except</span> (SystemExit, KeyboardInterrupt):<br>        <span class="hljs-keyword">raise</span><br>    <span class="hljs-keyword">except</span> BaseException <span class="hljs-keyword">as</span> exc:<br>        fut.set_exception(exc)<br>    <span class="hljs-keyword">else</span>:<br>        fut.set_result(<span class="hljs-literal">None</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_sock_write_done</span>(<span class="hljs-params">self, fd, fut, handle=<span class="hljs-literal">None</span></span>):</span><br>    <span class="hljs-comment"># 移除事件的监听</span><br>    <span class="hljs-keyword">if</span> handle <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> handle.cancelled():<br>        self.remove_writer(fd)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_sock_connect_cb</span>(<span class="hljs-params">self, fut, sock, address</span>):</span><br>    <span class="hljs-keyword">if</span> fut.done():<br>        <span class="hljs-keyword">return</span><br>    <span class="hljs-comment"># 当有写事件除非时代表着连接建立这个行为已经执行完毕了，但是需要检查建立结果</span><br>    <span class="hljs-keyword">try</span>:<br>        err = sock.getsockopt(socket.SOL_SOCKET, socket.SO_ERROR)<br>        <span class="hljs-keyword">if</span> err != <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">raise</span> OSError(err, <span class="hljs-string">f&#x27;Connect call failed <span class="hljs-subst">&#123;address&#125;</span>&#x27;</span>)<br>    <span class="hljs-keyword">except</span> (BlockingIOError, InterruptedError):<br>        <span class="hljs-keyword">pass</span><br>    <span class="hljs-keyword">except</span> (SystemExit, KeyboardInterrupt):<br>        <span class="hljs-keyword">raise</span><br>    <span class="hljs-keyword">except</span> BaseException <span class="hljs-keyword">as</span> exc:<br>        fut.set_exception(exc)<br>    <span class="hljs-keyword">else</span>:<br>        fut.set_result(<span class="hljs-literal">None</span>)<br></code></pre></td></tr></table></figure><p>这个方法的执行逻辑与其他的<code>Socket</code>方法的执行逻辑是类似，它们都会先尝试去执行<code>Socket</code>原先的方法，这时候如果操作系统准备就绪，那么意味着可以无阻塞的执行了<code>Socket</code>方法，否则是操作系统尚未准备好，需要捕获异常并对异常进行处理。</p><p>在捕获到异常后，会通过<code>_add_writer</code>添加了一个写事件的回调<code>_sock_connect_cb</code>，再通过fut添加一个fut完成时的<code>_sock_write_done</code>回调，然后就会把控制权交给了事件循环。<br>当事件循环发现文件描述符有事件被触发时，会调用<code>_sock_connect_cb</code>获取建立连接的结果，如果结果有异常，则把异常添加到fut中，否则就把结果放置到fut中，这样fut都会从<code>peding</code>状态变为<code>done</code>，fut也就会触发<code>_sock_write_done</code>移除掉事件循环对文件描述符的监听。</p><blockquote><p><code>_add_reader</code>，<code>_remove_reader</code>，<code>_add_writer</code>与<code>_remove_writer</code>是<code>Asyncio</code>为<code>socket</code>与<code>selector</code>直接交互封装的方法，可以通过文章<a href="https://so1n.me/2022/06/08/python_asyncio_schedule">《Python Asyncio调度原理》</a>进行了解。</p></blockquote><p>除了<code>Socket.connect</code>方法外，与<code>Asyncio.Socket</code>相关的方法还有很多，不过原理是一样的，它们的流程都可以简化为下图：<br><img    class="lazyload" data-original="https://fastly.jsdelivr.net/gh/so1n/so1n_blog_photo@master/blog_photo/1693295513482asyncio%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-asycnio-socket%E7%9A%84%E6%89%A7%E8%A1%8C%E9%80%BB%E8%BE%91.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">asyncio网络编程-asycnio-socket的执行逻辑.png</span></p><p>该图展示的是每个<code>Asyncio.Socket</code>方法的核心逻辑，各个方法具体的执行逻辑可以通过<a href="https://github.com/python/cpython/blob/677320348728ce058fa3579017e985af74a236d4/Lib/asyncio/selector_events.py">源码</a>进行详细的了解，常见的<code>socket</code>方法与<code>Asyncio Socket</code>方法对照表如下：</p><table><thead><tr><th>sock方法</th><th>Asyncio Sock方法</th><th>归属</th></tr></thead><tbody><tr><td>bind</td><td>无</td><td>服务端</td></tr><tr><td>listen</td><td>无</td><td>服务端</td></tr><tr><td>accept</td><td>sock_accept</td><td>服务端</td></tr><tr><td>connect</td><td>sock_connect</td><td>客户端</td></tr><tr><td>connect_ex</td><td>无</td><td>客户端</td></tr><tr><td>recv</td><td>sock_recv</td><td>共用</td></tr><tr><td>recv_info</td><td>sock_recv_into</td><td>共用</td></tr><tr><td>recvfrom</td><td>sock_recvfrom</td><td>共用</td></tr><tr><td>sendto</td><td>sock_sendto</td><td>共用</td></tr></tbody></table><h2 id="3-Protocol-amp-Transport"><a href="#3-Protocol-amp-Transport" class="headerlink" title="3.Protocol&amp;Transport"></a>3.Protocol&amp;Transport</h2><p><code>Asyncio.Socket</code>提供了<code>Socket</code>的调用方法的封装，但是如果直接基于<code>Socket</code>进行网络编程仍然会比较复杂，特别是TCP网络编程还需要处理很多东西。<br>为此<code>Asyncio</code>提供了一套<code>Protocol</code>&amp;<code>Transport</code>接口，它们面向开发者提供的方法都会屏蔽底层的<code>Socket</code>细节，并基于TCP或UDP协议封装了一些方法调用，开发者只要根据<code>Protocol</code>&amp;<code>Transport</code>协定的几个方法就可以快速开发出一个能够稳定使用的TCP服务。</p><p>在<code>Asyncio</code>的定义中，<code>Protocol</code>&amp;<code>Transport</code>是无法分开的一个整体，它们一起定义了网络I/O和进程间I/O的抽象接口，对于开发者来说可以简单的把<code>Protocol</code>理解为专门负责处理被动调用的，也就是连接什么时候建立，连接什么时候接收了数据；而<code>Transport</code>则是提供了许多开发者可以主动调用的接口，包括了向连接发送数据，关闭连接等等。</p><h3 id="3-1使用示例"><a href="#3-1使用示例" class="headerlink" title="3.1使用示例"></a>3.1使用示例</h3><p>官方的<code>Protocol</code>&amp;<code>Transport</code>的示例是<code>TCP Echo</code>，在这个示例中，服务端会接收客户端的消息并返回给客户端一样的消息，然后再关闭连接。而客户端会发送消息，并在接收消息后等待被关闭，其中服务端的示例代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> asyncio<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EchoServerProtocol</span>(<span class="hljs-params">asyncio.Protocol</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">connection_made</span>(<span class="hljs-params">self, transport</span>):</span><br>        <span class="hljs-comment"># transport创建成功后的回调，这里需要跟Protocol进行绑定</span><br>        peername = transport.get_extra_info(<span class="hljs-string">&#x27;peername&#x27;</span>)<br>        print(<span class="hljs-string">&#x27;Connection from &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(peername))<br>        self.transport = transport<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">data_received</span>(<span class="hljs-params">self, data</span>):</span><br>        <span class="hljs-comment"># socket收到数据的回调事件，这里先接收消息，再把内容返回给客户端最后再关闭</span><br>        message = data.decode()<br>        print(<span class="hljs-string">&#x27;Data received: &#123;!r&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(message))<br><br>        print(<span class="hljs-string">&#x27;Send: &#123;!r&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(message))<br>        self.transport.write(data)<br><br>        print(<span class="hljs-string">&#x27;Close the client socket&#x27;</span>)<br>        self.transport.close()<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    server = <span class="hljs-keyword">await</span> asyncio.get_running_loop().create_server(<br>        <span class="hljs-keyword">lambda</span>: EchoServerProtocol(), <span class="hljs-string">&#x27;127.0.0.1&#x27;</span>, <span class="hljs-number">8888</span><br>    )<br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> server:<br>        <span class="hljs-keyword">await</span> server.serve_forever()<br><br><br>asyncio.run(main())<br></code></pre></td></tr></table></figure><p>这份示例代码分为两大部分，一部分是<code>main</code>函数，它主要的工作是通过<code>create_server</code>创建一个TCP服务并通过<code>server.serve_forever()</code>运行服务。另一部分是<code>EchoServerProtocol</code>，它主要是在TCP服务<code>accept</code>了请求后被创建的，除此之外，<code>EchoServerProtocol</code>在收到请求数据后会把对应的数据通过<code>Protocol</code>的不同方法传递给使用者，而客户端的行为则不一样，它对应的源码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> asyncio<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EchoClientProtocol</span>(<span class="hljs-params">asyncio.Protocol</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, on_con_lost, received_queue</span>):</span><br>        <span class="hljs-comment"># 这里的on_con_lost是一个future对象，用于通知连接已经断开</span><br>        self.on_con_lost = on_con_lost<br>        <span class="hljs-comment"># 这里的received_queue是一个queue对象，用于接收消息</span><br>        self.received_queue = received_queue<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">connection_made</span>(<span class="hljs-params">self, transport</span>):</span><br>        <span class="hljs-comment"># transport创建成功后的回调，这里需要跟Protocol进行绑定</span><br>        self.transport = transport<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">data_received</span>(<span class="hljs-params">self, data</span>):</span><br>        self.received_queue.put_nowait(data.decode())<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">connection_lost</span>(<span class="hljs-params">self, exc</span>):</span><br>        <span class="hljs-comment"># socket连接断开的回调事件，这里需要通知on_con_lost</span><br>        self.on_con_lost.set_result(<span class="hljs-literal">True</span>)<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    loop = asyncio.get_running_loop()<br>    on_con_lost = loop.create_future()<br>    received_queue = asyncio.Queue()<br><br>    <span class="hljs-comment"># 初始化连接并接收返回的transport和protocol</span><br>    transport, protocol = <span class="hljs-keyword">await</span> loop.create_connection(<br>        <span class="hljs-keyword">lambda</span>: EchoClientProtocol(on_con_lost, received_queue),<br>        <span class="hljs-string">&#x27;127.0.0.1&#x27;</span>, <span class="hljs-number">8888</span>)<br><br>    <span class="hljs-comment"># 通过transport发送消息，写入消息是直接投递到系统的socket缓冲区，不会阻塞</span><br>    transport.write(<span class="hljs-string">&#x27;Hello World!&#x27;</span>.encode())<br>    <span class="hljs-comment"># 等待消息的返回</span><br>    rece_msg = <span class="hljs-keyword">await</span> received_queue.get()<br>    print(<span class="hljs-string">&quot;Data received:&quot;</span> + rece_msg)<br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-comment"># 等待连接被远方断开</span><br>        <span class="hljs-keyword">await</span> on_con_lost<br>    <span class="hljs-keyword">finally</span>:<br>        <span class="hljs-comment"># 确保连接被关闭</span><br>        transport.close()<br><br><br>asyncio.run(main())<br></code></pre></td></tr></table></figure><p>通过源码可以看到客户端也分为两部分，首先是<code>EchoClientProtocol</code>，它与服务端的<code>Protocol</code>类似，主要的区别是在初始化时的多了<code>on_con_lost</code>和<code>received_queue</code>参数，通过它们可以把异步回调转为同步调用。其中<code>on_con_lost</code>是用于监听连接什么时候丢失，<code>received_queue</code>则是接收了来自<code>Socket</code>的数据以供调用者获取。<br>另一部分的<code>main</code>函数的不同点是先通过<code>create_connection</code>建立了连接并返回了<code>Protocol</code>&amp;<code>Transport</code>，在建立连接成功后使用者可以通过<code>Transport</code>发送数据，或者通过<code>received_queue</code>获取数据以及通过<code>on_con_lost</code>等待连接被断开。</p><p>在把客户端与服务端的代码编写完毕后，先运行服务端的代码，然后再运行客户端的代码，会发现服务端打印了如下数据:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">Connection from (<span class="hljs-string">&#x27;127.0.0.1&#x27;</span>, 49072)<br>Data received: <span class="hljs-string">&#x27;Hello World!&#x27;</span><br>Send: <span class="hljs-string">&#x27;Hello World!&#x27;</span><br>Close the client socket<br></code></pre></td></tr></table></figure><p>而客户端打印了如下数据:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">Data received:Hello World!<br></code></pre></td></tr></table></figure><p>通过输出结果可以看到示例代码是正常运行的，它们基于<code>Protocol</code>&amp;<code>Transport</code>完成了数据的传输，<br>同时在运行的过程中涵盖了<code>Protocol</code>&amp;<code>Transport</code>的主要方法，对应的执行过程如下图：<br><img    class="lazyload" data-original="https://fastly.jsdelivr.net/gh/so1n/so1n_blog_photo@master/blog_photo/1692808529149asyncio%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-ProtocolTransport.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">1692808529149asyncio网络编程-ProtocolTransport.png</span></p><p>图中<code>loop</code>代表事件循环的方法，<code>t</code>代表<code>Transport</code>的方法，<code>p</code>则代表<code>Protoccol</code>的方法，通过图的执行过程可以看到除了<code>loop</code>的方法是在进行初始化外，不管对于客户端还是服务端，<code>Protocol</code>负责做回调的事情，<code>Transport</code>则是做主动调用的事情。此外客户端和服务端的<code>Protocol</code>&amp;<code>Transport</code>在建立连接和数据交互阶段的作用是一致的，可以看出<code>Protocol</code>&amp;<code>Transport</code>的逻辑是客户端和服务端共享的。</p><p>不过再回过头看示例代码则可以发现示例代码基于它们进行拓展开发的方式有所不同，对于服务端，由于它得等到客户端调用才能开始处理请求，它属于被动的一方，所以对服务端进行拓展开发时需要在它们的回调事件中编写对应的业务代码，并对<code>Transport</code>进行调用。<br>而客户端则处于主动的一方，需要初始化一些容器把异步回调变为同步调用，比如<code>asyncio.Future</code>，<code>asyncio.Queue</code>等交给<code>Protocol</code>接收数据，然后与<code>loop.create_connection</code>返回的<code>transport</code>一起进行主动调用。</p><h3 id="3-2-源码分析"><a href="#3-2-源码分析" class="headerlink" title="3.2.源码分析"></a>3.2.源码分析</h3><p>在了解了<code>Protocol</code>&amp;<code>Transport</code>的使用方法后，可以发现在<code>Protocol</code>&amp;<code>Transport</code>中已经看不到<code>Socket</code>的影子了，需要通过对<code>Protocol</code>&amp;<code>Transport</code>的源码进行分析，才能了解它性能更强的秘密。</p><p>在示例代码中可以看到客户端与服务端使用的<code>Protocol</code>&amp;<code>Transport</code>是一致的，所以先从它们各自的初始化方法<code>create_connection</code>和<code>create_server</code>开始下手。<br>其中<code>create_connection</code>方法非常简单，它先是对<code>Socket</code>和其他参数进行校验，接着再进行DNS解析以及通过<code>Happy Eyeballs</code>快速的选择IP地址，然后再调用<code>_create_connection_transport</code>方法。</p><p>而<code>_create_connection_transport</code>方法只是创建并返回<code>Transport</code>实例和<code>Protocol</code>实例，其中<code>Protocol</code>实例是通过用户传递的<code>Protocol</code>构造函数创建的，<code>Transport</code>则是由对应的事件循环创建的。</p><blockquote><ul><li>快乐眼球算法见:<a href="https://zh.wikipedia.org/wiki/Happy_Eyeballs">Happy Eyeballs</a></li><li><code>create_connection</code>的源码比较简单，具体见:<a href="https://github.com/python/cpython/blob/677320348728ce058fa3579017e985af74a236d4/Lib/asyncio/base_events.py#L976">https://github.com/python/cpython/blob/677320348728ce058fa3579017e985af74a236d4/Lib/asyncio/base_events.py#L976</a></li></ul></blockquote><p>对于服务端的<code>create_server</code>方法，它的处理逻辑一开始也是跟<code>create_connection</code>方法类似，也是先对<code>socket</code>和其他参数进行校验，然后再把参数和<code>Socket</code>放到<code>Server</code>实例中，接着再调用<code>Server</code>实例的<code>serve_forever</code>方法启动服务，而<code>serve_forever</code>的主要方法会调用到<code>_start_serving</code>方法(asyncio/base_events.py)，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-comment"># 位于:Lib/asyncio/selector_events.py</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_start_serving</span>(<span class="hljs-params">self</span>):</span><br>   <span class="hljs-keyword">if</span> self._serving:<br>       <span class="hljs-keyword">return</span><br>   self._serving = <span class="hljs-literal">True</span><br>   <span class="hljs-keyword">for</span> sock <span class="hljs-keyword">in</span> self._sockets:<br>       sock.listen(self._backlog)  <span class="hljs-comment"># &lt;--重点，后面有说</span><br>       self._loop._start_serving(<br>           self._protocol_factory, sock, self._ssl_context,<br>           self, self._backlog, self._ssl_handshake_timeout,<br>           self._ssl_shutdown_timeout)<br></code></pre></td></tr></table></figure><p>该方法会对所有托管的<code>socket</code>进行<code>listen</code>操作，并调用事件循环的<code>_start_serving</code>方法(asyncio/selector_events.py)为<code>Socket</code>向事件循环注册对应的可读事件回调，源码如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 位于:Lib/asyncio/selector_events.py</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_start_serving</span>(<span class="hljs-params">self, protocol_factory, sock,</span></span><br><span class="hljs-function"><span class="hljs-params">                   sslcontext=<span class="hljs-literal">None</span>, server=<span class="hljs-literal">None</span>, backlog=<span class="hljs-number">100</span>,</span></span><br><span class="hljs-function"><span class="hljs-params">                   ssl_handshake_timeout=constants.SSL_HANDSHAKE_TIMEOUT,</span></span><br><span class="hljs-function"><span class="hljs-params">                   ssl_shutdown_timeout=constants.SSL_SHUTDOWN_TIMEOUT</span>):</span><br>    self._add_reader(sock.fileno(), self._accept_connection,<br>                     protocol_factory, sock, sslcontext, server, backlog,<br>                     ssl_handshake_timeout, ssl_shutdown_timeout)<br></code></pre></td></tr></table></figure><p>通过源码可以看到这个方法是添加<code>Socket</code>文件描述符的可读事件回调，在添加之后每当<code>Socket</code>与客户端建立连接时，事件循环就会发现并调用<code>_accept_connection</code>方法，<code>_accept_connection</code>方法的源码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-comment"># 位于:Lib/asyncio/selector_events.py</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_accept_connection</span>(<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">        self, protocol_factory, sock,</span></span><br><span class="hljs-function"><span class="hljs-params">        sslcontext=<span class="hljs-literal">None</span>, server=<span class="hljs-literal">None</span>, backlog=<span class="hljs-number">100</span>,</span></span><br><span class="hljs-function"><span class="hljs-params">        ssl_handshake_timeout=constants.SSL_HANDSHAKE_TIMEOUT,</span></span><br><span class="hljs-function"><span class="hljs-params">        ssl_shutdown_timeout=constants.SSL_SHUTDOWN_TIMEOUT</span>):</span><br>    <span class="hljs-comment"># 执行n次accept，直到没有新的请求建立或者执行完毕</span><br>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(backlog):<br>        <span class="hljs-keyword">try</span>:<br>            conn, addr = sock.accept()<br>            conn.setblocking(<span class="hljs-literal">False</span>)<br>        <span class="hljs-keyword">except</span> (BlockingIOError, InterruptedError, ConnectionAbortedError):<br>            <span class="hljs-comment"># socket accept的缓冲区为空，所以不用处理了</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>        <span class="hljs-keyword">except</span> OSError <span class="hljs-keyword">as</span> exc:<br>            <span class="hljs-comment"># 如果有错误，则应该移除监听，再重新调用`_start_serving`进行监听</span><br>            <span class="hljs-keyword">if</span> exc.errno <span class="hljs-keyword">in</span> (errno.EMFILE, errno.ENFILE,<br>                             errno.ENOBUFS, errno.ENOMEM):<br>                <span class="hljs-comment"># 兼容accept多次后Linux一直将文件描述符标记为准备就绪的bug，先移除监听再重新监听</span><br>                self.call_exception_handler(&#123;<br>                    <span class="hljs-string">&#x27;message&#x27;</span>: <span class="hljs-string">&#x27;socket.accept() out of system resource&#x27;</span>,<br>                    <span class="hljs-string">&#x27;exception&#x27;</span>: exc,<br>                    <span class="hljs-string">&#x27;socket&#x27;</span>: trsock.TransportSocket(sock),<br>                &#125;)<br>                self._remove_reader(sock.fileno())<br>                self.call_later(constants.ACCEPT_RETRY_DELAY,<br>                                self._start_serving,<br>                                protocol_factory, sock, sslcontext, server,<br>                                backlog, ssl_handshake_timeout,<br>                                ssl_shutdown_timeout)<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">raise</span>  <span class="hljs-comment"># The event loop will catch, log and ignore it.</span><br>        <span class="hljs-keyword">else</span>:<br>            extra = &#123;<span class="hljs-string">&#x27;peername&#x27;</span>: addr&#125;<br>            <span class="hljs-comment"># 每个acccept都可以认为是一个新的客户端建立的请求，为了提高并发性，需要创建一个新的协程去处理。 </span><br>            accept = self._accept_connection2(<br>                protocol_factory, conn, extra, sslcontext, server,<br>                ssl_handshake_timeout, ssl_shutdown_timeout)<br>            self.create_task(accept)<br></code></pre></td></tr></table></figure><p>通过源码可以发现<code>_accept_connection</code>方法的主要作用就是同时处理backlog个<code>socket</code>的<code>accept</code>方法。<br>这个处理是专门针对事件循环进行优化的，因为<code>Socket</code>在接收到新的请求后会马上通知给事件循环，然后等待事件循环去调用事件对应的回调，虽然<code>epoll</code>的处理速度很快了，但是<code>Socket</code>收到新的请求与回调的执行仍有一定的延迟。<br>如果是触发一次事件就执行一次<code>accept</code>，那么处理整个程序<code>accept</code>的效率会降低，但是同时处理<code>Socket</code>的多个<code>accept</code>则可能会使系统的瞬间负载提高，所以这个方法会提供一个<code>backlog</code>参数供开发者选择<code>backlog</code>的大小以决定每次收到事件后执行多少次<code>accept</code>方法。</p><p>那么<code>backlog</code>的大小要怎么定义呢，其实这里的<code>backlog</code>与<code>_start_serving</code>方法(asyncio/base_events.py)中<code>listen</code>用到的<code>backlog</code>是一样的，而对于<code>listen</code>的backlog大小是需要根据场景来进行选择的，在Linux中，默认的backlog为128，而常见的后端服务的应用<code>Nginx</code>与<code>Redis</code>的默认值为511，这里不对<code>backlog</code>进行详细介绍，有兴趣的可以通过以下文章了解:</p><ul><li><a href="https://www.modb.pro/db/156775">再聊 TCP backlog</a></li><li><a href="https://stackoverflow.com/questions/36594400/what-is-backlog-in-tcp-connections">What is “backlog” in TCP connections?</a></li></ul><p>当<code>accept</code>成功后，则会调用<code>_accept_connection2</code>方法，<code>_accept_connection2</code>与客户端的<code>_create_connection_transport</code>一样，它创建了<code>Transport</code>实例和<code>Protocol</code>实例。不过在服务端中为了提高性能，通常都是一个协程对应一个<code>Protocol</code>&amp;<code>Transport</code>，所以是通过<code>create_task</code>来执行<code>_accept_connection2</code>方法。</p><h3 id="3-2-1-Transport"><a href="#3-2-1-Transport" class="headerlink" title="3.2.1.Transport"></a>3.2.1.Transport</h3><p><code>create_server</code>和<code>create_connection</code>只是负责对参数的校验以及创建和监听<code>Socket</code>，真正负责数据交互的逻辑都藏在<code>Protocol</code>&amp;<code>Transport</code>之中。<br>在<code>Protocol</code>&amp;<code>Transport</code>的协定中，<code>Transport</code>可以理解为<code>Socket</code>的上层，它负责控制<code>Socket</code>的所有行为，包括数据的读，写，限制流的传输还有最重要的是对<code>Protocol</code>的流进行控制。比如在对<code>Tranposrt</code>进行初始化时，它会在<code>Socket</code>创建完毕后调用<code>Protocol</code>的<code>connection_made</code>方法，<code>Transport</code>初始化的源码如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-comment"># 位于:Lib/asyncio/selector_events.py</span><br><span class="hljs-comment">#  Transport有多个实现，而_SelectorSocketTransport是专门适配UnixSelector事件循环的Transport的实现，它有一定的代表意义。</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">_SelectorSocketTransport</span>(<span class="hljs-params">_SelectorTransport</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, loop, sock, protocol, waiter=<span class="hljs-literal">None</span>,</span></span><br><span class="hljs-function"><span class="hljs-params">                 extra=<span class="hljs-literal">None</span>, server=<span class="hljs-literal">None</span></span>):</span><br>        self._read_ready_cb = <span class="hljs-literal">None</span><br>        <span class="hljs-comment"># 初始化参数以及通过`set_protocol`设置Protocol</span><br>        <span class="hljs-built_in">super</span>().__init__(loop, sock, protocol, extra, server)<br>        self._eof = <span class="hljs-literal">False</span><br>        self._paused = <span class="hljs-literal">False</span><br>        self._empty_waiter = <span class="hljs-literal">None</span><br><br>        <span class="hljs-comment"># 设置TCP_NODELAY，禁用Nagle算法以提升提升性能</span><br>        base_events._set_nodelay(self._sock)<br>        <span class="hljs-comment"># transport创建完毕</span><br>        self._loop.call_soon(self._protocol.connection_made, self)<br>        <span class="hljs-comment"># 注册读事件的回调</span><br>        self._loop.call_soon(self._add_reader, self._sock_fd, self._read_ready)<br>        <span class="hljs-keyword">if</span> waiter <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            self._loop.call_soon(futures._set_result_unless_cancelled, waiter, <span class="hljs-literal">None</span>)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">set_protocol</span>(<span class="hljs-params">self, protocol</span>):</span><br>        <span class="hljs-comment"># 根据协议设置对应的已读回调</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(protocol, protocols.BufferedProtocol):<br>            self._read_ready_cb = self._read_ready__get_buffer<br>        <span class="hljs-keyword">else</span>:<br>            self._read_ready_cb = self._read_ready__data_received<br><br>        <span class="hljs-built_in">super</span>().set_protocol(protocol)<br></code></pre></td></tr></table></figure><p>源码中，<code>Transport</code>在初始化时会先初始化参数并设置已读事件的回调，然后再对<code>sock</code>进行处理，在这里只设置TCP_NODELAY为True以禁用Nagle算法。</p><p>Ngale算法是为了优化网络传输而诞生的，但是优化网络传输跟时代是有关系的，在以前网络带宽都比较小的互联网初期，如果都是传输小流量的请求体会比较容易引起网络堵塞。<br>比如要传输10个字节长度为1的请求体，它们都会被装载在TCP报文上面，而TCP本身Header的长度在40字节左右，那么此时网络要传输的字节总数为10*(40 + 1) = 410字节。而在应用Ngale算法后，它可以把10个请求体合并在一起，那么传输的字节总数为40 + 1 * 10 = 50字节，可见在使用Ngale算法后可以减少大量的网络传输。</p><p>然而到了现在，大部分设备的网络带宽已经变得很大，而且Nagle算法与delay-ACK搭配会带来网络延迟，这对于类似HTTP1.1的请求来说影响可能不大，但对于那些小频快跑的实时数据交互场景却容易受到Nagle影响进而影响网络传输性能，为此<code>Transport</code>在初始化的时候就默认禁用了Nagle算法以减少网络数据交互的延迟。</p><blockquote><p>这里只做简单易懂的举例和介绍，实际上是比较复杂的，可以通过下面的连接进一步的了解。</p><ul><li><a href="https://en.wikipedia.org/wiki/Nagle%27s_algorithm">Nagle算法(英)</a></li><li><a href="https://github.com/python/asyncio/pull/373">关于讨论Asyncio是否默认禁用Nagle算法的Issue(英)</a></li></ul></blockquote><p>在<code>Socket</code>创建完毕后，<code>Transport</code>会调用<code>Protocol</code>的<code>connection_made</code>表示<code>transport</code>创建完毕，然后再调用<code>_add_reader</code>方法向<code>socket</code>文件描述符注册了可读事件的回调函数<code>self._read_ready</code>。</p><blockquote><p><code>__init__</code>方法无法被标记为<code>async</code>函数，所以这里使用了一个<code>waiter</code>用于标识<code>__init__</code>方法何时执行完毕，使其达到类似<code>async</code>函数的实现。</p></blockquote><p>在<code>Transport</code>创建完毕后，每当<code>socket</code>收到一条消息，就会触发一个可读事件，然后事件循环就会执行<code>self._read_ready</code>去处理消息。<br>这里假设<code>self._read_ready_cb</code>为<code>self._read_ready__data_received</code>，它对应的源码如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-comment"># 位于:Lib/asyncio/selector_events.py</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">_SelectorSocketTransport</span>(<span class="hljs-params">_SelectorTransport</span>):</span><br>    ...<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_read_ready__data_received</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">if</span> self._conn_lost:<br>            <span class="hljs-keyword">return</span><br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-comment"># 通过sock获获取数据</span><br>            data = self._sock.recv(self.max_size)<br>    <span class="hljs-comment"># 省去一些异常处理</span><br>        <span class="hljs-keyword">except</span> BaseException <span class="hljs-keyword">as</span> exc:<br>            self._fatal_error(exc, <span class="hljs-string">&#x27;Fatal read error on socket transport&#x27;</span>)<br>            <span class="hljs-keyword">return</span><br>    <br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> data:<br>            <span class="hljs-comment"># 没有数据则代表收到eof</span><br>            self._read_ready__on_eof()<br>            <span class="hljs-keyword">return</span><br>    <br>        <span class="hljs-keyword">try</span>:<br>            self._protocol.data_received(data)<br>    <span class="hljs-comment"># 省去一些异常处理</span><br>        <span class="hljs-keyword">except</span> BaseException <span class="hljs-keyword">as</span> exc:<br>            self._fatal_error(<br>                exc, <span class="hljs-string">&#x27;Fatal error: protocol.data_received() call failed.&#x27;</span>)<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_read_ready__on_eof</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">try</span>:<br>            keep_open = self._protocol.eof_received()<br>    <span class="hljs-comment"># 省去一些异常处理</span><br>        <span class="hljs-keyword">except</span> BaseException <span class="hljs-keyword">as</span> exc:<br>            self._fatal_error(<br>                exc, <span class="hljs-string">&#x27;Fatal error: protocol.eof_received() call failed.&#x27;</span>)<br>            <span class="hljs-keyword">return</span><br>    <br>        <span class="hljs-keyword">if</span> keep_open:<br>            self._loop._remove_reader(self._sock_fd)<br>        <span class="hljs-keyword">else</span>:<br>            self.close()<br></code></pre></td></tr></table></figure><p>在去掉其中的异常处理后可以发现，实际上它的工作原理就是通过<code>sock.recv</code>接收数据，当收到的数据不为空时就调用<code>Protocol</code>的<code>data_received</code>把数据传递给开发者定义的方法中，为空时就调用<code>self._read_ready__on_eof</code>。<br>而<code>_read_ready__on_eof</code>的逻辑也是很简单的，它会调用<code>Protocol</code>的<code>eof_received</code>方法获取返回结果，这个结果是开发者定义的，开发者可以定义它返回的是<code>True</code>还是<code>False</code>，如果是返回<code>True</code>则只移除读监听事件，这样方便在关闭连接之前<code>Socket</code>还能继续发送消息，如果返回<code>False</code>则是直接关闭连接<code>Socket</code>，使<code>Socket</code>既不能读也不能写。</p><p>此外，还可以从源码看到在执行读事件的回调时如果有异常发生就会调用<code>_fatal_error</code>方法进行处理，这个方法除了报告异常外，还会关闭<code>Socket</code>。<br>在之前的介绍中<code>Socket</code>是拥有读写两个缓冲区，也介绍了<code>Socket</code>支持只关闭一个缓冲区，另外一个缓冲区还能继续工作的情况，而在<code>Transport</code>中，只关闭写缓冲区称为普通关闭，两个缓冲区都关闭称为强制关闭，它们对应的方法为<code>close</code>和<code>abort</code>，其中<code>abort</code>方法与<code>_fatal_error</code>的功能是类似的，它们对应的源码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-comment"># 位于:Lib/asyncio/selector_events.py</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">_SelectorTransport</span>(<span class="hljs-params">transports._FlowControlMixin, transports.Transport</span>):</span><br>    ...<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">abort</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-comment"># 强制关闭连接</span><br>        self._force_close(<span class="hljs-literal">None</span>)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">is_closing</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> self._closing<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">close</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">if</span> self._closing:<br>            <span class="hljs-keyword">return</span><br>        <span class="hljs-comment"># close只移除读事件监听，buffer没有数据才会强制关闭</span><br>        self._closing = <span class="hljs-literal">True</span><br>        self._loop._remove_reader(self._sock_fd)<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self._buffer:<br>            self._conn_lost += <span class="hljs-number">1</span><br>            self._loop._remove_writer(self._sock_fd)<br>            self._loop.call_soon(self._call_connection_lost, <span class="hljs-literal">None</span>)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__del__</span>(<span class="hljs-params">self, _warn=warnings.warn</span>):</span><br>        <span class="hljs-keyword">if</span> self._sock <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            _warn(<span class="hljs-string">f&quot;unclosed transport <span class="hljs-subst">&#123;self!r&#125;</span>&quot;</span>, ResourceWarning, source=self)<br>            <span class="hljs-comment"># 确保sock被回收，如果没有这个操作，可能会导致内存溢出</span><br>            self._sock.close()<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_fatal_error</span>(<span class="hljs-params">self, exc, message=<span class="hljs-string">&#x27;Fatal error on transport&#x27;</span></span>):</span><br>        <span class="hljs-comment"># 省略的异常处理...</span><br>        self._force_close(exc)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_force_close</span>(<span class="hljs-params">self, exc</span>):</span><br>        <span class="hljs-keyword">if</span> self._conn_lost:<br>            <span class="hljs-comment"># 如果连接丢失就不管了</span><br>            <span class="hljs-keyword">return</span><br>        <span class="hljs-keyword">if</span> self._buffer:<br>            <span class="hljs-comment"># 移除写事件监听以及缓存的buffer</span><br>            self._buffer.clear()<br>            self._loop._remove_writer(self._sock_fd)<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self._closing:<br>            <span class="hljs-comment"># 移除读事件监听</span><br>            self._closing = <span class="hljs-literal">True</span><br>            self._loop._remove_reader(self._sock_fd)<br>        <span class="hljs-comment"># 稍后才关闭连接</span><br>        self._loop.call_soon(self._call_connection_lost, exc)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_call_connection_lost</span>(<span class="hljs-params">self, exc</span>):</span><br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-keyword">if</span> self._protocol_connected:<br>                <span class="hljs-comment"># 如果当前还处于连接中，那么需要通过Protocol的`connection_lost`方法把连接丢失的原因告诉使用方。</span><br>                self._protocol.connection_lost(exc)<br>        <span class="hljs-keyword">finally</span>:<br>            <span class="hljs-comment"># 关闭sock等一切资源</span><br>            self._sock.close()<br>            self._sock = <span class="hljs-literal">None</span><br>            self._protocol = <span class="hljs-literal">None</span><br>            self._loop = <span class="hljs-literal">None</span><br>            server = self._server<br>            <span class="hljs-keyword">if</span> server <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>                server._detach()<br>                self._server = <span class="hljs-literal">None</span><br></code></pre></td></tr></table></figure><p>通过源码可以发现<code>abort</code>与<code>_fatal_error</code>方法的唯一区别是<code>_fatal_error</code>方法会携带异常参数，<code>abort</code>的异常参数为空，而它们的执行逻辑都是调用<code>_force_close</code>方法对<code>Socket</code>进行强制关闭。<br>在<code>_force_close</code>方法被调用后，它会移除对应的事件监听，并把关闭连接的方法<code>_call_connection_lost</code>安排到<code>Asyncio Event Loop</code>中，交给<code>Asyncio Event Loop</code>调用。<br>这样做的目的是考虑到了还有一些读事件和写事件正在等待被<code>Asyncio Event Loop</code>执行，这时如果强制关闭<code>Socket</code>会导致这些事件被调用时由于<code>Socket</code>已经关闭而无法发送或获取数据，所以需要把<code>_call_connection_lost</code>的调用安排在读/写事件之后被运行。(asyncio的调度是按照先进先出为原则)</p><p>通过源码也可以发现<code>close</code>方法相对<code>_force_close</code>方法的唯一的区别是在buffer缓冲不为空时不会移除写事件监听也不会调用<code>_call_connection_lost</code>方法，从而确保所有在buffer缓冲区的消息都能正常发送。另外<code>Transport</code>还有一个方法–<code>__del__</code>，它是确保<code>Transport</code>被回收时，<code>Socket</code>会被完全关闭，不然可能造成内存溢出。</p><blockquote><p>关于<code>Python Socket</code>的内存溢出困扰了多个开源项目多年后才被解决，具体可以通过文章<a href="https://www.paulsprogrammingnotes.com/2021/12/python-memory-leaks.html">《Fixing Memory Leaks In Popular Python Libraries》</a>了解。</p></blockquote><p>最后，只剩下一个写数据的方法尚未窥探，它的相关源码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-comment"># 位于:Lib/asyncio/selector_events.py</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">_SelectorSocketTransport</span>(<span class="hljs-params">_SelectorTransport</span>):</span><br>    ...<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">write</span>(<span class="hljs-params">self, data</span>):</span><br>        ...<br>        <span class="hljs-comment"># 省略一些校验的</span><br>        <span class="hljs-keyword">if</span> self._eof:<br>            <span class="hljs-comment"># 已经eof了，不能写数据</span><br>            <span class="hljs-keyword">raise</span> RuntimeError(<span class="hljs-string">&#x27;Cannot call write() after write_eof()&#x27;</span>)<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self._buffer:<br>            <span class="hljs-comment"># 如果没有buffer,就代表当前的发送缓冲区可能为空，先发发试一试</span><br>            <span class="hljs-keyword">try</span>:<br>                <span class="hljs-comment"># 先看看能扔多少数据去缓冲区</span><br>                n = self._sock.send(data)<br>            <span class="hljs-keyword">except</span> (BlockingIOError, InterruptedError):<br>                <span class="hljs-comment"># 缓冲区满了，无法发送...</span><br>                <span class="hljs-keyword">pass</span><br>            <span class="hljs-comment"># 省去一些异常处理</span><br>            <span class="hljs-keyword">except</span> BaseException <span class="hljs-keyword">as</span> exc:<br>                self._fatal_error(exc, <span class="hljs-string">&#x27;Fatal write error on socket transport&#x27;</span>)<br>                <span class="hljs-keyword">return</span><br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-comment"># 去掉已经扔到缓冲区的数据</span><br>                data = data[n:]<br>                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> data:<br>                    <span class="hljs-keyword">return</span><br>            <span class="hljs-comment"># 如果缓冲区满了，那么还有剩余的数据，需要等待socket可写时才调用回调写数据</span><br>            self._loop._add_writer(self._sock_fd, self._write_ready)<br><br>        <span class="hljs-comment"># 把数据加入buffer中，buffer默认是bytesarray，效率很高</span><br>        self._buffer.extend(data)<br>        <span class="hljs-comment"># 如果写的压力很高，就需要暂停一下 </span><br>        self._maybe_pause_protocol()<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_write_ready</span>(<span class="hljs-params">self</span>):</span><br><br>        <span class="hljs-keyword">if</span> self._conn_lost:<br>            <span class="hljs-keyword">return</span><br>        <span class="hljs-keyword">try</span>:<br>            n = self._sock.send(self._buffer)<br>        <span class="hljs-comment"># 省去一些异常处理</span><br>        <span class="hljs-keyword">except</span> BaseException <span class="hljs-keyword">as</span> exc:<br>            <span class="hljs-comment"># 如果有异常，就移除监听，清空buffer</span><br>            self._loop._remove_writer(self._sock_fd)<br>            self._buffer.clear()<br>            <span class="hljs-comment"># 抛出异常并通过`force`强制关闭socket</span><br>            self._fatal_error(exc, <span class="hljs-string">&#x27;Fatal write error on socket transport&#x27;</span>)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">if</span> n:<br>                <span class="hljs-comment"># 从buffer清除掉已经发送的buffer</span><br>                <span class="hljs-keyword">del</span> self._buffer[:n]<br>            self._maybe_resume_protocol()  <span class="hljs-comment"># May append to buffer.</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self._buffer:<br>                <span class="hljs-comment"># 发送完了需要进行善后处理，因为有可能socket在发送完消息后就要关闭</span><br>                self._loop._remove_writer(self._sock_fd)<br>                <span class="hljs-keyword">if</span> self._closing:<br>                    self._call_connection_lost(<span class="hljs-literal">None</span>)<br>                <span class="hljs-keyword">elif</span> self._eof:<br>                    self._sock.shutdown(socket.SHUT_WR)<br></code></pre></td></tr></table></figure><p>这里比较特别的是写数据的方法<code>write</code>是一个普通的函数，这是因为<code>socket</code>底层有缓冲区，所以写入数据是非常方便的，且在设置不阻塞后，只要调用<code>socket.send</code>就可以把数据投递到缓冲区并马上返回，这个方法不涉及任何IO。</p><p>然而缓冲区也有满的情况，于是<code>Transport</code>对缓冲区满的情况做一些处理，正常情况下缓冲区的满有两种情况，如下图：<br><img    class="lazyload" data-original="https://fastly.jsdelivr.net/gh/so1n/so1n_blog_photo@master/blog_photo/1693299214481asyncio%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-socket%E5%86%99%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BB%A1%E7%9A%84%E6%83%85%E5%86%B5.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">asyncio网络编程-socket写缓冲区满的情况.png</span></p><p>图中假设缓冲区的大小为5，而投递数据的大小为3，对于图的左边，在投递数据的时候会发现缓冲区已经满，这时候操作系统会返回一个错误；而右边是投递时还没满的情况，这种情况下只能投递前面两个消息，此时<code>Transport</code>在执行<code>socket.send</code>方法后会获得到返回值为2，接着就删除<code>buffer</code>中前面的两个消息，只留下一个消息等待缓冲区可投递时再进行投递。</p><p>在后续如果缓冲区还不可投递时且仍有数据通过<code>write</code>方法被发送过来，<code>Transport</code>会把数据添加到<code>buffer</code>中，再监听可写事件，当<code>socket</code>可写时，才会调用<code>_write_ready</code>方法把<code>buffer</code>中的数据发送，这一个过程会随着可读事件的监听移除才结束，而只有<code>buffer</code>为空或者发送异常时，才会移除可读事件的监听。</p><p>在<code>write</code>源码中还可以看到<code>_maybe_resume_protocol</code>和<code>_maybe_pause_protocol</code>方法的相关调用，这两个方法都是为了控制写入速度的，毕竟<code>buffer</code>的长度是无限的，如果一些恶意客户端与服务端建立请求后，客户端选择拒收消息从而导致<code>buffer</code>会堆积一堆数据，而这些数据也是无意义同时在积累过多后可能导致服务端崩溃，所以需要根据<code>buffer</code>的积累数据的量决定暂停写入还是恢复写入。</p><p>除此之外，在<code>_ready_write</code>方法中还涉及到了<code>eof</code>机制，<code>eof</code>是<code>end of file</code>的缩写，它是表示流的结尾的标志。由于TCP是双工的协议，如果其中一端想关闭连接时，另一端可能正在发送数据，虽然程序不需要再写数据了，但不能直接关闭<code>Socket</code>，需要获取对方发送过来的所有数据后才能关闭。<br>而<code>socket</code>的<code>eof</code>机制就是用于告诉对位的读端在收到这个标记后就不需要再接收数据，且后续的数据发送完后也请尽快的关闭。<br>在<code>Transport</code>中通过<code>write_eof</code>方法提供了一个主动标记写通道为<code>eof</code>的功能，使用者也通过<code>can_write_eof</code>判断当前<code>Transport</code>是否可以使用<code>eof</code>机制，它们对应的源码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-comment"># 位于:Lib/asyncio/selector_events.py</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">_SelectorSocketTransport</span>(<span class="hljs-params">_SelectorTransport</span>):</span><br>    ...<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">write_eof</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">if</span> self._closing <span class="hljs-keyword">or</span> self._eof:<br>            <span class="hljs-keyword">return</span><br>        self._eof = <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self._buffer:<br>            self._sock.shutdown(socket.SHUT_WR)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">can_write_eof</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><p>可以看到<code>Transport</code>中与<code>eof</code>相关的源码很简单，它主要是先标记<code>_eof</code>为True，然后再判断当前的<code>buffer</code>是否为空，是的话就通过<code>sock.shutdown(socket.SHUT_WR)</code>关闭<code>Socket</code>中的写缓冲区。如果<code>buffer</code>不为空，则不做任何处理，在<code>_write_ready</code>发送完<code>buffer</code>的所有数据后再调用<code>sock.shutdown(socket.SHUT_WR)</code>关闭。</p><blockquote><p>注：</p><ul><li>当服务端调用<code>sock.shutdown(socket.SHUT_WR)</code>后，客户端会通过<code>socket.recv</code>收到一条空消息，客户端会通过空消息判定是服务端到发送端已经<code>eof</code>了。</li><li><code>shutdown</code>与<code>close</code>的区别：<code>socket</code>对应的是操作系统的一个资源，多个进程可以拥有同一个<code>socket</code>的句柄，当调用<code>close</code>时，会把句柄的计数减为1,当句柄技计数为0的时候，<code>socket</code>才会真正的关闭并释放资源。而<code>shutdown</code>则是会关闭底层的连接，比如它可以关闭读端，写端或者同时关闭读写端，并等待对方发送FIN/EOF，但是它不会释放<code>socket</code>占用的资源，调用者仍然需要调用<code>shutdown</code>。</li></ul></blockquote><h2 id="4-Stream"><a href="#4-Stream" class="headerlink" title="4.Stream"></a>4.Stream</h2><p><code>Stream</code>是<code>Asyncio</code>中的高级API，通过<code>Stream</code>可以方便的为流式服务进行编程，同时通过<code>Stream</code>编写出来的代码既简洁又容易理解，如官方文档的<code>TCP Echo client</code>示例代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> asyncio<br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">tcp_echo_client</span>(<span class="hljs-params">message</span>):</span><br>    reader, writer = <span class="hljs-keyword">await</span> asyncio.open_connection(<br>        <span class="hljs-string">&#x27;127.0.0.1&#x27;</span>, <span class="hljs-number">8888</span>)<br><br>    print(<span class="hljs-string">f&#x27;Send: <span class="hljs-subst">&#123;message!r&#125;</span>&#x27;</span>)<br>    writer.write(message.encode())<br>    <span class="hljs-keyword">await</span> writer.drain()<br><br>    data = <span class="hljs-keyword">await</span> reader.read(<span class="hljs-number">100</span>)<br>    print(<span class="hljs-string">f&#x27;Received: <span class="hljs-subst">&#123;data.decode()!r&#125;</span>&#x27;</span>)<br><br>    print(<span class="hljs-string">&#x27;Close the connection&#x27;</span>)<br>    writer.close()<br>    <span class="hljs-keyword">await</span> writer.wait_closed()<br><br>asyncio.run(tcp_echo_client(<span class="hljs-string">&#x27;Hello World!&#x27;</span>))<br></code></pre></td></tr></table></figure><p>可以看到，这份示例代码十分简单，它在初始化时会返回<code>reader</code>和<code>writer</code>对象，后续调用者可以通过<code>reader</code>读取消息，并通过<code>writer</code>发送消息和关闭连接。<br>而基于<code>Stream</code>接口编写的服务端的也变得简单了， <code>TCP Echo Server</code>源码如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> asyncio<br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">handle_echo</span>(<span class="hljs-params">reader, writer</span>):</span><br>    addr = writer.get_extra_info(<span class="hljs-string">&#x27;peername&#x27;</span>)<br><br>    data = <span class="hljs-keyword">await</span> reader.read(<span class="hljs-number">100</span>)<br>    message = data.decode()<br>    print(<span class="hljs-string">f&quot;Received <span class="hljs-subst">&#123;message!r&#125;</span> from <span class="hljs-subst">&#123;addr!r&#125;</span>&quot;</span>)<br><br>    print(<span class="hljs-string">f&quot;Send: <span class="hljs-subst">&#123;message!r&#125;</span>&quot;</span>)<br>    writer.write(data)<br>    <span class="hljs-keyword">await</span> writer.drain()<br><br>    print(<span class="hljs-string">&quot;Close the connection&quot;</span>)<br>    writer.close()<br>    <span class="hljs-keyword">await</span> writer.wait_closed()<br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    server = <span class="hljs-keyword">await</span> asyncio.start_server(<br>        handle_echo, <span class="hljs-string">&#x27;127.0.0.1&#x27;</span>, <span class="hljs-number">8888</span>)<br><br>    addrs = <span class="hljs-string">&#x27;, &#x27;</span>.join(<span class="hljs-built_in">str</span>(sock.getsockname()) <span class="hljs-keyword">for</span> sock <span class="hljs-keyword">in</span> server.sockets)<br>    print(<span class="hljs-string">f&#x27;Serving on <span class="hljs-subst">&#123;addrs&#125;</span>&#x27;</span>)<br><br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> server:<br>        <span class="hljs-keyword">await</span> server.serve_forever()<br><br>asyncio.run(main())<br></code></pre></td></tr></table></figure><p>通过代码可以发现，基于<code>Stream</code>编写的TCP Echo服务中<code>main</code>函数的用法与<code>Protocol</code>&amp;<code>Transport</code>类似创建一个<code>Server</code>实例，而处理连接的<code>handle_echo</code>方法的代码量比<code>Protocol</code>&amp;<code>Transport</code>还要少，同时它不再像<code>Protocol</code>&amp;<code>Transport</code>一样包含大量的异步回调方法。</p><p>下图是<code>Stream</code>客户端与<code>Stream</code>服务端的<code>TCP Echo</code>示例：<br><img    class="lazyload" data-original="https://fastly.jsdelivr.net/gh/so1n/so1n_blog_photo@master/blog_photo/1693300383481asyncio%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-Stream.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">1693300383481asyncio网络编程-Stream.png</span></p><p>通过图可以发现它们交互的形式与<code>Protocol</code>&amp;<code>Transport</code>类似，实际上<code>Stream</code>的核心<code>StreamProtocol</code>就是基于<code>Protocol</code>&amp;<code>Transport</code>进行拓展，然后<code>Stream</code>还抽象出<code>StreamReader</code>和<code>StreamWrite</code>两个对象用于连接用户和<code>StreamProtocol</code>的数据交互，使用户可以使用同步的思想进行网络编程。</p><h3 id="4-1-源码分析"><a href="#4-1-源码分析" class="headerlink" title="4.1.源码分析"></a>4.1.源码分析</h3><p><code>Stream</code>最大的特点就是把回调事件转为同步给用户使用以及运用了一些限流手段，但是它把细节全都隐藏起来了，需要通过源码去窥探它的运行逻辑。</p><p>首先是客户端和服务端建立连接和初始化的方法，它们的源码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-comment"># 位于:Lib/asyncio/stream.py</span><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">open_connection</span>(<span class="hljs-params">host=<span class="hljs-literal">None</span>, port=<span class="hljs-literal">None</span>, *, limit=_DEFAULT_LIMIT, **kwds</span>):</span><br>    <span class="hljs-comment"># 客户端建立连接的方法</span><br>    loop = events.get_running_loop()<br>    reader = StreamReader(limit=limit, loop=loop)<br>    protocol = StreamReaderProtocol(reader, loop=loop)<br>    transport, _ = <span class="hljs-keyword">await</span> loop.create_connection(<br>        <span class="hljs-keyword">lambda</span>: protocol, host, port, **kwds)<br>    writer = StreamWriter(transport, protocol, reader, loop)<br>    <span class="hljs-keyword">return</span> reader, writer<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">start_server</span>(<span class="hljs-params">client_connected_cb, host=<span class="hljs-literal">None</span>, port=<span class="hljs-literal">None</span>, *, limit=_DEFAULT_LIMIT, **kwds</span>):</span><br>    <span class="hljs-comment"># 服务端建立连接的方法</span><br>    loop = events.get_running_loop()<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">factory</span>():</span><br>        reader = StreamReader(limit=limit, loop=loop)<br>        protocol = StreamReaderProtocol(reader, client_connected_cb, loop=loop)<br>        <span class="hljs-keyword">return</span> protocol<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> loop.create_server(factory, host, port, **kwds)<br></code></pre></td></tr></table></figure><p>通过源码可以知道，<code>open_connection</code>与<code>start_server</code>类似，它们都是先创建好<code>StreamReaderProtocol</code>，再交给<code>create_connection</code>或者<code>create_server</code>运行。<br>而<code>StreamReaderProtocol</code>是继承于<code>Protocol</code>，它相比于<code>Protocol</code>多了一些适配了<code>StreamReader</code>和<code>StreamWriter</code>的调用。</p><blockquote><p><code>StreamProtocol</code>只是一个中间者，很多逻辑与<code>Protocol</code>&amp;<code>Transport</code>类似，故不会进行分析。</p></blockquote><h4 id="4-1-1-StreamWriter"><a href="#4-1-1-StreamWriter" class="headerlink" title="4.1.1.StreamWriter"></a>4.1.1.StreamWriter</h4><p>对于<code>StreamWriter</code>可以认为是<code>Transport</code>的代理对象，所以它负责的也是主动调用的那部分，它的很多方法都是直接调用到<code>Transport</code>的同名方法，它与<code>Transport</code>的唯一区别就是多了<code>wait_closed</code>和<code>drain</code>方法两个方法，对应的源码如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-comment"># 位于:Lib/asyncio/stream.py</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StreamWriter</span>:</span><br>    <span class="hljs-comment"># 初始化...</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, transport, protocol, reader, loop</span>):</span><br>        self._transport = transport<br>        self._protocol = protocol<br>        self._reader = reader<br>        self._loop = loop<br><br>    <span class="hljs-comment"># 省略了一堆代理transport的方法</span><br>    ...<br><br>    <span class="hljs-comment"># 相比transport多出来的方法</span><br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">wait_closed</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">await</span> self._protocol._get_close_waiter(self)<br><br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">drain</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">if</span> self._reader <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            exc = self._reader.exception()<br>            <span class="hljs-keyword">if</span> exc <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>                <span class="hljs-keyword">raise</span> exc<br>        <span class="hljs-keyword">if</span> self._transport.is_closing():<br>            <span class="hljs-keyword">await</span> sleep(<span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">await</span> self._protocol._drain_helper()<br></code></pre></td></tr></table></figure><p>源码中的<code>wait_closed</code>是等待<code>Protocol</code>的<code>_get_close_waiter</code>的方法，这个方法会一直阻塞直到<code>Protocol</code>的<code>connection_lost</code>被调用，所以在调用<code>await transport.wait_closed()</code>实际上等于<code>Protocol</code>&amp;<code>Transport</code>示例代码中的<code>on_con_lost</code>。<br>而<code>drain</code>方法则是<code>Stream</code>的流控制功能，它是结合<code>Write</code>一起使用的，它能防止写缓冲区被写满，以及及早的发现写缓冲区的异常，所以在使用<code>Stream</code>进行网络编程时，在执行<code>write.write()</code>后，一定要调用<code>await write.drain()</code>方法。</p><p>此外，源码中的<code>drain</code>方法有一句奇特的代码–<code>await sleep(0)</code>，这段代码出现在这里的原因是在<code>Protocol</code>&amp;<code>Transport</code>中，<code>write</code>的调用出错后会让事件循环尽快的执行<code>_connection_lost</code>的调用，但是用户在调用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">write.write()<br><span class="hljs-keyword">await</span> write.drain()<br></code></pre></td></tr></table></figure><p>的过程中并没有让步在事件循环，如果不添加<code>await sleep(0)</code>显式的让步给事件循环，就会导致<code>Protocol</code>的<code>_drain_helper</code>方法会在<code>_connection_lost</code>之前调用，最终导致写入数据这个操作无法感知到连接已经丢失。</p><blockquote><p><code>drain_helper</code>方法是与流控制相结合的，它在<code>Protocol</code>&amp;<code>Transport</code>调用了<code>_maybe_pause_protocol</code>时会阻塞，直到<code>_maybe_resume_protocol</code>被调用的时候才会释放，流控制的相关代码可以通过<a href="https://github.com/python/cpython/blob/677320348728ce058fa3579017e985af74a236d4/Lib/asyncio/streams.py#L116">FlowControlMixin的源码</a>了解。</p></blockquote><h4 id="4-1-1-StreamReader"><a href="#4-1-1-StreamReader" class="headerlink" title="4.1.1.StreamReader"></a>4.1.1.StreamReader</h4><p>用户在调用<code>StreamReader</code>时，通常都会调用到<code>read*</code>系列方法来获取数据，但是在<code>Protocol</code>&amp;<code>Transport</code>中的数据是通过回调把数据传递给用户的。<code>Stream</code>为了解决这个问题，它把<code>StreamReader</code>设计成一个类似于先进先出的容器，当<code>Protocol</code>&amp;<code>Transport</code>有数据时会把数据通过投喂数据的方法写入到<code>SteamReader</code>中，并提供获取数据，中止投递数据等方法交给用户调用。</p><p>其中投喂数据的源码如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StreamReader</span>:</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_wakeup_waiter</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-comment"># 告诉read系列的方法，已经有数据进来了，可以继续执行了</span><br>        waiter = self._waiter<br>        <span class="hljs-keyword">if</span> waiter <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            self._waiter = <span class="hljs-literal">None</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> waiter.cancelled():<br>                waiter.set_result(<span class="hljs-literal">None</span>)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">feed_eof</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-comment"># 投递了一个eof的信息</span><br>        self._eof = <span class="hljs-literal">True</span><br>        self._wakeup_waiter()<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">at_eof</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;给StreamProtocol判断是否需要投递`eof`&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">return</span> self._eof <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> self._buffer<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">feed_data</span>(<span class="hljs-params">self, data</span>):</span><br>        <span class="hljs-keyword">assert</span> <span class="hljs-keyword">not</span> self._eof, <span class="hljs-string">&#x27;feed_data after feed_eof&#x27;</span><br><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> data:<br>            <span class="hljs-keyword">return</span><br><br>        <span class="hljs-comment"># 把数据添加到buffer中</span><br>        self._buffer.extend(data)<br>        <span class="hljs-comment"># 通过`wakeup_waiter`唤醒read系列方法</span><br>        self._wakeup_waiter()<br><br>        <span class="hljs-keyword">if</span> (self._transport <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> self._paused <span class="hljs-keyword">and</span> <span class="hljs-built_in">len</span>(self._buffer) &gt; <span class="hljs-number">2</span> * self._limit):<br>            <span class="hljs-comment"># 如果当前的buffer数据超过了限制，就暂停数据的读取</span><br>            <span class="hljs-keyword">try</span>:<br>                self._transport.pause_reading()<br>            <span class="hljs-keyword">except</span> NotImplementedError:<br>                <span class="hljs-comment"># 如果当前transport不支持暂停，就直接忘掉它，后面需要调用者通过`set_transport`重新设置transport</span><br>                self._transport = <span class="hljs-literal">None</span><br>            <span class="hljs-keyword">else</span>:<br>                self._paused = <span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><p>通过源码可以看出，<code>StreamReader</code>中的投喂数据方法和用户调用方法会共享<code>self._waiter</code>和<code>self._buffer</code>对象，其中<code>self._buffer</code>用于接收和读取数据，而<code>self._waiter</code>用于通知<code>read</code>系列等方法，告诉它们有数据来了，可以继续处理，<code>StreamReader</code>的读数据相关源码如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StreamReader</span>:</span><br>    ... <span class="hljs-comment"># 省略设置异常的方法</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_maybe_resume_transport</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-comment"># 由于读取了数据了，`buffer`当前的水位已经降低，需要尝试恢复从transport读取数据。</span><br>        <span class="hljs-keyword">if</span> self._paused <span class="hljs-keyword">and</span> <span class="hljs-built_in">len</span>(self._buffer) &lt;= self._limit:<br>            self._paused = <span class="hljs-literal">False</span><br>            self._transport.resume_reading()<br><br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_wait_for_data</span>(<span class="hljs-params">self, func_name</span>):</span><br>        <span class="hljs-keyword">if</span> self._waiter <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">raise</span> RuntimeError(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;func_name&#125;</span>() called while another coroutine is already waiting for incoming data&#x27;</span>)<br><br>        <span class="hljs-comment"># 如果已经被暂停，那么应该恢复数据的读取</span><br>        <span class="hljs-keyword">if</span> self._paused:<br>            self._paused = <span class="hljs-literal">False</span><br>            self._transport.resume_reading()<br><br>        <span class="hljs-comment"># 创建_waiter并等待被唤醒。</span><br>        self._waiter = self._loop.create_future()<br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-keyword">await</span> self._waiter<br>        <span class="hljs-keyword">finally</span>:<br>            self._waiter = <span class="hljs-literal">None</span><br><br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">read</span>(<span class="hljs-params">self, n=-<span class="hljs-number">1</span></span>):</span><br>        <span class="hljs-comment"># 有异常直接抛异常</span><br>        <span class="hljs-keyword">if</span> self._exception <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">raise</span> self._exception<br><br>        <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span>:<br>            <span class="hljs-comment"># 如果为0,那么直接返回</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-string">b&#x27;&#x27;</span><br><br>        <span class="hljs-comment"># 省去小于0的情况，小于0时会一直获取数据，直到接收到EOF</span><br>        ...<br>        <br>        <span class="hljs-comment"># 如果没有buffer，则需要等待</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self._buffer <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> self._eof:<br>            <span class="hljs-keyword">await</span> self._wait_for_data(<span class="hljs-string">&#x27;read&#x27;</span>)<br><br>        <span class="hljs-comment"># 从buffer获取数据（同时也清空了它们在buffer中的占用）</span><br>        data = <span class="hljs-built_in">bytes</span>(self._buffer[:n])<br>        <span class="hljs-keyword">del</span> self._buffer[:n]<br><br>        self._maybe_resume_transport()<br>        <span class="hljs-keyword">return</span> data<br></code></pre></td></tr></table></figure><p>通过源码可以看到<code>StreamReader</code>获取数据的方法比<code>Protocol</code>&amp;<code>Transport</code>复杂了一点，它在调用<code>read</code>时，如果发现<code>buffer</code>有数据，就直接返回数据，否则就需要通过<code>wait_for_data</code>方法等待<code>waiter</code>对象被投喂数据的方法设置为不阻塞。</p><p>在这个流程中，<code>Stream</code>通过<code>waiter</code>对象和<code>buffer</code>完成异步回调到同步调用的转换，但是这样会导致每当有一条消息进来的时候，<code>StreamReader</code>需要通过<code>Asyncio Event Loop</code>的两次调用才能获取到消息，这也正是<code>Stream</code>比<code>Protocol</code>&amp;<code>Protocol</code>性能差点原因。</p><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5.总结"></a>5.总结</h2><p>通过<code>Protocol</code>&amp;<code>Transport</code>中的源码可以看到，<code>Protocol</code>&amp;<code>Transport</code>通过一次事件批量<code>accept</code>以及使用了<code>buffer</code>加快了发送速度来获得了比<code>Asyncio Socket</code>高出很多的性能，而<code>Stream</code>通过<code>asyncio.Future</code>和<code>asyncio.Queue</code>把<code>Protocol</code>&amp;<code>Transport</code>的异步回调转换为同步调用，以一定的性能消耗换取了易用性。</p><p>在TCP编程的场景中，这两个网络编程接口都有它们对应的使用场景，我们可以通过使用场景来选择对应的接口进行网络编程开发，通常情况下，默认服务端都会使用<code>Protocol</code>&amp;<code>Transport</code>进行网络编程开发，因为它们都会追求极高的性能。<br>而客户端则默认会使用<code>Stream</code>进行网络编程开发，因为客户端会偏通过同步调用的方式进行开发，如果使用<code>Protocol</code>&amp;<code>Transport</code>进行开发，也需要用到<code>asyncio.Future</code>和<code>asycnio.Queue</code>容器把异步回调转换为同步调用，这样一来使用<code>Protocol</code>&amp;<code>Transport</code>开发和使用<code>Stream</code>进行开发的客户端性能是差不多的。</p><blockquote><p>本文是偏理论的分析<code>Python Asyncio</code>的网络编程相关的接口原理，在后续将介绍如何通过<code>Protocol</code>&amp;<code>Transport</code>开发一个Web框架。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前记&quot;&gt;&lt;a href=&quot;#前记&quot; class=&quot;headerlink&quot; title=&quot;前记&quot;&gt;&lt;/a&gt;前记&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Python Asyncio&lt;/code&gt;不仅提供了简单的&lt;code&gt;Socket&lt;/code&gt;接口，还基于&lt;code&gt;Asyncio.Socket&lt;/code&gt;提供了&lt;code&gt;Protocol&lt;/code&gt;&amp;amp;&lt;code&gt;Transport&lt;/code&gt;接口以及更高级的&lt;code&gt;Stream&lt;/code&gt;接口，这些接口大大的减轻了开发者进行网络编程的心理负担。&lt;br&gt;本文主要介绍了&lt;code&gt;Asyncio&lt;/code&gt;这些接口的简单使用以及对应的原理分析。&lt;/p&gt;</summary>
    
    
    <content src="https://fastly.jsdelivr.net/gh/so1n/so1n_blog_photo@master/blog_photo/16550442517731649661119526images.png" type="image"/>
    
    
    <category term="Python Asyncio" scheme="http://so1n.me/categories/Python-Asyncio/"/>
    
    
    <category term="Python" scheme="http://so1n.me/tags/Python/"/>
    
    <category term="Asyncio" scheme="http://so1n.me/tags/Asyncio/"/>
    
  </entry>
  
  <entry>
    <title>Python Asyncio实践--高并发下如何防止缓存击穿</title>
    <link href="http://so1n.me/2023/08/14/python_asyncio_concunrrency_result_share/"/>
    <id>http://so1n.me/2023/08/14/python_asyncio_concunrrency_result_share/</id>
    <published>2023-08-14T15:33:18.000Z</published>
    <updated>2023-08-16T07:48:58.589Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前记"><a href="#前记" class="headerlink" title="前记"></a>前记</h2><p>本文描述的是如何基于<code>Asyncio.Future</code>的特性编写一个语言级别的防缓存击穿的工具–<code>Share</code>，并介绍它的使用和高并发下的处理方法。</p><span id="more"></span><h2 id="1-缓存击穿"><a href="#1-缓存击穿" class="headerlink" title="1.缓存击穿"></a>1.缓存击穿</h2><p>在后端服务中，大部分的系统瓶颈都集中在DB上，为了提升服务性能和减轻DB压力，一般会添加一层缓存层，然后每个请求都会先从缓存层获取数据，如果获取不到数据则先从DB系统中获取数据，获取到数据后才把数据放置在缓存层中再返回数据。<br>不过缓存层缓存的数据是有过期时间的，当设置的值过期时会导致所有请求无法从缓存层获取到数据，进而蜂拥冲向DB系统获取数据，这就是缓存击穿。由于缓存击穿是瞬时性且量级很大，所以它容易快速的提升DB系统压力，甚至打崩DB系统，流程如图：<br><img    class="lazyload" data-original="https://fastly.jsdelivr.net/gh/so1n/so1n_blog_photo@master/blog_photo/1692114894425%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B8%8B%E9%98%B2%E6%AD%A2%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F--%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">高并发下防止缓存穿透--缓存穿透.png</span></p><p>从图中可以看到，在缓存值失效后，所有请求会先后击穿缓存并请求到DB系统，DB系统从被击穿到缓存值被设置的这段时间会执行大量相同的查询，这些查询除了浪费系统资源外还会提升系统压力，为此，大部分业务会使用加锁来解决这个问题。</p><p>在加锁后，整个请求的流程就会变为先访问缓存层，在发现缓存层没有对应数据时(缓存失效)，请求会先去请求锁，当请求到锁的请求才可以去DB系统查询，并在缓存系统设置缓存值，而获取不到锁的请求只能等待锁释放后从缓存系统中获取值并返回，如图：<br><img    class="lazyload" data-original="https://fastly.jsdelivr.net/gh/so1n/so1n_blog_photo@master/blog_photo/1692115661425%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B8%8B%E9%98%B2%E6%AD%A2%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F-%E4%BD%BF%E7%94%A8%E9%94%81.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">高并发下防止缓存穿透-使用锁.png</span><br>通过图可以看到，在加锁后，访问DB系统的同类请求只剩一个了，这样一来可以减轻DB系统的压力，但是在采用加锁逻辑后会把压力从DB系统转移给了负责锁的系统，只是锁系统能容忍的上限会比DB系统高很多。<br>此外，如果这个锁系统是一个分布式锁，那么此时的锁系统也是一个热点值，后端服务与分布式锁系统之间会因为大量的请求获取锁而产生许多IO。</p><h2 id="2-语言级别的解决方案"><a href="#2-语言级别的解决方案" class="headerlink" title="2.语言级别的解决方案"></a>2.语言级别的解决方案</h2><p>为了在解决缓存击穿的问题，同时减少缓存击穿时导致不同系统的IO交互次数变多的情况，新的解决方案必须是编程语言级别的，而不是一个单独的组件。同时，这个解决方案除了能兜住大量缓存击穿的请求外，还需要做到只让其中的第一个访问的请求能够命中DB系统获取值再返回且拿到的值又能跟其他请求共享。<br>由于这个解决方案会在多个请求之间共享值，所以我取名为<code>Share</code>，它在系统架构中的位置如图：<br><img    class="lazyload" data-original="https://fastly.jsdelivr.net/gh/so1n/so1n_blog_photo@master/blog_photo/1692116134425%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B8%8B%E9%98%B2%E6%AD%A2%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F-%E4%BD%BF%E7%94%A8Share.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">高并发下防止缓存穿透-使用Share.png</span><br>通过图可以发现<code>Share</code>的位置与锁一样，不过具体逻辑却会有不同，如果仔细研究它的逻辑，会发现它的逻辑与<code>Asyncio.Future</code>类似。<br>比如在<code>asyncio.Future</code>的使用过程中，不同的协程可以通过<code>await asyncio.Future()</code>方法获取到已经被设置的结果，同时，如果这个值还没设置，其他协程在调用<code>await asyncio.Future()</code>时会一直被阻塞，直到其他协程通过<code>set_result</code>设置结果。</p><blockquote><p>Note: 在下面介绍<code>Share</code>中将以某个协程调用代替请求的操作</p></blockquote><p>有了<code>asyncio.Future</code>后，<code>Share</code>的实现会变得很轻松，只要再实现如何放行第一个协程的执行即可。<code>Share</code>实现的第一步是定义一个类似于如下的数据结构:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Python">Dict[<span class="hljs-built_in">str</span>, asyncio.Future]<br></code></pre></td></tr></table></figure><p>这个数据结构是一个Dict，其中它的key是这类协程的标识，然后再根据这个数据结构添加对应的逻辑：</p><ul><li>当协程通过<code>Share</code>被调用时，根据key判断是否有同类协程</li><li>如果没有则初始化一个<code>asyncio.Future</code>，然后再执行这个协程，在协程执行完毕时把协程的返回值设置在<code>asyncio.Future</code>中并从字典中删除这个key以及返回数据。</li><li>如果有则调用<code>await asyncio.Future</code>等待第一个共享协程的返回值。</li></ul><p>具体代码如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> asyncio<br><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> Any, Dict, Callable<br><br>future_dict: Dict[<span class="hljs-built_in">str</span>, asyncio.Future] = &#123;&#125;<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">share</span>(<span class="hljs-params">key: <span class="hljs-built_in">str</span>, fn: Callable, param: Any = <span class="hljs-literal">None</span></span>) -&gt; Any:</span><br>    <span class="hljs-keyword">if</span> key <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> future_dict:<br>        <span class="hljs-keyword">try</span>:<br>            future = asyncio.Future()<br>            future_dict[key] = future<br>            future.set_result(<span class="hljs-keyword">await</span> fn(*(param <span class="hljs-keyword">or</span> ())))<br>        <span class="hljs-keyword">finally</span>:<br>            future_dict.pop(key, <span class="hljs-literal">None</span>)<br>    <span class="hljs-keyword">else</span>:<br>        future = future_dict[key]<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> future<br><br><span class="hljs-comment"># 以下是测试share是否能够正常运行的程序</span><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">delay_return</span>(<span class="hljs-params">duration: <span class="hljs-built_in">int</span></span>) -&gt; int:</span><br>    <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">return</span> duration<br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>() -&gt; <span class="hljs-keyword">None</span>:</span><br>    task_list = [share(<span class="hljs-string">&quot;demo&quot;</span>, delay_return, (i, ))<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>)]<br>    done, _ = <span class="hljs-keyword">await</span> asyncio.wait(task_list)<br>    print([future.result() <span class="hljs-keyword">for</span> future <span class="hljs-keyword">in</span> done])<br><br><br>asyncio.run(main())<br></code></pre></td></tr></table></figure><p>在运行后可以发现，不同协程的初始化参数虽然是不同的，但是他们的结果是一样的（结果取决于哪个协程先运行），比如我这次运行后它的所有结果都为3，如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">[3, 3, 3, 3, 3, 3, 3, 3, 3, 3]<br></code></pre></td></tr></table></figure><p>这个结果意味着语言级别的兜底逻辑的没问题的，但是它还有一些问题仍然需要解决。</p><h2 id="3-Share的基础实现"><a href="#3-Share的基础实现" class="headerlink" title="3.Share的基础实现"></a>3.Share的基础实现</h2><p>在一开始时，我也是简单的实现了一个工具函数来解决缓存击穿的问题，但是在线上运行一段时间后，发现这个工具函数仍有一些小问题需要解决，于是对它进行了一些<code>复杂化处理</code>，使其能够拓展并解决一些高并发的问题，同时也提升了易用性。</p><p><code>Share</code>整个实现分为两部分，第一部份是一个名为<code>Token</code>的类，它的底层就是一个<code>asyncio.Future</code>，而提供的方法都是基于<code>asyncio.Future</code>的封装，代码如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Token</span>(<span class="hljs-params">Generic[_Tp]</span>):</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, key: Any</span>):</span><br>        self._key: Any = key<br>        self._future: Optional[asyncio.Future[_Tp]] = <span class="hljs-literal">None</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">can_do</span>(<span class="hljs-params">self</span>) -&gt; bool:</span><br>        <span class="hljs-comment"># 初始化future以及判断是否执行后续操作</span><br>        <span class="hljs-comment"># 这个逻辑可能有点怪，但是暂时没有想到更好的办法</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self._future:<br>            self._future = asyncio.Future()<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">is_done</span>(<span class="hljs-params">self</span>) -&gt; bool:</span><br>        <span class="hljs-comment"># 判断是否执行完成</span><br>        <span class="hljs-keyword">return</span> self._future <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> self._future.done()<br><br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">await_done</span>(<span class="hljs-params">self</span>) -&gt; _Tp:</span><br>        <span class="hljs-comment"># 获取设置在future的结果</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self._future:<br>            <span class="hljs-keyword">raise</span> RuntimeError(<span class="hljs-string">f&quot;You should use Token&lt;<span class="hljs-subst">&#123;self._key&#125;</span>&gt;.can_do() before Token&lt;<span class="hljs-subst">&#123;self._key&#125;</span>&gt;.await_done()&quot;</span>)<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self._future.done():<br>            <span class="hljs-keyword">await</span> self._future<br>        <span class="hljs-keyword">return</span> self._future.result()<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">set_result</span>(<span class="hljs-params">self, result: Union[_Tp, Exception]</span>) -&gt; bool:</span><br>        <span class="hljs-comment"># 设置结果到future中，需要注意的是，如果是异常，需要通过`set_exception`设置异常，否则在设置异常后调用`await asyncio.Futurte`时不会抛出错误。</span><br>        <span class="hljs-keyword">if</span> self._future <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> self._future.done():<br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(result, Exception):<br>                self._future.set_exception(result)<br>            <span class="hljs-keyword">else</span>:<br>                self._future.set_result(result)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><p>而第二部分就是<code>Share</code>的主体部分了，代码如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Share</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        <span class="hljs-comment"># 初始化存储token的容器</span><br>        self._token_dict: Dict[_ShareKeyType, Token] = <span class="hljs-built_in">dict</span>()<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_get_token</span>(<span class="hljs-params">self, key: _ShareKeyType</span>) -&gt; Token:</span><br>        <span class="hljs-comment"># 获取token的简单封装</span><br>        <span class="hljs-keyword">if</span> key <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> self._token_dict:<br>            self._token_dict[key] = Token(key)<br>        <span class="hljs-keyword">return</span> self._token_dict[key]<br><br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_do_handle</span>(<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">        self, key: _ShareKeyType, func: Callable[P, Coroutine[Any, Any, R_T]], args: P.args, kwargs: P.args</span></span><br><span class="hljs-function"><span class="hljs-params">    </span>) -&gt; R_T:</span><br>        token: Token = self._get_token(key)<br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-comment"># 判断是否可以执行操作</span><br>            <span class="hljs-keyword">if</span> token.can_do():<br>                <span class="hljs-comment"># 如果可以则执行</span><br>                <span class="hljs-keyword">try</span>:<br>                    token.set_result(<span class="hljs-keyword">await</span> func(*(args <span class="hljs-keyword">or</span> ()), **(kwargs <span class="hljs-keyword">or</span> &#123;&#125;)))<br>                <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>                    <span class="hljs-comment"># 存储异常值</span><br>                    token.set_result(e)<br>            <span class="hljs-comment"># 通过token获取值并返回，没有值则会阻塞</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> token.await_done()<br>        <span class="hljs-keyword">finally</span>:<br>            <span class="hljs-comment"># 用完就删除掉</span><br>            self._future_dict.pop(key, <span class="hljs-literal">None</span>)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">do</span>(<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">        self,</span></span><br><span class="hljs-function"><span class="hljs-params">        key: _ShareKeyType,</span></span><br><span class="hljs-function"><span class="hljs-params">        func: Callable[P, Coroutine[Any, Any, R_T]],</span></span><br><span class="hljs-function"><span class="hljs-params">        args: P.args = <span class="hljs-literal">None</span>,</span></span><br><span class="hljs-function"><span class="hljs-params">        kwargs: P.kwargs = <span class="hljs-literal">None</span>,</span></span><br><span class="hljs-function"><span class="hljs-params">    </span>) -&gt; Coroutine[Any, Any, R_T]:</span><br>        <span class="hljs-keyword">return</span> self._do_handle(key, func, args, kwargs)<br></code></pre></td></tr></table></figure><p>通过代码可以发现<code>Share</code>的主体逻辑非常简单，其中<code>_do_handle</code>的逻辑与第二节中的<code>share</code>函数类似，而新增的<code>do</code>方法只是<code>_do_handle</code>的一层封装，它在采用了<code>PEP-612</code>的类型标注后，使用者可以方便的从编辑器知道do的返回类型，接下来通过一段代码来检查<code>Share</code>是否正常，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">delay_return</span>(<span class="hljs-params">duration: <span class="hljs-built_in">int</span></span>) -&gt; int:</span><br>    <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">return</span> duration<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>() -&gt; <span class="hljs-keyword">None</span>:</span><br>    share = Share()<br>    task_list = [share.do(<span class="hljs-string">&quot;demo&quot;</span>, delay_return, (i, ))<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>)]<br>    done, _ = <span class="hljs-keyword">await</span> asyncio.wait(task_list)<br>    print([future.result() <span class="hljs-keyword">for</span> future <span class="hljs-keyword">in</span> done])<br><br><br>asyncio.run(main())<br></code></pre></td></tr></table></figure><p>在运行代码后输出如下（值可能不同）:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">[3, 3, 3, 3, 3, 3, 3, 3, 3, 3] <br></code></pre></td></tr></table></figure><p>通过结果可以发现<code>Share</code>运行正常，毕竟它的实现逻辑与<code>share</code>函数类似，但是当把鼠标移动到<code>task_list</code>上面可以发现，由于<code>do</code>方法采用了<code>PEP-612</code>的类型标注后，编辑器可以展示它的类型了，如下:<br><img    class="lazyload" data-original="https://fastly.jsdelivr.net/gh/so1n/so1n_blog_photo@master/blog_photo/16920949016431692094900746.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">share type hint.png</span></p><p>此外，基于<code>_do_handle</code>可以开发出一个装饰器，这样用起来就非常方便了，使用方法如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>() -&gt; <span class="hljs-keyword">None</span>:</span><br>    share = Share()<br><br><span class="hljs-meta">    @share.wrapper_do()</span><br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">delay_return</span>(<span class="hljs-params">duration: <span class="hljs-built_in">int</span></span>) -&gt; int:</span><br>        <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> duration<br><br>    task_list = [share.do(<span class="hljs-string">&quot;demo&quot;</span>, delay_return, (i, ))<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>)]<br>    done, _ = <span class="hljs-keyword">await</span> asyncio.wait(task_list)<br>    print([future.result() <span class="hljs-keyword">for</span> future <span class="hljs-keyword">in</span> done])<br><br><br>asyncio.run(main())<br></code></pre></td></tr></table></figure><blockquote><p>对应的实现方法见<a href="https://github.com/so1n/fast-tools/blob/master/fast_tools/share.py">源码</a></p></blockquote><h2 id="4-高并发下的问题"><a href="#4-高并发下的问题" class="headerlink" title="4.高并发下的问题"></a>4.高并发下的问题</h2><p>现在通过<code>Share</code>可以解决缓存击穿的问题了，但是与其他中间层一样，在引入<code>Share</code>之后会产生其他的严重的问题。</p><p>假设有这样一个场景，这个场景使用的DB系统有一个奇葩的Bug，这个Bug会导致每有1w次请求就有一个请求会被堵塞10秒，在未引入缓存击穿的保护逻辑之前，并不会有什么太大的影响，因为它的影响面很小，毕竟平均下来一个用户一天也就遇到几次，但是在引入缓存击穿保护的逻辑之后，就需要考虑这个问题对系统的影响了。<br>因为缓存击穿保护逻辑放行的请求在通过DB获取数据时，刚好遇到了Bug而堵塞了10秒，导致这个请求被堵住10秒后才能获取到值，这样会导致所有经过<code>Share</code>的请求在10秒内都被堵住，而这时影响面就非常大了。<br>首先它会影响到使用这个功能的所有接口在这10秒内这些功能无法使用，其次是这些请求会占用文件描述符和内存等资源，在占用过多时会影响其它服务的使用进而造成服务雪崩，为此需要对<code>Share</code>进行改进，防止单个请求异常而影响到其他地方的问题。</p><blockquote><p>使用<code>asyncio.wait</code>之类的带有超时异常机制的方法来执行也是可以的，因为<code>Python Asyncio</code>的异常传递性，无论是<code>asyncio.wait(share.do(xxx), timeout=xxx)</code>还是<code>share.do(asyncio.wait(xxx, timeout=xxx))</code>，第一个被放行的协程在执行超时后抛出的异常会传递给其他协程。</p></blockquote><h3 id="4-1-放行指定比例的请求"><a href="#4-1-放行指定比例的请求" class="headerlink" title="4.1.放行指定比例的请求"></a>4.1.放行指定比例的请求</h3><p>目前的<code>Share</code>只会允许第一个协程能被真正的执行，如果可以按照一定的几率放行请求，那么就能在防止请求堵住与降低DB压力之间做到一个平衡。具体的代码实现如下（只列出变更的方法）:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Share</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, rate: Optional[Tuple[<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>]] = <span class="hljs-literal">None</span></span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        <span class="hljs-comment"># 当rate = (1, 100)时代表是百分之一</span><br>        <span class="hljs-comment"># 当rate = (1, 1000)时代表是千分之一</span><br>        <span class="hljs-keyword">if</span> rate <span class="hljs-keyword">and</span> rate[<span class="hljs-number">0</span>] &gt; rate[<span class="hljs-number">1</span>]:<br>            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">f&quot;rate[0] should less than rate[1], but <span class="hljs-subst">&#123;rate[<span class="hljs-number">0</span>]&#125;</span> &gt; <span class="hljs-subst">&#123;rate[<span class="hljs-number">1</span>]&#125;</span>&quot;</span>)<br>        self._rate: Optional[Tuple[<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>]] = rate<br>        self._token_dict: Dict[_ShareKeyType, Token] = <span class="hljs-built_in">dict</span>()<br>    <br>    ...<br><br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_do_handle</span>(<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">        self, key: _ShareKeyType, func: Callable[P, Coroutine[Any, Any, R_T]], args: P.args, kwargs: P.args</span></span><br><span class="hljs-function"><span class="hljs-params">    </span>) -&gt; R_T:</span><br>        token: Token = self._get_token(key)<br>        <span class="hljs-keyword">try</span>:<br>            can_do = token.can_do()<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> can_do <span class="hljs-keyword">and</span> self._rate:<br>                can_do = random.randint(self._rate[<span class="hljs-number">0</span>], self._rate[<span class="hljs-number">1</span>]) == self._rate[<span class="hljs-number">0</span>]<br>            <span class="hljs-keyword">if</span> can_do:<br>                <span class="hljs-keyword">try</span>:<br>                    <span class="hljs-comment"># 多个请求也无所谓，Token会确保只有一个请求执行</span><br>                    token.set_result(<span class="hljs-keyword">await</span> func(*(args <span class="hljs-keyword">or</span> ()), **(kwargs <span class="hljs-keyword">or</span> &#123;&#125;)))<br>                <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>                    token.set_result(e)<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> token.await_done()<br>        <span class="hljs-keyword">finally</span>:<br>            self._token_dict.pop(key, <span class="hljs-literal">None</span>)<br></code></pre></td></tr></table></figure><p>代码中<code>Share</code>在<code>__init__</code>方法添加了一个新的参数<code>rate</code>，并在<code>_do_handle</code>方法中使用到，新的<code>_do_handle</code>方法除了会放行第一个协程外，其他的协程会通过<code>rate</code>来决定是否放行，具体的逻辑是调用者在通过<code>Share</code>的<code>_do_handle</code>执行协程时，<code>_do_handle</code>在判断不允许放行后会使用<code>random</code>模块根据<code>rate</code>生成一个随机数，如果生成的随机数与<code>rate[0]</code>相等时就会放行请求，现在改进第三节的测试代码以便验证<code>rate</code>的效果，具体代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">delay_return</span>(<span class="hljs-params">duration: <span class="hljs-built_in">int</span></span>) -&gt; int:</span><br>    <span class="hljs-comment"># 由于结果只有一个，所以需要打印出来才能判断是否有多个协程被放行</span><br>    print(<span class="hljs-string">f&quot;I go it, <span class="hljs-subst">&#123;duration&#125;</span>&quot;</span>)<br>    <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">return</span> duration<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>() -&gt; <span class="hljs-keyword">None</span>:</span><br>    <span class="hljs-comment"># 设置有1/3的放行概率</span><br>    share = Share(rate=(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>))<br>    task_list = [share.do(<span class="hljs-string">&quot;demo&quot;</span>, delay_return, (i, ))<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>)]<br>    done, _ = <span class="hljs-keyword">await</span> asyncio.wait(task_list)<br>    print([future.result() <span class="hljs-keyword">for</span> future <span class="hljs-keyword">in</span> done])<br><br><br>asyncio.run(main())<br></code></pre></td></tr></table></figure><p>在运行程序后一般会看到有多条<code>I go it, xxx</code>的文本输出，如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">I go it, 2<br>I go it, 1<br>I go it, 6<br>I go it, 3<br>[2, 2, 2, 2, 2, 2, 2, 2, 2, 2]<br></code></pre></td></tr></table></figure><p>通过输出也可以看到经过<code>Share</code>的处理后，所有协程获取到的结果还是取决于第一个协程执行的结果，但是确实有4个协程得到了执行了，这样一来即使有第个协程被堵住，其他协程也能够正常执行。</p><p>除了自动的按照一定比例放行协程的执行外，<code>Share</code>还有两个方法可以手动放行协程的执行，调用者只需要自己根据业务场景在恰当的时间调用对应的方法也可以解决高并发下由于引入<code>Share</code>而引发的问题。</p><blockquote><p>比如每隔n秒钟执行一次。</p></blockquote><h3 id="4-2-取消被堵住的请求"><a href="#4-2-取消被堵住的请求" class="headerlink" title="4.2.取消被堵住的请求"></a>4.2.取消被堵住的请求</h3><p><code>Token</code>底层的<code>asyncio.Future</code>拥有一个<code>cancel</code>的方法，通过调用<code>cancel</code>方法后不仅可以取消<code>Future</code>还可以把取消异常传递给<code>Future</code>对应的协程，进而中断协程的运行。</p><blockquote><p>对于取消机制和<code>asyncio.Future</code>可以参考:</p><ul><li><a href="https://so1n.me/2023/03/25/python_asyncio_lib_cancel">Python Asyncio 库之从ChatGPT Bug了解Cancel机制</a></li><li><a href="https://so1n.me/2022/04/11/python's_waitable_objects_in_asyncio/">Python的可等待对象在Asyncio的作用</a></li></ul></blockquote><p>于是可以通过这个方法使<code>Share</code>拥有取消被堵住的请求功能， 具体的改进逻辑是先在<code>Token</code>暴露出一个<code>cancel</code>的方法，这个方法会尽最大的能力取消可以被取消的<code>Future</code>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Token</span>(<span class="hljs-params">Generic[_Tp]</span>):</span><br>    ...<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">cancel</span>(<span class="hljs-params">self</span>) -&gt; bool:</span><br>        <span class="hljs-comment"># 如果future可以被取消，则尽最大的努力取消future</span><br>        <span class="hljs-keyword">if</span> self._future <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> self._future.done():<br>            <span class="hljs-keyword">if</span> self._future.cancelled():<br>                self._future.cancel()<br>            <span class="hljs-keyword">else</span>:<br>                self.set_result(asyncio.CancelledError())<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><p>不过<code>Token</code>只是<code>Future</code>的封装，调用者无法接触到<code>Token</code>，所以需要在<code>Share</code>添加一个<code>cancel</code>方法使调用者可以通过这个方法取消因<code>Share</code>影响的协程，从而释放资源占用，具体修改代码如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Share</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    ...<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">cancel</span>(<span class="hljs-params">self, key: Optional[_ShareKeyType] = <span class="hljs-literal">None</span></span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> key:<br>            <span class="hljs-comment"># 如果key为空，则取消所有相关token</span><br>            <span class="hljs-keyword">for</span> token <span class="hljs-keyword">in</span> self._token_dict.values():<br>                token.cancel()<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-comment"># 不为空则按照Key取消指定的token</span><br>            self._token_dict[key].cancel()<br><br></code></pre></td></tr></table></figure><p>修改完毕后编写一段代码进行验证：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> time<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">delay_print</span>(<span class="hljs-params">duration: <span class="hljs-built_in">int</span></span>) -&gt; int:</span><br>    <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">return</span> duration<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">cancel_in_aio</span>(<span class="hljs-params">share: <span class="hljs-string">&quot;Share&quot;</span></span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>    <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">0.1</span>)<br>    share.cancel()<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>() -&gt; <span class="hljs-keyword">None</span>:</span><br>    share = Share()<br>    task_list: <span class="hljs-string">&quot;List[Coroutine]&quot;</span> = [<br>        share.do(<span class="hljs-string">&quot;test_cancel_in_aio&quot;</span>, delay_print, args=[i]) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> [<span class="hljs-number">11</span>, <span class="hljs-number">12</span>, <span class="hljs-number">13</span>, <span class="hljs-number">14</span>, <span class="hljs-number">15</span>, <span class="hljs-number">16</span>, <span class="hljs-number">17</span>, <span class="hljs-number">18</span>, <span class="hljs-number">19</span>]<br>    ]<br>    <span class="hljs-comment"># 添加一个取消share所有token的操作</span><br>    task_list.append(cancel_in_aio(share))<br>    t_list = [asyncio.Task(t) <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> task_list]<br>    <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">1</span>)<br><br>    <span class="hljs-comment"># 统计有多少协程被取消</span><br>    result = []<br>    <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> t_list:<br>        <span class="hljs-comment"># 不统计`cancel_in_aio`</span><br>        <span class="hljs-comment"># 部分Python版本可能没有这个方法，需要注释掉，但是打印的结果会多出一个1</span><br>        <span class="hljs-keyword">if</span> t._coro.__name__ == <span class="hljs-string">&quot;cancel_in_aio&quot;</span>:  <span class="hljs-comment"># type: ignore</span><br>            <span class="hljs-keyword">continue</span><br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-keyword">await</span> t<br>            result.append(<span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">except</span> asyncio.CancelledError:<br>            result.append(<span class="hljs-number">0</span>)<br>    print(result)<br><br>asyncio.run(main())<br></code></pre></td></tr></table></figure><p>运行代码后可以看到输出结果如下，通过输出结果可以知道所有协程都被取消了:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">[0, 0, 0, 0, 0, 0, 0, 0, 0]<br></code></pre></td></tr></table></figure><h3 id="4-3-忘记被堵住的请求"><a href="#4-3-忘记被堵住的请求" class="headerlink" title="4.3.忘记被堵住的请求"></a>4.3.忘记被堵住的请求</h3><p>直接取消同一类请求也可能太狠了，它属于一个应急的方法，在业务场景中该操作可能导致多数用户在同一时间内都收到异常响应，为此<code>Share</code>还引入一个<code>forget</code>的功能，使<code>Share</code>能忘掉当前托管的<code>Token</code>，使后续的请求访问<code>Share</code>时，<code>Share</code>能够另起炉灶一个新的<code>Token</code>，这样一来新的请求被会之前的<code>Token</code>影响到。这个功能对应的改造很简单，只需要动到<code>Share</code>类，如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Share</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    ...<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">forget</span>(<span class="hljs-params">self, key: _ShareKeyType</span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        <span class="hljs-keyword">if</span> key <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> self._token_dict:<br>            <span class="hljs-keyword">raise</span> KeyError(<span class="hljs-string">f&quot;Token <span class="hljs-subst">&#123;key&#125;</span> not found&quot;</span>)<br>        token = self._token_dict[key]<br>        <span class="hljs-keyword">if</span> self._token_dict[key].is_done():<br>            <span class="hljs-keyword">raise</span> RuntimeError(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;token&#125;</span> is done&quot;</span>)<br>        self._token_dict.pop(key, <span class="hljs-literal">None</span>)<br></code></pre></td></tr></table></figure><p>接着在修改对应的老朋友–验证代码，如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">delay_return</span>(<span class="hljs-params">duration: <span class="hljs-built_in">int</span></span>) -&gt; int:</span><br>    <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">return</span> duration<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>() -&gt; <span class="hljs-keyword">None</span>:</span><br>    share = Share()<br>    a_task = asyncio.Task(asyncio.wait([share.do(<span class="hljs-string">&quot;demo&quot;</span>, delay_return, (i, ))<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>)]))<br>    <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">0.01</span>)<br>    share.forget(<span class="hljs-string">&quot;demo&quot;</span>)<br>    b_task = asyncio.Task(asyncio.wait([share.do(<span class="hljs-string">&quot;demo&quot;</span>, delay_return, (i, ))<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>)]))<br>    <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">0.1</span>)<br>    print(&#123;future.result() <span class="hljs-keyword">for</span> future <span class="hljs-keyword">in</span> (<span class="hljs-keyword">await</span> a_task)[<span class="hljs-number">0</span>]&#125;)<br>    print(&#123;future.result() <span class="hljs-keyword">for</span> future <span class="hljs-keyword">in</span> (<span class="hljs-keyword">await</span> b_task)[<span class="hljs-number">0</span>]&#125;)<br><br><br>asyncio.run(main())<br></code></pre></td></tr></table></figure><p>这段代码会执行两批协程，第一批返回的值只有可能是0-9,而第二批的值只有可能是10-19，它们的运行间隔只有0.01秒，但是运行时长是一样的。<br>此外，在执行第二批之前会先调用<code>share.forget(&quot;demo&quot;)</code>，使<code>Share</code>忘记了自己托管过第一批协程，在运行代码后可以看到如下输出:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">&#123;4&#125;<br>&#123;15&#125;<br></code></pre></td></tr></table></figure><p>通过输出可以发现，第一批协程执行时间与第二批协程执行的时间虽然是一样的，但是他们共享的是不同的结果，<code>Share</code>会正常的忘记掉第一批协程。</p><p>不过这个功能还是有点缺陷，假设第二批协程都能正常执行，但第一批协程还是因为被放行的协程在执行时被堵住而全都堵塞了，这是一种糟糕的情况。<br>大部分场景下都希望第二批协程执行完毕后，第一批协程也能共享到第一批协程的执行结果(被卡住的协程除外)，于是需要对<code>forget</code>的功能进行升级。<br>首先是<code>Token</code>的改造，<code>Token</code>需要在被<code>forget</code>后又能在下个协程调用时重新被<code>记</code>起来，改造的代码如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Token</span>(<span class="hljs-params">Generic[_Tp]</span>):</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, key: Any</span>):</span><br>        <span class="hljs-comment"># 标记Token是否处于被忘记</span><br>        self.is_forget = <span class="hljs-literal">False</span><br>        self._key: Any = key<br>        self._future: Optional[asyncio.Future[_Tp]] = <span class="hljs-literal">None</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">can_do</span>(<span class="hljs-params">self</span>) -&gt; bool:</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self._future:<br>            self._future = asyncio.Future()<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">if</span> self.is_forget:<br>            <span class="hljs-comment"># 如果该Token被忘记了，但是future还存在，那就重新记得Token，并放行该协程</span><br>            self.is_forget = <span class="hljs-literal">False</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>    <br>    ...<br></code></pre></td></tr></table></figure><p>接着就是<code>Share</code>的改造，主要是添加一个参数用于判断在调用<code>forget</code>时是否为强制<code>忘记</code>，代码如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Share</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">forget</span>(<span class="hljs-params">self, key: _ShareKeyType, force: <span class="hljs-built_in">bool</span> = <span class="hljs-literal">True</span></span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        <span class="hljs-comment"># 添加一个参数用于是否强制忘记</span><br>        <span class="hljs-keyword">if</span> key <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> self._token_dict:<br>            <span class="hljs-keyword">raise</span> KeyError(<span class="hljs-string">f&quot;Token <span class="hljs-subst">&#123;key&#125;</span> not found&quot;</span>)<br>        token = self._token_dict[key]<br>        <span class="hljs-keyword">if</span> self._token_dict[key].is_done():<br>            <span class="hljs-keyword">raise</span> RuntimeError(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;token&#125;</span> is done&quot;</span>)<br>        <span class="hljs-keyword">if</span> force:<br>            <span class="hljs-comment"># 如果是强制忘记则像之前一样移除Token</span><br>            self._token_dict.pop(key, <span class="hljs-literal">None</span>)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-comment"># 不是强制忘记则只标记Token的属性为忘记，等待重新被记起来</span><br>            token.is_forget = <span class="hljs-literal">True</span><br><br></code></pre></td></tr></table></figure><p>接着运行如下测试代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs Python">_is_first: <span class="hljs-built_in">bool</span> = <span class="hljs-literal">True</span><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">delay_return</span>(<span class="hljs-params">duration: <span class="hljs-built_in">int</span></span>) -&gt; int:</span><br>    <span class="hljs-keyword">global</span> _is_first<br>    <span class="hljs-keyword">if</span> _is_first:<br>        <span class="hljs-comment"># 第一个执行的协程耗费的时间会比较久一点</span><br>        _is_first = <span class="hljs-literal">False</span><br>        print(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;duration&#125;</span> is first&quot;</span>)<br>        <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">3</span>)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">return</span> duration<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>() -&gt; <span class="hljs-keyword">None</span>:</span><br>    share = Share()<br>    a_task = asyncio.Task(asyncio.wait([share.do(<span class="hljs-string">&quot;demo&quot;</span>, delay_return, (i, ))<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>)]))<br>    <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">0.01</span>)<br>    share.forget(<span class="hljs-string">&quot;demo&quot;</span>, force=<span class="hljs-literal">False</span>)<br>    b_task = asyncio.Task(asyncio.wait([share.do(<span class="hljs-string">&quot;demo&quot;</span>, delay_return, (i, ))<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>)]))<br>    <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">0.1</span>)<br>    <span class="hljs-comment"># a_task会执行比较久，所以先打印b_task</span><br>    print(&#123;future.result() <span class="hljs-keyword">for</span> future <span class="hljs-keyword">in</span> (<span class="hljs-keyword">await</span> b_task)[<span class="hljs-number">0</span>]&#125;, asyncio.get_event_loop().time())<br>    print(&#123;future.result() <span class="hljs-keyword">for</span> future <span class="hljs-keyword">in</span> (<span class="hljs-keyword">await</span> a_task)[<span class="hljs-number">0</span>]&#125;, asyncio.get_event_loop().time())<br><br><br>asyncio.run(main())<br></code></pre></td></tr></table></figure><p>然后可以在终端中看到如下输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">4 is first<br>&#123;12&#125; 291267.247258633<br>&#123;12&#125; 291269.238582831<br></code></pre></td></tr></table></figure><p>通过输出可以发现，4是最先执行的，但是最后<code>a</code>和<code>b</code>任务的结果都是12（第二批的值），同时第一批执行完毕的时间是比第二批晚了3秒钟。</p><h2 id="5-附录"><a href="#5-附录" class="headerlink" title="5.附录"></a>5.附录</h2><p><code>Share</code>对应的实现方法见<a href="https://github.com/so1n/fast-tools/blob/master/fast_tools/share.py">源码</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前记&quot;&gt;&lt;a href=&quot;#前记&quot; class=&quot;headerlink&quot; title=&quot;前记&quot;&gt;&lt;/a&gt;前记&lt;/h2&gt;&lt;p&gt;本文描述的是如何基于&lt;code&gt;Asyncio.Future&lt;/code&gt;的特性编写一个语言级别的防缓存击穿的工具–&lt;code&gt;Share&lt;/code&gt;，并介绍它的使用和高并发下的处理方法。&lt;/p&gt;</summary>
    
    
    <content src="https://fastly.jsdelivr.net/gh/so1n/so1n_blog_photo@master/blog_photo/1692114894425%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B8%8B%E9%98%B2%E6%AD%A2%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F--%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F.png" type="image"/>
    
    
    <category term="Python Asyncio" scheme="http://so1n.me/categories/Python-Asyncio/"/>
    
    
    <category term="Python" scheme="http://so1n.me/tags/Python/"/>
    
    <category term="Asyncio" scheme="http://so1n.me/tags/Asyncio/"/>
    
  </entry>
  
  <entry>
    <title>分布式锁(1)--分布式锁的简单实现</title>
    <link href="http://so1n.me/2023/07/23/distributed_lock_lntroduction_and_lmplementation/"/>
    <id>http://so1n.me/2023/07/23/distributed_lock_lntroduction_and_lmplementation/</id>
    <published>2023-07-23T15:33:18.000Z</published>
    <updated>2023-07-24T09:18:30.080Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前记"><a href="#前记" class="headerlink" title="前记"></a>前记</h2><p>随着业务的增长，后端技术架构会慢慢的从单体服务转向多服务或者微服务的分布式架构，此时语言级别的锁无法管理所有资源的竞争，只能采用分布式锁。而分布式锁的主体思想虽然与语言级别的锁类似，但还需要考虑到一些网络因素，使其变得复杂。</p><span id="more"></span><h2 id="1-为何需要分布式锁"><a href="#1-为何需要分布式锁" class="headerlink" title="1.为何需要分布式锁"></a>1.为何需要分布式锁</h2><p>举一个栗子，比如在做聊天服务时，需要统计一个聊天会话的在线人数，它的简单示例代码如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Counter</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, namespace: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        self.namespace: <span class="hljs-built_in">int</span> = namespace<br>        self.count: <span class="hljs-built_in">int</span> = <span class="hljs-number">0</span><br>    <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">login</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        self.count += <span class="hljs-number">1</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">logout</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        self.count -= <span class="hljs-number">1</span><br>    <br></code></pre></td></tr></table></figure><p>这份代码比较简单，它是每个<code>namespace</code>的全局计数器实现，每有一个用户成功登陆就会调用<code>login</code>方法使计数器+1，而每次退出就会调用<code>logout</code>方法使计数器-1。这个计数器看起来实现了需求，但是它也符合了最简单的线程不安全模型，意味着在多线程/进程等环境下无法得出正确的结果。</p><p>这个操作之所以线程不安全，是因为<code>self.count+=1</code>的这类操作不是原子性的，它在运行之前会被编译为<code>self.count = self.count + 1</code>，这是一个先更改再赋值的操作，实际在执行的时候CPU会分为下面三个步骤去执行:</p><ul><li>1.将count的值从内存读到CPU对应的寄存器上。</li><li>2.CPU操作寄存器上的count并进行+1操作。</li><li>3.把寄存器里的指写回内存中。</li></ul><p>这样在多线程/进程的场景下可能出现了CPU核心1和CPU核心2同时从内存读到对应值0，并放到了自己的寄存器上面，然后再对它进行+1操作，最后又把值(此时已经为1)写回到内存中，导致self.count的结果变为1而不是真正想要的值2了。</p><blockquote><ul><li>1.<code>self.count-=1</code>同理。</li><li>2.线程是操作系统的最小调度单位，在多核心系统时，会出现多核心同时调用线程去进行资源争夺。</li><li>3.Python 3.11做了优化，可能进行了几百次加减处理，结果也是对的。</li></ul></blockquote><p>这就是多线程环境对同一个资源竞争从而产生数据安全性的就问题，许多语言为了解决这个问题引入了锁机制，并使用锁机制保护了多线程环境下对同一个资源竞争的数据安全性。<br>开发者可以非常方便的通过锁机制给一些代码块加上锁从而使这些操作变成了原子性，比如对示例代码的<code>Counter</code>进行了如下修改:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">from</span> threading <span class="hljs-keyword">import</span> Lock<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Counter</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, namespace: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        self.namespace: <span class="hljs-built_in">int</span> = namespace<br>        self.count: <span class="hljs-built_in">int</span> = <span class="hljs-number">0</span><br><br>        self._lock: Lock = Lock()<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">login</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        <span class="hljs-keyword">with</span> lock():<br>            self.count += <span class="hljs-number">1</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">logout</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        <span class="hljs-keyword">with</span> lock():<br>            self.count -= <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>代码引入了<code>Lock</code>对象，并把它套在了资源冲突的<code>self.count+=1</code>和<code>self.count-=1</code>上面，使得线程只有持有锁的时候才能对<code>self.count</code>进行操作，而拿不到锁的线程则需要等待到获取锁才能继续操作，这样一来就不会产生多个线程同时操作一份数据而导致了结果不一致的问题。</p><p>不过现在的大多数服务不再是单体应用，更多的是以多服务，微服务的形式存在，这时上述的问题就会从不同的线程/进程争夺一个资源变为不同的机器上的服务对同一个资源进行竞争。<br>而语言级别的锁只存在于进程中，无法跨进程，只能管理自己进程里面的资源竞争，无法解决跨服务资源竞争的问题，只能使用一个带有锁机制的中间人来协调各个服务的资源竞争的问题，而这个中间人就是分布式锁。</p><h2 id="2-分布式锁的实现"><a href="#2-分布式锁的实现" class="headerlink" title="2.分布式锁的实现"></a>2.分布式锁的实现</h2><p>为了解决多服务，微服务的资源竞争这问题，分布式锁诞生了，分布式锁与语言级别的锁一样都是在某块空间打上标记，然后再通过打标记是否成功来判断是否获取锁，与语言级别锁唯一不同的是分布式锁需要通过网络进行通信，而网络是复杂的，这也就导致分布式锁的实现变得复杂。</p><p>为了降低分布式锁实现的复杂度，大多数分布式锁的方案都会基于拥有存储媒介和防止资源冲突的数据库进行开发，比如关系数据库<code>MySQL</code>，KV数据库<code>Redis</code>和<code>Etcd</code>等，它们都有一套逻辑来确保数据的一致性和可用性，同时也有一套完善的传输协议，这样就可以不去考虑网络传输的问题和数据冲突与丢失的问题，只专注分布式锁功能的实现了。<br>不过实际业务中需要分布式锁有较高的性能，所以大多数会分布式锁都会基于KV数据库开发，目前常用的分布式锁使用的KV数据库是<code>Redis</code>。 </p><h3 id="2-1-基于Redis的分布式锁"><a href="#2-1-基于Redis的分布式锁" class="headerlink" title="2.1.基于Redis的分布式锁"></a>2.1.基于Redis的分布式锁</h3><p><code>Redis</code>本质上就是使用一个单进程对一块内存进行读写（只考虑基本的读写），且每个操作都是以一个协程去操作内存，这保证了客户端提交的每个操作都是拥有原子性的。同时<code>Redis</code>还支持使用Lua脚本去编写复杂的操作，这两个特性组合起来意味着可以通过<code>Redis</code>实现出一个高性能且功能复杂的分布式锁。</p><p>在<code>Python</code>的<code>Redis</code>客户端库<code>py-redis</code>中，提供了一个简单的<code>Redis</code>锁封装，开发者通过这个封装可以很方便的使用基于<code>Redis</code>的分布式锁。如以上面计数器示例代码进行修改后的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> asyncio<br><span class="hljs-keyword">from</span> redis.asyncio <span class="hljs-keyword">import</span> Redis<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Counter</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, namespace: <span class="hljs-built_in">str</span>, redis: Redis</span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        self._redis = redis<br>        self.namespace: <span class="hljs-built_in">int</span> = namespace<br>        self.count: <span class="hljs-built_in">int</span> = <span class="hljs-number">0</span><br><br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">login</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> self._redis.lock(<span class="hljs-string">&quot;demo&quot;</span>):<br>            self.count += <span class="hljs-number">1</span><br><br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">logout</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> self._redis.lock(<span class="hljs-string">&quot;demo&quot;</span>):<br>            self.count -= <span class="hljs-number">1</span><br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    counter = Counter(<span class="hljs-string">&quot;demo&quot;</span>, Redis())<br>    <span class="hljs-keyword">await</span> counter.login()<br>    <span class="hljs-keyword">await</span> counter.logout()<br><br><br>asyncio.run(main())<br></code></pre></td></tr></table></figure><p>在这个示例代码中可以发现，锁的使用方法很简单，只要通过<code>redis.lock</code>方法就可以获取到分布式锁的实例，而这个锁实例的使用方法与<code>thread.Lock</code>类似，不用大改代码。</p><p>不过lock方法只是提供了一个简单的调用，实际上它返回的是符合如下函数签名的对象：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Lock</span>:</span><br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__aenter__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">pass</span><br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__aexit__</span>(<span class="hljs-params">self, exc_type, exc_value, traceback</span>):</span><br>        <span class="hljs-keyword">pass</span><br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">acquire</span>(<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">        self,</span></span><br><span class="hljs-function"><span class="hljs-params">        blocking: Optional[<span class="hljs-built_in">bool</span>] = <span class="hljs-literal">None</span>,</span></span><br><span class="hljs-function"><span class="hljs-params">        blocking_timeout: Optional[<span class="hljs-built_in">float</span>] = <span class="hljs-literal">None</span>,</span></span><br><span class="hljs-function"><span class="hljs-params">        token: Optional[Union[<span class="hljs-built_in">str</span>, <span class="hljs-built_in">bytes</span>]] = <span class="hljs-literal">None</span>,</span></span><br><span class="hljs-function"><span class="hljs-params">    </span>):</span><br>        <span class="hljs-keyword">pass</span><br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">locked</span>(<span class="hljs-params">self</span>) -&gt; bool:</span><br>        <span class="hljs-keyword">pass</span><br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">owned</span>(<span class="hljs-params">self</span>) -&gt; bool:</span><br>        <span class="hljs-keyword">pass</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">release</span>(<span class="hljs-params">self</span>) -&gt; Awaitable[<span class="hljs-keyword">None</span>]:</span><br>        <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure><p>这个对象拥有多个方法，首先是针对<code>async with</code>语法提供了<code>__aenter__</code>和<code>__aexit__</code>方法，它们分别在进入和离开<code>async with</code>语法块时被调用，它们的源码如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Lock</span>:</span><br>    ...<br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__aenter__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">await</span> self.acquire():<br>            <span class="hljs-keyword">return</span> self<br>        <span class="hljs-keyword">raise</span> LockError(<span class="hljs-string">&quot;Unable to acquire lock within the time specified&quot;</span>)<br><br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__aexit__</span>(<span class="hljs-params">self, exc_type, exc_value, traceback</span>):</span><br>        <span class="hljs-keyword">await</span> self.release()<br></code></pre></td></tr></table></figure><p>通过源码可以看到它们的实现很简单，<code>__aenter__</code>只调用<code>acquire</code>方法，如果返回<code>True</code>就允许进入代码块，如果返回<code>False</code>则抛出获取锁错误，而<code>__aexit__</code>则更简单，它只是调用<code>release</code>方法执行分布式锁的释放。</p><p>接下来就是<code>acquire</code>和<code>release</code>这两个分别代表获取锁和释放锁的核心方法了，其中<code>acquire</code>的源码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Lock</span>:</span><br>    ...<br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">acquire</span>(<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">        self,</span></span><br><span class="hljs-function"><span class="hljs-params">        blocking: Optional[<span class="hljs-built_in">bool</span>] = <span class="hljs-literal">None</span>,</span></span><br><span class="hljs-function"><span class="hljs-params">        blocking_timeout: Optional[<span class="hljs-built_in">float</span>] = <span class="hljs-literal">None</span>,</span></span><br><span class="hljs-function"><span class="hljs-params">        token: Optional[Union[<span class="hljs-built_in">str</span>, <span class="hljs-built_in">bytes</span>]] = <span class="hljs-literal">None</span>,</span></span><br><span class="hljs-function"><span class="hljs-params">    </span>):</span><br>        <span class="hljs-comment">################################</span><br>        <span class="hljs-comment"># 第一部分，这里主要是初始化各种参数 #</span><br>        <span class="hljs-comment">################################</span><br>        sleep = self.sleep<br>        <span class="hljs-keyword">if</span> token <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            token = uuid.uuid1().<span class="hljs-built_in">hex</span>.encode()<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">try</span>:<br>                encoder = self.redis.connection_pool.get_encoder()<br>            <span class="hljs-keyword">except</span> AttributeError:<br>                <span class="hljs-comment"># Cluster</span><br>                encoder = self.redis.get_encoder()<br>            token = encoder.encode(token)<br>        <span class="hljs-keyword">if</span> blocking <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            blocking = self.blocking<br>        <span class="hljs-keyword">if</span> blocking_timeout <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            blocking_timeout = self.blocking_timeout<br>        stop_trying_at = <span class="hljs-literal">None</span><br>        <span class="hljs-keyword">if</span> blocking_timeout <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            stop_trying_at = asyncio.get_running_loop().time() + blocking_timeout<br>        <span class="hljs-comment">#####################################################</span><br>        <span class="hljs-comment"># 第二部分，这里通过一个循环去争夺锁，在争夺成功时会返回True #</span><br>        <span class="hljs-comment">#####################################################</span><br>        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">await</span> self.do_acquire(token):<br>                <span class="hljs-comment"># 争夺成功，把Token存入当前线程存储中，并返回True</span><br>                self.local.token = token<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>            <span class="hljs-comment"># 争夺失败且设置blocking为False，则返回获取锁失败</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> blocking:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>            <span class="hljs-comment"># 在设置的时间内争夺失败，返回获取锁失败</span><br>            next_try_at = asyncio.get_running_loop().time() + sleep<br>            <span class="hljs-keyword">if</span> stop_trying_at <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> next_try_at &gt; stop_trying_at:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>            <span class="hljs-comment"># 每次争夺锁的间隔，这是在初始化Lock对象时指定的，</span><br>            <span class="hljs-comment"># 建议根据业务设置比较大的sleep时间，防止获取锁失败时频繁的与Redis通信。</span><br>            <span class="hljs-keyword">await</span> asyncio.sleep(sleep)<br><br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">do_acquire</span>(<span class="hljs-params">self, token: Union[<span class="hljs-built_in">str</span>, <span class="hljs-built_in">bytes</span>]</span>) -&gt; bool:</span><br>        <span class="hljs-keyword">if</span> self.timeout:<br>            <span class="hljs-comment"># convert to milliseconds</span><br>            timeout = <span class="hljs-built_in">int</span>(self.timeout * <span class="hljs-number">1000</span>)<br>        <span class="hljs-keyword">else</span>:<br>            timeout = <span class="hljs-literal">None</span><br>        <span class="hljs-comment"># 真正通过Redis设置锁的方法，</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">await</span> self.redis.<span class="hljs-built_in">set</span>(self.name, token, nx=<span class="hljs-literal">True</span>, px=timeout):<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><p>通过源码可以发现<code>acquire</code>方法主要是做三件事:</p><ul><li>1.初始化各种参数，其中token是采用uuid1生成的，该方法虽然会泄露主机信息，但它是能确保每个客户端生成的ID唯一且速度很快的方法，同时<code>Redis</code>一般都在内网运行的，只要能确保内网安全，一般也没啥事。</li><li>2.通过<code>do_acquire</code>方法去获取锁，当获取成功就会返回<code>True</code>，获取失败且设置不阻塞就返回<code>False</code>，而获取失败且设置阻塞就会通过循环去竞争锁。</li><li>3.获取锁的重点(do_acquire方法)，这里通过<code>Redis</code>的<code>set &lt;key&gt; &lt;value&gt; nx xxx ps xxx</code>的方法向Redis设置了一个K-V，并返回设置是否成功。这个命令是原子性的执行三个操作，从而保证获取锁的操作要么成功要么失败。 命令中的nx是确保Key不存在时且该命令能正常写入才返回<code>True</code>，而ps是设置了Key的过期时间，防止客户端假死或宕机而导致整个锁无法被释放（避免死锁的一种技术手段）。</li></ul><p>了解完获取锁<code>acquire</code>方法的执行原理后再看释放锁<code>release</code>方法的源码，由于<code>release</code>操作要多个操作，所以采用了Lua脚本，如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Lock</span>:</span><br>    ...<br>    <span class="hljs-comment"># 初始化时会初始化lua脚本--`LUA_RELEASE_SCRIPT`，</span><br>    <span class="hljs-comment"># 并把Redis返回的ID存放到lua_release中，减少后续调用的网络传输</span><br>    lua_release = <span class="hljs-literal">None</span><br>    <span class="hljs-comment"># lua脚本的逻辑是通过name获取token，如果token不存在或者不是实例产生的则返回0，</span><br>    <span class="hljs-comment"># 否则代表成功获取到锁，然后会执行删除锁并返回1告诉客户端说锁释放成功。</span><br>    LUA_RELEASE_SCRIPT = <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        local token = redis.call(&#x27;get&#x27;, KEYS[1])</span><br><span class="hljs-string">        if not token or token ~= ARGV[1] then</span><br><span class="hljs-string">            return 0</span><br><span class="hljs-string">        end</span><br><span class="hljs-string">        redis.call(&#x27;del&#x27;, KEYS[1])</span><br><span class="hljs-string">        return 1</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    ...<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">release</span>(<span class="hljs-params">self</span>) -&gt; Awaitable[<span class="hljs-keyword">None</span>]:</span><br>        <span class="hljs-comment"># 如果没有从本地线程存储获取到Token，则代表还没有获取到锁，抛出对应的异常</span><br>        expected_token = self.local.token<br>        <span class="hljs-keyword">if</span> expected_token <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">raise</span> LockError(<span class="hljs-string">&quot;Cannot release an unlocked lock&quot;</span>)<br>        <span class="hljs-comment"># 先清楚本地线程存放的Token，再释放锁</span><br>        self.local.token = <span class="hljs-literal">None</span><br>        <span class="hljs-keyword">return</span> self.do_release(expected_token)<br><br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">do_release</span>(<span class="hljs-params">self, expected_token: <span class="hljs-built_in">bytes</span></span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        <span class="hljs-comment"># 调用lua脚本并根据响应结果判断释放锁是否成功。</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">bool</span>(<br>            <span class="hljs-keyword">await</span> self.lua_release(<br>                keys=[self.name], args=[expected_token], client=self.redis<br>            )<br>        ):<br>            <span class="hljs-keyword">raise</span> LockNotOwnedError(<span class="hljs-string">&quot;Cannot release a lock that&#x27;s no longer owned&quot;</span>)<br></code></pre></td></tr></table></figure><p><code>release</code>也比较简单，它的整个逻辑是先通过本地线程存储中获取token，如果该值为空，则证明有可能没有执行<code>acquire</code>获取锁，需要抛出锁已经被释放的异常，如果不为空则置空，再通过<code>lua</code>脚本去释放锁，在释放锁时会校验token的值防止释放一个不是自己产生的锁。</p><p>此外，<code>Lock</code>中的token存放在本地线程存储的原因是为了防止多线程调用同个Loc实例导致的问题，如下：</p><ul><li>1.当A线程以timeout为30秒获取了锁。</li><li>2.B线程获取了锁，但是由于A已经获取了锁了，所以通过自旋进行等待。</li><li>3.A线程执行的逻辑超过30秒还未执行完成，而锁已经过期而被释放。</li><li>4.B线程发现锁已经被释放，开始获取锁并执行，最终在A线程执行完成之前运行完毕，并执行了释放锁的操作。</li><li>5.A线程执行了释放锁的操作，发现锁已经被释放了。</li></ul><p>可以看到这个方法只是防止动作没执行完，但锁却过期的一种情况，它并不能真正的解决问题，如果要真正的解决这个问题，则需要引入WatchDog机制。</p><h3 id="2-2-WatchDog实现"><a href="#2-2-WatchDog实现" class="headerlink" title="2.2.WatchDog实现"></a>2.2.WatchDog实现</h3><p><code>py-redis</code>的<code>Lock</code>对象支持<code>Timeout</code>参数，Timeout参数的作用是标记锁在被获取的n秒后被自动释放，这样加锁的程序即使崩溃了也能确保锁会在一定的时间后被释放，避免了死锁问题。<br>不过需要注意的是，Timeout参数就不能设置太长，如果设置太长，且程序在获取锁后崩溃而无法释放锁时，其他等待获取锁的程序会花时间进行无效的等待。<br>然而Timeout参数设置得太短也不行，如果程序的执行时间超过了Timeout设置的时间，那么就会出现程序还在运行着，但是锁却提前释放了，最终就会导致多个程序争夺同一个资源，也就是锁机制无效了。</p><p>由于Timeout参数设置太短太长都有问题，这意味着Timeout参数并不能完美的解决问题，这时就需要一个更好的机制–WatchDog来完善Timeout参数的不足。<br>WatchDog机制会在程序获取锁之后启动，在释放锁之前关闭，也就是跟随程序获取锁的行为一起运行，然后它会在程序执行期间按照一定的时间间隔帮锁自动续约(也就是增加锁的过期时间)，从而防止业务代码没执行完，锁却过期的情况。</p><p><code>py-redis</code>库的<code>Lock</code>追求的是简单的原则，它没有提供一套完整的WatchDog实现，但是提供了一个续约机制，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Lock</span>:</span><br>    <span class="hljs-comment"># 效果与lua_release一致 </span><br>    lua_extend = <span class="hljs-literal">None</span><br><br>    <span class="hljs-comment"># 续约的Lua代码主要逻辑为：</span><br>    <span class="hljs-comment"># 1.判断token是否一致，不一致则不是自己获取的锁，返回0。</span><br>    <span class="hljs-comment"># 2.判读锁的过期时间，如果小于0则锁不存在，返回0</span><br>    <span class="hljs-comment"># 3.如果当前锁的过期时间还未变为0,则为当前的锁续约</span><br>    <span class="hljs-comment">#   续约的方式有两种，一种是在原来的基础增加一个固定值，另一种是把过期时间设置为固定值。</span><br>    <span class="hljs-comment">#   最后再返回1，代表续约成功</span><br>    LUA_EXTEND_SCRIPT = <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        local token = redis.call(&#x27;get&#x27;, KEYS[1])</span><br><span class="hljs-string">        if not token or token ~= ARGV[1] then</span><br><span class="hljs-string">            return 0</span><br><span class="hljs-string">        end</span><br><span class="hljs-string">        local expiration = redis.call(&#x27;pttl&#x27;, KEYS[1])</span><br><span class="hljs-string">        if not expiration then</span><br><span class="hljs-string">            expiration = 0</span><br><span class="hljs-string">        end</span><br><span class="hljs-string">        if expiration &lt; 0 then</span><br><span class="hljs-string">            return 0</span><br><span class="hljs-string">        end</span><br><span class="hljs-string"></span><br><span class="hljs-string">        local newttl = ARGV[2]</span><br><span class="hljs-string">        if ARGV[3] == &quot;0&quot; then</span><br><span class="hljs-string">            newttl = ARGV[2] + expiration</span><br><span class="hljs-string">        end</span><br><span class="hljs-string">        redis.call(&#x27;pexpire&#x27;, KEYS[1], newttl)</span><br><span class="hljs-string">        return 1</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">extend</span>(<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">        self, additional_time: <span class="hljs-built_in">float</span>, replace_ttl: <span class="hljs-built_in">bool</span> = <span class="hljs-literal">False</span></span></span><br><span class="hljs-function"><span class="hljs-params">    </span>) -&gt; Awaitable[bool]:</span><br>        <span class="hljs-comment"># 判断是否持有锁，没有锁不能续约</span><br>        <span class="hljs-keyword">if</span> self.local.token <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">raise</span> LockError(<span class="hljs-string">&quot;Cannot extend an unlocked lock&quot;</span>)<br>        <span class="hljs-comment"># 没设置超时不能续约</span><br>        <span class="hljs-keyword">if</span> self.timeout <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">raise</span> LockError(<span class="hljs-string">&quot;Cannot extend a lock with no timeout&quot;</span>)<br>        <span class="hljs-keyword">return</span> self.do_extend(additional_time, replace_ttl)<br><br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">do_extend</span>(<span class="hljs-params">self, additional_time, replace_ttl</span>) -&gt; bool:</span><br>        <span class="hljs-comment"># 通过Lua脚本执行续约的逻辑</span><br>        additional_time = <span class="hljs-built_in">int</span>(additional_time * <span class="hljs-number">1000</span>)<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">bool</span>(<br>            <span class="hljs-keyword">await</span> self.lua_extend(<br>                keys=[self.name],<br>                args=[self.local.token, additional_time, replace_ttl <span class="hljs-keyword">and</span> <span class="hljs-string">&quot;1&quot;</span> <span class="hljs-keyword">or</span> <span class="hljs-string">&quot;0&quot;</span>],<br>                client=self.redis,<br>            )<br>        ):<br>            <span class="hljs-keyword">raise</span> LockNotOwnedError(<span class="hljs-string">&quot;Cannot extend a lock that&#x27;s no longer owned&quot;</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><p>它的逻辑非常简单，就是先校验当前是不是自己持有锁以及锁是否还在，当所有条件都满足时才续约，不过续约有两种方案，一种是把key的过期时间设置为指定的时间，另一种是在剩余的过期时间基础上再添加指定的时间。了解了<code>py-redis</code>提供的续约机制后，我们还需要考虑WatchDog剩余的逻辑，一个是什么时候开启/关闭WatchDog，另一个是如何制订WatchDog的执行周期。   </p><p>前面说到WatchDog会伴随着加锁一直运行着，那么意味着WatchDog会在加锁成功后开始运行，并在释放锁之前停止，在根据之前针对Lock的代码分析可以判断，WatchDog需要在<code>acquire</code>后开始运行，在<code>do_release</code>之前停止运行。<br>至于WatchDog的间隔时间，大部分框架都是采用用户定义Timeout时间的1/3，这是考虑到网络通信的不可靠以及防止发送太多请求而权衡的结果。</p><p>现在WatchDog的原理分析完毕，可以着手实现WatchDog了，WatchDog最终的代码实现如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> asyncio<br><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> Optional, Union<br><span class="hljs-keyword">from</span> redis.asyncio.lock <span class="hljs-keyword">import</span> Lock<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyLock</span>(<span class="hljs-params">Lock</span>):</span><br>    <span class="hljs-comment"># 存储循环的协程对象</span><br>    _watch_dog: Optional[asyncio.Task]<br><br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_watch</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        这是一个一直在循环的方法，它每次循环都会执行续约，然后休眠超时时间的1/3，然后再执行下一个循环。</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>            <span class="hljs-keyword">await</span> self.extend(self.timeout)<br>            <span class="hljs-keyword">await</span> asyncio.sleep(self.timeout / <span class="hljs-number">3</span>)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_cancel_watch_dog</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        取消正在运行WatchDog的协程</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        _old_watch_dog: Optional[asyncio.Future] = <span class="hljs-built_in">getattr</span>(self, <span class="hljs-string">&quot;_watch_dog&quot;</span>, <span class="hljs-literal">None</span>)<br>        <span class="hljs-keyword">if</span> _old_watch_dog <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> _old_watch_dog.cancelled():<br>            _old_watch_dog.cancel()<br><br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">acquire</span>(<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">        self,</span></span><br><span class="hljs-function"><span class="hljs-params">        blocking: Optional[<span class="hljs-built_in">bool</span>] = <span class="hljs-literal">None</span>,</span></span><br><span class="hljs-function"><span class="hljs-params">        blocking_timeout: Optional[<span class="hljs-built_in">float</span>] = <span class="hljs-literal">None</span>,</span></span><br><span class="hljs-function"><span class="hljs-params">        token: Optional[Union[<span class="hljs-built_in">str</span>, <span class="hljs-built_in">bytes</span>]] = <span class="hljs-literal">None</span>,</span></span><br><span class="hljs-function"><span class="hljs-params">    </span>) -&gt; bool:</span><br>        result = <span class="hljs-keyword">await</span> <span class="hljs-built_in">super</span>().acquire(blocking, blocking_timeout, token)<br>        <span class="hljs-keyword">if</span> result:<br>            <span class="hljs-comment"># 获取锁成功就开始启用WatchDog机制</span><br>            <span class="hljs-comment"># 它先把旧的WatchDog取消，再通过`asyncio.create_task`方法使用一个单独的协程执行WatchDog</span><br>            self._cancel_watch_dog()<br>            self._watch_dog = asyncio.create_task(self._watch())<br>        <span class="hljs-keyword">return</span> result<br><br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">do_release</span>(<span class="hljs-params">self, expected_token: <span class="hljs-built_in">bytes</span></span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        <span class="hljs-comment"># 在释放之前取消WatchDod机制</span><br>        <span class="hljs-comment"># 即使取消TachDog成功，但是锁释放失败也没关系，因为有超时机制兜底</span><br>        self._cancel_watch_dog()<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> <span class="hljs-built_in">super</span>().do_release(expected_token)<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__del__</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        <span class="hljs-keyword">try</span>:<br>            self._cancel_watch_dog()<br>        <span class="hljs-keyword">except</span> Exception:<br>            <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure><p>接着编写一个Demo文件来验证编写的WatchDog是否有效，Demo文件代码如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> asyncio<br><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> Optional, Union<br><span class="hljs-keyword">from</span> redis.asyncio.lock <span class="hljs-keyword">import</span> Lock<br><span class="hljs-keyword">from</span> redis.asyncio <span class="hljs-keyword">import</span> Redis<br><br><span class="hljs-comment"># WatchDog实现省略...</span><br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    _redis = Redis()<br>    s_t = time.time()<br>    <span class="hljs-comment"># pyredis的`lock`方法通过`lock_class`参数支持自定义Lock类</span><br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> _redis.lock(<span class="hljs-string">&quot;demo&quot;</span>, lock_class=MyLock, timeout=<span class="hljs-number">3</span>):<br>        print(<span class="hljs-string">&quot;lock&quot;</span>)<br>        <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">5</span>)<br>    print(<span class="hljs-string">&quot;ok&quot;</span>, time.time() - s_t)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    asyncio.run(main())<br></code></pre></td></tr></table></figure><p>然后在终端直接运行，会看到终端有如下输出:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">lock<br>ok 5.005310297012329<br></code></pre></td></tr></table></figure><p>通过输出可以发现，虽然锁设定的timeout参数为3秒，但是被锁住的代码能够正常的执行了5秒，也就代表WatchDog的实现是成功的。</p><blockquote><p>需要注意的是，协程的创建销毁成本很低，所以使用一个协程执行一个WatchDog，如果是在线程模型下，则不能使用一个单独的线程来执行WatchDog，这样会导致频繁的开启和关闭线程，建议使用一个线程池来管理所有锁的WatchDog的运行。不过WatchDog是每隔一段时间运行的，所以也可以使用时间轮+单独的Worker来执行WatchDog。</p></blockquote><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3.总结"></a>3.总结</h2><p>到目前为止，实现的分布式锁基本完备，也没有什么缺陷，同时它的性能也是非常高的。不过由于<code>py-redis</code>的锁实现比较简单，导致拓展性比较低，无法兼容部分场景，同时<code>py-redis</code>库并没有打算开发出包含更多功能的分布锁实现。这意味着开发者只能根据他提供的Lock对象进行重新开发，并通过<code>redis.lock</code>中的<code>lock_class</code>参数传递重新开发后的锁实现。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前记&quot;&gt;&lt;a href=&quot;#前记&quot; class=&quot;headerlink&quot; title=&quot;前记&quot;&gt;&lt;/a&gt;前记&lt;/h2&gt;&lt;p&gt;随着业务的增长，后端技术架构会慢慢的从单体服务转向多服务或者微服务的分布式架构，此时语言级别的锁无法管理所有资源的竞争，只能采用分布式锁。而分布式锁的主体思想虽然与语言级别的锁类似，但还需要考虑到一些网络因素，使其变得复杂。&lt;/p&gt;</summary>
    
    
    <content src="https://fastly.jsdelivr.net/gh/so1n/so1n_blog_photo@master/blog_photo/1690116367110distributed lock.jpg" type="image"/>
    
    
    <category term="分布式" scheme="http://so1n.me/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="Redis" scheme="http://so1n.me/tags/Redis/"/>
    
    <category term="分布式锁" scheme="http://so1n.me/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>Redis Scan命令踩坑笔记</title>
    <link href="http://so1n.me/2023/06/28/how_to_safe_user_redis_scan/"/>
    <id>http://so1n.me/2023/06/28/how_to_safe_user_redis_scan/</id>
    <published>2023-06-28T15:33:18.000Z</published>
    <updated>2023-07-05T09:01:18.163Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前记"><a href="#前记" class="headerlink" title="前记"></a>前记</h2><p>大部分人在接触Redis时就都会了解到Redis是以单线程的形式处理用户命令，导致O(N)的命令有极大的几率会阻塞Redis，所以在使用Redis时需要放弃一些O(n)命令的使用，比如不要去使用<code>KEYS</code>命令而应该使用<code>SCAN</code>命令，然而<code>SCAN</code>命令也有一些坑。</p><h2 id="1-踩到的坑"><a href="#1-踩到的坑" class="headerlink" title="1.踩到的坑"></a>1.踩到的坑</h2><p>为了减少<code>MySQL</code>的压力，在部分变动比较少的表会通过<code>Redis</code>套上缓存，如下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-meta">@cache(<span class="hljs-params">key_name=<span class="hljs-string">&quot;demo_system:user&quot;</span>, expire=<span class="hljs-number">10</span></span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_user</span>(<span class="hljs-params">user_id: <span class="hljs-built_in">str</span></span>) -&gt; UserDict:</span><br>    <span class="hljs-keyword">with</span> conn.cursor() <span class="hljs-keyword">as</span> cursor:<br>        cursor.execute(<span class="hljs-string">&quot;SELECT * FROM user WHERE user_id=%s&quot;</span>, (user_id, ))<br>        <span class="hljs-keyword">return</span> cursor.fetchone() <span class="hljs-keyword">or</span> ()<br></code></pre></td></tr></table></figure><p>这段代码中会有一个<code>cache</code>装饰器，它每次被调用时会把<code>key_name</code>与传入的参数绑定为一个Key，比如某次调用的参数<code>user_id</code>为10086时，生成的Key为<code>demo_system:user:10086</code>。<br>它在执行时会先去Redis检查一下该Key是否存在，如果存在就直接返回数据，如果不存在就进入<code>get_user</code>函数通过<code>MySQL</code>获取<code>user_id</code>为10086的数据，不过在返回数据10086的数据之前会先缓存到对应的Key中。</p><p>可见这个实现非常简单，也没有什么坑，但是当遇到需要按照模糊匹配批量删除缓存的需求时，问题也就跟着过来了，因为Redis本身并没有按照模糊匹配再批量删除的方法，只能先通过Redis的<code>KEYS</code>或者<code>SCAN</code>的模糊匹配查找一批Key，然后再通过<code>DEL</code>命令批量删除。<br>为了防止<code>Redis</code>阻塞，大都会选用<code>SCAN</code>来进行模糊匹配并通过<code>DEL</code>命令删除，使用起来也简单，代码如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">delete_cache_start_with</span>(<span class="hljs-params">cache_name: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>    <span class="hljs-string">&quot;&quot;&quot;根据前缀删除批量缓存&quot;&quot;&quot;</span><br>    cache_name += <span class="hljs-string">&quot;*&quot;</span><br>    cache_name_list = [item <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> redis.scan_iter(cache_name)]<br>    <span class="hljs-keyword">if</span> cache_name_list:<br>        redis.delete(*cache_name_list)<br><br>delete_cache_start_with(<span class="hljs-string">&quot;demo_system:user&quot;</span>)<br></code></pre></td></tr></table></figure><p>通过这段代码就可以批量删除与<code>demo_system:user</code>相关的Key了，在测试环境验证基本也不会出现问题，但是当上到生产环境时就会发现拥有批量删除逻辑的接口在某些情况下它的响应时长会变得很长，比如我在排查某个业务时看到的Jaeger数据如下图:<br><img    class="lazyload" data-original="https://fastly.jsdelivr.net/gh/so1n/so1n_blog_photo@master/blog_photo/1688110959832%E6%88%AA%E5%9B%BE_%E9%80%89%E6%8B%A9%E5%8C%BA%E5%9F%9F_20230629142027.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">1688110959832截图_选择区域_20230629142027.png</span></p><p>图中展示的是本次调用执行了多次<code>SCAN</code>命令，同时通过捕获的命令也可以知道<code>SCAN</code>的索引是一直在变的，而且不会重复，这意味着<code>SCAN</code>的执行逻辑是正常的，但是需要执行很多次才能获得最终的结果，所以导致接口的响应时长非常的长。</p><h2 id="2-解决方案"><a href="#2-解决方案" class="headerlink" title="2.解决方案"></a>2.解决方案</h2><p>当前的问题是当Redis的Key数量过多时，<code>SCAN</code>的扫描次数也变多了，导致服务需要向Redis发起多次IO交互，而每一次IO交互都需要一定的时间开销，最终导致接口响应时长变长， 所以解决这个问题的核心就变为在每次执行批量删除时尽量的减少<code>SCAN</code>命令次数(最终结果集不变的情况下)。</p><p>由于扫描次数是由<code>SCAN</code>命令中的<code>COUNT</code>大小和要扫描的Key总量这两个条件决定的，所以分别衍生出两套解决方案。</p><h3 id="2-1-修改COUNT参数"><a href="#2-1-修改COUNT参数" class="headerlink" title="2.1.修改COUNT参数"></a>2.1.修改COUNT参数</h3><p>如果代码中有大量依赖于<code>SCAN</code>命令且比较难更改的情况或者是代码中是使用了类似于<code>django.core.cache</code>的<code>cache.delete_pattern</code>封装函数，那么直接修改代码会非常麻烦，这时可以选择通过改大COUNT参数来减少<code>SCAN</code>命令的次数。</p><p>不过COUNT参数也不能太大，根据<a href="https://docs.keydb.dev/blog/2020/08/10/blog-post">KeyDB</a>中的描述在一个包含500万Key的Redis执行<code>SCAN</code>时，不同的COUNT参数与通过<code>SCAN</code>扫描所有Key的消耗时间的关系如下图:</p><p><img   class="lazyload" data-original="https://docs.keydb.dev/assets/images/scan_time_vs_count-8153069e42f3d752df0fcb16ca74d9b5.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" ></p><p>通过图可以看到，当COUNT大于1000时，通过<code>SCAN</code>扫码所有Key的消耗时间变化已经不是很大，但是我们也需要考虑COUNT过大时可能会对Redis的负载性能有影响，所以我们需要针对自己使用的Redis服务进行压测后，选择最适合当前Redis服务的<code>COUNT</code>(一般建议在100-1000之间)。</p><h3 id="2-2-创建一个存放缓存Key的Bucket"><a href="#2-2-创建一个存放缓存Key的Bucket" class="headerlink" title="2.2.创建一个存放缓存Key的Bucket"></a>2.2.创建一个存放缓存Key的Bucket</h3><p>由于缓存的Key的数量远远小于业务Key的数量，如果能做到只扫描缓存的Key而不是所有Key，那么<code>SCAN</code>命令执行的次数就会少了很多很多。<br>而这个解决方案就是通过创建一个单独的Bucket来存放缓存的Key，然后在模糊匹配时只扫描Bucket中的Key，最后在执行删除时除了删除业务Key外还需要同时删除Bucket中的Key。至于这个实现这个Bucket的方案有很多种，比如进程中的内存里或者一个公有文件中，但是Bucket的最佳实现还得是Redis的<code>SET</code>。</p><p>这个方案的实现最好是基于Redis客户端库再封装一层统一的调用，比如上面示例的<code>cache</code>装饰器，这个装饰器的核心逻辑如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-comment"># 省去装饰的逻辑</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_cache</span>(<span class="hljs-params">func: Callable, key: <span class="hljs-built_in">str</span></span>) -&gt; Any:</span><br>    result: Any = redis.get(key)<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> result:<br>        result = func()<br>        redis.<span class="hljs-built_in">set</span>(key, result)<br>    <span class="hljs-keyword">return</span> result<br></code></pre></td></tr></table></figure><p>它会先判断key是否存在Redis中，如果存在就直接返回，不存在则调用函数获取结果，再把结果存入Redis后并返回。</p><p>在进行改造时，只需要先指定Bucket的Key名，然后在调用<code>redis.set</code>时把缓存的key存入到Bucket中，如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Python">bucket_key: <span class="hljs-built_in">str</span> = <span class="hljs-string">&quot;demo_system:bucket&quot;</span><br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_cache</span>(<span class="hljs-params">func: Callable, key: <span class="hljs-built_in">str</span></span>) -&gt; Any:</span><br>    result: Any = redis.get(key)<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> result:<br>        result = func()<br>        redis.sadd(bucket_key, key)  <span class="hljs-comment"># &lt;-- 新增语句，为了保持双写成功，建议使用pipe，否则一定要放在set之前</span><br>        redis.<span class="hljs-built_in">set</span>(key, result)<br>    <span class="hljs-keyword">return</span> result<br></code></pre></td></tr></table></figure><p>然后删除的逻辑也需要修改，首先是把扫描Key从扫描Redis全局改为扫描Bucket，然后在删除Key时顺便把Key也从Bucket中移除，代码如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">delete_cache_start_with</span>(<span class="hljs-params">cache_name: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>    <span class="hljs-string">&quot;&quot;&quot;根据前缀删除批量缓存&quot;&quot;&quot;</span><br>    cache_name += <span class="hljs-string">&quot;*&quot;</span><br>    cache_name_list = [item <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> redis.sscan_iter(bucket_key, match=cache_name)]  <span class="hljs-comment"># &lt;--修改点</span><br>    <span class="hljs-keyword">if</span> cache_name_list:<br>        redis.delete(*cache_name_list)<br>        redis.srem(bucket_key, *cache_name_list)  <span class="hljs-comment"># &lt;--同样建议使用pipe，如果没有则必须放在delete后</span><br><br>delete_cache_start_with(<span class="hljs-string">&quot;demo_system:user&quot;</span>)<br></code></pre></td></tr></table></figure><p>这样一来就改造完成了，经过在线上跑了一段时间后，所有接口的响应时间并不会受删除Key的逻辑影响。</p><h2 id="3-其他注意点"><a href="#3-其他注意点" class="headerlink" title="3.其他注意点"></a>3.其他注意点</h2><p>在翻阅Redis关于<code>SCAN</code>命令的文档后发现有如下这一段描述:</p><blockquote><p>Scan guarantees<br>The SCAN command, and the other commands in the SCAN family, are able to provide to the user a set of guarantees associated to full iterations.</p><ul><li>A full iteration always retrieves all the elements that were present in the collection from the start to the end of a full iteration. This means that if a given element is inside the collection when an iteration is started, and is still there when an iteration terminates, then at some point SCAN returned it to the user.</li><li>A full iteration never returns any element that was NOT present in the collection from the start to the end of a full iteration. So if an element was removed before the start of an iteration, and is never added back to the collection for all the time an iteration lasts, SCAN ensures that this element will never be returned.<br>H</li><li>A given element may be returned multiple times. It is up to the application to handle the case of duplicated elements, for example only using the returned elements in order to perform operations that are safe when re-applied multiple times.</li></ul></blockquote><p>通过描述可以发现<code>SCAN</code>命令会保证扫描出在遍历开始之前就已经存在Redis的值，但是如果有一个值是在遍历开始之后才加入的，那么<code>SCAN</code>无法保证一定能被扫描出来，不过对于当前的删除缓存Key场景并没有什么影响。此外<code>SCAN</code>多次扫描的结果可能有重复的，需要我们在程序中把扫码的结果重新整理并去重。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前记&quot;&gt;&lt;a href=&quot;#前记&quot; class=&quot;headerlink&quot; title=&quot;前记&quot;&gt;&lt;/a&gt;前记&lt;/h2&gt;&lt;p&gt;大部分人在接触Redis时就都会了解到Redis是以单线程的形式处理用户命令，导致O(N)的命令有极大的几率会阻塞Redis，所以在使用Re</summary>
      
    
    
    <content src="https://fastly.jsdelivr.net/gh/so1n/so1n_blog_photo@master/blog_photo/16550442517731649661119526images.png" type="image"/>
    
    
    <category term="Redis" scheme="http://so1n.me/categories/Redis/"/>
    
    
    <category term="Redis" scheme="http://so1n.me/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Web框架的快速路由实现</title>
    <link href="http://so1n.me/2023/06/27/web_framwork-fast_route/"/>
    <id>http://so1n.me/2023/06/27/web_framwork-fast_route/</id>
    <published>2023-06-27T15:33:18.000Z</published>
    <updated>2023-06-29T18:05:36.238Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前记"><a href="#前记" class="headerlink" title="前记"></a>前记</h2><p>多功能的路由匹配是<code>Python</code>Web框架的一个特色，从<code>Django</code>，<code>Flask</code>框架开始，他们的路由匹配功能就非常丰富，它们基本上都允许Host匹配，重定向匹配以及其他正则匹配等使得用户可以添加他们大部分想要的路由规则，但也增加了路由匹配模块的复杂性和增加了路由匹配的时间消耗。</p><h2 id="1-Web框架高性能的秘密"><a href="#1-Web框架高性能的秘密" class="headerlink" title="1.Web框架高性能的秘密"></a>1.Web框架高性能的秘密</h2><p>目前<code>Python Asyncio</code>的Web框架百花齐放，每个框架都有自己的特色，但是它们的基础功能基本上都是相同的，但是由于它们在部分功能模块的实现有些不同，导致他们的性能表现各不相同，下图是<a href="http://klen.github.io/py-frameworks-bench/">py-frameworks-bench</a>提供的压测结果:</p><p><img    class="lazyload" data-original="https://fastly.jsdelivr.net/gh/so1n/so1n_blog_photo@master/blog_photo/16879623297911687962328974.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">16879623297911687962328974.png</span></p><p>通过压测结果可以把框架分类成三部分，第一部分是<code>Django</code>, <code>Quart</code>, <code>tornado</code>, <code>Aiohttp</code>这类比较老的框架，它们的压测结果都比较差，第二部分是<code>Starlette</code>和<code>Emmett</code>，它们的压测结果处于中等水平，而<code>Blacsheep</code>，<code>Sanic</code>这类框架的压测结果都是很高的。</p><p>在粗略的查看了他们的源码和设计说明后可以总结出他们性能差异的原因：</p><ul><li>1.对于老式框架<code>tornado</code>,<code>aiohttp</code>，他们并不支持ASGI，导致无法使用<code>uvicorn</code>等ASGI服务器，从而要自己去实现HTTP协议解析，而他们的HTTP协议解析是纯<code>Python</code>实现的，解析性能不如C实现的HTTP解析器强。</li><li>2.对于新式框架，他们的部分组件使用了<code>Cython</code>去编写，从而使这些组件获得了<code>C</code>一样的性能。</li><li>3.新式框架不再使用传统的路由匹配，而是改用路由树或者通过AST路由。</li></ul><p>如果再把上面的描述进一步提炼，就可以发现，目前的Web框架性能差异主要是在协议解析，路由匹配两个大模块上，其中协议解析是与使用的协议绑定的，所以针对HTTP的WEB框架再怎么改动都很难有提升，而路由匹配关心的是如何根据一个URL找到对应的路由，可定制性大。</p><h2 id="2-复杂的路由匹配"><a href="#2-复杂的路由匹配" class="headerlink" title="2.复杂的路由匹配"></a>2.复杂的路由匹配</h2><p>一般来说只要创建一个字典，然后把Url和路由绑定就可以完成一个速度极快又非常简单的路由匹配功能了，如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Python">route_dict = &#123;<br>    <span class="hljs-string">&quot;/&quot;</span>: index_route,<br>    <span class="hljs-string">&quot;/api/user&quot;</span>: user_route,<br>    <span class="hljs-string">&quot;/api/manager&quot;</span>: manager_route,<br>&#125;<br></code></pre></td></tr></table></figure><p>这种方式实现的路由匹配速度是非常快的（算法复杂度O(1)），但是在遇到不同的用户通过<code>/api/user/123</code>和<code>/api/user/345</code>等多个Url需要匹配同一个路由时，这个设计就有问题了，毕竟一个系统的用户数会很多，把它们对应的URL装进字典里并不是一件很实际的事，所以就需要通过另一种方案来实现路由匹配，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Python">route_list = [<br>    (<span class="hljs-string">&quot;/&quot;</span>, index_route),<br>    (<span class="hljs-string">&quot;/api/user/&lt;user_id&gt;&quot;</span>, user_route),<br>    (<span class="hljs-string">&quot;/api/manager&quot;</span>, manager_route),<br>]<br></code></pre></td></tr></table></figure><p>这种方案是把路由表从哈希字典改成一个数组，同时URL不再被规定为字符串，它也可以是正则表达式，然后在进行路由匹配时，就会遍历每个定义URL，如果发现访问的URL与定义的URL相等或者符合定义的URL正则表达式，那么就意味着匹配成功，这样一来只需要在路由表编写<code>/api/user/&lt;user_id&gt;</code>的映射关系就可以满足<code>/api/user/123</code>，<code>/api/user/345</code>等URL，路由表映射编写的便利性提升到了质的飞跃。</p><p>除了包含正则表达式的URL外，还有一些比较特殊的匹配需求，如域名匹配，简单的域名匹配路由表如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Python">route_list = [<br>    (<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;/&quot;</span>, index_route),<br>    (<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;/api/user/&lt;user_id&gt;&quot;</span>, user_route),<br>    (<span class="hljs-string">&quot;example.com&quot;</span>, <span class="hljs-string">&quot;/api/manager&quot;</span>, manager_route_1),<br>    (<span class="hljs-string">&quot;www.example.com&quot;</span>, <span class="hljs-string">&quot;/api/manager&quot;</span>, manager_route_2),<br>]<br></code></pre></td></tr></table></figure><p>在这种方案的路由表多了一个元素–域名，通过增加域名这个元素使其在路由匹配时会先检验当前的域名是否匹配，如果域名匹配成功了才会再去匹配第二项的路由URL，当域名和URL都完全匹配时才会去访问对应的路由。<br>比如<code>http://example.com/api/manager</code>会匹配到<code>manager_route_1</code>路由，而<code>http://www.example.com/api/manager</code>会匹配到<code>manager_route_2</code>路由。</p><blockquote><p>这里只做简单演示，实际上在使用时不会通过添加多一个元素来满足多一种条件的方式，具体可以通过<code>werkzeug</code>的<code>routing</code>源码了解。</p></blockquote><p>到现在位置，可以发现循环遍历匹配路由的实现非常简单，同时拓展起来也非常方便，这也就是<code>Django</code>，<code>Flask</code>，<code>Starlette</code>等流行的框架会采用遍历的方法来实现路由匹配的原因，但是随着而来的是路由匹配的算法复杂度从O(1)变为O(n)，这也意味着后面添加的路由被匹配的效率是很低的。</p><p>为了解决路由数组循环匹配的性能以及哈希匹配的拓展性都比较差的情况，很多人都在研究其他的路由匹配方法，比较出名的有路由前缀树和AST路由两种方案，在<a href="https://github.com/richardolsson/falcon-routing-survey">Falcon Routing Surver</a>中就测出了几种不同路由实现的性能，如下(其中省去几行不是关键的输出)：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash">----------------------------------------<br>BENCHMARKING ROUTER: tree_router<br>...<br>RESULT: 3.99470496178s (200000 iterations)<br>...<br>----------------------------------------<br>BENCHMARKING ROUTER: regex_router<br>...<br>RESULT: 8.51333618164s (200000 iterations)<br>...<br>----------------------------------------<br>BENCHMARKING ROUTER: compiled_router<br>...<br>RESULT: 0.957674980164s (200000 iterations)<br>...<br></code></pre></td></tr></table></figure><p>通过输出结果可以发现AST路由的速度是最快的，是路由数组的8倍，而路由前缀树方案的速度是路由数组的4倍。<br>不过，在AST路由和路由前缀树方案都带来了性能的提升同时，它们支持的路由匹配功能却少了一些。</p><h2 id="3-路由前缀树"><a href="#3-路由前缀树" class="headerlink" title="3.路由前缀树"></a>3.路由前缀树</h2><p>在制订URL的时候往往都是以/来划分层级的，比如下面的URL：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">/api/user/create<br>/api/user/delete<br>/api/user/&lt;user_id&gt;/info<br><br>/api/blog/list<br>/api/blog/content<br>/api/blog/comment<br><br>/internal/metric<br>/internal/info<br>/internal/health<br></code></pre></td></tr></table></figure><p>通过观察可以发现他们拥有共同的前缀，按照前缀的不同可以分为业务组–<code>/api/xxx</code>和内部接口组–<code>/internal/xxx</code>，而业务组可以细分用户组–<code>xxx/user/xxx</code>，博客组–<code>xxx/blog/xxx</code>。<br>现在就换个角度观察它们，先按<code>/</code>把URL切分成多个字符串，如<code>/api/user/create</code>可以被切分为<code>api</code>，<code>user</code>，<code>create</code>三个字符串，然后把他们按顺序排列并去掉重复的前缀，结果如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">api user create<br>         delete<br>         &lt;user_id&gt; info<br><br>    blog list<br>         content<br>         comment<br><br>internal metric<br>         info<br>         health<br></code></pre></td></tr></table></figure><p>然后再根据这个结果创建路由树，首先是创建<code>/</code>节点，然后按顺序把他们与上层节点连上，这样就形成一颗路由树了，如图:<br><img    class="lazyload" data-original="https://fastly.jsdelivr.net/gh/so1n/so1n_blog_photo@master/blog_photo/16880456728751688045672080.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">16880456728751688045672080.png</span></p><p>通过图可以发现路由树的构造与经典的数据结构<a href="https://zh.wikipedia.org/zh-cn/Trie">前缀树</a>类似，只不过前缀树是以每个字母为节点，而路由树是以<code>/</code>为根节点，并通过<code>/</code>切分URL形成多个子path，这些子path都为子节点。</p><p>了解前缀树的话会知道前缀树的一个优点是内存占用和查找性能都介于数组和哈希字典的中间，也就是不浪费空间占用，查找的复杂度也不是O(n)，比如在查找<code>/api/user/create</code>时，会先命中<code>/api</code>节点，然后再命中<code>/user</code>节点，最后再命中<code>create</code>节点，这个过程虽然会进行三次哈希查找，但是他的时间复杂度只能算是O(k) (k为树的层级)，远优于遍历队列查找的O(n)。</p><h3 id="3-1-路由前缀树的实现"><a href="#3-1-路由前缀树的实现" class="headerlink" title="3.1.路由前缀树的实现"></a>3.1.路由前缀树的实现</h3><p>了解了路由前缀树的原理后就可以着手实现路由前缀树了，路由前缀树的实现有很多种，这里演示的路由前缀树实现了最简单的路由匹配功能，同时它还支持与拥有正则的URL(只支持一个变量)绑定。</p><p>路由前缀树整个实现有三部分，首先是定义一个模拟路由，通过拓展它可以挂载路由函数，但这里这是一个简单的实现，所以只需要传入一个属性–<code>url</code>，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Route</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, url: <span class="hljs-built_in">str</span></span>):</span><br>        self.url: <span class="hljs-built_in">str</span> = url<br><br>        <span class="hljs-comment"># 用于后面匹配URL的正则表达式</span><br>        self.url_re = url<br>    <br>    <span class="hljs-comment"># 用于格式化打印</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__repr__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">f&quot;&lt;Route url=<span class="hljs-subst">&#123;self.url&#125;</span>&gt;&quot;</span><br></code></pre></td></tr></table></figure><p>然后在构造路由前缀树之前，需要构造路由前缀树的节点，该节点会以字典来存储子节点与自己的关系，同时为了支持类似<code>/api/user/&lt;user_id&gt;/info</code>带有正则的URL，节点需要存储对应的路由列表，同时存储当前正则表达式的变量名，代码如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RouteNode</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">        self,</span></span><br><span class="hljs-function"><span class="hljs-params">        route_list: Optional[List[Route]] = <span class="hljs-literal">None</span>,</span></span><br><span class="hljs-function"><span class="hljs-params">        node: Optional[Dict[<span class="hljs-built_in">str</span>, <span class="hljs-string">&quot;RouteNode&quot;</span>]] = <span class="hljs-literal">None</span>,</span></span><br><span class="hljs-function"><span class="hljs-params">    </span>):</span><br>        <span class="hljs-comment"># 当URL包含正则时，可能会绑定多个路由</span><br>        self.route_list: List[Route] = route_list <span class="hljs-keyword">if</span> route_list <span class="hljs-keyword">else</span> []<br>        <span class="hljs-comment"># 子节点与当前节点的映射关系</span><br>        self.node: Dict[<span class="hljs-built_in">str</span>, <span class="hljs-string">&quot;RouteNode&quot;</span>] = node <span class="hljs-keyword">if</span> node <span class="hljs-keyword">else</span> <span class="hljs-built_in">dict</span>()<br>        <span class="hljs-comment"># 如果当前的节点不是普通的字符串，而是正则表达式，那么就存储它的正则表达式的key名</span><br>        self.var_name: Optional[<span class="hljs-built_in">str</span>] = <span class="hljs-literal">None</span><br></code></pre></td></tr></table></figure><p>接着就可以实现路由前缀树了，一个简单的路由前缀树会有一个根节点，然后还拥有构造路由前缀树和通过路由前缀树查询的功能，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RouteTrie</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        <span class="hljs-comment"># 构造树的根节点</span><br>        self.root_node: <span class="hljs-string">&quot;RouteNode&quot;</span> = RouteNode()<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">insert</span>(<span class="hljs-params">self, route: Route</span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        <span class="hljs-string">&quot;&quot;&quot;向路由树插入节点的功能&quot;&quot;&quot;</span><br>        cur_node: <span class="hljs-string">&quot;RouteNode&quot;</span> = self.root_node<br>        <span class="hljs-keyword">for</span> node_url <span class="hljs-keyword">in</span> route.url.strip().split(<span class="hljs-string">&quot;/&quot;</span>):<br>            <span class="hljs-comment"># 按/拆分URL</span><br>            <span class="hljs-keyword">if</span> node_url <span class="hljs-keyword">and</span> <span class="hljs-string">&quot;&lt;&quot;</span> == node_url[<span class="hljs-number">0</span>] <span class="hljs-keyword">and</span> <span class="hljs-string">&quot;&gt;&quot;</span> == node_url[-<span class="hljs-number">1</span>]:<br>                <span class="hljs-comment"># 如果属于正则的URL就存储变量名，并替换url，方便后面通过正则匹配</span><br>                cur_node.var_name = node_url[<span class="hljs-number">1</span>:-<span class="hljs-number">1</span>]<br>                route.url_re = route.url_re.replace(node_url, <span class="hljs-string">&quot;(\w+)&quot;</span>)<br>                <span class="hljs-keyword">break</span><br>            <span class="hljs-keyword">elif</span> node_url <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> cur_node.node:<br>                <span class="hljs-comment"># 如果是普通的URL则构建子节点并与自己建立映射关系</span><br>                cur_node.node[node_url] = RouteNode()<br>            cur_node = cur_node.node[node_url]<br>        <span class="hljs-comment"># 为当前节点绑定路由</span><br>        cur_node.route_list.append(route)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_search_node</span>(<span class="hljs-params">self, url_path: <span class="hljs-built_in">str</span></span>) -&gt; Tuple[RouteNode, Dict]:</span><br>        <span class="hljs-string">&quot;&quot;&quot;通过路由树查找节点&quot;&quot;&quot;</span><br>        cur_node = self.root_node<br>        var_dict = &#123;&#125;<br>        <span class="hljs-keyword">for</span> url_node <span class="hljs-keyword">in</span> url_path.strip().split(<span class="hljs-string">&quot;/&quot;</span>):<br>            <span class="hljs-comment"># 按/拆分URL</span><br>            <span class="hljs-keyword">if</span> url_node <span class="hljs-keyword">in</span> cur_node.node:<br>                <span class="hljs-comment"># 对于普通路由则通过映射关系找到下一个节点</span><br>                cur_node = cur_node.node[url_node]<br>            <span class="hljs-keyword">elif</span> cur_node.var_name:<br>                <span class="hljs-comment"># 对于正则路由则附上变量的值</span><br>                var_dict[cur_node.var_name] = url_node<br>                <span class="hljs-keyword">break</span><br>        <span class="hljs-keyword">return</span> cur_node, var_dict<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">search</span>(<span class="hljs-params">self, url_path: <span class="hljs-built_in">str</span></span>) -&gt; Tuple[Optional[Route], Dict]:</span><br>        <span class="hljs-comment"># 根据URL查出对应的节点</span><br>        cur_node, var_dict = self._search_node(url_path)<br>        <span class="hljs-keyword">if</span> var_dict <span class="hljs-keyword">and</span> cur_node.route_list:<br>            <span class="hljs-comment"># 如果是带有正则的URL，需要遍历匹配每个路由</span><br>            <span class="hljs-keyword">for</span> route <span class="hljs-keyword">in</span> cur_node.route_list:<br>                <span class="hljs-keyword">if</span> re.match(route.url_re, url_path):<br>                    <span class="hljs-keyword">return</span> route, var_dict<br>        <span class="hljs-keyword">elif</span> cur_node.route_list:<br>            <span class="hljs-comment"># 如果是普通的URL，直接返回节点的第一个路由</span><br>            <span class="hljs-keyword">return</span> cur_node.route_list[<span class="hljs-number">0</span>], var_dict<br>        <span class="hljs-comment"># 如果当前节点并没有绑定路由，那么寻找失败</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>, var_dict<br></code></pre></td></tr></table></figure><p>这样一来，简单的路由前缀树就实现完成了，运行如下代码验证路由树是否正常实现，通过输出后可以发现路由前缀树能够正常的匹配到路由，同时也支持带有正则URL的变量生成：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs Python">route_trie = RouteTrie()<br>route_trie.insert(Route(<span class="hljs-string">&quot;/api/user/create&quot;</span>))<br>route_trie.insert(Route(<span class="hljs-string">&quot;/api/user/delete&quot;</span>))<br>route_trie.insert(Route(<span class="hljs-string">&quot;/api/user/&lt;user_id&gt;/info&quot;</span>))<br>route_trie.insert(Route(<span class="hljs-string">&quot;/api/blog/list&quot;</span>))<br>route_trie.insert(Route(<span class="hljs-string">&quot;/api/blog/content&quot;</span>))<br>route_trie.insert(Route(<span class="hljs-string">&quot;/api/blog/comment&quot;</span>))<br>route_trie.insert(Route(<span class="hljs-string">&quot;/internal/metric&quot;</span>))<br>route_trie.insert(Route(<span class="hljs-string">&quot;/internal/info&quot;</span>))<br>route_trie.insert(Route(<span class="hljs-string">&quot;/internal/health&quot;</span>))<br><br>print(route_trie.search(<span class="hljs-string">&quot;/api/user/create&quot;</span>))<br><span class="hljs-comment"># &gt;&gt;&gt; (&lt;Route url=/api/user/create&gt;, &#123;&#125;)</span><br>print(route_trie.search(<span class="hljs-string">&quot;/api/user/123&quot;</span>))<br><span class="hljs-comment"># &gt;&gt;&gt; (None, &#123;&#x27;user_id&#x27;: &#x27;123&#x27;&#125;)</span><br>print(route_trie.search(<span class="hljs-string">&quot;/api/user/123/info&quot;</span>))<br><span class="hljs-comment"># &gt;&gt;&gt; (&lt;Route url=/api/user/&lt;user_id&gt;/info&gt;, &#123;&#x27;user_id&#x27;: &#x27;123&#x27;&#125;)</span><br>print(route_trie.search(<span class="hljs-string">&quot;/internal/health&quot;</span>))<br><span class="hljs-comment"># &gt;&gt;&gt; (&lt;Route url=/internal/health&gt;, &#123;&#125;)</span><br></code></pre></td></tr></table></figure><p>路由树的查找速度会比路由数组的快，但是在实现支持包含正则的URL功能时，会发现路由–<code>Route</code>，路由树节点–<code>RouteNode</code>，路由树–<code>RouteTrie</code>这三点都需要进行改造，导致路由前缀树的开发成本比路由数组高。</p><blockquote><p>如果对路由树有兴趣，可以参考一些比较好的实现:</p><ul><li><a href="https://github.com/nitely/kua">https://github.com/nitely/kua</a></li><li><a href="https://github.com/vltr/xrtr">https://github.com/vltr/xrtr</a></li><li><a href="https://github.com/shiyanhui/Router">https://github.com/shiyanhui/Router</a></li></ul></blockquote><h2 id="4-AST路由"><a href="#4-AST路由" class="headerlink" title="4.AST路由"></a>4.AST路由</h2><p>AST路由是一种粗暴的解决方案，它在添加路由的时候也是构造一颗路由树，并在构造完路由树后遍历路由树并通过<code>Python</code>的动态能力有规则的生成含有大量<code>IF</code>语句的路由匹配代码，虽然生成的路由匹配代码比较丑，但是由于只含有<code>IF</code>逻辑，AST路由的匹配性能出奇的高。</p><blockquote><p>性能高的原因主要有两点:</p><ul><li>1.由于有规则的生成匹配逻辑，CPU在遇到IF时进行分支预测的准确性会大大提高，匹配的速度也得到提高，详见<a href="https://zhuanlan.zhihu.com/p/369942218">当 CPU 遇上 if 语句</a></li><li>2.<code>Python</code>的<code>For</code>语句性能比较差(相对于其他语言)，而AST路由是唯一没有<code>For</code>语句的路由匹配方案。</li></ul></blockquote><p>AST路由的实现比较复杂，所以直接采用<a href="https://github.com/richardolsson/falcon-routing-survey">falcon-routing-survey</a>的实现，如果有兴趣可以直接查看它的源码。<br><a href="https://github.com/richardolsson/falcon-routing-survey">falcon-routing-survey</a>封装的AST路由–<code>CompiledTreeRoute</code>的使用很简单，如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">from</span> routers.compiled <span class="hljs-keyword">import</span> CompiledTreeRouter<br><br><span class="hljs-comment"># 生成AST路由树</span><br>ctr = CompiledTreeRouter()<br><br><br><span class="hljs-comment"># 向路由树添加路由</span><br><span class="hljs-keyword">for</span> url <span class="hljs-keyword">in</span> [<br>    <span class="hljs-string">&quot;/api/user/create&quot;</span>,<br>    <span class="hljs-string">&quot;/api/user/delete&quot;</span>,<br>    <span class="hljs-string">&quot;/api/user/&#123;user_id&#125;/info&quot;</span>,  <span class="hljs-comment"># &lt; -- ctr支持的URL是&#123;user_id&#125;而不是&lt;user_id&gt;</span><br>    <span class="hljs-string">&quot;/api/blog/list&quot;</span>,<br>    <span class="hljs-string">&quot;/api/blog/content&quot;</span>,<br>    <span class="hljs-string">&quot;/api/blog/comment&quot;</span>,<br>    <span class="hljs-string">&quot;/internal/metric&quot;</span>,<br>    <span class="hljs-string">&quot;/internal/info&quot;</span>,<br>    <span class="hljs-string">&quot;/internal/health&quot;</span><br>]:<br>    ctr.add_route(url, <span class="hljs-keyword">lambda</span> : print(url))<br><br><span class="hljs-comment"># 匹配路由</span><br><span class="hljs-comment"># 第一次寻找路由时会通过路由树生成匹配逻辑代码，这里略</span><br>print(ctr.find_responder(<span class="hljs-string">&quot;/api/user/create&quot;</span>))<br><span class="hljs-comment"># (&lt;function &lt;lambda&gt; at 0x7f70299cf1e0&gt;, &#123;&#125;)</span><br>print(ctr.find_responder(<span class="hljs-string">&quot;/api/user/123&quot;</span>))<br><span class="hljs-comment"># (None, &#123;&#x27;user_id&#x27;: &#x27;123&#x27;&#125;)</span><br>print(ctr.find_responder(<span class="hljs-string">&quot;/api/user/123/info&quot;</span>))<br><span class="hljs-comment"># (&lt;function &lt;lambda&gt; at 0x7f702980af28&gt;, &#123;&#x27;user_id&#x27;: &#x27;123&#x27;&#125;)</span><br>print(ctr.find_responder(<span class="hljs-string">&quot;/internal/health&quot;</span>))<br><span class="hljs-comment"># (&lt;function &lt;lambda&gt; at 0x7f702980e488&gt;, &#123;&#125;)</span><br>print(ctr.find_responder(<span class="hljs-string">&quot;/internal/health&quot;</span>)[<span class="hljs-number">0</span>]())<br><span class="hljs-comment"># &quot;/internal/health&quot;</span><br></code></pre></td></tr></table></figure><p>代码中通过<code>add_route</code>向路由树绑定了URL和路由，然后使用<code>find_responder</code>通过URL寻找路由，可以看到它除了支持普通URL的路由匹配外，也支持含有正则的URL路由匹配，而负责路由匹配的逻辑代码则是在第一次调用<code>find_responder</code>时生成的，这次运行时生成的代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">find</span>(<span class="hljs-params">path, responders, expressions, params</span>):</span><br>  path_len = <span class="hljs-built_in">len</span>(path)<br>  <span class="hljs-keyword">if</span> path_len &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> path[<span class="hljs-number">0</span>] == <span class="hljs-string">&quot;api&quot;</span>:<br>    <span class="hljs-keyword">if</span> path_len &gt; <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> path[<span class="hljs-number">1</span>] == <span class="hljs-string">&quot;user&quot;</span>:<br>      <span class="hljs-keyword">if</span> path_len &gt; <span class="hljs-number">2</span> <span class="hljs-keyword">and</span> path[<span class="hljs-number">2</span>] == <span class="hljs-string">&quot;create&quot;</span>:<br>        <span class="hljs-keyword">return</span> responders[<span class="hljs-number">0</span>]<br>      <span class="hljs-keyword">if</span> path_len &gt; <span class="hljs-number">2</span> <span class="hljs-keyword">and</span> path[<span class="hljs-number">2</span>] == <span class="hljs-string">&quot;delete&quot;</span>:<br>        <span class="hljs-keyword">return</span> responders[<span class="hljs-number">1</span>]<br>      <span class="hljs-keyword">if</span> path_len &gt; <span class="hljs-number">2</span>:<br>        params[<span class="hljs-string">&quot;user_id&quot;</span>] = path[<span class="hljs-number">2</span>]<br>        <span class="hljs-keyword">if</span> path_len &gt; <span class="hljs-number">3</span> <span class="hljs-keyword">and</span> path[<span class="hljs-number">3</span>] == <span class="hljs-string">&quot;info&quot;</span>:<br>          <span class="hljs-keyword">return</span> responders[<span class="hljs-number">2</span>]<br>    <span class="hljs-keyword">if</span> path_len &gt; <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> path[<span class="hljs-number">1</span>] == <span class="hljs-string">&quot;blog&quot;</span>:<br>      <span class="hljs-keyword">if</span> path_len &gt; <span class="hljs-number">2</span> <span class="hljs-keyword">and</span> path[<span class="hljs-number">2</span>] == <span class="hljs-string">&quot;list&quot;</span>:<br>        <span class="hljs-keyword">return</span> responders[<span class="hljs-number">3</span>]<br>      <span class="hljs-keyword">if</span> path_len &gt; <span class="hljs-number">2</span> <span class="hljs-keyword">and</span> path[<span class="hljs-number">2</span>] == <span class="hljs-string">&quot;content&quot;</span>:<br>        <span class="hljs-keyword">return</span> responders[<span class="hljs-number">4</span>]<br>      <span class="hljs-keyword">if</span> path_len &gt; <span class="hljs-number">2</span> <span class="hljs-keyword">and</span> path[<span class="hljs-number">2</span>] == <span class="hljs-string">&quot;comment&quot;</span>:<br>        <span class="hljs-keyword">return</span> responders[<span class="hljs-number">5</span>]<br>  <span class="hljs-keyword">if</span> path_len &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> path[<span class="hljs-number">0</span>] == <span class="hljs-string">&quot;internal&quot;</span>:<br>    <span class="hljs-keyword">if</span> path_len &gt; <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> path[<span class="hljs-number">1</span>] == <span class="hljs-string">&quot;metric&quot;</span>:<br>      <span class="hljs-keyword">return</span> responders[<span class="hljs-number">6</span>]<br>    <span class="hljs-keyword">if</span> path_len &gt; <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> path[<span class="hljs-number">1</span>] == <span class="hljs-string">&quot;info&quot;</span>:<br>      <span class="hljs-keyword">return</span> responders[<span class="hljs-number">7</span>]<br>    <span class="hljs-keyword">if</span> path_len &gt; <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> path[<span class="hljs-number">1</span>] == <span class="hljs-string">&quot;health&quot;</span>:<br>      <span class="hljs-keyword">return</span> responders[<span class="hljs-number">8</span>]<br></code></pre></td></tr></table></figure><p>可以看到生成的代码虽然很长，但逻辑也很简单，都是匹配<code>path</code>的长度以及<code>path</code>的某一项的值等于什么，<br>同时通过生成代码的缩进可以发现，代码中的<code>IF</code>逻辑可以分为几部分，每部分恰好与按照URL区分的组类似，比如<code>api</code>和<code>internal</code>都是处于第一层，而<code>user</code>,<code>blog</code>处于<code>api</code>的下一层。</p><p>虽然AST路由的性能很快，但是每次新增功能也需要大量的改动，同时他是通过各种逻辑判断后才生成的代码，所以代码的易读性并不会很好，在改动逻辑前可能需要把生成的代码打印出来才能理顺，不过路由匹配本来就是一个稳定的功能，对于追求极致性能的框架都会采用AST路由来提升自己的性能，比如<code>Sanic</code>和<code>Falcon</code>，如果对AST路由感兴趣，可以通过如下URL:</p><ul><li><a href="https://github.com/sanic-org/sanic-routing/blob/main/sanic_routing/tree.py">https://github.com/sanic-org/sanic-routing/blob/main/sanic_routing/tree.py</a></li><li><a href="https://github.com/falconry/falcon/blob/master/falcon/routing/compiled.py">https://github.com/falconry/falcon/blob/master/falcon/routing/compiled.py</a></li></ul><p>分别访问<code>Sanic</code>和<code>Falcon</code>的路由源码查看他们的实现。</p><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5.总结"></a>5.总结</h2><p>路由组匹配，路由前缀树，AST路由它们三者的性能与简单性成反比，<br>在查阅资料后发现采纳不同的路由匹配方式与Web框架诞生的时代有一定的相关性。<br>目前采用路由组匹配的Web框架都是在Web1.0时代诞生的，而且都在路由组匹配上实现了很多小众的功能;<br>采用路由前缀树的Web框架则大部分都是近10年内诞生的Web框架，他们的作者根据URL的特性实现了路由前缀树来提升路由匹配的功能，同时由于路由前缀树在各大语言的Web框架都有实现，大家互相借鉴推动了路由前缀树的功能迭代（如很多框架在使用路由前缀树时会新增路由组功能），这使路由前缀树成为了路由匹配中的六边形战士。<br>而采用AST路由的都是在<code>Python</code>等动态语言中，诞生的比较晚且勇于尝试新事物和追求高性能的框架。</p><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p>其他参考链接</p><ul><li><code>Sanic</code>从路由组匹配改为AST路由的讨论 <a href="https://community.sanicframework.org/t/a-fast-new-router/649/10">https://community.sanicframework.org/t/a-fast-new-router/649/10</a></li><li><code>Quart</code>作者关于<code>Werkzeug</code>重新实现的路由描述 <a href="https://pgjones.dev/blog/faster-routing-2022/">https://pgjones.dev/blog/faster-routing-2022/</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前记&quot;&gt;&lt;a href=&quot;#前记&quot; class=&quot;headerlink&quot; title=&quot;前记&quot;&gt;&lt;/a&gt;前记&lt;/h2&gt;&lt;p&gt;多功能的路由匹配是&lt;code&gt;Python&lt;/code&gt;Web框架的一个特色，从&lt;code&gt;Django&lt;/code&gt;，&lt;code&gt;Flas</summary>
      
    
    
    <content src="https://fastly.jsdelivr.net/gh/so1n/so1n_blog_photo@master/blog_photo/16880456728751688045672080.png" type="image"/>
    
    
    <category term="Web框架" scheme="http://so1n.me/categories/Web%E6%A1%86%E6%9E%B6/"/>
    
    
    <category term="Web框架" scheme="http://so1n.me/tags/Web%E6%A1%86%E6%9E%B6/"/>
    
    <category term="路由" scheme="http://so1n.me/tags/%E8%B7%AF%E7%94%B1/"/>
    
  </entry>
  
  <entry>
    <title>Python Asyncio 协程对象开销成本</title>
    <link href="http://so1n.me/2023/05/29/python_asyncio_lib_overhead/"/>
    <id>http://so1n.me/2023/05/29/python_asyncio_lib_overhead/</id>
    <published>2023-05-29T15:33:18.000Z</published>
    <updated>2023-06-28T02:44:44.736Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前记"><a href="#前记" class="headerlink" title="前记"></a>前记</h2><p>最近看到一篇文章<a href="https://pkolaczk.github.io/memory-consumption-of-async/">《How Much Memory Do You Need to Run 1 Million Concurrent Tasks?》</a>,它介绍了不同语言在运行100万并发时的内存占用，文章列举了多种语言在不同并发环境下的内存占用，让我比较意外的是，在文章最后的结果看到了<code>Go</code>在100万并发时内存的占用比<code>Python</code>还高。<br>于是我很好奇一个<code>Python Asyncio</code>协程内存占用有多少，以及他的其他创建开销数据，处理性能等。</p><span id="more"></span><h2 id="1-创建协程的开销"><a href="#1-创建协程的开销" class="headerlink" title="1.创建协程的开销"></a>1.创建协程的开销</h2><blockquote><p>注：测试数据因电脑性能、<code>Python</code>版本区别有不同的差异，本次采用的<code>Python</code>环境为<code>Python3.8</code>。</p></blockquote><p>在<code>Python Asyncio</code>中，一个<code>asyncio.Task</code>就代表是一个协程，而<code>asyncio.ceate_task</code>是便捷的创建<code>asyncio.Task</code>的方法，所以只需要计算通过<code>asyncio.create_task</code>创建n个<code>asyncio.Task</code>需要耗费多少秒，就可以知道<code>Python Asyncio</code>创建协程的开销了。</p><p>首先测的是裸创建协程的数据，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> asyncio<br><span class="hljs-keyword">from</span> time <span class="hljs-keyword">import</span> process_time <span class="hljs-keyword">as</span> time<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">time_tasks</span>(<span class="hljs-params">count: <span class="hljs-built_in">int</span> =<span class="hljs-number">100</span></span>) -&gt; float:</span><br><br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">nop_task</span>() -&gt; <span class="hljs-keyword">None</span>:</span><br>        <span class="hljs-keyword">pass</span><br><br>    start = time()<br>    <span class="hljs-comment"># 创建一批asyncio.Task</span><br>    tasks = [asyncio.create_task(nop_task()) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(count)]<br>    <span class="hljs-comment"># 计算创建时间</span><br>    elapsed = time() - start<br>    <span class="hljs-comment"># 消费创建的asyncio.Task</span><br>    <span class="hljs-keyword">await</span> asyncio.gather(*tasks)<br>    <span class="hljs-keyword">return</span> elapsed<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>() -&gt; <span class="hljs-keyword">None</span>:</span><br>    <span class="hljs-keyword">for</span> count <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">100_000</span>, <span class="hljs-number">1000_000</span> + <span class="hljs-number">1</span>, <span class="hljs-number">100_000</span>):<br>        create_time = <span class="hljs-keyword">await</span> time_tasks(count)<br>        create_per_second = <span class="hljs-number">1</span> / (create_time / count)<br>        print(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;count:,&#125;</span> tasks \t <span class="hljs-subst">&#123;create_per_second:<span class="hljs-number">0</span>,<span class="hljs-number">.0</span>f&#125;</span> tasks per/s&quot;</span>)<br><br>asyncio.run(main())<br></code></pre></td></tr></table></figure><p>在我的电脑运行代码后得出的数据如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">100,000 tasks  163,661 tasks per/s<br>200,000 tasks  163,275 tasks per/s<br>300,000 tasks  163,771 tasks per/s<br>400,000 tasks  155,471 tasks per/s<br>500,000 tasks  169,313 tasks per/s<br>600,000 tasks  161,779 tasks per/s<br>700,000 tasks  128,751 tasks per/s<br>800,000 tasks  173,240 tasks per/s<br>900,000 tasks  182,140 tasks per/s<br>1,000,000 tasks  182,871 tasks per/s<br></code></pre></td></tr></table></figure><p>可以看到裸创建协程的性能还是ok的，这是由于<code>Python Asyncio</code>的协程是跑在一个线程上的用户级别协程，不需要跟操作系统交互，所以裸创建的协程性能会比较高。</p><p>不过这是在<code>Python Asyncio</code>环境比较干净的情况下跑出来的数据，如果移除掉<code>time_tasks</code>函数中的<code>await asyncio.gather(*tasks)</code>，就会每一轮测试后<code>Python Asyncio</code>中还存在一些未跑完的<code>asyncio.Task</code>，这些<code>asyncio.Task</code>会的运行会影响到测试的准确度，导致下一轮测试会比较慢了，具体数据如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">100,000 tasks  183,077 tasks per/s<br>200,000 tasks  132,444 tasks per/s<br>300,000 tasks  130,042 tasks per/s<br>400,000 tasks  139,849 tasks per/s<br>500,000 tasks  196,590 tasks per/s<br>600,000 tasks  139,296 tasks per/s<br>700,000 tasks  169,764 tasks per/s<br>800,000 tasks  151,947 tasks per/s<br>900,000 tasks  154,378 tasks per/s<br>1,000,000 tasks  147,910 tasks per/s<br></code></pre></td></tr></table></figure><p>除了裸创建协程的开销这个指标外，还有一个比较重要的指标就是<code>Python Asyncio</code>能同时处理多少个协程。不过要做这个测试会比较困难，但是把指标改为一秒能处理多少个协程后进行测试就比较简单了，改动方法非常简单，只需要移动下<code>await asyncio.gather(*tasks)</code>的位置即可，代码如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> asyncio<br><span class="hljs-keyword">from</span> time <span class="hljs-keyword">import</span> process_time <span class="hljs-keyword">as</span> time<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">time_tasks</span>(<span class="hljs-params">count: <span class="hljs-built_in">int</span> =<span class="hljs-number">100</span></span>) -&gt; float:</span><br><br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">nop_task</span>() -&gt; <span class="hljs-keyword">None</span>:</span><br>        <span class="hljs-keyword">pass</span><br><br>    start = time()<br>    tasks = [asyncio.create_task(nop_task()) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(count)]<br>    <span class="hljs-keyword">await</span> asyncio.gather(*tasks)   <span class="hljs-comment"># &lt;--移动在elapsed之前</span><br>    elapsed = time() - start<br>    <span class="hljs-keyword">return</span> elapsed<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>() -&gt; <span class="hljs-keyword">None</span>:</span><br>    <span class="hljs-keyword">for</span> count <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">100_000</span>, <span class="hljs-number">1000_000</span> + <span class="hljs-number">1</span>, <span class="hljs-number">100_000</span>):<br>        create_time = <span class="hljs-keyword">await</span> time_tasks(count)<br>        create_per_second = <span class="hljs-number">1</span> / (create_time / count)<br>        print(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;count:,&#125;</span> tasks \t <span class="hljs-subst">&#123;create_per_second:<span class="hljs-number">0</span>,<span class="hljs-number">.0</span>f&#125;</span> tasks per/s&quot;</span>)<br><br>asyncio.run(main())<br></code></pre></td></tr></table></figure><p>通过测试后发现，在我的电脑上<code>Python Asyncio</code>每秒能处理接近10w个协程，算还ok(在m1 pro跑的数据是我电脑的3倍)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">100,000 tasks  101,301 tasks per/s<br>200,000 tasks  85,196 tasks per/s<br>300,000 tasks  75,686 tasks per/s<br>400,000 tasks  90,694 tasks per/s<br>500,000 tasks  91,721 tasks per/s<br>600,000 tasks  90,821 tasks per/s<br>700,000 tasks  87,428 tasks per/s<br>800,000 tasks  84,583 tasks per/s<br>900,000 tasks  88,311 tasks per/s<br>1,000,000 tasks  102,782 tasks per/s<br></code></pre></td></tr></table></figure><p>不过<code>Asyncio</code>的性能只能算中规中矩，为了在生产环境下拥有更强的性能，大部分服务都会使用<code>uvloop</code>，所以也附上了在我电脑上跑<code>uvloop</code>的数据：</p><ul><li>1.裸跑创建<code>asyncio.Task</code><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">100,000 tasks  236,275 tasks per/s<br>200,000 tasks  175,045 tasks per/s<br>300,000 tasks  195,661 tasks per/s<br>400,000 tasks  190,515 tasks per/s<br>500,000 tasks  207,637 tasks per/s<br>600,000 tasks  203,315 tasks per/s<br>700,000 tasks  189,886 tasks per/s<br>800,000 tasks  161,822 tasks per/s<br>900,000 tasks  241,289 tasks per/s<br>1,000,000 tasks  216,428 tasks per/s<br></code></pre></td></tr></table></figure></li><li>2.裸跑创建<code>asyncio.Task</code>(每次开始时仍有未完成的<code>asyncio.Task</code>)<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">100,000 tasks  236,375 tasks per/s<br>200,000 tasks  157,874 tasks per/s<br>300,000 tasks  195,601 tasks per/s<br>400,000 tasks  163,596 tasks per/s<br>500,000 tasks  246,414 tasks per/s<br>600,000 tasks  161,369 tasks per/s<br>700,000 tasks  219,827 tasks per/s<br>800,000 tasks  200,722 tasks per/s<br>900,000 tasks  195,852 tasks per/s<br>1,000,000 tasks  161,363 tasks per/s<br></code></pre></td></tr></table></figure></li><li>3.每秒处理<code>asyncio.Task</code>能力:  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">100,000 tasks  138,045 tasks per/s<br>200,000 tasks  115,583 tasks per/s<br>300,000 tasks  122,949 tasks per/s<br>400,000 tasks  134,310 tasks per/s<br>500,000 tasks  125,624 tasks per/s<br>600,000 tasks  120,950 tasks per/s<br>700,000 tasks  123,622 tasks per/s<br>800,000 tasks  125,671 tasks per/s<br>900,000 tasks  116,234 tasks per/s<br>1,000,000 tasks  130,501 tasks per/s<br></code></pre></td></tr></table></figure></li></ul><p>通过上述结果可以看出，在使用<code>uvloop</code>后，三种测试方式的结果都优于<code>Python Asyncio</code>。</p><h2 id="2-内存占用"><a href="#2-内存占用" class="headerlink" title="2.内存占用"></a>2.内存占用</h2><p>一般情况下，为了测试程序的真正内存占用，会选择直接运行程序，然后在终端上通过命令查看程序的内存占用。不过好在<code>Python Asyncio</code>是在线程上运行的用户级别程序，<code>Python Asyncio</code>不会像线程一样每启动一个线程都需要一向系统申请单独的内存和上下文，这意味着可以通过<code>tracemalloc</code>快速的捕获到内存，<code>tramalloc</code>是<code>Python</code>的标准库中的模块，他能获取到内存的使用情况快照，使用方法非常简单，如下代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">demo</span>() -&gt; <span class="hljs-keyword">None</span>:</span><br>    tracemalloc.start()<br>    demo_dict = &#123;&#125;<br>    snapshot = tracemalloc.take_snapshot()<br>    total_bytes = <span class="hljs-built_in">sum</span>(stat.size <span class="hljs-keyword">for</span> stat <span class="hljs-keyword">in</span> snapshot.statistics(<span class="hljs-string">&#x27;lineno&#x27;</span>))<br>    print(total_bytes / <span class="hljs-number">1024.0</span>)<br></code></pre></td></tr></table></figure><p>这段代码需要捕获<code>demo_dict</code>占用了多少内存，于是会在<code>demo_dict</code>之前添加<code>tracemalloc.start()</code>,在<code>demo_dict</code>后面添加<code>tramallo.take_snapshot()</code>，然后就可以根据<code>shapshot.statistics</code>来统计<code>demo_dict</code>的内存占用了，具体使用方法可以查看<a href="https://docs.python.org/3/library/tracemalloc.html"><code>tracemalloc</code>文档</a>。</p><p>内存占用的统计工具已经找到了，现在就需要编写一个简单的协程函数，由于要防止出现部分协程还没有运行，其他协程已经执行完毕的情况，这个协程函数需要加上一点点料，如下，该函数会遍历10次，且每次都休眠时间为0.1秒：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sub_demo</span>() -&gt; <span class="hljs-keyword">None</span>:</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):<br>        <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">0.1</span>)<br></code></pre></td></tr></table></figure><p>接着就需要通过<code>asyncio.create_task</code>来创建运行<code>sub_demo</code>的<code>asyncio.Task</code>，并且使用<code>tracemalloc.start</code>来统计他们的内存使用:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">demo</span>() -&gt; <span class="hljs-keyword">None</span>:</span><br>    tracemalloc.start()<br>    tasks = [asyncio.create_task(sub_demo()) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(num)]<br>    snapshot = tracemalloc.take_snapshot()<br></code></pre></td></tr></table></figure><p>但是如果直接这样测试，会发现测试结果中平均每个协程的内存占用大约只有1kb左右，这是因为直接创建的<code>asyncio.Task</code>只是被初始化，还未被调度，所以占用的资源是比较少的，测出来的数据也是不准的。<br>为了解决这个问题，就需要在程序中添加<code>await asyncio.sleep(0)</code>这个最简单的让步方法，使创建的<code>asyncio.Task</code>可以被初始化，最终成品代码如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> asyncio<br><span class="hljs-keyword">import</span> tracemalloc<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sub_demo</span>() -&gt; <span class="hljs-keyword">None</span>:</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):<br>        <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">0.1</span>)<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">benchmark</span>(<span class="hljs-params">num: <span class="hljs-built_in">int</span></span>) -&gt; float:</span><br>    tracemalloc.start()<br>    tasks = [asyncio.create_task(sub_demo()) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(num)]<br>    <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">0</span>)<br>    snapshot = tracemalloc.take_snapshot()<br>    <span class="hljs-keyword">await</span> asyncio.wait(tasks)  <span class="hljs-comment"># 等待执行完成，防止影响到后面的其他测试</span><br>    total_bytes = <span class="hljs-built_in">sum</span>(stat.size <span class="hljs-keyword">for</span> stat <span class="hljs-keyword">in</span> snapshot.statistics(<span class="hljs-string">&#x27;lineno&#x27;</span>))<br>    <span class="hljs-keyword">return</span> total_bytes / <span class="hljs-number">1024.0</span><br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>() -&gt; <span class="hljs-keyword">None</span>:</span><br>    <span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> [<span class="hljs-number">2000</span>, <span class="hljs-number">5000</span>, <span class="hljs-number">10000</span>, <span class="hljs-number">50000</span>, <span class="hljs-number">100000</span>]:<br>        total_kb = <span class="hljs-keyword">await</span> benchmark(n)<br>        print(<span class="hljs-string">f&#x27;&gt; coroutines=<span class="hljs-subst">&#123;n:<span class="hljs-number">5</span>&#125;</span> used <span class="hljs-subst">&#123;total_kb:<span class="hljs-number">.3</span>f&#125;</span> K/b  per:<span class="hljs-subst">&#123;total_kb / n&#125;</span> K/b&#x27;</span>)<br><br><br>asyncio.run(main())<br></code></pre></td></tr></table></figure><p>运行代码后，可以看到随着生成<code>asyncio.Task</code>对象越多，平均每个<code>asyncio.Task</code>的内存占用越趋向于2K/b，这时可以简单的认为<code>Python Asyncio</code>创建的每个协程的内存占用约为2Kb</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">coroutines= 2000 used 4172.743 K/b  per:2.08637158203125 K/b<br>coroutines= 5000 used 10627.268 K/b  per:2.125453515625 K/b<br>coroutines=10000 used 20718.018 K/b  per:2.0718017578125 K/b<br>coroutines=50000 used 102878.197 K/b  per:2.0575639453125 K/b<br>coroutines=100000 used 205737.854 K/b  per:2.05737853515625 K/b<br></code></pre></td></tr></table></figure><h2 id="3-附录–解惑"><a href="#3-附录–解惑" class="headerlink" title="3.附录–解惑"></a>3.附录–解惑</h2><p>在<a href="https://go.dev/doc/go1.4#runtime">Go 1.4</a>发版说明中已经说了一个<code>Goroutine</code>的内存占用只有2Kb，与上面测试总结<code>Python Asyncio</code>的内存占用是接近的，而在<a href="https://pkolaczk.github.io/memory-consumption-of-async/">《# <a href="https://pkolaczk.github.io/memory-consumption-of-async/">How Much Memory Do You Need to Run 1 Million Concurrent Tasks?</a>》</a>文中介绍了100万并发时，<code>Go</code>的内存占用比<code>Python Asyncio</code>还高。<br>这是因为<code>Goroutine</code>并不是真协程的调用，他与其他语言的协程调度的设计还是有区别的，大部分语言（<code>Python</code>, <code>Js</code>, <code>Dart</code>等）的协程都是交给一个线程去调度，而<code>Go</code>的协程–<code>Goroutine</code>是交给很多线程去调用的，所以大部分语言在100万并发与1万并发使用的线程数量是一样的，而<code>Go</code>在100万并发时除了有约100万个<code>Goroutinue</code>占用了内存空间外，还需要创建很多线程去调度<code>Goroutine</code>，它们会占用内存资源，最终导致在100万并发下<code>Go</code>占用的内存大于<code>Python Asyncio</code>。</p><blockquote><p>可以通过<a href="https://tpaschalis.me/goroutines-size/">goroutines-size</a>了解<code>Goroutinue</code>的内存占用</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前记&quot;&gt;&lt;a href=&quot;#前记&quot; class=&quot;headerlink&quot; title=&quot;前记&quot;&gt;&lt;/a&gt;前记&lt;/h2&gt;&lt;p&gt;最近看到一篇文章&lt;a href=&quot;https://pkolaczk.github.io/memory-consumption-of-async/&quot;&gt;《How Much Memory Do You Need to Run 1 Million Concurrent Tasks?》&lt;/a&gt;,它介绍了不同语言在运行100万并发时的内存占用，文章列举了多种语言在不同并发环境下的内存占用，让我比较意外的是，在文章最后的结果看到了&lt;code&gt;Go&lt;/code&gt;在100万并发时内存的占用比&lt;code&gt;Python&lt;/code&gt;还高。&lt;br&gt;于是我很好奇一个&lt;code&gt;Python Asyncio&lt;/code&gt;协程内存占用有多少，以及他的其他创建开销数据，处理性能等。&lt;/p&gt;</summary>
    
    
    <content src="https://fastly.jsdelivr.net/gh/so1n/so1n_blog_photo@master/blog_photo/16550442517731649661119526images.png" type="image"/>
    
    
    <category term="Python Asyncio" scheme="http://so1n.me/categories/Python-Asyncio/"/>
    
    
    <category term="Python" scheme="http://so1n.me/tags/Python/"/>
    
    <category term="Asyncio" scheme="http://so1n.me/tags/Asyncio/"/>
    
  </entry>
  
  <entry>
    <title>Python Asyncio 库之从ChatGPT Bug了解Cancel机制</title>
    <link href="http://so1n.me/2023/03/25/python_asyncio_lib_cancel/"/>
    <id>http://so1n.me/2023/03/25/python_asyncio_lib_cancel/</id>
    <published>2023-03-25T15:33:18.000Z</published>
    <updated>2023-03-27T15:37:53.554Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前记"><a href="#前记" class="headerlink" title="前记"></a>前记</h2><p>最近几天，在使用ChatGPT时会发现无法使用历史记录功能。而在3月24号时，OpenAI公布了这次问题是由于某个Bug导致，导致部分用户能获得到其他用户的信息，而这一切是因为<code>redis-py</code>开发者没有考虑到<code>Asyncio Cancel</code>的问题。而<code>Cancel</code>有两个问题，一个是使用<code>Cancel</code>的问题，另外一个是没有使用<code>Cancel</code>的问题。</p><span id="more"></span><p>注:</p><ul><li>1：下文说的取消这个名词代表着<code>Asyncio Cancel</code></li><li>2：了解<code>Cancel</code>机制之前，需要了解<code>Task</code>对象的执行原理，可以通过<a href="https://so1n.me/2022/04/11/python's_waitable_objects_in_asyncio/">可等待对象的原理</a>了解执行原理。</li><li>在<code>Asyncio</code>中，每个协程的实体都是<code>Asyncio.Task</code>对象，或者说是被<code>Asyncio.Task</code>托管，所以本文以<code>Asyncio.Task</code>对象代称协程。</li></ul><h2 id="1-ChatGPT遇到的问题"><a href="#1-ChatGPT遇到的问题" class="headerlink" title="1.ChatGPT遇到的问题"></a>1.ChatGPT遇到的问题</h2><p>本次ChatGPT问题导致了部分用户能获取到另一个用户的数据，这是一个非常严重的问题。<br>根据<a href="https://openai.com/blog/march-20-chatgpt-outage">OpenAI披露问题细节</a>可以知道，ChatGPT使用<code>Redis</code>缓存用户的信息，而后台服务是基于<code>Asyncio</code>运行的，所以使用的是<code>redis-py</code>中的<code>AsyncRedis</code>与他们的<code>Redis</code>集群进行交互的。</p><blockquote><p>AsyncRedis代表着是<code>redis-py</code>中的<code>redis.asyncio.client</code>中的<code>Redis</code>类，下同</p></blockquote><p>在大部分情况下(包括测试)，这种使用方式是没问题的，但是在他们对服务进行修改后导致<code>Redis</code>请求的取消数量激增，而取消是通过<code>asyncio</code>的<code>Cancel</code>实现的，正常情况下，在遇到<code>Cancel</code>后可以捕获取消异常再进行重试或者直接抛出异常。ChatGPT在业务层也是这样实现的，所以ChatGPT的代码并没有问题，真正有问题的是ChatGPT使用到的<code>redis-py</code>库中的<code>AsyncRedis</code>。</p><p><code>AsyncRedis</code>在ChatGPT服务器和<code>Redis</code>集群之间维护一个共享连接池，这些连接池存放着很多个TCP连接，TCP连接拥有请求队列和响应队列，在通过TCP发送数据时，实际上是把数据投递到请求队列中，再由操作系统把数据发送到目标服务器，而在接收到服务器数据后，会把数据存放到响应队列中，等待程序获取。<br>而ChatGPT服务每次与<code>Redis</code>交互时，都会从<code>Redis</code>连接池获取一个连接，并将请求推入到连接中的请求队列中，接着再从连接的响应队列获取数据并返回。<br>但是，如果交互A成功把请求推入到连接后，当前的<code>Asyncio.Task</code>对象由于意外被取消了，那么这时候ChatGPT服务只收到一个取消异常，而<code>AsyncRedis</code>会回收当前连接，并给交互B使用。而交互B在发送请求前，连接的响应队列恰好收到了<code>Redis</code>服务返回的数据，那么交互B在发送请求后就会从响应队列得到了交互A的响应数据了，更糟糕的是由于大部分的请求都是一个发送对应一个接收到，这就意味着后续交互获得的响应都是上一个交互请求的数据了。</p><blockquote><p>ChatGPT问题细节并不本文重点，有兴趣的可以 访问<a href="https://openai.com/blog/march-20-chatgpt-outage">OpenAI披露问题细节</a>。同时应该知道，保护用户数据是后端开发者的主要职责之一，我们不止要校验请求的参数，还需要对返回的隐私数据进行校验，而不是单纯的依赖在使用的工具和服务。</p></blockquote><h2 id="2-重现并找出问题"><a href="#2-重现并找出问题" class="headerlink" title="2.重现并找出问题"></a>2.重现并找出问题</h2><p>通过<a href="https://openai.com/blog/march-20-chatgpt-outage">OpenAI披露问题细节</a>可以知道，这就是类似ORM的那种由于封装导致程序行为与真实结果不一致问题，开发者以为<code>Asyncio.Task</code>对象被取消了所以收不到数据，但真正的结果是<code>Asyncio.Task</code>对象被取消了，但是底层的数据结构却还能正常收到数据。</p><p>然而ChatGPT只是公布了大概的原因，并没有公布自己出现的代码是怎么实现的，在搜索了一圈后，发现<code>redis-py</code>l的<a href="https://github.com/redis/redis-py/issues/2624">issue-2624</a>中有可以重现该问题的代码，不过为了确保能100%重现这个问题，首先需要在本机安装<code>Redis</code>服务(如果不是使用本机的<code>Redis</code>服务，那么不一定能100%重现)，然后运行<a href="https://github.com/redis/redis-py/issues/2624">issue-2624</a>的代码（后续提到的示例代码都代表是本代码）:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-comment"># 对应的redis-py版本为4.5.2（新推出的修复版本4.5.3仍然有该问题,4.5.3只修复了PIPE）</span><br><span class="hljs-keyword">import</span> asyncio<br><span class="hljs-keyword">from</span> redis.asyncio <span class="hljs-keyword">import</span> Redis<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> Redis(single_connection_client=<span class="hljs-literal">True</span>) <span class="hljs-keyword">as</span> r:<br><br>        <span class="hljs-keyword">await</span> r.<span class="hljs-built_in">set</span>(<span class="hljs-string">&#x27;foo&#x27;</span>, <span class="hljs-string">&#x27;foo&#x27;</span>)<br>        <span class="hljs-keyword">await</span> r.<span class="hljs-built_in">set</span>(<span class="hljs-string">&#x27;bar&#x27;</span>, <span class="hljs-string">&#x27;bar&#x27;</span>)<br><br>        t = asyncio.create_task(r.get(<span class="hljs-string">&#x27;foo&#x27;</span>))<br>        <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">0</span>)  <span class="hljs-comment"># 模拟IO</span><br>        t.cancel()<br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-keyword">await</span> t<br>            print(<span class="hljs-string">&#x27;try again, we did not cancel the task in time&#x27;</span>)<br>        <span class="hljs-keyword">except</span> asyncio.CancelledError <span class="hljs-keyword">as</span> e:<br>            print(<span class="hljs-string">&#x27;managed to cancel the task, connection is left open with unread response&#x27;</span>)<br><br>        print(<span class="hljs-string">&#x27;bar:&#x27;</span>, <span class="hljs-keyword">await</span> r.get(<span class="hljs-string">&#x27;bar&#x27;</span>))<br>        print(<span class="hljs-string">&#x27;ping:&#x27;</span>, <span class="hljs-keyword">await</span> r.ping())<br>        print(<span class="hljs-string">&#x27;foo:&#x27;</span>, <span class="hljs-keyword">await</span> r.get(<span class="hljs-string">&#x27;foo&#x27;</span>))<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    asyncio.run(main())<br></code></pre></td></tr></table></figure><p>在运行该代码后可以得到如下输出:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Bash">managed to cancel the task, connection is left open with unread response<br>bar: b<span class="hljs-string">&#x27;foo&#x27;</span><br>ping: False<br>foo: b<span class="hljs-string">&#x27;PONG&#x27;</span><br></code></pre></td></tr></table></figure><p>通过输出结果可以发现，第一个交互是从<code>Redis</code>获取键值为<code>foo</code>的值，但是在被显式的执行取消操作后，后续的交互获取的值都是上一次交互想要的值，这是非常糟糕的，为了找到问题的原因，需要深入到<code>AsyncRedis</code>的源码中查找。</p><p>在用户发起命令<code>set</code>和<code>get</code>中涉及到的核心调用都是只有<code>execute_command</code>方法，它对应的代码如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># redis.asyncio.client</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Redis</span>:</span><br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">execute_command</span>(<span class="hljs-params">self, *args, **options</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;Execute a command and return a parsed response&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">await</span> self.initialize()<br>        pool = self.connection_pool<br>        command_name = args[<span class="hljs-number">0</span>]<br>        conn = self.connection <span class="hljs-keyword">or</span> <span class="hljs-keyword">await</span> pool.get_connection(command_name, **options)<br><br>        <span class="hljs-keyword">if</span> self.single_connection_client:<br>            <span class="hljs-keyword">await</span> self._single_conn_lock.acquire()<br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> conn.retry.call_with_retry(<br>                <span class="hljs-keyword">lambda</span>: self._send_command_parse_response(<br>                    conn, command_name, *args, **options<br>                ),<br>                <span class="hljs-keyword">lambda</span> error: self._disconnect_raise(conn, error),<br>            )<br>        <span class="hljs-keyword">finally</span>:<br>            <span class="hljs-keyword">if</span> self.single_connection_client:<br>                self._single_conn_lock.release()<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self.connection:<br>                <span class="hljs-keyword">await</span> pool.release(conn)<br><br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_send_command_parse_response</span>(<span class="hljs-params">self, conn, command_name, *args, **options</span>):</span><br>        <span class="hljs-keyword">await</span> conn.send_command(*args)<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> self.parse_response(conn, command_name, **options)<br></code></pre></td></tr></table></figure><p>代码中的<code>execute_command</code>方法对应的就是从连接池获取连接并通过<code>_send_command_parse_response</code>方法把请求数据发送到连接中，然后等待连接返回的数据并返回，最后则是释放连接的占用，使连接回到连接池等待被下次调用。<br>可以发现真正与<code>Redis</code>发生交互的是<code>send_commanad_parse_response</code>方法中的<code>send_command</code>和<code>parse_response</code>两个IO操作方法。此外，由于通过复现问题的代码输出可以发现在显式调用取消后，下一个交互得到的输出永远为上一个交互得到的结果，这也就意味着<code>send_command</code>这个方法是执行成功的，所以取消操作真正命中的是<code>self.parse_response</code>方法。</p><blockquote><p>如果重新问题代码中的<code>asyncio.sleep(0)</code>被移除，则不会有问题发生，这是因为取消操作命中的是<code>send_command</code>方法</p></blockquote><p>如果了解了取消机制的原理(后文会有详细的描述)，那么可以知道在对示例代码中的<code>t</code>调用<code>cancel</code>方法执行取消操作的时候，会取消正在等待的<code>parse_response</code>方法，然后再沿着堆栈向上抛出异常。然而<code>execute_commanad</code>中的名为<code>call_with_retry</code>的重试方法只针对连接异常和超时异常进行重试，所以<code>call_with_retry</code>在收到取消异常时会继续往上抛，这时<code>execute_command</code>方法就会回收连接，并把异常向上抛到调用<code>AsyncRedis</code>的业务层中供用户使用。</p><p>由于<code>Cancel</code>可以向上堆栈传递取消异常，于是业务层，<code>AsyncRedis</code>层能收到取消异常，并最终由<code>t</code>这个<code>Asyncio.Task</code>对象捕获到了取消异常，至此当前协程就已经被取消了，可以认为程序是没有什么问题，取消操作也完成了自己的任务。<br>不过<code>AsyncRedis</code>中的连接并未被关闭且响应队列的数据写入操作是系统决定的，而不是当前<code>t</code>对象管理的(可以认为是另外一个<code>Asyncio.Task</code>对象在管理的)，这意味着针对<code>t</code>对象的取消操作并不会影响到响应队列的写入操作，响应队列仍然还能接收另一端发送过来的数据，这下问题就出现了，由于<code>Redis</code>协议是按照一进一出来处理数据的（仅限于当前示例代码的<code>Redis</code>命令），这意味着必须每次发送一个请求后都要读取一次请求，但是取消操作却把某一次读取数据的操作给取消了，这就导致了后续取的数据永远是上一个。</p><p>但是这个例子涉及到系统调用，比较难理解具体的逻辑，于是把实现进行一下转换，把示例代码全转换为纯<code>Python</code>实现，不引入其他的库，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> asyncio<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    <span class="hljs-comment"># 针对于worker来说是只写的</span><br>    write_queue = asyncio.Queue()<br>    <span class="hljs-comment"># 针对于worker来说是只读的</span><br>    read_queue = asyncio.Queue()<br><br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">porter</span>():</span><br>        <span class="hljs-string">&quot;&quot;&quot;搬运工负责把write_queue中的数据写入到read_queue中&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>            item = <span class="hljs-keyword">await</span> write_queue.get()<br>            <span class="hljs-keyword">await</span> read_queue.put(item)<br>            write_queue.task_done()<br><br>    asyncio.create_task(porter())<br><br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">worker</span>(<span class="hljs-params">cnt</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;模拟Redis的从写入队列写入数据，并从只读队列中读取数据&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">await</span> write_queue.put(cnt)<br>        print(<span class="hljs-string">f&quot;worker:<span class="hljs-subst">&#123;cnt&#125;</span> get num :<span class="hljs-subst">&#123;<span class="hljs-keyword">await</span> read_queue.get()&#125;</span>&quot;</span>)<br><br>    <span class="hljs-comment"># 模拟取消操作</span><br>    t = asyncio.create_task(worker(<span class="hljs-number">1</span>))<br>    <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">0</span>)<br>    t.cancel()<br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-keyword">await</span> t<br>        print(<span class="hljs-string">&quot;no cancel&quot;</span>)<br>    <span class="hljs-keyword">except</span> asyncio.CancelledError:<br>        print(<span class="hljs-string">&quot;cancel&quot;</span>)<br><br>    <span class="hljs-keyword">await</span> worker(<span class="hljs-number">2</span>)<br>    <span class="hljs-keyword">await</span> worker(<span class="hljs-number">3</span>)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    asyncio.run(main())<br></code></pre></td></tr></table></figure><p>这段代码中使用<code>write_queue</code>和<code>read_queue</code>分别模拟连接的写入队列和读取队列，而<code>porter</code>则是一个搬运工，它负责把写入队列的数据转移到只读队列中，模拟<code>redis-py</code>客户端在通过连接发送数据后获取数据的功能，在运行代码后可以得到如下输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Bash">cancel<br>worker:2 get num :1<br>worker:3 get num :2<br></code></pre></td></tr></table></figure><p>通过输出可以发现该程序的输出结果与<a href="https://github.com/redis/redis-py/issues/2624">issue-2624</a>的输出结果类似–下一个发起请求的函数的响应结果实际上是上一个请求产生的。<br>而且通过这份代码可以明显的看出，负责转移数据的<code>poeter</code>函数是由<code>asyncio.create_task</code>启动，这代表他是由另一个<code>Asyncio.Task</code>对象管理的(在这个场景中可以认为<code>poeter</code>是<code>redis-py</code>连接池中的某一个连接)。</p><p>这样一来，由于<code>poeter</code>对象与后面的<code>t</code>对象并不是同一个<code>Asyncio.Task</code>对象，而<code>t</code>对象的<code>worker</code>函数在往写入队列写入数据后，就被主动取消了，且取消这个操作只影响到了<code>t</code>这个对象，这意味着只取消了<code>read_queue.get</code>这个动作，而其他的协程/动作都还在正常的执行着，包括<code>poeter</code>对象。<br>所以<code>poeter</code>对象还是能正常的从<code>write_queue</code>队列中获取数据再推到<code>read_queue</code>队列中，这也就导致了<code>worker(2)</code>和<code>worker(3)</code>虽然是正常执行的推入的是<code>2</code>和<code>3</code>，但是他们分别得到的值却是<code>1</code>和<code>2</code>。</p><p>通过上述的分析可以看出，<code>Asyncio</code>的取消操作是属于某一对象的方法，这意味着取消操作只能取消并中断该方法对应的<code>Asyncio.Task</code>对象执行，不能取消其他<code>Asyncio.Task</code>对象的操作，此外，取消只能管理某个动作，不会去影响到动作相关的资源。<br>同时要知道的是由于<code>Asyncio</code>的机制是任何协程都能互相影响，也就是A协程可以取消B协程，这意味着开发者在业务代码对某个协程进行取消时，取消是可以被传递的。<br>现在再回到<code>redis-py</code>这个库本身，由于<code>redis-py</code>本身没有用到取消操作相关的语法，于是没有考虑到取消操作这件事，但是业务代码中针对某一<code>Asyncio.Task</code>对象执行取消操作时，取消这个动作影响会到了<code>redis-py</code>库的方法，最终导致这个问题出现。</p><p><code>Python.Asyncio</code>的任何协程都能互相影响的机制解决了协程无法被管理导致的内存溢出等问题，但这也间接的导致了库的开发者需要注意到取消机制的存在。<br>而与之相反的是<code>Go</code>协程，由于它本身的特性，虽然B协程是A协程创造出来的，但是A协程没有办法影响到B协程，为了实现A协程能影响到B协程，需要显式的把context从A协程传到B协程中，然后由A协程通过context传递动作，B协程根据context的结果做出响应，如下代码:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;context&quot;</span><br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">demo</span><span class="hljs-params">(ctx context.Context, quit <span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>)</span></span> &#123;<br>    <span class="hljs-keyword">for</span> &#123;<br>        <span class="hljs-keyword">select</span> &#123;<br>        <span class="hljs-keyword">case</span> &lt;-ctx.Done():<br>            fmt.Printf(<span class="hljs-string">&quot;ctx.Done&quot;</span>)<br>            quit &lt;- <span class="hljs-number">1</span><br>        <span class="hljs-keyword">case</span> &lt;-quit:<br>            fmt.Printf(<span class="hljs-string">&quot;quit&quot;</span>)<br>            <span class="hljs-keyword">return</span><br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    rootContext := context.Background()<br>    ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>)<br>    ctx, cancelFunc := context.WithCancel(rootContext)<br>    <span class="hljs-keyword">go</span> demo(ctx, ch)<br>    cancelFunc()<br>    time.Sleep(time.Second * <span class="hljs-number">1</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个代码中<code>main</code>函数可以认为是协程A，而<code>demo</code>函数是协程B，在通过<code>go demo</code>启动协程B后，协程B就无法再被管理，如果要管理协程B，就必须像示例代码一样让<code>demo</code>函数支持外部传入context变量，同时内部会对context变量的状态进行监听并做出响应的操作。<br>这就意味着新启动的协程能支持协程的哪些功能，全由这个协程的实现者决定，这样即使<code>redis-py</code>没有考虑到取消的功能，也并不会被用户的业务代码影响到，但反过来用户却没办法使用到取消功能来影响<code>redis-py</code>的功能，除非开发者有意去添加取消功能。</p><p>通过对比发现，为了功能完备，无论使用<code>Go</code>还是<code>Python</code>都需要开发者去针对取消机制去进行处理，如果开发者没有去处理的话，在<code>Go</code>中是无法使用取消功能，而<code>Python</code>则是会引发一些问题，这种情况下<code>Go</code>的机制会好一些，不过对于结构化并发和超时等功能，<code>Go</code>都需要库开发者去显式的支持，而<code>Python</code>却不用，这一点我会觉得<code>Python</code>的实现更好一些，当然，哪种实现更好还是取决于使用者本人。</p><h2 id="3-使用取消需要考虑的问题"><a href="#3-使用取消需要考虑的问题" class="headerlink" title="3.使用取消需要考虑的问题"></a>3.使用取消需要考虑的问题</h2><p>通过ChatGPT的问题可以知道在使用<code>Asyncio</code>时没有考虑到取消这个场景时会导致一些问题的发生，然而在使用取消机制时也有很多问题需要考虑的。</p><h3 id="3-1-取消无法取消已经完成的Asyncio-Task对象"><a href="#3-1-取消无法取消已经完成的Asyncio-Task对象" class="headerlink" title="3.1.取消无法取消已经完成的Asyncio.Task对象"></a>3.1.取消无法取消已经完成的<code>Asyncio.Task</code>对象</h3><p>还记得一开始的例子代码中的一段<code>asyncio.sleep(0)</code>的代码吗？这里是特意修改为0从而确保这段代码能触发Bug，如果休眠时间变长，则不一定能触发，为了能更好的理解，这里使用转换后的例子代码来演示，并把<code>asyncio.sleep(0)</code>改为<code>asyncio.sleep(0.1)</code>，代码如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> asyncio<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    <span class="hljs-comment"># 针对于worker来说是只写的</span><br>    write_queue = asyncio.Queue()<br>    <span class="hljs-comment"># 针对于worker来说是只读的</span><br>    read_queue = asyncio.Queue()<br><br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">porter</span>():</span><br>        <span class="hljs-string">&quot;&quot;&quot;搬运工负责把write_queue中的数据写入到read_queue中&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>            item = <span class="hljs-keyword">await</span> write_queue.get()<br>            <span class="hljs-keyword">await</span> read_queue.put(item)<br>            write_queue.task_done()<br><br>    asyncio.create_task(porter())<br><br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">worker</span>(<span class="hljs-params">cnt</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;模拟Redis的从写入队列写入数据，并从只读队列中读取数据&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">await</span> write_queue.put(cnt)<br>        print(<span class="hljs-string">f&quot;worker:<span class="hljs-subst">&#123;cnt&#125;</span> get num :<span class="hljs-subst">&#123;<span class="hljs-keyword">await</span> read_queue.get()&#125;</span>&quot;</span>)<br><br>    <span class="hljs-comment"># 模拟取消操作</span><br>    t = asyncio.create_task(worker(<span class="hljs-number">1</span>))<br>    <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">0.1</span>)<br>    t.cancel()<br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-keyword">await</span> t<br>        print(<span class="hljs-string">&quot;no cancel&quot;</span>)<br>    <span class="hljs-keyword">except</span> asyncio.CancelledError:<br>        print(<span class="hljs-string">&quot;cancel&quot;</span>)<br><br>    <span class="hljs-keyword">await</span> worker(<span class="hljs-number">2</span>)<br>    <span class="hljs-keyword">await</span> worker(<span class="hljs-number">3</span>)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    asyncio.run(main())<br></code></pre></td></tr></table></figure><p>运行代码后就可以看到终端会有如下输出:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Python">worker:<span class="hljs-number">1</span> get num :<span class="hljs-number">1</span><br>no cancel<br>worker:<span class="hljs-number">2</span> get num :<span class="hljs-number">2</span><br>worker:<span class="hljs-number">3</span> get num :<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>通过输出结果可以发现，<code>t</code>对象并没有被取消，后面的<code>worker</code>对象执行也是正常的了。这是因为取消这个动作执行的时候<code>t</code>对象已经执行完毕了，而取消只能取消处于等待过程的<code>Asyncio.Task</code>对象，所以在这个例子中的取消操作是没有执行成功的。</p><p>为了能更好的了解这个机制，可以通过如下代码进行验证：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> asyncio<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    t = asyncio.create_task(asyncio.sleep(<span class="hljs-number">0</span>))<br>    print(t.done())    <span class="hljs-comment"># False</span><br>    <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">0.1</span>)<br>    print(t.done())    <span class="hljs-comment"># True</span><br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    asyncio.run(main())<br></code></pre></td></tr></table></figure><p>通过运行该代码后，可以发现第一次打印<code>t.done</code>是<code>False</code>，而第二次打印为<code>True</code>。其实在<a href="https://so1n.me/2022/04/11/python's_waitable_objects_in_asyncio/">可等待对象的原理</a> 中介绍了<code>Task</code>是协程的载体，而<code>Task</code>继承于<code>Future</code>，所以通过<code>Future</code>的源码也可以知道<code>Cancel</code>方法仅当协程为等待状态(<code>PENDING</code>)时生效，而且他的工作只是把协程状态改为<code>CANCELLED</code>状态(<code>Asyncio.Task</code>对象会复杂一点):</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Future</span>:</span><br>    ... <span class="hljs-comment"># 省略其他方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">cancel</span>(<span class="hljs-params">self, msg=<span class="hljs-literal">None</span></span>):</span><br>        self.__log_traceback = <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">if</span> self._state != _PENDING:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        self._state = _CANCELLED<br>        self._cancel_message = msg<br>        self.__schedule_callbacks()<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><h3 id="3-2-取消是一个异步操作"><a href="#3-2-取消是一个异步操作" class="headerlink" title="3.2.取消是一个异步操作"></a>3.2.取消是一个异步操作</h3><p>取消是一个异步操作，这意味着取消这个操作可能需要一段时间才能执行完毕。</p><p>如果是第一次接触示例代码的话，那么一定会好奇为何一定要有<code>asyncio.sleep(0)</code>这个语句，才能百分百复现Bug？为了验证这个问题，先编写一个简单的示例，代码如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> asyncio<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">demo</span>():</span><br>        print(<span class="hljs-string">&quot;demo函数运行了！&quot;</span>)<br>        <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">10</span>)<br>    t = asyncio.create_task(demo())<br>    t.cancel()<br>    print(t.cancelled())<br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-keyword">await</span> t<br>    <span class="hljs-keyword">except</span> asyncio.CancelledError:<br>        print(<span class="hljs-string">&quot;demo已经被取消了&quot;</span>)<br>    print(t.cancelled())<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    asyncio.run(main())<br></code></pre></td></tr></table></figure><p>在运行该示例时可以发现有如下输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">False<br>demo已经被取消了<br>True<br></code></pre></td></tr></table></figure><p>可以发现<code>demo</code>函数的第一句就已经没有执行了， 这是因为没有<code>asyncio.sleep(0)</code>来让出控制权，事件循环就无法去调度<code>t</code>对象去启动，这时即使针对<code>t</code>对象执行了取消操作，但由于<code>t</code>对象没有运行，那么此时的操作只能是给<code>t</code>对象打个标记，告诉<code>t</code>对象已经是取消状态了，然后等到调用<code>await t</code>主动去激活<code>t</code>对象后，<code>t</code>对象就会开始运行，但是在启动后发现自己已经被取消了，就不会去执行<code>demo</code>函数，而是直接抛错了。</p><p>这个例子解释了加上<code>asyncio.sleep(0)</code>这个语句的必要性，但是示例代码中已经加上了<code>asyncio.sleep(0)</code>语句了，后面为啥还要使用<code>await t</code>呢？这是因为执行取消操作时会取消当前<code>t</code>对象正在执行的操作，然后逐步把异常向上抛，但是内部可以由开发者捕获取消异常后执行一些等待操作(如IO操作)，此时<code>t</code>对象就无法马上收到取消异常，这意味着取消动作还未结束。<br>当IO操作执行完后，会继续向上抛异常，然后<code>t</code>对象在接收到取消异常后会转为完成状态，此时取消操作也就完成了。<br>如下是模拟取消操作被堵住的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">demo</span>():</span><br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">except</span> asyncio.CancelledError <span class="hljs-keyword">as</span> e:<br>            <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">2</span>)<br>            <span class="hljs-keyword">raise</span> e<br><br>    t = asyncio.create_task(demo())<br>    <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">0</span>)<br>    t.cancel()<br>    start_cancel_time = time.time()<br>    print(t.cancelled())<br>    <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">0.5</span>)<br>    print(t.cancelled())<br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-keyword">await</span> t<br>    <span class="hljs-keyword">except</span> asyncio.CancelledError <span class="hljs-keyword">as</span> e:<br>        print(t.cancelled())<br>    print(<span class="hljs-string">f&quot;取消操作的执行时间为：<span class="hljs-subst">&#123;time.time() - start_cancel_time&#125;</span>&quot;</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    asyncio.run(main())<br></code></pre></td></tr></table></figure><p>在执行完成的时候，控制台有如下输出:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">False<br>False<br>True<br>取消操作的执行时间为：2.002300500869751<br></code></pre></td></tr></table></figure><p>通过输出可以看到，第一次打印取消状态和休眠0.5秒后第二次打印的取消状态都是一样的，表示协程尚未被取消，但在执行<code>await t</code>后，就打印了协程已经被取消了，且可以发现从取消协程开始到结束所花费的时间正好是2秒左右，与<code>demo</code>函数捕获取消异常后休眠2秒一致。</p><h3 id="3-3-取消异常的处理"><a href="#3-3-取消异常的处理" class="headerlink" title="3.3.取消异常的处理"></a>3.3.取消异常的处理</h3><p>从上面可以的分析可以知道，取消操作是取消某一段执行，然后向上抛异常，当<code>Asyncio.Task</code>捕获到异常后，会标记<code>AsyncioTask</code>对象的状态为取消。那如果向<code>Asyncio.Task</code>对象执行取消操作，但是取消的异常被屏蔽了，会如何处理呢？下面是一个基于3.1中示例代码修改的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">demo</span>():</span><br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">except</span> asyncio.CancelledError <span class="hljs-keyword">as</span> e:<br>            print(<span class="hljs-string">&quot;任务已经被取消了&quot;</span>)<br>            <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">2</span>)<br><br>    t = asyncio.create_task(demo())<br>    <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">0</span>)<br>    t.cancel()<br>    print(t.cancelled())<br>    print(<span class="hljs-string">&quot;取消的标记为： &quot;</span>, t._must_cancel)<br>    <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-keyword">await</span> t<br>        print(<span class="hljs-string">&quot;没有收到取消操作, 协程的取消结果为：&quot;</span>, t.cancelled())<br>    <span class="hljs-keyword">except</span> asyncio.CancelledError <span class="hljs-keyword">as</span> e:<br>        print(<span class="hljs-string">&quot;已经收到取消操作, 协程的取消结果为：&quot;</span>, t.cancelled())<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    asyncio.run(main())<br></code></pre></td></tr></table></figure><p>运行代码后可以发现输出如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Bash">False<br>取消的标记为：  True<br>任务已经被取消了<br>没有收到取消操作, 协程的取消结果为： False<br></code></pre></td></tr></table></figure><p>通过取消标记可以发现取消操作已经正确执行了，但是由于取消异常没有被向上抛出，导致<code>t</code>对象无法捕获到取消异常，从而认为<code>t</code>对象的取消状态为<code>False</code>。所以如果不是有意对取消异常做特别处理（比如超时的实现是把取消异常转为超时异常抛出），那么在捕获取消异常进行处理后仍然需要抛出取消异常。</p><h2 id="4-取消机制的实现"><a href="#4-取消机制的实现" class="headerlink" title="4.取消机制的实现"></a>4.取消机制的实现</h2><p>前面写了取消机制的几种情况，都是通过源码分析出来的，因为官方文档并没有明显的说明，所以要用好取消机制，最好还是过一遍相关的源码，好在跟取消机制相关的地方不多，只跟<code>Asyncio.Task</code>对象和<code>Asyncio</code>事件循环的调度有关。</p><blockquote><ul><li>1.<code>Asyncio.Future</code>也跟取消机制有关，不过非常简单，这里就不说了。</li><li>2.本文只介绍跟取消操作相关的，如果要了解<code>Asyncio.Task</code>对象的具体原理，详见<a href="https://so1n.me/2022/04/11/python's_waitable_objects_in_asyncio/">Python的可等待对象在Asyncio的作用</a>，如果要了解<code>Asyncio</code>的调度原理，详见<a href="https://so1n.me/2022/06/08/python_asyncio_schedule/">Python Asyncio调度原理</a></li></ul></blockquote><p>首先是看<code>Task</code>对象，<code>Task</code>对象跟取消机制相关代码如下（<code>uncancel</code>相关代码也移除了）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Task</span>(<span class="hljs-params">futures._PyFuture</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, coro, *, loop=<span class="hljs-literal">None</span>, name=<span class="hljs-literal">None</span>, context=<span class="hljs-literal">None</span></span>):</span><br>        ...<br>        self._must_cancel = <span class="hljs-literal">False</span><br>        self._fut_waiter = <span class="hljs-literal">None</span><br>        ...<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">cancel</span>(<span class="hljs-params">self, msg=<span class="hljs-literal">None</span></span>):</span><br>        ...<br>        <span class="hljs-keyword">if</span> self.done():<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">if</span> self._fut_waiter <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">if</span> self._fut_waiter.cancel(msg=msg):<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>        self._must_cancel = <span class="hljs-literal">True</span><br>        self._cancel_message = msg<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__step</span>(<span class="hljs-params">self, exc=<span class="hljs-literal">None</span></span>):</span><br>        <span class="hljs-keyword">if</span> self.done():<br>            <span class="hljs-keyword">raise</span> exceptions.InvalidStateError(<br>                <span class="hljs-string">f&#x27;_step(): already done: <span class="hljs-subst">&#123;self!r&#125;</span>, <span class="hljs-subst">&#123;exc!r&#125;</span>&#x27;</span>)<br>        <span class="hljs-keyword">if</span> self._must_cancel:<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">isinstance</span>(exc, exceptions.CancelledError):<br>                exc = self._make_cancelled_error()<br>            self._must_cancel = <span class="hljs-literal">False</span><br>        coro = self._coro<br>        self._fut_waiter = <span class="hljs-literal">None</span><br><br>        _enter_task(self._loop, self)<br>        <span class="hljs-comment"># Call either coro.throw(exc) or coro.send(None).</span><br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-keyword">if</span> exc <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>                <span class="hljs-comment"># We use the `send` method directly, because coroutines</span><br>                <span class="hljs-comment"># don&#x27;t have `__iter__` and `__next__` methods.</span><br>                result = coro.send(<span class="hljs-literal">None</span>)<br>            <span class="hljs-keyword">else</span>:<br>                result = coro.throw(exc)<br>        <span class="hljs-keyword">except</span> StopIteration <span class="hljs-keyword">as</span> exc:<br>            <span class="hljs-keyword">if</span> self._must_cancel:<br>                <span class="hljs-comment"># Task is cancelled right before coro stops.</span><br>                self._must_cancel = <span class="hljs-literal">False</span><br>                <span class="hljs-built_in">super</span>().cancel(msg=self._cancel_message)<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-built_in">super</span>().set_result(exc.value)<br>        <span class="hljs-keyword">except</span> exceptions.CancelledError <span class="hljs-keyword">as</span> exc:<br>            <span class="hljs-comment"># Save the original exception so we can chain it later.</span><br>            self._cancelled_exc = exc<br>            <span class="hljs-built_in">super</span>().cancel()  <span class="hljs-comment"># I.e., Future.cancel(self).</span><br>        <span class="hljs-keyword">except</span> (KeyboardInterrupt, SystemExit) <span class="hljs-keyword">as</span> exc:<br>            <span class="hljs-built_in">super</span>().set_exception(exc)<br>            <span class="hljs-keyword">raise</span><br>        <span class="hljs-keyword">except</span> BaseException <span class="hljs-keyword">as</span> exc:<br>            <span class="hljs-built_in">super</span>().set_exception(exc)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-comment"># 这里没有取消操作的相关逻辑，这部分不属于本文的主体，直接省略，知道会通过</span><br>            <span class="hljs-comment"># `self._loop.call_sonn`调用`self.__step`使`Asyncio.Task`能继续往下走</span><br>            <span class="hljs-comment"># 如果如果发现有其他的`coro`或者`Future`对象在等待时就把他们赋值到`self._fut_waiter`就可以了</span><br>            <span class="hljs-comment"># 具体内容请参考《Python的可等待对象在Asyncio的作用》文章</span><br>                ...<br>                result._asyncio_future_blocking = <span class="hljs-literal">False</span><br>                result.add_done_callback(self.__wakeup, context=self._context)<br>                self._fut_waiter = result<br>                <span class="hljs-keyword">if</span> self._must_cancel:<br>                    <span class="hljs-keyword">if</span> self._fut_waiter.cancel(msg=self._cancel_message):<br>                        self._must_cancel = <span class="hljs-literal">False</span><br>                ...<br>        <span class="hljs-keyword">finally</span>:<br>            _leave_task(self._loop, self)<br>            self = <span class="hljs-literal">None</span>  <span class="hljs-comment"># Needed to break cycles when an exception occurs.</span><br>            <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__wakeup</span>(<span class="hljs-params">self, future</span>):</span><br>        <span class="hljs-keyword">try</span>:<br>            future.result()<br>        <span class="hljs-keyword">except</span> BaseException <span class="hljs-keyword">as</span> exc:<br>            <span class="hljs-comment"># This may also be a cancellation.</span><br>            self.__step(exc)<br>        <span class="hljs-keyword">else</span>:<br>            self.__step()<br>        self = <span class="hljs-literal">None</span>  <span class="hljs-comment"># Needed to break cycles when an exception occurs.</span><br></code></pre></td></tr></table></figure><p>在阅读源码之前，先简单的过一下<code>Asyncio.Task</code>的原理，在对<code>Asyncio.Task</code>进行初始化时，会调用<code>__init__</code>方法进行初始化，然后需要用户通过<code>await</code>调用初始化好的<code>Asynio.Task</code>对象时，才会触发<code>_step</code>方法，<code>_step</code>方法则是通过生成器的<code>send</code>方法来驱动协程的执行，如果协程内部有非<code>Asyncio.Task</code>可等待对象，则会把他们赋值到<code>self._fut_waiter</code>对象中，并通过<code>loop.call_xxx</code>系列函数安排事件循环在下次有空且<code>self._fut_Waiter</code>对象准备好时再来调用<code>_step</code>方法，然后就这样一直循环反复，直到执行结束或者遇到异常为止，如下面的代码(执行逻辑见注释):</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> asyncio<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">demo</span>():</span><br>    <span class="hljs-keyword">await</span> asyncio.Future()  <span class="hljs-comment"># &lt;--3:发现coro.send返回的对象是asyncio.Future，此时把asyncio.Future赋值到self._fut_waiter中,并等待`asyncio.Future`执行完毕后来调用自己`self.__wakeup方法`从而再回到`self.__step`方法。</span><br>    <span class="hljs-keyword">await</span> asyncio.Future()  <span class="hljs-comment"># &lt;--4:此时被事件循环唤醒，但是又发现是asyncio.Future，与第三步处理类似</span><br>    <span class="hljs-comment"># &lt;-- 后续没有任务语句，直接抛出StopIteration异常，交由`Asyncio.Task`对象处理</span><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    t = asyncio.create_task(demo())  <span class="hljs-comment"># &lt;-- 1:此时创建一个`asyncio.Task`对象</span><br>    <span class="hljs-keyword">await</span> t   <span class="hljs-comment"># &lt;-- 2:第一次调用了`_step`方法</span><br><br><br>asyncio.run(main())<br></code></pre></td></tr></table></figure><p>这段代码中，第一部分是<code>__init__</code>方法，这个方法很简单，它会初始化<code>self._must_cancel</code>为<code>False</code>，以及<code>self._fut_waiter</code>为空。</p><p>第二部分则是取消操作对应的<code>cancel</code>方法，它会先判断当前<code>Asyncio.Task</code>是否已经执行完毕，如果执行完毕就会直接退出，不执行<code>cancel</code>的剩下操作，这里解释了3.1标题中说的《取消无法取消已经完成的<code>Asyncio.Task</code>对象》。<br>如果<code>Asyncio.Task</code>没有执行完毕则会判断当前的<code>self._fut_waiter</code>对象是否为空，如果不为空，则直接取消<code>self._fut_waiter</code>对象，并返回。如果为空则设置<code>self._must_cancel</code>为<code>True</code>。</p><p>第三部分是<code>_step</code>方法，该方法如果发现<code>self._must_cancel</code>为<code>True</code>，且没有异常或者异常不属于取消异常时会生成一份默认的取消异常，然后就直接到了<code>coro.throw(exc)</code>这行代码，直接告诉被<code>Asyncio.Task</code>托管的Coro出现了取消异常，然后Coro会抛出对应的取消异常并被<code>Asyncio.Task</code>捕获并退出。这时如果<code>Coro</code>并没有通过<code>coro.send</code>预激（也就是第一次调用<code>_step</code>方法时直接命中了<code>coro.throw</code>方法），则<code>Coro</code>不会被运行，此时对应的是3.2.取消是一个异步操作中的第一个示例代码的场景。<br>然而如果<code>Coro</code>还有<code>await</code>语法没走完就会进入到没异常的<code>else</code>语块中，该语块会向<code>result</code>注册一个回调，让<code>result</code>完成时来调用自己的<code>__wakeup</code>方法，如果<code>result</code>抛出异常就会把异常传入<code>_step</code>方法中。现在循环就又回到了<code>_step</code>方法了， 而这次不属于第一次运行<code>_step</code>方法了，此时执行了<code>coro.throw(exc)</code>这行代码，那么就会使<code>Coro</code>中的对应的<code>await</code>语句抛出取消异常，然后交由<code>Asyncio.Task</code>捕获取消异常并返回。</p><blockquote><p><code>_step</code>方法入口时就把<code>self._must_cancel</code>设置为<code>Fasle</code>了，而<code>else</code>语块还要判断<code>self._must_cancel</code>为<code>True</code>的情况，这里应该是考虑了线程不安全的问题，但是我没有去验证。</p></blockquote><p>可以发现第二部分能让开发者主动诱发<code>self._fut_waiter</code>对象抛出取消异常，而<code>__wakeup</code>能监听<code>self._fut_waiter</code>的取消异常，从而传入<code>_step</code>方法中，最终让<code>Asyncio.Task</code>的状态变为取消状态，这是一个闭环。<br>如果这一环中有有一处代码捕获到取消异常并不再抛出取消异常，那么<code>Asyncio.Task</code>就无法变为取消状态，而是以正常的步骤继续调用<code>_step</code>方法。</p><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5.总结"></a>5.总结</h2><p>可以发现<code>Asyncio</code>的取消机制还是有一点点复杂，作为库的开发者，需要无时无刻考虑到如果自己编写的代码遇到取消异常时，需要怎么去妥善处理(其实<code>Python</code>自己实现的<code>Asyncio</code>同步原语或者高级API也被取消异常坑过)。<br>而作为使用者，也需要知道取消异常的使用局限性和使用方法。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前记&quot;&gt;&lt;a href=&quot;#前记&quot; class=&quot;headerlink&quot; title=&quot;前记&quot;&gt;&lt;/a&gt;前记&lt;/h2&gt;&lt;p&gt;最近几天，在使用ChatGPT时会发现无法使用历史记录功能。而在3月24号时，OpenAI公布了这次问题是由于某个Bug导致，导致部分用户能获得到其他用户的信息，而这一切是因为&lt;code&gt;redis-py&lt;/code&gt;开发者没有考虑到&lt;code&gt;Asyncio Cancel&lt;/code&gt;的问题。而&lt;code&gt;Cancel&lt;/code&gt;有两个问题，一个是使用&lt;code&gt;Cancel&lt;/code&gt;的问题，另外一个是没有使用&lt;code&gt;Cancel&lt;/code&gt;的问题。&lt;/p&gt;</summary>
    
    
    <content src="https://fastly.jsdelivr.net/gh/so1n/so1n_blog_photo@master/blog_photo/16550442517731649661119526images.png" type="image"/>
    
    
    <category term="Python Asyncio" scheme="http://so1n.me/categories/Python-Asyncio/"/>
    
    
    <category term="Python" scheme="http://so1n.me/tags/Python/"/>
    
    <category term="Asyncio" scheme="http://so1n.me/tags/Asyncio/"/>
    
  </entry>
  
  <entry>
    <title>Python Asyncio 库之同步原语常用函数详解</title>
    <link href="http://so1n.me/2023/02/27/python_asyncio_lib_asycio_sync_introduction/"/>
    <id>http://so1n.me/2023/02/27/python_asyncio_lib_asycio_sync_introduction/</id>
    <published>2023-02-27T15:33:18.000Z</published>
    <updated>2023-03-02T14:07:01.440Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前记"><a href="#前记" class="headerlink" title="前记"></a>前记</h2><p><code>Asyncio</code>的同步原语可以简化我们编写资源竞争的代码和规避资源竞争导致的Bug的出现。<br>但是由于协程的特性，在大部分业务代码中并不需要去考虑资源竞争的出现，导致<code>Asyncio</code>同步原语被使用的频率比较低，但是如果想机遇<code>Asyncio</code>编写框架则需要学习同步原语的使用。</p><span id="more"></span><h2 id="0-基础"><a href="#0-基础" class="headerlink" title="0.基础"></a>0.基础</h2><p>同步原语都是适用于某些条件下对某个资源的争夺，在代码中大部分的资源都是属于一个代码块，而<code>Python</code>对于代码块的管理的最佳实践是使用<code>with</code>语法，<code>with</code>语法实际上是调用了一个类中的<code>__enter__</code>和<code>__exit__</code>方法，比如下面的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__enter__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> <br>    <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__exit__</span>(<span class="hljs-params">self, exc_type, exc_val, exc_tb</span>):</span><br>        <span class="hljs-keyword">return</span> <br>    <br><br><span class="hljs-keyword">with</span> Demo():<br>    <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure><p>代码中的<code>Demo</code>类实现了<code>__enter__</code>和<code>__exit__</code>方法后，就可以被<code>with</code>语法调用，其中<code>__enter__</code>方法是进入代码块执行的逻辑，<code>__enxi__</code>方法是用于退出代码块(包括异常退出)的逻辑。这两个方法符合同步原语中对资源的争夺和释放，但是<code>__enter__</code>和<code>__exit__</code>两个方法都是不支持<code>await</code>调用的，为了解决这个问题，<code>Python</code>引入了<code>async with</code>语法。</p><p><code>async with</code>语法和<code>with</code>语法类似 ，我们只要编写一个拥有<code>__aenter__</code>和<code>__aexit__</code>方法的类，那么这个类就支持<code>asyncio with</code>语法了，如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> asyncio<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__aenter__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span><br><br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__aexit__</span>(<span class="hljs-params">self, exc_type, exc_val, exc_tb</span>):</span><br>        <span class="hljs-keyword">return</span><br><br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> Demo():<br>        <span class="hljs-keyword">pass</span><br><br><br>asyncio.run(main())<br></code></pre></td></tr></table></figure><p>其中，类中的<code>__aenter__</code>方法是进入代码块时执行的方法，<code>__aexit__</code>是退出代码块时执行的方法。</p><p>有了<code>async with</code>语法的加持，<code>asyncio</code>的同步原语使用起来会比较方便，所以<code>asyncio</code>中对资源争夺的同步原语都会继承于<code>_ContextManagerMixin</code>类：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">_ContextManagerMixin</span>:</span><br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__aenter__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">await</span> self.acquire()<br>        <span class="hljs-comment"># We have no use for the &quot;as ...&quot;  clause in the with</span><br>        <span class="hljs-comment"># statement for locks.</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br><br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__aexit__</span>(<span class="hljs-params">self, exc_type, exc, tb</span>):</span><br>        self.release()<br></code></pre></td></tr></table></figure><p>并实现了<code>acquire</code>和<code>release</code>方法，供<code>__aenter__</code>和<code>__aexit__</code>方法调用，同时我们在使用同步原语的时候尽量用到<code>async with</code>语法防止忘记释放资源的占用。</p><h2 id="1-Lock"><a href="#1-Lock" class="headerlink" title="1.Lock"></a>1.Lock</h2><p>由于协程的特性，在编写协程代码时基本上可以不考虑到锁的情况，但在一些情况下我们还是需要用到锁，并通过锁来维护并发时的数据安全性，如下例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> asyncio<br><br><br>share_data = &#123;&#125;<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sub</span>(<span class="hljs-params">i</span>):</span><br>    <span class="hljs-comment"># 赋上相同的key和value</span><br>    share_data[i] = i<br>    <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">0</span>)<br>    print(i, share_data[i] == i)<br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sub_add</span>(<span class="hljs-params">i</span>):</span><br>    <span class="hljs-comment"># 赋上的value值是原来的+1</span><br>    share_data[i] = i + <span class="hljs-number">1</span><br>    <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">0</span>)<br>    print(i, share_data[i] == i + <span class="hljs-number">1</span>)<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    <span class="hljs-comment"># 创建并发任务</span><br>    task_list = []<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):<br>        task_list.append(sub(i))<br>        task_list.append(sub_add(i))<br>    <span class="hljs-comment"># 并发执行</span><br>    <span class="hljs-keyword">await</span> asyncio.gather(*task_list)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    asyncio.run(main())<br></code></pre></td></tr></table></figure><p>在这个例子中程序会并发的执行<code>sub</code>和<code>sub_add</code>函数，他们是由不同的<code>asyncio.Task</code>驱动的，这意味着会出现这样一个场景。<br>当负责执行<code>sub(1)</code>函数的<code>asyncio.Task</code>在执行完<code>share_data[i]=i</code>后就执行<code>await asyncio.sleep(0)</code>从而主动让出控制权并交还给事件循环，等待事件循环的下一次调度。<br>不过事件循环不会空下来，而是马上安排下一个<code>asyncio.Task</code>执行，此时会先执行到<code>sub_add(1)</code>函数的<code>share_data[i] = i + 1</code>，并同样的在执行到<code>await asyncio.sleep(0)</code>的时候把控制权交会给事件循环。<br>这时候控制权会由事件循环转移给原先执行<code>sub(1)</code>函数的<code>asyncio.Task</code>，获取到控制权l后<code>sub(1)</code>函数的逻辑会继续走，但由于<code>share_data[i]</code>的数据已经被<code>share_data[i] = i + 1</code>修改了，导致最后执行<code>print</code>时，<code>share_data[i]</code>的数据已经变为脏数据，而不是原本想要的数据了。 </p><p>为了解决这个问题，我们可以使用<code>asyncio.Lock</code>来解决资源的冲突，如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> asyncio<br><br><br>share_data = &#123;&#125;<br><span class="hljs-comment"># 存放对应资源的锁</span><br>lock_dict = &#123;&#125;<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sub</span>(<span class="hljs-params">i</span>):</span><br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> lock_dict[i]:  <span class="hljs-comment"># &lt;-- 通过async with语句来控制锁的粒度</span><br>        share_data[i] = i<br>        <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">0</span>)<br>        print(i, share_data[i] == i)<br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sub_add</span>(<span class="hljs-params">i</span>):</span><br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> lock_dict[i]:<br>        share_data[i] = i + <span class="hljs-number">1</span><br>        <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">0</span>)<br>        print(i, share_data[i] == i + <span class="hljs-number">1</span>)<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    task_list = []<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):<br>        lock_dict[i] = asyncio.Lock()<br>        task_list.append(sub(i))<br>        task_list.append(sub_add(i))<br>    <span class="hljs-keyword">await</span> asyncio.gather(*task_list)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    asyncio.run(main())<br></code></pre></td></tr></table></figure><p>从例子可以看到<code>asyncio.Lock</code>的使用方法跟多线程的<code>Lock</code>差不多，通过<code>async with</code>语法来获取和释放锁，它的原理也很简单，主要做了如下几件事：</p><ul><li>1.确保某一协程获取锁后的执行期间，别的协程在获取锁时需要一直等待，直到执行完成并释放锁。</li><li>2.当有协程持有锁的时候，其他协程必须等待，直到持有锁的协程释放了锁。</li><li>2.确保所有协程能够按照获取的顺序获取到锁。</li></ul><p>这意味着需要有一个数据结构来维护当前持有锁的协程的和下一个获取锁协程的关系，同时也需要一个队列来维护多个获取锁的协程的唤醒顺序。</p><p><code>asyncio.Lock</code>跟其它<code>asyncio</code>功能的用法一样，使用<code>asyncio.Future</code>来同步协程之间锁的状态，使用<code>deque</code>维护协程间的唤醒顺序，源码如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Lockl</span>(<span class="hljs-params">_ContextManagerMixin, mixins._LoopBoundMixin</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        self._waiters = <span class="hljs-literal">None</span><br>        self._locked = <span class="hljs-literal">False</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">locked</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> self._locked<br><br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">acquire</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">not</span> self._locked <span class="hljs-keyword">and</span> (self._waiters <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">or</span> <span class="hljs-built_in">all</span>(w.cancelled() <span class="hljs-keyword">for</span> w <span class="hljs-keyword">in</span> self._waiters))):<br>            <span class="hljs-comment"># 目前没有其他协程持有锁，当前协程可以运行</span><br>            self._locked = <span class="hljs-literal">True</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br><br>        <span class="hljs-keyword">if</span> self._waiters <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            self._waiters = collections.deque()<br>        <span class="hljs-comment"># 创建属于自己的容器，并推送到`_waiters`这个双端队列中</span><br>        fut = self._get_loop().create_future()<br>        self._waiters.append(fut)<br><br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-keyword">try</span>:<br>                <span class="hljs-keyword">await</span> fut<br>            <span class="hljs-keyword">finally</span>:<br>                <span class="hljs-comment"># 如果执行完毕，需要把自己移除，防止被`wake_up_first`调用</span><br>                self._waiters.remove(fut)<br>        <span class="hljs-keyword">except</span> exceptions.CancelledError:<br>            <span class="hljs-comment"># 如果是等待的过程中被取消了，需要唤醒下一个调用`acquire`</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self._locked:<br>                self._wake_up_first()<br>            <span class="hljs-keyword">raise</span><br>        <span class="hljs-comment"># 持有锁</span><br>        self._locked = <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">release</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">if</span> self._locked:<br>            <span class="hljs-comment"># 释放锁</span><br>            self._locked = <span class="hljs-literal">False</span><br>            self._wake_up_first()<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">raise</span> RuntimeError(<span class="hljs-string">&#x27;Lock is not acquired.&#x27;</span>)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_wake_up_first</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self._waiters:<br>            <span class="hljs-keyword">return</span><br>        <span class="hljs-comment"># 获取还处于锁状态协程对应的容器</span><br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-comment"># 获取下一个等待获取锁的waiter</span><br>            fut = <span class="hljs-built_in">next</span>(<span class="hljs-built_in">iter</span>(self._waiters))<br>        <span class="hljs-keyword">except</span> StopIteration:<br>            <span class="hljs-keyword">return</span><br>        <span class="hljs-comment"># 设置容器为True,这样对应协程就可以继续运行了。</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> fut.done():<br>            fut.set_result(<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure><p>通过源码可以知道，锁主要提供了获取和释放的功能，对于获取锁需要区分两种情况：</p><ul><li>1:当有协程想要获取锁时会先判断锁是否被持有，如果当前锁没有被持有就直接返回，使协程能够正常运行。</li><li>2:如果协程获取锁时，锁发现自己已经被其他协程持有则创建一个属于当前协程的<code>asyncio.Future</code>，用来同步状态，并添加到<code>deque</code>中。</li></ul><p>而对于释放锁就比较简单，只要获取<code>deque</code>中的第一个<code>asyncio.Future</code>，并通过<code>fut.set_result(True)</code>进行标记，使<code>asyncio.Future</code>从<code>peding</code>状态变为<code>done</code>状态，这样一来，持有该<code>asyncio.Future</code>的协程就能继续运行，从而持有锁。</p><p>不过需要注意源码中<code>acquire</code>方法中对<code>CancelledError</code>异常进行捕获，再唤醒下一个锁，这是为了解决<code>acquire</code>方法执行异常导致锁一直被卡住的场景，通常情况下这能解决大部分的问题，但是如果遇到错误的封装时，我们需要亲自处理异常，并执行锁的唤醒。比如在通过继承<code>asyncio.Lock</code>编写一个超时锁时，最简单的实现代码如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> asyncio<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TimeoutLock</span>(<span class="hljs-params">asyncio.Lock</span>):</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, timeout, *, loop=<span class="hljs-literal">None</span></span>):</span><br>        self.timeout = timeout<br>        <span class="hljs-built_in">super</span>().__init__(loop=loop)<br>        <br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">acquire</span>(<span class="hljs-params">self</span>) -&gt; bool:</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> asyncio.wait_for(<span class="hljs-built_in">super</span>().acquire(), self.timeout)<br></code></pre></td></tr></table></figure><p>这份代码非常简单，他只需要在<code>__init__</code>方法传入<code>timeout</code>参数，并在<code>acuiqre</code>方法中通过<code>wait_for</code>来实现锁超时即可，现在假设<code>wait_for</code>方法是一个无法传递协程<code>cancel</code>的方法，且编写的<code>acquire</code>没有进行捕获异常再释放锁的操作，当异常发生的时候会导致锁一直被卡住。<br>为了解决这个问题，只需要对<code>TimeoutLock</code>的<code>acquire</code>方法添加异常捕获，并在捕获到异常时释放锁即可，代码如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TimeoutLock</span>(<span class="hljs-params">asyncio.Lock</span>):</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, timeout, *, loop=<span class="hljs-literal">None</span></span>):</span><br>        self.timeout = timeout<br>        <span class="hljs-built_in">super</span>().__init__(loop=loop)<br><br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">acquire</span>(<span class="hljs-params">self</span>) -&gt; bool:</span><br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> asyncio.wait_for(<span class="hljs-built_in">super</span>().acquire(), self.timeout)<br>        <span class="hljs-keyword">except</span> Exception:<br>            self._wake_up_first()<br>            <span class="hljs-keyword">raise</span><br></code></pre></td></tr></table></figure><h3 id="1-1-什么时候要使用锁"><a href="#1-1-什么时候要使用锁" class="headerlink" title="1.1.什么时候要使用锁"></a>1.1.什么时候要使用锁</h3><p>在<code>async</code>中判断是否需要使用<code>asyncio.Lock</code>很简单，就是判断这个资源会不会被多个协程使用，最简单的就是这个资源是否被多个协程使用，如下代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> asyncio <br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">demo</span>():</span><br>    cache = &#123;&#125;<br>    <span class="hljs-comment"># some code</span><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    asyncio.create_task(demo())<br>    asyncio.create_task(demo())<br>    <span class="hljs-comment"># some code</span><br><br><br>asyncio.run(main())<br></code></pre></td></tr></table></figure><p>这段代码的资源是<code>demo</code>函数的<code>cache</code>，由于他归属于<code>demo</code>函数，只能被<code>demo</code>函数中的其他代码读写，后面只要确保<code>demo</code>函数的逻辑只会被一个协程完整的执行，那么就不需要锁了，即使<code>demo</code>函数被两个<code>asyncio.Task</code>并发驱动。<br>但是如果<code>demo</code>函数被改为如下代码就不一样了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">demo</span>():</span><br>    cache = &#123;&#125;<br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_update</span>(<span class="hljs-params">key, value</span>):</span><br>        cache[key] = value<br>    asyncio.create(_update(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>))<br>    asyncio.create(_update(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>))<br></code></pre></td></tr></table></figure><p>这时候出现了两个<code>asyncio.Task</code>并发驱动到修改<code>cache</code>的<code>_update</code>函数，会出现资源冲突的情况，这时候就需要锁了。</p><p>所以判断资源需不需要锁的规则很简单，就是这个资源是否被多个<code>asyncio.Task</code>并发驱动，如果是则需要加锁。</p><h2 id="2-Event"><a href="#2-Event" class="headerlink" title="2.Event"></a>2.Event</h2><p><code>asyncio.Event</code>也是一个简单的同步原语，但它跟<code>asyncio.Lock</code>不一样，<code>asyncio.Lock</code>是确保每个资源只能被一个协程操作，而<code>asyncio.Event</code>是确保某个资源何时可以被协程操作，可以认为<code>asyncio.Lock</code>锁的是资源，<code>asyncio.Event</code>锁的是协程，所以<code>asyncio.Event</code>并不需要<code>acquire</code>来锁资源，<code>release</code>释放资源，所以也用不到<code>async with</code>语法。</p><p><code>asyncio.Event</code>的简单使用示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> asyncio<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sub</span>(<span class="hljs-params">event: asyncio.Event</span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>    <span class="hljs-keyword">await</span> event.wait()<br>    print(<span class="hljs-string">&quot;I&#x27;m Done&quot;</span>)<br><br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>() -&gt; <span class="hljs-keyword">None</span>:</span><br>    event = asyncio.Event()<br>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):<br>        asyncio.create_task(sub(event))<br>    <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">1</span>)<br>    event.<span class="hljs-built_in">set</span>()<br><br>asyncio.run(main())<br></code></pre></td></tr></table></figure><p>在这个例子中会先创建10个<code>asyncio.Task</code>来执行<code>sub</code>函数，但是所有<code>sub</code>函数都会在<code>event.wait</code>处等待，直到<code>main</code>函数中调用<code>event.set</code>后，所有的<code>sub</code>函数的<code>event.wait</code>会放行，使<code>sub</code>函数能继续执行。</p><p>可以看到<code>asyncio.Event</code>功能比较简单，它的源码实现也很简单，源码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Event</span>(<span class="hljs-params">mixins._LoopBoundMixin</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        self._waiters = collections.deque()<br>        self._value = <span class="hljs-literal">False</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">is_set</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> self._value<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">set</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self._value:<br>            <span class="hljs-comment"># 确保每次只能set一次</span><br>            self._value = <span class="hljs-literal">True</span><br>            <span class="hljs-comment"># 设置每个协程存放的容器为True，这样对应的协程就可以运行了</span><br>            <span class="hljs-keyword">for</span> fut <span class="hljs-keyword">in</span> self._waiters:<br>                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> fut.done():<br>                    fut.set_result(<span class="hljs-literal">True</span>)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">clear</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-comment"># 清理上一次的set</span><br>        self._value = <span class="hljs-literal">False</span><br><br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">wait</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">if</span> self._value:<br>            <span class="hljs-comment"># 如果设置了，就不需要等待了</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>        <span class="hljs-comment"># 否则需要创建一个容器，并需要等待容器完成</span><br>        fut = self._get_loop().create_future()<br>        self._waiters.append(fut)<br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-keyword">await</span> fut<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">finally</span>:<br>            self._waiters.remove(fut)<br></code></pre></td></tr></table></figure><p>通过源码可以看到<code>wait</code>方法主要是创建了一个<code>asyncio.Future</code>，并把它加入到<code>deque</code>队列后就一直等待着，而<code>set</code>方法被调用时会遍历整个<code>deque</code>队列，并把处于<code>peding</code>状态的<code>asyncio.Future</code>设置为<code>done</code>，这时其他在调用<code>event.wait</code>方法的协程就会得到放行。</p><blockquote><p>通过源码也可以看出，<code>asyncio.Event</code>并没有继承于<code>_ContextManagerMixin</code>，这是因为它锁的是协程，而不是资源。</p></blockquote><p><code>asyncio.Event</code>的使用频率比<code>asyncio.Lock</code>多许多，不过通常都会让<code>asyncio.Event</code>和其他数据结构进行封装再使用，比如实现一个服务器的优雅关闭功能，这个功能会确保服务器在等待n秒后或者所有连接都关闭后才关闭服务器，这个功能就可以使用<code>set</code>与<code>asyncio.Event</code>结合，如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> asyncio<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SetEvent</span>(<span class="hljs-params">asyncio.Event</span>):</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, *, loop=<span class="hljs-literal">None</span></span>):</span><br>        self._set = <span class="hljs-built_in">set</span>()<br>        <span class="hljs-built_in">super</span>().__init__(loop=loop)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span>(<span class="hljs-params">self, value</span>):</span><br>        self._set.add(value)<br>        self.clear()<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">remove</span>(<span class="hljs-params">self, value</span>):</span><br>        self._set.remove(value)<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self._set:<br>            self.<span class="hljs-built_in">set</span>()<br></code></pre></td></tr></table></figure><p>这个<code>SetEvent</code>结合了<code>set</code>和<code>SetEvent</code>的功能，当<code>set</code>有数据的时候，会通过<code>clear</code>方法使<code>SetEvent</code>变为等待状态，而<code>set</code>没数据的时候，会通过<code>set</code>方法使<code>SetEvent</code>变为无需等待的状态，所有调用<code>wait</code>的协程都可以放行，通过这种结合，<code>SetEvent</code>拥有了等待资源为空的功能。<br>接下来就可以用于服务器的优雅退出功能：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">mock_conn_io</span>() -&gt; <span class="hljs-keyword">None</span>:</span><br>    <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">1</span>)<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">conn_handle</span>(<span class="hljs-params">set_event: SetEvent</span>):</span><br>    task: asyncio.Task = asyncio.create_task(mock_conn_io())<br>    set_event.add(task)<br>    task.add_done_callback(<span class="hljs-keyword">lambda</span> t: set_event.remove(t))<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    set_event: SetEvent = SetEvent()<br>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):<br>        conn_handle(set_event)<br><br>    <span class="hljs-comment"># 假设这里收到了退出信号</span><br>    <span class="hljs-keyword">await</span> asyncio.wait(set_event.wait(), timeout=<span class="hljs-number">9</span>)<br><br><br>asyncio.run(main())<br></code></pre></td></tr></table></figure><p>在这个演示功能中，<code>mock_conn_io</code>用于模拟服务器的连接正在处理中，而<code>conn_handle</code>用于创建服务器连接，<code>main</code>则是先创建10个连接，并模拟在收到退出信号后等待资源为空或者超时才退出服务。</p><blockquote><p>这只是简单的演示，实际上的优雅关闭功能要考虑的东西不仅仅是这些。</p></blockquote><h2 id="4-Condition"><a href="#4-Condition" class="headerlink" title="4.Condition"></a>4.Condition</h2><blockquote><p>condition只做简单介绍</p></blockquote><p><code>asyncio.Condition</code>是同步原语中使用最少的一种，因为他使用情况很奇怪，而且大部分场景可以被其他写法代替，比如下面这个<a href="https://superfastpython.com/asyncio-condition-variable/#Notify_All_Waiting_Coroutines">例子</a>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> asyncio<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">task</span>(<span class="hljs-params">condition, work_list</span>):</span><br>    <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">1</span>)<br>    work_list.append(<span class="hljs-number">33</span>)<br>    print(<span class="hljs-string">&#x27;Task sending notification...&#x27;</span>)<br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> condition:<br>        condition.notify()<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    condition = asyncio.Condition()<br>    work_list = <span class="hljs-built_in">list</span>()<br>    print(<span class="hljs-string">&#x27;Main waiting for data...&#x27;</span>)<br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> condition:<br>        _ = asyncio.create_task(task(condition, work_list))<br>        <span class="hljs-keyword">await</span> condition.wait()<br>    print(<span class="hljs-string">f&#x27;Got data: <span class="hljs-subst">&#123;work_list&#125;</span>&#x27;</span>)<br><br><br>asyncio.run(main())<br><span class="hljs-comment"># &gt;&gt;&gt; Main waiting for data...</span><br><span class="hljs-comment"># &gt;&gt;&gt; Task sending notification...</span><br><span class="hljs-comment"># &gt;&gt;&gt; Got data: [33]</span><br></code></pre></td></tr></table></figure><p>在这个例子中可以看到，<code>notify</code>和<code>wait</code>方法只能在<code>async with condition</code>中可以使用，如果没有在<code>async with condition</code>中使用则会报错，同时这个示例代码有点复杂，没办法一看就知道执行逻辑是什么，其实这个逻辑可以转变成一个更简单的写法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> asyncio<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">task</span>(<span class="hljs-params">work_list</span>):</span><br>    <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">1</span>)<br>    work_list.append(<span class="hljs-number">33</span>)<br>    print(<span class="hljs-string">&#x27;Task sending notification...&#x27;</span>)<br>    <span class="hljs-keyword">return</span><br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    work_list = <span class="hljs-built_in">list</span>()<br>    print(<span class="hljs-string">&#x27;Main waiting for data...&#x27;</span>)<br>    _task = asyncio.create_task(task(work_list))<br>    <span class="hljs-keyword">await</span> _task<br>    print(<span class="hljs-string">f&#x27;Got data: <span class="hljs-subst">&#123;work_list&#125;</span>&#x27;</span>)<br><br><br>asyncio.run(main())<br><br><span class="hljs-comment"># &gt;&gt;&gt; Main waiting for data...</span><br><span class="hljs-comment"># &gt;&gt;&gt; Task sending notification...</span><br><span class="hljs-comment"># &gt;&gt;&gt; Got data: [33]</span><br></code></pre></td></tr></table></figure><p>通过这个代码可以看到这个写法更简单一点，而且更有逻辑性，而<code>condition</code>的写法却更有点<code>Go</code>协程写法/或者回调函数写法的感觉。<br>所以建议在认为自己的代码可能会用到<code>asyncio.Conditon</code>时需要先考虑到是否需要<code>asyncio.Codition</code>？是否有别的方案代替，如果没有才考虑去使用<code>asyncio.Conditon</code>k。</p><h2 id="5-Semaphore"><a href="#5-Semaphore" class="headerlink" title="5.Semaphore"></a>5.Semaphore</h2><p><code>asyncio.Semaphore</code>–信号量是同步原语中被使用最频繁的，大多数都是用在限流场景中，比如用在爬虫中和客户端网关中限制请求频率。</p><p><code>asyncio.Semaphore</code>可以认为是一个延缓触发的<code>asyncio.Lock</code>，<code>asyncio.Semaphore</code>内部会维护一个计数器，无论何时进行获取或释放，它都会递增或者递减(但不会超过边界值)，当计数器归零时，就会进入到锁的逻辑，但是这个锁逻辑会在计数器大于0的时候释放j，它的用法如下：`</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> asyncio<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    semaphore = asyncio.Semaphore(<span class="hljs-number">10</span>):<br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> semaphore:<br>        <span class="hljs-keyword">pass</span><br>    <br>    <br>asyncio.run(main())<br></code></pre></td></tr></table></figure><p>示例中代码通过<code>async with</code>来指明一个代码块（代码用<code>pass</code>代替），这个代码块是被<code>asyncio.Semaphore</code>管理的，每次协程在进入代码块时，<code>asyncio.Semaphore</code>的内部计数器就会递减一，而离开代码块则<code>asyncio.Semaphore</code>的内部计数器会递增一。<br>当有一个协程进入代码块时<code>asyncio.Semaphore</code>发现计数器已经为0了，则会使当前协程进入等待状态，直到某个协程离开这个代码块时，计数器会递增一，并唤醒等待的协程，使其能够进入代码块中继续执行。</p><p><code>asyncio.Semaphore</code>的源码如下，需要注意的是由于<code>asyncio.Semaphore</code>是一个延缓的<code>asyncio.Lock</code>，所以当调用一次<code>release</code>后可能会导致被唤醒的协程和刚进入代码块的协程起冲突，所以在<code>acquire</code>方法中要通过一个<code>while</code>循环来解决这个问题：`</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Semaphore</span>(<span class="hljs-params">_ContextManagerMixin, mixins._LoopBoundMixin</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, value=<span class="hljs-number">1</span></span>):</span><br>        <span class="hljs-keyword">if</span> value &lt; <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&quot;Semaphore initial value must be &gt;= 0&quot;</span>)<br>        self._value = value<br>        self._waiters = collections.deque()<br>        self._wakeup_scheduled = <span class="hljs-literal">False</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_wake_up_next</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">while</span> self._waiters:<br>            <span class="hljs-comment"># 按照放置顺序依次弹出容器 </span><br>            waiter = self._waiters.popleft()<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> waiter.done():<br>                <span class="hljs-comment"># 设置容器状态，使对应的协程可以继续执行</span><br>                waiter.set_result(<span class="hljs-literal">None</span>)<br>                <span class="hljs-comment"># 设置标记 </span><br>                self._wakeup_scheduled = <span class="hljs-literal">True</span><br>                <span class="hljs-keyword">return</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">locked</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> self._value == <span class="hljs-number">0</span><br><br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">acquire</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-comment"># 如果`self._wakeup_scheduled`为True或者value小于0</span><br>        <span class="hljs-keyword">while</span> self._wakeup_scheduled <span class="hljs-keyword">or</span> self._value &lt;= <span class="hljs-number">0</span>:<br>            <span class="hljs-comment"># 创建容器并等待执行完成</span><br>            fut = self._get_loop().create_future()<br>            self._waiters.append(fut)<br>            <span class="hljs-keyword">try</span>:<br>                <span class="hljs-keyword">await</span> fut<br>                self._wakeup_scheduled = <span class="hljs-literal">False</span><br>            <span class="hljs-keyword">except</span> exceptions.CancelledError:<br>                <span class="hljs-comment"># 如果被取消了，也要唤醒下一个协程</span><br>                self._wake_up_next()<br>                <span class="hljs-keyword">raise</span><br>        self._value -= <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">release</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-comment"># 释放资源占用，唤醒下一个协程。</span><br>        self._value += <span class="hljs-number">1</span><br>        self._wake_up_next()<br></code></pre></td></tr></table></figure><p>针对<code>asyncio.Semaphore</code>进行修改可以实现很多功能，比如基于信号量可以实现一个简单的协程池，这个协程池可以限制创建协程的量，当协程池满的时候就无法继续创建协程，只有协程中的协程执行完毕后才能继续创建(当然无法控制在协程中创建新的协程)，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> asyncio<br><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> Coroutine<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pool</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, max_concurrency: <span class="hljs-built_in">int</span></span>):</span><br>        self._semaphore: asyncio.Semaphore = asyncio.Semaphore(max_concurrency)<br><br><br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">create_task</span>(<span class="hljs-params">self, coro: Coroutine</span>) -&gt; asyncio.Task:</span><br>        <span class="hljs-keyword">await</span>  self._semaphore.acquire()<br>        task: asyncio.Task = asyncio.create_task(coro)<br>        task.add_done_callback(<span class="hljs-keyword">lambda</span> t: self._semaphore.release())<br>        <span class="hljs-keyword">return</span> task<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">demo</span>(<span class="hljs-params">cnt: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>    print(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;<span class="hljs-built_in">int</span>(time.time())&#125;</span> create <span class="hljs-subst">&#123;cnt&#125;</span> task...&quot;</span>)<br>    <span class="hljs-keyword">await</span>  asyncio.sleep(cnt)<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>() -&gt; <span class="hljs-keyword">None</span>:</span><br>    pool: Pool = Pool(<span class="hljs-number">3</span>)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):<br>        <span class="hljs-keyword">await</span> pool.create_task(demo(i))<br><br><br>asyncio.run(main())<br><span class="hljs-comment"># &gt;&gt;&gt; 1677517996 create 0 task...</span><br><span class="hljs-comment"># &gt;&gt;&gt; 1677517996 create 1 task...</span><br><span class="hljs-comment"># &gt;&gt;&gt; 1677517996 create 2 task...</span><br><span class="hljs-comment"># &gt;&gt;&gt; 1677517996 create 3 task...</span><br><span class="hljs-comment"># &gt;&gt;&gt; 1677517997 create 4 task...</span><br><span class="hljs-comment"># &gt;&gt;&gt; 1677517998 create 5 task...</span><br><span class="hljs-comment"># &gt;&gt;&gt; 1677517999 create 6 task...</span><br><span class="hljs-comment"># &gt;&gt;&gt; 1677518001 create 7 task...</span><br><span class="hljs-comment"># &gt;&gt;&gt; 1677518003 create 8 task...</span><br><span class="hljs-comment"># &gt;&gt;&gt; 1677518005 create 9 task...</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前记&quot;&gt;&lt;a href=&quot;#前记&quot; class=&quot;headerlink&quot; title=&quot;前记&quot;&gt;&lt;/a&gt;前记&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Asyncio&lt;/code&gt;的同步原语可以简化我们编写资源竞争的代码和规避资源竞争导致的Bug的出现。&lt;br&gt;但是由于协程的特性，在大部分业务代码中并不需要去考虑资源竞争的出现，导致&lt;code&gt;Asyncio&lt;/code&gt;同步原语被使用的频率比较低，但是如果想机遇&lt;code&gt;Asyncio&lt;/code&gt;编写框架则需要学习同步原语的使用。&lt;/p&gt;</summary>
    
    
    <content src="https://fastly.jsdelivr.net/gh/so1n/so1n_blog_photo@master/blog_photo/16550442517731649661119526images.png" type="image"/>
    
    
    <category term="Python Asyncio" scheme="http://so1n.me/categories/Python-Asyncio/"/>
    
    
    <category term="Python" scheme="http://so1n.me/tags/Python/"/>
    
    <category term="Asyncio" scheme="http://so1n.me/tags/Asyncio/"/>
    
  </entry>
  
  <entry>
    <title>Python Asyncio 库之asyncio.task常用函数详解</title>
    <link href="http://so1n.me/2022/12/08/python_asyncio_lib_asyncio.task_introduction/"/>
    <id>http://so1n.me/2022/12/08/python_asyncio_lib_asyncio.task_introduction/</id>
    <published>2022-12-08T15:33:18.000Z</published>
    <updated>2023-02-26T16:18:25.943Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前记"><a href="#前记" class="headerlink" title="前记"></a>前记</h2><p><code>Asyncio</code>在经过一段时间的发展以及获取<code>Curio</code>等第三方库的经验来提供更多的功能，目前高级功能也基本完善，但是相对于其他语言，<code>Python</code>的<code>Asyncio</code>高级功能还是不够的，但好在<code>Asyncio</code>的低级API也比较完善，开发者可以通过参考<code>Asyncio</code>高级API的例子来自己实现一些功能，同时也可以通过这些功能更加了解<code>Asyncio</code>的原理和避免踩到高级API的坑。</p><h2 id="0-基础"><a href="#0-基础" class="headerlink" title="0.基础"></a>0.基础</h2><p>在<a href="https://so1n.me/2022/06/08/python_asyncio_schedule/">《Python Asyncio调度原理》</a>中介绍了<code>Asyncio</code>的两种调度基本单位，<code>Handler</code>和<code>TimeHandler</code>，他们只能被<code>loop.call_xx</code>函数调用，开发者从表面上不知道他们的存在，他们和<code>loop.call_xx</code>属于事件循环的基础功能，但是这些操作都属于单一操作，需要开发者自己编写代码把他们的操作给串联起来。<br>而在<a href="https://so1n.me/2022/04/11/python's_waitable_objects_in_asyncio/">《Python的可等待对象在Asyncio的作用》</a>中介绍了协程链的发起者<code>asyncio.Task</code>能通过<code>loop.call_soon</code>跟事件循环进行交互，并串联整个协程链中可等待对象以及安排可等待对象的运行。<br>不过对于<code>loop.call_at</code>和<code>loop.call_later</code>仍需要开发者通过<code>asyncio.Future</code>来把<code>Timehandler</code>的执行结果与<code>asyncio.Task</code>给串联起来，比如休眠一秒的代码实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> asyncio<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    loop = asyncio.get_event_loop()<br>    f = asyncio.Future()<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_on_complete</span>():</span><br>        f.set_result(<span class="hljs-literal">True</span>)<br><br>    loop.call_later(<span class="hljs-number">1</span>, _on_complete)<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> f<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    <span class="hljs-keyword">import</span> time<br>    s_t = time.time()<br>    asyncio.run(main())<br>    print(time.time() - s_t)<br></code></pre></td></tr></table></figure><p>这段代码中<code>asyncio.Future</code>执行的是类似容器的功能，自己本身会接受各种状态，并把自己的状态同步给管理当前协程链的<code>asyncio.Task</code>，使<code>asyncio.Task</code>能管理其他类型的操作。</p><p>在<code>asyncio.tasks</code>模块中的所有功能函数的原理也差不多，他们接受的参数基本是都是可等待对象，然后通过<code>asyncio.Futurte</code>作为容器来同步调用端和可等待对象间的状态，也可以通过其他的一些方法把<code>asyncio.Task</code>的状态同步给可等待对象。</p><h2 id="1-休眠–asyncio-sleep"><a href="#1-休眠–asyncio-sleep" class="headerlink" title="1.休眠–asyncio.sleep"></a>1.休眠–asyncio.sleep</h2><p><code>asyncio.sleep</code>是一个常用的方法，开发者通过它可以很方便的让协程休眠设定的时间，它本身也非常简单，它的源码如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-meta">@types.coroutine</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__sleep0</span>():</span><br>    <span class="hljs-keyword">yield</span><br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sleep</span>(<span class="hljs-params">delay, result=<span class="hljs-literal">None</span></span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;Coroutine that completes after a given time (in seconds).&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">if</span> delay &lt;= <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">await</span> __sleep0()<br>        <span class="hljs-keyword">return</span> result<br><br>    loop = events.get_running_loop()<br>    future = loop.create_future()<br>    h = loop.call_later(delay,<br>                        futures._set_result_unless_cancelled,<br>                        future, result)<br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> future<br>    <span class="hljs-keyword">finally</span>:<br>        h.cancel()<br></code></pre></td></tr></table></figure><p>通过源码可以发现当设置的休眠时间等于小于0的时候，<code>sleep</code>只执行了<code>yield</code>，并不会执行其他逻辑，而在值大于0时会创建一个<code>Future</code>对象，接着就一直等待，直到<code>Future</code>对象被<code>loop.call_later</code>控制结束时才返回结果值。</p><p>需要注意的是，当<code>asyncio.sleep</code>在值为0时，<code>sleep</code>执行<code>yield</code>可以让<code>Task.__step</code>感知而让出控制权，这是最小的让出当前协程控制权的方法，所以我们在编写涉及到CPU比较多的时候或者消耗时间较长的函数时可以通过<code>asyncio.sleep(0)</code>来主动让出控制权，如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> asyncio<br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">demo</span>() -&gt; <span class="hljs-keyword">None</span>:</span><br>    <span class="hljs-keyword">for</span> index, i <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(<span class="hljs-built_in">range</span>(<span class="hljs-number">10000</span>)):<br>        <span class="hljs-keyword">if</span> index % <span class="hljs-number">100</span> == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">0</span>)<br>        ...  <span class="hljs-comment"># 假设这里的代码占用过多的CPU时间</span><br></code></pre></td></tr></table></figure><p>在这个例子中每循环100次就让出控制权，以减少对其他协程的影响。</p><h2 id="2-屏蔽取消–asyncio-shield"><a href="#2-屏蔽取消–asyncio-shield" class="headerlink" title="2.屏蔽取消–asyncio.shield"></a>2.屏蔽取消–asyncio.shield</h2><p><code>asyncio.shield</code>可以保护一个可等待对象被取消，或者说是防止协程链上的取消传播到被<code>asyncio.shield</code>托管的可等待对象，但是调用可等待对象的<code>cancel</code>方法仍然可以取消可等待对象的运行，如下例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> asyncio<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sub</span>(<span class="hljs-params">f</span>):</span><br>    <span class="hljs-keyword">await</span> asyncio.shield(f)<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    f1 = asyncio.Future()<br>    f2 = asyncio.Future()<br>    sub1 = asyncio.create_task(sub(f1))<br>    sub2 = asyncio.create_task(sub(f2))<br>    f1.cancel()<br>    sub2.cancel()<br>    <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">0</span>)  <span class="hljs-comment"># 确保已经取消完成</span><br>    print(<span class="hljs-string">&quot;f1 future run success:&quot;</span>, f1.done())<br>    print(<span class="hljs-string">&quot;f2 future run success:&quot;</span>, f2.done())<br>    print(<span class="hljs-string">&quot;sub1 future run result:&quot;</span>, sub1.done())<br>    print(<span class="hljs-string">&quot;sub2 future run result:&quot;</span>, sub2.done())<br><br>asyncio.run(main())<br><br><span class="hljs-comment"># &gt;&gt;&gt; future run success: True</span><br><span class="hljs-comment"># &gt;&gt;&gt; future run success: False</span><br><span class="hljs-comment"># &gt;&gt;&gt; sub1 future run result: True</span><br><span class="hljs-comment"># &gt;&gt;&gt; sub2 future run result: True</span><br></code></pre></td></tr></table></figure><p>其中<code>f1</code>, <code>f2</code>都在<code>main</code>函数中创建， 然后同时被<code>sub</code>函数包裹，并通过<code>asyncio.create_task</code>在后台异步运行并分别返回<code>sub1</code>和<code>sub2</code>两个<code>Future</code>对应着<code>sub</code>函数的执行情况。<br>接着分别取消<code>f1</code>和<code>sub2</code>的执行，并把<code>f1</code>,<code>f2</code>,<code>sub1</code>,<code>sub2</code>是否为<code>done</code>打印出来，可以发现<code>f1</code>,<code>sub1</code>,<code>sub2</code>的状态都为<code>done</code>（被取消也认为是done)，而<code>f2</code>则还在运行中。</p><p>在文章<a href="https://so1n.me/2022/04/11/python's_waitable_objects_in_asyncio/">《Python的可等待对象在Asyncio的作用》</a>中说过，一条协程链是由<code>asyncio.Task</code>牵头组成的，后续的所有成功和异常都会在这条链上传播，而取消本质上就是一种异常，所以也可以在协程链上传播。<br>而<code>shield</code>为了杜绝运行的可等待对象收到协程链的异常传播又能让协程链知道可等待对象的执行结果，会先让可等待对象在另外一条协程链运行，然后创建一个容器接到原来链上，并在可等待对象执行完成的时候把结果告诉容器，由容器把结果传播到原有的协程链上，对应的源码如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">shield</span>(<span class="hljs-params">arg</span>):</span><br>    <span class="hljs-comment"># 如果是Coro，则需要包装成future</span><br>    inner = _ensure_future(arg)<br>    <span class="hljs-keyword">if</span> inner.done():<br>        <span class="hljs-comment"># 如果已经完成，就不需要被处理了</span><br>        <span class="hljs-keyword">return</span> inner<br>    loop = futures._get_loop(inner)<br>    <span class="hljs-comment"># 创建一个future容器</span><br>    outer = loop.create_future()<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_inner_done_callback</span>(<span class="hljs-params">inner</span>):</span><br>        <span class="hljs-keyword">if</span> outer.cancelled():<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> inner.cancelled():<br>                <span class="hljs-comment"># 如果容器已经被取消，而自己没被取消且已经完成，则手动获取下结果，方便被回收</span><br>                inner.exception()<br>            <span class="hljs-keyword">return</span><br><br>        <span class="hljs-keyword">if</span> inner.cancelled():<br>            <span class="hljs-comment"># 如果自己被取消，则把取消通过容器传播到协程链上</span><br>            outer.cancel()<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-comment"># 自己已经完成且容器未完成，把自己的结果或者异常通过替身传播到协程链上</span><br>            exc = inner.exception()<br>            <span class="hljs-keyword">if</span> exc <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>                outer.set_exception(exc)<br>            <span class="hljs-keyword">else</span>:<br>                outer.set_result(inner.result())<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_outer_done_callback</span>(<span class="hljs-params">outer</span>):</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> inner.done():<br>            inner.remove_done_callback(_inner_done_callback)<br><br>    <span class="hljs-comment"># 添加回调，在执行成功或被取消时通知对方</span><br>    inner.add_done_callback(_inner_done_callback)<br>    outer.add_done_callback(_outer_done_callback)<br>    <span class="hljs-keyword">return</span> outer<br></code></pre></td></tr></table></figure><p>通过源码可以发现<code>shield</code>被调用的时候(假设驱动调用<code>shield</code>的<code>Task</code>名为<code>main.Task</code>)，会先通过<code>_ensure_future</code>辅助函数创建一个<code>Task</code>(<code>other.Task</code>)在后台异步运行可等待对象，驱动可等待对象的运行，由于是新的<code>Task</code>驱动着可等待对象的执行，所以<code>main.Task</code>的任何状态不会传播到当前的可等待对象。<br>接着创建一个<code>Future</code>容器，并在<code>other.Task</code>和<code>Future</code>容器挂上完成的回调使他们在完成的时候都能通知到对方，最后返回<code>Future</code>容器给<code>main.Task</code>，使<code>main.Task</code>能够间接的知道可等待对象的运行结果，如下图：<br><img   class="lazyload" data-original="https://fastly.jsdelivr.net/gh/so1n/so1n_blog_photo@master/blog_photo/16703080357051670308034840.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" ></p><p>不过<code>Future</code>容器完成的回调只是把托管可等待对象的<code>other.Task</code>回调给移除了，导致<code>main.Task</code>的状态不会同步到<code>other.Task</code>中(图中<code>Future</code>通知可等待对象<code>aws</code>的通道是不通的)，进而不会影响到托管的可等待对象。<br>而<code>other.Task</code>完成的回调会把任何状态同步到<code>Future</code>中，进而影响到<code>main.Task</code>。</p><h2 id="3-超时–asyncio-wait-for"><a href="#3-超时–asyncio-wait-for" class="headerlink" title="3.超时–asyncio.wait_for"></a>3.超时–asyncio.wait_for</h2><p><code>asyncio.wait_for</code>可以托管可等待对象，直到可等待对象完成，不过可等待对象在设定的时间内还没执行完成时会被直接取消执行并抛出<code>asyncio.TimeoutError</code>异常。<br>它的运行原理综合了上面的<code>asyncio.shield</code>和<code>asyncio.sleep</code>，它一样会为可等待对象创建一个<code>Future</code>容器,并在容器上挂了一个超时的回调和可等待对象执行结束的回调，接着就等待容器执行结束。<br>不过在了解<code>asyncio.wait_for</code>之前，先了解他用到的两个辅助函数<code>_cancel_and_wait</code>和<code>_release_waiter</code>，他们的源码如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_release_waiter</span>(<span class="hljs-params">waiter, *args</span>):</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> waiter.done():<br>        waiter.set_result(<span class="hljs-literal">None</span>)<br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_cancel_and_wait</span>(<span class="hljs-params">fut, loop</span>):</span><br>    waiter = loop.create_future()<br>    cb = functools.partial(_release_waiter, waiter)<br>    fut.add_done_callback(cb)<br><br>    <span class="hljs-keyword">try</span>:<br>        fut.cancel()<br>        <span class="hljs-keyword">await</span> waiter<br>    <span class="hljs-keyword">finally</span>:<br>        fut.remove_done_callback(cb)<br></code></pre></td></tr></table></figure><p>可以看出源码比较简单，他们的作用都是为了确保可等待对象能完全执行结束才返回，其中<code>_release_waiter</code>是确保可等待对象一定被设置为执行结束，而<code>_cancel_and_wait</code>是为了确保能等到可等待对象被取消且完整结束时才返回。</p><blockquote><p>可等待对象的<code>cancel</code>方法可以认为是异步的，调用后需要等事件循环再次调用可等待对象时，可等待对象才会被取消。而<code>_cancel_and_wait</code>通过一个容器来规避这个问题，使取消这个操作变为同步的，这个方法在某些开发场景经常被使用，如果不是私有API就更好了。</p></blockquote><p>接下来就可以通过<code>wait_for</code>的源码了解他的执行逻辑了，源码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">wait_for</span>(<span class="hljs-params">fut, timeout</span>):</span><br>    loop = events.get_running_loop()<br><br>    <span class="hljs-keyword">if</span> timeout <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> fut<br><br>    <span class="hljs-keyword">if</span> timeout &lt;= <span class="hljs-number">0</span>:<br>        <span class="hljs-comment"># 当超时的值小于等于0时就意味着想马上得到结果</span><br>        <br>        fut = ensure_future(fut, loop=loop)<br><br>        <span class="hljs-keyword">if</span> fut.done():<br>            <span class="hljs-comment"># 如果执行完成就返回可等待对象的数据</span><br>            <span class="hljs-keyword">return</span> fut.result()<br>        <span class="hljs-comment"># 取消可等待对象并等待</span><br>        <span class="hljs-keyword">await</span> _cancel_and_wait(fut, loop=loop)<br>        <span class="hljs-comment"># 如果被_cancel_and_wait取消，那么会抛出CancelledError异常，这时候把它转为超时异常</span><br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-keyword">return</span> fut.result()<br>        <span class="hljs-keyword">except</span> exceptions.CancelledError <span class="hljs-keyword">as</span> exc:<br>            <span class="hljs-keyword">raise</span> exceptions.TimeoutError() <span class="hljs-keyword">from</span> exc<br><br>    <span class="hljs-comment"># 初始化一个Future,只有在超时和完成时才会变为done</span><br>    waiter = loop.create_future()<br>    timeout_handle = loop.call_later(timeout, _release_waiter, waiter)<br>    cb = functools.partial(_release_waiter, waiter)<br><br>    fut = ensure_future(fut, loop=loop)<br>    fut.add_done_callback(cb)<br><br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-keyword">await</span> waiter<br>        <span class="hljs-keyword">except</span> exceptions.CancelledError:<br>            <span class="hljs-comment"># 此时是asyncio.Task被取消，并把取消传播到waiter</span><br>            <span class="hljs-keyword">if</span> fut.done():<br>                <span class="hljs-keyword">return</span> fut.result()<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-comment"># 如果任务被取消了，那么需要确保任务没有被执行才返回</span><br>                fut.remove_done_callback(cb)<br>                <span class="hljs-keyword">await</span> _cancel_and_wait(fut, loop=loop)<br>                <span class="hljs-keyword">raise</span><br>        <span class="hljs-comment"># 计时结束或者是执行完毕的情况</span><br>        <span class="hljs-keyword">if</span> fut.done():<br>            <span class="hljs-comment"># 执行完毕，返回对应的值</span><br>            <span class="hljs-keyword">return</span> fut.result()<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-comment"># 计时结束，清理资源，并抛出异常</span><br>            fut.remove_done_callback(cb)<br>            <span class="hljs-comment"># 如果任务被取消了，那么需要确保任务没有被执行才返回</span><br>            <span class="hljs-keyword">await</span> _cancel_and_wait(fut, loop=loop)<br>            <span class="hljs-comment"># 如果被_cancel_and_wait取消，那么会抛出CancelledError异常，这时候把它转为超时异常</span><br>            <span class="hljs-keyword">try</span>:<br>                <span class="hljs-keyword">return</span> fut.result()<br>            <span class="hljs-keyword">except</span> exceptions.CancelledError <span class="hljs-keyword">as</span> exc:<br>                <span class="hljs-keyword">raise</span> exceptions.TimeoutError() <span class="hljs-keyword">from</span> exc<br>    <span class="hljs-keyword">finally</span>:<br>        timeout_handle.cancel()<br></code></pre></td></tr></table></figure><p><code>wait_for</code>的源码为了兼容各种情况，代码复杂度比较高，同时超时参数小于等于0跟大于0的逻辑是一样的，分开写只是为了避免在小于等于0时创建了一些额外的对象，在精简了一些<code>asyncio.Task</code>传播异常给<code>waiter</code>的逻辑后，<code>wait_for</code>的执行逻辑如下图：<br><img   class="lazyload" data-original="https://fastly.jsdelivr.net/gh/so1n/so1n_blog_photo@master/blog_photo/16703111707771670311170743.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" ></p><blockquote><p>fut为可等待对象，timeout为超时时间</p></blockquote><p>可以看到<code>wait_for</code>的主要逻辑是先创建一个名为<code>waiter</code>的容器，接着通过<code>loop.call_later</code>指定在多少时间后释放容器，然后再通过<code>ensure_future</code>使另一个<code>asyncio.Task</code>来托管可等待对象，并安排执行完毕的时候释放容器，再等待<code>waiter</code>容器的执行直到被释放。当容器被释放的时候再判断可等待对象是否执行完毕，如果执行完毕了就直接返回，否则抛出超时异常。</p><h2 id="4-简单的等待–wait"><a href="#4-简单的等待–wait" class="headerlink" title="4.简单的等待–wait"></a>4.简单的等待–wait</h2><p><code>asyncio.wait</code>用于等待一批可等待对象，当有一个可等待对象执行完成或者出现异常的时候才会返回数据(具体还是要看<code>return_when</code>指定的条件，默认为所有等待对象结束或取消时才返回)，需要注意的是<code>wait</code>虽然支持<code>timeout</code>参数，但是在超时的试试不会取消可等待对象，也不会抛出超时的异常，只会把完成的可等待对象放在完成的集合，把未完成的可等待对象放在未完成的集合并返回，如下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> asyncio<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> asyncio.wait(<br>        &#123;asyncio.create_task(asyncio.sleep(<span class="hljs-number">1</span>))&#125;,<br>        timeout=<span class="hljs-number">0.5</span><br>    )<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    asyncio.run(main())<br></code></pre></td></tr></table></figure><p>这段代码可以正常的运作，不会抛出超时错，不过还要注意的是在后续版本中<code>asyncio.wait</code>只支持<code>Task</code>对象，如果想要传入的是<code>coro</code>和<code>Future</code>对象，则需要开发者自己手动转换。<br><code>wait</code>的逻辑与<code>wait_for</code>类似，源码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_wait</span>(<span class="hljs-params">fs, timeout, return_when, loop</span>):</span><br>    <span class="hljs-keyword">assert</span> fs, <span class="hljs-string">&#x27;Set of Futures is empty.&#x27;</span><br>    waiter = loop.create_future()<br>    timeout_handle = <span class="hljs-literal">None</span><br>    <span class="hljs-keyword">if</span> timeout <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>        <span class="hljs-comment"># 定义一个time handler,在timeout秒后通过`_release_waiter`完成.</span><br>        timeout_handle = loop.call_later(timeout, _release_waiter, waiter)<br>    counter = <span class="hljs-built_in">len</span>(fs)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_on_completion</span>(<span class="hljs-params">f</span>):</span><br>        <span class="hljs-comment"># 每个可等待对象执行完成的回调</span><br>        <span class="hljs-keyword">nonlocal</span> counter<br>        counter -= <span class="hljs-number">1</span><br>        <span class="hljs-keyword">if</span> (counter &lt;= <span class="hljs-number">0</span> <span class="hljs-keyword">or</span><br>            return_when == FIRST_COMPLETED <span class="hljs-keyword">or</span><br>            return_when == FIRST_EXCEPTION <span class="hljs-keyword">and</span><br>             (<span class="hljs-keyword">not</span> f.cancelled() <span class="hljs-keyword">and</span> f.exception() <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>)<br>        ):<br>            <span class="hljs-comment"># 如果所有任务执行完成，或者是第一个完成或者是第一个抛出异常时，</span><br>            <span class="hljs-comment"># 意味着执行完成，需要取消time handler,并标记为完成</span><br>            <span class="hljs-keyword">if</span> timeout_handle <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>                timeout_handle.cancel()<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> waiter.done():<br>                waiter.set_result(<span class="hljs-literal">None</span>)<br>    <span class="hljs-comment"># 为每个可等待对象添加回调</span><br>    <span class="hljs-keyword">for</span> f <span class="hljs-keyword">in</span> fs:<br>        f.add_done_callback(_on_completion)<br><br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-comment"># 等待替身执行完成</span><br>        <span class="hljs-keyword">await</span> waiter<br>    <span class="hljs-keyword">finally</span>:<br>        <span class="hljs-comment"># 取消time handler并移除回调(因为cancel是异步的)</span><br>        <span class="hljs-keyword">if</span> timeout_handle <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            timeout_handle.cancel()<br>        <span class="hljs-keyword">for</span> f <span class="hljs-keyword">in</span> fs:<br>            f.remove_done_callback(_on_completion)<br><br>    <span class="hljs-comment"># 处理并返回done和pending，其中done代表完成，pending代表执行中。</span><br>    done, pending = <span class="hljs-built_in">set</span>(), <span class="hljs-built_in">set</span>()<br>    <span class="hljs-keyword">for</span> f <span class="hljs-keyword">in</span> fs:<br>        <span class="hljs-keyword">if</span> f.done():<br>            done.add(f)<br>        <span class="hljs-keyword">else</span>:<br>            pending.add(f)<br>    <span class="hljs-keyword">return</span> done, pending<br></code></pre></td></tr></table></figure><p>可以看到<code>wait_for</code>的复杂度没有<code>wait</code>高，而且可以看到<code>asyncio.wait</code>是等<code>waiter</code>这个容器执行完并移除可等待对象上面的<code>_on_completion</code>回调后才把可等待对象按照是否完成区分到<code>done</code>和<code>pending</code>两个集合，这样的准确度比在<code>_on_completion</code>高一些，但是如果开发者在处理集合时触发一些异步操作也可能导致<code>pending</code>集合中的部分可等待对象变为完成的，如下代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> asyncio<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    f_list = [asyncio.Future() <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>)]<br>    done, pending = <span class="hljs-keyword">await</span> asyncio.wait(f_list, timeout=<span class="hljs-number">1</span>)<br>    print(<span class="hljs-built_in">len</span>(done), <span class="hljs-built_in">len</span>(pending))<br>    print([i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> pending <span class="hljs-keyword">if</span> i.done()])<br>    f_list[<span class="hljs-number">1</span>].set_result(<span class="hljs-literal">True</span>)<br>    print([i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> pending <span class="hljs-keyword">if</span> i.done()])<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    asyncio.run(main())<br><span class="hljs-comment"># &gt;&gt;&gt; 0 10</span><br><span class="hljs-comment"># &gt;&gt;&gt; []</span><br><span class="hljs-comment"># &gt;&gt;&gt; [&lt;Future finished result=True&gt;]</span><br></code></pre></td></tr></table></figure><p>通过输出可以发现，在<code>asyncio.wait</code>执行完毕后，<code>pending</code>中的完成的元素只有0个，而在后续强制为其中的一个<code>Future</code>设置数据后，<code>pending</code>中完成的元素有1个了。</p><h2 id="5-迭代可等待对象的完成–asyncio-as-completed"><a href="#5-迭代可等待对象的完成–asyncio-as-completed" class="headerlink" title="5.迭代可等待对象的完成–asyncio.as_completed"></a>5.迭代可等待对象的完成–asyncio.as_completed</h2><p><code>asyncio.wait</code>的机制是只要被触发就会返回，其他尚未完成的可等待对象需要开发者自己在处理，而<code>asyncio.as_completed</code>可以确保每个可等待对象完成返回数据或者超时时抛出异常，使用方法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> asyncio<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sub</span>(<span class="hljs-params">i</span>):</span><br>    <span class="hljs-keyword">await</span> asyncio.sleep(i)<br>    <span class="hljs-keyword">return</span> i<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    <span class="hljs-keyword">for</span> f <span class="hljs-keyword">in</span> asyncio.as_completed([sub(i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>)], timeout=<span class="hljs-number">3</span>):<br>        print(<span class="hljs-keyword">await</span> f)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    asyncio.run(main())<br><span class="hljs-comment"># &gt;&gt;&gt; 0</span><br><span class="hljs-comment"># &gt;&gt;&gt; 1</span><br><span class="hljs-comment"># &gt;&gt;&gt; 2</span><br><span class="hljs-comment"># &gt;&gt;&gt; Traceback (most recent call last):</span><br><span class="hljs-comment">#       File &quot;/home/so1n/github/demo_project/demo.py&quot;, line 18, in &lt;module&gt;</span><br><span class="hljs-comment">#         asyncio.run(main())</span><br><span class="hljs-comment">#       File &quot;/usr/lib/python3.7/asyncio/runners.py&quot;, line 43, in run</span><br><span class="hljs-comment">#         return loop.run_until_complete(main)</span><br><span class="hljs-comment">#       File &quot;/usr/lib/python3.7/asyncio/base_events.py&quot;, line 584, in run_until_complete</span><br><span class="hljs-comment">#         return future.result()</span><br><span class="hljs-comment">#       File &quot;/home/so1n/github/demo_project/demo.py&quot;, line 14, in main</span><br><span class="hljs-comment">#         print(await f)</span><br><span class="hljs-comment">#       File &quot;/usr/lib/python3.7/asyncio/tasks.py&quot;, line 532, in _wait_for_one</span><br><span class="hljs-comment">#         raise futures.TimeoutError</span><br><span class="hljs-comment">#     concurrent.futures._base.TimeoutError</span><br></code></pre></td></tr></table></figure><p>该程序并发执行5个协程，其中执行最久的时间是5秒，而<code>as_completed</code>设置的超时为3秒。通过输出可以发现，每当一个可等待对象执行结束时就会把数据抛出来，当超时则会抛出超时错误。为了能达每有一个可等待对象就返回一次数据的效果，<code>as_completed</code>通过一个队列来维护数据的返回，它的源码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">as_completed</span>(<span class="hljs-params">fs, *, timeout=<span class="hljs-literal">None</span></span>):</span><br>    <span class="hljs-keyword">from</span> .queues <span class="hljs-keyword">import</span> Queue  <span class="hljs-comment"># Import here to avoid circular import problem.</span><br>    done = Queue()<br><br>    loop = events._get_event_loop()<br>    todo = &#123;ensure_future(f, loop=loop) <span class="hljs-keyword">for</span> f <span class="hljs-keyword">in</span> <span class="hljs-built_in">set</span>(fs)&#125;<br>    timeout_handle = <span class="hljs-literal">None</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_on_timeout</span>():</span><br>        <span class="hljs-comment"># 超时时调用，需要注意的是，失败时结果为空，所以要推送一个空的数据到队列中</span><br>        <span class="hljs-comment"># 在消费者发现元素为空时抛出错误</span><br>        <span class="hljs-keyword">for</span> f <span class="hljs-keyword">in</span> todo:<br>            f.remove_done_callback(_on_completion)<br>            done.put_nowait(<span class="hljs-literal">None</span>)  <span class="hljs-comment"># Queue a dummy value for _wait_for_one().</span><br>        todo.clear()  <span class="hljs-comment"># Can&#x27;t do todo.remove(f) in the loop.</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_on_completion</span>(<span class="hljs-params">f</span>):</span><br>        <span class="hljs-comment"># 如果成功，就把Future推送到队列中，消费者可以通过Future获取到结果</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> todo:<br>            <span class="hljs-keyword">return</span>  <span class="hljs-comment"># _on_timeout() was here first.</span><br>        todo.remove(f)<br>        done.put_nowait(f)<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> todo <span class="hljs-keyword">and</span> timeout_handle <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            timeout_handle.cancel()<br><br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_wait_for_one</span>():</span><br>        f = <span class="hljs-keyword">await</span> done.get()<br>        <span class="hljs-keyword">if</span> f <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-comment"># 如果元素为空，则证明已经超时了，要抛出异常</span><br>            <span class="hljs-keyword">raise</span> exceptions.TimeoutError<br>        <span class="hljs-keyword">return</span> f.result()<br><br>    <span class="hljs-keyword">for</span> f <span class="hljs-keyword">in</span> todo:<br>        f.add_done_callback(_on_completion)<br>    <span class="hljs-keyword">if</span> todo <span class="hljs-keyword">and</span> timeout <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>        timeout_handle = loop.call_later(timeout, _on_timeout)<br>    <span class="hljs-comment"># 通过生成器语法返回协程函数，该协程函数可以获取最近完成的可等待对象的结果</span><br>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(todo)):<br>        <span class="hljs-keyword">yield</span> _wait_for_one()<br><br></code></pre></td></tr></table></figure><p>通过源码可以发现可等待对象就像生产者一样，执行结束的时候就会把结果投递给队列，同时<code>as_completed</code>会迭代跟可等待对象的数量一样的<code>_wait_for_one</code>协程函数，供开发者消费数据。不过需要注意的是<code>as_completed</code>在超时的时候，并不会取消尚未完成的可等待对象，他们会变为不可控的状态，在某些时候会造成内存溢出，如下示例代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> asyncio<br><span class="hljs-keyword">import</span> random<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sub</span>():</span><br>    <span class="hljs-comment"># 一半的几率会被set一个值并返回，一半的几率会卡死</span><br>    f = asyncio.Future()<br>    <span class="hljs-keyword">if</span> random.choice([<span class="hljs-number">0</span>, <span class="hljs-number">1</span>]) == <span class="hljs-number">0</span>:<br>        f.set_result(<span class="hljs-literal">None</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> f<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-keyword">for</span> f <span class="hljs-keyword">in</span> asyncio.as_completed([sub() <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>)], timeout=<span class="hljs-number">1</span>):<br>            print(<span class="hljs-keyword">await</span> f)<br>    <span class="hljs-keyword">except</span> asyncio.TimeoutError:<br>        <span class="hljs-comment"># 忽略超时</span><br>        <span class="hljs-keyword">pass</span><br>    <span class="hljs-comment"># 统计未完成的sub任务</span><br>    cnt = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> asyncio.all_tasks():<br>        <span class="hljs-keyword">if</span> i._coro.__name__ == sub.__name__:<br>            cnt += <span class="hljs-number">1</span><br>    print(<span class="hljs-string">&quot;runing task by name sub:&quot;</span>, cnt)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    asyncio.run(main())<br><span class="hljs-comment"># &gt;&gt;&gt; None</span><br><span class="hljs-comment"># &gt;&gt;&gt; None</span><br><span class="hljs-comment"># &gt;&gt;&gt; None</span><br><span class="hljs-comment"># &gt;&gt;&gt; runing task by name sub: 2</span><br></code></pre></td></tr></table></figure><p>通过结果(由于采用随机，结果可能不一样)可以发现，<code>sub</code>成功执行完成的数量有3个(输出<code>None</code>)，而在<code>as_completed</code>触发超时后仍有两个<code>sub</code>在执行中，这时的两个<code>sub</code>成为无人管理的可等待对象，除非开发者通过<code>asyncio.all_tasks</code>去找到他并清理掉，否则这几个可等待对象会一直伴随着程序运行，这很容易造成内存溢出。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前记&quot;&gt;&lt;a href=&quot;#前记&quot; class=&quot;headerlink&quot; title=&quot;前记&quot;&gt;&lt;/a&gt;前记&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Asyncio&lt;/code&gt;在经过一段时间的发展以及获取&lt;code&gt;Curio&lt;/code&gt;等第三方库的经验来提供更多的功能，目</summary>
      
    
    
    <content src="https://fastly.jsdelivr.net/gh/so1n/so1n_blog_photo@master/blog_photo/16550442517731649661119526images.png" type="image"/>
    
    
    <category term="Python Asyncio" scheme="http://so1n.me/categories/Python-Asyncio/"/>
    
    
    <category term="Python" scheme="http://so1n.me/tags/Python/"/>
    
    <category term="Asyncio" scheme="http://so1n.me/tags/Asyncio/"/>
    
  </entry>
  
  <entry>
    <title>Python-gRPC实践(9)--gRPC在gevent与asyncio的简单使用对比.md</title>
    <link href="http://so1n.me/2022/11/25/Python-gRPC%E5%AE%9E%E8%B7%B5(9)--gRPC%E5%9C%A8gevent%E4%B8%8Easyncio%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%E5%92%8C%E5%AF%B9%E6%AF%94/"/>
    <id>http://so1n.me/2022/11/25/Python-gRPC%E5%AE%9E%E8%B7%B5(9)--gRPC%E5%9C%A8gevent%E4%B8%8Easyncio%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%E5%92%8C%E5%AF%B9%E6%AF%94/</id>
    <published>2022-11-25T12:35:24.000Z</published>
    <updated>2022-11-29T09:55:59.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前在<a href="https://so1n.me/categories/Python-gRPC%E5%AE%9E%E8%B7%B5/">Python-gRPC实践</a>系列文章中都是在多线程模式中介绍如何使用<code>gRPC</code>，但是在<code>Python</code>生态中更偏好通过协程的方式来运行服务，而<code>Python</code>的协程运行方式却有多种，虽然他们的原理类似，但是使用上却有区别，本文主要是对在<code>gevent</code>和<code>asyncio</code>中对<code>gRPC</code>的使用进行对比。</p><h2 id="1-简单的例子"><a href="#1-简单的例子" class="headerlink" title="1.简单的例子"></a>1.简单的例子</h2><p>本章以官方中的<a href="https://github.com/grpc/grpc/blob/master/examples/protos/helloworld.proto">helloworld</a> <code>Protobuf</code>文件为例子，介绍在不同协程中如何运行服务，该<code>Protobuf</code>文件内容如下:</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs protobuf"><span class="hljs-class"><span class="hljs-keyword">service</span> <span class="hljs-title">Greeter</span> </span>&#123;<br>  <span class="hljs-comment">// Sends a greeting</span><br>  <span class="hljs-function"><span class="hljs-keyword">rpc</span> SayHello (HelloRequest) <span class="hljs-keyword">returns</span> (HelloReply) </span>&#123;&#125;<br>&#125;<br><br><span class="hljs-comment">// The request message containing the user&#x27;s name.</span><br><span class="hljs-class"><span class="hljs-keyword">message</span> <span class="hljs-title">HelloRequest</span> </span>&#123;<br>  <span class="hljs-built_in">string</span> name = <span class="hljs-number">1</span>;<br>  <span class="hljs-built_in">int32</span> sleep_millisecond = <span class="hljs-number">2</span>;<br>&#125;<br><br><span class="hljs-comment">// The response message containing the greetings</span><br><span class="hljs-class"><span class="hljs-keyword">message</span> <span class="hljs-title">HelloReply</span> </span>&#123;<br>  <span class="hljs-built_in">string</span> <span class="hljs-class"><span class="hljs-keyword">message</span> = 1;</span><br><span class="hljs-class">&#125;</span><br></code></pre></td></tr></table></figure><p>其中<code>HelloRequest</code>和<code>HelloReply</code>是<code>Message</code>，<code>Gretter</code>为<code>service</code>，它们生成的对应代码位于<code>grpc_asyncio_example/protos</code>目录下面，而对应的客户端代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> logging<br><span class="hljs-keyword">import</span> grpc<br><span class="hljs-keyword">from</span> grpc_asyncio_example.protos <span class="hljs-keyword">import</span> helloworld_pb2, helloworld_pb2_grpc<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">client</span>(<span class="hljs-params">target: <span class="hljs-built_in">str</span> = <span class="hljs-string">&quot;localhost:9999&quot;</span></span>):</span><br>    <span class="hljs-keyword">with</span> grpc.insecure_channel(target=target) <span class="hljs-keyword">as</span> channel:<br>        stub: helloworld_pb2_grpc.GreeterStub = helloworld_pb2_grpc.GreeterStub(channel)<br>        response: helloworld_pb2.HelloReply = stub.SayHello(helloworld_pb2.HelloRequest(name=<span class="hljs-string">&#x27;you&#x27;</span>), timeout=<span class="hljs-number">10</span>)<br>    logging.info(<span class="hljs-string">&quot;Greeter client received: &quot;</span> + response.message)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    logging.basicConfig()<br>    client()<br></code></pre></td></tr></table></figure><p>服务端代码如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">from</span> concurrent <span class="hljs-keyword">import</span> futures<br><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> logging<br><br><span class="hljs-keyword">import</span> grpc<br><span class="hljs-keyword">from</span> grpc_asyncio_example.protos <span class="hljs-keyword">import</span> helloworld_pb2, helloworld_pb2_grpc<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Greeter</span>(<span class="hljs-params">helloworld_pb2_grpc.GreeterServicer</span>):</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">SayHello</span>(<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">        self, request: helloworld_pb2.HelloRequest, context: grpc.ServicerContext</span></span><br><span class="hljs-function"><span class="hljs-params">    </span>) -&gt; helloworld_pb2.HelloReply:</span><br>        time.sleep(request.sleep_millisecond / <span class="hljs-number">1000</span>)  <span class="hljs-comment"># 模拟IO</span><br>        <span class="hljs-keyword">return</span> helloworld_pb2.HelloReply(message=<span class="hljs-string">&#x27;Hello, %s!&#x27;</span> % request.name)<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">serve</span>(<span class="hljs-params">target: <span class="hljs-built_in">str</span> = <span class="hljs-string">&quot;localhost:9999&quot;</span></span>) -&gt; grpc.server:</span><br>    server: grpc.server = grpc.server(futures.ThreadPoolExecutor(max_workers=<span class="hljs-number">100</span>))<br>    helloworld_pb2_grpc.add_GreeterServicer_to_server(Greeter(), server)<br>    server.add_insecure_port(target)<br>    server.start()<br>    <span class="hljs-keyword">return</span> server<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    logging.basicConfig()<br>    serve().wait_for_termination()<br></code></pre></td></tr></table></figure><p>客户端与服务端的代码都非常简单，客户端主要是发送一个请求，该请求参数为<code>name=you</code>，而服务端则是解析参数，并把<code>Hello &#123;name&#125;</code>返回给客户端，最终由客户端把服务端返回的消息打印出来。<br>这份代码只可以用于<code>Python</code>的多线程中，无法在协程环境中运行，接下来讲分别介绍<code>Python gRPC</code>在<code>gevent</code>和<code>asyncio</code>中的使用和原理分析。</p><blockquote><p>只介绍<code>UNARY_UNARY</code>请求方式，其他方式不同可以通过对应的文档了解如何使用。</p></blockquote><h2 id="2-Gevent"><a href="#2-Gevent" class="headerlink" title="2.Gevent"></a>2.Gevent</h2><p><code>gevent </code>是一个基于协程的<code>Python</code>网络库，它通过<code>greenlet</code>在<code>libev</code>或<code>libuv</code>事件循环之上提供高级同步API，在<code>Python</code>程序使用<code>gevent</code>很简单，只要在代码引入如下猴子补丁语法:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> gevent.monkey<br>gevent.monkey.patch_all()<br></code></pre></td></tr></table></figure><p>那么整个程序的<code>Python</code>代码都支持<code>gevent</code>了，程序也可以通过<code>gevent</code>来运行。</p><p>不过<code>Python gRPC</code>是个例外，因为<code>Python gRPC</code>的核心是由<code>C</code>语言编写的，而<code>gevent</code>应用的猴子补丁只能涉及到用<code>Python</code>语言编写的代码，所以单靠应用<code>gevent</code>的猴子补丁是没办法使<code>Python gRPC</code>在<code>gevent</code>中运行的，可能还会导致调用<code>gRPC</code>客户端方法时出现卡死的情况。</p><p>好在<code>Python gRPC</code>提供了一个用法，使<code>Python gRPC</code>能够在<code>gevent</code>中兼容运行，代码如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-comment"># 先应用猴子补丁</span><br><span class="hljs-keyword">import</span> gevent.monkey<br>gevent.monkey.patch_all()<br><br><span class="hljs-comment"># 再为gRPC启用gevent兼容模式</span><br><span class="hljs-keyword">import</span> grpc.experimental.gevent<br>grpc.experimental.gevent.init_gevent()<br><br><span class="hljs-comment"># gRPC客户端或服务端的代码</span><br>...<br><br></code></pre></td></tr></table></figure><p>这份代码通过调用<code>grpc.experimental.gevent.init_gevent</code>，使<code>gRPC</code>能在<code>gevent</code>中运行，而且在<code>gevent</code>模式下<code>gRPC</code>的所有模块和方法的使用方式都不需要改变。 但是<code>gRPC</code>在通过<code>gevent</code>的兼容模式运行的时候，性能会大打折扣，比如通过下面的命令:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">ghz -c 100 -n 10000 \<br>    --insecure \<br>    --proto ../protos/grpc_asyncio_example/protos/helloworld.proto \<br>    --call helloworld.Greeter.SayHello \<br>    -d <span class="hljs-string">&#x27;&#123;&quot;name&quot;:&quot;Joe&quot;, &quot;sleep_millisecond&quot;: 10&#125;&#x27;</span> \<br>    localhost:9999<br></code></pre></td></tr></table></figure><p>对<code>gevent</code>模式下的<code>Python gRPC</code>服务进行压测，其中<code>c</code>是指并发数，<code>n</code>为最大请求数，而<code>-d</code>是请求的参数，里面的<code>sleep_millisecond</code>代表服务端收到请求后会休眠10毫秒来模拟IO处理，他们的压测结果如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 多线程模式</span><br>Summary:<br>  Count:10000<br>  Total:2.67 s<br>  Slowest:45.01 ms<br>  Fastest:12.04 ms<br>  Average:26.34 ms<br>  Requests/sec:3746.87<br><span class="hljs-comment"># gevent兼容模式</span><br>Summary:<br>  Count:10000<br>  Total:5.23 s<br>  Slowest:69.31 ms<br>  Fastest:13.43 ms<br>  Average:51.83 ms<br>  Requests/sec:1913.44<br></code></pre></td></tr></table></figure><p>通过压测结果可以发现，<code>gevent</code>兼容模式的性能只有多线程模式下的一半(以<code>Requests/sec</code>对比)，会有这样的结果是因为<code>Python gRPC</code>的异步请求是在多线程上执行，同时<code>Python gRPC</code>是一个基于<code>C</code>的库，它可以绕过<code>Python</code>的<code>GIL</code>，从而获得了CPU多核的并发能力，而在启用了<code>gevent</code>兼容模式后<code>gevent</code>可能会导致多线程无法绕过<code>Python</code>的<code>GIL</code>，从而失去了上面提到的并发性。</p><p>此外<code>Python gRPC</code>目前只做到了兼容<code>gevent</code>的运行，通过<a href="https://github.com/grpc/grpc/blob/master/src/python/grpcio_tests/commands.py">commands.py</a>中<code>TestGevent</code>的注释可以看出<code>Python gRPC</code>尚未对<code>gevent</code>模式的性能做出优化，所以建议不要在<code>Python gRPC</code>的服务端启用<code>gevent</code>兼容模式，在<code>Python gRPC</code>的客户端可以根据实际情况决定是否启用(比如在<code>gunicorn</code> + <code>gevent</code> + <code>Flask</code>运行的服务中的<code>Python gRPC</code>客户端)。</p><blockquote><p>通过下列文件可以看出<code>gevent</code>兼容模式是把线程池替换为<code>gevent</code>的线程池:</p><ul><li>客户端调用到<code>gevent</code>的代码<a href="https://github.com/grpc/grpc/blob/2d4f3c56001cd1e1f85734b2f7c5ce5f2797c38a/src/python/grpcio/grpc/_cython/_cygrpc/credentials.pyx.pxi#L27">credentials.pyx.pxi</a></li><li>服务端调用到<code>gevent</code>的代码<a href="https://github.com/grpc/grpc/blob/b8c2818c6b5b9013adfe3f02a49dcc93675a7787/src/python/grpcio/grpc/_cython/_cygrpc/completion_queue.pyx.pxi#L111">completion_queue.pyx.pxi</a></li><li>启用<code>gevent</code>兼容模式的代码<a href="https://github.com/grpc/grpc/blob/066a310df1fe9d68a00f346bd36e6c965d62e528/src/python/grpcio/grpc/_cython/_cygrpc/grpc_gevent.pyx.pxi">grpc_gevent.pyx.pxi</a></li></ul></blockquote><h2 id="3-Asyncio"><a href="#3-Asyncio" class="headerlink" title="3.Asyncio"></a>3.Asyncio</h2><p><code>Python gRPC</code>一开始是不支持在<code>Asyncio</code>中运行的，所以社区出现了一个名为<a href="https://github.com/vmagamedov/grpclib">grpclib</a>的库来解决这一问题，而官方的<code>Python gRPC</code>在后面的迭代后诞生了<code>grpc.aio</code>模块以支持<code>grpc</code>在<code>Asyncio</code>中运行。</p><h3 id="3-1-grpclib"><a href="#3-1-grpclib" class="headerlink" title="3.1.grpclib"></a>3.1.grpclib</h3><p><a href="https://github.com/vmagamedov/grpclib">grpclib</a>这个库提供了纯<code>Python</code>的实现，这意味着能按自己的需求对它进行拓展，可塑性强。<br>所以诞生了基于<a href="https://github.com/vmagamedov/grpclib">grpclib</a>和<a href="https://github.com/eigenein/protobuf/">pure-protobuf</a>封装的另一个库–<a href="https://github.com/danielgtaylor/python-betterproto/tree/master">python-betterproto</a>。该库可以使开发者编写<code>grpc</code>代码更加的方便，比如<a href="https://github.com/grpc/grpc/blob/master/examples/protos/helloworld.proto">helloworld</a>生成对应的<code>Message</code>代码如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-meta">@dataclass(<span class="hljs-params">eq=<span class="hljs-literal">False</span>, <span class="hljs-built_in">repr</span>=<span class="hljs-literal">False</span></span>)</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloRequest</span>(<span class="hljs-params">betterproto.Message</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;The request message containing the user&#x27;s name.&quot;&quot;&quot;</span><br><br>    name: <span class="hljs-built_in">str</span> = betterproto.string_field(<span class="hljs-number">1</span>)<br>    sleep_millisecond: <span class="hljs-built_in">int</span> = betterproto.int32_field(<span class="hljs-number">2</span>)<br><br><br><span class="hljs-meta">@dataclass(<span class="hljs-params">eq=<span class="hljs-literal">False</span>, <span class="hljs-built_in">repr</span>=<span class="hljs-literal">False</span></span>)</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloReply</span>(<span class="hljs-params">betterproto.Message</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;The response message containing the greetings&quot;&quot;&quot;</span><br><br>    message: <span class="hljs-built_in">str</span> = betterproto.string_field(<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p>可以看到这段代码打可读性比起官方的<code>Python gRPC</code>要高很多，这样开发者在查阅<code>message</code>的用法时会非常的方便，而客户端和服务端的用法则与官方的<code>Python gRPC</code>类似，比如客户端的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> asyncio<br><span class="hljs-keyword">import</span> logging<br><br><span class="hljs-keyword">from</span> grpclib.client <span class="hljs-keyword">import</span> Channel<br><br><span class="hljs-keyword">from</span> grpc_asyncio_example.protos <span class="hljs-keyword">import</span> helloworld<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">client</span>() -&gt; <span class="hljs-keyword">None</span>:</span><br>    channel: Channel = Channel(host=<span class="hljs-string">&quot;localhost&quot;</span>, port=<span class="hljs-number">9999</span>)<br>    response: helloworld.HelloReply = <span class="hljs-keyword">await</span> helloworld.GreeterStub(channel).say_hello(<br>        hello_request=helloworld.HelloRequest(name=<span class="hljs-string">&quot;you&quot;</span>)<br>    )<br>    logging.info(response)<br><br>    <span class="hljs-comment"># don&#x27;t forget to close the channel when done!</span><br>    channel.close()<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    asyncio.run(client())<br></code></pre></td></tr></table></figure><p>可以看出与多线程的<code>Python gRPC</code>代码类似，而服务端的代码如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> asyncio<br><br><span class="hljs-keyword">from</span> grpclib.server <span class="hljs-keyword">import</span> Server<br><br><span class="hljs-keyword">from</span> grpc_asyncio_example.protos <span class="hljs-keyword">import</span> helloworld<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloWorldService</span>(<span class="hljs-params">helloworld.GreeterBase</span>):</span><br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">say_hello</span>(<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">        self, request: <span class="hljs-string">&quot;helloworld.HelloRequest&quot;</span></span></span><br><span class="hljs-function"><span class="hljs-params">    </span>) -&gt; &quot;helloworld.HelloReply&quot;:</span><br>        <span class="hljs-keyword">await</span> asyncio.sleep(request.sleep_millisecond / <span class="hljs-number">1000</span>)<br>        <span class="hljs-keyword">return</span> helloworld.HelloReply(message=<span class="hljs-string">&quot;Hello, %s!&quot;</span> % request.name)<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">serve</span>() -&gt; Server:</span><br>    server: Server = Server([HelloWorldService()])<br>    <span class="hljs-keyword">await</span> server.start(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">9999</span>)<br>    <span class="hljs-keyword">return</span> server<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br><br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>() -&gt; <span class="hljs-keyword">None</span>:</span><br>        <span class="hljs-keyword">await</span> (<span class="hljs-keyword">await</span> serve()).wait_closed()<br><br>    asyncio.run(main())<br></code></pre></td></tr></table></figure><p>可以看出服务端的代码与多线程的<code>Python gRPC</code>也类似，但是缺少<code>Context</code>的参数，如果跳进去<code>helloworld.GretterBase</code>查看源码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GreeterBase</span>(<span class="hljs-params">ServiceBase</span>):</span><br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">say_hello</span>(<span class="hljs-params">self, hello_request: <span class="hljs-string">&quot;HelloRequest&quot;</span></span>) -&gt; &quot;HelloReply&quot;:</span><br>        <span class="hljs-keyword">raise</span> grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)<br><br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__rpc_say_hello</span>(<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">        self, stream: <span class="hljs-string">&quot;grpclib.server.Stream[HelloRequest, HelloReply]&quot;</span></span></span><br><span class="hljs-function"><span class="hljs-params">    </span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        request = <span class="hljs-keyword">await</span> stream.recv_message()<br>        response = <span class="hljs-keyword">await</span> self.say_hello(request)<br>        <span class="hljs-keyword">await</span> stream.send_message(response)<br></code></pre></td></tr></table></figure><p>则可以发现在<code>__rpc_say_hellp</code>方法中的<code>stream</code>对象是类似于官方<code>Python gRPC</code>中的<code>Context</code>，这意味着如果要使用<code>Context</code>方法时需要自己新增一个方法去处理，好在该库是纯<code>Python</code>编写的，<code>grpclib</code>对应客户端的<code>Channel</code>和服务端对应的<code>Server</code>代码也封装得很好，不像官方<code>Python gRPC</code>一样跳进源代码后就不知道它的代码在哪里，所以处理起来比较方便。</p><p>不过它也因此拥有了纯<code>Python</code>编写库的缺点–性能较低， 在经过与<code>gevent</code>一样的命令进行压测后得出如下数据:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># grpclib</span><br>Summary:<br>  Count:10000<br>  Total:6.37 s<br>  Slowest:96.38 ms<br>  Fastest:31.54 ms<br>  Average:63.33 ms<br>  Requests/sec:1571.05<br><br><span class="hljs-comment"># grpclib &amp;&amp; uvloop</span><br>Summary:<br>  Count:10000<br>  Total:5.44 s<br>  Slowest:90.97 ms<br>  Fastest:38.18 ms<br>  Average:53.13 ms<br>  Requests/sec:1839.73<br></code></pre></td></tr></table></figure><p>通过数据可以发现，<code>betterproto</code>的性能基本是多线程模式性能的3成，而这部分性能的差距主要来自于对<code>HTTP2</code>的解析，如果能把解析<code>HTTP2</code>的实现进行替换为高性能的版本，那么它的性能就能够接近<code>Python gRPC</code>官方实现的<code>grpc.aio</code>了。</p><p>此外，<a href="https://github.com/vmagamedov/grpclib">grpclib</a>的功能比官方<code>Python gRPC</code>比较少，需要开发能力比较强以及对<code>gRPC</code>了解得比较深的开发者对其进行二次开发，才能使它发挥更好的作用。</p><h3 id="3-2-grpc-aio"><a href="#3-2-grpc-aio" class="headerlink" title="3.2.grpc.aio"></a>3.2.grpc.aio</h3><p>官方的<code>Python gRPC</code>现在通过<code>grpc.aio</code>模块对<code>Asyncio</code>提供了支持，它的用法与线程版本一致，只是涉及到IO相关的模块是存在于<code>grpc.aio</code>包中，对于使用者来说，需要把用到的<code>grpc.XXX</code>模块需要变为<code>grpc.aio.XXX</code>模块,同时要确保调用代码一处异步，处处异步，比如客户端的代码如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> asyncio<br><span class="hljs-keyword">import</span> logging<br><br><span class="hljs-keyword">import</span> grpc<br><span class="hljs-keyword">from</span> grpc_asyncio_example.protos <span class="hljs-keyword">import</span> helloworld_pb2, helloworld_pb2_grpc<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">client</span>(<span class="hljs-params">target: <span class="hljs-built_in">str</span> = <span class="hljs-string">&quot;localhost:9999&quot;</span></span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> grpc.aio.insecure_channel(target) <span class="hljs-keyword">as</span> channel:<br>        stub: helloworld_pb2_grpc.GreeterStub = helloworld_pb2_grpc.GreeterStub(channel)<br>        response: helloworld_pb2.HelloRequest = <span class="hljs-keyword">await</span> stub.SayHello(helloworld_pb2.HelloRequest(name=<span class="hljs-string">&#x27;you&#x27;</span>))<br>    logging.info(<span class="hljs-string">&quot;Greeter client received: &quot;</span> + response.message)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    logging.basicConfig()<br>    asyncio.run(client())<br></code></pre></td></tr></table></figure><p>通过代码可以看出初始化<code>Channel</code>的代码不是<code>grpc.insecure_channel</code>而是<code>grpc.aio.insecure_channel</code>，而且在<code>helloworld_pb2_grpc.GreeterStub</code>没有发生变化的情况下，调用<code>stub.SayHello</code>时仍然需要加上<code>await</code>语法，这是因为<code>Python gRPC</code>中<code>Stub</code>的设计模式类似于<a href="https://sans-io.readthedocs.io/">sans-io</a>，是否要添加<code>await</code>语法则是取决于核心IO处理的实现，在这里处理IO的是<code>Channel</code>，所以开发者在调用<code>stub.SayHello</code>时最终会由<code>stub</code>的<code>channel</code>来发送请求，而<code>channel</code>发送请求是一个异步IO实现，所以需要添加<code>await</code>语法。</p><p>而对于服务端的改动也是类似的，对应的代码如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> asyncio<br><span class="hljs-keyword">import</span> logging<br><br><span class="hljs-keyword">import</span> grpc<br><span class="hljs-keyword">from</span> grpc_asyncio_example.protos <span class="hljs-keyword">import</span> helloworld_pb2, helloworld_pb2_grpc<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Greeter</span>(<span class="hljs-params">helloworld_pb2_grpc.GreeterServicer</span>):</span><br><br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">SayHello</span>(<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">        self, request: helloworld_pb2.HelloRequest, context: grpc.aio.ServicerContext</span></span><br><span class="hljs-function"><span class="hljs-params">    </span>) -&gt; helloworld_pb2.HelloReply:</span><br>        <span class="hljs-keyword">await</span> asyncio.sleep(request.sleep_millisecond / <span class="hljs-number">1000</span>)<br>        <span class="hljs-keyword">return</span> helloworld_pb2.HelloReply(message=<span class="hljs-string">&#x27;Hello, %s!&#x27;</span> % request.name)<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">serve</span>(<span class="hljs-params">target: <span class="hljs-built_in">str</span> = <span class="hljs-string">&quot;localhost:9999&quot;</span></span>) -&gt; grpc.aio.Server:</span><br>    server: grpc.aio.Server = grpc.aio.server()<br>    helloworld_pb2_grpc.add_GreeterServicer_to_server(Greeter(), server)<br>    server.add_insecure_port(target)<br>    logging.info(<span class="hljs-string">&quot;Starting server on %s&quot;</span>, target)<br>    <span class="hljs-keyword">await</span> server.start()<br>    <span class="hljs-keyword">return</span> server<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    logging.basicConfig(level=logging.INFO)<br><br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>() -&gt; <span class="hljs-keyword">None</span>:</span><br>        <span class="hljs-keyword">await</span> (<span class="hljs-keyword">await</span> serve()).wait_for_termination()<br><br>    asyncio.run(main())<br></code></pre></td></tr></table></figure><p>可以看到代码中IO相关语法都需要添加<code>await</code>语句，同时<code>SayHello</code>方法添加了<code>async</code>语法，这样就可以在<code>SayHello</code>函数里面编写<code>await</code>语句了。<br>需要注意的是，由于<code>Python gRPC</code>是通过<code>ServicerContext</code>来传输数据的，导致<code>ServicerContext</code>中有些方法是与IO相关的，所以这里用到的<code>ServicerContext</code>是<code>grpc.aio.ServicerContext</code>。</p><p>对于IO相关的用法可能有一些区别，但是对于其他跟IO无关的功能，则保持跟多线程模式的一致，比如客户端在启用时填写的参数如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">with</span> grpc.insecure_channel(target=<span class="hljs-string">&#x27;localhost:50051&#x27;</span>,<br>                           options=[(<span class="hljs-string">&#x27;grpc.lb_policy_name&#x27;</span>, <span class="hljs-string">&#x27;pick_first&#x27;</span>),<br>                                    (<span class="hljs-string">&#x27;grpc.enable_retries&#x27;</span>, <span class="hljs-number">0</span>),<br>                                    (<span class="hljs-string">&#x27;grpc.keepalive_timeout_ms&#x27;</span>, <span class="hljs-number">10000</span>)<br>                                   ]) <span class="hljs-keyword">as</span> channel:<br></code></pre></td></tr></table></figure><p>而在<code>grpc.aio</code>中代码如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> grpc.aio.insecure_channel(target=<span class="hljs-string">&#x27;localhost:50051&#x27;</span>,<br>                           options=[(<span class="hljs-string">&#x27;grpc.lb_policy_name&#x27;</span>, <span class="hljs-string">&#x27;pick_first&#x27;</span>),<br>                                    (<span class="hljs-string">&#x27;grpc.enable_retries&#x27;</span>, <span class="hljs-number">0</span>),<br>                                    (<span class="hljs-string">&#x27;grpc.keepalive_timeout_ms&#x27;</span>, <span class="hljs-number">10000</span>)<br>                                   ]) <span class="hljs-keyword">as</span> channel:<br></code></pre></td></tr></table></figure><p>可以看到填写的参数Key名和值都是一样的，没有发生变化。</p><p>这里只是以一些常见的功能举例，简述不同模式<code>Python gRPC</code>的使用，详细的<code>grpc.aio</code>功能见<a href="https://grpc.github.io/grpc/python/grpc_asyncio.html#">grpc_asyncio文档</a>，如果熟悉多线程模式下<code>Python gRPC</code>和<code>Python Asyncio</code>的用法，那么上手<code>grpc.aio</code>是非常容易的。</p><h4 id="3-2-1-grpc-aio的事件循环"><a href="#3-2-1-grpc-aio的事件循环" class="headerlink" title="3.2.1.grpc.aio的事件循环"></a>3.2.1.grpc.aio的事件循环</h4><p>在<code>Python gRPC</code>的<code>grpc.aio</code>中使用到了<code>asyncio</code>的事件循环，所以可以通过<code>uvloop</code>来提高<code>grpc.aio</code>的性能，使用<code>uvloop</code>非常简单，只要在代码最前面添加如下代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> uvloop<br>uvloop.install()<br></code></pre></td></tr></table></figure><p>就可以使程序获得<code>uvloop</code>带来的性能加成，在对使用<code>asyncio.loop</code>和<code>uvloop.loop</code>的服务端代码进行压测后结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># asyncio.loop</span><br>Summary:<br>  Count:10000<br>  Total:2.15 s<br>  Slowest:30.56 ms<br>  Fastest:11.09 ms<br>  Average:21.19 ms<br>  Requests/sec:4643.73<br><br><span class="hljs-comment"># uvloop.loop</span><br>Summary:<br>  Count:10000<br>  Total:1.45 s<br>  Slowest:25.14 ms<br>  Fastest:9.41 ms<br>  Average:14.08 ms<br>  Requests/sec:6885.81<br></code></pre></td></tr></table></figure><p>可以发现<code>grpc.aio</code>的性能比多线程模式稍好一些，同时在使用了<code>uvloop</code>后性能提升了50%(以<code>Requests/sec</code>对比)。</p><p>不过在与用<code>uvicorn</code>运行的服务中使用<code>gRPC</code>客户端时，需要确保在<code>uvicorn</code>启动后才初始化<code>grpc.aio.Channel</code>，因为在初始化<code>grpc.aio.Channel</code>时会获取到一个事件循环，如果当前没有事件循环时则会自动创建一个事件循环，而<code>uvicorn</code>在启动是会单独创建一个新的事件循环，这会导致<code>grpc.aio.Channel</code>与<code>uvicorn</code>不在同一个事件循环运行导致运行出错。不过这个问题也很好解决，解决代码如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> Any<br><span class="hljs-keyword">import</span> grpc<br><span class="hljs-keyword">from</span> starlette.applications <span class="hljs-keyword">import</span> Starlette<br><span class="hljs-keyword">from</span> grpc_asyncio_example.protos <span class="hljs-keyword">import</span> helloworld_pb2, helloworld_pb2_grpc<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">create_app</span>() -&gt; Starlette:</span><br>    app: Starlette = Starlette()<br><br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_before_server_start</span>(<span class="hljs-params">*_: Any</span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        app.state.channel = grpc.aio.insecure_channel(<span class="hljs-string">&quot;localhost:9999&quot;</span>)<br><br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_after_server_stop</span>(<span class="hljs-params">*_: Any</span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        <span class="hljs-keyword">await</span> app.state.channel.close()<br><br>    app.add_event_handler(<span class="hljs-string">&quot;startup&quot;</span>, _before_server_start)<br>    app.add_event_handler(<span class="hljs-string">&quot;shutdown&quot;</span>, _after_server_stop)<br>    <span class="hljs-keyword">return</span> app<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br><br>    <span class="hljs-keyword">import</span> uvicorn  <span class="hljs-comment"># type: ignore</span><br>    starlette_app: Starlette = create_app()<br>    uvicorn.run(starlette_app)<br></code></pre></td></tr></table></figure><p>在所示的代码中，<code>grpc.aio.channel</code>在<code>startup</code>事件时才进行初始化，在<code>shutdown</code>事件关闭，由于触发<code>startup</code>事件时，<code>uvicorn</code>已经初始化了一个事件循环，所以初始化<code>grpc.aio.Channel</code>时获取到的事件循环与<code>uvicorn</code>一致。</p><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h2><p>如果为了能跟上社区的脚步，以及为了跨语言能够很好的合作，建议还是根据服务所在场景来使用多线程默认的<code>gRPC</code>或者<code>grpc.aio</code>，这是最好的选择;<br>对于类似<code>gunicorn</code> + <code>gevnet</code> + 类似于<code>Flask</code>框架的服务通过<code>gRPC</code>客户端发送请求时可以使用<code>gevent</code>兼容模式；<br>对于开发能力比较强，本身也是追求<code>Pythonic</code>的开发者且是基于<code>Asyncio</code>生态编写服务以及有比较强的定制需求的，则可以考虑使用<code>betterproto</code>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;之前在&lt;a href=&quot;https://so1n.me/categories/Python-gRPC%E5%AE%9E%E8%B7%B5/&quot;</summary>
      
    
    
    <content src="https://ftp.bmp.ovh/imgs/2022/02/bd67e15aa8d46101.png" type="image"/>
    
    
    <category term="Python-gRPC实践" scheme="http://so1n.me/categories/Python-gRPC%E5%AE%9E%E8%B7%B5/"/>
    
    
    <category term="Python" scheme="http://so1n.me/tags/Python/"/>
    
    <category term="gRPC" scheme="http://so1n.me/tags/gRPC/"/>
    
    <category term="Protobuf" scheme="http://so1n.me/tags/Protobuf/"/>
    
  </entry>
  
  <entry>
    <title>如何使用Poetry(1.2+)管理Python虚拟环境</title>
    <link href="http://so1n.me/2022/11/23/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Poetry(1.2+)%E7%AE%A1%E7%90%86Python%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/"/>
    <id>http://so1n.me/2022/11/23/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Poetry(1.2+)%E7%AE%A1%E7%90%86Python%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/</id>
    <published>2022-11-23T12:35:24.000Z</published>
    <updated>2023-07-07T06:19:52.065Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前记"><a href="#前记" class="headerlink" title="前记"></a>前记</h2><p>一个项目最重要的就是跑起来， 大家基本会同时在本地开发多个项目， 而每个项目用到的环境都是不一样的， 如果这些项目都共用一份依赖那么会导致多个项目的依赖发生冲突以及导致线上服务不稳定，所以就需要用到虚拟环境隔离。在<code>Python</code>中提供了名为<code>venv</code>的虚拟环境管理包用于做多个项目的环境隔离，它提供了很多基础的功能，但是还有很多功能都需要开发者手动操作非常不方便，这时候就可以用到<code>Poetry</code>啦。</p><span id="more"></span><p>本文是<a href="https://so1n.me/2021/08/10/%E4%BF%9D%E9%9A%9CPython%E9%A1%B9%E7%9B%AE%E8%B4%A8%E9%87%8F%E7%9A%84%E5%B7%A5%E5%85%B7/">保障Python项目质量的工具</a>文章中<code>项目环境管理-Poetry</code>的拓展版，由于<code>Poetry</code>在1.2后发生了一些大变化，所以本文的内容不保证能支持<code>Poetry</code>1.2以下的版本。</p><h2 id="1-最初的开始"><a href="#1-最初的开始" class="headerlink" title="1.最初的开始"></a>1.最初的开始</h2><p>在未依赖任何外部工具时，通常都会使用自带的工具来初始化项目的环境，如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  ~ <span class="hljs-built_in">cd</span> demo<br>➜  demo  <br>➜  demo  python3 -m venv .venv<br>➜  demo  <span class="hljs-built_in">source</span> .venv/bin/activate<br>➜  demo  python3 -m pip install --upgrade pip setuptools wheel<br>➜  demo  python3 -m pip install -r requirements.dev.txt<br></code></pre></td></tr></table></figure><p>这几个命令中，由<code>venv</code>完成初始化和使用虚拟环境，再由<code>pip</code>命令来安装包含测试环境的依赖。<br>这些工具都能正常的使用，但是却有几个弊端：</p><ul><li>直接使用<code>python3</code>命令，无法确定准确的<code>Python</code>的版本，导致本地的<code>Python</code>版本与其他人或者服务器的版本不同步。</li><li>每次都要显式的进入和切换虚拟换(<code>Pycharm</code>会默认读取到虚拟环境)。</li><li>通过<code>pip</code>来管理依赖，无法完成依赖管理，也无法自动的对依赖进行分组，如区分测试依赖和正式依赖等。</li></ul><p>此外对于打包，推送包之类的功能还需要开发者去手动编辑文件再通过繁杂的命令去处理，这是非常麻烦的，而<code>Poetry</code>对很多重复且需要开发者手动操作都步骤都统一起来，提供一些命令方便开发者去操作。</p><blockquote><p><code>Poetry</code>的安装非常简单，一条命令就可以搞定了，不同系统的安装教程官方已经说得很详细，具体见<a href="https://python-poetry.org/docs/#installation">官方安装文档</a></p></blockquote><h2 id="2-如何使用Poetry初始化项目环境"><a href="#2-如何使用Poetry初始化项目环境" class="headerlink" title="2.如何使用Poetry初始化项目环境"></a>2.如何使用Poetry初始化项目环境</h2><p>如果这是第一个项目，那么可以使用<code>poetry new &#123;项目名&#125;</code>的命令来创建项目，如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  ~ poetry new demo<br>Created package demo <span class="hljs-keyword">in</span> demo<br></code></pre></td></tr></table></figure><p>这时<code>Poetry</code>会在当前目录创建一个<code>demo</code>目录，<code>demo</code>目录里面的结构如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  ~ <span class="hljs-built_in">cd</span> demo<br>➜  demo tree<br>.<br>├── demo<br>│   └── __init__.py<br>├── pyproject.toml<br>├── README.md<br>└── tests<br>    └── __init__.py<br><br>2 directories, 4 files<br></code></pre></td></tr></table></figure><p>可以看到<code>Poetry</code>会帮忙创建一个最小项目的结构，其中<code>demo</code>是我们本次要开发的目录，<code>README.md</code>是一个项目描述文档，但它是空的，等着我们去填写，<code>tests</code>则是一个测试用例的目录，而<code>pyproject.toml</code>是<code>Python</code>项目相关的一些配置，<code>poetry</code>会预写一些项目的最小信息，如下:</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs toml"><span class="hljs-section">[tool.poetry]</span><br><span class="hljs-attr">name</span> = <span class="hljs-string">&quot;demo&quot;</span><br><span class="hljs-attr">version</span> = <span class="hljs-string">&quot;0.1.0&quot;</span><br><span class="hljs-attr">description</span> = <span class="hljs-string">&quot;&quot;</span><br><span class="hljs-attr">authors</span> = [<span class="hljs-string">&quot;so1n &lt;qaz6803609@163.com&gt;&quot;</span>]<br><span class="hljs-attr">readme</span> = <span class="hljs-string">&quot;README.md&quot;</span><br><br><span class="hljs-section">[tool.poetry.dependencies]</span><br><span class="hljs-attr">python</span> = <span class="hljs-string">&quot;^3.7&quot;</span><br><br><br><span class="hljs-section">[build-system]</span><br><span class="hljs-attr">requires</span> = [<span class="hljs-string">&quot;poetry-core&quot;</span>]<br><span class="hljs-attr">build-backend</span> = <span class="hljs-string">&quot;poetry.core.masonry.api&quot;</span><br></code></pre></td></tr></table></figure><p>其中作者信息是通过<code>git config</code>里面的配置获取的。</p><p>如果是在已有项目下使用<code>Poetry</code>则可以通过<code>poetry init</code>命令，这样<code>Poetry</code>就会通过一个交互式命令行来协助开发者创建项目信息和虚拟环境，不过在创建之前要先确保系统上拥有自己想要的<code>Python</code>版本，<code>Poetry</code>是不会负责<code>Python</code>版本的管理的，需要开发者通过手动处理,<code>pyenv</code>,<code>conda</code>等命令来完成这一步操作，具体的<code>poetry init</code>操作如动图:<br><img   class="lazyload" data-original="https://files.catbox.moe/hvev5v.gif" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" ><br>可以看到如果没有填写值得话，<code>Poetry</code>会默认为你填写一些值，我在某些选项中填入了一些自己的值，最后<code>pyproject.toml</code>会生成如下内容：</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs toml"><span class="hljs-section">[tool.poetry]</span><br><span class="hljs-attr">name</span> = <span class="hljs-string">&quot;demo&quot;</span><br><span class="hljs-attr">version</span> = <span class="hljs-string">&quot;0.0.1&quot;</span><br><span class="hljs-attr">description</span> = <span class="hljs-string">&quot;My demo project&quot;</span><br><span class="hljs-attr">authors</span> = [<span class="hljs-string">&quot;so1n &lt;qaz6803609@163.com&gt;&quot;</span>]<br><span class="hljs-attr">license</span> = <span class="hljs-string">&quot;Apache&quot;</span><br><span class="hljs-attr">readme</span> = <span class="hljs-string">&quot;README.md&quot;</span><br><br><span class="hljs-section">[tool.poetry.dependencies]</span><br><span class="hljs-attr">python</span> = <span class="hljs-string">&quot;^3.9.10&quot;</span><br><br><br><span class="hljs-section">[build-system]</span><br><span class="hljs-attr">requires</span> = [<span class="hljs-string">&quot;poetry-core&quot;</span>]<br><span class="hljs-attr">build-backend</span> = <span class="hljs-string">&quot;poetry.core.masonry.api&quot;</span><br></code></pre></td></tr></table></figure><p>至此，项目初始化完毕，可以开始编写我们的项目了，但是当用<code>PyCharm</code>打开项目的时候会发现有如图的提醒:<br><img   class="lazyload" data-original="https://files.catbox.moe/9ocxnn.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" ></p><p>这个提醒是<code>PyCharm</code>找不到<code>Poetry</code>的可执行文件，需要通过我们指定<code>Poetry</code>的路径才可以执行，这时候可以通过命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">which</span> poetry<br></code></pre></td></tr></table></figure><p>来获取<code>Poetry</code>的可执行路径并填写到弹窗里面，之后<code>PyCharm</code>就会调用<code>Poetry</code>进行虚拟环境初始化，并在当前路径创建<code>.venv</code>文件夹，通过<code>poetry env info</code>获取当前项目的虚拟环境:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  demo poetry env info <br>Virtualenv<br>Python:         3.9.10<br>Implementation: CPython<br>Path:           /home/so1n/demo/.venv<br>Executable:     /home/so1n/demo/.venv/bin/python<br>Valid:          True<br><br>System<br>Platform:   linux<br>OS:         posix<br>Python:     3.9.10<br>Path:       /usr/<span class="hljs-built_in">local</span><br>Executable: /usr/<span class="hljs-built_in">local</span>/bin/python3.9<br></code></pre></td></tr></table></figure><blockquote><ul><li>1.如果想在已有的项目下使用<code>Poetry</code>则需要先删除当前的虚拟环境，并通过命令<code>poetry env use 3.9.10</code></li><li>2.如果创建的虚拟环境版本不是自己想要的，且是通过<code>pyenv</code>管理<code>Python</code>版本，那么可以通过<a href="https://python-poetry.org/blog/announcing-poetry-1.2.0/#detection-of-the-currently-active-python-experimental%E4%BA%86%E8%A7%A3%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3">https://python-poetry.org/blog/announcing-poetry-1.2.0/#detection-of-the-currently-active-python-experimental了解如何解决</a></li><li>3.如果第二点仍然无法解决问题，可以采用如下命令显示的指导<code>Poetry</code>使用到正确的<code>Python</code>版本:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">pyenv <span class="hljs-built_in">local</span> 3.9.10<br>poetry env use $(pyenv <span class="hljs-built_in">which</span> python)<br></code></pre></td></tr></table></figure></li></ul></blockquote><h2 id="3-编写与运行项目"><a href="#3-编写与运行项目" class="headerlink" title="3.编写与运行项目"></a>3.编写与运行项目</h2><p>虚拟环境初始化完成后就可以开始编写项目了，这个<code>demo</code>项目很简单，就是获取一个网站当前的状态，需要用到一个名为<code>httpx</code>的包，这时可以通过命令:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">poetry add httpx<br></code></pre></td></tr></table></figure><p>来安装这个包，当命令执行完毕后，可以发现<code>pyproject.toml</code>文件新增了一行关于<code>httpx</code>包的版本描述：</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs toml"><span class="hljs-section">[tool.poetry.dependencies]</span><br><span class="hljs-attr">python</span> = <span class="hljs-string">&quot;^3.9.10&quot;</span><br><span class="hljs-attr">poetry</span> = <span class="hljs-string">&quot;^1.2.2&quot;</span><br><span class="hljs-attr">httpx</span> = <span class="hljs-string">&quot;^0.23.1&quot;</span>   <span class="hljs-comment"># &lt;------ 新增</span><br></code></pre></td></tr></table></figure><p>这段描述意味着<code>httpx</code>的版本会锁定在<code>0.23.1</code>这个版本中。</p><p>安装好依赖后，在<code>demo/__init__.py</code>编写如下代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> httpx<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_status_code</span>() -&gt; int:</span><br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> httpx.AsyncClient() <span class="hljs-keyword">as</span> client:<br>        resp: httpx.Response = <span class="hljs-keyword">await</span> client.get(<span class="hljs-string">&quot;https://so1n.me&quot;</span>)<br>        <span class="hljs-keyword">return</span> resp.status_code<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    <span class="hljs-keyword">import</span> asyncio<br>    print(asyncio.run(get_status_code()))<br>    <br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    main()<br></code></pre></td></tr></table></figure><p>这段代码非常简单，就是请求<code>https://so1n.me</code>并打印对应的HTTP状态码，接着可以在终端通过命令直接运行，不用再通激活虚拟环境，运行结果如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  demo poetry run python demo/__init__.py<br>200<br></code></pre></td></tr></table></figure><p>不过这段命令比较长，经常这样输入会比较麻烦，这时可以采用<code>Poetry</code>的脚本功能，只需要向<code>pyproject.toml</code>文件追加如下内容:</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs toml"><span class="hljs-section">[tool.poetry.scripts]</span><br><span class="hljs-attr">demo</span> = <span class="hljs-string">&#x27;demo.__init__:main&#x27;</span><br></code></pre></td></tr></table></figure><p>这段内容中的<code>demo = &#39;demo.__init__:main&#39;</code>以等号分成两边，左边的<code>demo</code>是脚本key，这意味着在<code>tool.poetry.scripts</code>中不能出现相同的Key，而等号右边的<code>demo.__init__:main</code>则代表要执行<code>demo</code>目录下的<code>__init__.py</code>的<code>main</code>函数。<br>接下来可以通过<code>poetry run &#123;脚本key&#125;</code>语法来执行我们想要跑的代码，执行效果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  demo poetry run demo<br>200<br></code></pre></td></tr></table></figure><p>除此之外，还可以通过<code>poetry install</code>的方式来让<code>Poetry</code>创建我们的<code>demo</code>脚本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  demo poetry install<br>Installing dependencies from lock file<br><br>No dependencies to install or update<br><br>Installing the current project: demo (0.0.1)<br>➜  demo poetry run <span class="hljs-built_in">which</span> demo<br>/home/so1n/demo/.venv/bin/demo<br>➜  demo cat /home/so1n/demo/.venv/bin/demo<br><span class="hljs-meta">#!/home/so1n/demo/.venv/bin/python</span><br>import sys<br>from demo.__init__ import main<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    sys.exit(main())<br></code></pre></td></tr></table></figure><p>可以看到<code>Poetry</code>在<code>/home/so1n/demo/.venv/bin/demo</code>路径下创建了一个脚本文件，如果这时候如果通过<code>poetry shell</code>进入带有当前虚拟环境的交互<code>shell</code>，则可以通过<code>demo</code>直接执行我们的代码，如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  demo poetry shell<br>Spawning shell within /home/so1n/demo/.venv<br>➜  demo . /home/so1n/demo/.venv/bin/activate<br>(demo-py3.9.10) ➜  demo <span class="hljs-built_in">pwd</span><br>/home/so1n/demo/demo<br>(demo-py3.9.10) ➜  demo demo  <br>200<br></code></pre></td></tr></table></figure><h2 id="4-运行测试用例"><a href="#4-运行测试用例" class="headerlink" title="4.运行测试用例"></a>4.运行测试用例</h2><p>项目编写完成后需要确保我们的代码符合规范以及需要补充对应的测试用例，这是一个良好的习惯，在<code>Python</code>生态中，常用的测试框架是<code>pytest</code>，常用的检查代码规范则是通过<code>pre-commit</code>去执行的。</p><blockquote><p>可以通过<a href="https://so1n.me/2021/08/10/%E4%BF%9D%E9%9A%9CPython%E9%A1%B9%E7%9B%AE%E8%B4%A8%E9%87%8F%E7%9A%84%E5%B7%A5%E5%85%B7/#1-%E9%A1%B9%E7%9B%AE%E7%8E%AF%E5%A2%83%E7%AE%A1%E7%90%86-Poetry">保障Python项目质量的工具</a>了解有什么提升代码质量的工具以及如何使用<code>pre-commit</code>。</p></blockquote><p>在<code>poetry</code>可以通过如下方式安装<code>pytest</code>, <code>pytest-asyncio</code>和<code>pre-commit</code>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">poetry add --group=dev pre-commit pytest pytest-asyncio<br></code></pre></td></tr></table></figure><p>执行完命令后可以发现<code>pyproject.toml</code>新增了如下内容:</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs toml"><span class="hljs-section">[tool.poetry.group.dev.dependencies]</span><br><span class="hljs-attr">pytest</span> = <span class="hljs-string">&quot;^7.2.0&quot;</span><br><span class="hljs-attr">pre-commit</span> = <span class="hljs-string">&quot;^2.20.0&quot;</span><br><span class="hljs-attr">pytest-asyncio</span> = <span class="hljs-string">&quot;^0.20.2&quot;</span><br></code></pre></td></tr></table></figure><p>这块内容表示<code>Poetry</code>托管的虚拟环境安装了<code>pytest</code>和<code>pre-commit</code>的依赖，但是他们是属于<code>dev</code>组的，在正式情况下不会被使用，这对于导出依赖时非常有作用。</p><p>接下来先检查项目的代码格式，首先创建<code>.pre-commit-config.yaml</code>文件，并输入如下内容</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">repos:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">repo:</span> <span class="hljs-string">https://github.com/pre-commit/mirrors-mypy</span><br>    <span class="hljs-attr">rev:</span> <span class="hljs-string">v0.910</span><br>    <span class="hljs-attr">hooks:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">mypy</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">repo:</span> <span class="hljs-string">https://github.com/PyCQA/isort</span><br>    <span class="hljs-attr">rev:</span> <span class="hljs-number">5.9</span><span class="hljs-number">.3</span><br>    <span class="hljs-attr">hooks:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">isort</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">repo:</span> <span class="hljs-string">https://github.com/psf/black</span><br>    <span class="hljs-attr">rev:</span> <span class="hljs-number">21.</span><span class="hljs-string">7b0</span><br>    <span class="hljs-attr">hooks:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">black</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">repo:</span> <span class="hljs-string">https://github.com/PyCQA/flake8</span><br>    <span class="hljs-attr">rev:</span> <span class="hljs-number">3.9</span><span class="hljs-number">.2</span><br>    <span class="hljs-attr">hooks:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">flake8</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">repo:</span> <span class="hljs-string">https://github.com/myint/autoflake</span><br>    <span class="hljs-attr">rev:</span> <span class="hljs-string">v1.4</span><br>    <span class="hljs-attr">hooks:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">autoflake</span><br>        <span class="hljs-attr">args:</span> [<span class="hljs-string">&#x27;--in-place&#x27;</span>, <span class="hljs-string">&#x27;--remove-all-unused-imports&#x27;</span>, <span class="hljs-string">&#x27;--remove-unused-variable&#x27;</span>, <span class="hljs-string">&#x27;--ignore-init-module-imports&#x27;</span>]<br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">repo:</span> <span class="hljs-string">https://github.com/pre-commit/pre-commit-hooks</span><br>    <span class="hljs-attr">rev:</span> <span class="hljs-string">v3.2.0</span><br>    <span class="hljs-attr">hooks:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">check-ast</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">check-byte-order-marker</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">check-case-conflict</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">check-docstring-first</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">check-executables-have-shebangs</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">check-json</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">check-yaml</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">debug-statements</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">detect-private-key</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">end-of-file-fixer</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">trailing-whitespace</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">mixed-line-ending</span><br><br></code></pre></td></tr></table></figure><p>然后执行如下命令:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  demo git init<br>➜  demo git:(master) ✗ poetry run pre-commit run --all-file<br></code></pre></td></tr></table></figure><p>其中第一个命令是为项目进行git初始化，第二个命令是执行代码检查。</p><blockquote><p>如果出现<code>ModuleNotFoundError: No module named &#39;_sqlite3&#39;</code>错误，可以访问<a href="https://stackoverflow.com/questions/1210664/no-module-named-sqlite3">No module named _sqlite3</a>了解如何解决。</p></blockquote><p>执行完代码检查后，在<code>tests</code>目录里面创建一个名为<code>test_demo.py</code>文件，并输入如下内容:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> pytest<br><span class="hljs-keyword">from</span> demo <span class="hljs-keyword">import</span> get_status_code<br><br><br>pytestmark = pytest.mark.asyncio<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestDemo</span>:</span><br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_demo</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">assert</span> <span class="hljs-number">200</span> == <span class="hljs-keyword">await</span> get_status_code()<br></code></pre></td></tr></table></figure><p>接着运行<code>poetry run pytest --capture=no -v</code>执行测试结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  demo git:(master) ✗ poetry run pytest --capture=no -v<br>============================ <span class="hljs-built_in">test</span> session starts =============================<br>platform linux -- Python 3.9.10, pytest-7.2.0, pluggy-1.0.0 -- /home/so1n/demo/.venv/bin/python<br>cachedir: .pytest_cache<br>rootdir: /home/so1n/demo<br>plugins: anyio-3.6.2, asyncio-0.20.2<br>asyncio: mode=strict<br>collected 1 item                                                             <br><br>tests/test_demo.py::TestDemo::test_demo PASSED<br><br>============================= 1 passed <span class="hljs-keyword">in</span> 0.32s ==============================<br></code></pre></td></tr></table></figure><p>发现测试正常，接下来可以生成项目的依赖，使其他没有使用<code>Poetry</code>的环境也可以读取到项目的依赖，对应的命令如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">poetry <span class="hljs-built_in">export</span> -o requirements.txt --without-hashes --with-credentials<br>poetry <span class="hljs-built_in">export</span> -o requirements-dev.txt --without-hashes --with-credentials --with dev<br></code></pre></td></tr></table></figure><p>其中第一条命令是生成正常使用下的依赖，第二条命令是包含测试环境的依赖。</p><h2 id="5-打包与发布"><a href="#5-打包与发布" class="headerlink" title="5.打包与发布"></a>5.打包与发布</h2><p>如果这个项目想发到<code>PyPi</code>供别人使用，那么可以先打包项目再发布到<code>PyPi</code>中，这时候需要先修改<code>pyproject.toml</code>中<code>version</code>的值，比如把它改为<code>0.0.2</code>，再通过<code>poetry builld</code>和<code>poetry publish</code>命令发布。<br>当然，除了发布到<code>PyPi</code>外，还可能把项目的代码发布到<code>Github</code>中，同时为了让开发者快速的找到对应的版本，往往会给当前的<code>commit</code>打上对应的tag，这就代表着我们必须保证<code>version</code>中的值与<code>tag</code>是一致的，此外，项目中<code>demo/__init__.py</code>也需要添加如下内容:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">__version__ = <span class="hljs-string">&quot;0.0.2&quot;</span><br></code></pre></td></tr></table></figure><p>使得别人在引用这个项目时知道项目的版本号是多少，这样一来每次做项目升级的时候需要同时修改三处地方的版本号，非常折腾，为了省心省力，可以采用<code>Poetry</code>的一个插件–<a href="https://github.com/mtkennerly/poetry-dynamic-versioning">poetry-dynamic-versioning</a>来解决这个问题。</p><p>首先是通过命令:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">poetry self add <span class="hljs-string">&quot;poetry-dynamic-versioning[plugin]&quot;</span><br></code></pre></td></tr></table></figure><p>向<code>Poetry</code>安装插件，然后向<code>pyproject.toml</code>添加如下内容:</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs toml"><span class="hljs-section">[tool.poetry-dynamic-versioning]</span><br><span class="hljs-attr">enable</span> = <span class="hljs-literal">true</span>       <span class="hljs-comment"># 代表启用该插件</span><br><span class="hljs-attr">metadata</span>=<span class="hljs-literal">false</span>      <span class="hljs-comment"># 生成的版本号不带上其他数据</span><br><span class="hljs-attr">vcs</span> = <span class="hljs-string">&quot;git&quot;</span>         <span class="hljs-comment"># 指定的版本控制系统为git</span><br><span class="hljs-attr">format</span> = <span class="hljs-string">&quot;v&#123;base&#125;&quot;</span>  <span class="hljs-comment"># 指定版本号的生成规则</span><br></code></pre></td></tr></table></figure><p>接着把<code>pyproject.toml</code>文件中的<code>build-system</code>块替换为如下内容:</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs toml"><span class="hljs-section">[build-system]</span><br><span class="hljs-attr">requires</span> = [<span class="hljs-string">&quot;poetry-core&gt;=1.0.0&quot;</span>, <span class="hljs-string">&quot;poetry-dynamic-versioning&quot;</span>]<br><span class="hljs-attr">build-backend</span> = <span class="hljs-string">&quot;poetry_dynamic_versioning.backend&quot;</span><br></code></pre></td></tr></table></figure><p>最后把<code>pyproject.toml</code>和<code>demo/__init__.py</code>中的版本号改为<code>&quot;0.0.0&quot;</code>（这是<code>poetry-dynamic-versioning</code>的一个动态版本号占位符）</p><p>一切准备就绪后可以执行如下命令进行代码提交以及打上对应的版本tag:</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">➜  demo git:(<span class="hljs-literal">master</span>) ✗ git add *<br>➜  demo git:(<span class="hljs-literal">master</span>) ✗ git commit -m<span class="hljs-string">&quot;Add, First commit&quot;</span><br>➜  demo git:(<span class="hljs-literal">master</span>) ✗ git <span class="hljs-keyword">tag</span> <span class="hljs-title">v0</span>.<span class="hljs-number">0.2</span><br></code></pre></td></tr></table></figure><p>接下来执行<code>poetry build</code>对项目打包:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  demo git:(master) ✗ poetry build<br>Building demo (v0.0.2)<br>  - Building sdist<br>  - Built demo-0.0.2.tar.gz<br>  - Building wheel<br>  - Built demo-0.0.2-py3-none-any.whl<br></code></pre></td></tr></table></figure><p>通过命令可以发现包的版本正好是我们提交的tag<code>v0.0.2</code>中的<code>0.0.2</code>，如果找到包里面的<code>demo/__init__.py</code>的文件，可以发现文件中存在如下一行代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">__version__ = <span class="hljs-string">&quot;v0.0.2&quot;</span><br></code></pre></td></tr></table></figure><p>其中<code>__version__</code>的值与<code>tag</code>一样。</p><p>打包完成后就可以把包传到<code>PyPi</code>了，不过在第一次上传之前需要通过如下命令配置自己的<code>PyPi</code>账户信息:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># my-token可以在`pypi.org`网站中设置</span><br>poetry config pypi-token.pypi my-token<br><span class="hljs-comment"># 或者通过如下命令配置自己的账号密码</span><br>poetry config http-basic.pypi &lt;username&gt; &lt;password&gt;<br></code></pre></td></tr></table></figure><p>最后通过<code>poetry publish</code>命令即可把包传到<code>PyPi</code>中</p><h2 id="6-Poetry的pre-commit"><a href="#6-Poetry的pre-commit" class="headerlink" title="6.Poetry的pre-commit"></a>6.Poetry的pre-commit</h2><p>从上面的流程可以发现<code>Poetry</code>为我们带来方便的虚拟环境管理和依赖管理，但有些时候仍然需要我们调用<code>poetry update</code>来确定依赖有及时更新以及通过<code>poetry export</code>来导出依赖，这时可以通过<code>pre-commit-config</code>来确保提交代码的时候能执行自动执行<code>poetry update</code>和<code>poetry export</code>等语法。</p><p>第一步先向<code>.pre-commit-config.yaml</code>追加如下内容:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs toml">- repo: https://github.com/python-poetry/poetry<br>  rev: &#x27;&#x27;  # add version here<br>  hooks:<br>    - id: poetry-check<br>    - id: poetry-lock<br>    - id: poetry-export<br>      args: [ &quot;-f&quot;, &quot;requirements.txt&quot;, &quot;-o&quot;, &quot;requirements.txt&quot;, &quot;--without-hashes&quot;, &quot;--with-credentials&quot;]<br>    - id: poetry-export<br>      args: [ &quot;-f&quot;, &quot;requirements.txt&quot;, &quot;-o&quot;, &quot;requirements-dev.txt&quot;, &quot;--without-hashes&quot;, &quot;--with-credentials&quot;, &quot;--with&quot;, &quot;dev&quot;]<br></code></pre></td></tr></table></figure><p>并执行如下命令:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">poetry run pre-commit install<br>poetry run pre-commit run --all-file<br></code></pre></td></tr></table></figure><p>验证<code>pre-commit</code>是否正常执行。</p><h2 id="7-总结"><a href="#7-总结" class="headerlink" title="7.总结"></a>7.总结</h2><p>至此就可以享受<code>Poetry</code>为我们带来的便利，只要简单几部操作就可以完成虚拟环境的使用和依赖管理，但是本文还有一些内容没有介绍，可以通过<a href="https://python-poetry.org/docs/">官方文档</a>了解<code>Poetry</code>的更多功能。<br>``</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前记&quot;&gt;&lt;a href=&quot;#前记&quot; class=&quot;headerlink&quot; title=&quot;前记&quot;&gt;&lt;/a&gt;前记&lt;/h2&gt;&lt;p&gt;一个项目最重要的就是跑起来， 大家基本会同时在本地开发多个项目， 而每个项目用到的环境都是不一样的， 如果这些项目都共用一份依赖那么会导致多个项目的依赖发生冲突以及导致线上服务不稳定，所以就需要用到虚拟环境隔离。在&lt;code&gt;Python&lt;/code&gt;中提供了名为&lt;code&gt;venv&lt;/code&gt;的虚拟环境管理包用于做多个项目的环境隔离，它提供了很多基础的功能，但是还有很多功能都需要开发者手动操作非常不方便，这时候就可以用到&lt;code&gt;Poetry&lt;/code&gt;啦。&lt;/p&gt;</summary>
    
    
    <content src="https://files.catbox.moe/66hvqo.png" type="image"/>
    
    
    <category term="Python" scheme="http://so1n.me/categories/Python/"/>
    
    
    <category term="Python" scheme="http://so1n.me/tags/Python/"/>
    
    <category term="Poetry" scheme="http://so1n.me/tags/Poetry/"/>
    
  </entry>
  
  <entry>
    <title>Python-gRPC实践(8)--Protobuf插件</title>
    <link href="http://so1n.me/2022/11/22/Python-gRPC%E5%AE%9E%E8%B7%B5(8)--Protobuf%E6%8F%92%E4%BB%B6%20copy/"/>
    <id>http://so1n.me/2022/11/22/Python-gRPC%E5%AE%9E%E8%B7%B5(8)--Protobuf%E6%8F%92%E4%BB%B6%20copy/</id>
    <published>2022-11-22T12:35:24.000Z</published>
    <updated>2022-11-25T12:32:51.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近在完善一个<code>Protobuf</code>中的<code>Message</code>转为<code>pydantic.BaseModel</code>对象的库–<a href="https://github.com/so1n/protobuf_to_pydantic">protobuf_to_pydantic</a>，想为它增加一个从原生<code>Protobuf</code>文件直接生成对应<code>pydantic.BaseModel</code>对象源代码的功能，在通过了解后发现可以通过<code>Protobuf</code>插件的形式来实现</p><p>但是搜索了大量的资源后才发现大多数的<code>Protobuf</code>插件都是由<code>Go</code>编写的，并且没有(或者很少)关于<code>Python</code>插件的编写教程以及在<a href="https://googleapis.dev/python/protobuf/latest/">Python Protobuf官方文档</a>中找不到任何关于<code>Plugin</code>的介绍，所以踩了很多坑，而本文也就成了我编写<code>Protobuf</code>插件的踩坑总结</p><span id="more"></span><p>如果不知道如何编写<code>Protobuf</code>文件以及如何生成对应的<code>Python</code>代码，可以先阅读<a href="https://so1n.me/2022/04/07/Python-gRPC%E5%AE%9E%E8%B7%B5(3)--%E4%BD%BF%E7%94%A8Python%E5%AE%9E%E7%8E%B0gRPC%E6%9C%8D%E5%8A%A1/">Python-gRPC实践(3)–使用Python实现gRPC服务</a></p><h2 id="1-什么是Protobuf插件"><a href="#1-什么是Protobuf插件" class="headerlink" title="1.什么是Protobuf插件"></a>1.什么是Protobuf插件</h2><p>在官方的介绍中，<code>Protobuf</code>插件是一个标准的程序，它会从标准输入读取协议缓冲区并写入到<code>CodeGeneratorRequest</code>对象中，然后将<code>CodeGeneratorResponse</code>序列化后通过协议缓冲区写进标准输出，其中这些消息类型是在<a href="https://developers.google.com/protocol-buffers/docs/reference/cpp/google.protobuf.compiler.plugin.pb">plugin.proto</a>中定义的。</p><p>同时，在使用的过程中可以通过<code>CodeGeneratorRequest</code>获取到<code>Protobuf</code>文件所描述的对象(在<code>Protobuf</code>中称为<code>FileDescriptorProto</code>)，通过这个<code>FileDescriptorProto</code>对象可以得到文件中的所有信息，比如<a href="https://github.com/nipunn1313/mypy-protobuf">mypy-protobuf</a>就是通过<code>CodeGeneratorRequest</code>对象来生成对应的<code>pyi</code>文件内容，最后再通过<code>CodeGeneratorResponse</code>对象把内容写入到对应的文件中。</p><p>如果熟悉<code>Linux</code>的管道，就能知道<code>Protobuf</code>插件的原理与<code>Linux</code>的管道类似，比如下面的例子，首先现在有一个文本文件名为<code>demo.txt</code>,它的内容如下:</p><figure class="highlight mercury"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mercury">This <span class="hljs-keyword">is</span> line <span class="hljs-number">1</span>.<br>This <span class="hljs-keyword">is</span> line <span class="hljs-number">2</span>.<br></code></pre></td></tr></table></figure><p>而在调用命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cat demo.txt| sed -e 2a\n<span class="hljs-string">&#x27;wahaha&#x27;</span> &gt; new_demo.txt<br></code></pre></td></tr></table></figure><p>后就可以发现新增了一个名为<code>new_demo.txt</code>的文件，且内容如下：</p><figure class="highlight mercury"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mercury">This <span class="hljs-keyword">is</span> line <span class="hljs-number">1</span>.<br>This <span class="hljs-keyword">is</span> line <span class="hljs-number">2</span>.<br>wahaha<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>demo.txt</code>可以比喻为原来的<code>Protobuf</code>文件，<code>cat</code>命令是加载<code>Protobuf</code>文件的<code>protoc</code>命令，而<code>|</code>就是一个管道，通过<code>|</code>把数据流传到下一个命令中，而<code>sed</code>命令可以认为是一个插件，其中<code>2a\n&#39;wahaha&#39;</code>就是插件要修改的内容，这里的意思就是在第二行后追加一段指定的文本，最后<code>&gt;</code>就是像<code>CodeGeneratorResponse</code>对象一样把管道的数据写入指定的文件中。</p><blockquote><p><code>Linux</code>管道只允许一个输出流(在不算错误的管道的情况下)，而<code>Protoc</code>命令生成的代码输出不会被插件影响，插件间的输出也不会互相影响。</p></blockquote><p>简单的了解了<code>Protobuf</code>插件后，接下来以<a href="https://github.com/so1n/grpc-example-common/tree/master">grpc-example-common</a>项目为例，介绍如何制作<code>Protobuf</code>插件。</p><h2 id="2-制作一个Protobuf插件"><a href="#2-制作一个Protobuf插件" class="headerlink" title="2.制作一个Protobuf插件"></a>2.制作一个Protobuf插件</h2><p>首先是确保已经安装了<code>gRPC</code>和<code>Protobuf</code>的依赖，接着在根目录创建一个名为<code>example_plugin.py</code>的文件，该文件的代码和注释如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> logging<br><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> Set, Iterator, Tuple<br><span class="hljs-keyword">from</span> contextlib <span class="hljs-keyword">import</span> contextmanager<br><br><span class="hljs-keyword">from</span> google.protobuf.compiler.plugin_pb2 <span class="hljs-keyword">import</span> CodeGeneratorRequest, CodeGeneratorResponse<br><br><span class="hljs-comment"># 初始化logger</span><br>logger = logging.getLogger(__name__)<br>logging.basicConfig(<br>    <span class="hljs-built_in">format</span>=<span class="hljs-string">&quot;[%(asctime)s %(levelname)s] %(message)s&quot;</span>, datefmt=<span class="hljs-string">&quot;%y-%m-%d %H:%M:%S&quot;</span>, level=logging.INFO<br>)<br><br><span class="hljs-meta">@contextmanager</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">code_generation</span>() -&gt; Iterator[Tuple[CodeGeneratorRequest, CodeGeneratorResponse]]:</span><br>    <span class="hljs-string">&quot;&quot;&quot;模仿mypy-protobuf的代码&quot;&quot;&quot;</span><br>    <span class="hljs-comment"># 从程序的标准输入读取对应的数据到 CodeGeneratorRequest对象中</span><br>    request: CodeGeneratorResponse = CodeGeneratorRequest.FromString(sys.stdin.buffer.read())<br>    <span class="hljs-comment"># 初始化 CodeGeneratorResponse 对象 </span><br>    response: CodeGeneratorResponse = CodeGeneratorResponse()<br><br>    <span class="hljs-comment"># 声明插件是支持版本为3的protobuf文件也可以使用`OPTIONAL`语法。</span><br>    <span class="hljs-comment"># protoc程序默认是支持的，而插件则是默认不支持的，所以需要开启，避免执行出错。</span><br>    response.supported_features |= CodeGeneratorResponse.FEATURE_PROTO3_OPTIONAL<br><br>    <span class="hljs-keyword">yield</span> request, response<br><br>    <span class="hljs-comment"># 序列化response对象，并写入到标准输出中 </span><br>    sys.stdout.buffer.write(response.SerializeToString())<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>() -&gt; <span class="hljs-keyword">None</span>:</span><br>    <span class="hljs-keyword">with</span> code_generation() <span class="hljs-keyword">as</span> (request, response):<br>        <span class="hljs-comment"># 获取protoc命令中指定的proto路径，也就是开发者编写proto文件的集合</span><br>        file_name_set: Set[<span class="hljs-built_in">str</span>] = &#123;i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> request.file_to_generate&#125;<br>        <span class="hljs-keyword">for</span> proto_file <span class="hljs-keyword">in</span> request.proto_file:<br>            <span class="hljs-keyword">if</span> proto_file.name <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> file_name_set:<br>                <span class="hljs-comment"># 排除非开发者编写的proto文件，不做多余的解析 </span><br>                <span class="hljs-keyword">continue</span><br>            <span class="hljs-comment"># 打印protobuf文件名</span><br>            logger.info(proto_file.name)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    main()<br></code></pre></td></tr></table></figure><p>通过代码可以发现，这个插件只是一个雏形，它非常简单，只是通过<code>logger</code>打印出插件加载到的<code>Protobuf</code>文件名。</p><p>在编写完插件后就可以尝试运行插件了，<code>Protobuf</code>插件是通过<code>protoc</code>命令运行的，在还没使用插件之前，先看看执行生成<code>Python</code>文件的命令长啥样：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">python -m grpc_tools.protoc \<br>  --python_out=./ \<br>  --grpc_python_out=./ \<br>  -I protos $(find ./protos -name <span class="hljs-string">&#x27;*.proto&#x27;</span>)<br></code></pre></td></tr></table></figure><p><code>protoc</code>命令会加载<code>-I</code>指定的<code>Protobuf</code>文件路径，也就是当前路径下<code>protos</code>目录里面的所有后缀为<code>.proto</code>的文件，而<code>python_out</code>和<code>grpc_python_out</code>是指定生成<code>Python</code>代码的路径，由于定义它们的路径都为<code>.</code>，那么命令会在类似的路径下生成对应的<code>Python</code>代码，比如<code>Protobuf</code>文件所在的目录结构如下：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs armasm">.  # 也就是项目的根目录grpc-example-<span class="hljs-meta">common</span><br>└── protos<br>    └── grpc_example_common<br>        └── protos<br>            ├── book<br>            ├── <span class="hljs-meta">common</span><br>            └── user<br></code></pre></td></tr></table></figure><p>其中<code>Protobuf</code>文件分别位于<code>book</code>, <code>common</code>, <code>user</code>这三个目录中，那么该命令会在项目的根目录下生成对应的<code>Python</code>代码文件，生成文件后的项目目录如下：</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs clean">.  # 也就是项目的根目录grpc-example-common<br>├── grpc_example_common # 这里本来是grpc-example-common，但生成的时候会自动专为grpc_example_common <br>│   └── protos<br>│       └── grpc_example_common<br>│           └── protos<br>│               ├── book   # &lt;--- book的Protobuf文件生成的`Python`代码文件下这里<br>│               ├── common # &lt;--- common的Protobuf文件生成的`Python`代码文件下这里<br>│               └── user   # &lt;--- user的Protobuf文件生成的`Python`代码文件下这里<br>└── protos<br>    └── grpc_example_common<br>        └── protos<br>            ├── book<br>            ├── common<br>            └── user<br></code></pre></td></tr></table></figure><p>现在为了向<code>protoc</code>命令引入我们刚才编写的插件，需要对命令进行修改，如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">python -m grpc_tools.protoc \<br>  --plugin=protoc-gen-custom-plugin=./example_plugin.py --custom-plugin_out=. \<br>  --mypy_grpc_out=./ \<br>  --mypy_out=./ \<br>  --python_out=./ \<br>  --grpc_python_out=./ \<br>  -I protos $(find ./protos -name <span class="hljs-string">&#x27;*.proto&#x27;</span>)<br></code></pre></td></tr></table></figure><p>这条命令多了一行内容为<code>--plugin=protoc-gen-custom-plugin=./example_plugin.py --custom-plugin_out=.</code>的文本，其中<code>--plugin</code>指定的值永远要以<code>protoc-gen-</code>开头，后面跟着的<code>custom-plugin</code>则是本次插件的名，<code>=./example_plugin.py</code>则是定义<code>custome-plugin</code>插件的路径。至于后面的<code>--custom-plugin_out=.</code>则是用来定义插件<code>custom-plugin</code>的输出路径为<code>.</code>，也就是插件处理每一个<code>Protobuf</code>文件后输出的文件与<code>protoc</code>命令是同一个目录的。</p><blockquote><p>为了保证插件正确加载，需要确保<code>--plugin=protoc-gen-custom-plugin</code>中的<code>custom-plugin</code>与<code>--custom-plugin_out</code>中的<code>custom-plugin</code>一致。<br>同时需要注意<code>--plugin=protoc-gen-custom-plugin=./example_plugin.py --custom-plugin_out=. \</code>中最后的文本是<code>. \</code>而不是<code>.\</code>，如果是<code>.\</code>则会导致<code>protoc</code>命令执行出错。</p></blockquote><p>再执行完这个命令后可以在终端看到如下输出:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">[22-11-22 20:39:25 INFO] grpc_example_common/protos/book/manager.proto<br>[22-11-22 20:39:25 INFO] grpc_example_common/protos/book/social.proto<br>[22-11-22 20:39:25 INFO] grpc_example_common/protos/common/p2p_validate.proto<br>[22-11-22 20:39:25 INFO] grpc_example_common/protos/common/exce.proto<br></code></pre></td></tr></table></figure><p>不过除了生成<code>Python</code>代码外并没有其他文件生成，这是因为现在编写的插件还没有向<code>CodeGeneratorResponse</code>写入任何内容。</p><p>为了让插件能够输出内容，现在先编写一个接收文件对象<code>FileDescriptorProto</code>并生成对应Json文件的处理函数<code>process_file</code>，代码如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">process_file</span>(<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">    proto_file: FileDescriptorProto, response: CodeGeneratorResponse</span></span><br><span class="hljs-function"><span class="hljs-params"></span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>    options = <span class="hljs-built_in">str</span>(proto_file.options).strip().replace(<span class="hljs-string">&quot;\n&quot;</span>, <span class="hljs-string">&quot;, &quot;</span>).replace(<span class="hljs-string">&#x27;&quot;&#x27;</span>, <span class="hljs-string">&quot;&quot;</span>)<br>    file = response.file.add()  <span class="hljs-comment"># 向响应对象添加并返回一个输出的文件对象</span><br>    file.name = proto_file.name + <span class="hljs-string">&quot;.json&quot;</span>  <span class="hljs-comment"># 指定输出文件的名字</span><br>    <span class="hljs-comment"># 指定输出文件的内容</span><br>    file.content = json.dumps(<br>        &#123;<br>            <span class="hljs-string">&quot;package&quot;</span>: <span class="hljs-string">f&quot;<span class="hljs-subst">&#123;proto_file.package&#125;</span>&quot;</span>,  <span class="hljs-comment"># protobuf 包名</span><br>            <span class="hljs-string">&quot;filename&quot;</span>: <span class="hljs-string">f&quot;<span class="hljs-subst">&#123;proto_file.name&#125;</span>&quot;</span>,    <span class="hljs-comment"># protobuf 文件名</span><br>            <span class="hljs-string">&quot;dependencies&quot;</span>: <span class="hljs-built_in">list</span>(proto_file.dependency),  <span class="hljs-comment"># protobuf依赖</span><br>            <span class="hljs-string">&quot;message_type&quot;</span>: [MessageToDict(i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> proto_file.message_type],  <span class="hljs-comment"># protobuf 定义的message</span><br>            <span class="hljs-string">&quot;service&quot;</span>: [MessageToDict(i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> proto_file.service],  <span class="hljs-comment"># protobuf定义的service</span><br>            <span class="hljs-string">&quot;public_dependency&quot;</span>: <span class="hljs-built_in">list</span>(proto_file.public_dependency),    <span class="hljs-comment"># protobuf定义的依赖</span><br>            <span class="hljs-string">&quot;enum_type&quot;</span>: [MessageToDict(i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> proto_file.enum_type],  <span class="hljs-comment"># protobuf定义的枚举值</span><br>            <span class="hljs-string">&quot;extension&quot;</span>: [MessageToDict(i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> proto_file.extension],  <span class="hljs-comment"># protobuf定义的拓展</span><br>            <span class="hljs-string">&quot;options&quot;</span>: <span class="hljs-built_in">dict</span>(item.split(<span class="hljs-string">&quot;: &quot;</span>) <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> options.split(<span class="hljs-string">&quot;, &quot;</span>) <span class="hljs-keyword">if</span> options),  <span class="hljs-comment"># protobuf定义的options</span><br>        &#125;,<br>        indent=<span class="hljs-number">2</span><br>    ) + <span class="hljs-string">&quot;\r\n&quot;</span><br><br></code></pre></td></tr></table></figure><p>接着更改插件中<code>main</code>函数:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>() -&gt; <span class="hljs-keyword">None</span>:</span><br>    <span class="hljs-keyword">with</span> code_generation() <span class="hljs-keyword">as</span> (request, response):<br>        <span class="hljs-comment"># 获取protoc命令中指定的proto路径</span><br>        file_name_set: Set[<span class="hljs-built_in">str</span>] = &#123;i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> request.file_to_generate&#125;<br>        <span class="hljs-keyword">for</span> proto_file <span class="hljs-keyword">in</span> request.proto_file:<br>            <span class="hljs-keyword">if</span> proto_file.name <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> file_name_set:<br>                <span class="hljs-comment"># 排除非开发者编写的proto文件，不做多余的解析 </span><br>                <span class="hljs-keyword">continue</span><br>            process_file(proto_file, response)  <span class="hljs-comment"># &lt;----修改这里</span><br></code></pre></td></tr></table></figure><p>然后再运行<code>protoc</code>命令即可看到对应的输出结果了，比如对于<code>user.proto</code>,生成的json内容如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;package&quot;</span>: <span class="hljs-string">&quot;user&quot;</span>,<br>  <span class="hljs-attr">&quot;filename&quot;</span>: <span class="hljs-string">&quot;grpc_example_common/protos/user/user.proto&quot;</span>,<br>  <span class="hljs-attr">&quot;dependencies&quot;</span>: [<span class="hljs-string">&quot;google/protobuf/empty.proto&quot;</span>],<br>  <span class="hljs-attr">&quot;message_type&quot;</span>: [<br>    &#123;<br>      <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;CreateUserRequest&quot;</span>,<br>      <span class="hljs-attr">&quot;field&quot;</span>: [<br>        &#123; <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;uid&quot;</span>, <span class="hljs-attr">&quot;number&quot;</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">&quot;label&quot;</span>: <span class="hljs-string">&quot;LABEL_OPTIONAL&quot;</span>, <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;TYPE_STRING&quot;</span>, <span class="hljs-attr">&quot;jsonName&quot;</span>: <span class="hljs-string">&quot;uid&quot;</span> &#125;,<br>        &#123; <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;user_name&quot;</span>, <span class="hljs-attr">&quot;number&quot;</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">&quot;label&quot;</span>: <span class="hljs-string">&quot;LABEL_OPTIONAL&quot;</span>, <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;TYPE_STRING&quot;</span>, <span class="hljs-attr">&quot;jsonName&quot;</span>: <span class="hljs-string">&quot;userName&quot;</span> &#125;,<br>        &#123; <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;password&quot;</span>, <span class="hljs-attr">&quot;number&quot;</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">&quot;label&quot;</span>: <span class="hljs-string">&quot;LABEL_OPTIONAL&quot;</span>, <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;TYPE_STRING&quot;</span>, <span class="hljs-attr">&quot;jsonName&quot;</span>: <span class="hljs-string">&quot;password&quot;</span> &#125;<br>      ]<br>    &#125;,<br>  ],<br>  <span class="hljs-attr">&quot;service&quot;</span>: [<br>    &#123;<br>      <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;User&quot;</span>,<br>      <span class="hljs-attr">&quot;method&quot;</span>: [<br>        &#123; <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;get_uid_by_token&quot;</span>, <span class="hljs-attr">&quot;inputType&quot;</span>: <span class="hljs-string">&quot;.user.GetUidByTokenRequest&quot;</span>, <span class="hljs-attr">&quot;outputType&quot;</span>: <span class="hljs-string">&quot;.user.GetUidByTokenResult&quot;</span> &#125;,<br>        &#123; <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;logout_user&quot;</span>, <span class="hljs-attr">&quot;inputType&quot;</span>: <span class="hljs-string">&quot;.user.LogoutUserRequest&quot;</span>, <span class="hljs-attr">&quot;outputType&quot;</span>: <span class="hljs-string">&quot;.google.protobuf.Empty&quot;</span> &#125;,<br>        &#123; <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;login_user&quot;</span>, <span class="hljs-attr">&quot;inputType&quot;</span>: <span class="hljs-string">&quot;.user.LoginUserRequest&quot;</span>, <span class="hljs-attr">&quot;outputType&quot;</span>: <span class="hljs-string">&quot;.user.LoginUserResult&quot;</span> &#125;,<br>        &#123; <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;create_user&quot;</span>, <span class="hljs-attr">&quot;inputType&quot;</span>: <span class="hljs-string">&quot;.user.CreateUserRequest&quot;</span>, <span class="hljs-attr">&quot;outputType&quot;</span>: <span class="hljs-string">&quot;.google.protobuf.Empty&quot;</span> &#125;,<br>        &#123; <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;delete_user&quot;</span>, <span class="hljs-attr">&quot;inputType&quot;</span>: <span class="hljs-string">&quot;.user.DeleteUserRequest&quot;</span>, <span class="hljs-attr">&quot;outputType&quot;</span>: <span class="hljs-string">&quot;.google.protobuf.Empty&quot;</span> &#125;<br>      ]<br>    &#125;<br>  ],<br>  <span class="hljs-attr">&quot;public_dependency&quot;</span>: [],<br>  <span class="hljs-attr">&quot;enum_type&quot;</span>: [],<br>  <span class="hljs-attr">&quot;extension&quot;</span>: [],<br>  <span class="hljs-attr">&quot;options&quot;</span>: &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过输出的内容可以看出通过插件的方式可以获得到<code>Protobuf</code>文件中的很多输出，而且除了这些数据外，还能提供对应<code>Message</code>的<code>Option</code>数据以及通过<code>proto_file.source_code_info</code>获得到完整的源码信息。</p><blockquote><p>json文件中的<code>message_type</code>内容比较多，所以省略的一些输出，详细的输出可以通过<a href="https://github.com/so1n/grpc-example-common/tree/grpc-plugin/grpc_example_common/protos">grpc_example_common/protos</a>查看每个<code>Protobuf</code>文件的输出。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;最近在完善一个&lt;code&gt;Protobuf&lt;/code&gt;中的&lt;code&gt;Message&lt;/code&gt;转为&lt;code&gt;pydantic.BaseModel&lt;/code&gt;对象的库–&lt;a href=&quot;https://github.com/so1n/protobuf_to_pydantic&quot;&gt;protobuf_to_pydantic&lt;/a&gt;，想为它增加一个从原生&lt;code&gt;Protobuf&lt;/code&gt;文件直接生成对应&lt;code&gt;pydantic.BaseModel&lt;/code&gt;对象源代码的功能，在通过了解后发现可以通过&lt;code&gt;Protobuf&lt;/code&gt;插件的形式来实现&lt;/p&gt;
&lt;p&gt;但是搜索了大量的资源后才发现大多数的&lt;code&gt;Protobuf&lt;/code&gt;插件都是由&lt;code&gt;Go&lt;/code&gt;编写的，并且没有(或者很少)关于&lt;code&gt;Python&lt;/code&gt;插件的编写教程以及在&lt;a href=&quot;https://googleapis.dev/python/protobuf/latest/&quot;&gt;Python Protobuf官方文档&lt;/a&gt;中找不到任何关于&lt;code&gt;Plugin&lt;/code&gt;的介绍，所以踩了很多坑，而本文也就成了我编写&lt;code&gt;Protobuf&lt;/code&gt;插件的踩坑总结&lt;/p&gt;</summary>
    
    
    <content src="https://ftp.bmp.ovh/imgs/2022/02/bd67e15aa8d46101.png" type="image"/>
    
    
    <category term="Python-gRPC实践" scheme="http://so1n.me/categories/Python-gRPC%E5%AE%9E%E8%B7%B5/"/>
    
    
    <category term="Python" scheme="http://so1n.me/tags/Python/"/>
    
    <category term="gRPC" scheme="http://so1n.me/tags/gRPC/"/>
    
    <category term="Protobuf" scheme="http://so1n.me/tags/Protobuf/"/>
    
  </entry>
  
  <entry>
    <title>使用Pait快速构建gRPC Json网关</title>
    <link href="http://so1n.me/2022/10/29/%E4%BD%BF%E7%94%A8Pait%E6%9E%84%E5%BB%BAgRPC%20Json%E7%BD%91%E5%85%B3/"/>
    <id>http://so1n.me/2022/10/29/%E4%BD%BF%E7%94%A8Pait%E6%9E%84%E5%BB%BAgRPC%20Json%E7%BD%91%E5%85%B3/</id>
    <published>2022-10-29T12:31:18.000Z</published>
    <updated>2022-11-22T06:14:46.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前记"><a href="#前记" class="headerlink" title="前记"></a>前记</h2><p><code>gRPC</code>已经是一个大多数开发者使用微服务时选择的通信协议，大多数公司的内部服务都会通过<code>gRPC</code>来通信，但是服务端和客户端使用的通信协议还是<code>HTTP</code>，这就意味着需要在客户端和内部服务之间架起一个可以转换<code>HTTP</code>与<code>gRPC</code>协议的网关。<br><a href="https://github.com/so1n/pait">pait</a>的<code>gRPC Gateway</code>模块就是实现了这样的一个功能，<code>gRPC Gateway</code>模块通过<code>pait</code>能快速的把<code>Python</code>Web框架和<code>gRPC</code>连接起来，并自动处理和转发请求。</p><blockquote><p>目前只支持<code>Flask</code>, <code>Starlite</code>, <code>Sanic</code>, <code>Tornado</code></p></blockquote><h2 id="1-一个简单的例子"><a href="#1-一个简单的例子" class="headerlink" title="1.一个简单的例子"></a>1.一个简单的例子</h2><p>在介绍如何使用<code>Pait</code>快速构建<code>gRPC Json</code>网关之前先以一个简单的示例项目为例子来介绍没用网关前的局限性。</p><blockquote><p>例子项目代码见附录一链接</p></blockquote><p>在这个例子中存在一个客户端和三个后端服务，其中<code>gRPC</code>服务有两个，一个是负责用户的创建、注销、登录、登出，token校验五个功能的<code>User</code>服务;另外一个是负责书本的信息获取和书本评论和点赞等功能的<code>book</code>服务。而剩下的后端服务是使用<code>Flask</code>框架构建的API服务，它负责暴露出HTTP接口供客户端调用，当被客户端调用时会把请求进行处理并通过<code>gRPC</code>客户端转发给另外两个<code>gRPC</code>服务，他们的关系图如下：<br><img   class="lazyload" data-original="https://files.catbox.moe/s5e3hf.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" ><br>通过关系图可以发现客户端只与<code>Flask</code>应用通过HTTP通信，<code>Flask</code>应用通过<code>gRPC</code>客户端与其它机器的<code>gRPC</code>服务通过<code>gRPC</code>进行通信，客户端无法直接访问到<code>gRPC</code>服务所在的机器<code>node2</code>和<code>node3</code>。</p><p>这个设计简单又实用，挺不错的，但是在编写代码时却有点烦恼，以用户服务为例子，编写<code>gRPC</code>服务的第一步是编写好<code>Protobuf文件</code>，其中用户服务的<code>Protobuf</code>文件描述的<code>Service</code>如下：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Protobuf"><span class="hljs-comment">// 省略其它protobuf 代码</span><br><span class="hljs-class"><span class="hljs-keyword">service</span> <span class="hljs-title">User</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">rpc</span> get_uid_by_token (GetUidByTokenRequest) <span class="hljs-keyword">returns</span> (GetUidByTokenResult)</span>;<br>  <span class="hljs-function"><span class="hljs-keyword">rpc</span> logout_user (LogoutUserRequest) <span class="hljs-keyword">returns</span> (google.protobuf.Empty)</span>;<br>  <span class="hljs-function"><span class="hljs-keyword">rpc</span> login_user(LoginUserRequest) <span class="hljs-keyword">returns</span> (LoginUserResult)</span>;<br>  <span class="hljs-function"><span class="hljs-keyword">rpc</span> create_user(CreateUserRequest) <span class="hljs-keyword">returns</span> (google.protobuf.Empty)</span>;<br>  <span class="hljs-function"><span class="hljs-keyword">rpc</span> delete_user(DeleteUserRequest) <span class="hljs-keyword">returns</span> (google.protobuf.Empty)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>第二步是根据<code>Protobuf</code>文件生成的接口代码来编写对应的代码逻辑，然后把代码部署在<code>node2</code>机器上运行。</p><p>接下来就是麻烦的第三步了，首先是根据<code>Protobuf</code>文件生成客户端代码，然后编写调用<code>gRPC</code>客户端的路由函数，代码如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Response, request<br><span class="hljs-comment"># 生成的Python文件都存放在gRPC公有包里面</span><br><span class="hljs-keyword">from</span> grpc_example_common.protos.user <span class="hljs-keyword">import</span> user_pb2 <span class="hljs-keyword">as</span> user_message<br><br><span class="hljs-keyword">from</span> app_service.utils <span class="hljs-keyword">import</span> g, get_uid_by_token, make_response<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">create_user</span>() -&gt; Response:</span><br>    request_dict: <span class="hljs-built_in">dict</span> = request.json<br>    g.user_grpc_service.create_user(<br>        uid=request_dict[<span class="hljs-string">&quot;uid&quot;</span>], user_name=request_dict[<span class="hljs-string">&quot;user_name&quot;</span>], password=request_dict[<span class="hljs-string">&quot;password&quot;</span>]<br>    )<br>    <span class="hljs-keyword">return</span> make_response()<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">delete_user</span>() -&gt; Response:</span><br>    request_dict: <span class="hljs-built_in">dict</span> = request.json<br>    g.user_grpc_service.delete_user(uid=request_dict[<span class="hljs-string">&quot;uid&quot;</span>])<br>    <span class="hljs-keyword">return</span> make_response()<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">login_route</span>() -&gt; Response:</span><br>    request_dict: <span class="hljs-built_in">dict</span> = request.json<br>    login_result: user_message.LoginUserResult = g.user_grpc_service.login_user(<br>        uid=request_dict[<span class="hljs-string">&quot;uid&quot;</span>], password=request_dict[<span class="hljs-string">&quot;password&quot;</span>]<br>    )<br>    <span class="hljs-keyword">return</span> make_response(&#123;<span class="hljs-string">&quot;token&quot;</span>: login_result.token, <span class="hljs-string">&quot;uid&quot;</span>: login_result.uid&#125;)<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">logout_route</span>() -&gt; Response:</span><br>    request_dict: <span class="hljs-built_in">dict</span> = request.json<br>    <span class="hljs-keyword">if</span> get_uid_by_token() == request_dict[<span class="hljs-string">&quot;uid&quot;</span>]:<br>        token: <span class="hljs-built_in">str</span> = request.headers.get(<span class="hljs-string">&quot;token&quot;</span>, <span class="hljs-string">&quot;&quot;</span>)<br>        g.user_grpc_service.logout_user(uid=request_dict[<span class="hljs-string">&quot;uid&quot;</span>], token=token)<br>        <span class="hljs-keyword">return</span> make_response()<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">raise</span> RuntimeError(<span class="hljs-string">&quot;Uid ERROR&quot;</span>)<br></code></pre></td></tr></table></figure><p>可以看到示例代码中的几个路由函数都是重复的获取请求参数，再把参数逐一的传给<code>gRPC</code>客户端，通过<code>gRPC</code>客户端调用得到结果后对结果反序列化再返回给客户端。</p><p>当路由函数编写完成后就需要把路由函数注册到<code>Flask</code>应用中，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">from</span> flask.blueprints <span class="hljs-keyword">import</span> Blueprint<br><br><span class="hljs-keyword">from</span> app_service <span class="hljs-keyword">import</span> user_route<br><br>user_bp: Blueprint = Blueprint(<span class="hljs-string">&quot;user_bp&quot;</span>, __name__, url_prefix=<span class="hljs-string">&quot;/api/user&quot;</span>)<br>user_bp.add_url_rule(<span class="hljs-string">&quot;/create&quot;</span>, view_func=user_route.create_user, methods=[<span class="hljs-string">&quot;POST&quot;</span>])<br>user_bp.add_url_rule(<span class="hljs-string">&quot;/delete&quot;</span>, view_func=user_route.delete_user, methods=[<span class="hljs-string">&quot;POST&quot;</span>])<br>user_bp.add_url_rule(<span class="hljs-string">&quot;/login&quot;</span>, view_func=user_route.login_route, methods=[<span class="hljs-string">&quot;POST&quot;</span>])<br>user_bp.add_url_rule(<span class="hljs-string">&quot;/logout&quot;</span>, view_func=user_route.logout_route, methods=[<span class="hljs-string">&quot;POST&quot;</span>])<br></code></pre></td></tr></table></figure><p>在把代码中的<code>blueprint</code>注册到<code>Flask</code>应用后，<code>api</code>服务也编写完成了，接着就可以部署到<code>node1</code>机器上并供客户端调用了。</p><p>可以看到这一切都非常简单，但是手动编写的重复代码比较多，通过示例代码可以看出路由函数名和url名都差别不大，每个路由代码逻辑也很像。<br>而且当想要修改<code>gRPC</code>服务的调用名称，会发现除了修改<code>Protobuf</code>文件外，<code>api</code>服务的代码也要跟着手动修改，这太麻烦了，也容易出错。</p><p>同时可以发现在上述例子中编写的转发路由代码跟<code>Protobuf</code>很像，这意味着也可以通过<code>Protobuf</code>文件生成对应的路由代码，这也是<a href="https://github.com/so1n/pait">pait</a>的实现思路，同时<a href="https://github.com/so1n/pait">pait</a><br>参照了<a href="https://github.com/googleapis/googleapis/blob/master/google/api/http.proto">google.api.http</a>来补充<code>Protobuf</code>缺少的HTTP信息，参照<a href="https://github.com/bufbuild/protoc-gen-validate">protoc-gen-validate</a>补充了请求体的信息，使<code>Protobuf</code>文件能表示<code>OpenAPI</code>的所有字段数据。</p><h2 id="2-使用Pait构建gRPC-Json网关"><a href="#2-使用Pait构建gRPC-Json网关" class="headerlink" title="2.使用Pait构建gRPC Json网关"></a>2.使用Pait构建gRPC Json网关</h2><p>了解完后，现在开始以<code>User</code>服务为例构建<code>gRPC Json</code>网关，主要涉及到API服务和Protobuf文件的修改。</p><blockquote><p>完整代码见附录二</p></blockquote><h3 id="2-1-修改Protobuf文件"><a href="#2-1-修改Protobuf文件" class="headerlink" title="2.1.修改Protobuf文件"></a>2.1.修改Protobuf文件</h3><p>使用<code>Pait</code>构建gRPC Json网关的第一步是在<code>gRPC</code>公有包中更改<code>Protobuf</code>文件, <code>gRPC</code>公有包项目结构如下:</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">.<br>├── grpc_example_common<br>│   ├── helper                  <span class="hljs-comment"># gRPC通用封装</span><br>│   ├── interceptor<br>│   │   ├── client_interceptor  <span class="hljs-comment"># gRPC客户端拦截器</span><br>│   │   └── server_interceptor  <span class="hljs-comment"># gRPC服务端拦截器</span><br>│   └── protos  <span class="hljs-comment"># 存放Protobuf文件生成的对应Python代码</span><br>│       ├── book<br>│       ├── common<br>│       └── user<br>└── protos      <span class="hljs-comment"># 存放Protobuf文件</span><br>    └── grpc_example_common<br>        └── protos<br>            ├── book    <span class="hljs-comment"># 存放书籍相关的Protobuf文件</span><br>            ├── common  <span class="hljs-comment"># 存放公有的Protobuf文件</span><br>            └── <span class="hljs-keyword">user</span>    <span class="hljs-title"># 存放用户相关的Protobuf</span>文件<br></code></pre></td></tr></table></figure><p>更改<code>Protobuf</code>文件的第一步是通过<a href="https://github.com/so1n/pait/blob/master/pait/http/api.proto">api.proto</a>和<a href="https://github.com/so1n/protobuf_to_pydantic/blob/master/p2p_validate/p2p_validate.proto">p2p_validate.proto</a>下载Protobuf文件到<code>./protos/grpc_example_common/protos/common</code>目录中，其中<code>api.proto</code>提供的是对<code>gRPC</code>接口(也就是service.rpc)的描述，<code>p2p_validate.proto</code>提供的是对<code>Message</code>的描述，下载完成后<code>./protos/grpc_example_common/protos/common</code>目录存放的<code>Protobuf</code>文件有如下3个：</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs pf">.<br>├── grpc_example_common<br>└── protos      <span class="hljs-comment"># 存放Protobuf文件</span><br>    └── grpc_example_common<br>        └── protos<br>           ├── book<br>           ├── common<br>           │   ├── api.<span class="hljs-keyword">proto</span>             <span class="hljs-comment"># &lt;-- new</span><br>           │   ├── exce.<span class="hljs-keyword">proto</span>            <span class="hljs-comment"># &lt;-- new</span><br>           │   └── p2p_validate.<span class="hljs-keyword">proto</span>    <span class="hljs-comment"># &lt;-- new</span><br>           └── <span class="hljs-keyword">user</span><br></code></pre></td></tr></table></figure><p>第二步是更改对应的Protobuf文件，以<code>User</code>服务为例子，首先是引入<code>api.proto</code>和<code>p2p_validate.proto</code>:</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Protobuf"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;grpc_example_common/protos/common/api.proto&quot;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;grpc_example_common/protos/common/p2p_validate.proto&quot;</span>;<br></code></pre></td></tr></table></figure><p>如果是使用<code>Pycharm</code>且出现如下提示:<br><img   class="lazyload" data-original="https://fastly.jsdelivr.net/gh/so1n/so1n_blog_photo@master/blog_photo/16682806984141668280697552.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" ><br>那么可以通过点击<code>Add import path to plugin settings</code>解决，如果还没办法解决而弹出一个项目文件结构的窗KPI，则点击窗口中<code>proto</code>对应的文件即可解决。</p><p>在完成头文件的引入后，就可以修改Protobuf的其他代码了，首先是修改<code>service</code>的代码，为<code>service</code>中的每一个<code>rpc</code>方法附上对应的OpenAPI信息，如下:</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs Protobuf"><span class="hljs-class"><span class="hljs-keyword">service</span> <span class="hljs-title">User</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">rpc</span> get_uid_by_token (GetUidByTokenRequest) <span class="hljs-keyword">returns</span> (GetUidByTokenResult) </span>&#123;<br>    <span class="hljs-keyword">option</span> (pait.api.http) = &#123;<br>      not_enable: <span class="hljs-literal">true</span>,   <span class="hljs-comment">// 定义Pait不解析该函数，这样Pait就不会为该函数映射到接口路由中</span><br>    &#125;;<br>  &#125;;<br>  <span class="hljs-function"><span class="hljs-keyword">rpc</span> logout_user (LogoutUserRequest) <span class="hljs-keyword">returns</span> (google.protobuf.Empty) </span>&#123;<br>    <span class="hljs-keyword">option</span> (pait.api.http) = &#123;<br>      summary: <span class="hljs-string">&quot;User exit from the system&quot;</span>,  <span class="hljs-comment">// 定义函数对应接口的简介</span><br>      <span class="hljs-comment">// url定义函数对应接口的url是&quot;/user/logout&quot;,如果不定义，则会被`Pait`自动绑定为`/User/logout_user`</span><br>      <span class="hljs-comment">// any代表具体的HTTP方法由GrpcGateway方法定义，如果要指定HTTP方法为DELETE,那么需要把any替换为delete</span><br>      any: &#123;url: <span class="hljs-string">&quot;/user/logout&quot;</span>&#125;,<br>      <span class="hljs-comment">// 定义函数接口对应的OpenAPI标签</span><br>      tag: [&#123;name: <span class="hljs-string">&quot;grpc-user&quot;</span>, desc: <span class="hljs-string">&quot;grpc_user_service&quot;</span>&#125;, &#123;name: <span class="hljs-string">&quot;user-action&quot;</span>, desc: <span class="hljs-string">&quot;User Operating Interface&quot;</span>&#125;],<br><br>      <span class="hljs-comment">// 为该函数映射一个新的接口，该接口只有如下属性不一样，其余的功能还是相同的，毕竟User服务的`logout_user`函数没有实现删除用户的功能</span><br>      additional_bindings: &#123;<br>        desc: <span class="hljs-string">&quot;This interface performs a logical delete, not a physical delete&quot;</span>,<br>        summary: <span class="hljs-string">&quot;Like delete_user&quot;</span>,<br>        delete: &#123;url: <span class="hljs-string">&quot;/user/logout&quot;</span>&#125;,<br>        tag: [<br>          &#123;name: <span class="hljs-string">&quot;grpc-user&quot;</span>, desc: <span class="hljs-string">&quot;grpc_user_service&quot;</span>&#125;,<br>          &#123;name: <span class="hljs-string">&quot;grpc-user-system&quot;</span>, desc: <span class="hljs-string">&quot;grpc_user_service&quot;</span>&#125;<br>        ]<br>      &#125;<br>    &#125;;<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>接着再修改<code>gRPC</code>函数对应的<code>Message</code>，以<code>CreateUserRequest</code>和<code>LogoutUserRequest</code>为例子,修改如下:</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs Protobuf"><span class="hljs-comment">// create user</span><br><span class="hljs-class"><span class="hljs-keyword">message</span> <span class="hljs-title">CreateUserRequest</span> </span>&#123;<br>  <span class="hljs-built_in">string</span> uid = <span class="hljs-number">1</span> [<br>    (p2p_validate.rules).<span class="hljs-built_in">string</span>.miss_default = <span class="hljs-literal">true</span>, <span class="hljs-comment">// 定义生成的字段不带有默认值</span><br>    (p2p_validate.rules).<span class="hljs-built_in">string</span>.example = <span class="hljs-string">&quot;10086&quot;</span>,  <span class="hljs-comment">// 定义生成的字段的示例值为10086</span><br>    (p2p_validate.rules).<span class="hljs-built_in">string</span>.title = <span class="hljs-string">&quot;UID&quot;</span>,  <span class="hljs-comment">// 定义生成的字段OpenAPI的Title为UId</span><br>    (p2p_validate.rules).<span class="hljs-built_in">string</span>.description = <span class="hljs-string">&quot;user union id&quot;</span>  <span class="hljs-comment">// 定义生成的字段的描述</span><br>  ];<br>  <span class="hljs-built_in">string</span> user_name = <span class="hljs-number">2</span> [<br>    (p2p_validate.rules).<span class="hljs-built_in">string</span>.description = <span class="hljs-string">&quot;user name&quot;</span>,<br>    (p2p_validate.rules).<span class="hljs-built_in">string</span>.min_length = <span class="hljs-number">1</span>, <span class="hljs-comment">// 定义字段的最小长度</span><br>    (p2p_validate.rules).<span class="hljs-built_in">string</span>.max_length = <span class="hljs-number">10</span>, <span class="hljs-comment">// 定义字段的最大长度</span><br>    (p2p_validate.rules).<span class="hljs-built_in">string</span>.example = <span class="hljs-string">&quot;so1n&quot;</span><br>  ];<br>  <span class="hljs-built_in">string</span> password = <span class="hljs-number">3</span> [<br>    (p2p_validate.rules).<span class="hljs-built_in">string</span>.description = <span class="hljs-string">&quot;user password&quot;</span>,<br>    (p2p_validate.rules).<span class="hljs-built_in">string</span>.alias = <span class="hljs-string">&quot;pw&quot;</span>,  <span class="hljs-comment">// 定义字段的别名</span><br>    (p2p_validate.rules).<span class="hljs-built_in">string</span>.min_length = <span class="hljs-number">6</span>,<br>    (p2p_validate.rules).<span class="hljs-built_in">string</span>.max_length = <span class="hljs-number">18</span>,<br>    (p2p_validate.rules).<span class="hljs-built_in">string</span>.example = <span class="hljs-string">&quot;123456&quot;</span>,<br>    <span class="hljs-comment">// 定义字段的类型，该类型是来自于`pydantic`</span><br>    <span class="hljs-comment">// 参考 https://pydantic-docs.helpmanual.io/usage/types/#secret-types</span><br>    (p2p_validate.rules).<span class="hljs-built_in">string</span>.pydantic_type = <span class="hljs-string">&quot;SecretStr&quot;</span><br>  ];<br>&#125;<br><span class="hljs-comment">// logout user</span><br><span class="hljs-class"><span class="hljs-keyword">message</span> <span class="hljs-title">LogoutUserRequest</span> </span>&#123;<br>  <span class="hljs-built_in">string</span> uid = <span class="hljs-number">1</span> [<br>    (p2p_validate.rules).<span class="hljs-built_in">string</span>.example = <span class="hljs-string">&quot;10086&quot;</span>,<br>    (p2p_validate.rules).<span class="hljs-built_in">string</span>.title = <span class="hljs-string">&quot;UID&quot;</span>,<br>    (p2p_validate.rules).<span class="hljs-built_in">string</span>.description = <span class="hljs-string">&quot;user union id&quot;</span><br>  ];<br>  <span class="hljs-built_in">string</span> token = <span class="hljs-number">2</span> [<br>    (p2p_validate.rules).<span class="hljs-built_in">string</span>.description = <span class="hljs-string">&quot;user token&quot;</span>,<br>    (p2p_validate.rules).<span class="hljs-built_in">string</span>.enable = <span class="hljs-literal">false</span> <span class="hljs-comment">// 定义不要把该值映射到model中</span><br>  ];<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><ul><li>详细的user.proto文件见：<a href="https://github.com/so1n/grpc-example-common/blob/pait-example/protos/user/user.proto">https://github.com/so1n/grpc-example-common/blob/pait-example/protos/user/user.proto</a> </li><li>这里只是做简单的介绍，更多使用方法见<a href="https://so1n.me/pait-zh-doc/7_gRPC_gateway/">Pait-gRPC-gateway文档</a></li></ul></blockquote><p>修改完成后记得通过<code>Protobuf</code>文件生成对应的<code>Python</code>代码并打包,再传到代码仓库中，具体流程见文章:<a href="https://so1n.me/2022/04/07/Python-gRPC%E5%AE%9E%E8%B7%B5(3)--%E4%BD%BF%E7%94%A8Python%E5%AE%9E%E7%8E%B0gRPC%E6%9C%8D%E5%8A%A1/">Python-gRPC实践(3)–使用Python实现gRPC服务</a></p><h3 id="2-2-修改Flask应用"><a href="#2-2-修改Flask应用" class="headerlink" title="2.2.修改Flask应用"></a>2.2.修改Flask应用</h3><p>Protobuf文件修改完后可以开始修改<code>Flask</code>服务，<code>Flask</code>应用的项目结构如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs css">├── <span class="hljs-selector-tag">app</span><span class="hljs-selector-class">.py</span><br>├── <span class="hljs-selector-tag">app_service</span><br>│   ├── __<span class="hljs-selector-tag">init__</span><span class="hljs-selector-class">.py</span><br>│   ├── <span class="hljs-selector-tag">manager_book_route</span><span class="hljs-selector-class">.py</span><br>│   ├── <span class="hljs-selector-tag">route</span><span class="hljs-selector-class">.py</span><br>│   ├── <span class="hljs-selector-tag">social_book_route</span><span class="hljs-selector-class">.py</span><br>│   ├── <span class="hljs-selector-tag">user_route</span><span class="hljs-selector-class">.py</span><br>│   └── <span class="hljs-selector-tag">utils</span><span class="hljs-selector-class">.py</span><br>├── <span class="hljs-selector-tag">grpc_service</span><br>│   ├── <span class="hljs-selector-tag">book_service</span><span class="hljs-selector-class">.py</span><br>│   ├── __<span class="hljs-selector-tag">init__</span><span class="hljs-selector-class">.py</span><br>│   └── <span class="hljs-selector-tag">user_service</span><span class="hljs-selector-class">.py</span><br>└── <span class="hljs-selector-tag">gunicorn</span><span class="hljs-selector-class">.conf</span><span class="hljs-selector-class">.py</span><br></code></pre></td></tr></table></figure><p>为了区分两种不同的调用，会在<code>app_service</code>文件夹新建一个名为<code>user_gateway_route.py</code>的文件，并编写如下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> Type<br><span class="hljs-keyword">import</span> grpc<br><br><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Flask, jsonify, Response<br><span class="hljs-keyword">from</span> pydantic <span class="hljs-keyword">import</span> BaseModel, Field<br><br><span class="hljs-keyword">from</span> pait.app.flask.grpc_route <span class="hljs-keyword">import</span> GrpcGatewayRoute<br><span class="hljs-keyword">from</span> pait.app <span class="hljs-keyword">import</span> set_app_attribute<br><span class="hljs-keyword">from</span> pait.model.response <span class="hljs-keyword">import</span> PaitBaseResponseModel, PaitJsonResponseModel<br><span class="hljs-keyword">from</span> pait.util.grpc_inspect.stub <span class="hljs-keyword">import</span> GrpcModel<br><span class="hljs-keyword">from</span> protobuf_to_pydantic <span class="hljs-keyword">import</span> msg_to_pydantic_model<br><br><span class="hljs-keyword">from</span> grpc_example_common.protos.user <span class="hljs-keyword">import</span> user_pb2_grpc<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">gen_response_model_handle</span>(<span class="hljs-params">grpc_model: GrpcModel</span>) -&gt; Type[PaitBaseResponseModel]:</span><br>    <span class="hljs-comment"># 动态生成对应的响应模型</span><br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomerJsonResponseModel</span>(<span class="hljs-params">PaitJsonResponseModel</span>):</span><br>        <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomerJsonResponseRespModel</span>(<span class="hljs-params">BaseModel</span>):</span><br>            code: <span class="hljs-built_in">int</span> = Field(<span class="hljs-number">0</span>, description=<span class="hljs-string">&quot;api code&quot;</span>)<br>            msg: <span class="hljs-built_in">str</span> = Field(<span class="hljs-string">&quot;success&quot;</span>, description=<span class="hljs-string">&quot;api status msg&quot;</span>)<br>            data: msg_to_pydantic_model(grpc_model.response) = Field(description=<span class="hljs-string">&quot;api response data&quot;</span>)  <span class="hljs-comment"># type: ignore</span><br><br>        name: <span class="hljs-built_in">str</span> = grpc_model.response.DESCRIPTOR.name<br>        response_data: Type[BaseModel] = CustomerJsonResponseRespModel<br><br>    <span class="hljs-keyword">return</span> CustomerJsonResponseModel<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add_grpc_gateway_route</span>(<span class="hljs-params">app: Flask</span>) -&gt; <span class="hljs-keyword">None</span>:</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_make_response</span>(<span class="hljs-params">resp_dict: <span class="hljs-built_in">dict</span></span>) -&gt; Response:</span><br>        <span class="hljs-keyword">return</span> jsonify(&#123;<span class="hljs-string">&quot;code&quot;</span>: <span class="hljs-number">0</span>, <span class="hljs-string">&quot;msg&quot;</span>: <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;data&quot;</span>: resp_dict&#125;)<br>    <br>    <span class="hljs-comment"># 定义一个网关路由，该路由已经把gRPC的方法映射到指定的Flask应用中</span><br>    grpc_gateway_route: GrpcGatewayRoute = GrpcGatewayRoute(<br>        app,<br>        <span class="hljs-comment"># 通过User.proto生成的Python代码中的`UserStub`类,Pait可以通过该类解析出User.proto对应的方法</span><br>        user_pb2_grpc.UserStub,<br>        <span class="hljs-comment"># 指定对应路由的前缀</span><br>        prefix=<span class="hljs-string">&quot;/api/gateway&quot;</span>,<br>        title=<span class="hljs-string">&quot;UserGrpc&quot;</span>,<br>        gen_response_model_handle=gen_response_model_handle,  <span class="hljs-comment"># 定义返回响应的OpenAPI模型，方便生成OpenAPI文档</span><br>        make_response=_make_response,   <span class="hljs-comment"># 定义返回的响应格式</span><br>    )<br>    <span class="hljs-comment"># 初始化gRPC的channel并传入`grpc_gateway_route`中</span><br>    grpc_gateway_route.init_channel(grpc.intercept_channel(grpc.insecure_channel(<span class="hljs-string">&quot;0.0.0.0:9001&quot;</span>)))<br></code></pre></td></tr></table></figure><p>这样一来<code>Pait</code>就能把<code>User</code>的服务映射到对应的<code>Flask</code>应用实例了， 但是User服务的部分接口并没有要求用户验证，需要我们先在<code>Flask</code>实例进行校验后才可以调用<code>gRPC</code>服务，而对于<code>logout_user</code>方法则需要token参数。<br>对于这两个需求，可以通过对<code>GrpcGatewayRoute</code>的生成路由方法进行改写来达到我们的目的，改写代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomerGrpcGatewayRoute</span>(<span class="hljs-params">GrpcGatewayRoute</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">gen_route</span>(<span class="hljs-params">self, grpc_model: GrpcModel, request_pydantic_model_class: Type[BaseModel]</span>) -&gt; Callable:</span><br><br>        <span class="hljs-comment"># 对于登录和创建用户接口不需要Token，所以采用原生的方法</span><br>        <span class="hljs-keyword">if</span> grpc_model.method <span class="hljs-keyword">in</span> (<span class="hljs-string">&quot;/user.User/login_user&quot;</span>, <span class="hljs-string">&quot;/user.User/create_user&quot;</span>):<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>().gen_route(grpc_model, request_pydantic_model_class)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_route</span>(<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">                <span class="hljs-comment"># 通过对应的grpc message生成的pydantic.BaseModel对象</span></span></span><br><span class="hljs-function"><span class="hljs-params">                request_pydantic_model: request_pydantic_model_class,  <span class="hljs-comment"># type: ignore</span></span></span><br><span class="hljs-function"><span class="hljs-params">                <span class="hljs-comment"># 添加token参数</span></span></span><br><span class="hljs-function"><span class="hljs-params">                token: <span class="hljs-built_in">str</span> = Header.i(<span class="hljs-params">description=<span class="hljs-string">&quot;User Token&quot;</span></span>),</span></span><br><span class="hljs-function"><span class="hljs-params">                <span class="hljs-comment"># 添加请求id参数，与需求无关</span></span></span><br><span class="hljs-function"><span class="hljs-params">                req_id: <span class="hljs-built_in">str</span> = Header.i(<span class="hljs-params">alias=<span class="hljs-string">&quot;X-Request-Id&quot;</span>, default_factory=<span class="hljs-keyword">lambda</span>: <span class="hljs-built_in">str</span>(<span class="hljs-params">uuid4(<span class="hljs-params"></span>)</span>)</span>),</span></span><br><span class="hljs-function"><span class="hljs-params">            </span>) -&gt; Any:</span><br>                func: Callable = self.get_grpc_func(grpc_model.method)<br>                request_dict: <span class="hljs-built_in">dict</span> = request_pydantic_model.<span class="hljs-built_in">dict</span>()  <span class="hljs-comment"># type: ignore</span><br>                <span class="hljs-keyword">if</span> grpc_model.method == <span class="hljs-string">&quot;/user.User/logout_user&quot;</span>:<br>                    <span class="hljs-comment"># 退出登陆接口需要token</span><br>                    request_dict[<span class="hljs-string">&quot;token&quot;</span>] = token<br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-comment"># 其他接口不需要token参数，只需要校验token是否合法，如果不合法则抛出异常</span><br>                    result: user_pb2.GetUidByTokenResult = user_pb2_grpc.UserStub(self.channel).get_uid_by_token(<br>                        user_pb2.GetUidByTokenRequest(token=token)<br>                    )<br>                    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> result.uid:<br>                        <span class="hljs-keyword">raise</span> RuntimeError(<span class="hljs-string">f&quot;Not found user by token:<span class="hljs-subst">&#123;token&#125;</span>&quot;</span>)<br>                <span class="hljs-comment"># 生成调用参数后再调用gRPC方法，并把gRPC方法返回的数据返回给调用端</span><br>                request_msg: Message = self.get_msg_from_dict(grpc_model.request, request_dict)<br>                grpc_msg: Message = func(request_msg, metadata=[(<span class="hljs-string">&quot;req_id&quot;</span>, req_id)])<br>                <span class="hljs-keyword">return</span> self._make_response(self.get_dict_from_msg(grpc_msg))<br><br>            <span class="hljs-keyword">return</span> _route<br></code></pre></td></tr></table></figure><p>这样一来业务逻辑就跟原本的逻辑一样了，可以进行最后一步操作–往<code>Flask</code>应用注入对应的路由，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">create_app</span>() -&gt; Flask:</span><br>    app: Flask = Flask(__name__)<br>    app.json_encoder = CustomJSONEncoder<br>    app.register_blueprint(manager_book_bp)<br>    app.register_blueprint(social_book_bp)<br>    app.register_blueprint(user_bp)<br><br>    book_grpc_service: BookGrpcService = BookGrpcService(<span class="hljs-string">&quot;0.0.0.0&quot;</span>, <span class="hljs-number">9000</span>)<br>    book_grpc_service.channel_ready_future(timeout=<span class="hljs-number">3</span>)<br>    user_grpc_service: UserGrpcService = UserGrpcService(<span class="hljs-string">&quot;0.0.0.0&quot;</span>, <span class="hljs-number">9001</span>)<br>    user_grpc_service.channel_ready_future(timeout=<span class="hljs-number">3</span>)<br>    ContextMiddleware(app=app, book_grpc_service=book_grpc_service, user_grpc_service=user_grpc_service)<br><br>    <span class="hljs-comment"># 映射gRPC服务对应的接口到app</span><br>    add_grpc_gateway_route(app)<br>    <span class="hljs-comment"># 添加一个OpenAPI文档路由，从而可以查看被Pait托管路由的接口文档</span><br>    add_doc_route(app)<br>    app.errorhandler(Exception)(api_exception)<br>    <span class="hljs-keyword">return</span> app<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    <span class="hljs-comment"># 屏蔽接口文档中`OPTIONS`和`HEAD`方法接口的展示</span><br>    config.init_config(apply_func_list=[apply_block_http_method_set(&#123;<span class="hljs-string">&quot;OPTIONS&quot;</span>, <span class="hljs-string">&quot;HEAD&quot;</span>&#125;)])<br>    create_app().run(<span class="hljs-string">&quot;localhost&quot;</span>, port=<span class="hljs-number">8000</span>)<br><br></code></pre></td></tr></table></figure><p>代码修改完毕后，分别先启动User和Book服务，再启动Flask应用，并在浏览器输入<code>http://127.0.0.1:8000/swagger</code>即可看到通过<code>Pait Json</code>网关生成的接口的接口文档页面：<br><img   class="lazyload" data-original="https://fastly.jsdelivr.net/gh/so1n/so1n_blog_photo@master/blog_photo/16683504910421668350490672.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" ></p><p>在检查文档展示的接口与Protobuf文件描述的是一致后，可以通过接口文档页面来尝试生成的<code>gRPC Json</code>网关是否可以正常使用，如下动图，其中左上图为<code>User</code>服务，左下图为<code>Flask</code>应用，而右半边的图是<code>Swagger</code>页面:<br><img   class="lazyload" data-original="https://fastly.jsdelivr.net/gh/so1n/so1n_blog_photo@master/blog_photo/1668352148437%E5%BD%95%E5%B1%8F_%E9%80%89%E6%8B%A9%E5%8C%BA%E5%9F%9F_20221113230819.gif" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" ></p><p>除了动图的操作外，还可以尝试修改<code>uid</code>等字段的长度在执行，会发现<code>Flask</code>应用由于我们传过来的值不满足校验规则而抛出错误。</p><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p>示例代码只是为了演示，并无任何实际意义，也不适用于生产环境：</p><h3 id="附录一，简单的gRPC示例项目代码"><a href="#附录一，简单的gRPC示例项目代码" class="headerlink" title="附录一，简单的gRPC示例项目代码"></a>附录一，简单的gRPC示例项目代码</h3><p>api服务：<a href="https://github.com/so1n/grpc-example-api-backend-service">https://github.com/so1n/grpc-example-api-backend-service</a><br>用户服务: <a href="https://github.com/so1n/grpc-example-user-grpc-service">https://github.com/so1n/grpc-example-user-grpc-service</a><br>书籍管理服务：<a href="https://github.com/so1n/grpc-example-book-grpc-service">https://github.com/so1n/grpc-example-book-grpc-service</a><br><code>gRPC</code>公有包（包括<code>gRPC</code>调用封装和protobuf文件）：<a href="https://github.com/so1n/grpc-example-common">https://github.com/so1n/grpc-example-common</a></p><h3 id="附录二，使用Pait快速构建gRPC-Json网关代码"><a href="#附录二，使用Pait快速构建gRPC-Json网关代码" class="headerlink" title="附录二，使用Pait快速构建gRPC Json网关代码"></a>附录二，使用Pait快速构建gRPC Json网关代码</h3><p>api服务:<a href="https://github.com/so1n/grpc-example-api-backend-service">https://github.com/so1n/grpc-example-api-backend-service</a><br><code>gRPC</code>公有包：<a href="https://github.com/so1n/grpc-example-common/tree/pait-example">https://github.com/so1n/grpc-example-common/tree/pait-example</a></p><blockquote><p>其他服务只需要把<code>gRPC</code>公有包依赖更新到<code>pait-example</code>分支即可</p></blockquote><h3 id="服务三，使用文档"><a href="#服务三，使用文档" class="headerlink" title="服务三，使用文档"></a>服务三，使用文档</h3><p><code>Pait Json</code>网关文档: <a href="https://so1n.me/pait-zh-doc/7_gRPC_gateway/">https://so1n.me/pait-zh-doc/7_gRPC_gateway/</a><br><a href="https://github.com/so1n/protobuf_to_pydantic">protobuf_to_pydantic文档</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前记&quot;&gt;&lt;a href=&quot;#前记&quot; class=&quot;headerlink&quot; title=&quot;前记&quot;&gt;&lt;/a&gt;前记&lt;/h2&gt;&lt;p&gt;&lt;code&gt;gRPC&lt;/code&gt;已经是一个大多数开发者使用微服务时选择的通信协议，大多数公司的内部服务都会通过&lt;code&gt;gRPC&lt;/co</summary>
      
    
    
    <content src="https://fastly.jsdelivr.net/gh/so1n/so1n_blog_photo@master/blog_photo/1668428052290logo_transparent.png" type="image"/>
    
    
    <category term="pait" scheme="http://so1n.me/categories/pait/"/>
    
    
    <category term="gRPC,pait" scheme="http://so1n.me/tags/gRPC-pait/"/>
    
  </entry>
  
  <entry>
    <title>为何在Python生态很少听说到依赖注入</title>
    <link href="http://so1n.me/2022/10/15/%E4%B8%BA%E4%BD%95%E5%9C%A8Python%E7%94%9F%E6%80%81%E5%BE%88%E5%B0%91%E5%90%AC%E8%AF%B4%E5%88%B0%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/"/>
    <id>http://so1n.me/2022/10/15/%E4%B8%BA%E4%BD%95%E5%9C%A8Python%E7%94%9F%E6%80%81%E5%BE%88%E5%B0%91%E5%90%AC%E8%AF%B4%E5%88%B0%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/</id>
    <published>2022-10-15T12:31:18.000Z</published>
    <updated>2022-10-25T16:15:54.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前记"><a href="#前记" class="headerlink" title="前记"></a>前记</h2><p>由于使用的主要编程语言是<code>Python</code>，所以对于依赖注入这个概念并不是很清楚或者不知道自己已经在代码中运用了依赖注入的用法，在接触了DDD后才开始真正的了解什么是依赖注入以及依赖注入的重要性，同时也很好奇为何在<code>Python</code> 生态中依赖注入的出现率较低。</p><h2 id="1-控制反转与依赖注入"><a href="#1-控制反转与依赖注入" class="headerlink" title="1.控制反转与依赖注入"></a>1.控制反转与依赖注入</h2><p>在查找依赖注入的相关资料时发现依赖注入与控制反转这两个词是成对出现的，这是因为控制反转并不是一种技术，而是一种编程思想，这种思想能指导我们如何设计出松耦合优良的程序，而依赖注入是一个具体的设计模式，它是控制反转的一种具体实现。</p><p>控制反转这个概念有点模糊，但后端开发者来说却是经常接触到的，比如在对框架与库的使用时，分别接触到他们的反向控制和正向控制，而框架的反向控制正是控制反转的体现。<br>大多数人很少去区分在项目中使用的包是属于框架还是库，也不会很清晰的去区分它们属于哪一种，我也是这样的，在经过了一段编程生涯后我才可以简单的把主动调用的包归类为库，只能被动调用的包归类为框架。</p><p>不过最近在翻阅依赖注入与控制反转的相关文章<a href="https://martinfowler.com/bliki/InversionOfControl.html">InversionOfControl</a>时发现，控制反转也可以是框架和库的关键区别点。因为对于一个库来说，程序员使用的方式是主动的调用它，如下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> httpx<br><br>response = httpx.get(<span class="hljs-string">&quot;https://so1n.me&quot;</span>)<br>print(response.status_code)<br></code></pre></td></tr></table></figure><p>这段代码主动的调用<code>httpx</code>包的<code>get</code>方法发起一个请求以获取网站对应的状态码，由于这种调用方法属于开发者去主动调用库，所以属于正向的控制。</p><p>而框架就不一样了，框架一般都会提供一些注册的方法将我们编写的代码注册到框架中，最后由框架来调用程序员编写的代码，如下例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">from</span> starlette.applications <span class="hljs-keyword">import</span> Starlette<br><span class="hljs-keyword">from</span> starlette.requests <span class="hljs-keyword">import</span> Request<br><span class="hljs-keyword">from</span> starlette.responses <span class="hljs-keyword">import</span> PlainTextResponse<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">demo</span>(<span class="hljs-params">request: Request</span>) -&gt; PlainTextResponse:</span><br>    <span class="hljs-keyword">return</span> PlainTextResponse(<span class="hljs-string">f&quot;Hello <span class="hljs-subst">&#123;request.query_params.get(<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>)&#125;</span>!&quot;</span>)<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">create_app</span>() -&gt; Starlette:</span><br>    app: Starlette = Starlette()<br>    app.add_route(<span class="hljs-string">&quot;/&quot;</span>, demo, methods=[<span class="hljs-string">&quot;GET&quot;</span>])<br>    <span class="hljs-keyword">return</span> app<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    <span class="hljs-keyword">import</span> uvicorn<br><br>    app: Starlette = create_app()<br>    uvicorn.run(app)<br></code></pre></td></tr></table></figure><p>这段代码中先是声明一个路由函数<code>demo</code>，这个路由函数是按照框架要求的方式编写的，这个要求是路由函数必须接收一个<code>Request</code>参数以及返回一个<code>Response</code>类；接着在实例化框架时通过<code>add_route</code>方法以<code>path=/</code>，<code>method=GET</code>的形式注册到框架中以及在调用<code>uvicorn.run(app)</code>的时候把控制权转移给了框架，并由框架在后续完成对<code>demo</code>路由函数的调用，这种调用方式属于反向控制。</p><blockquote><p>Note: 对于流式客户端封装的库可能包含着主动调用与被动调用，使其不像框架也不像库。</p></blockquote><p>此外，从例子中可以看到，创建的<code>demo</code>路由函数是交给了框架控制的，不再由开发者控制，而且<code>demo</code>路由函数接收的<code>Request</code>类参数是在运行时由框架管理创建和注销并注入给路由函数供路由函数使用的，这就是控制反转的主体思想，通过这种思想能公减少工程项目不同层次代码打耦合。</p><p>依赖注入则是控制反转的一种具体实现方式，这种方式能让一个对象接收它所依赖的其他对象。其中“依赖”是指接收方所需的对象，“注入”是指将“依赖”传递给接收方的过程。在“注入”之后，接收方才会调用该“依赖”。<br>而依赖注入框架则是一种根据对象的依赖关系的在运行时进行绑定的技术，通常它都会带有一个容器，这个容器托管着许多对象，并在运行时根据对象的依赖关系把对象传递给被控制的其它对象中。比如例子中的<code>starlette</code>框架在运行时就是一个容器，它可以根据不同的请求创建不同的请求对象并在根据请求规则匹配到对应的路由函数后把请求对象注入给路由函数使用。</p><h2 id="2-为什么需要控制反转与依赖注入"><a href="#2-为什么需要控制反转与依赖注入" class="headerlink" title="2.为什么需要控制反转与依赖注入"></a>2.为什么需要控制反转与依赖注入</h2><p>以一个客户端的设计为例，通常一个客户端会分为调用层，协议层和连接层3层，通常情况下都会这样去实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> Any<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Connection</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, host: <span class="hljs-built_in">str</span>, port: <span class="hljs-built_in">int</span></span>):</span><br>        self._host: <span class="hljs-built_in">str</span> = host<br>        self._port: <span class="hljs-built_in">int</span> = port<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">send</span>(<span class="hljs-params">self, data: Any</span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        <span class="hljs-string">&quot;&quot;&quot;发送数据到服务端&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">pass</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">read</span>(<span class="hljs-params">self</span>) -&gt; Any:</span><br>        <span class="hljs-string">&quot;&quot;&quot;从服务端接收数据&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">pass</span><br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Protocol</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, host: <span class="hljs-built_in">str</span>, port: <span class="hljs-built_in">int</span></span>):</span><br>        self._conn: Connection = Connection(host, port)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">request</span>(<span class="hljs-params">self, *args: Any, **kwargs: Any</span>) -&gt; Any:</span><br>        <span class="hljs-string">&quot;&quot;&quot;发送请求并等待响应&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">pass</span><br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, host: <span class="hljs-built_in">str</span>, port: <span class="hljs-built_in">int</span></span>):</span><br>        self._protocol: Protocol = Protocol(host, port)<br></code></pre></td></tr></table></figure><p>这段代码中分别包括了客户端的连接层的<code>Connection</code>，协议层的<code>Protocol</code>以及调用层的<code>Client</code>，对于使用者来说，他们不用去过于了解<code>Connection</code>和<code>Protocol</code>的实现，只需要知道<code>host</code>和<code>port</code>的参数要填什么以及<code>Client</code>该如何使用即可。</p><p>不过这段代码却出现了一条依赖链（<code>Client</code>依赖于<code>Protocol</code>，<code>Protocol</code>依赖于<code>Connection</code>)，同时客户端里面的不同层都把控了对下层对象的创建主动权，创建主动时机以及使用权，这样会造成上下层对象有很强的耦合，导致代码比较难维护。<br>比如要在<code>Connection</code>增加一个SSL功能，这个功能需要一些SSL参数，那么三层都要进行更改，使用者才可以把SSL参数传给<code>Connection</code>，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> Any<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Connection</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, host: <span class="hljs-built_in">str</span>, port: <span class="hljs-built_in">int</span>, ssl: Any</span>):</span>  <span class="hljs-comment"># &lt;--</span><br>        self._host: <span class="hljs-built_in">str</span> = host<br>        self._port: <span class="hljs-built_in">int</span> = port<br>        self._ssl: Any = ssl<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">send</span>(<span class="hljs-params">self, data: Any</span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        <span class="hljs-string">&quot;&quot;&quot;发送数据到服务端&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">pass</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">read</span>(<span class="hljs-params">self</span>) -&gt; Any:</span><br>        <span class="hljs-string">&quot;&quot;&quot;从服务端接收数据&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">pass</span><br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Protocol</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, host: <span class="hljs-built_in">str</span>, port: <span class="hljs-built_in">int</span>, ssl: Any</span>):</span>  <span class="hljs-comment"># &lt;--</span><br>        self._conn: Connection = Connection(host, port, ssl)  <span class="hljs-comment"># &lt;--</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">request</span>(<span class="hljs-params">self, *args: Any, **kwargs: Any</span>) -&gt; Any:</span><br>        <span class="hljs-string">&quot;&quot;&quot;发送请求并等待响应&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">pass</span><br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, host: <span class="hljs-built_in">str</span>, port: <span class="hljs-built_in">int</span>, ssl: Any</span>):</span>  <span class="hljs-comment"># &lt;--</span><br>        self._protocol: Protocol = Protocol(host, port, Any)  <span class="hljs-comment"># &lt;--</span><br><br></code></pre></td></tr></table></figure><p>通过这段代码可以看到，为了让连接层支持SSL功能，需要从<code>Client</code>开始一层一层的把SSL功能的参数传递下去，这还好只是分了三层，比较容易操作，如果分的层次比较多，将会非常的难受，而且在工程项目中，一个类可能会被不同的类所依赖的，这意味着为一个基础类增减某些功能会导致其它依赖它的类也要进行修改，这会浪费大量的开发时间和测试时间，同时使依赖它的类都需要发生变动，这会增加系统出现BUG的风险。</p><p>为了解决这个问题，可以根据控制反转的思想，把上层对象创建下层对象的权利和创建时机转移给第三方来控制，仅保留上层对象对下层对象的使用权，修改完的代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> Any<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Connection</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, host: <span class="hljs-built_in">str</span>, port: <span class="hljs-built_in">int</span>, ssl: Any</span>):</span>  <span class="hljs-comment"># &lt;--</span><br>        self._host: <span class="hljs-built_in">str</span> = host<br>        self._port: <span class="hljs-built_in">int</span> = port<br>        self._ssl: Any = ssl<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">send</span>(<span class="hljs-params">self, data: Any</span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        <span class="hljs-string">&quot;&quot;&quot;发送数据到服务端&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">pass</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">read</span>(<span class="hljs-params">self</span>) -&gt; Any:</span><br>        <span class="hljs-string">&quot;&quot;&quot;从服务端接收数据&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">pass</span><br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Protocol</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, connection: Connection</span>):</span>  <span class="hljs-comment"># &lt;--</span><br>        self._conn: Connection = connection  <span class="hljs-comment"># &lt;--</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">request</span>(<span class="hljs-params">self, *args: Any, **kwargs: Any</span>) -&gt; Any:</span><br>        <span class="hljs-string">&quot;&quot;&quot;发送请求并等待响应&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">pass</span><br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, protocol: Protocol</span>):</span>  <span class="hljs-comment"># &lt;--</span><br>        self._protocol: Protocol = protocol   <span class="hljs-comment"># &lt;--</span><br></code></pre></td></tr></table></figure><p>可以发现，这段代码经过变更后，每一层只接收自己需要依赖的对象，在这种设计下可以在<code>Client</code>和<code>Protocol</code>代码没变动的情况下同时接收实现SSL功能和没实现SSL功能等实现了<code>send</code>和<code>read</code>方法的<code>Connection</code>对象。</p><p>接下来只要通过第三方来创建对象即可，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Python">client: Client = Client(<br>    protocol=Protocol(<br>        connection=Connection(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">8000</span>, <span class="hljs-built_in">object</span>())<br>    )<br>)<br><br>no_ssl_client: Client = Client(<br>    protocol=Protocol(<br>        connection=NoSslConnection(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">8000</span>)<br>    )<br>)<br></code></pre></td></tr></table></figure><p>这段代码中管理依赖对象的生命周期以及对象的关系全靠手动编写代码，使其在运行时完成对象绑定的，如果项目中分了很多层或者依赖关系比较复杂的话，手动处理会比较麻烦，也不方便后续的迭代。<br>这时就需要通过依赖注入框架来帮忙自动整理依赖关系以及注入到需要的对象中，比如在使用<code>dependency-injector</code>这个依赖注入框架后，代码就可以变为如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">from</span> dependency_injector <span class="hljs-keyword">import</span> containers, providers<br><span class="hljs-keyword">from</span> dependency_injector.wiring <span class="hljs-keyword">import</span> Provide, inject<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Container</span>(<span class="hljs-params">containers.DeclarativeContainer</span>):</span><br>    <span class="hljs-comment"># 依赖注入框架提供的容器，该容器会管理对象的创建</span><br><br>    <span class="hljs-comment"># 用于加载配置</span><br>    config = providers.Configuration()<br><br>    <span class="hljs-comment"># 通过`providers.Singleton`创建的对象在整个生命周期中会保持唯一(单例)</span><br>    conn = providers.Singleton(<br>        Connection ,<br>        host=config.host,<br>        port=config.port,<br>    )<br>    <span class="hljs-comment"># 创建protocol层的工厂函数</span><br>    protocol = providers.Factory(<br>        Protocol,<br>        connection=Connection,<br>    )<br><br>    <span class="hljs-comment"># 创建client层的工厂函数</span><br>    client = providers.Factory(<br>        Client,<br>        protocol=protocol,<br>    )<br><br><span class="hljs-comment"># 注入装饰器，可以自动的把对应的值注入到被装饰的函数中</span><br><span class="hljs-meta">@inject</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>(<span class="hljs-params">client: Client = Provide[Container.client]</span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>    ...<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    <span class="hljs-comment"># 初始化容器</span><br>    container = Container()<br>    <span class="hljs-comment"># 通过env加载配置</span><br>    container.config.api_key.from_env(<span class="hljs-string">&quot;host&quot;</span>, required=<span class="hljs-literal">True</span>)<br>    container.config.timeout.from_env(<span class="hljs-string">&quot;port&quot;</span>, as_=<span class="hljs-built_in">int</span>, default=<span class="hljs-number">4</span>)<br>    <span class="hljs-comment"># 通过wire把容器与模块连接起来，这样该模块的`inject`装饰器可以读到对应的容器</span><br>    container.wire(modules=[__name__])<br><br>    main()  <span class="hljs-comment"># 通过带有SSL功能的Connection运行代码</span><br><br>    <span class="hljs-keyword">with</span> container.conn.override(NoSslConnection(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">8000</span>)):<br>        main()  <span class="hljs-comment"># 通过没有SSL功能的Connection运行代码</span><br></code></pre></td></tr></table></figure><p>通过这段代码可以发现，每个对象都存在于容器<code>Container</code>中，并通过<code>inject</code>装饰器就可以自动的把依赖对象进行绑定，不再需要手动处理，在依赖层级比较深的时候能缓解开发者的心智负担，同时通过<code>override</code>语法可以很方便的在新的作用域替换其中的一个依赖对象。</p><h2 id="3-为何在Python生态中很少听到依赖注入"><a href="#3-为何在Python生态中很少听到依赖注入" class="headerlink" title="3.为何在Python生态中很少听到依赖注入"></a>3.为何在Python生态中很少听到依赖注入</h2><p>了解了依赖注入与控制反转后可以发现，在<code>Python</code>生态也会通过控制反转的方式去进行解耦，但是很少有人会直接说自己用了依赖注入来解决上述的问题。</p><p>会这样的第一个原因是大部分被依赖注入容器托管的对象都被要求是单例的，而<code>Python</code>的每个模块中的对象也都是单例的，这样一来实现工程项目就会比较方便，比如下面一个Web项目的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-comment"># orm.py</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Orm</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-keyword">pass</span><br><br><br>orm: Orm = Orm()<br><br><span class="hljs-comment"># route.py</span><br><span class="hljs-keyword">from</span> starlette.requests <span class="hljs-keyword">import</span> Request<br><span class="hljs-keyword">from</span> starlette.responses <span class="hljs-keyword">import</span> PlainTextResponse<br><span class="hljs-keyword">from</span> orm <span class="hljs-keyword">import</span> orm<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">demo</span>(<span class="hljs-params">request: Request</span>) -&gt; PlainTextResponse:</span><br>    name: <span class="hljs-built_in">str</span> = request.query_params.get(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;&quot;</span>)<br>    _id: <span class="hljs-built_in">int</span> = orm.user.get(name)<br>    <span class="hljs-keyword">return</span> PlainTextResponse(<span class="hljs-string">f&quot;Hello <span class="hljs-subst">&#123;_id&#125;</span>!&quot;</span>)<br></code></pre></td></tr></table></figure><p>这个例子是<code>Python</code>开发者常用的开发模式，在这个例子中有<code>orm</code>和<code>route</code>两个模块，这时如果把<code>Python</code>的运行时环境认为是一个大的依赖注入容器，把<code>orm</code>模块和<code>route</code>模块认为是容器的托管的对象，把<code>route</code>模块引用到了<code>orm</code>模块则认为是依赖注入容器把orm注入到了<code>route</code>模块中时可以发现，<code>Python</code>开发者在不经意间就实现类似于静态语言的依赖注入了。</p><p>除此之外，还有重要的一点是在静态语言中，编译期，装载期和运行时期都是严格分离的，无法在运行期执行装载期的工作，这样就需要依赖注入容器通过反射来进行处理，比如<code>Java</code>的<code>Spring</code>框架，而<code>Python</code>是一门动态语言，它的运行时环境可以认为是一个大的依赖注入容器，所以<code>Python</code>可以在运行时替换某个对象，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs Python">  <br><span class="hljs-keyword">import</span> requests  <br><span class="hljs-keyword">import</span> httpx  <br>  <br>  <br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span>  <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span>  <br>        self._get = requests.get  <br>  <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__call__</span>(<span class="hljs-params">self, *args, **kwargs</span>) -&gt; Any:</span>  <br>        <span class="hljs-keyword">return</span> self._get(*args, **kwargs)  <br>  <br>print(<span class="hljs-built_in">type</span>(Demo()(<span class="hljs-string">&quot;https://so1n.me&quot;</span>)))<br><span class="hljs-comment"># &gt;&gt;&gt; &lt;class &#x27;requests.models.Response&#x27;&gt;</span><br>requests.get = httpx.get  <br>print(<span class="hljs-built_in">type</span>(Demo()(<span class="hljs-string">&quot;https://so1n.me&quot;</span>)))<br><span class="hljs-comment"># &gt;&gt;&gt; &lt;class &#x27;httpx.Response&#x27;&gt;</span><br></code></pre></td></tr></table></figure><p>在这段代码中，由于<code>httpx</code>库采用了类似<code>requests</code>库的实现，所以在使用上差别不大，在<code>Python</code>中可以简单的对依赖对象进行替换，通过输出结果可以看出，没替换前返回的响应结果类型是<code>requests.model.Respnose</code>而替换后响应结果类型是<code>httpx.Response</code>，证明已经替换成功了。</p><p>所以<code>Python</code>开发者可以通过<code>Python</code>的语法特性快速的实现静态语言中依赖注入容器的相关功能了，可以认为在<code>Python</code>中依赖注入是很常见的，但是因为太常见了，而且只需要用到<code>Python</code>的语言特性就可以实现依赖注入容器的功能，导致没有那么多人知道自己已经使用了依赖注入，也没必要用到依赖注入框架，所以讨论的热度会比较低，这可能就是在<code>Python</code>生态中很少听到依赖注入的原因吧。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>可以看出通过控制反转可以很方便的把对象之中的依赖进行解耦，方便项目的迭代开发，而依赖注入是控制反转的具体实现，在静态语言中通过依赖注入可以将对象的索取从编译期和装载期移到了运行期。而<code>Python</code>由于本身是动态语言以及自己的语言特性，开发者会通过常见的开发模式来达到静态语言依赖注入的类似需求，所以在<code>Python</code>生态中很少听到依赖注入，不过对于DDD领域设计开发则是一个例外。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前记&quot;&gt;&lt;a href=&quot;#前记&quot; class=&quot;headerlink&quot; title=&quot;前记&quot;&gt;&lt;/a&gt;前记&lt;/h2&gt;&lt;p&gt;由于使用的主要编程语言是&lt;code&gt;Python&lt;/code&gt;，所以对于依赖注入这个概念并不是很清楚或者不知道自己已经在代码中运用了依赖注入</summary>
      
    
    
    <content src="https://fastly.jsdelivr.net/gh/so1n/so1n_blog_photo@master/blog_photo/16667142993131666714298611.png" type="image"/>
    
    
    <category term="依赖注入" scheme="http://so1n.me/categories/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/"/>
    
    
    <category term="依赖注入，控制反转" scheme="http://so1n.me/tags/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%EF%BC%8C%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC/"/>
    
  </entry>
  
  <entry>
    <title>Python-gRPC实践(7)--gRPC的错误传递</title>
    <link href="http://so1n.me/2022/06/23/Python-gRPC%E5%AE%9E%E8%B7%B5(7)--gRPC%E9%94%99%E8%AF%AF%E4%BC%A0%E9%80%92%20copy/"/>
    <id>http://so1n.me/2022/06/23/Python-gRPC%E5%AE%9E%E8%B7%B5(7)--gRPC%E9%94%99%E8%AF%AF%E4%BC%A0%E9%80%92%20copy/</id>
    <published>2022-06-23T12:35:24.000Z</published>
    <updated>2022-11-22T06:16:10.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前在文章<a href="https://so1n.me/2022/04/07/Python-gRPC%E5%AE%9E%E8%B7%B5(3)--%E4%BD%BF%E7%94%A8Python%E5%AE%9E%E7%8E%B0gRPC%E6%9C%8D%E5%8A%A1/">《Python-gRPC实践(3)–使用Python实现gRPC服务》</a>介绍的实现<code>gRPC</code>服务中使用了一套自定义的协议来传递错误，但这并不是一个优雅的解决方案，因为这种方案的兼容性很差，好在官方定义了一种解决方案，通过这种方案可以使不同的服务都能传递错误。</p><h2 id="1-自定义的错误传递"><a href="#1-自定义的错误传递" class="headerlink" title="1.自定义的错误传递"></a>1.自定义的错误传递</h2><p>在编写普通的HTTP/1.1接口时，我们都会定制一套业务相关的错误来与HTTP标注的错误区分开，比如通常都会返回这样一个结构体：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>    <span class="hljs-attr">&quot;code&quot;</span>: <span class="hljs-string">&quot;0&quot;</span>,<br>    <span class="hljs-attr">&quot;msg&quot;</span>: <span class="hljs-string">&quot;success&quot;</span>,<br>    <span class="hljs-attr">&quot;data&quot;</span>: &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个结构体包含了<code>code</code>,<code>msg</code>和<code>data</code>三个字段，他们分别是错误码，错误信息，和要返回的结构。<br>客户端在收到响应后，会判断<code>code</code>的值是什么，如果属于定义的成功状态码则通过<code>data</code>提取数据，否则把<code>msg</code>信息通过异常抛出来。</p><p>在使用<code>gRPC</code>中更不例外，因为我们在使用<code>gRPC</code>调用时，就像调用一个普通函数一样，不过<code>gRPC</code>服务间是通过传递message数据来进行交互的，每个调用的请求message和响应message都已经被固定了，如果我们想返回一个错误信息，那么必定会跟响应结构体不一样，所以错误的信息的结构体一定要跟响应体匹配，否则只能另寻它路，比如在每个响应体嵌入错误信息的字段，如下:</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs protobuf"><span class="hljs-class"><span class="hljs-keyword">message</span> <span class="hljs-title">Demo</span> </span>&#123;<br>    <span class="hljs-built_in">string</span> a=<span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">int32</span> b=<span class="hljs-number">2</span>;<br><br>    <span class="hljs-built_in">int32</span> err_code=<span class="hljs-number">3</span>;<br>    <span class="hljs-built_in">string</span> err_msg=<span class="hljs-number">4</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后服务端判断调用执行出错就把错误转换为对应的<code>err_code</code>和<code>err_msg</code>再塞入到message中传给客户端，而客户端每收到调用响应就判断<code>err_code</code>是否有值，有则代表是异常请求，只把<code>err_code</code>和<code>err_msg</code>提取出来生成一个异常并抛给调用者，否则就正常返回数据。</p><p>采用这种方法可以兼容每一种调用，但是并不是十分的优雅，如果能通过别的协议容器把数据传给客户端，客户端通过对应的协议解析到错误信息并生产异常就好，在之前介绍的<code>gRPC</code>服务中，就是采用<code>gRPC.metadata</code>来传输数据。同时为了能自动处理服务端异常的捕获和客户端的异常生成，会分别在客户端和服务端设置一个顶层的拦截器，服务端的顶层拦截器代码如下(因为其它的拦截器可能会抛错，所以捕获错误的拦截器一定要放置在最顶层)：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-comment"># code url: https://github.com/so1n/grpc-example-common/blob/v0.1.5/grpc_example_common/interceptor/server_interceptor/customer_top.py</span><br><span class="hljs-keyword">import</span> logging<br><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> Any, Callable, List, Tuple<br><br><span class="hljs-keyword">import</span> grpc<br><br><span class="hljs-keyword">from</span> grpc_example_common.helper.context <span class="hljs-keyword">import</span> context_proxy<br><br><span class="hljs-keyword">from</span> .base <span class="hljs-keyword">import</span> BaseInterceptor<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomerTopInterceptor</span>(<span class="hljs-params">BaseInterceptor</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">intercept</span>(<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">        self,</span></span><br><span class="hljs-function"><span class="hljs-params">        next_handler_method: Callable,</span></span><br><span class="hljs-function"><span class="hljs-params">        request_proto_message: Any,</span></span><br><span class="hljs-function"><span class="hljs-params">        context: grpc.ServicerContext,</span></span><br><span class="hljs-function"><span class="hljs-params">    </span>) -&gt; Any:</span><br>        return_initial_metadata: List[Tuple] = [(<span class="hljs-string">&quot;customer-user-agent&quot;</span>, <span class="hljs-string">&quot;Python3&quot;</span>)]<br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-comment"># 执行gRPC的调用</span><br>            <span class="hljs-keyword">return</span> next_handler_method(request_proto_message, context)<br>        <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>            <span class="hljs-comment"># 限定客户端带有如下Key-Value的才设置错误信息</span><br>            <span class="hljs-keyword">if</span> self.metadata_dict.get(<span class="hljs-string">&quot;customer-user-agent&quot;</span>, <span class="hljs-string">&quot;&quot;</span>) == <span class="hljs-string">&quot;Python3&quot;</span>:<br>                return_initial_metadata.append((<span class="hljs-string">&quot;exc_name&quot;</span>, e.__class__.__name__))<br>                return_initial_metadata.append((<span class="hljs-string">&quot;exc_info&quot;</span>, <span class="hljs-built_in">str</span>(e)))<br>            <span class="hljs-comment"># 抛出异常，这样gRPC服务端就能捕获到对应的异常，方便服务端进行后续的处理</span><br>            <span class="hljs-keyword">raise</span> e<br>        <span class="hljs-keyword">finally</span>:<br>            <span class="hljs-comment"># 发送结束metadata流到客户端</span><br>            context.send_initial_metadata(return_initial_metadata)<br></code></pre></td></tr></table></figure><p>该拦截器会捕获调用的异常，然后把异常的方法名和异常信息存在metedata中，这里之所以把值设置到metadata中，而不通过<code>context.set_code</code>,<code>context.set_details</code>来设置错误码和错误信息是有原因的。</p><p>首先是<code>code</code>，<code>gRPC</code>限制了只能设置它允许的<code>code</code>，所以这会限制我们去自定义<code>code</code>，同时我们也不应该把业务的错误码设置到响应的错误码中，所以不在这里使用<code>context.set_code</code>；而对于<code>set_details</code>,则是因为<code>gRPC</code>服务端在捕获到异常后会解析对应的异常，然后把异常数据通过<code>context.set_details</code>设置到<code>details</code>中，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_call_behavior</span>(<span class="hljs-params">rpc_event,</span></span><br><span class="hljs-function"><span class="hljs-params">                   state,</span></span><br><span class="hljs-function"><span class="hljs-params">                   behavior,</span></span><br><span class="hljs-function"><span class="hljs-params">                   argument,</span></span><br><span class="hljs-function"><span class="hljs-params">                   request_deserializer,</span></span><br><span class="hljs-function"><span class="hljs-params">                   send_response_callback=<span class="hljs-literal">None</span></span>):</span><br>    <span class="hljs-keyword">from</span> grpc <span class="hljs-keyword">import</span> _create_servicer_context<br>    <span class="hljs-keyword">with</span> _create_servicer_context(rpc_event, state,<br>                                  request_deserializer) <span class="hljs-keyword">as</span> context:<br>        <span class="hljs-keyword">try</span>:<br>            response_or_iterator = <span class="hljs-literal">None</span><br>            <span class="hljs-comment"># 调用请求</span><br>            <span class="hljs-keyword">if</span> send_response_callback <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>                response_or_iterator = behavior(argument, context,<br>                                                send_response_callback)<br>            <span class="hljs-keyword">else</span>:<br>                response_or_iterator = behavior(argument, context)<br>            <span class="hljs-keyword">return</span> response_or_iterator, <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> exception:  <span class="hljs-comment"># pylint: disable=broad-except</span><br>            <span class="hljs-keyword">with</span> state.condition:<br>                <span class="hljs-keyword">if</span> state.aborted:<br>                    _abort(state, rpc_event.call, cygrpc.StatusCode.unknown,<br>                           <span class="hljs-string">b&#x27;RPC Aborted&#x27;</span>)<br>                <span class="hljs-keyword">elif</span> exception <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> state.rpc_errors:<br>                    <span class="hljs-comment"># 这里判断并不属于grpc的错误，则会把错误信息设置到details</span><br>                    details = <span class="hljs-string">&#x27;Exception calling application: &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(<br>                        exception)<br>                    _LOGGER.exception(details)<br>                    _abort(state, rpc_event.call, cygrpc.StatusCode.unknown,<br>                           _common.encode(details))<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>, <span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><p>这就意味着我们即使在拦截器设置了<code>details</code>，但是由于抛出来的异常并不属于<code>gRPC</code>的异常，所以<code>details</code>最终被异常信息覆盖了。</p><p>了解完了服务端的拦截器实现，接下来看看客户端的拦截器实现，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># code url: https://github.com/so1n/grpc-example-common/blob/v0.1.5/grpc_example_common/interceptor/client_interceptor/customer_top.py</span><br><span class="hljs-keyword">import</span> inspect<br><span class="hljs-keyword">import</span> logging<br><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> Any, Callable, Dict, List, Optional, Type<br><br><br><span class="hljs-keyword">from</span> .base <span class="hljs-keyword">import</span> GRPC_RESPONSE, BaseInterceptor, ClientCallDetailsType<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomerTopInterceptor</span>(<span class="hljs-params">BaseInterceptor</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, exc_list: Optional[List[Type[Exception]]] = <span class="hljs-literal">None</span></span>):</span><br>        self.exc_dict: Dict[<span class="hljs-built_in">str</span>, Type[Exception]] = &#123;&#125;<br>        <span class="hljs-keyword">for</span> key, exc <span class="hljs-keyword">in</span> <span class="hljs-built_in">globals</span>()[<span class="hljs-string">&quot;__builtins__&quot;</span>].items():<br>            <span class="hljs-comment"># 注册Python自带的异常</span><br>            <span class="hljs-keyword">if</span> inspect.isclass(exc) <span class="hljs-keyword">and</span> <span class="hljs-built_in">issubclass</span>(exc, Exception):<br>                self.exc_dict[key] = exc<br><br>        <span class="hljs-keyword">if</span> exc_list:<br>            <span class="hljs-comment"># 注册用户指定的异常</span><br>            <span class="hljs-keyword">for</span> exc <span class="hljs-keyword">in</span> exc_list:<br>                <span class="hljs-keyword">if</span> <span class="hljs-built_in">issubclass</span>(exc, Exception):<br>                    self.exc_dict[exc.__name__] = exc<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">intercept</span>(<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">        self,</span></span><br><span class="hljs-function"><span class="hljs-params">        method: Callable,</span></span><br><span class="hljs-function"><span class="hljs-params">        request_or_iterator: Any,</span></span><br><span class="hljs-function"><span class="hljs-params">        call_details: ClientCallDetailsType,</span></span><br><span class="hljs-function"><span class="hljs-params">    </span>) -&gt; GRPC_RESPONSE:</span><br>        <span class="hljs-keyword">if</span> call_details.metadata <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-comment"># 添加协定的信息 </span><br>            call_details.metadata.append((<span class="hljs-string">&quot;customer-user-agent&quot;</span>, <span class="hljs-string">&quot;Python3&quot;</span>))  <span class="hljs-comment"># type: ignore</span><br>        response: GRPC_RESPONSE = method(call_details, request_or_iterator)<br>        metadata_dict: <span class="hljs-built_in">dict</span> = &#123;item.key: item.value <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> response.initial_metadata()&#125;<br>        <span class="hljs-keyword">if</span> metadata_dict.get(<span class="hljs-string">&quot;customer-user-agent&quot;</span>) == <span class="hljs-string">&quot;Python3&quot;</span>:<br>            <span class="hljs-comment"># 提取异常信息</span><br>            exc_name: <span class="hljs-built_in">str</span> = metadata_dict.get(<span class="hljs-string">&quot;exc_name&quot;</span>, <span class="hljs-string">&quot;&quot;</span>)<br>            exc_info: <span class="hljs-built_in">str</span> = metadata_dict.get(<span class="hljs-string">&quot;exc_info&quot;</span>, <span class="hljs-string">&quot;&quot;</span>)<br>            <span class="hljs-comment"># 通过exc_name查找异常</span><br>            exc: Optional[Type[Exception]] = self.exc_dict.get(exc_name)<br>            <span class="hljs-keyword">if</span> exc:<br>                <span class="hljs-comment"># 抛出异常</span><br>                <span class="hljs-keyword">raise</span> exc(exc_info)<br>        <span class="hljs-keyword">return</span> response<br></code></pre></td></tr></table></figure><p>可以看出客户端拦截器通过获取服务端返回的metada来判断是否有异常信息，如果有就提取出并抛出错误，否则就正常返回响应。这样一来只要客户端服务端都设置了正确的拦截器，客户端就能获得到服务端的错误信息并抛出异常，不过这种实现方式是依赖<code>gRPC.metadata</code>传输数据的，而<code>gRPC.metadata</code>的值必须是ASCII或者规范的字节，不然就不给传输甚至还会卡住请求，这就意味着我们需要对错误信息进行一些序列化。</p><h2 id="2-基于官方协定的错误传输实现"><a href="#2-基于官方协定的错误传输实现" class="headerlink" title="2.基于官方协定的错误传输实现"></a>2.基于官方协定的错误传输实现</h2><p>由于上面的实现不是很优雅，于是就上网冲浪寻找一个官方的实现，后面终于在<code>Github</code>中找到了<a href="https://github.com/grpc/grpc/tree/master/examples/python/errors">官方的错误传输示例</a>，其中官方的服务端示例代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">create_greet_limit_exceed_error_status</span>(<span class="hljs-params">name</span>):</span><br>    <span class="hljs-comment"># 创建一个Message对象</span><br>    detail = any_pb2.Any()<br>    <span class="hljs-comment"># 把一个自定义的错误转为一个Any的对象，这样收发消息时就不会出现校验不通过的情况了</span><br>    detail.Pack(<br>        error_details_pb2.QuotaFailure(violations=[<br>            error_details_pb2.QuotaFailure.Violation(<br>                subject=<span class="hljs-string">&quot;name: %s&quot;</span> % name,<br>                description=<span class="hljs-string">&quot;Limit one greeting per person&quot;</span>,<br>            )<br>        ],))<br>    <span class="hljs-comment"># 生成一个Status对象，这个对象包括了code,message,details三个字段</span><br>    <span class="hljs-keyword">return</span> status_pb2.Status(<br>        code=code_pb2.RESOURCE_EXHAUSTED,<br>        message=<span class="hljs-string">&#x27;Request limit exceeded.&#x27;</span>,<br>        <span class="hljs-comment"># 错误对象数组</span><br>        details=[detail],<br>    )<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LimitedGreeter</span>(<span class="hljs-params">helloworld_pb2_grpc.GreeterServicer</span>):</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        self._lock = threading.RLock()<br>        self._greeted = <span class="hljs-built_in">set</span>()<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">SayHello</span>(<span class="hljs-params">self, request, context</span>):</span><br>        <span class="hljs-comment"># 对应的gRPC调用</span><br>        <span class="hljs-keyword">with</span> self._lock:<br>            <span class="hljs-keyword">if</span> request.name <span class="hljs-keyword">in</span> self._greeted:<br>                rich_status = create_greet_limit_exceed_error_status(<br>                    request.name)<br>                context.abort_with_status(rpc_status.to_status(rich_status))<br>            <span class="hljs-keyword">else</span>:<br>                self._greeted.add(request.name)<br>        <span class="hljs-keyword">return</span> helloworld_pb2.HelloReply(message=<span class="hljs-string">&#x27;Hello, %s!&#x27;</span> % request.name)<br></code></pre></td></tr></table></figure><p>该示例代码中的<code>SayHello</code>方法逻辑非常简单，它判断如果<code>name</code>不存在，就把<code>name</code>添加到集合中，并正常返回，如果已经存在，则先生成一个<code>Status</code>对象，再通过<code>to_status</code>方法生成 一个<code>_Status</code>对象， 最后通过<code>abort_with_stauts</code>方法把<code>_Status</code>对象传进去，这样就把错误数据传输到了客户端。</p><p>其中<code>abort_with_stauts</code>方法会使请求引发异常并以非正常状态终止，再把用户指定的<code>Status</code>对象传给客户端，而<code>to_status</code>的源码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">to_status</span>(<span class="hljs-params">status</span>):</span><br>    <span class="hljs-keyword">return</span> _Status(code=code_to_grpc_status_code(status.code),<br>                   details=status.message,<br>                   trailing_metadata=((GRPC_DETAILS_METADATA_KEY,<br>                                       status.SerializeToString()),))<br></code></pre></td></tr></table></figure><p>通过源码可以看出这个函数就是把<code>status.code</code>转为<code>gRPC</code>响应的<code>code</code>，把<code>status.message</code>转为<code>gRPC</code>的<code>details</code>，最后把<code>status</code>转为合法的字符串，并通过<code>GRPC_DETAILS_METADATA_KEY</code>把字符串设置到metadata中。</p><p>而对于客户端则比较简单，源码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">process</span>(<span class="hljs-params">stub</span>):</span><br>    <span class="hljs-keyword">try</span>:<br>        response = stub.SayHello(helloworld_pb2.HelloRequest(name=<span class="hljs-string">&#x27;Alice&#x27;</span>))<br>        _LOGGER.info(<span class="hljs-string">&#x27;Call success: %s&#x27;</span>, response.message)<br>    <span class="hljs-keyword">except</span> grpc.RpcError <span class="hljs-keyword">as</span> rpc_error:<br>        _LOGGER.error(<span class="hljs-string">&#x27;Call failure: %s&#x27;</span>, rpc_error)<br>        <span class="hljs-comment"># 通过`grpc.RpcError`提取Status对象</span><br>        status = rpc_status.from_call(rpc_error)<br>        <span class="hljs-keyword">for</span> detail <span class="hljs-keyword">in</span> status.details:<br>            <span class="hljs-comment"># 读取detail里面的对象，并判断是不是对应的message，如果是则打印一条错误日志，如果不是则抛错</span><br>            <span class="hljs-keyword">if</span> detail.Is(error_details_pb2.QuotaFailure.DESCRIPTOR):<br>                info = error_details_pb2.QuotaFailure()<br>                detail.Unpack(info)<br>                _LOGGER.error(<span class="hljs-string">&#x27;Quota failure: %s&#x27;</span>, info)<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">raise</span> RuntimeError(<span class="hljs-string">&#x27;Unexpected failure: %s&#x27;</span> % detail)<br></code></pre></td></tr></table></figure><p>这段代码中，如果是正常响应，则打印响应体，而如果是异常，客户端会发现响应体的<code>code</code>并不是正常的状态码，所以会抛出一个<code>grpc.RpcError</code>异常，然后通过<code>rpc_status.from_call</code>函数提取异常, 这个函数的逻辑非常简单，源码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">from_call</span>(<span class="hljs-params">call</span>):</span><br>    <span class="hljs-comment"># 如果没有metadata数据就直接返回空</span><br>    <span class="hljs-keyword">if</span> call.trailing_metadata() <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>    <span class="hljs-comment"># 有数据就遍历数据</span><br>    <span class="hljs-keyword">for</span> key, value <span class="hljs-keyword">in</span> call.trailing_metadata():<br>        <span class="hljs-comment"># 如果Key为官方指定的Key，就进入提取数据逻辑</span><br>        <span class="hljs-keyword">if</span> key == GRPC_DETAILS_METADATA_KEY:<br>            <span class="hljs-comment"># 把数据反序列化成一个message对象</span><br>            rich_status = status_pb2.Status.FromString(value)<br>            <span class="hljs-comment"># 校验对象数据是否跟响应体一样</span><br>            <span class="hljs-keyword">if</span> call.code().value[<span class="hljs-number">0</span>] != rich_status.code:<br>                <span class="hljs-keyword">raise</span> ValueError(<br>                    <span class="hljs-string">&#x27;Code in Status proto (%s) doesn\&#x27;t match status code (%s)&#x27;</span><br>                    % (code_to_grpc_status_code(rich_status.code), call.code()))<br>            <span class="hljs-keyword">if</span> call.details() != rich_status.message:<br>                <span class="hljs-keyword">raise</span> ValueError(<br>                    <span class="hljs-string">&#x27;Message in Status proto (%s) doesn\&#x27;t match status details (%s)&#x27;</span><br>                    % (rich_status.message, call.details()))<br>            <span class="hljs-keyword">return</span> rich_status<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br></code></pre></td></tr></table></figure><p>通过源码看出这个逻辑和自定义的错误传递一样，也是通过<code>metadata</code>提取数据然后拼成一个异常对象。不过，需要注意的是<code>from_call</code>的<code>call</code>参数不仅支持<code>grpc.RpcError</code>，它还支持客户端拦截器中得到的<code>response</code>对象，因为<code>call</code>参数在<code>form_call</code>中用到了<code>trailing_metadata</code>，<code>code</code>和<code>details</code>方法都是<code>grpc.RpcError</code>和<code>response</code>对象共同拥有的方法。</p><p>在简单的了解了<code>gRPC</code>的错误传递示例后可以发现，官方的方法与自定义的错误传递很类似，只不过它定义了一个规范的Key，这样一来大家都会认为这个Key对应的值是一个<code>Status</code>对象的序列化成的字符串（由于序列化了，就不用担心存在非ASCII字符的问题）。而这个<code>Status</code>对象中包含了<code>code</code>,<code>message</code>和<code>detail</code>三个字段，分别对应着上面所说的错误结构体:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>    <span class="hljs-attr">&quot;code&quot;</span>: <span class="hljs-string">&quot;0&quot;</span>,<br>    <span class="hljs-attr">&quot;msg&quot;</span>: <span class="hljs-string">&quot;success&quot;</span>,<br>    <span class="hljs-attr">&quot;data&quot;</span>: &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>中的<code>code</code>,<code>msg</code>和<code>data</code>，不过需要注意的是<code>detail</code>是一个数组，它可以存放多个自定义的<code>Message</code>对象。</p><h2 id="3-重新设计错误传递实现"><a href="#3-重新设计错误传递实现" class="headerlink" title="3.重新设计错误传递实现"></a>3.重新设计错误传递实现</h2><p>通过官方的错误传输实现可以发现，这个例子需要服务端的业务逻辑主动通过<code>context.abort_with_status</code>逻辑来主动把错误信息设置到<code>metadata</code>中，同时也需要客户端捕获<code>grpc.RpcError</code>异常再打印出来，这样对业务层来说是非常啰嗦的，于是就尝试把官方协定的错误传输实现与自定义的错误传递结合起来。</p><p>首先是定义一个内部统一的<code>message</code>：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs protobuf"><span class="hljs-class"><span class="hljs-keyword">message</span> <span class="hljs-title">Exec</span></span>&#123;<br>  <span class="hljs-built_in">string</span> name = <span class="hljs-number">1</span>; <span class="hljs-comment">// 异常名</span><br>  <span class="hljs-built_in">string</span> msg = <span class="hljs-number">2</span>;  <span class="hljs-comment">// 异常信息</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这个Message只用于内部业务服务，如果该服务端有开发给其它部门使用，且他们没有兼容这个<code>message</code>，他们也可以通过<code>code</code>和<code>detail</code>知道大概是什么样的错误。</p><p>然后就开始折腾服务端的顶层拦截器，这个拦截器只要改造捕获异常部分的代码即可，源码如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-comment"># code url: https://github.com/so1n/grpc-example-common/blob/v0.1.7/grpc_example_common/interceptor/server_interceptor/customer_top.py</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomerTopInterceptor</span>(<span class="hljs-params">BaseInterceptor</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">intercept</span>(<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">        self,</span></span><br><span class="hljs-function"><span class="hljs-params">        next_handler_method: Callable,</span></span><br><span class="hljs-function"><span class="hljs-params">        request_proto_message: Any,</span></span><br><span class="hljs-function"><span class="hljs-params">        context: grpc.ServicerContext,</span></span><br><span class="hljs-function"><span class="hljs-params">    </span>) -&gt; Any:</span><br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-comment"># 服务调用</span><br>            <span class="hljs-keyword">return</span> next_handler_method(request_proto_message, context)<br>        <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>            <span class="hljs-comment"># 创建一个Message对象</span><br>            detail = any_pb2.Any()<br>            <span class="hljs-comment"># 把一个自定义的错误转为一个Any的对象，这样收发消息时就不会出现校验不通过的情况了</span><br>            <span class="hljs-comment"># 需要注意的是，这里是我们自己定义的message.Exec</span><br>            detail.Pack(<br>                Exec(<br>                    name=e.__class__.__name__,<br>                    msg=<span class="hljs-built_in">str</span>(e)<br>                )<br>            )<br>            <span class="hljs-comment"># 通过abort_with_status把数据通过metadata传给客户端</span><br>            context.abort_with_status(<br>                rpc_status.to_status(<br>                    status_pb2.Status(<br>                        code=code_pb2.RESOURCE_EXHAUSTED,  <span class="hljs-comment"># 这里只允许填写gRPC的错误码，就像我们定义了业务的错误码为2001，但是HTTP的状态码还是200一样</span><br>                        message=<span class="hljs-built_in">str</span>(e),<br>                        details=[detail], <span class="hljs-comment"># 这里是一个数组，所以这里可以定义多套异常的对象去兼容不同的系统，不过在内部调用中尽量统一只有一套方法</span><br>                    )<br>                )<br>            )<br>            <span class="hljs-comment"># 抛出异常，不过gRPC服务端判断该调用已经被标记为abort，不会继续处理</span><br>            <span class="hljs-comment"># 但是对于其它的功能却是有用的，比如opentelemetry的官方实现是在channel外再套用一个channel，所以它需要捕获异常并生成对应的Event</span><br>            <span class="hljs-keyword">raise</span> e<br></code></pre></td></tr></table></figure><p>接着就折腾客户端的顶层拦截器，同样的它只需要改一下数据的获取就可以了，源码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-comment"># code url: https://github.com/so1n/grpc-example-common/blob/v0.1.7/grpc_example_common/interceptor/client_interceptor/customer_top.py</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomerTopInterceptor</span>(<span class="hljs-params">BaseInterceptor</span>):</span><br><br>    <span class="hljs-comment"># 注册异常的带按摩略</span><br>    ...<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">intercept</span>(<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">        self,</span></span><br><span class="hljs-function"><span class="hljs-params">        method: Callable,</span></span><br><span class="hljs-function"><span class="hljs-params">        request_or_iterator: Any,</span></span><br><span class="hljs-function"><span class="hljs-params">        call_details: ClientCallDetailsType,</span></span><br><span class="hljs-function"><span class="hljs-params">    </span>) -&gt; GRPC_RESPONSE:</span><br>        response: GRPC_RESPONSE = method(call_details, request_or_iterator)<br>        <span class="hljs-comment"># 前面说到`from_call`也支持客户端拦截器里通过`method`方法得到的response对象</span><br>        status: Optional[status_pb2.Status] = rpc_status.from_call(response)<br>        <span class="hljs-comment"># 如果不为None,则证明得到了异常数据</span><br>        <span class="hljs-keyword">if</span> status:<br>            <span class="hljs-keyword">for</span> detail <span class="hljs-keyword">in</span> status.details:<br>                <span class="hljs-comment"># 判断这个detail是不是我们要的Message</span><br>                <span class="hljs-keyword">if</span> detail.Is(Exec.DESCRIPTOR):<br>                    <span class="hljs-comment"># 通过反序列化获取数据</span><br>                    exec_instance: Exec = Exec()<br>                    detail.Unpack(exec_instance)<br>                    <span class="hljs-comment"># 生成异常并抛出</span><br>                    exec_class: Type[Exception] = self.exc_dict.get(exec_instance.name) <span class="hljs-keyword">or</span> RuntimeError<br>                    <span class="hljs-keyword">raise</span> exec_class(exec_instance.msg)<br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-keyword">raise</span> RuntimeError(<span class="hljs-string">&#x27;Unexpected failure: %s&#x27;</span> % detail)<br>        <span class="hljs-keyword">return</span> response<br></code></pre></td></tr></table></figure><p>这样一来，新的错误传递实现已经完成了，现在通过一个简单的demo来验证成果，demo代码如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-comment"># grpc_example_common url:https://github.com/so1n/grpc-example-common/tree/v0.1.7</span><br><span class="hljs-comment"># 服务端代码</span><br><span class="hljs-keyword">from</span> concurrent <span class="hljs-keyword">import</span> futures<br><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> List<br><br><span class="hljs-keyword">import</span> grpc<br><span class="hljs-keyword">from</span> grpc_example_common.interceptor.server_interceptor.base <span class="hljs-keyword">import</span> BaseInterceptor<br><span class="hljs-keyword">from</span> google.protobuf.empty_pb2 <span class="hljs-keyword">import</span> Empty  <span class="hljs-comment"># type: ignore</span><br><span class="hljs-keyword">from</span> grpc_example_common.protos.user <span class="hljs-keyword">import</span> user_pb2 <span class="hljs-keyword">as</span> user_message<br><span class="hljs-keyword">from</span> grpc_example_common.interceptor.server_interceptor.customer_top <span class="hljs-keyword">import</span> CustomerTopInterceptor<br><br><span class="hljs-keyword">from</span> grpc_example_common.protos.user <span class="hljs-keyword">import</span> user_pb2_grpc <span class="hljs-keyword">as</span> user_service<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserService</span>(<span class="hljs-params">user_service.UserServicer</span>):</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">delete_user</span>(<span class="hljs-params">self, request: user_message.DeleteUserRequest,</span></span><br><span class="hljs-function"><span class="hljs-params">                    context: grpc.ServicerContext</span>) -&gt; Empty:</span><br>        uid: <span class="hljs-built_in">str</span> = request.uid<br>        <span class="hljs-keyword">if</span> uid == <span class="hljs-string">&quot;123&quot;</span>:<br>            <span class="hljs-keyword">return</span> Empty()<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">f&quot;Not found user:<span class="hljs-subst">&#123;uid&#125;</span>&quot;</span>)<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>(<span class="hljs-params">host: <span class="hljs-built_in">str</span> = <span class="hljs-string">&quot;127.0.0.1&quot;</span>, port: <span class="hljs-built_in">str</span> = <span class="hljs-string">&quot;9000&quot;</span></span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>    interceptor_list: List[BaseInterceptor] = [CustomerTopInterceptor()]<br>    server: grpc.server = grpc.server(<br>        futures.ThreadPoolExecutor(max_workers=<span class="hljs-number">10</span>),<br>        interceptors=interceptor_list,<br>    )<br>    user_service.add_UserServicer_to_server(UserService(), server)<br>    server.add_insecure_port(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;host&#125;</span>:<span class="hljs-subst">&#123;port&#125;</span>&quot;</span>)<br>    server.start()<br>    <span class="hljs-keyword">try</span>:<br>        server.wait_for_termination()<br>    <span class="hljs-keyword">except</span> KeyboardInterrupt:<br>        server.stop(<span class="hljs-number">0</span>)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    main()<br><br><span class="hljs-comment"># 客户端代码</span><br><span class="hljs-keyword">import</span> grpc<br><span class="hljs-keyword">from</span> grpc_example_common.protos.user <span class="hljs-keyword">import</span> user_pb2 <span class="hljs-keyword">as</span> user_message<br><span class="hljs-keyword">from</span> grpc_example_common.protos.user <span class="hljs-keyword">import</span> user_pb2_grpc <span class="hljs-keyword">as</span> user_service<br><span class="hljs-keyword">from</span> grpc_example_common.interceptor.client_interceptor.customer_top <span class="hljs-keyword">import</span> CustomerTopInterceptor<br><br>channel: grpc.Channel = grpc.intercept_channel(<br>    grpc.insecure_channel(<span class="hljs-string">&quot;127.0.0.1:9000&quot;</span>), CustomerTopInterceptor()<br>)<br>user_stub: user_service.UserStub = user_service.UserStub(channel)<br>user_stub.delete_user(user_message.DeleteUserRequest(uid=<span class="hljs-string">&quot;123&quot;</span>))<br>user_stub.delete_user(user_message.DeleteUserRequest(uid=<span class="hljs-string">&quot;456&quot;</span>))<br></code></pre></td></tr></table></figure><p>编写完demo后开始运行，运行后客户端抛出如下错误信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">Traceback (most recent call last):<br>  File <span class="hljs-string">&quot;/home/so1n/github/grpc-example-project/grpc-example-api-backend-service/demo.py&quot;</span>, line 11, <span class="hljs-keyword">in</span> &lt;module&gt;<br>    user_stub.delete_user(user_message.DeleteUserRequest(uid=<span class="hljs-string">&quot;456&quot;</span>))<br>  File <span class="hljs-string">&quot;/home/so1n/github/grpc-example-project/grpc-example-api-backend-service/.venv/lib/python3.8/site-packages/grpc/_interceptor.py&quot;</span>, line 216, <span class="hljs-keyword">in</span> __call__<br>    response, ignored_call = self._with_call(request,<br>  File <span class="hljs-string">&quot;/home/so1n/github/grpc-example-project/grpc-example-api-backend-service/.venv/lib/python3.8/site-packages/grpc/_interceptor.py&quot;</span>, line 254, <span class="hljs-keyword">in</span> _with_call<br>    call = self._interceptor.intercept_unary_unary(continuation,<br>  File <span class="hljs-string">&quot;/home/so1n/github/grpc-example-project/grpc-example-api-backend-service/.venv/lib/python3.8/site-packages/grpc_example_common/interceptor/client_interceptor/base.py&quot;</span>, line 74, <span class="hljs-keyword">in</span> intercept_unary_unary<br>    <span class="hljs-built_in">return</span> self.intercept(continuation, request, call_details)<br>  File <span class="hljs-string">&quot;/home/so1n/github/grpc-example-project/grpc-example-api-backend-service/.venv/lib/python3.8/site-packages/grpc_example_common/interceptor/client_interceptor/customer_top.py&quot;</span>, line 44, <span class="hljs-keyword">in</span> intercept<br>    raise exec_class(exec_instance.msg)<br>ValueError: Not found user:456<br></code></pre></td></tr></table></figure><p>通过信息可以发现，重新设计的错误传递实现完美运行。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;之前在文章&lt;a href=&quot;https://so1n.me/2022/04/07/Python-gRPC%E5%AE%9E%E8%B7%B5</summary>
      
    
    
    <content src="https://ftp.bmp.ovh/imgs/2022/02/bd67e15aa8d46101.png" type="image"/>
    
    
    <category term="Python-gRPC实践" scheme="http://so1n.me/categories/Python-gRPC%E5%AE%9E%E8%B7%B5/"/>
    
    
    <category term="Python" scheme="http://so1n.me/tags/Python/"/>
    
    <category term="gRPC" scheme="http://so1n.me/tags/gRPC/"/>
    
  </entry>
  
  <entry>
    <title>Python 3.11 Asyncio新增的两个高级类</title>
    <link href="http://so1n.me/2022/06/13/two_functional_implementations_based_on_asyncio.Task_extensions/"/>
    <id>http://so1n.me/2022/06/13/two_functional_implementations_based_on_asyncio.Task_extensions/</id>
    <published>2022-06-13T15:33:18.000Z</published>
    <updated>2022-06-24T14:40:56.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前记"><a href="#前记" class="headerlink" title="前记"></a>前记</h2><p><code>Python Asyncio</code>提供了很多基础的API以及对应的对象，如果只用于编写简单的HTTP API处理函数，那么这些<code>Python Asyncio</code>是足够的，但在面对一些复杂点多的需求或者编写网络相关框架时，就需要基于<code>Python Asyncio</code>的基础API封装成高级对象。目前比较常用的高级对象有两个，一个是用于管理代码域超时的<code>timeout</code>以及一个用于结构化并发的<code>TaskGroup</code>，它们最先出现在<a href="https://github.com/python-trio/trio">Trio</a>这个协程库中，后来<a href="https://github.com/agronholm/anyio">Anyio</a>库也支持这两个对象，现在，准备发布Python 3.11中<code>Asyncio</code>库也包括这两个功能。</p><span id="more"></span><blockquote><p>注： 正常情况下，调用经过封装的高级对象的耗时肯定会大于直接调用基础API的耗时，但是高级对象能使代码结构更加优美。比如<code>starlette</code>框架在集成<code>anyio</code>后，性能降低了4.5%，具体见:<a href="https://github.com/encode/starlette/pull/1157">https://github.com/encode/starlette/pull/1157</a></p></blockquote><h2 id="1-人性化的超时"><a href="#1-人性化的超时" class="headerlink" title="1.人性化的超时"></a>1.人性化的超时</h2><p>通常情况下，我们的代码调用结果只有成功或者是失败，但是对于客户端的网络调用来说还存在另外一种情况，就是网络调用可能会永远挂起，不会响应成功或者失败，然后就一直占用着文件描述符等系统资源。所以大多数的客户端都会实现超时机制来解决这个问题，但是客户端支持的超时API都是只针对自己的对应调用，比如<code>httpx</code>这个库，它的对应调用如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-comment"># 使用get方法请求， 超时时间为9秒</span><br><span class="hljs-keyword">import</span> asyncio<br><span class="hljs-keyword">import</span> httpx<br><br>asyncio.run(httpx.AsyncClient().get(url=<span class="hljs-string">&quot;http://so1n.me&quot;</span>, timeout=<span class="hljs-number">9</span>))<br></code></pre></td></tr></table></figure><p>这个调用会请求到<code>http://so1n.me</code>，然后等待响应，如果该网站超过9秒仍未返回响应或者由于网络原因导致该调用没有返回响应，那么就会抛出一个超时错误。<br>这种设计的非常OK的，使用起来非常简单，但如果现在要求的更改为在9秒内请求两次<code>http://so1n.me</code>后还按照上面的写法，就会变得很糟糕，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> asyncio<br><span class="hljs-keyword">import</span> httpx<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">demo</span>() -&gt; <span class="hljs-keyword">None</span>:</span><br>    <span class="hljs-keyword">await</span> httpx.AsyncClient().get(url=<span class="hljs-string">&quot;http://so1n.me&quot;</span>, timeout=<span class="hljs-number">9</span>)<br>    <span class="hljs-keyword">await</span> httpx.AsyncClient().get(url=<span class="hljs-string">&quot;http://so1n.me&quot;</span>, timeout=<span class="hljs-number">9</span>)<br></code></pre></td></tr></table></figure><p>这种情况下假设该方法的每个请求时长为8秒， 那么他的总请求时长为16秒， 已经超出总的超时时长为9秒的要求的, 但每个请求都没有触发超时机制，所以并不会抛出异常。<br>不过这时我们可以换个思路， 因为超时的原本意思是在n秒后中断此次请求, 也就是在某个时刻时终止请求， 那么我们只要在调用时计算出距离超时时刻还有多少时间差，并设置到timeout参数中，就可以使<code>demo</code>调用符合我们的要求了，代码改写后如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> asyncio<br><span class="hljs-keyword">import</span> httpx<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">demo</span>(<span class="hljs-params">timeout: <span class="hljs-built_in">int</span> = <span class="hljs-number">9</span></span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>    deadline: <span class="hljs-built_in">float</span> = time.time() + <span class="hljs-number">9</span><br>    <span class="hljs-keyword">await</span> httpx.AsyncClient().get(url=<span class="hljs-string">&quot;http://so1n.me&quot;</span>, timeout=time.time() - deadline)<br>    <span class="hljs-keyword">await</span> httpx.AsyncClient().get(url=<span class="hljs-string">&quot;http://so1n.me&quot;</span>, timeout=time.time() - deadline)<br></code></pre></td></tr></table></figure><p>这段代码可以完美的工作， 假设第一个请求的时长为5秒， 那么第二次请求的超时参数的值会是4秒， 这是非常ok， 代码也依然保持简单。 不过目前还是有个缺点， 就是每次都计算一次超时时间， 然后再显示传进去, 这个超时是不可传递的， 如果有一个抽象能方便的使用， 那是非常好的，比如像使用<code>wait_for</code>后的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> asyncio<br><span class="hljs-keyword">import</span> httpx<br><span class="hljs-keyword">import</span> time<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sub_demo</span>() -&gt; <span class="hljs-keyword">None</span>:</span><br>    <span class="hljs-keyword">await</span> httpx.AsyncClient().get(url=<span class="hljs-string">&quot;http://so1n.me&quot;</span>)<br>    <span class="hljs-keyword">await</span> httpx.AsyncClient().get(url=<span class="hljs-string">&quot;http://so1n.me&quot;</span>)<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">demo</span>() -&gt; <span class="hljs-keyword">None</span>:</span><br>    <span class="hljs-keyword">await</span> asyncio.wait_for(sub_demo(), timeout=<span class="hljs-number">9</span>)<br><br><br>asyncio.run(demo())<br></code></pre></td></tr></table></figure><p>这段代码通过<code>wait_for</code>使一个函数内的调用共享一个截止时间，当抵达截止时间时， 无论执行当前已经执行到哪个函数， 都会触发超时异常。不过这样的实现会差点意思， 因为每有一个共享截止时间的代码范围， 就需要把对应的逻辑独立出来成一个新的函数, 这样的代码不是特别的优雅， 而且当需要传的参数比较多时， 这简直就是灾难了(当然也可以写成闭包的形式)。</p><p>好在<code>Python</code>通过<code>with</code>语句提供了一个代码范围的管理，所以我们可以尝试通过<code>with</code>语句来管理这片代码范围的执行超时，那该如何实现呢？熟悉<code>with</code>语句的开发者都知道，<code>with</code>语句实际上是一个带有<code>__enter__</code>方法和<code>__exit__</code>方法的类，这两个方法分别提供了进入代码范围和退出代码范围的调用，对于超时这个需求在结合<code>with</code>语句后，只需要在进入代码范围初始化一个计时器，退出时关闭计时器，如果计时器数完（也就是超时了）且尚未被退出逻辑关闭，则会引发超时，并取消代码范围的协程，大概的伪逻辑如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">demo</span>() -&gt; <span class="hljs-keyword">None</span>:</span><br>    <span class="hljs-comment"># 该代码只为了演示逻辑，实际上无法正常运行</span><br>    timer = Timer(<span class="hljs-number">9</span>)<br>    <span class="hljs-keyword">await</span> httpx.AsyncClient().get(url=<span class="hljs-string">&quot;http://so1n.me&quot;</span>)<br>    <span class="hljs-keyword">await</span> httpx.AsyncClient().get(url=<span class="hljs-string">&quot;http://so1n.me&quot;</span>)<br>    timer.close()<br></code></pre></td></tr></table></figure><p>通过伪代码逻辑可以看出两个运行的协程并跟timer并没有任何联系，timer无法管理到这两个协程的，所以timer超时时，两个协程还能正常运行，那该如何与他们建立联系呢？文章<a href="https://so1n.me/2022/04/11/python's_waitable_objects_in_asyncio">《Python的可等待对象在Asyncio的作用》</a>中讲到在一个协程函数中通过<code>await</code>执行的子协程，是交给执行该协程函数对应的<code>task</code>对象管理的，也就是我们对执行协程函数的<code>task</code>对象进行的任何操作都是会传播到对应的子协程的，所以我们只要在进入代码范围时捕获到当前的<code>task</code>，然后通过<code>loop.call_at</code>方法在指定时间调用<code>task.cancel</code>取消<code>task</code>对象，并由<code>task</code>对象传播到被调用的子协程，如下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> asyncio<br><span class="hljs-keyword">import</span> httpx<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">demo</span>() -&gt; <span class="hljs-keyword">None</span>:</span><br>    current_task: asyncio.Task = asyncio.Task.current_task()<br>    loop: asyncio.AbstractEventLoop = asyncio.get_event_loop()<br>    <span class="hljs-comment"># 设置9秒后超时</span><br>    timer: asyncio.events.TimerHandle = loop.call_at(loop.time() + <span class="hljs-number">9</span>, <span class="hljs-keyword">lambda</span>: current_task.cancel())持续创作，加速成长！这是我参与「掘金日新计划 · <span class="hljs-number">6</span> 月更文挑战」的第<span class="hljs-number">2</span>天，点击查看活动详情<br><br><br>    <span class="hljs-keyword">await</span> httpx.AsyncClient().get(url=<span class="hljs-string">&quot;http://so1n.me&quot;</span>)<br>    <span class="hljs-keyword">await</span> httpx.AsyncClient().get(url=<span class="hljs-string">&quot;http://so1n.me&quot;</span>)<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> timer.cancelled():<br>        timer.cancel()<br>    <br></code></pre></td></tr></table></figure><p>这段是可以正常运行的，接下来我们就需要把这段逻辑封装到一个类里面，这样调用者只需要简单的调用就可以实现整块代码域的超时管理，对应的代码如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-comment"># 这是一个简化版本的伪代码, 存在一些逻辑漏洞, 但是都包含了主要流程了，</span><br><br><span class="hljs-keyword">import</span> asyncio<br><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> Optional, Type<br><span class="hljs-keyword">from</span> types <span class="hljs-keyword">import</span> TracebackType<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Deadline</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">        self,</span></span><br><span class="hljs-function"><span class="hljs-params">        delay: Optional[<span class="hljs-built_in">float</span>],</span></span><br><span class="hljs-function"><span class="hljs-params">        loop: Optional[asyncio.AbstractEventLoop] = <span class="hljs-literal">None</span>,</span></span><br><span class="hljs-function"><span class="hljs-params">        timeout_exc: Optional[Exception] = <span class="hljs-literal">None</span>,</span></span><br><span class="hljs-function"><span class="hljs-params">    </span>):</span><br>        <span class="hljs-comment"># 代表多少秒后超时</span><br>        self._delay: Optional[<span class="hljs-built_in">float</span>] = delay<br>        <span class="hljs-comment"># asyncio需要的事件循环</span><br>        self._loop = loop <span class="hljs-keyword">or</span> asyncio.get_event_loop()<br>        <span class="hljs-comment"># 当超时时，如何抛异常</span><br>        self._timeout_exc: Exception = timeout_exc <span class="hljs-keyword">or</span> asyncio.TimeoutError()<br><br>        <span class="hljs-comment"># 控制结束的future</span><br>        self._deadline_future: asyncio.Future = asyncio.Future()<br>        <span class="hljs-comment"># 注册with语句捕获的future</span><br>        self._with_scope_future: Optional[asyncio.Future] = <span class="hljs-literal">None</span> <br>        <span class="hljs-keyword">if</span> self._delay <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-comment"># 计算截止时间和注册截止时间回调，通知event loop在截止时间执行超时机制</span><br>            self._loop.call_at(self._loop.time() + self._delay, self._set_deadline_future_result)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_set_deadline_future_result</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        <span class="hljs-comment"># 当到截止时间时， 设置执行结束， 并对还在执行的with future进行cancel操作</span><br>        self._deadline_future.set_result(<span class="hljs-literal">True</span>)<br>        <span class="hljs-keyword">if</span> self._with_scope_future <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> self._with_scope_future.cancelled():<br>            self._with_scope_future.cancel()<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__enter__</span>(<span class="hljs-params">self</span>) -&gt; &quot;Deadline&quot;:</span><br>        <span class="hljs-comment"># 进入with语句范围</span><br>        <span class="hljs-keyword">if</span> self._with_scope_future:<br>            <span class="hljs-comment"># 一个实例同时只能调用一次， 多次调用会出错</span><br>            <span class="hljs-keyword">raise</span> RuntimeError(<span class="hljs-string">&quot;`with` can only be called once&quot;</span>)<br>        <span class="hljs-keyword">if</span> self._delay <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-comment"># 启动了超时机制</span><br><br>            <span class="hljs-comment"># 获取当前运行的task</span><br>            main_task: Optional[asyncio.Task] = asyncio.Task.current_task(self._loop)<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> main_task:<br>                <span class="hljs-keyword">raise</span> RuntimeError(<span class="hljs-string">&quot;Can not found current task&quot;</span>)<br>            <span class="hljs-comment"># 注册with语句所在的future</span><br>            self._with_scope_future = main_task<br>        <span class="hljs-keyword">return</span> self<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__exit__</span>(<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">        self,</span></span><br><span class="hljs-function"><span class="hljs-params">        exc_type: Optional[Type[BaseException]],</span></span><br><span class="hljs-function"><span class="hljs-params">        exc_val: Optional[BaseException],</span></span><br><span class="hljs-function"><span class="hljs-params">        exc_tb: Optional[TracebackType],</span></span><br><span class="hljs-function"><span class="hljs-params">    </span>) -&gt; Optional[bool]:</span><br>        <span class="hljs-comment"># 由于执行完成或者是异常退出with语句范围</span><br>        <span class="hljs-keyword">if</span> self._with_scope_future:<br>            self._with_scope_future = <span class="hljs-literal">None</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br><br>        <span class="hljs-keyword">if</span> self._deadline_future.done():<br>            <span class="hljs-comment"># 如果控制结束的future已经结束， 代表此次with语句范围的代码执行超时了</span><br>            <span class="hljs-keyword">raise</span> self._timeout_exc<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br></code></pre></td></tr></table></figure><p>现在超时类编写完成，它的使用方法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> asyncio<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">demo</span>() -&gt; <span class="hljs-keyword">None</span>:</span><br>    <span class="hljs-keyword">with</span> Deadline(delay=<span class="hljs-number">9</span>):<br>        <span class="hljs-keyword">await</span> httpx.AsyncClient().get(url=<span class="hljs-string">&quot;http://so1n.me&quot;</span>)<br>        <span class="hljs-keyword">await</span> httpx.AsyncClient().get(url=<span class="hljs-string">&quot;http://so1n.me&quot;</span>)<br><br><br>asyncio.run(demo())<br></code></pre></td></tr></table></figure><p>可以看到，这样的使用方法非常方便，不过这个功能在<code>Python</code>3.11已经提供了，可以通过<a href="https://github.com/python/cpython/blob/v3.11.0b3/Lib/asyncio/timeouts.py%E4%BA%86%E8%A7%A3Python%E6%8F%90%E4%BE%9B%E7%9A%84timeout%E5%AE%9E%E7%8E%B0%E3%80%82">https://github.com/python/cpython/blob/v3.11.0b3/Lib/asyncio/timeouts.py了解Python提供的timeout实现。</a></p><h2 id="2-结构化并发"><a href="#2-结构化并发" class="headerlink" title="2.结构化并发"></a>2.结构化并发</h2><p>结构化并发借鉴了结构化编程这一名词，它的作用就是确保调用者进行了一个调用后还能控制这个调用过程，或者是得到调用结果，具体的结构化并发描述见<a href="https://vorpus.org/blog/notes-on-structured-concurrency-or-go-statement-considered-harmful/">Notes on structured concurrency, or: Go statement considered harmful</a>或者译文<a href="https://juejin.cn/post/6844904146424823816">【译】「结构化并发」简析，或：有害的go语句</a>。</p><p>在使用<code>Python Asyncio</code>编写代码时，会为了提高并发能力而通过<code>asyncio.create</code>创建很多Task运行，这种情况下可能导致调用者无法得到协程的运行结果，比如一个服务端为了提高并发能力，在接收到请求时通常都会分发给其它协程去处理，这时就可能导致代码不属于结构化并发， 下面通过一个生产消费者来模拟这一个行为，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> asyncio<br><span class="hljs-keyword">import</span> random<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">request_handle</span>(<span class="hljs-params">data</span>):</span><br>    <span class="hljs-comment"># 处理请求</span><br>    print(data)<br>    <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">1</span>)<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">recv_request</span>(<span class="hljs-params">queue: asyncio.Queue</span>):</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        <span class="hljs-comment"># 接收请求</span><br>        data = <span class="hljs-keyword">await</span> queue.get()<br>        <span class="hljs-comment"># 分发给其它协程处理</span><br>        asyncio.create_task(request_handle(data))<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">send_request</span>(<span class="hljs-params">queue: asyncio.Queue</span>):</span><br>    <span class="hljs-comment"># 发送请求</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        <span class="hljs-keyword">await</span> queue.put(random.randint(<span class="hljs-number">0</span>, <span class="hljs-number">100</span>))<br>        <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">0.01</span>)<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    queue: asyncio.Queue = asyncio.Queue()<br>    asyncio.create_task(recv_request(queue))<br>    <span class="hljs-keyword">await</span> (send_request(queue))<br><br>asyncio.run(main())<br><br></code></pre></td></tr></table></figure><p>这段代码首先是通过<code>asyncio.create_task</code>创建一个发送者在后台运行着，然后通过<code>await</code>等待<code>send_request</code>调用运行结束，不过<code>send_request</code>是不会结束的，它会一直运行下去，并且每隔0.01秒就会发送一个数据到queue里面。同时在后台运行的<code>recv_request</code>就会从queue获取到数据，并且为了不阻塞自己的处理逻辑，会通过<code>create_task</code>创建一个请求处理者来处理这个请求。</p><p>这段程序可以一直运行着，但是调用者不知道后台运行的任务是否一直在正常的运行着，而且可能需要他们在运行出错时捕获到对应的错误，并把错误抛出来，于是需要对<code>main</code>函数进行一些改造：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    queue: asyncio.Queue = asyncio.Queue()<br>    recv_coro = recv_request(queue)<br>    send_coro = send_request(queue)<br>    <span class="hljs-keyword">await</span> asyncio.gather(recv_coro, send_coro)<br></code></pre></td></tr></table></figure><p>这样就能捕获到发送消息的协程和接收消息的协程的异常，并把错误抛出来了，不过对于接收消息并分发给其它协程这段逻辑却无法通过<code>asyncio.gather</code>来管理，因为该逻辑是收到消息就会创建一个协程来处理的，这是实时创建的，而<code>asyncio.gather</code>只能管理已经创建的Corotinue。</p><p>如果有一个类，可以像<code>timeout</code>管理这个作用域的所有派生出来的协程，捕获派送协程的异常，那就很棒了。而在<code>Python</code>3.11或者是<code>Anyio</code>中可以通过<code>TaskGroup</code>解决这个问题，在使用<code>TaskGroup</code>后，<code>recv_request</code>代码改写为如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> asyncio<br><span class="hljs-keyword">import</span> random<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">request_handle</span>(<span class="hljs-params">data</span>):</span><br>    <span class="hljs-comment"># 处理请求</span><br>    print(data)<br>    <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">1</span>)<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">recv_request</span>(<span class="hljs-params">queue: asyncio.Queue</span>):</span><br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> asyncio.task_group.TaskGroup() <span class="hljs-keyword">as</span> tg:<br>        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>            <span class="hljs-comment"># 接收请求</span><br>            data = <span class="hljs-keyword">await</span> queue.get()<br>            <span class="hljs-comment"># 分发给其它协程处理</span><br>            tg.create_task(request_handle(data))<br></code></pre></td></tr></table></figure><p>可以看到这个代码改动不大，首先是通过<code>asyncio.task_group.TaskGroup</code>创建一个对象并开启一个代码域，然后通过<code>tg</code>这个对象的<code>create_task</code>方法派生一个协程来处理数据，这个用法跟<code>asyncio.create_task</code>很像，但是通过<code>tg.create_task</code>创建的协程是会被<code>tg</code>管理的。<br>这时，如果<code>request_handle</code>对应的协程抛出来异常，<code>tg</code>对象也会退出并抛出对应的异常，同时这个代码域执行完毕后，也不会退出这片代码域，而是需要等所有通过<code>tg.create_task</code>创建的协程执行完毕后才会退出。</p><p>通过上面的<code>timeout</code>可以猜到<code>TaskGroup</code>也是在<code>__aenter__</code>时获取当前<code>task</code>对象并在后续使用着，现在通过<a href="https://github.com/python/cpython/blob/v3.11.0b3/Lib/asyncio/taskgroups.py">taskgroups.py</a>了解<code>TaskGroup</code>是如何执行的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">from</span> asycnio <span class="hljs-keyword">import</span> events<br><span class="hljs-keyword">from</span> asycnio <span class="hljs-keyword">import</span> exceptions<br><span class="hljs-keyword">from</span> asycnio <span class="hljs-keyword">import</span> tasks<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TaskGroup</span>:</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        self._entered = <span class="hljs-literal">False</span><br>        self._exiting = <span class="hljs-literal">False</span><br>        self._aborting = <span class="hljs-literal">False</span><br>        self._loop = <span class="hljs-literal">None</span><br>        self._parent_task = <span class="hljs-literal">None</span><br>        self._parent_cancel_requested = <span class="hljs-literal">False</span><br>        self._tasks = <span class="hljs-built_in">set</span>()<br>        self._errors = []<br>        self._base_error = <span class="hljs-literal">None</span><br>        self._on_completed_fut = <span class="hljs-literal">None</span><br><br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__aenter__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-comment"># 限制只能调用一次</span><br>        <span class="hljs-keyword">if</span> self._entered:<br>            <span class="hljs-keyword">raise</span> RuntimeError(<br>                <span class="hljs-string">f&quot;TaskGroup <span class="hljs-subst">&#123;self!r&#125;</span> has been already entered&quot;</span>)<br>        self._entered = <span class="hljs-literal">True</span><br><br>        <span class="hljs-keyword">if</span> self._loop <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            self._loop = events.get_running_loop()<br><br>        <span class="hljs-comment"># 获取当前的task</span><br>        self._parent_task = tasks.current_task(self._loop)<br>        <span class="hljs-keyword">if</span> self._parent_task <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">raise</span> RuntimeError(<br>                <span class="hljs-string">f&#x27;TaskGroup <span class="hljs-subst">&#123;self!r&#125;</span> cannot determine the parent task&#x27;</span>)<br><br>        <span class="hljs-keyword">return</span> self<br><br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__aexit__</span>(<span class="hljs-params">self, et, exc, tb</span>):</span><br>        self._exiting = <span class="hljs-literal">True</span><br>        propagate_cancellation_error = <span class="hljs-literal">None</span><br><br>        <span class="hljs-keyword">if</span> (exc <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span><br>                self._is_base_error(exc) <span class="hljs-keyword">and</span><br>                self._base_error <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>):<br>            self._base_error = exc<br><br>        <span class="hljs-keyword">if</span> et <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">if</span> et <span class="hljs-keyword">is</span> exceptions.CancelledError:<br>                <span class="hljs-keyword">if</span> self._parent_cancel_requested <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> self._parent_task.uncancel():<br>                    <span class="hljs-comment"># Do nothing, i.e. swallow the error.</span><br>                    <span class="hljs-keyword">pass</span><br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-comment"># 如果有一个协程已经取消了，就设置取消的exc</span><br>                    propagate_cancellation_error = exc<br><br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self._aborting:<br>                <span class="hljs-comment"># 取消所有的task</span><br>                self._abort()<br><br>        <span class="hljs-comment"># 如果还有派生的协程来运行，就陷在这个逻辑中</span><br>        <span class="hljs-keyword">while</span> self._tasks:<br>            <span class="hljs-keyword">if</span> self._on_completed_fut <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>                self._on_completed_fut = self._loop.create_future()<br><br>            <span class="hljs-keyword">try</span>:<br>                <span class="hljs-comment"># 创建一个中间future来捕获所有派生协程的异常，并等待协程运行完毕</span><br>                <span class="hljs-keyword">await</span> self._on_completed_fut<br>            <span class="hljs-keyword">except</span> exceptions.CancelledError <span class="hljs-keyword">as</span> ex:<br>                <span class="hljs-comment"># TaskGroup不会使_on_completed_fut抛出取消异常，但是如果main_task被取消时，会传播到_on_completed_fut</span><br>                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self._aborting:<br>                    <span class="hljs-comment"># 与上面一样设置错误，并取消所有协程</span><br>                    propagate_cancellation_error = ex<br>                    self._abort()<br><br>            self._on_completed_fut = <span class="hljs-literal">None</span><br><br>        <span class="hljs-keyword">assert</span> <span class="hljs-keyword">not</span> self._tasks<br><br>        <span class="hljs-comment"># 如果有异常，则抛出</span><br>        <span class="hljs-keyword">if</span> self._base_error <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">raise</span> self._base_error<br><br>        <span class="hljs-keyword">if</span> propagate_cancellation_error <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">raise</span> propagate_cancellation_error<br><br>        <span class="hljs-keyword">if</span> et <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> et <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> exceptions.CancelledError:<br>            self._errors.append(exc)<br><br>        <span class="hljs-comment"># 抛出所有运行期间的异常</span><br>        <span class="hljs-keyword">if</span> self._errors:<br>            errors = self._errors<br>            self._errors = <span class="hljs-literal">None</span><br><br>            me = BaseExceptionGroup(<span class="hljs-string">&#x27;unhandled errors in a TaskGroup&#x27;</span>, errors)<br>            <span class="hljs-keyword">raise</span> me <span class="hljs-keyword">from</span> <span class="hljs-literal">None</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">create_task</span>(<span class="hljs-params">self, coro, *, name=<span class="hljs-literal">None</span>, context=<span class="hljs-literal">None</span></span>):</span><br>        <span class="hljs-comment"># 判断目前是否生效，如果不生效就无法派生协程</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self._entered:<br>            <span class="hljs-keyword">raise</span> RuntimeError(<span class="hljs-string">f&quot;TaskGroup <span class="hljs-subst">&#123;self!r&#125;</span> has not been entered&quot;</span>)<br>        <span class="hljs-keyword">if</span> self._exiting <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> self._tasks:<br>            <span class="hljs-keyword">raise</span> RuntimeError(<span class="hljs-string">f&quot;TaskGroup <span class="hljs-subst">&#123;self!r&#125;</span> is finished&quot;</span>)<br>        <span class="hljs-comment"># 通过事件循环创建协程</span><br>        <span class="hljs-keyword">if</span> context <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            task = self._loop.create_task(coro)<br>        <span class="hljs-keyword">else</span>:<br>            task = self._loop.create_task(coro, context=context)<br>        tasks._set_task_name(task, name)<br>        <span class="hljs-comment"># 添加task执行结果回调</span><br>        task.add_done_callback(self._on_task_done)<br>        <span class="hljs-comment"># 把task添加到对应的self._task，这样其它方法就会判断协程是否运行完毕了</span><br>        self._tasks.add(task)<br>        <span class="hljs-keyword">return</span> task<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_is_base_error</span>(<span class="hljs-params">self, exc: BaseException</span>) -&gt; bool:</span><br>        <span class="hljs-keyword">assert</span> <span class="hljs-built_in">isinstance</span>(exc, BaseException)<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">isinstance</span>(exc, (SystemExit, KeyboardInterrupt))<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_abort</span>(<span class="hljs-params">self</span>):</span><br>        self._aborting = <span class="hljs-literal">True</span><br><br>        <span class="hljs-comment"># 取消所有派生的协程</span><br>        <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> self._tasks:<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> t.done():<br>                t.cancel()<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_on_task_done</span>(<span class="hljs-params">self, task</span>):</span><br>        <span class="hljs-comment"># 安全的删除对应的task</span><br>        self._tasks.discard(task)<br><br>        <span class="hljs-keyword">if</span> self._on_completed_fut <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> self._tasks:<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self._on_completed_fut.done():<br>                <span class="hljs-comment"># 如果最后一个派生的协程运行结束，则设置中间future,这样TaskGroup.__aexit__的while循环就能继续执行了</span><br>                self._on_completed_fut.set_result(<span class="hljs-literal">True</span>)<br><br>        <span class="hljs-comment"># 如果task已经取消或者没有异常，则不走下面的逻辑</span><br>        <span class="hljs-keyword">if</span> task.cancelled():<br>            <span class="hljs-keyword">return</span><br>        exc = task.exception()<br>        <span class="hljs-keyword">if</span> exc <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">return</span><br><br>        <span class="hljs-comment"># 把异常添加到类中</span><br>        self._errors.append(exc)<br>        <span class="hljs-keyword">if</span> self._is_base_error(exc) <span class="hljs-keyword">and</span> self._base_error <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            self._base_error = exc<br><br>        <span class="hljs-comment"># 最后处理下当前task</span><br>        <span class="hljs-keyword">if</span> self._parent_task.done():<br>            <span class="hljs-comment"># Not sure if this case is possible, but we want to handle</span><br>            <span class="hljs-comment"># it anyways.</span><br>            self._loop.call_exception_handler(&#123;<br>                <span class="hljs-string">&#x27;message&#x27;</span>: <span class="hljs-string">f&#x27;Task <span class="hljs-subst">&#123;task!r&#125;</span> has errored out but its parent &#x27;</span><br>                           <span class="hljs-string">f&#x27;task <span class="hljs-subst">&#123;self._parent_task&#125;</span> is already completed&#x27;</span>,<br>                <span class="hljs-string">&#x27;exception&#x27;</span>: exc,<br>                <span class="hljs-string">&#x27;task&#x27;</span>: task,<br>            &#125;)<br>            <span class="hljs-keyword">return</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self._aborting <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> self._parent_cancel_requested:<br>            self._abort()<br>            self._parent_cancel_requested = <span class="hljs-literal">True</span><br>            self._parent_task.cancel()<br></code></pre></td></tr></table></figure><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3.总结"></a>3.总结</h2><p>可以看到，这两个功能都是通过<code>task</code>把我们的调用向子协程进行传播，这样一来就可以通过<code>task</code>方便的控制对应的协程，但是这也有一个缺点，就是一处函数为<code>async</code>，则处处函数都是<code>async</code>（对于需要IO调用的函数来说），而<code>Go</code>语言的协程就没有这种担忧，但是<code>Go</code>语言创建的协程是无法被管理的，除非创建协程的时候把<code>Context</code>对象传进去，并在对应的协程中通过<code>channel</code>来捕获<code>Context</code>对象的方法，这就要求开发<code>Go</code>库的开发者需要有良好的开发能力，能考虑到使用者在调用时是否需要考虑到超时，结构化并发等需求。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前记&quot;&gt;&lt;a href=&quot;#前记&quot; class=&quot;headerlink&quot; title=&quot;前记&quot;&gt;&lt;/a&gt;前记&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Python Asyncio&lt;/code&gt;提供了很多基础的API以及对应的对象，如果只用于编写简单的HTTP API处理函数，那么这些&lt;code&gt;Python Asyncio&lt;/code&gt;是足够的，但在面对一些复杂点多的需求或者编写网络相关框架时，就需要基于&lt;code&gt;Python Asyncio&lt;/code&gt;的基础API封装成高级对象。目前比较常用的高级对象有两个，一个是用于管理代码域超时的&lt;code&gt;timeout&lt;/code&gt;以及一个用于结构化并发的&lt;code&gt;TaskGroup&lt;/code&gt;，它们最先出现在&lt;a href=&quot;https://github.com/python-trio/trio&quot;&gt;Trio&lt;/a&gt;这个协程库中，后来&lt;a href=&quot;https://github.com/agronholm/anyio&quot;&gt;Anyio&lt;/a&gt;库也支持这两个对象，现在，准备发布Python 3.11中&lt;code&gt;Asyncio&lt;/code&gt;库也包括这两个功能。&lt;/p&gt;</summary>
    
    
    <content src="https://fastly.jsdelivr.net/gh/so1n/so1n_blog_photo@master/blog_photo/16550442517731649661119526images.png" type="image"/>
    
    
    <category term="Python Asyncio" scheme="http://so1n.me/categories/Python-Asyncio/"/>
    
    
    <category term="Python" scheme="http://so1n.me/tags/Python/"/>
    
    <category term="Asyncio" scheme="http://so1n.me/tags/Asyncio/"/>
    
  </entry>
  
  <entry>
    <title>Python Asyncio调度原理</title>
    <link href="http://so1n.me/2022/06/08/python_asyncio_schedule/"/>
    <id>http://so1n.me/2022/06/08/python_asyncio_schedule/</id>
    <published>2022-06-08T15:33:18.000Z</published>
    <updated>2022-06-12T15:08:22.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前记"><a href="#前记" class="headerlink" title="前记"></a>前记</h2><p>在文章<a href="https://so1n.me/2022/04/11/python's_waitable_objects_in_asyncio/">《Python的可等待对象在Asyncio的作用》</a>中介绍了<code>Python</code>的可等待对象作用，特别是<code>Task</code>对象在启动的时候可以自我驱动，但是一个<code>Task</code>对象只能驱动一条执行链，如果要多条链执行（并发），还是需要<code>EventLoop</code>来安排驱动，接下来将通过<code>Python.Asyncio</code>库的源码来了解<code>EventLoop</code>是如何运作的。</p><span id="more"></span><h2 id="1-基本介绍"><a href="#1-基本介绍" class="headerlink" title="1.基本介绍"></a>1.基本介绍</h2><p><code>Python.Asyncio</code>是一个大而全的库，它包括很多功能，而跟核心调度相关的逻辑除了三种可等待对象外，还有其它一些功能，它们分别位于<code>runners.py</code>，<code>base_event.py</code>，<code>event.py</code>三个文件中。</p><p><code>runners.py</code>文件有一个主要的类–<code>Runner</code>，它的主要职责是做好进入协程模式的事件循环等到初始化工作，以及在退出协程模式时清理还在内存的协程，生成器等对象。</p><blockquote><p>协程模式只是为了能方便理解，对于计算机而言，并没有这样区分</p></blockquote><p><code>event.py</code>文件除了存放着<code>EventLoop</code>对象的接口以及获取和设置<code>EventLoop</code>的函数外，还有两个<code>EventLoop</code>可调度的对象，分别为<code>Handler</code>和<code>TimerHandler</code>，它们可以认为是<code>EvnetLoop</code>调用其它对象的容器，用于连接待调度对象和事件循环的关系，不过它们的实现非常简单，对于<code>Handler</code>，它的源码如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-comment"># 已经移除了一些不想关的代码</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Handle</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, callback, args, loop, context=<span class="hljs-literal">None</span></span>):</span><br>        <span class="hljs-comment"># 初始化上下文，确保执行的时候能找到Handle所在的上下文</span><br>        <span class="hljs-keyword">if</span> context <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            context = contextvars.copy_context()<br>        self._context = context<br>        self._loop = loop<br>        self._callback = callback<br>        self._args = args<br>        self._cancelled = <span class="hljs-literal">False</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">cancel</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-comment"># 设置当前Handle为取消状态</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self._cancelled:<br>            self._cancelled = <span class="hljs-literal">True</span><br>            self._callback = <span class="hljs-literal">None</span><br>            self._args = <span class="hljs-literal">None</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">cancelled</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> self._cancelled<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_run</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-comment"># 用于执行真正的函数，且通过context.run方法来确保在自己的上下文内执行。</span><br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-comment"># 保持在自己持有的上下文中执行对应的回调</span><br>            self._context.run(self._callback, *self._args)<br>        <span class="hljs-keyword">except</span> (SystemExit, KeyboardInterrupt):<br>            <span class="hljs-keyword">raise</span><br>        <span class="hljs-keyword">except</span> BaseException <span class="hljs-keyword">as</span> exc:<br>            cb = format_helpers._format_callback_source(<br>                self._callback, self._args)<br>            msg = <span class="hljs-string">f&#x27;Exception in callback <span class="hljs-subst">&#123;cb&#125;</span>&#x27;</span><br>            context = &#123;<br>                <span class="hljs-string">&#x27;message&#x27;</span>: msg,<br>                <span class="hljs-string">&#x27;exception&#x27;</span>: exc,<br>                <span class="hljs-string">&#x27;handle&#x27;</span>: self,<br>            &#125;<br>            self._loop.call_exception_handler(context)<br></code></pre></td></tr></table></figure><p>通过源码可以发现，<code>Handle</code>功能十分简单，提供了可以被取消以及可以在自己所处的上下文执行的功能，而<code>TimerHandle</code>继承于<code>Handle</code>比<code>Handle</code>多了一些和时间以及排序相关的参数，源码如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TimerHandle</span>(<span class="hljs-params">Handle</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, when, callback, args, loop, context=<span class="hljs-literal">None</span></span>):</span><br>        <span class="hljs-built_in">super</span>().__init__(callback, args, loop, context)<br>        self._when = when<br>        self._scheduled = <span class="hljs-literal">False</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__hash__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">hash</span>(self._when)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__lt__</span>(<span class="hljs-params">self, other</span>):</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(other, TimerHandle):<br>            <span class="hljs-keyword">return</span> self._when &lt; other._when<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NotImplemented</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__le__</span>(<span class="hljs-params">self, other</span>):</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(other, TimerHandle):<br>            <span class="hljs-keyword">return</span> self._when &lt; other._when <span class="hljs-keyword">or</span> self.__eq__(other)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NotImplemented</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__gt__</span>(<span class="hljs-params">self, other</span>):</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(other, TimerHandle):<br>            <span class="hljs-keyword">return</span> self._when &gt; other._when<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NotImplemented</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__ge__</span>(<span class="hljs-params">self, other</span>):</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(other, TimerHandle):<br>            <span class="hljs-keyword">return</span> self._when &gt; other._when <span class="hljs-keyword">or</span> self.__eq__(other)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NotImplemented</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__eq__</span>(<span class="hljs-params">self, other</span>):</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(other, TimerHandle):<br>            <span class="hljs-keyword">return</span> (self._when == other._when <span class="hljs-keyword">and</span><br>                    self._callback == other._callback <span class="hljs-keyword">and</span><br>                    self._args == other._args <span class="hljs-keyword">and</span><br>                    self._cancelled == other._cancelled)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NotImplemented</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">cancel</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self._cancelled:<br>            <span class="hljs-comment"># 用于通知事件循环当前Handle已经退出了</span><br>            self._loop._timer_handle_cancelled(self)<br>        <span class="hljs-built_in">super</span>().cancel()<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">when</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> self._when<br></code></pre></td></tr></table></figure><p>通过代码可以发现，这两个对象十分简单，而我们在使用<code>Python.Asyncio</code>时并不会直接使用到这两个对象，而是通过<code>loop.call_xxx</code>系列方法来把调用封装成<code>Handle</code>对象，然后等待<code>EventLoop</code>执行。<br>所以<code>loop.call_xxx</code>系列方法可以认为是<code>EventLoop</code>的注册操作，基本上所有非IO的异步操作都需要通过<code>loop.call_xxx</code>方法来把自己的调用注册到<code>EventLoop</code>中，比如<code>Task</code>对象就在初始化后通过调用<code>loop.call_soon</code>方法来注册到<code>EventLoop</code>中，<code>loop.call_sonn</code>的实现很简单，它的源码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseEventLoop</span>:</span><br>    ...<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">call_soon</span>(<span class="hljs-params">self, callback, *args, context=<span class="hljs-literal">None</span></span>):</span><br>        <span class="hljs-comment"># 检查是否事件循环是否关闭，如果是则直接抛出异常</span><br>        self._check_closed()<br>        handle = self._call_soon(callback, args, context)<br>        <span class="hljs-keyword">return</span> handle<br><br>   <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_call_soon</span>(<span class="hljs-params">self, callback, args, context</span>):</span><br>        <span class="hljs-comment"># 把调用封装成一个handle，这样方便被事件循环调用</span><br>        handle = events.Handle(callback, args, self, context)<br>        <span class="hljs-comment"># 添加一个handle到_ready，等待被调用</span><br>        self._ready.append(handle)<br>        <span class="hljs-keyword">return</span> handle<br></code></pre></td></tr></table></figure><p>可以看到<code>call_soon</code>真正相关的代码只有10几行，它负责把一个调用封装成一个<code>Handle</code>，并添加到<code>self._reday</code>中，从而实现把调用注册到事件循环之中。</p><p><code>loop.call_xxx</code>系列函数除了<code>loop.call_soon</code>系列函数外，还有另外两个方法–<code>loop.call_at</code>和<code>loop.call_later</code>，它们类似于<code>loop.call_soon</code>，不过多了一个时间参数，来告诉<code>EventLoop</code>在什么时间后才可以调用，同时通过<code>loop.call_at</code>和<code>loop.call_later</code>注册的调用会通过<code>Python</code>的堆排序模块<code>headpq</code>注册到<code>self._scheduled</code>变量中，具体代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseEventLoop</span>:</span><br>    ...<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">call_later</span>(<span class="hljs-params">self, delay, callback, *args, context=<span class="hljs-literal">None</span></span>):</span><br>        <span class="hljs-keyword">if</span> delay <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">raise</span> TypeError(<span class="hljs-string">&#x27;delay must not be None&#x27;</span>)<br>        timer = self.call_at(self.time() + delay, callback, *args, context=context)<br>        <span class="hljs-keyword">return</span> timer<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">call_at</span>(<span class="hljs-params">self, when, callback, *args, context=<span class="hljs-literal">None</span></span>):</span><br>        <span class="hljs-keyword">if</span> when <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">raise</span> TypeError(<span class="hljs-string">&quot;when cannot be None&quot;</span>)<br>        self._check_closed()<br>        <span class="hljs-comment"># 创建一个timer handle，然后添加到事件循环的_scheduled中，等待被调用</span><br>        timer = events.TimerHandle(when, callback, args, self, context)<br>        heapq.heappush(self._scheduled, timer)<br>        timer._scheduled = <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">return</span> timer<br></code></pre></td></tr></table></figure><h2 id="2-EventLoop的调度实现"><a href="#2-EventLoop的调度实现" class="headerlink" title="2.EventLoop的调度实现"></a>2.EventLoop的调度实现</h2><p>在文章<a href="https://so1n.me/2022/04/11/python's_waitable_objects_in_asyncio/">《Python的可等待对象在Asyncio的作用》</a>中已经分析到了<code>runner</code>会通过<code>loop.run_until_complete</code>来调用<code>main</code>Task从而开启<code>EventLoop</code>的调度，所以在分析<code>EventLoop</code>的调度时，应该先从<code>loop.run_until_complete</code>入手，对应的源码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseEventLoop</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run_until_complete</span>(<span class="hljs-params">self, future</span>):</span><br>        ...<br><br>        new_task = <span class="hljs-keyword">not</span> futures.isfuture(future)<br>        <span class="hljs-comment"># 把coroutine转换成task，这样事件循环就可以调度了，事件循环的最小调度单位为task</span><br>        <span class="hljs-comment"># 需要注意的是此时事件循环并没注册到全局变量中，所以需要显示的传进去，</span><br>        <span class="hljs-comment"># 同时Task对象注册的时候，已经通过loop.call_soon把自己注册到事件循环中，等待调度</span><br>        future = tasks.ensure_future(future, loop=self)<br>        <span class="hljs-keyword">if</span> new_task:<br>            <span class="hljs-comment"># An exception is raised if the future didn&#x27;t complete, so there</span><br>            <span class="hljs-comment"># is no need to log the &quot;destroy pending task&quot; message</span><br>            future._log_destroy_pending = <span class="hljs-literal">False</span><br><br>        <span class="hljs-comment"># 当该task完成时，意味着当前事件循环失去了调度对象，无法继续调度，所以需要关闭当前事件循环，程序会由协程模式返回到线程模式</span><br>        future.add_done_callback(_run_until_complete_cb)<br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-comment"># 事件循环开始运行</span><br>            self.run_forever()<br>        <span class="hljs-keyword">except</span>:<br>            <span class="hljs-keyword">if</span> new_task <span class="hljs-keyword">and</span> future.done() <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> future.cancelled():<br>                <span class="hljs-comment"># The coroutine raised a BaseException. Consume the exception</span><br>                <span class="hljs-comment"># to not log a warning, the caller doesn&#x27;t have access to the</span><br>                <span class="hljs-comment"># local task.</span><br>                future.exception()<br>            <span class="hljs-keyword">raise</span><br>        <span class="hljs-keyword">finally</span>:<br>            future.remove_done_callback(_run_until_complete_cb)<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> future.done():<br>            <span class="hljs-keyword">raise</span> RuntimeError(<span class="hljs-string">&#x27;Event loop stopped before Future completed.&#x27;</span>)<br><br>        <span class="hljs-keyword">return</span> future.result()<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run_forever</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-comment"># 进行一些初始化工作</span><br>        self._check_closed()<br>        self._check_running()<br>        self._set_coroutine_origin_tracking(self._debug)<br>        self._thread_id = threading.get_ident()<br><br>        old_agen_hooks = sys.get_asyncgen_hooks()<br>        <span class="hljs-comment"># 通过asyncgen钩子来自动关闭asyncgen函数，这样可以提醒用户生成器还未关闭</span><br>        sys.set_asyncgen_hooks(firstiter=self._asyncgen_firstiter_hook,<br>                               finalizer=self._asyncgen_finalizer_hook)<br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-comment"># 设置当前在运行的事件循环到全局变量中，这样就可以在任一阶段获取到当前的事件循环了</span><br>            events._set_running_loop(self)<br>            <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>                <span class="hljs-comment"># 正真执行任务的逻辑</span><br>                self._run_once()<br>                <span class="hljs-keyword">if</span> self._stopping:<br>                    <span class="hljs-keyword">break</span><br>        <span class="hljs-keyword">finally</span>:<br>            <span class="hljs-comment"># 关闭循环, 并且清理一些资源</span><br>            self._stopping = <span class="hljs-literal">False</span><br>            self._thread_id = <span class="hljs-literal">None</span><br>            events._set_running_loop(<span class="hljs-literal">None</span>)<br>            self._set_coroutine_origin_tracking(<span class="hljs-literal">False</span>)<br>            sys.set_asyncgen_hooks(*old_agen_hooks)<br></code></pre></td></tr></table></figure><p>这段源码并不复杂，它的主要逻辑是通过把<code>Corotinue</code>转为一个<code>Task</code>对象，然后通过<code>Task</code>对象初始化时调用<code>loop.call_sonn</code>方法把自己注册到<code>EventLoop</code>中，最后再通过<code>loop.run_forever</code>中的循环代码一直运行着，直到<code>_stopping</code>被标记为<code>True</code>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    <span class="hljs-comment"># 正真执行任务的逻辑</span><br>    self._run_once()<br>    <span class="hljs-keyword">if</span> self._stopping:<br>        <span class="hljs-keyword">break</span><br></code></pre></td></tr></table></figure><p>可以看出，这段代码是确保事件循环能一直执行着，自动循环结束，而真正调度的核心是<code>_run_once</code>函数，它的源码如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseEventLoop</span>:</span><br>    ...<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_run_once</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-comment"># self._scheduled是一个列表，它只存放TimerHandle</span><br>        sched_count = <span class="hljs-built_in">len</span>(self._scheduled)<br>        <span class="hljs-comment">###############################</span><br>        <span class="hljs-comment"># 第一阶段，整理self._scheduled #</span><br>        <span class="hljs-comment">###############################</span><br>        <span class="hljs-keyword">if</span> (sched_count &gt; _MIN_SCHEDULED_TIMER_HANDLES <span class="hljs-keyword">and</span><br>            self._timer_cancelled_count / sched_count &gt; _MIN_CANCELLED_TIMER_HANDLES_FRACTION):<br>            <span class="hljs-comment"># 当待调度的任务数量超过100且待取消的任务占总任务的50%时，才进入这个逻辑</span><br>            <span class="hljs-comment"># 把需要取消的任务移除</span><br>            new_scheduled = []<br>            <span class="hljs-keyword">for</span> handle <span class="hljs-keyword">in</span> self._scheduled:<br>                <span class="hljs-keyword">if</span> handle._cancelled:<br>                    <span class="hljs-comment"># 设置handle的_cancelled为True，并且把handle从_scheduled中移除</span><br>                    handle._scheduled = <span class="hljs-literal">False</span><br>                <span class="hljs-keyword">else</span>:<br>                    new_scheduled.append(handle)<br><br>            <span class="hljs-comment"># 重新排列堆</span><br>            heapq.heapify(new_scheduled)<br>            self._scheduled = new_scheduled<br>            self._timer_cancelled_count = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-comment"># 需要取消的handle不多，则只会走这个逻辑，这里会把堆顶的handle弹出，并标记为不可调度，但不会访问整个堆</span><br>            <span class="hljs-keyword">while</span> self._scheduled <span class="hljs-keyword">and</span> self._scheduled[<span class="hljs-number">0</span>]._cancelled:<br>                self._timer_cancelled_count -= <span class="hljs-number">1</span><br>                handle = heapq.heappop(self._scheduled)<br>                handle._scheduled = <span class="hljs-literal">False</span><br><br>        <span class="hljs-comment">#################################</span><br>        <span class="hljs-comment"># 第二阶段，计算超时值以及等待事件IO #</span><br>        <span class="hljs-comment">#################################</span><br>        timeout = <span class="hljs-literal">None</span><br>        <span class="hljs-comment"># 当有准备调度的handle或者是正在关闭时，不等待，方便尽快的调度</span><br>        <span class="hljs-keyword">if</span> self._ready <span class="hljs-keyword">or</span> self._stopping:<br>            timeout = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">elif</span> self._scheduled:<br>            <span class="hljs-comment"># Compute the desired timeout.</span><br>            <span class="hljs-comment"># 如果堆有数据时，通过堆顶的handle计算最短的超时时间，但是最多不能超过MAXIMUM_SELECT_TIMEOUT，以免超过系统限制</span><br>            when = self._scheduled[<span class="hljs-number">0</span>]._when<br>            timeout = <span class="hljs-built_in">min</span>(<span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, when - self.time()), MAXIMUM_SELECT_TIMEOUT)<br><br>        <span class="hljs-comment"># 事件循环等待事件，直到有事件或者超时</span><br>        event_list = self._selector.select(timeout)<br><br>        <span class="hljs-comment">##################################################</span><br>        <span class="hljs-comment"># 第三阶段，把满足条件的TimeHandle放入到self._ready中 #</span><br>        <span class="hljs-comment">##################################################</span><br>        <span class="hljs-comment"># 获取得到的事件的回调，然后装填到_ready</span><br>        self._process_events(event_list)<br><br>        <span class="hljs-comment"># 把一些在self._scheduled且满足调度条件的handle放到_ready中，比如TimerHandle。</span><br>        <span class="hljs-comment"># end_time为当前时间+一个时间单位，猜测是能多处理一些这段时间内产生的事件</span><br>        end_time = self.time() + self._clock_resolution<br>        <span class="hljs-keyword">while</span> self._scheduled:<br>            handle = self._scheduled[<span class="hljs-number">0</span>]<br>            <span class="hljs-keyword">if</span> handle._when &gt;= end_time:<br>                <span class="hljs-keyword">break</span><br>            handle = heapq.heappop(self._scheduled)<br>            handle._scheduled = <span class="hljs-literal">False</span><br>            self._ready.append(handle)<br><br>        <span class="hljs-comment">################################################################################</span><br>        <span class="hljs-comment"># 第四阶段，遍历所有准备调度的handle，并且通过handle的context来执行handle对应的callback #</span><br>        <span class="hljs-comment">################################################################################</span><br>        ntodo = <span class="hljs-built_in">len</span>(self._ready)<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(ntodo):<br>            handle = self._ready.popleft()<br>            <span class="hljs-comment"># 如果handle已经被取消，则不调用</span><br>            <span class="hljs-keyword">if</span> handle._cancelled:<br>                <span class="hljs-keyword">continue</span><br>            <span class="hljs-keyword">if</span> self._debug:<br>                <span class="hljs-keyword">try</span>:<br>                    self._current_handle = handle<br>                    t0 = self.time()<br>                    handle._run()<br>                    dt = self.time() - t0<br>                    <span class="hljs-keyword">if</span> dt &gt;= self.slow_callback_duration:<br>                        <span class="hljs-comment"># 执行太久的回调，记录下来，这些需要开发者自己优化</span><br>                        logger.warning(<span class="hljs-string">&#x27;Executing %s took %.3f seconds&#x27;</span>,<br>                                       _format_handle(handle), dt)<br>                <span class="hljs-keyword">finally</span>:<br>                    self._current_handle = <span class="hljs-literal">None</span><br>            <span class="hljs-keyword">else</span>:<br>                handle._run()<br>        handle = <span class="hljs-literal">None</span>  <span class="hljs-comment"># Needed to break cycles when an exception occurs.</span><br></code></pre></td></tr></table></figure><p>通过源码分析，可以很明确的知道调度逻辑中第一步是先规整<code>self._scheduled</code>，在规整的过程是使用堆排序来进行的，因为堆排序在调度的场景下效率是非常高的，不过这段规整代码分成两种，我猜测是当需要取消的数量过多时直接遍历的效率会更高。<br>在规整<code>self._scheduled</code>后，就进入第二步，该步骤开始等待系统事件循环返回对应的事件，如果<code>self._ready</code>中有数据，就不做等待了，需要马上到下一步骤，以便能赶紧安排调度。<br>在得到系统事件循环得到的事件后，就进入到了第三步，该步骤会通过<code>self._process_events</code>方法处理对应的事件，并把事件对应的回调存放到了<code>self._ready</code>中，最后再遍历<code>self._ready</code>中的所有<code>Handle</code>并逐一执行(执行时可以认为<code>EventLoop</code>把控制权返回给对应的调用逻辑)，至此一个完整的调度逻辑就结束了，并进入下一个调度逻辑。</p><h2 id="3-网络IO事件的处理"><a href="#3-网络IO事件的处理" class="headerlink" title="3.网络IO事件的处理"></a>3.网络IO事件的处理</h2><blockquote><p>注：由于系统事件循环的限制，所以文件IO一般还是使用多线程来执行，具体见：<a href="https://github.com/python/asyncio/wiki/ThirdParty#filesystem">https://github.com/python/asyncio/wiki/ThirdParty#filesystem</a></p></blockquote><p>在分析<code>EventLoop</code>调度实现的时候忽略了<code>self._process_events</code>的具体实现逻辑，因为<code>_process_events</code>方法所在<code>asyncio.base_event.py</code>文件中的<code>BaseEventLoop</code>类并未有具体实现的，因为网络IO相关的需要系统的事件循环来帮忙处理，所以与系统事件循环相关的逻辑都在<code>asyncio.selector_events.py</code>中的<code>BaseSelectorEventLoop</code>类中。<code>BaseSelectorEventLoop</code>类封装了<code>selector</code>模块与系统事件循环交互，使调用者不需要去考虑sock的创建以及sock产生的文件描述符的监听与注销等操作，下面以<code>BaseSelectorEventLoop</code>中自带的pipe为例子，分析<code>BaseSelectorEventLoop</code>是如何进行网络IO事件处理的。</p><p>在分析之前，先看一个例子，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> asyncio<br><span class="hljs-keyword">import</span> threading<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">task</span>():</span><br>    print(<span class="hljs-string">&quot;task&quot;</span>)<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run_loop_inside_thread</span>(<span class="hljs-params">loop</span>):</span><br>    loop.run_forever()<br><br><br>loop = asyncio.get_event_loop()<br>threading.Thread(target=run_loop_inside_thread, args=(loop,)).start()<br>loop.call_soon(task)<br></code></pre></td></tr></table></figure><p>如果直接运行这个例子，它并不会输出<code>task</code>（不过在IDE使用DEBUG模式下线程启动会慢一点，所以会输出的），因为在调用<code>loop.run_forever</code>后<code>EventLoop</code>会一直卡在这段逻辑中:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Python">event_list = self._selector.select(timeout)<br></code></pre></td></tr></table></figure><p>所以调用<code>loop.call_soon</code>并不会使<code>EventLoop</code>马上安排调度，而如果把<code>call_soon</code>换成<code>call_soon_threadsafe</code>则可以正常输出，这是因为<code>call_soon_threadsafe</code>中多了一个<code>self._write_to_self</code>的调用，它的源码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseEventLoop</span>:</span><br>    ...<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">call_soon_threadsafe</span>(<span class="hljs-params">self, callback, *args, context=<span class="hljs-literal">None</span></span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;Like call_soon(), but thread-safe.&quot;&quot;&quot;</span><br>        self._check_closed()<br>        handle = self._call_soon(callback, args, context)<br>        self._write_to_self()<br>        <span class="hljs-keyword">return</span> handle<br></code></pre></td></tr></table></figure><p>由于这个调用是涉及到IO相关的，所以需要到<code>BaseSelectorEventLoop</code>类查看，接下来以pipe相关的网络IO操作来分析<code>EventLoop</code>是如何处理IO事件的(只演示reader对象，writer对象操作与reader类似)，对应的源码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseSelectorEventLoop</span>(<span class="hljs-params">base_events.BaseEventLoop</span>):</span><br><br>    <span class="hljs-comment">#######</span><br>    <span class="hljs-comment"># 创建 #</span><br>    <span class="hljs-comment">#######</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, selector=<span class="hljs-literal">None</span></span>):</span><br>        <span class="hljs-built_in">super</span>().__init__()<br><br>        <span class="hljs-keyword">if</span> selector <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-comment"># 获取最优的selector</span><br>            selector = selectors.DefaultSelector()<br>        self._selector = selector<br>        <span class="hljs-comment"># 创建pipe</span><br>        self._make_self_pipe()<br>        self._transports = weakref.WeakValueDictionary()<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_make_self_pipe</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-comment"># 创建Pipe对应的sock </span><br>        self._ssock, self._csock = socket.socketpair()<br>        <span class="hljs-comment"># 设置sock为非阻塞</span><br>        self._ssock.setblocking(<span class="hljs-literal">False</span>)<br>        self._csock.setblocking(<span class="hljs-literal">False</span>)<br>        self._internal_fds += <span class="hljs-number">1</span><br>        <span class="hljs-comment"># 阻塞服务端sock读事件对应的回调</span><br>        self._add_reader(self._ssock.fileno(), self._read_from_self)<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_add_reader</span>(<span class="hljs-params">self, fd, callback, *args</span>):</span><br>        <span class="hljs-comment"># 检查事件循环是否关闭</span><br>        self._check_closed()<br>        <span class="hljs-comment"># 封装回调为handle对象</span><br>        handle = events.Handle(callback, args, self, <span class="hljs-literal">None</span>)<br>        <span class="hljs-keyword">try</span>:<br>            key = self._selector.get_key(fd)<br>        <span class="hljs-keyword">except</span> KeyError:<br>            <span class="hljs-comment"># 如果没有注册到系统的事件循环，则注册</span><br>            self._selector.register(fd, selectors.EVENT_READ,<br>                                    (handle, <span class="hljs-literal">None</span>))<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-comment"># 如果已经注册过，则更新</span><br>            mask, (reader, writer) = key.events, key.data<br>            self._selector.modify(fd, mask | selectors.EVENT_READ,<br>                                  (handle, writer))<br>            <span class="hljs-keyword">if</span> reader <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>                reader.cancel()<br>        <span class="hljs-keyword">return</span> handle<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_read_from_self</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-comment"># 负责消费sock数据</span><br>        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>            <span class="hljs-keyword">try</span>:<br>                data = self._ssock.recv(<span class="hljs-number">4096</span>)<br>                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> data:<br>                    <span class="hljs-keyword">break</span><br>                self._process_self_data(data)<br>            <span class="hljs-keyword">except</span> InterruptedError:<br>                <span class="hljs-keyword">continue</span><br>            <span class="hljs-keyword">except</span> BlockingIOError:<br>                <span class="hljs-keyword">break</span><br><br>    <span class="hljs-comment">#######</span><br>    <span class="hljs-comment"># 删除 #</span><br>    <span class="hljs-comment">#######</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_close_self_pipe</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-comment"># 注销Pipe对应的描述符 </span><br>        self._remove_reader(self._ssock.fileno())<br>        <span class="hljs-comment"># 关闭sock</span><br>        self._ssock.close()<br>        self._ssock = <span class="hljs-literal">None</span><br>        self._csock.close()<br>        self._csock = <span class="hljs-literal">None</span><br>        self._internal_fds -= <span class="hljs-number">1</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_remove_reader</span>(<span class="hljs-params">self, fd</span>):</span><br>        <span class="hljs-comment"># 如果事件循环已经关闭了，就不用操作了</span><br>        <span class="hljs-keyword">if</span> self.is_closed():<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-comment"># 查询文件描述符是否在selector中</span><br>            key = self._selector.get_key(fd)<br>        <span class="hljs-keyword">except</span> KeyError:<br>            <span class="hljs-comment"># 不存在则返回</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-comment"># 存在则进入移除的工作</span><br>            mask, (reader, writer) = key.events, key.data<br>            <span class="hljs-comment"># 通过事件掩码判断是否有其它事件</span><br>            mask &amp;= ~selectors.EVENT_READ<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> mask:<br>                <span class="hljs-comment"># 移除已经注册到selector的文件描述符</span><br>                self._selector.unregister(fd)<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-comment"># 移除已经注册到selector的文件描述符，并注册新的事件</span><br>                self._selector.modify(fd, mask, (<span class="hljs-literal">None</span>, writer))<br><br>            <span class="hljs-comment"># 如果reader不为空，则取消reader</span><br>            <span class="hljs-keyword">if</span> reader <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>                reader.cancel()<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><p>通过源码中的创建部分可以看到，<code>EventLoop</code>在启动的时候会创建一对建立通信的sock，并设置为非阻塞，然后把对应的回调封装成一个<code>Handle</code>对象并注册到系统事件循环中（删除则进行对应的反向操作），之后系统事件循环就会一直监听对应的事件，也就是<code>EventLoop</code>的执行逻辑会阻塞在下面的调用中，等待事件响应：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Python">event_list = self._selector.select(timeout)<br></code></pre></td></tr></table></figure><p>这时如果执行<code>loop.call_soon_threadsafe</code>，那么会通过<code>write_to_self</code>写入一点信息：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_write_to_self</span>(<span class="hljs-params">self</span>):</span><br>    csock = self._csock<br>    <span class="hljs-keyword">if</span> csock <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>        <span class="hljs-keyword">return</span><br><br>    <span class="hljs-keyword">try</span>:<br>        csock.send(<span class="hljs-string">b&#x27;\0&#x27;</span>)<br>    <span class="hljs-keyword">except</span> OSError:<br>        <span class="hljs-keyword">if</span> self._debug:<br>            logger.debug(<span class="hljs-string">&quot;Fail to write a null byte into the self-pipe socket&quot;</span>, exc_info=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure><p>由于<code>csock</code>被写入了数据，那么它对应的<code>ssock</code>就会收到一个读事件，系统事件循环在收到这个事件通知后就会把数据返回，然后<code>EventLoop</code>就会获得到对应的数据，并交给<code>process_events</code>方法进行处理，它的相关代码如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseSelectorEventLoop</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_process_events</span>(<span class="hljs-params">self, event_list</span>):</span><br>        <span class="hljs-keyword">for</span> key, mask <span class="hljs-keyword">in</span> event_list:<br>            <span class="hljs-comment"># 从回调事件中获取到对应的数据，key.data在注册时是一个元祖，所以这里要对元祖进行解包</span><br>            fileobj, (reader, writer) = key.fileobj, key.data<br>            <span class="hljs-keyword">if</span> mask &amp; selectors.EVENT_READ <span class="hljs-keyword">and</span> reader <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>                <span class="hljs-comment"># 得到reader handle，如果是被标记为取消，就移除对应的文件描述符</span><br>                <span class="hljs-keyword">if</span> reader._cancelled:<br>                    self._remove_reader(fileobj)<br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-comment"># 如果没被标记为取消，则安排到self._ready中</span><br>                    self._add_callback(reader)<br>            <span class="hljs-keyword">if</span> mask &amp; selectors.EVENT_WRITE <span class="hljs-keyword">and</span> writer <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>                <span class="hljs-comment"># 对于写对象，也是同样的道理。</span><br>                <span class="hljs-keyword">if</span> writer._cancelled:<br>                    self._remove_writer(fileobj)<br>                <span class="hljs-keyword">else</span>:<br>                    self._add_callback(writer)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_add_callback</span>(<span class="hljs-params">self, handle</span>):</span><br>        <span class="hljs-comment"># 把回调的handle添加到_ready中</span><br>        <span class="hljs-keyword">assert</span> <span class="hljs-built_in">isinstance</span>(handle, events.Handle), <span class="hljs-string">&#x27;A Handle is required here&#x27;</span><br>        <span class="hljs-keyword">if</span> handle._cancelled:<br>            <span class="hljs-keyword">return</span><br>        <span class="hljs-keyword">assert</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">isinstance</span>(handle, events.TimerHandle)<br>        self._ready.append(handle)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_remove_reader</span>(<span class="hljs-params">self, fd</span>):</span><br>        <span class="hljs-comment"># 如果事件循环已经关闭了，就不用操作了</span><br>        <span class="hljs-keyword">if</span> self.is_closed():<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-comment"># 查询文件描述符是否在selector中</span><br>            key = self._selector.get_key(fd)<br>        <span class="hljs-keyword">except</span> KeyError:<br>            <span class="hljs-comment"># 不存在则返回</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-comment"># 存在则进入移除的工作</span><br>            mask, (reader, writer) = key.events, key.data<br>            mask &amp;= ~selectors.EVENT_READ<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> mask:<br>                <span class="hljs-comment"># 移除已经注册到selector的文件描述符</span><br>                self._selector.unregister(fd)<br>            <span class="hljs-keyword">else</span>:<br>                self._selector.modify(fd, mask, (<span class="hljs-literal">None</span>, writer))<br><br>            <span class="hljs-keyword">if</span> reader <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>                reader.cancel()<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><p>从代码中可以看出<code>_process_events</code>会对事件对应的文件描述符进行处理，并从事件回调中获取到对应的<code>Handle</code>对象添加到<code>self._ready</code>中，由<code>EventLoop</code>在接下来遍历<code>self._ready</code>并执行。</p><p>可以看到网络IO事件的处理并不复杂，因为系统事件循环已经为我们做了很多工作了，但是用户所有与网络IO相关的操作都需要有一个类似的操作，这样是非常的繁琐的，幸好<code>asyncio</code>库已经为我们做了封装，我们只要调用就可以了，方便了很多。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前记&quot;&gt;&lt;a href=&quot;#前记&quot; class=&quot;headerlink&quot; title=&quot;前记&quot;&gt;&lt;/a&gt;前记&lt;/h2&gt;&lt;p&gt;在文章&lt;a href=&quot;https://so1n.me/2022/04/11/python&#39;s_waitable_objects_in_asyncio/&quot;&gt;《Python的可等待对象在Asyncio的作用》&lt;/a&gt;中介绍了&lt;code&gt;Python&lt;/code&gt;的可等待对象作用，特别是&lt;code&gt;Task&lt;/code&gt;对象在启动的时候可以自我驱动，但是一个&lt;code&gt;Task&lt;/code&gt;对象只能驱动一条执行链，如果要多条链执行（并发），还是需要&lt;code&gt;EventLoop&lt;/code&gt;来安排驱动，接下来将通过&lt;code&gt;Python.Asyncio&lt;/code&gt;库的源码来了解&lt;code&gt;EventLoop&lt;/code&gt;是如何运作的。&lt;/p&gt;</summary>
    
    
    <content src="https://fastly.jsdelivr.net/gh/so1n/so1n_blog_photo@master/blog_photo/16550442517731649661119526images.png" type="image"/>
    
    
    <category term="Python Asyncio" scheme="http://so1n.me/categories/Python-Asyncio/"/>
    
    
    <category term="Python" scheme="http://so1n.me/tags/Python/"/>
    
    <category term="Asyncio" scheme="http://so1n.me/tags/Asyncio/"/>
    
  </entry>
  
  <entry>
    <title>Python-gRPC实践(6)--编写gRPC网关</title>
    <link href="http://so1n.me/2022/05/23/Python-gRPC%E5%AE%9E%E8%B7%B5(6)--%E7%BC%96%E5%86%99gRPC%E7%BD%91%E5%85%B3%20copy/"/>
    <id>http://so1n.me/2022/05/23/Python-gRPC%E5%AE%9E%E8%B7%B5(6)--%E7%BC%96%E5%86%99gRPC%E7%BD%91%E5%85%B3%20copy/</id>
    <published>2022-05-23T12:35:24.000Z</published>
    <updated>2022-06-24T11:27:05.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>就目前而言，在大多数场景中，用户侧的客户端和服务端还是通过HTTP进行交互，然后服务端内部各种服务再通过过各种协议进行交互，所以在采用了gRPC做内部服务的交互协议后，就需要一个网关来把gRPC的调用自动映射到HTTP应用上，方便客户端调用。</p><blockquote><p>注：本文只针对一对一的gRPC服务。</p><p>之前原本想当做一个简单的实现，后面发现可以与我编写的<a href="https://github.com/so1n/pait">pait</a>框架可以嵌到一起，这样也可以对多个Web框架提供Gateway功能，于是就把这个功能的实现嵌入到<a href="https://github.com/so1n/pait">pait</a>框架中，所以下面有些代码来自于我编写的<a href="https://github.com/so1n/pait">pait</a>框架，对应的gRPC网关文档使用说明见:<a href="https://so1n.me/pait-zh-doc/7_gRPC_gateway/">Pait gRPC Gateway</a></p></blockquote><h2 id="1-网关的基础实现思路"><a href="#1-网关的基础实现思路" class="headerlink" title="1.网关的基础实现思路"></a>1.网关的基础实现思路</h2><p>网关的思路很简单，就是把HTTP请求转发到了对应的gRPC服务，在<code>Go</code>生态中，已经出现了一个类似的框架–<a href="https://github.com/grpc-ecosystem/grpc-gateway">grpc-gateway</a>，它负责grpc服务自动的映射到HTTP服务中，同时它通过让HTTP服务和gRPC服务监听同一个端口来降低使用者的疑惑。</p><p>通过前面的文章我们了解到，gRPC采用的是HTTP/2做传输协议，而HTTP/2是对于HTTP/1.1的一个升级，这样的话服务端在接收socket的数据且转为HTTP数据后就可以判断Header中<code>Upgrade</code>字段对应的值来把数据分别分发到HTTP服务和gRPC服务。</p><p>但是，<code>Python</code>的gRPC是通过gRPC-C转译的，也就是它的底层是C实现的，所以<code>Python</code>的gRPC无法传socket来启动服务，而是只能通过指定ip:port的形式来启动服务，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> grpc<br><span class="hljs-keyword">from</span> concurrent <span class="hljs-keyword">import</span> futures<br><br>grpc.server(<br>    futures.ThreadPoolExecutor(max_workers=<span class="hljs-number">10</span>),<br>).add_insecure_port(<span class="hljs-string">&quot;127.0.0.1:9000&quot;</span>)<br></code></pre></td></tr></table></figure><p>这样上述的做法就无法实现了，只能让HTTP服务和gRPC服务分别监听不同的端口，无法做到像<a href="https://github.com/grpc-ecosystem/grpc-gateway">Go grpc-gateway</a>那样，毕竟Go才是亲儿子。</p><p>最终只能以下面的方式实现：<br><img   class="lazyload" data-original="https://cdn.jsdelivr.net/gh/so1n/so1n_blog_photo@master/blog_photo/1653363969391gRPC-Gateway.jpg" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" ><br>图中客户端发起的请求会先发送到HTTP服务绑定的端口，HTTP服务收到请求后，会转发到gRPC客户端，交由gRPC客户端发送到gRPC服务端，这样一系列服务就串起来了。</p><blockquote><p>图中的示例HTTP服务与gRPC客户端在同一个进程，而gRPC服务在同台机器的另外一个进程，但是他们也可以在同一个进程内。</p></blockquote><h2 id="2-如何编写转发路由"><a href="#2-如何编写转发路由" class="headerlink" title="2.如何编写转发路由"></a>2.如何编写转发路由</h2><p>总体思路决定后，就开始细究路由的实现了，路由只负责转发，不做其它功能，通过前面文章<a href="https://so1n.me/2022/01/05/Python-gRPC%E5%AE%9E%E8%B7%B5(1)--%E7%AE%80%E4%BB%8B/">Python-gRPC实践（1）–gRPC简介</a>的捉包可以知道，gRPC传输数据时，采用的是HTTP/2来传输请求，用的是POST方法，同时使用Body传输数据，那么我们可以采用尽量相似的方法来接收请求，再通过gRPC客户端传到对应的服务端，如下的Proto文件:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs proto">syntax &#x3D; &quot;proto3&quot;;<br>package example;<br><br><br>message LoginUserRequest &#123;<br>  string uid &#x3D; 1;<br>  string password &#x3D; 2;<br>&#125;<br>message LoginUserResult &#123;<br>  string uid &#x3D; 1;<br>  string user_name &#x3D; 2;<br>  string token &#x3D; 3;<br>&#125;<br><br><br>service User &#123;<br>    rpc login_user(LoginUserRequest) returns (LoginUserResult);<br>&#125;<br></code></pre></td></tr></table></figure><p>接着，以这种方法来创建一个路由来映射这个Proto文件的请求，这个路由采用POST方法然后解析对应的数据并通过对应的gRPC客户端传递到服务端，为了尽量的跟gRPC一致，所以HTTP服务与客户端通过Json进行交互，映射的路由代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> grpc<br><span class="hljs-keyword">from</span> starlette.applications <span class="hljs-keyword">import</span> Starlette<br><span class="hljs-keyword">from</span> starlette.routing <span class="hljs-keyword">import</span> Route<br><span class="hljs-keyword">from</span> starlette.requests <span class="hljs-keyword">import</span> Request<br><span class="hljs-keyword">from</span> starlette.responses <span class="hljs-keyword">import</span> JSONResponse<br><br><span class="hljs-comment"># pait项目的演示代码，由Proto文件生产的</span><br><span class="hljs-keyword">from</span> example.example_grpc.python_example_proto_code.example_proto.user <span class="hljs-keyword">import</span> user_pb2<br><span class="hljs-keyword">from</span> example.example_grpc.python_example_proto_code.example_proto.user <span class="hljs-keyword">import</span> user_pb2_grpc<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">login_route</span>(<span class="hljs-params">request: Request</span>) -&gt; JSONResponse:</span><br>    <span class="hljs-comment"># 接收请求</span><br>    request_dict: <span class="hljs-built_in">dict</span> = <span class="hljs-keyword">await</span> request.json()<br>    user_service: user_pb2_grpc.UserStub = request.app.state.user_service<br>    <span class="hljs-comment"># 发送请求到对应的gRPC服务端</span><br>    result: user_pb2.LoginUserResult = user_service.login_user(<br>        user_pb2.LoginUserRequest(uid=request_dict[<span class="hljs-string">&quot;uid&quot;</span>], password=request_dict[<span class="hljs-string">&quot;password&quot;</span>])<br>    )<br>    <span class="hljs-comment"># 返回对应的响应</span><br>    <span class="hljs-keyword">return</span> JSONResponse(<br>        &#123;<br>            <span class="hljs-string">&quot;uid&quot;</span>: result.uid,<br>            <span class="hljs-string">&quot;user_name&quot;</span>: result.user_name,<br>            <span class="hljs-string">&quot;token&quot;</span>: result.token,<br>        &#125;<br>    )<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">create_app</span>() -&gt; Starlette:</span><br>    <span class="hljs-comment"># 绑定路由</span><br>    app: Starlette = Starlette(routes=[Route(<span class="hljs-string">&quot;/api/login&quot;</span>, login_route, methods=[<span class="hljs-string">&quot;POST&quot;</span>])])<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_before_server_start</span>() -&gt; <span class="hljs-keyword">None</span>:</span><br>        <span class="hljs-comment"># 启动时绑定gRPC客户端到对应的实例</span><br>        app.state.user_service = user_pb2_grpc.UserStub(grpc.aio.insecure_channel(<span class="hljs-string">&quot;0.0.0.0:9000&quot;</span>))<br>    <br>    app.add_event_handler(<span class="hljs-string">&quot;startup&quot;</span>, _before_server_start)<br>    <span class="hljs-keyword">return</span> app<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    <span class="hljs-keyword">import</span> uvicorn  <span class="hljs-comment"># type: ignore</span><br><br>    uvicorn.run(create_app(), log_level=<span class="hljs-string">&quot;debug&quot;</span>)<br></code></pre></td></tr></table></figure><p>这样一个简单的转发就编写完毕了，但是目前是手动编写的代码，意味着每新增一个接口，我们就需有编写一个对应的路由函数，同时如果Protobuf文件发生了变更，那么我们需要定位到对应的代码再修改，非常麻烦，特别是我们在定义Protobuf文件时，已经很像在定义一个接口了，结果还要再编写路由函数，效率非常低，所以一个网关最关键的是需要通过Protobuf文件或者通过Protobuf的产物来自动生成路由函数并映射到对应的服务，这样一来，其它使用者后续只要修改Protobuf文件即可。</p><h2 id="3-提取路由需要的数据"><a href="#3-提取路由需要的数据" class="headerlink" title="3.提取路由需要的数据"></a>3.提取路由需要的数据</h2><p>为了自动生成路由，还需要一些数据，通过编写的转发路由可以发现，我们只需要收到用户的请求，解析数据，然后通过对应的gRPC客户端方法来发送数据即可，所以需要通过这个gRPC客户端的方法来找到所有需要的数据（尝试了多种方法，目前这种是最优的）。</p><p>以上面的Protobuf文件自动生成的<code>Python</code>代码中的<code>user_pb2_grpc.UserStub</code>为例子(可以通过<a href="https://github.com/so1n/pait/tree/master/example/example_grpc">pait/example/example_grpc</a>了解)，它的代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> grpc<br><br><span class="hljs-keyword">from</span> example.example_grpc.python_example_proto_code.example_proto.user <span class="hljs-keyword">import</span> user_pb2 <span class="hljs-keyword">as</span> example__proto_dot_user_dot_user__pb2<br><span class="hljs-keyword">from</span> google.protobuf <span class="hljs-keyword">import</span> empty_pb2 <span class="hljs-keyword">as</span> google_dot_protobuf_dot_empty__pb2<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserStub</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, channel</span>):</span><br>        self.get_uid_by_token = channel.unary_unary(<br>                <span class="hljs-string">&#x27;/user.User/get_uid_by_token&#x27;</span>,<br>                request_serializer=example__proto_dot_user_dot_user__pb2.GetUidByTokenRequest.SerializeToString,<br>                response_deserializer=example__proto_dot_user_dot_user__pb2.GetUidByTokenResult.FromString,<br>                )<br>        self.logout_user = channel.unary_unary(<br>                <span class="hljs-string">&#x27;/user.User/logout_user&#x27;</span>,<br>                request_serializer=example__proto_dot_user_dot_user__pb2.LogoutUserRequest.SerializeToString,<br>                response_deserializer=google_dot_protobuf_dot_empty__pb2.Empty.FromString,<br>                )<br>        self.login_user = channel.unary_unary(<br>                <span class="hljs-string">&#x27;/user.User/login_user&#x27;</span>,<br>                request_serializer=example__proto_dot_user_dot_user__pb2.LoginUserRequest.SerializeToString,<br>                response_deserializer=example__proto_dot_user_dot_user__pb2.LoginUserResult.FromString,<br>                )<br>        self.create_user = channel.unary_unary(<br>                <span class="hljs-string">&#x27;/user.User/create_user&#x27;</span>,<br>                request_serializer=example__proto_dot_user_dot_user__pb2.CreateUserRequest.SerializeToString,<br>                response_deserializer=google_dot_protobuf_dot_empty__pb2.Empty.FromString,<br>                )<br>        self.delete_user = channel.unary_unary(<br>                <span class="hljs-string">&#x27;/user.User/delete_user&#x27;</span>,<br>                request_serializer=example__proto_dot_user_dot_user__pb2.DeleteUserRequest.SerializeToString,<br>                response_deserializer=google_dot_protobuf_dot_empty__pb2.Empty.FromString,<br>                )<br></code></pre></td></tr></table></figure><p>通过这份生成的代码可以发现，这个对象类中包括了每个调用的url，请求体和响应体，这样再加上上面说了gRPC是以POST方法进行请求的，那么构成一个最小路由的条件都已经满足了。<br>但是，要通过这份代码提取数据却比较麻烦，由于都是在<code>__init__</code>方法后才初始化各个gRPC的调用方法，所以没办法通过<code>dir(UserStub)</code>获取到对应的gRPC调用方法，只能通过<code>UserStub(channel).__dict__</code>来获取gRPC的调用方法，不过<code>channel</code>最好需要在对应的HTTP服务启动时再初始化，特别是对于uvicorn来说，如果grpc.aio.channel提前初始化，那么他们使用的不是同一个事件循环，这意味着就必须在Web实例启动后再注册路由，但由于<code>Sanic</code>等框架是不支持实例启动后再注册路由的，所以这个方法行不通。此外，示例代码中的请求体，响应体都是调用对应的方法再加载到<code>channel.unary_unary</code>中，之后我们没办法在运行时通过<code>UserStub</code>的实例来直接获取。</p><p>幸运的是，由Proto文件生成的<code>UserStub</code>对象是有规则的，所以可以在程序运行时获取到<code>UserStub</code>的源码，然后通过一定的规则把数据提取出来，分析上面的源码，可以发现有如下几个规则：</p><ul><li>1.<code>self.xxx</code>中是gRPC调用的方法名，同时<code>channel.unary_unary</code>代表了这是一对一的请求。</li><li>2.<code>self.xxx</code>的下面第一行是gRPC方法对应的url</li><li>3.<code>self.xxx</code>的下面第二行出现了gRPC方法的请求对象，这一行是以<code>request_serializer=</code>开头，以<code>.SerializeToString</code>结尾，可以通过正则提取中间的对象字符串，然后可以在运行时通过解析字符串从<code>UserStub</code>所在的模块中提取到正确的请求对象。</li><li>4.<code>self.xxx</code>的下面第三行则是gRPC方法的响应对象，处理方法跟请求对象类似。</li></ul><p>发现了规则后就可以通过规则提取对应的数据，具体代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> inspect<br><span class="hljs-keyword">import</span> re<br><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> Any, List, Generator, Optional, Type<br><span class="hljs-keyword">from</span> types <span class="hljs-keyword">import</span> ModuleType<br><span class="hljs-keyword">from</span> google.protobuf.message <span class="hljs-keyword">import</span> Message<br><br><span class="hljs-keyword">from</span> example.example_grpc.python_example_proto_code.example_proto.user <span class="hljs-keyword">import</span> user_pb2_grpc<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_gen_message</span>(<span class="hljs-params">class_module: ModuleType, line: <span class="hljs-built_in">str</span>, match_str: <span class="hljs-built_in">str</span></span>) -&gt; Type[Message]:</span><br>    <span class="hljs-comment"># 通过正则提取对应的字符串</span><br>    module_path_find_list = re.findall(match_str, line)<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(module_path_find_list) != <span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&quot;module path not found&quot;</span>)<br>    module_path: <span class="hljs-built_in">str</span> = module_path_find_list[<span class="hljs-number">0</span>]<br>    module_path_list: List[<span class="hljs-built_in">str</span>] = module_path.split(<span class="hljs-string">&quot;.&quot;</span>)<br>    <span class="hljs-comment"># 通过UserStub模块获取到消息体对应的模块</span><br>    message_module: ModuleType = <span class="hljs-built_in">getattr</span>(class_module, module_path_list[<span class="hljs-number">0</span>])<br>    <span class="hljs-comment"># 从模块提取到对应的对象</span><br>    message_model: Type[Message] = <span class="hljs-built_in">getattr</span>(message_module, module_path_list[<span class="hljs-number">1</span>])<br><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">issubclass</span>(message_model, Message):<br>        <span class="hljs-keyword">raise</span> RuntimeError(<span class="hljs-string">&quot;Can not found message&quot;</span>)<br>    <span class="hljs-keyword">return</span> message_model<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">parse</span>(<span class="hljs-params">stub: Any</span>) -&gt; Generator[tuple, <span class="hljs-keyword">None</span>, <span class="hljs-keyword">None</span>]:</span><br>    <span class="hljs-comment"># 提取对应对象的源码，以`\n`切分成每一行</span><br>    line_list: List[<span class="hljs-built_in">str</span>] = inspect.getsource(stub).split(<span class="hljs-string">&quot;\n&quot;</span>)<br><br>    <span class="hljs-comment"># 获取对象的模块，这样就能知道这个模块引用了什么包，方便后面提取请求和响应对象</span><br>    class_module: Optional[ModuleType] = inspect.getmodule(stub)<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> class_module:<br>        <span class="hljs-keyword">raise</span> RuntimeError(<span class="hljs-string">f&quot;Can not found <span class="hljs-subst">&#123;stub&#125;</span> module&quot;</span>)<br>    <span class="hljs-comment"># 通过enumerate，可以获取到行数对应的索引</span><br>    <span class="hljs-keyword">for</span> index, line <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(line_list):<br>        <span class="hljs-comment"># 不是self.所在的行，就跳过</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;self.&quot;</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> line:<br>            <span class="hljs-keyword">continue</span><br>        <span class="hljs-comment"># 只映射一对一的gRPC请求，其它gRPC请求则忽略</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;channel.unary_unary&quot;</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> line:<br>            <span class="hljs-keyword">continue</span><br><br>        <span class="hljs-comment"># 通过这一行提取gRPC调用端方法名</span><br>        invoke_name: <span class="hljs-built_in">str</span> = line.split(<span class="hljs-string">&quot;=&quot;</span>)[<span class="hljs-number">0</span>].replace(<span class="hljs-string">&quot;self.&quot;</span>, <span class="hljs-string">&quot;&quot;</span>).strip()<br>        <span class="hljs-comment"># 从下一行提取url</span><br>        method: <span class="hljs-built_in">str</span> = line_list[index + <span class="hljs-number">1</span>].strip()[<span class="hljs-number">1</span>:-<span class="hljs-number">2</span>]<br>        <span class="hljs-comment"># 从下两行提取请求对象</span><br>        request: Type[Message] = _gen_message(<br>            class_module, line_list[index + <span class="hljs-number">2</span>], <span class="hljs-string">r&quot;request_serializer=(.+).SerializeToString&quot;</span><br>        )<br>        <span class="hljs-comment"># 从下三行提取响应对象</span><br>        response: Type[Message] = _gen_message(<br>            class_module, line_list[index + <span class="hljs-number">3</span>], <span class="hljs-string">r&quot;response_deserializer=(.+).FromString&quot;</span><br>        )<br>        <span class="hljs-comment"># 返回提取的数据</span><br>        <span class="hljs-keyword">yield</span> invoke_name, method, request, response<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> parse(user_pb2_grpc.UserStub):<br>        print(i)<br><br><br></code></pre></td></tr></table></figure><p>这段代码执行后就会输出以下结果，可以发现，这段代码正常的从<code>UserStub</code>中提取到了我们想要的数据。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">(<span class="hljs-string">&#x27;get_uid_by_token&#x27;</span>, <span class="hljs-string">&#x27;/user.User/get_uid_by_token&#x27;</span>, &lt;class <span class="hljs-string">&#x27;example_proto.user.user_pb2.GetUidByTokenRequest&#x27;</span>&gt;, &lt;class <span class="hljs-string">&#x27;example_proto.user.user_pb2.GetUidByTokenResult&#x27;</span>&gt;)<br>(<span class="hljs-string">&#x27;logout_user&#x27;</span>, <span class="hljs-string">&#x27;/user.User/logout_user&#x27;</span>, &lt;class <span class="hljs-string">&#x27;example_proto.user.user_pb2.LogoutUserRequest&#x27;</span>&gt;, &lt;class <span class="hljs-string">&#x27;google.protobuf.empty_pb2.Empty&#x27;</span>&gt;)<br>(<span class="hljs-string">&#x27;login_user&#x27;</span>, <span class="hljs-string">&#x27;/user.User/login_user&#x27;</span>, &lt;class <span class="hljs-string">&#x27;example_proto.user.user_pb2.LoginUserRequest&#x27;</span>&gt;, &lt;class <span class="hljs-string">&#x27;example_proto.user.user_pb2.LoginUserResult&#x27;</span>&gt;)<br>(<span class="hljs-string">&#x27;create_user&#x27;</span>, <span class="hljs-string">&#x27;/user.User/create_user&#x27;</span>, &lt;class <span class="hljs-string">&#x27;example_proto.user.user_pb2.CreateUserRequest&#x27;</span>&gt;, &lt;class <span class="hljs-string">&#x27;google.protobuf.empty_pb2.Empty&#x27;</span>&gt;)<br>(<span class="hljs-string">&#x27;delete_user&#x27;</span>, <span class="hljs-string">&#x27;/user.User/delete_user&#x27;</span>, &lt;class <span class="hljs-string">&#x27;example_proto.user.user_pb2.DeleteUserRequest&#x27;</span>&gt;, &lt;class <span class="hljs-string">&#x27;google.protobuf.empty_pb2.Empty&#x27;</span>&gt;)<br></code></pre></td></tr></table></figure><p>不过这还不够，比如使用者可能想自定义这个请求映射的URL，或者是控制这个gRPC请求方法是否要映射等等，这些功能是无法通过Proto文件来控制的，如果写在另一个文件配置又非常麻烦，最后决定通过Proto文件的注释来实现这些功能，比如下面的Proto代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs proto">service User &#123;<br>  &#x2F;&#x2F; The interface should not be exposed for external use<br>  &#x2F;&#x2F; pait: &#123;&quot;enable&quot;: false&#125;<br>  rpc get_uid_by_token (GetUidByTokenRequest) returns (GetUidByTokenResult);<br>  &#x2F;&#x2F; pait: &#123;&quot;tag&quot;: [[&quot;grpc-user&quot;, &quot;grpc_user_service&quot;], [&quot;grpc-user-system&quot;, &quot;grpc_user_service&quot;]]&#125;<br>  &#x2F;&#x2F; pait: &#123;&quot;summary&quot;: &quot;Create users through the system&quot;, &quot;url&quot;: &quot;&#x2F;user&#x2F;create&quot;&#125;<br>  rpc create_user(CreateUserRequest) returns (google.protobuf.Empty);<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码有一个标准的<code>pait:</code>开头，这样在解析时，就可以知道这一行是需要解析的文本，然后就会去解析后面跟着的一串Json字符串，就可以知道<code>get_uid_by_token</code>设置了<code>enable</code>为<code>false</code>，而<code>create_user</code>设置了url为<code>/user/create</code>。不过，默认生成的代码中，客户端对象是没有携带Proto文件的注释信息的，只有他们对应的服务端对象才有携带，比如<code>UserStub</code>没有携带注释信息，而<code>UserStub</code>对应的<code>User</code>对象则携带，所以需要从<code>User</code>中提取数据。</p><p>此外，对于请求对象和响应对象也可以采用这样的思路，但是<code>Python</code>的gRPC库通过Proto文件生成<code>Python</code>代码时，Proto文件中为Message编写的注释是不会一起跟过来的，需要自己编写一个插件，或者通过<code>mypy-proto</code>插件生成的文件来获取。由于这部分的代码比较长且繁杂，这里只做简单说明，具体源码见<a href="https://github.com/so1n/pait/blob/master/pait/util/grpc_inspect/stub.py">pait.util.groc_inspect.stub.py</a></p><h2 id="4-自动映射路由"><a href="#4-自动映射路由" class="headerlink" title="4.自动映射路由"></a>4.自动映射路由</h2><p>至此，url，请求方法，请求体和响应体都获取到了，现在可以自动映射路由了，还是以<code>starlette</code>框架为例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> grpc<br><span class="hljs-keyword">from</span> starlette.applications <span class="hljs-keyword">import</span> Starlette<br><span class="hljs-keyword">from</span> starlette.requests <span class="hljs-keyword">import</span> Request<br><span class="hljs-keyword">from</span> starlette.responses <span class="hljs-keyword">import</span> JSONResponse<br><span class="hljs-keyword">from</span> google.protobuf.message <span class="hljs-keyword">import</span> Message<br><span class="hljs-keyword">from</span> google.protobuf.json_format <span class="hljs-keyword">import</span> MessageToDict<br><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> Any, Callable<br><br><span class="hljs-comment"># pait项目的演示代码，由Proto文件生产的</span><br><span class="hljs-keyword">from</span> example.example_grpc.python_example_proto_code.example_proto.user <span class="hljs-keyword">import</span> user_pb2<br><span class="hljs-keyword">from</span> example.example_grpc.python_example_proto_code.example_proto.user <span class="hljs-keyword">import</span> user_pb2_grpc<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">gen_route</span>(<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">    app: Starlette,</span></span><br><span class="hljs-function"><span class="hljs-params">    stub: Any,</span></span><br><span class="hljs-function"><span class="hljs-params">    url: <span class="hljs-built_in">str</span>,</span></span><br><span class="hljs-function"><span class="hljs-params">    invoke_name: <span class="hljs-built_in">str</span>,</span></span><br><span class="hljs-function"><span class="hljs-params">    grpc_request: Message,</span></span><br><span class="hljs-function"><span class="hljs-params">    grpc_response: Message,</span></span><br><span class="hljs-function"><span class="hljs-params"></span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    :param app: Starlette实例</span><br><span class="hljs-string">    :param stub: gRPC客户端对应的类</span><br><span class="hljs-string">    :param url: url</span><br><span class="hljs-string">    :param invoke_name: gRPC调用的方法名</span><br><span class="hljs-string">    :param grpc_request: gRPC请求体</span><br><span class="hljs-string">    :param grpc_response: gRPC响应体，可以发现它没有被使用</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_route</span>(<span class="hljs-params">request: Request</span>) -&gt; JSONResponse:</span><br>        resp_dict: <span class="hljs-built_in">dict</span> = <span class="hljs-keyword">await</span> request.json()<br>        <span class="hljs-comment"># 通过app实例携带的channel来调用gRPC服务</span><br>        func: Callable = <span class="hljs-built_in">getattr</span>(stub(app.state.channel), invoke_name)<br>        <span class="hljs-comment"># 把gRPC响应数据专为json响应</span><br>        <span class="hljs-keyword">return</span> JSONResponse(MessageToDict(<span class="hljs-keyword">await</span> func(grpc_request(**resp_dict))))<br><br>    <span class="hljs-comment"># 注册路由</span><br>    app.add_route(url, _route, methods=[<span class="hljs-string">&quot;POST&quot;</span>])<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">create_app</span>() -&gt; Starlette:</span><br>    <span class="hljs-comment"># 绑定路由</span><br>    app: Starlette = Starlette()<br><br>    <span class="hljs-comment"># 通过调用上面段parse函数得到了gRPC对应的数据再通过gen_route来自动注册路由</span><br>    <span class="hljs-keyword">for</span> parse_result_list <span class="hljs-keyword">in</span> parse(user_pb2_grpc.UserStub):<br>        gen_route(<br>            app,<br>            user_pb2_grpc.UserStub,<br>            *parse_result_list,<br>        )<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_before_server_start</span>() -&gt; <span class="hljs-keyword">None</span>:</span><br>        <span class="hljs-comment"># 启动时绑定gRPC客户端对应的channel</span><br>        app.state.channel = grpc.aio.insecure_channel(<span class="hljs-string">&quot;0.0.0.0:9000&quot;</span>)<br><br>    app.add_event_handler(<span class="hljs-string">&quot;startup&quot;</span>, _before_server_start)<br>    <span class="hljs-keyword">return</span> app<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    <span class="hljs-keyword">import</span> uvicorn  <span class="hljs-comment"># type: ignore</span><br><br>    uvicorn.run(create_app(), log_level=<span class="hljs-string">&quot;debug&quot;</span>)<br></code></pre></td></tr></table></figure><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5.总结"></a>5.总结</h2><p>至此，gRPC网关的最核心的实现已经编写完成了，不过可以发现gRPC的响应体并没有被使用，同时这个实现非常简单，不容易拓展，可以通过<a href="https://so1n.me/pait-zh-doc/7_gRPC_gateway/#6gateway-route">自定义Gateway Route路由函数</a>了解更多的拓展。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;就目前而言，在大多数场景中，用户侧的客户端和服务端还是通过HTTP进行交互，然后服务端内部各种服务再通过过各种协议进行交互，所以在采用了gR</summary>
      
    
    
    <content src="https://ftp.bmp.ovh/imgs/2022/02/bd67e15aa8d46101.png" type="image"/>
    
    
    <category term="Python-gRPC实践" scheme="http://so1n.me/categories/Python-gRPC%E5%AE%9E%E8%B7%B5/"/>
    
    
    <category term="Python" scheme="http://so1n.me/tags/Python/"/>
    
    <category term="gRPC" scheme="http://so1n.me/tags/gRPC/"/>
    
  </entry>
  
  <entry>
    <title>Python-gRPC实践(5)--简述gRPC的高级用法</title>
    <link href="http://so1n.me/2022/04/16/Python-gRPC%E5%AE%9E%E8%B7%B5(5)--%E7%AE%80%E8%BF%B0gRPC%E7%9A%84%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95/"/>
    <id>http://so1n.me/2022/04/16/Python-gRPC%E5%AE%9E%E8%B7%B5(5)--%E7%AE%80%E8%BF%B0gRPC%E7%9A%84%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95/</id>
    <published>2022-04-16T12:35:24.000Z</published>
    <updated>2022-04-20T15:57:59.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><a href="https://so1n.me/2022/04/07/Python-gRPC%E5%AE%9E%E8%B7%B5(3)--%E4%BD%BF%E7%94%A8Python%E5%AE%9E%E7%8E%B0gRPC%E6%9C%8D%E5%8A%A1/">Python-gRPC实践(3)–使用Python实现gRPC服务</a><br>讲述了如何编写和使用gRPC服务，而本文主要讲述一些业务之外的gRPC用法。</p><h2 id="1-优雅的重启服务"><a href="#1-优雅的重启服务" class="headerlink" title="1.优雅的重启服务"></a>1.优雅的重启服务</h2><p>线上运行的服务永远都不会一尘不变的，特别是对于微服务，服务的更新频率越来越快，需要重启的次数也就变多了，而每次重启都会导致服务正在处理的请求被强行关闭，所以我们需要优雅的重启服务，确保在滚动更新服务的时候不会影响到客户端，好在gRPC自带了一个类似的功能，代码例子如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">from</span> signal <span class="hljs-keyword">import</span> signal, SIGTERM<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">serve</span>():</span><br>    <span class="hljs-comment"># 启动端口配置，默认为启用</span><br>    options = [(<span class="hljs-string">&quot;grpc.so_reuseport&quot;</span>, <span class="hljs-number">1</span>)]<br>    <span class="hljs-comment"># 正常的运行服务</span><br>    server = grpc.server(futures.ThreadPoolExecutor(max_workers=<span class="hljs-number">10</span>), options=options)<br>    ...<br>    server.add_insecure_port(<span class="hljs-string">&quot;0.0.0.0:9000&quot;</span>)<br>    server.start()<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sig_handle</span>(<span class="hljs-params">*args</span>):</span><br>        <span class="hljs-comment"># 调用server.stop函数，调用stop(30)后，该服务会拒绝客户端新的请求，并返回一个threading.Event</span><br>        event = server.stop(<span class="hljs-number">30</span>)<br>        <span class="hljs-comment"># 调用event.wait()后，服务会一直等着，直到30秒后服务才会关闭，关闭之前服务还是能正常处理请求</span><br>        event.wait()<br>    <br>    <span class="hljs-comment"># 接收一个SIGTERM信号的注册</span><br>    signal(SIGTERM, sig_handle)<br>    <span class="hljs-comment"># 等待服务停止</span><br>    server.wait_for_termination()<br></code></pre></td></tr></table></figure><p>这个代码假设gRPC服务以端口复用模式运行(默认启用), 代码通过加上<code>SIGTERM</code>信号的对应回调后，我们的更新服务的逻辑就可以进行一些调整。首先是运行一个全新的gRPC服务在9000端口，这时候请求会分流到新和旧的gRPC服务，然后我们主动向旧的服务进程发送<code>SIGTERM</code>信号，这时旧服务就能开始拒绝新的请求，请求只会流向新的gRPC服务，之后我们只需要等服务自动关闭即可。</p><p>不过光这种方法还是不够，还需要注册中心等，具体实现逻辑可以通过<a href="https://so1n.me/2021/08/28/RPC%E6%A1%86%E6%9E%B6%E7%BC%96%E5%86%99%E5%AE%9E%E8%B7%B5--%E4%BC%98%E9%9B%85%E7%9A%84%E9%87%8D%E5%90%AF/">RPC框架编写实践–服务的优雅的重启</a>了解。</p><blockquote><p>代码中的options是用于配置gRPC服务的一些功能，可以从gRPC c源码中获悉<a href="https://github.com/grpc/grpc/blob/v1.38.x/include/grpc/impl/codegen/grpc_types.h">grpc_types.h</a>,也可以通过代码生成的页面获取比较容易看到的<a href="https://grpc.github.io/grpc/core/group__grpc__arg__keys.html#gaa3f69f6e1e789e36d2d9c6083fec0257">说明文档</a>。此外还有一些配置是需要传入一个Dict对象，可以参考<a href="https://github.com/grpc/grpc-proto/blob/master/grpc/service_config/service_config.proto">service_config.proto</a></p></blockquote><blockquote><p>更多优雅的重启说明见<a href="https://github.com/grpc/proposal/blob/master/L54-python-server-wait.md">gRPC Python Server Wait API</a></p></blockquote><h2 id="2-重试机制"><a href="#2-重试机制" class="headerlink" title="2.重试机制"></a>2.重试机制</h2><p>gRPC服务是通过网络来传输请求的，所以可能会因为网络波动等原因造成请求失败，这时候就需要重试机制来使请求能成功通信了，但是引入重试机制后可能会带来一些负面的问题：</p><ul><li>比如服务端已经扛不住了，而客户端还一直重试，造成持续的增加服务端压力</li><li>接口不是幂等，某个请求实际上已经处理完了，但是由于网络问题导致客户端认为服务端返回了错误，从而客户端进行了重试，最后导致服务端又再次处理请求，导致对应的数据发生了改变。</li></ul><p>于是，gRPC抽象出一套重试机制，使用户可以灵活为自己想要的方法应用对应的重试机制，这个重试机制包括的最大重试次数，指数退避，可重试状态码等等，比如下面的代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BookGrpcService</span>(<span class="hljs-params">BookSocialGrpcServiceMixin, BookManagerGrpcServiceMixin</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, host: <span class="hljs-built_in">str</span>, port: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        service_config_json = json.dumps(&#123;<br>            <span class="hljs-string">&quot;methodConfig&quot;</span>: [&#123;<br>                <span class="hljs-string">&quot;name&quot;</span>: [<br>                    &#123;<br>                        <span class="hljs-string">&quot;service&quot;</span>: <span class="hljs-string">&quot;book_manager.BookManager&quot;</span>,<br>                        <span class="hljs-string">&quot;method&quot;</span>: <span class="hljs-string">&quot;create_book&quot;</span><br>                    &#125;,<br>                    &#123;<br>                        <span class="hljs-string">&quot;service&quot;</span>: <span class="hljs-string">&quot;book_manager.BookManager&quot;</span>,<br>                        <span class="hljs-string">&quot;method&quot;</span>: <span class="hljs-string">&quot;delete_book&quot;</span><br>                    &#125;,<br>                ],<br>                <span class="hljs-string">&quot;retryPolicy&quot;</span>: &#123;<br>                    <span class="hljs-string">&quot;maxAttempts&quot;</span>: <span class="hljs-number">5</span>,<br>                    <span class="hljs-string">&quot;initialBackoff&quot;</span>: <span class="hljs-string">&quot;0.1s&quot;</span>,<br>                    <span class="hljs-string">&quot;maxBackoff&quot;</span>: <span class="hljs-string">&quot;1s&quot;</span>,<br>                    <span class="hljs-string">&quot;backoffMultiplier&quot;</span>: <span class="hljs-number">2</span>,<br>                    <span class="hljs-string">&quot;retryableStatusCodes&quot;</span>: [<span class="hljs-string">&quot;UNAVAILABLE&quot;</span>],<br>                &#125;,<br>            &#125;]<br>        &#125;)<br>        options = []<br>        <span class="hljs-comment"># <span class="hljs-doctag">NOTE:</span> 启动重试模式， 默认在v1.40.0后自动启用</span><br>        options.append((<span class="hljs-string">&quot;grpc.enable_retries&quot;</span>, <span class="hljs-number">1</span>))<br>        <span class="hljs-comment"># 重试的一些参数配置</span><br>        options.append((<span class="hljs-string">&quot;grpc.service_config&quot;</span>, service_config_json))<br><br><br>        self.channel: grpc.Channel = grpc.intercept_channel(<br>            grpc.insecure_channel(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;host&#125;</span>:<span class="hljs-subst">&#123;port&#125;</span>&quot;</span>), CustomerTopInterceptor(), options=options<br>        )<br>        BookSocialGrpcServiceMixin.__init__(self, self.channel)<br>        BookManagerGrpcServiceMixin.__init__(self, self.channel)<br></code></pre></td></tr></table></figure><p>该代码复制于<a href="https://github.com/so1n/grpc-example-api-backend-service/blob/part-1/grpc_service/book_service.py#L68">grpc-example-api-backend-service</a>，并进行一点拓展，可以看到在调用<code>grpc.intercept_channel</code>进行初始化时，传入了一个options参数，这样在创建channel时会自动应用到对应的配置。</p><p>这个配置中，<code>grpc.enable_retries</code>为1代表启用了重试，而<code>grpc.service_config</code>接收到的是一个服务配置方法，具体可以访问<a href="https://github.com/grpc/grpc-proto/blob/ec886024c2f7b7f597ba89d5b7d60c3f94627b17/grpc/service_config/service_config.proto#L38">service_config.proto</a>了解，不过需要注意的是，在传入<code>grpc.service_config</code>时，传的是一个Dict的对应json序列化字符串。</p><p>接下来就在<code>grpc.service_config</code>的<code>methodConfig</code>中，我们传入了一个数组，这个数组里面只有一个Dict，这个Dict通过<code>name</code>指定了只有<code>book_manager.BookManager</code>的<code>create_book</code>方法和<code>delete_book</code>方法会应用到重试的规则，如果这个配置为:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>    <span class="hljs-attr">&quot;methodConfig&quot;</span>: [&#123;<br>        <span class="hljs-attr">&quot;name&quot;</span>: [&#123;&#125;],<br>        <span class="hljs-attr">&quot;retryPolicy&quot;</span>: &#123;<br>            <span class="hljs-attr">&quot;maxAttempts&quot;</span>: <span class="hljs-number">5</span>,<br>            <span class="hljs-attr">&quot;initialBackoff&quot;</span>: <span class="hljs-string">&quot;0.1s&quot;</span>,<br>            <span class="hljs-attr">&quot;maxBackoff&quot;</span>: <span class="hljs-string">&quot;1s&quot;</span>,<br>            <span class="hljs-attr">&quot;backoffMultiplier&quot;</span>: <span class="hljs-number">2</span>,<br>            <span class="hljs-attr">&quot;retryableStatusCodes&quot;</span>: [<span class="hljs-string">&quot;UNAVAILABLE&quot;</span>],<br>        &#125;,<br>    &#125;]<br>&#125;<br></code></pre></td></tr></table></figure><p>则会应用到所有的方法中。<br>在这个配置中，<code>name</code>负责指定应用范围，而<code>retryPolicy</code>负责指定应用规则，方便用户调整重试逻辑，他们的含义如下:</p><ul><li>maxAttempts: 最大的重试次数，必须大于，如果大于5则他的值为5</li><li>Backoff系列: 指数退避参数，第一次重试是在random(0, initalBackoff)秒后进行的，而后续的重试间隔计算为min(initial_backoff*backoff_multiplier**(n-1), max_backoff)).</li><li>retryableStatusCodes: 指定什么样的响应状态码才需要重试，具体参照gRPC状态码文档。</li></ul><p>开发者只要合理的进行配置，那么就能简单的应用重试机制，但是光看这点配置还是没办法解决重试导致机器过载的问题，所以gRPC还包含另外一组参数重试限流策略–<a href="https://github.com/grpc/grpc-proto/blob/ec886024c2f7b7f597ba89d5b7d60c3f94627b17/grpc/service_config/service_config.proto#L436">retryThrottling</a>来解决这个问题，这个配置的含义是当客户端的失败和成功超过某个阈值时，gRPC会通过金庸重试策略来防止由于重试导致服务器过载，使用方法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BookGrpcService</span>(<span class="hljs-params">BookSocialGrpcServiceMixin, BookManagerGrpcServiceMixin</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, host: <span class="hljs-built_in">str</span>, port: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        service_config_json = json.dumps(&#123;<br>            <span class="hljs-string">&quot;methodConfig&quot;</span>: [&#123;<br>                <span class="hljs-string">&quot;name&quot;</span>: [<br>                    &#123;<br>                        <span class="hljs-string">&quot;service&quot;</span>: <span class="hljs-string">&quot;book_manager.BookManager&quot;</span>,<br>                        <span class="hljs-string">&quot;method&quot;</span>: <span class="hljs-string">&quot;create_book&quot;</span><br>                    &#125;,<br>                    &#123;<br>                        <span class="hljs-string">&quot;service&quot;</span>: <span class="hljs-string">&quot;book_manager.BookManager&quot;</span>,<br>                        <span class="hljs-string">&quot;method&quot;</span>: <span class="hljs-string">&quot;delete_book&quot;</span><br>                    &#125;,<br>                ],<br>                <span class="hljs-string">&quot;retryPolicy&quot;</span>: &#123;<br>                    <span class="hljs-string">&quot;maxAttempts&quot;</span>: <span class="hljs-number">5</span>,<br>                    <span class="hljs-string">&quot;initialBackoff&quot;</span>: <span class="hljs-string">&quot;0.1s&quot;</span>,<br>                    <span class="hljs-string">&quot;maxBackoff&quot;</span>: <span class="hljs-string">&quot;1s&quot;</span>,<br>                    <span class="hljs-string">&quot;backoffMultiplier&quot;</span>: <span class="hljs-number">2</span>,<br>                    <span class="hljs-string">&quot;retryableStatusCodes&quot;</span>: [<span class="hljs-string">&quot;UNAVAILABLE&quot;</span>],<br>                &#125;,<br>            &#125;],<br>            <span class="hljs-string">&quot;retryThrottling&quot;</span>: &#123;<br>                <span class="hljs-string">&quot;maxTokens&quot;</span>: <span class="hljs-number">10</span>,<br>                <span class="hljs-string">&quot;tokenRatio&quot;</span>: <span class="hljs-number">0.1</span><br>            &#125;<br>        &#125;)<br>        options = []<br>        <span class="hljs-comment"># <span class="hljs-doctag">NOTE:</span> 启动重试模式， 默认在v1.40.0后自动启用</span><br>        options.append((<span class="hljs-string">&quot;grpc.enable_retries&quot;</span>, <span class="hljs-number">1</span>))<br>        <span class="hljs-comment"># 重试的一些参数配置</span><br>        options.append((<span class="hljs-string">&quot;grpc.service_config&quot;</span>, service_config_json))<br><br><br>        self.channel: grpc.Channel = grpc.intercept_channel(<br>            grpc.insecure_channel(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;host&#125;</span>:<span class="hljs-subst">&#123;port&#125;</span>&quot;</span>), CustomerTopInterceptor(), options=options<br>        )<br>        BookSocialGrpcServiceMixin.__init__(self, self.channel)<br>        BookManagerGrpcServiceMixin.__init__(self, self.channel)<br></code></pre></td></tr></table></figure><p>在这段代码中，通过引入与<code>methodConfig</code>同级的<code>retryThrottling</code>配置，之后gRPC客户端会维护一个tokenCount的变量，它的初始值为maxToken,值得范围在0-maxToken波动，之后每一次请求成功时，tokenCount都会递增<code>tokenRatio</code>的值，每次请求失败时，tokenCount都会递减1，之后在重试之前如果发现tokaneCount小于或等于maxToken/2时，gRPC客户端不会进行重试且不会进行对冲。需要注意的是<code>tokenRatio</code>的设定范围只能在0-1之间，且只支持小数点后3位，如0.5466将为视为0.546，而MmaxTOkens的取值范围为0-1000的整数值。</p><blockquote><p>目前Python gRPC不支持对冲，更多gRPC重试内容和设计见<a href="https://github.com/grpc/proposal/blob/master/A6-client-retries.md">A6-client-retries</a></p></blockquote><h2 id="3-调用时参数"><a href="#3-调用时参数" class="headerlink" title="3.调用时参数"></a>3.调用时参数</h2><h2 id="3-1-超时"><a href="#3-1-超时" class="headerlink" title="3.1.超时"></a>3.1.超时</h2><p>超时机制， 是一个简单又方便的控制网络请求异常的一种方法， 它可以保证服务稳定(本质是快速失败)， 良好的超时控制策略可以尽快的释放高延迟的请求，避免请求堆积。对于一般的HTTP请求，只需要在客户端添加一个超时参数，然后客户端检查在超时时间范围内还没收到对应的网络请求时，就会单方面关闭请求，这种处理方法在大多数情况下是没问题的，但在遇到阻塞性调用等情况时，客户端单方面关闭了请求，但服务端还在继续处理请求，并做出响应，不过客户端已经关闭了连接了，它无法收到该响应，这样就造成了服务端都性能浪费了。要解决这个问题，就需要引入一个超时传递的机制，使服务端能获取到本次请求的指定超时时间，并做出响应的操作。</p><p>好在gRPC已经自带了超时和超时传递的功能了，只需要在调用时添加timeout参数即可，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserGrpcServiceMixin</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, channel: grpc.Channel</span>):</span><br>        self.user_stub: user_service.UserStub = user_service.UserStub(channel)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">create_user</span>(<span class="hljs-params">self, *, uid: <span class="hljs-built_in">str</span>, user_name: <span class="hljs-built_in">str</span>, password: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        self.user_stub.create_user(user_message.CreateUserRequest(uid=uid, user_name=user_name, password=password), timeout=<span class="hljs-number">10</span>)<br></code></pre></td></tr></table></figure><p>这样一来，客户端在调用的时候，就会进行倒计时，如果10秒内任然没有收到响应，那么它就会抛出超时异常，而服务端可以通过<code>context.time_remaining()</code>获取到还有多少剩余时间，并在主要逻辑代码使用，如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserService</span>(<span class="hljs-params">user_service.UserServicer</span>):</span><br><span class="hljs-meta">    @conn_proxy()</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">create_user</span>(<span class="hljs-params">self, request: user_message.CreateUserRequest, context: grpc.ServicerContext</span>) -&gt; Empty:</span><br>        <span class="hljs-keyword">with</span> TimeoutContext(context.time_remaining()):<br>            user_dal.create_user(uid=request.uid, user_name=request.user_name, password=request.password)<br>        <span class="hljs-keyword">return</span> Empty()<br></code></pre></td></tr></table></figure><p>该代码引入一个TimeoutContext对象，这个对象会托管该作用域，如果该作用域的运行时长超多指定的时间，则会直接抛出错误，具体见<a href="https://so1n.me/2021/10/22/RPC%E6%A1%86%E6%9E%B6%E7%BC%96%E5%86%99%E5%AE%9E%E8%B7%B5--%E8%B6%85%E6%97%B6%E4%B8%8E%E8%B6%85%E6%97%B6%E4%BC%A0%E9%80%92">RPC框架编写实践–超时与超时传递</a></p><h2 id="3-2-等待服务就绪"><a href="#3-2-等待服务就绪" class="headerlink" title="3.2.等待服务就绪"></a>3.2.等待服务就绪</h2><p>一般的gRPC客户端在请求服务端都时候，如果发现服务端无法及时传输数据，比如channel处于<code>TRANSIENT_FAILURE</code>或<code>SHUTDOWN</code>状态时，客户端应该马上响应失败，这种方法被称为快速失败，但是服务端还有其它的状态如<code>CONNECTING</code>、<code>READY</code>或<code>IDLE</code>，这时候channel处于准备状态，还无法提供服务，但是在稍后将可以提供服务，比如客户端服务端同时启动，但因为短暂的网络故障导致服务端不可用等场景。这时候就可以使用<code>wait-for-ready</code>功能，使用<code>wait-for-ready</code>的调用将自动等待，直到服务器准备好接受请求时再发送，如下例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserGrpcServiceMixin</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, channel: grpc.Channel</span>):</span><br>        self.user_stub: user_service.UserStub = user_service.UserStub(channel)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">create_user</span>(<span class="hljs-params">self, *, uid: <span class="hljs-built_in">str</span>, user_name: <span class="hljs-built_in">str</span>, password: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        self.user_stub.create_user(user_message.CreateUserRequest(uid=uid, user_name=user_name, password=password), wait_for_ready=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure><p>这样一来在调用<code>create_user</code>时，如果服务端还处于准备阶段，那么他会一直等待，直到服务端处于运行状态，需要注意的是，等待时间不会超过timeout指定的时间。</p><h2 id="4-数据类型的转换"><a href="#4-数据类型的转换" class="headerlink" title="4.数据类型的转换"></a>4.数据类型的转换</h2><p>在演示的代码<a href="https://github.com/so1n/grpc-example-common/blob/part-1/grpc_example_common/helper/field.py">grpc_example_common.helper.field</a>中，我编写了几个参数，用于做Protobuf文件的数据类型转换，这些实现是非常简陋的，有些类型并没有考虑到，不过官方提供好了数据类型的转换，这些功能都位于<a href="https://googleapis.dev/python/protobuf/latest/google/protobuf/json_format.html">google.protobuf.json_format</a>之中，大多数我们只要用<code>json_format.ParseDict</code>或者是<code>json_format.MessageToDict</code>即可，不过有些时候我们需要进行一些定制化，但是json_format并没有开放出对应的接口，我们只能使用一些奇怪的方法来定制化，比如<code>json_format.ParseDict</code>，我们只要重置<code>json_format._ConvertScalarFieldValue</code>方法即可，用法如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">from</span> decimal <span class="hljs-keyword">import</span> Decimal<br><span class="hljs-keyword">from</span> google.protobuf <span class="hljs-keyword">import</span> json_format<br><span class="hljs-keyword">from</span> grpc_example_common.protos.book.social_pb2 <span class="hljs-keyword">import</span> GetBookLikesResult<br><br><br><span class="hljs-comment"># 获取到原来的用法</span><br>_ConvertScalarFieldValue = json_format._ConvertScalarFieldValue<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">ConvertScalarFieldValue</span>(<span class="hljs-params">value, field, path, require_str=<span class="hljs-literal">False</span></span>):</span><br>    <span class="hljs-comment"># 制定我们的规则</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(value, <span class="hljs-built_in">str</span>):<br>        <span class="hljs-comment"># 字符串添加一个faker</span><br>        value = <span class="hljs-string">&quot;faker&quot;</span> + value<br>    <span class="hljs-keyword">elif</span> <span class="hljs-built_in">isinstance</span>(value, Decimal):<br>        <span class="hljs-comment"># Decimal就+10</span><br>        value = <span class="hljs-built_in">int</span>(value) + <span class="hljs-number">10</span><br>    <span class="hljs-comment"># 最后再交给原来的方法处理</span><br>    <span class="hljs-keyword">return</span> _ConvertScalarFieldValue(value, field, path, require_str)<br><br><span class="hljs-built_in">setattr</span>(json_format, <span class="hljs-string">&#x27;_ConvertScalarFieldValue&#x27;</span>, ConvertScalarFieldValue)<br><br><br>parse_message = json_format.ParseDict(&#123;<span class="hljs-string">&quot;isbn&quot;</span>: <span class="hljs-string">&quot;xxx&quot;</span>, <span class="hljs-string">&quot;book_like&quot;</span>: Decimal(<span class="hljs-string">&quot;2.0&quot;</span>)&#125;, GetBookLikesResult)<br><span class="hljs-comment"># 输出符合我们的预期</span><br>print(parse_message.book_like)<br><span class="hljs-comment"># --&gt; 12</span><br>print(parse_message.isbn)<br><span class="hljs-comment"># --&gt; fakerxxx</span><br></code></pre></td></tr></table></figure><p>可以看到输出与符合我们定义的规则，而对于<code>json_format.MessageToDict</code>，可以直接修改它使用的<code>_Printer</code>中的<code>_FieldToJsonObject</code>方法，并创建一个全新的<code>MessageToDict</code>来调用到我们编写的<code>Printer</code>的类，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">from</span> google.protobuf <span class="hljs-keyword">import</span> json_format<br><span class="hljs-keyword">from</span> grpc_example_common.protos.book.social_pb2 <span class="hljs-keyword">import</span> GetBookLikesResult<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Printer</span>(<span class="hljs-params">json_format._Printer</span>):</span>  <span class="hljs-comment"># noqa</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_FieldToJsonObject</span>(<span class="hljs-params">self, field, value</span>):</span><br>        <span class="hljs-comment"># 如果是int类型，就加10</span><br>        <span class="hljs-keyword">if</span> field.cpp_type <span class="hljs-keyword">in</span> json_format._INT_TYPES:<br>            <span class="hljs-keyword">return</span> value+<span class="hljs-number">10</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>()._FieldToJsonObject(field, value)<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">MessageToDict</span>(<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">    message,</span></span><br><span class="hljs-function"><span class="hljs-params">    including_default_value_fields=<span class="hljs-literal">False</span>,</span></span><br><span class="hljs-function"><span class="hljs-params">    preserving_proto_field_name=<span class="hljs-literal">False</span>,</span></span><br><span class="hljs-function"><span class="hljs-params">    use_integers_for_enums=<span class="hljs-literal">False</span>,</span></span><br><span class="hljs-function"><span class="hljs-params">    descriptor_pool=<span class="hljs-literal">None</span>,</span></span><br><span class="hljs-function"><span class="hljs-params">    float_precision=<span class="hljs-literal">None</span></span>):</span><br>    printer = Printer(<br>        including_default_value_fields,<br>        preserving_proto_field_name,<br>        use_integers_for_enums,<br>        descriptor_pool,<br>        float_precision=float_precision)<br>    <span class="hljs-comment"># pylint: disable=protected-access</span><br>    <span class="hljs-keyword">return</span> printer._MessageToJsonObject(message)<br><br><br>print(MessageToDict(GetBookLikesResult(book_like=<span class="hljs-number">10</span>)))<br><span class="hljs-comment"># --&gt; 20</span><br></code></pre></td></tr></table></figure><p>通过输出后可以发现，输出的结果是20，符合我们的定义的规则。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://so1n.me/2022/04/07/Python-gRPC%E5%AE%9E%E8%B7%B5(3)--</summary>
      
    
    
    <content src="https://ftp.bmp.ovh/imgs/2022/02/bd67e15aa8d46101.png" type="image"/>
    
    
    <category term="Python-gRPC实践" scheme="http://so1n.me/categories/Python-gRPC%E5%AE%9E%E8%B7%B5/"/>
    
    
    <category term="Python" scheme="http://so1n.me/tags/Python/"/>
    
    <category term="gRPC" scheme="http://so1n.me/tags/gRPC/"/>
    
  </entry>
  
  <entry>
    <title>Python-gRPC实践(4)--简述gRPC拦截器</title>
    <link href="http://so1n.me/2022/04/13/Python-gRPC%E5%AE%9E%E8%B7%B5(4)--gRPC%E6%8B%A6%E6%88%AA%E5%99%A8/"/>
    <id>http://so1n.me/2022/04/13/Python-gRPC%E5%AE%9E%E8%B7%B5(4)--gRPC%E6%8B%A6%E6%88%AA%E5%99%A8/</id>
    <published>2022-04-13T12:35:24.000Z</published>
    <updated>2022-04-13T17:09:17.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>世界上没有百分之百不会挂的服务，只能人为的去增加服务的可用性，为了能让服务的可用性增加，需要为服务添加服务治理的功能，而在gRPC中，可以通过拦截器实现一些服务治理的功能。</p><span id="more"></span><h2 id="1-什么是拦截器"><a href="#1-什么是拦截器" class="headerlink" title="1.什么是拦截器"></a>1.什么是拦截器</h2><p>在<code>Python</code>中，很少有框架把自己的功能称为拦截器，反而都称为中间件或者是钩子，gRPC的拦截器功能与<code>Python</code>Web框架常用的中间件基本一样，它主要的功能是可以在调用函数之前，之后已经发生异常时能够捕获到对应的数据，比如如下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">demo_rpc_method</span>():</span><br>    <span class="hljs-comment"># run before code</span><br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-keyword">pass</span>  <span class="hljs-comment"># rpc logic</span><br>    <span class="hljs-keyword">except</span> Exception:<br>        <span class="hljs-keyword">pass</span>  <span class="hljs-comment"># exc code</span><br>    <span class="hljs-keyword">finally</span>:<br>        <span class="hljs-comment"># run after code</span><br></code></pre></td></tr></table></figure><p>这段代码提现了拦截器的主要特点：</p><ul><li>1.裹住了一个RPC调用逻辑</li><li>2.能够在裹住的逻辑调用之前，之后以及调用异常的时候自定义数据</li></ul><p>对于<code>Python</code>开发人员来说，看到这思路后脑子里的第一个想法就是可以通过<code>Python</code>的装饰器轻松的实现<code>gRPC</code>拦截器的逻辑。</p><p>所以在官方尚未敲定拦截器实现的时候，大家也都是使用装饰器来实现拦截器的，比如下面这段代码（源码见<a href="https://github.com/so1n/grpc-example-common/blob/part-1/grpc_example_common/helper/grpc_wrapper.py#L25">grpc_example_common/helper/grpc_wrapper.py</a>）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">grpc_client_func_wrapper</span>(<span class="hljs-params">*args: Any, **kwargs: Any</span>) -&gt; Callable:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">wrapper</span>(<span class="hljs-params">func: Callable</span>) -&gt; Callable:</span><br>        <span class="hljs-comment"># func是装饰器装饰的一个方法</span><br><span class="hljs-meta">        @wraps(<span class="hljs-params">func</span>)</span><br>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_wrapper</span>(<span class="hljs-params">*_args: Any, **_kwargs: Any</span>) -&gt; Any:</span><br>            <span class="hljs-comment"># 查看调用段方法是否有指定metadata参数，如果没有就定义一个</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;metadata&quot;</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> _kwargs:<br>                _kwargs[<span class="hljs-string">&quot;metadata&quot;</span>] = []<br>            <span class="hljs-keyword">return</span> func(*_args, **_kwargs)<br><br>        <span class="hljs-keyword">return</span> _wrapper<br><br>    <span class="hljs-keyword">return</span> wrapper<br></code></pre></td></tr></table></figure><p>这是我目前还在用的一个通过装饰器实现的拦截器，因为目前gRPC的客户端在调用方法没定义<code>metadata</code>参数时，<code>gRPC</code>客户端拦截器是没办法去更改<code>metadata</code>参数的，强行修改还会报错，而<code>meatdata</code>参数类似于HTTP的Header参数，很多通过拦截器实现的功能如链路追踪，身份校验等功能的实现都需要通过拦截器更改或写入<code>metadata</code>参数来实现，所以这个装饰器一直保留着。</p><p>既然有了装饰器，那为什么gRPC最终还是选择拦截器这个方案呢，原因是装饰器虽然很灵活，但是本身有很多缺点：</p><ul><li>0.装饰器只能用于方法上，如果遇到一个无法调用到指定的方法的请求，那么这个请求就无法没监控到。</li><li>1.需要显式的为每个方法添加装饰器。</li><li>2.过多的装饰器会变得非常混乱。</li><li>3.上篇文章提到的由于装饰器导致需要延后声明才能使方法mock生效。</li></ul><blockquote><p>Note： 可以通过<a href="https://github.com/so1n/grpc-example-common/blob/part-1/grpc_example_common/helper/grpc_wrapper.py#L38">grpc_example_common/helper/grpc_wrapper.py</a>函数自动应用装饰器，使用方法见<a href="https://github.com/so1n/grpc-example-api-backend-service/blob/master/grpc_service/book_service.py#L19">grpc_service/book_service.py</a></p></blockquote><h2 id="2-如何使用拦截器"><a href="#2-如何使用拦截器" class="headerlink" title="2.如何使用拦截器"></a>2.如何使用拦截器</h2><p>由于装饰器自己带有一些缺点，所以<code>gRPC</code>最后自己定义了一个拦截器方案，不过<code>Python</code>实现gRPC拦截器API非常复杂，按照官方文档的指引，我们需要为每种请求类型定义一个拦截器，但是他们的代码却是相同的，这对开发人员来说非常的不友好，不过好在有一个<a href="https://github.com/d5h-foss/grpc-interceptor">grpc-interceptor</a>包进行了统一，使用起来非常方便，只用继承他提供的类，再覆盖intercept方法就可以同时为一对一，多对一，一对多的请求套上拦截器，比如我定义了一个可以把错误类型在不同基于<code>Python</code>实现的gRPC服务传播的拦截器：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-comment">##############</span><br><span class="hljs-comment"># 服务端拦截器 #</span><br><span class="hljs-comment">##############</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ServerCustomerTopInterceptor</span>(<span class="hljs-params">BaseInterceptor</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">intercept</span>(<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">        self,</span></span><br><span class="hljs-function"><span class="hljs-params">        next_handler_method: Callable,</span></span><br><span class="hljs-function"><span class="hljs-params">        request_proto_message: Any,</span></span><br><span class="hljs-function"><span class="hljs-params">        context: grpc.ServicerContext,</span></span><br><span class="hljs-function"><span class="hljs-params">    </span>) -&gt; Any:</span><br>        <span class="hljs-comment"># 在这个区域实现未调用方法的代码</span><br>        start_time: <span class="hljs-built_in">float</span> = time.time()<br>        return_initial_metadata: List[Tuple] = [(<span class="hljs-string">&quot;customer-user-agent&quot;</span>, <span class="hljs-string">&quot;Python3&quot;</span>)]<br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-comment"># 调用下一个拦截器或者是方法 </span><br>            <span class="hljs-keyword">return</span> next_handler_method(request_proto_message, context)<br>        <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>            <span class="hljs-comment"># 发生错误的处理，解析错误 </span><br>            <span class="hljs-keyword">if</span> self.metadata_dict.get(<span class="hljs-string">&quot;customer-user-agent&quot;</span>, <span class="hljs-string">&quot;&quot;</span>) == <span class="hljs-string">&quot;Python3&quot;</span>:<br>                return_initial_metadata.append((<span class="hljs-string">&quot;exc_name&quot;</span>, e.__class__.__name__))<br>                return_initial_metadata.append((<span class="hljs-string">&quot;exc_info&quot;</span>, <span class="hljs-built_in">str</span>(e)))<br>            logging.exception(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;context_proxy.method&#125;</span> request exc:<span class="hljs-subst">&#123;e.__class__.__name__&#125;</span> error:<span class="hljs-subst">&#123;e&#125;</span>&quot;</span>)<br>            <span class="hljs-comment"># 记住一定要把异常抛出来，这样才能走grpc的异常逻辑，否则客户端那边会解析到错误的body</span><br>            <span class="hljs-keyword">raise</span> e<br>        <span class="hljs-keyword">finally</span>:<br>            <span class="hljs-comment"># 调用方法后的逻辑，这里把metadata插入到context中</span><br>            context.send_initial_metadata(return_initial_metadata)<br>            <span class="hljs-comment"># 打印access log</span><br>            logging.info(<br>                <span class="hljs-string">f&quot;Got Request. method:<span class="hljs-subst">&#123;self.method&#125;</span>, code:<span class="hljs-subst">&#123;context.code()&#125;</span>, detail:<span class="hljs-subst">&#123;context.details()&#125;</span>, duration:<span class="hljs-subst">&#123;time.time() - start_time&#125;</span>&quot;</span><br>            )<br><span class="hljs-comment">##############</span><br><span class="hljs-comment"># 客户端拦截器 #</span><br><span class="hljs-comment">##############</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClientCustomerTopInterceptor</span>(<span class="hljs-params">BaseInterceptor</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, exc_list: Optional[List[Type[Exception]]] = <span class="hljs-literal">None</span></span>):</span><br>        <span class="hljs-comment"># 注入可用的异常</span><br>        self.exc_dict: Dict[<span class="hljs-built_in">str</span>, Type[Exception]] = &#123;&#125;<br>        <span class="hljs-keyword">for</span> key, exc <span class="hljs-keyword">in</span> <span class="hljs-built_in">globals</span>()[<span class="hljs-string">&quot;__builtins__&quot;</span>].items():<br>            <span class="hljs-keyword">if</span> inspect.isclass(exc) <span class="hljs-keyword">and</span> <span class="hljs-built_in">issubclass</span>(exc, Exception):<br>                self.exc_dict[key] = exc<br><br>        <span class="hljs-keyword">if</span> exc_list:<br>            <span class="hljs-keyword">for</span> exc <span class="hljs-keyword">in</span> exc_list:<br>                <span class="hljs-keyword">if</span> <span class="hljs-built_in">issubclass</span>(exc, Exception):<br>                    self.exc_dict[exc.__name__] = exc<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">intercept</span>(<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">        self,</span></span><br><span class="hljs-function"><span class="hljs-params">        method: Callable,</span></span><br><span class="hljs-function"><span class="hljs-params">        request_or_iterator: Any,</span></span><br><span class="hljs-function"><span class="hljs-params">        call_details: ClientCallDetailsType,</span></span><br><span class="hljs-function"><span class="hljs-params">    </span>) -&gt; GRPC_RESPONSE:</span><br>        <span class="hljs-comment"># 调用方法之前的操作，注意一定要判断metadata是否为空，如果是的话，metadata是不可写的，强行写入会报错</span><br>        <span class="hljs-keyword">if</span> call_details.metadata <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            call_details.metadata.append((<span class="hljs-string">&quot;customer-user-agent&quot;</span>, <span class="hljs-string">&quot;Python3&quot;</span>))  <span class="hljs-comment"># type: ignore</span><br>            call_details.metadata.append((<span class="hljs-string">&quot;request_id&quot;</span>, context_proxy.request_id))<br>        <span class="hljs-comment"># 调用方法</span><br>        response: GRPC_RESPONSE = method(call_details, request_or_iterator)<br>        <span class="hljs-comment"># 调用完方法的对应操作</span><br>        metadata_dict: <span class="hljs-built_in">dict</span> = &#123;item.key: item.value <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> response.initial_metadata()&#125;<br>        <span class="hljs-keyword">if</span> metadata_dict.get(<span class="hljs-string">&quot;customer-user-agent&quot;</span>) == <span class="hljs-string">&quot;Python3&quot;</span>:<br>            exc_name: <span class="hljs-built_in">str</span> = metadata_dict.get(<span class="hljs-string">&quot;exc_name&quot;</span>, <span class="hljs-string">&quot;&quot;</span>)<br>            exc_info: <span class="hljs-built_in">str</span> = metadata_dict.get(<span class="hljs-string">&quot;exc_info&quot;</span>, <span class="hljs-string">&quot;&quot;</span>)<br>            exc: Optional[Type[Exception]] = self.exc_dict.get(exc_name)<br>            <span class="hljs-keyword">if</span> exc:<br>                <span class="hljs-keyword">raise</span> exc(exc_info)<br>        <span class="hljs-keyword">return</span> response<br></code></pre></td></tr></table></figure><p>可以看到源码中的拦截器都有调用之前，调用中，调用后三大逻辑，与我们前面说的一样，给予开发者极强的自定义能力，这样一来就可以通过拦截器来实现一些服务治理的功能，对于如何实现可见<a href="https://so1n.me/categories/RPC%E6%A1%86%E6%9E%B6%E7%BC%96%E5%86%99%E5%AE%9E%E8%B7%B5/">RPC框架编写实践系列</a></p><p>实现完拦截器后就需要应用到gRPC服务中，由于<a href="https://github.com/d5h-foss/grpc-interceptor">grpc-interceptor</a>是对官方拦截器的简单安装，所以可以像官方拦截器一样应用到服务中，服务端应用拦截器可参考<a href="https://github.com/so1n/grpc-example-book-grpc-service/blob/part-1/app.py#L21">grpc-example-book-grpc-service项目</a>在<code>grpc.Server</code>初始化时通过<code>interceptors</code>参数把拦截器列表传进去，简要代码如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>(<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">    host: <span class="hljs-built_in">str</span> = <span class="hljs-string">&quot;0.0.0.0&quot;</span>, port: <span class="hljs-built_in">str</span> = <span class="hljs-string">&quot;9000&quot;</span>, ssl_port: Optional[<span class="hljs-built_in">str</span>] = <span class="hljs-literal">None</span></span></span><br><span class="hljs-function"><span class="hljs-params"></span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>    interceptor_list: List[BaseInterceptor] = [CustomerTopInterceptor()]<br>    server: grpc.server = grpc.server(<br>        futures.ThreadPoolExecutor(max_workers=<span class="hljs-number">10</span>),<br>        interceptors=interceptor_list,<br>    )<br>    manager_service.add_BookManagerServicer_to_server(ManagerService(), server)<br>    social_service.add_BookSocialServicer_to_server(SocialService(), server)<br></code></pre></td></tr></table></figure><p>而对于客户端可以参考<a href="https://github.com/so1n/grpc-example-api-backend-service/blob/master/grpc_service/book_service.py#L68">grpc-example-api-backend-service项目</a>在通过生成<code>channel</code>时，把拦截器通过参数传进去</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BookGrpcService</span>(<span class="hljs-params">BookSocialGrpcServiceMixin, BookManagerGrpcServiceMixin</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, host: <span class="hljs-built_in">str</span>, port: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        self.channel: grpc.Channel = grpc.intercept_channel(<br>            grpc.insecure_channel(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;host&#125;</span>:<span class="hljs-subst">&#123;port&#125;</span>&quot;</span>), CustomerTopInterceptor()<br>        )<br>        BookSocialGrpcServiceMixin.__init__(self, self.channel)<br>        BookManagerGrpcServiceMixin.__init__(self, self.channel)<br></code></pre></td></tr></table></figure><p>拦截器编写完成后应该去测试它，但是大多数都拦截器都依赖于一些特定的服务，如Prometheus监控依赖Prometheus，链路追踪可能依赖到的jaeger等，所以很多时候都会在测试环境或者预发布环境进行测试，但是对于其它无服务依赖的拦截器则可以使用<code>grpc_interceptor</code>包实现的测试模块来进行测试，如官方的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">from</span> grpc_interceptor <span class="hljs-keyword">import</span> ExceptionToStatusInterceptor<br><span class="hljs-keyword">from</span> grpc_interceptor.exceptions <span class="hljs-keyword">import</span> NotFound<br><span class="hljs-keyword">from</span> grpc_interceptor.testing <span class="hljs-keyword">import</span> dummy_client, DummyRequest, raises<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_exception</span>():</span><br>    special_cases = &#123;<span class="hljs-string">&quot;error&quot;</span>: raises(NotFound())&#125;<br>    <span class="hljs-comment"># 指定的拦截器</span><br>    interceptors = [ExceptionToStatusInterceptor()]<br>    <span class="hljs-comment"># 模拟一个客户端发起请求，该客户端响应的数据等于input时指定的数据</span><br>    <span class="hljs-comment"># 不过也可以通过special_cases来指定input数据对应的异常响应</span><br>    <span class="hljs-keyword">with</span> dummy_client(special_cases=special_cases, interceptors=interceptors) <span class="hljs-keyword">as</span> client:<br>        <span class="hljs-comment"># 输入input时必定会响应一个output</span><br>        <span class="hljs-keyword">assert</span> client.Execute(DummyRequest(<span class="hljs-built_in">input</span>=<span class="hljs-string">&quot;foo&quot;</span>)).output == <span class="hljs-string">&quot;foo&quot;</span><br>        <span class="hljs-comment"># 输入error时，会抛出一个对应的响应</span><br>        <span class="hljs-keyword">with</span> pytest.raises(grpc.RpcError) <span class="hljs-keyword">as</span> e:<br>            client.Execute(DummyRequest(<span class="hljs-built_in">input</span>=<span class="hljs-string">&quot;error&quot;</span>))<br>        <span class="hljs-keyword">assert</span> e.value.code() == grpc.StatusCode.NOT_FOUND<br></code></pre></td></tr></table></figure><p>通过该例子可以方便的实现一个正常请求和错误请求来测试拦截器的返回，但是对于一些内在逻辑最好通过pytest-mock或者是官方的unitest-mock来判断是否有调用到，调用几次，调用时的内容是否符合标准等等。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;世界上没有百分之百不会挂的服务，只能人为的去增加服务的可用性，为了能让服务的可用性增加，需要为服务添加服务治理的功能，而在gRPC中，可以通过拦截器实现一些服务治理的功能。&lt;/p&gt;</summary>
    
    
    <content src="https://ftp.bmp.ovh/imgs/2022/02/bd67e15aa8d46101.png" type="image"/>
    
    
    <category term="Python-gRPC实践" scheme="http://so1n.me/categories/Python-gRPC%E5%AE%9E%E8%B7%B5/"/>
    
    
    <category term="Python" scheme="http://so1n.me/tags/Python/"/>
    
    <category term="gRPC" scheme="http://so1n.me/tags/gRPC/"/>
    
  </entry>
  
</feed>
