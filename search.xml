<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>重换新生</title>
    <url>/2020/03/22/new/</url>
    <content><![CDATA[<h2 id="杂记"><a href="#杂记" class="headerlink" title="杂记"></a>杂记</h2><p>终于,2020年的3月22日,在某块硬盘上面找到了博客的备份了.</p>
<p>这个博客从我实习后就开始没有更新了,在找回博客后看到以前自己写的内容颇有感慨,发现自己以前以为自己很厉害的写下一些文章,其实却没卵用,但起码也是进步的印记,还是有留念意义.</p>
<p>虽然博客断更两年了,但好在平时还有写写文章的记录,接下来这段时间可以把写在为知的文章慢慢迁移到博客里面来,同时对文章重新整理,以及写在为知的文章可能涉及到公司的数据,需要去掉与公司相关的数据再进行发表.</p>
<p>同时,也对博客的旧文章进行更新,毕竟之前的文章有些还是惨不忍睹的,有些图片也缺失了,需要重新补上去,再对博客的其他有问题的地方进行修修.</p>
<p>最后,2020,只要干不死,就往死里干!</p>
]]></content>
      <categories>
        <category>计划</category>
      </categories>
      <tags>
        <tag>计划</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Pait快速构建gRPC Json网关</title>
    <url>/2022/10/29/%E4%BD%BF%E7%94%A8Pait%E6%9E%84%E5%BB%BAgRPC%20Json%E7%BD%91%E5%85%B3/</url>
    <content><![CDATA[<h2 id="前记"><a href="#前记" class="headerlink" title="前记"></a>前记</h2><p><code>gRPC</code>已经是一个大多数开发者使用微服务时选择的通信协议，大多数公司的内部服务都会通过<code>gRPC</code>来通信，但是服务端和客户端使用的通信协议还是<code>HTTP</code>，这就意味着需要在客户端和内部服务之间架起一个可以转换<code>HTTP</code>与<code>gRPC</code>协议的网关。<br><a href="https://github.com/so1n/pait">pait</a>的<code>gRPC Gateway</code>模块就是实现了这样的一个功能，<code>gRPC Gateway</code>模块通过<code>pait</code>能快速的把<code>Python</code>Web框架和<code>gRPC</code>连接起来，并自动处理和转发请求。</p>
<h2 id="1-一个简单的例子"><a href="#1-一个简单的例子" class="headerlink" title="1.一个简单的例子"></a>1.一个简单的例子</h2><p>在介绍如何使用<code>Pait</code>快速构建<code>gRPC Json</code>网关之前先以一个简单的示例项目为例子来介绍没用网关前的局限性。</p>
<blockquote>
<p>例子项目代码见附录一链接</p>
</blockquote>
<p>在这个例子中存在一个客户端和三个后端服务，其中<code>gRPC</code>服务有两个，一个是负责用户的创建、注销、登录、登出，token校验五个功能的<code>User</code>服务;另外一个是负责书本的信息获取和书本评论和点赞等功能的<code>book</code>服务。而剩下的后端服务是使用<code>Flask</code>框架构建的API服务，它负责暴露出HTTP接口供客户端调用，当被客户端调用时会把请求进行处理并通过<code>gRPC</code>客户端转发给另外两个<code>gRPC</code>服务，他们的关系图如下：<br><img   class="lazyload" data-original="https://files.catbox.moe/s5e3hf.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" ><br>通过关系图可以发现客户端只与<code>Flask</code>应用通过HTTP通信，<code>Flask</code>应用通过<code>gRPC</code>客户端与其它机器的<code>gRPC</code>服务通过<code>gRPC</code>进行通信，客户端无法直接访问到<code>gRPC</code>服务所在的机器<code>node2</code>和<code>node3</code>。</p>
<p>这个设计简单又实用，挺不错的，但是在编写代码时却有点烦恼，以用户服务为例子，编写<code>gRPC</code>服务的第一步是编写好<code>Protobuf文件</code>，其中用户服务的<code>Protobuf</code>文件描述的<code>Service</code>如下：</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><code class="hljs Protobuf"><span class="hljs-comment">// 省略其它protobuf 代码</span><br><span class="hljs-class"><span class="hljs-keyword">service</span> <span class="hljs-title">User</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">rpc</span> get_uid_by_token (GetUidByTokenRequest) <span class="hljs-keyword">returns</span> (GetUidByTokenResult)</span>;<br>  <span class="hljs-function"><span class="hljs-keyword">rpc</span> logout_user (LogoutUserRequest) <span class="hljs-keyword">returns</span> (google.protobuf.Empty)</span>;<br>  <span class="hljs-function"><span class="hljs-keyword">rpc</span> login_user(LoginUserRequest) <span class="hljs-keyword">returns</span> (LoginUserResult)</span>;<br>  <span class="hljs-function"><span class="hljs-keyword">rpc</span> create_user(CreateUserRequest) <span class="hljs-keyword">returns</span> (google.protobuf.Empty)</span>;<br>  <span class="hljs-function"><span class="hljs-keyword">rpc</span> delete_user(DeleteUserRequest) <span class="hljs-keyword">returns</span> (google.protobuf.Empty)</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>第二步是根据<code>Protobuf</code>文件生成的接口代码来编写对应的代码逻辑，然后把代码部署在<code>node2</code>机器上运行。</p>
<p>接下来就是麻烦的第三步了，首先是根据<code>Protobuf</code>文件生成客户端代码，然后编写调用<code>gRPC</code>客户端的路由函数，代码如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Response, request<br><span class="hljs-comment"># 生成的Python文件都存放在gRPC公有包里面</span><br><span class="hljs-keyword">from</span> grpc_example_common.protos.user <span class="hljs-keyword">import</span> user_pb2 <span class="hljs-keyword">as</span> user_message<br><br><span class="hljs-keyword">from</span> app_service.utils <span class="hljs-keyword">import</span> g, get_uid_by_token, make_response<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">create_user</span>() -&gt; Response:</span><br>    request_dict: <span class="hljs-built_in">dict</span> = request.json<br>    g.user_grpc_service.create_user(<br>        uid=request_dict[<span class="hljs-string">&quot;uid&quot;</span>], user_name=request_dict[<span class="hljs-string">&quot;user_name&quot;</span>], password=request_dict[<span class="hljs-string">&quot;password&quot;</span>]<br>    )<br>    <span class="hljs-keyword">return</span> make_response()<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">delete_user</span>() -&gt; Response:</span><br>    request_dict: <span class="hljs-built_in">dict</span> = request.json<br>    g.user_grpc_service.delete_user(uid=request_dict[<span class="hljs-string">&quot;uid&quot;</span>])<br>    <span class="hljs-keyword">return</span> make_response()<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">login_route</span>() -&gt; Response:</span><br>    request_dict: <span class="hljs-built_in">dict</span> = request.json<br>    login_result: user_message.LoginUserResult = g.user_grpc_service.login_user(<br>        uid=request_dict[<span class="hljs-string">&quot;uid&quot;</span>], password=request_dict[<span class="hljs-string">&quot;password&quot;</span>]<br>    )<br>    <span class="hljs-keyword">return</span> make_response(&#123;<span class="hljs-string">&quot;token&quot;</span>: login_result.token, <span class="hljs-string">&quot;uid&quot;</span>: login_result.uid&#125;)<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">logout_route</span>() -&gt; Response:</span><br>    request_dict: <span class="hljs-built_in">dict</span> = request.json<br>    <span class="hljs-keyword">if</span> get_uid_by_token() == request_dict[<span class="hljs-string">&quot;uid&quot;</span>]:<br>        token: <span class="hljs-built_in">str</span> = request.headers.get(<span class="hljs-string">&quot;token&quot;</span>, <span class="hljs-string">&quot;&quot;</span>)<br>        g.user_grpc_service.logout_user(uid=request_dict[<span class="hljs-string">&quot;uid&quot;</span>], token=token)<br>        <span class="hljs-keyword">return</span> make_response()<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">raise</span> RuntimeError(<span class="hljs-string">&quot;Uid ERROR&quot;</span>)<br></code></pre></td></tr></table></figure>
<p>可以看到示例代码中的几个路由函数都是重复的获取请求参数，再把参数逐一的传给<code>gRPC</code>客户端，通过<code>gRPC</code>客户端调用得到结果后对结果反序列化再返回给客户端。</p>
<p>当路由函数编写完成后就需要把路由函数注册到<code>Flask</code>应用中，代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">from</span> flask.blueprints <span class="hljs-keyword">import</span> Blueprint<br><br><span class="hljs-keyword">from</span> app_service <span class="hljs-keyword">import</span> user_route<br><br>user_bp: Blueprint = Blueprint(<span class="hljs-string">&quot;user_bp&quot;</span>, __name__, url_prefix=<span class="hljs-string">&quot;/api/user&quot;</span>)<br>user_bp.add_url_rule(<span class="hljs-string">&quot;/create&quot;</span>, view_func=user_route.create_user, methods=[<span class="hljs-string">&quot;POST&quot;</span>])<br>user_bp.add_url_rule(<span class="hljs-string">&quot;/delete&quot;</span>, view_func=user_route.delete_user, methods=[<span class="hljs-string">&quot;POST&quot;</span>])<br>user_bp.add_url_rule(<span class="hljs-string">&quot;/login&quot;</span>, view_func=user_route.login_route, methods=[<span class="hljs-string">&quot;POST&quot;</span>])<br>user_bp.add_url_rule(<span class="hljs-string">&quot;/logout&quot;</span>, view_func=user_route.logout_route, methods=[<span class="hljs-string">&quot;POST&quot;</span>])<br></code></pre></td></tr></table></figure>
<p>在把代码中的<code>blueprint</code>注册到<code>Flask</code>应用后，<code>api</code>服务也编写完成了，接着就可以部署到<code>node1</code>机器上并供客户端调用了。</p>
<p>可以看到这一切都非常简单，但是手动编写的重复代码比较多，通过示例代码可以看出路由函数名和url名都差别不大，每个路由代码逻辑也很像。<br>而且当想要修改<code>gRPC</code>服务的调用名称，会发现除了修改<code>Protobuf</code>文件外，<code>api</code>服务的代码也要跟着手动修改，这太麻烦了，也容易出错。</p>
<p>同时可以发现在上述例子中编写的转发路由代码跟<code>Protobuf</code>很像，这意味着也可以通过<code>Protobuf</code>文件生成对应的路由代码，这也是<a href="https://github.com/so1n/pait">pait</a>的实现思路，同时<a href="https://github.com/so1n/pait">pait</a><br>参照了<a href="https://github.com/googleapis/googleapis/blob/master/google/api/http.proto">google.api.http</a>来补充<code>Protobuf</code>缺少的HTTP信息，参照<a href="https://github.com/bufbuild/protoc-gen-validate">protoc-gen-validate</a>补充了请求体的信息，使<code>Protobuf</code>文件能表示<code>OpenAPI</code>的所有字段数据。</p>
<h2 id="2-使用Pait构建gRPC-Json网关"><a href="#2-使用Pait构建gRPC-Json网关" class="headerlink" title="2.使用Pait构建gRPC Json网关"></a>2.使用Pait构建gRPC Json网关</h2><p>了解完后，现在开始以<code>User</code>服务为例构建<code>gRPC Json</code>网关，主要涉及到API服务和Protobuf文件的修改。</p>
<blockquote>
<p>完整代码见附录二</p>
</blockquote>
<h3 id="2-1-修改Protobuf文件"><a href="#2-1-修改Protobuf文件" class="headerlink" title="2.1.修改Protobuf文件"></a>2.1.修改Protobuf文件</h3><p>使用<code>Pait</code>构建gRPC Json网关的第一步是在<code>gRPC</code>公有包中更改<code>Protobuf</code>文件, <code>gRPC</code>公有包项目结构如下:</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><code class="hljs crmsh">.<br>├── grpc_example_common<br>│   ├── helper                  <span class="hljs-comment"># gRPC通用封装</span><br>│   ├── interceptor<br>│   │   ├── client_interceptor  <span class="hljs-comment"># gRPC客户端拦截器</span><br>│   │   └── server_interceptor  <span class="hljs-comment"># gRPC服务端拦截器</span><br>│   └── protos  <span class="hljs-comment"># 存放Protobuf文件生成的对应Python代码</span><br>│       ├── book<br>│       ├── common<br>│       └── user<br>└── protos      <span class="hljs-comment"># 存放Protobuf文件</span><br>    └── grpc_example_common<br>        └── protos<br>            ├── book    <span class="hljs-comment"># 存放书籍相关的Protobuf文件</span><br>            ├── common  <span class="hljs-comment"># 存放公有的Protobuf文件</span><br>            └── <span class="hljs-keyword">user</span>    <span class="hljs-title"># 存放用户相关的Protobuf</span>文件<br></code></pre></td></tr></table></figure>
<p>更改<code>Protobuf</code>文件的第一步是通过<a href="https://github.com/so1n/pait/blob/master/pait/http/api.proto">api.proto</a>和<a href="https://github.com/so1n/protobuf_to_pydantic/blob/master/p2p_validate/p2p_validate.proto">p2p_validate.proto</a>下载Protobuf文件到<code>./protos/grpc_example_common/protos/common</code>目录中，其中<code>api.proto</code>提供的是对<code>gRPC</code>接口(也就是service.rpc)的描述，<code>p2p_validate.proto</code>提供的是对<code>Message</code>的描述，下载完成后<code>./protos/grpc_example_common/protos/common</code>目录存放的<code>Protobuf</code>文件有如下3个：</p>
<figure class="highlight pf"><table><tr><td class="code"><pre><code class="hljs pf">.<br>├── grpc_example_common<br>└── protos      <span class="hljs-comment"># 存放Protobuf文件</span><br>    └── grpc_example_common<br>        └── protos<br>           ├── book<br>           ├── common<br>           │   ├── api.<span class="hljs-keyword">proto</span>             <span class="hljs-comment"># &lt;-- new</span><br>           │   ├── exce.<span class="hljs-keyword">proto</span>            <span class="hljs-comment"># &lt;-- new</span><br>           │   └── p2p_validate.<span class="hljs-keyword">proto</span>    <span class="hljs-comment"># &lt;-- new</span><br>           └── <span class="hljs-keyword">user</span><br></code></pre></td></tr></table></figure>

<p>第二步是更改对应的Protobuf文件，以<code>User</code>服务为例子，首先是引入<code>api.proto</code>和<code>p2p_validate.proto</code>:</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><code class="hljs Protobuf"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;grpc_example_common/protos/common/api.proto&quot;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;grpc_example_common/protos/common/p2p_validate.proto&quot;</span>;<br></code></pre></td></tr></table></figure>
<p>如果是使用<code>Pycharm</code>且出现如下提示:<br><img   class="lazyload" data-original="https://fastly.jsdelivr.net/gh/so1n/so1n_blog_photo@master/blog_photo/16682806984141668280697552.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" ><br>那么可以通过点击<code>Add import path to plugin settings</code>解决，如果还没办法解决而弹出一个项目文件结构的窗KPI，则点击窗口中<code>proto</code>对应的文件即可解决。</p>
<p>在完成头文件的引入后，就可以修改Protobuf的其他代码了，首先是修改<code>service</code>的代码，为<code>service</code>中的每一个<code>rpc</code>方法附上对应的OpenAPI信息，如下:</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><code class="hljs Protobuf"><span class="hljs-class"><span class="hljs-keyword">service</span> <span class="hljs-title">User</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">rpc</span> get_uid_by_token (GetUidByTokenRequest) <span class="hljs-keyword">returns</span> (GetUidByTokenResult) </span>&#123;<br>    <span class="hljs-keyword">option</span> (pait.api.http) = &#123;<br>      not_enable: <span class="hljs-literal">true</span>,   <span class="hljs-comment">// 定义Pait不解析该函数，这样Pait就不会为该函数映射到接口路由中</span><br>    &#125;;<br>  &#125;;<br>  <span class="hljs-function"><span class="hljs-keyword">rpc</span> logout_user (LogoutUserRequest) <span class="hljs-keyword">returns</span> (google.protobuf.Empty) </span>&#123;<br>    <span class="hljs-keyword">option</span> (pait.api.http) = &#123;<br>      summary: <span class="hljs-string">&quot;User exit from the system&quot;</span>,  <span class="hljs-comment">// 定义函数对应接口的简介</span><br>      <span class="hljs-comment">// url定义函数对应接口的url是&quot;/user/logout&quot;,如果不定义，则会被`Pait`自动绑定为`/User/logout_user`</span><br>      <span class="hljs-comment">// any代表具体的HTTP方法由GrpcGateway方法定义，如果要指定HTTP方法为DELETE,那么需要把any替换为delete</span><br>      any: &#123;url: <span class="hljs-string">&quot;/user/logout&quot;</span>&#125;,<br>      <span class="hljs-comment">// 定义函数接口对应的OpenAPI标签</span><br>      tag: [&#123;name: <span class="hljs-string">&quot;grpc-user&quot;</span>, desc: <span class="hljs-string">&quot;grpc_user_service&quot;</span>&#125;, &#123;name: <span class="hljs-string">&quot;user-action&quot;</span>, desc: <span class="hljs-string">&quot;User Operating Interface&quot;</span>&#125;],<br><br>      <span class="hljs-comment">// 为该函数映射一个新的接口，该接口只有如下属性不一样，其余的功能还是相同的，毕竟User服务的`logout_user`函数没有实现删除用户的功能</span><br>      additional_bindings: &#123;<br>        desc: <span class="hljs-string">&quot;This interface performs a logical delete, not a physical delete&quot;</span>,<br>        summary: <span class="hljs-string">&quot;Like delete_user&quot;</span>,<br>        delete: &#123;url: <span class="hljs-string">&quot;/user/logout&quot;</span>&#125;,<br>        tag: [<br>          &#123;name: <span class="hljs-string">&quot;grpc-user&quot;</span>, desc: <span class="hljs-string">&quot;grpc_user_service&quot;</span>&#125;,<br>          &#123;name: <span class="hljs-string">&quot;grpc-user-system&quot;</span>, desc: <span class="hljs-string">&quot;grpc_user_service&quot;</span>&#125;<br>        ]<br>      &#125;<br>    &#125;;<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>接着再修改<code>gRPC</code>函数对应的<code>Message</code>，以<code>CreateUserRequest</code>和<code>LogoutUserRequest</code>为例子,修改如下:</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><code class="hljs Protobuf"><span class="hljs-comment">// create user</span><br><span class="hljs-class"><span class="hljs-keyword">message</span> <span class="hljs-title">CreateUserRequest</span> </span>&#123;<br>  <span class="hljs-built_in">string</span> uid = <span class="hljs-number">1</span> [<br>    (p2p_validate.rules).<span class="hljs-built_in">string</span>.miss_default = <span class="hljs-literal">true</span>, <span class="hljs-comment">// 定义生成的字段不带有默认值</span><br>    (p2p_validate.rules).<span class="hljs-built_in">string</span>.example = <span class="hljs-string">&quot;10086&quot;</span>,  <span class="hljs-comment">// 定义生成的字段的示例值为10086</span><br>    (p2p_validate.rules).<span class="hljs-built_in">string</span>.title = <span class="hljs-string">&quot;UID&quot;</span>,  <span class="hljs-comment">// 定义生成的字段OpenAPI的Title为UId</span><br>    (p2p_validate.rules).<span class="hljs-built_in">string</span>.description = <span class="hljs-string">&quot;user union id&quot;</span>  <span class="hljs-comment">// 定义生成的字段的描述</span><br>  ];<br>  <span class="hljs-built_in">string</span> user_name = <span class="hljs-number">2</span> [<br>    (p2p_validate.rules).<span class="hljs-built_in">string</span>.description = <span class="hljs-string">&quot;user name&quot;</span>,<br>    (p2p_validate.rules).<span class="hljs-built_in">string</span>.min_length = <span class="hljs-number">1</span>, <span class="hljs-comment">// 定义字段的最小长度</span><br>    (p2p_validate.rules).<span class="hljs-built_in">string</span>.max_length = <span class="hljs-number">10</span>, <span class="hljs-comment">// 定义字段的最大长度</span><br>    (p2p_validate.rules).<span class="hljs-built_in">string</span>.example = <span class="hljs-string">&quot;so1n&quot;</span><br>  ];<br>  <span class="hljs-built_in">string</span> password = <span class="hljs-number">3</span> [<br>    (p2p_validate.rules).<span class="hljs-built_in">string</span>.description = <span class="hljs-string">&quot;user password&quot;</span>,<br>    (p2p_validate.rules).<span class="hljs-built_in">string</span>.alias = <span class="hljs-string">&quot;pw&quot;</span>,  <span class="hljs-comment">// 定义字段的别名</span><br>    (p2p_validate.rules).<span class="hljs-built_in">string</span>.min_length = <span class="hljs-number">6</span>,<br>    (p2p_validate.rules).<span class="hljs-built_in">string</span>.max_length = <span class="hljs-number">18</span>,<br>    (p2p_validate.rules).<span class="hljs-built_in">string</span>.example = <span class="hljs-string">&quot;123456&quot;</span>,<br>    <span class="hljs-comment">// 定义字段的类型，该类型是来自于`pydantic`</span><br>    <span class="hljs-comment">// 参考 https://pydantic-docs.helpmanual.io/usage/types/#secret-types</span><br>    (p2p_validate.rules).<span class="hljs-built_in">string</span>.pydantic_type = <span class="hljs-string">&quot;SecretStr&quot;</span><br>  ];<br>&#125;<br><span class="hljs-comment">// logout user</span><br><span class="hljs-class"><span class="hljs-keyword">message</span> <span class="hljs-title">LogoutUserRequest</span> </span>&#123;<br>  <span class="hljs-built_in">string</span> uid = <span class="hljs-number">1</span> [<br>    (p2p_validate.rules).<span class="hljs-built_in">string</span>.example = <span class="hljs-string">&quot;10086&quot;</span>,<br>    (p2p_validate.rules).<span class="hljs-built_in">string</span>.title = <span class="hljs-string">&quot;UID&quot;</span>,<br>    (p2p_validate.rules).<span class="hljs-built_in">string</span>.description = <span class="hljs-string">&quot;user union id&quot;</span><br>  ];<br>  <span class="hljs-built_in">string</span> token = <span class="hljs-number">2</span> [<br>    (p2p_validate.rules).<span class="hljs-built_in">string</span>.description = <span class="hljs-string">&quot;user token&quot;</span>,<br>    (p2p_validate.rules).<span class="hljs-built_in">string</span>.enable = <span class="hljs-literal">false</span> <span class="hljs-comment">// 定义不要把该值映射到model中</span><br>  ];<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>详细的user.proto文件见：<a href="https://github.com/so1n/grpc-example-common/blob/pait-example/protos/user/user.proto">https://github.com/so1n/grpc-example-common/blob/pait-example/protos/user/user.proto</a> </li>
<li>这里只是做简单的介绍，更多使用方法见<a href="https://so1n.me/pait-zh-doc/7_gRPC_gateway/">Pait-gRPC-gateway文档</a></li>
</ul>
</blockquote>
<p>修改完成后记得通过<code>Protobuf</code>文件生成对应的<code>Python</code>代码并打包,再传到代码仓库中，具体流程见文章:<a href="https://so1n.me/2022/04/07/Python-gRPC%E5%AE%9E%E8%B7%B5(3)--%E4%BD%BF%E7%94%A8Python%E5%AE%9E%E7%8E%B0gRPC%E6%9C%8D%E5%8A%A1/">Python-gRPC实践(3)–使用Python实现gRPC服务</a></p>
<h3 id="2-2-修改Flask应用"><a href="#2-2-修改Flask应用" class="headerlink" title="2.2.修改Flask应用"></a>2.2.修改Flask应用</h3><p>Protobuf文件修改完后可以开始修改<code>Flask</code>服务，<code>Flask</code>应用的项目结构如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css">├── <span class="hljs-selector-tag">app</span><span class="hljs-selector-class">.py</span><br>├── <span class="hljs-selector-tag">app_service</span><br>│   ├── __<span class="hljs-selector-tag">init__</span><span class="hljs-selector-class">.py</span><br>│   ├── <span class="hljs-selector-tag">manager_book_route</span><span class="hljs-selector-class">.py</span><br>│   ├── <span class="hljs-selector-tag">route</span><span class="hljs-selector-class">.py</span><br>│   ├── <span class="hljs-selector-tag">social_book_route</span><span class="hljs-selector-class">.py</span><br>│   ├── <span class="hljs-selector-tag">user_route</span><span class="hljs-selector-class">.py</span><br>│   └── <span class="hljs-selector-tag">utils</span><span class="hljs-selector-class">.py</span><br>├── <span class="hljs-selector-tag">grpc_service</span><br>│   ├── <span class="hljs-selector-tag">book_service</span><span class="hljs-selector-class">.py</span><br>│   ├── __<span class="hljs-selector-tag">init__</span><span class="hljs-selector-class">.py</span><br>│   └── <span class="hljs-selector-tag">user_service</span><span class="hljs-selector-class">.py</span><br>└── <span class="hljs-selector-tag">gunicorn</span><span class="hljs-selector-class">.conf</span><span class="hljs-selector-class">.py</span><br></code></pre></td></tr></table></figure>
<p>为了区分两种不同的调用，会在<code>app_service</code>文件夹新建一个名为<code>user_gateway_route.py</code>的文件，并编写如下代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> Type<br><span class="hljs-keyword">import</span> grpc<br><br><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Flask, jsonify, Response<br><span class="hljs-keyword">from</span> pydantic <span class="hljs-keyword">import</span> BaseModel, Field<br><br><span class="hljs-keyword">from</span> pait.app.flask.grpc_route <span class="hljs-keyword">import</span> GrpcGatewayRoute<br><span class="hljs-keyword">from</span> pait.app <span class="hljs-keyword">import</span> set_app_attribute<br><span class="hljs-keyword">from</span> pait.model.response <span class="hljs-keyword">import</span> PaitBaseResponseModel, PaitJsonResponseModel<br><span class="hljs-keyword">from</span> pait.util.grpc_inspect.stub <span class="hljs-keyword">import</span> GrpcModel<br><span class="hljs-keyword">from</span> protobuf_to_pydantic <span class="hljs-keyword">import</span> msg_to_pydantic_model<br><br><span class="hljs-keyword">from</span> grpc_example_common.protos.user <span class="hljs-keyword">import</span> user_pb2_grpc<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">gen_response_model_handle</span>(<span class="hljs-params">grpc_model: GrpcModel</span>) -&gt; Type[PaitBaseResponseModel]:</span><br>    <span class="hljs-comment"># 动态生成对应的响应模型</span><br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomerJsonResponseModel</span>(<span class="hljs-params">PaitJsonResponseModel</span>):</span><br>        <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomerJsonResponseRespModel</span>(<span class="hljs-params">BaseModel</span>):</span><br>            code: <span class="hljs-built_in">int</span> = Field(<span class="hljs-number">0</span>, description=<span class="hljs-string">&quot;api code&quot;</span>)<br>            msg: <span class="hljs-built_in">str</span> = Field(<span class="hljs-string">&quot;success&quot;</span>, description=<span class="hljs-string">&quot;api status msg&quot;</span>)<br>            data: msg_to_pydantic_model(grpc_model.response) = Field(description=<span class="hljs-string">&quot;api response data&quot;</span>)  <span class="hljs-comment"># type: ignore</span><br><br>        name: <span class="hljs-built_in">str</span> = grpc_model.response.DESCRIPTOR.name<br>        response_data: Type[BaseModel] = CustomerJsonResponseRespModel<br><br>    <span class="hljs-keyword">return</span> CustomerJsonResponseModel<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add_grpc_gateway_route</span>(<span class="hljs-params">app: Flask</span>) -&gt; <span class="hljs-keyword">None</span>:</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_make_response</span>(<span class="hljs-params">resp_dict: <span class="hljs-built_in">dict</span></span>) -&gt; Response:</span><br>        <span class="hljs-keyword">return</span> jsonify(&#123;<span class="hljs-string">&quot;code&quot;</span>: <span class="hljs-number">0</span>, <span class="hljs-string">&quot;msg&quot;</span>: <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;data&quot;</span>: resp_dict&#125;)<br>    <br>    <span class="hljs-comment"># 定义一个网关路由，该路由已经把gRPC的方法映射到指定的Flask应用中</span><br>    grpc_gateway_route: GrpcGatewayRoute = GrpcGatewayRoute(<br>        app,<br>        <span class="hljs-comment"># 通过User.proto生成的Python代码中的`UserStub`类,Pait可以通过该类解析出User.proto对应的方法</span><br>        user_pb2_grpc.UserStub,<br>        <span class="hljs-comment"># 指定对应路由的前缀</span><br>        prefix=<span class="hljs-string">&quot;/api/gateway&quot;</span>,<br>        title=<span class="hljs-string">&quot;UserGrpc&quot;</span>,<br>        gen_response_model_handle=gen_response_model_handle,  <span class="hljs-comment"># 定义返回响应的OpenAPI模型，方便生成OpenAPI文档</span><br>        make_response=_make_response,   <span class="hljs-comment"># 定义返回的响应格式</span><br>    )<br>    <span class="hljs-comment"># 初始化gRPC的channel并传入`grpc_gateway_route`中</span><br>    grpc_gateway_route.init_channel(grpc.intercept_channel(grpc.insecure_channel(<span class="hljs-string">&quot;0.0.0.0:9001&quot;</span>)))<br></code></pre></td></tr></table></figure>
<p>这样一来<code>Pait</code>就能把<code>User</code>的服务映射到对应的<code>Flask</code>应用实例了， 但是User服务的部分接口并没有要求用户验证，需要我们先在<code>Flask</code>实例进行校验后才可以调用<code>gRPC</code>服务，而对于<code>logout_user</code>方法则需要token参数。<br>对于这两个需求，可以通过对<code>GrpcGatewayRoute</code>的生成路由方法进行改写来达到我们的目的，改写代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomerGrpcGatewayRoute</span>(<span class="hljs-params">GrpcGatewayRoute</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">gen_route</span>(<span class="hljs-params">self, grpc_model: GrpcModel, request_pydantic_model_class: Type[BaseModel]</span>) -&gt; Callable:</span><br><br>        <span class="hljs-comment"># 对于登录和创建用户接口不需要Token，所以采用原生的方法</span><br>        <span class="hljs-keyword">if</span> grpc_model.method <span class="hljs-keyword">in</span> (<span class="hljs-string">&quot;/user.User/login_user&quot;</span>, <span class="hljs-string">&quot;/user.User/create_user&quot;</span>):<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>().gen_route(grpc_model, request_pydantic_model_class)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_route</span>(<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">                <span class="hljs-comment"># 通过对应的grpc message生成的pydantic.BaseModel对象</span></span></span><br><span class="hljs-function"><span class="hljs-params">                request_pydantic_model: request_pydantic_model_class,  <span class="hljs-comment"># type: ignore</span></span></span><br><span class="hljs-function"><span class="hljs-params">                <span class="hljs-comment"># 添加token参数</span></span></span><br><span class="hljs-function"><span class="hljs-params">                token: <span class="hljs-built_in">str</span> = Header.i(<span class="hljs-params">description=<span class="hljs-string">&quot;User Token&quot;</span></span>),</span></span><br><span class="hljs-function"><span class="hljs-params">                <span class="hljs-comment"># 添加请求id参数，与需求无关</span></span></span><br><span class="hljs-function"><span class="hljs-params">                req_id: <span class="hljs-built_in">str</span> = Header.i(<span class="hljs-params">alias=<span class="hljs-string">&quot;X-Request-Id&quot;</span>, default_factory=<span class="hljs-keyword">lambda</span>: <span class="hljs-built_in">str</span>(<span class="hljs-params">uuid4(<span class="hljs-params"></span>)</span>)</span>),</span></span><br><span class="hljs-function"><span class="hljs-params">            </span>) -&gt; Any:</span><br>                func: Callable = self.get_grpc_func(grpc_model.method)<br>                request_dict: <span class="hljs-built_in">dict</span> = request_pydantic_model.<span class="hljs-built_in">dict</span>()  <span class="hljs-comment"># type: ignore</span><br>                <span class="hljs-keyword">if</span> grpc_model.method == <span class="hljs-string">&quot;/user.User/logout_user&quot;</span>:<br>                    <span class="hljs-comment"># 退出登陆接口需要token</span><br>                    request_dict[<span class="hljs-string">&quot;token&quot;</span>] = token<br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-comment"># 其他接口不需要token参数，只需要校验token是否合法，如果不合法则抛出异常</span><br>                    result: user_pb2.GetUidByTokenResult = user_pb2_grpc.UserStub(self.channel).get_uid_by_token(<br>                        user_pb2.GetUidByTokenRequest(token=token)<br>                    )<br>                    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> result.uid:<br>                        <span class="hljs-keyword">raise</span> RuntimeError(<span class="hljs-string">f&quot;Not found user by token:<span class="hljs-subst">&#123;token&#125;</span>&quot;</span>)<br>                <span class="hljs-comment"># 生成调用参数后再调用gRPC方法，并把gRPC方法返回的数据返回给调用端</span><br>                request_msg: Message = self.get_msg_from_dict(grpc_model.request, request_dict)<br>                grpc_msg: Message = func(request_msg, metadata=[(<span class="hljs-string">&quot;req_id&quot;</span>, req_id)])<br>                <span class="hljs-keyword">return</span> self._make_response(self.get_dict_from_msg(grpc_msg))<br><br>            <span class="hljs-keyword">return</span> _route<br></code></pre></td></tr></table></figure>
<p>这样一来业务逻辑就跟原本的逻辑一样了，可以进行最后一步操作–往<code>Flask</code>应用注入对应的路由，代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">create_app</span>() -&gt; Flask:</span><br>    app: Flask = Flask(__name__)<br>    app.json_encoder = CustomJSONEncoder<br>    app.register_blueprint(manager_book_bp)<br>    app.register_blueprint(social_book_bp)<br>    app.register_blueprint(user_bp)<br><br>    book_grpc_service: BookGrpcService = BookGrpcService(<span class="hljs-string">&quot;0.0.0.0&quot;</span>, <span class="hljs-number">9000</span>)<br>    book_grpc_service.channel_ready_future(timeout=<span class="hljs-number">3</span>)<br>    user_grpc_service: UserGrpcService = UserGrpcService(<span class="hljs-string">&quot;0.0.0.0&quot;</span>, <span class="hljs-number">9001</span>)<br>    user_grpc_service.channel_ready_future(timeout=<span class="hljs-number">3</span>)<br>    ContextMiddleware(app=app, book_grpc_service=book_grpc_service, user_grpc_service=user_grpc_service)<br><br>    <span class="hljs-comment"># 映射gRPC服务对应的接口到app</span><br>    add_grpc_gateway_route(app)<br>    <span class="hljs-comment"># 添加一个OpenAPI文档路由，从而可以查看被Pait托管路由的接口文档</span><br>    add_doc_route(app)<br>    app.errorhandler(Exception)(api_exception)<br>    <span class="hljs-keyword">return</span> app<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    <span class="hljs-comment"># 屏蔽接口文档中`OPTIONS`和`HEAD`方法接口的展示</span><br>    config.init_config(apply_func_list=[apply_block_http_method_set(&#123;<span class="hljs-string">&quot;OPTIONS&quot;</span>, <span class="hljs-string">&quot;HEAD&quot;</span>&#125;)])<br>    create_app().run(<span class="hljs-string">&quot;localhost&quot;</span>, port=<span class="hljs-number">8000</span>)<br><br></code></pre></td></tr></table></figure>
<p>代码修改完毕后，分别先启动User和Book服务，再启动Flask应用，并在浏览器输入<code>http://127.0.0.1:8000/swagger</code>即可看到通过<code>Pait Json</code>网关生成的接口的接口文档页面：<br><img   class="lazyload" data-original="https://fastly.jsdelivr.net/gh/so1n/so1n_blog_photo@master/blog_photo/16683504910421668350490672.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" ></p>
<p>在检查文档展示的接口与Protobuf文件描述的是一致后，可以通过接口文档页面来尝试生成的<code>gRPC Json</code>网关是否可以正常使用，如下动图，其中左上图为<code>User</code>服务，左下图为<code>Flask</code>应用，而右半边的图是<code>Swagger</code>页面:<br><img   class="lazyload" data-original="https://fastly.jsdelivr.net/gh/so1n/so1n_blog_photo@master/blog_photo/1668352148437%E5%BD%95%E5%B1%8F_%E9%80%89%E6%8B%A9%E5%8C%BA%E5%9F%9F_20221113230819.gif" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" ></p>
<p>除了动图的操作外，还可以尝试修改<code>uid</code>等字段的长度在执行，会发现<code>Flask</code>应用由于我们传过来的值不满足校验规则而抛出错误。</p>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p>示例代码只是为了演示，并无任何实际意义，也不适用于生产环境：</p>
<h3 id="附录一，简单的gRPC示例项目代码"><a href="#附录一，简单的gRPC示例项目代码" class="headerlink" title="附录一，简单的gRPC示例项目代码"></a>附录一，简单的gRPC示例项目代码</h3><p>api服务：<a href="https://github.com/so1n/grpc-example-api-backend-service">https://github.com/so1n/grpc-example-api-backend-service</a><br>用户服务: <a href="https://github.com/so1n/grpc-example-user-grpc-service">https://github.com/so1n/grpc-example-user-grpc-service</a><br>书籍管理服务：<a href="https://github.com/so1n/grpc-example-book-grpc-service">https://github.com/so1n/grpc-example-book-grpc-service</a><br><code>gRPC</code>公有包（包括<code>gRPC</code>调用封装和protobuf文件）：<a href="https://github.com/so1n/grpc-example-common">https://github.com/so1n/grpc-example-common</a></p>
<h3 id="附录二，使用Pait快速构建gRPC-Json网关代码"><a href="#附录二，使用Pait快速构建gRPC-Json网关代码" class="headerlink" title="附录二，使用Pait快速构建gRPC Json网关代码"></a>附录二，使用Pait快速构建gRPC Json网关代码</h3><p>api服务:<a href="https://github.com/so1n/grpc-example-api-backend-service">https://github.com/so1n/grpc-example-api-backend-service</a><br><code>gRPC</code>公有包：<a href="https://github.com/so1n/grpc-example-common/tree/pait-example">https://github.com/so1n/grpc-example-common/tree/pait-example</a></p>
<blockquote>
<p>其他服务只需要把<code>gRPC</code>公有包依赖更新到<code>pait-example</code>分支即可</p>
</blockquote>
<h3 id="服务三，使用文档"><a href="#服务三，使用文档" class="headerlink" title="服务三，使用文档"></a>服务三，使用文档</h3><p><code>Pait Json</code>网关文档: <a href="https://so1n.me/pait-zh-doc/7_gRPC_gateway/">https://so1n.me/pait-zh-doc/7_gRPC_gateway/</a><br><a href="https://github.com/so1n/protobuf_to_pydantic">protobuf_to_pydantic文档</a></p>
]]></content>
      <categories>
        <category>gRPC</category>
      </categories>
      <tags>
        <tag>gRPC,pait</tag>
      </tags>
  </entry>
  <entry>
    <title>为何在Python生态很少听说到依赖注入</title>
    <url>/2022/10/15/%E4%B8%BA%E4%BD%95%E5%9C%A8Python%E7%94%9F%E6%80%81%E5%BE%88%E5%B0%91%E5%90%AC%E8%AF%B4%E5%88%B0%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/</url>
    <content><![CDATA[<h2 id="前记"><a href="#前记" class="headerlink" title="前记"></a>前记</h2><p>由于使用的主要编程语言是<code>Python</code>，所以对于依赖注入这个概念并不是很清楚或者不知道自己已经在代码中运用了依赖注入的用法，在接触了DDD后才开始真正的了解什么是依赖注入以及依赖注入的重要性，同时也很好奇为何在<code>Python</code> 生态中依赖注入的出现率较低。</p>
<h2 id="1-控制反转与依赖注入"><a href="#1-控制反转与依赖注入" class="headerlink" title="1.控制反转与依赖注入"></a>1.控制反转与依赖注入</h2><p>在查找依赖注入的相关资料时发现依赖注入与控制反转这两个词是成对出现的，这是因为控制反转并不是一种技术，而是一种编程思想，这种思想能指导我们如何设计出松耦合优良的程序，而依赖注入是一个具体的设计模式，它是控制反转的一种具体实现。</p>
<p>控制反转这个概念有点模糊，但后端开发者来说却是经常接触到的，比如在对框架与库的使用时，分别接触到他们的反向控制和正向控制，而框架的反向控制正是控制反转的体现。<br>大多数人很少去区分在项目中使用的包是属于框架还是库，也不会很清晰的去区分它们属于哪一种，我也是这样的，在经过了一段编程生涯后我才可以简单的把主动调用的包归类为库，只能被动调用的包归类为框架。</p>
<p>不过最近在翻阅依赖注入与控制反转的相关文章<a href="https://martinfowler.com/bliki/InversionOfControl.html">InversionOfControl</a>时发现，控制反转也可以是框架和库的关键区别点。因为对于一个库来说，程序员使用的方式是主动的调用它，如下代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> httpx<br><br>response = httpx.get(<span class="hljs-string">&quot;https://so1n.me&quot;</span>)<br>print(response.status_code)<br></code></pre></td></tr></table></figure>
<p>这段代码主动的调用<code>httpx</code>包的<code>get</code>方法发起一个请求以获取网站对应的状态码，由于这种调用方法属于开发者去主动调用库，所以属于正向的控制。</p>
<p>而框架就不一样了，框架一般都会提供一些注册的方法将我们编写的代码注册到框架中，最后由框架来调用程序员编写的代码，如下例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">from</span> starlette.applications <span class="hljs-keyword">import</span> Starlette<br><span class="hljs-keyword">from</span> starlette.requests <span class="hljs-keyword">import</span> Request<br><span class="hljs-keyword">from</span> starlette.responses <span class="hljs-keyword">import</span> PlainTextResponse<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">demo</span>(<span class="hljs-params">request: Request</span>) -&gt; PlainTextResponse:</span><br>    <span class="hljs-keyword">return</span> PlainTextResponse(<span class="hljs-string">f&quot;Hello <span class="hljs-subst">&#123;request.query_params.get(<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>)&#125;</span>!&quot;</span>)<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">create_app</span>() -&gt; Starlette:</span><br>    app: Starlette = Starlette()<br>    app.add_route(<span class="hljs-string">&quot;/&quot;</span>, demo, methods=[<span class="hljs-string">&quot;GET&quot;</span>])<br>    <span class="hljs-keyword">return</span> app<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    <span class="hljs-keyword">import</span> uvicorn<br><br>    app: Starlette = create_app()<br>    uvicorn.run(app)<br></code></pre></td></tr></table></figure>
<p>这段代码中先是声明一个路由函数<code>demo</code>，这个路由函数是按照框架要求的方式编写的，这个要求是路由函数必须接收一个<code>Request</code>参数以及返回一个<code>Response</code>类；接着在实例化框架时通过<code>add_route</code>方法以<code>path=/</code>，<code>method=GET</code>的形式注册到框架中以及在调用<code>uvicorn.run(app)</code>的时候把控制权转移给了框架，并由框架在后续完成对<code>demo</code>路由函数的调用，这种调用方式属于反向控制。</p>
<blockquote>
<p>Note: 对于流式客户端封装的库可能包含着主动调用与被动调用，使其不像框架也不像库。</p>
</blockquote>
<p>此外，从例子中可以看到，创建的<code>demo</code>路由函数是交给了框架控制的，不再由开发者控制，而且<code>demo</code>路由函数接收的<code>Request</code>类参数是在运行时由框架管理创建和注销并注入给路由函数供路由函数使用的，这就是控制反转的主体思想，通过这种思想能公减少工程项目不同层次代码打耦合。</p>
<p>依赖注入则是控制反转的一种具体实现方式，这种方式能让一个对象接收它所依赖的其他对象。其中“依赖”是指接收方所需的对象，“注入”是指将“依赖”传递给接收方的过程。在“注入”之后，接收方才会调用该“依赖”。<br>而依赖注入框架则是一种根据对象的依赖关系的在运行时进行绑定的技术，通常它都会带有一个容器，这个容器托管着许多对象，并在运行时根据对象的依赖关系把对象传递给被控制的其它对象中。比如例子中的<code>starlette</code>框架在运行时就是一个容器，它可以根据不同的请求创建不同的请求对象并在根据请求规则匹配到对应的路由函数后把请求对象注入给路由函数使用。</p>
<h2 id="2-为什么需要控制反转与依赖注入"><a href="#2-为什么需要控制反转与依赖注入" class="headerlink" title="2.为什么需要控制反转与依赖注入"></a>2.为什么需要控制反转与依赖注入</h2><p>以一个客户端的设计为例，通常一个客户端会分为调用层，协议层和连接层3层，通常情况下都会这样去实现：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> Any<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Connection</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, host: <span class="hljs-built_in">str</span>, port: <span class="hljs-built_in">int</span></span>):</span><br>        self._host: <span class="hljs-built_in">str</span> = host<br>        self._port: <span class="hljs-built_in">int</span> = port<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">send</span>(<span class="hljs-params">self, data: Any</span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        <span class="hljs-string">&quot;&quot;&quot;发送数据到服务端&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">pass</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">read</span>(<span class="hljs-params">self</span>) -&gt; Any:</span><br>        <span class="hljs-string">&quot;&quot;&quot;从服务端接收数据&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">pass</span><br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Protocol</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, host: <span class="hljs-built_in">str</span>, port: <span class="hljs-built_in">int</span></span>):</span><br>        self._conn: Connection = Connection(host, port)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">request</span>(<span class="hljs-params">self, *args: Any, **kwargs: Any</span>) -&gt; Any:</span><br>        <span class="hljs-string">&quot;&quot;&quot;发送请求并等待响应&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">pass</span><br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, host: <span class="hljs-built_in">str</span>, port: <span class="hljs-built_in">int</span></span>):</span><br>        self._protocol: Protocol = Protocol(host, port)<br></code></pre></td></tr></table></figure>
<p>这段代码中分别包括了客户端的连接层的<code>Connection</code>，协议层的<code>Protocol</code>以及调用层的<code>Client</code>，对于使用者来说，他们不用去过于了解<code>Connection</code>和<code>Protocol</code>的实现，只需要知道<code>host</code>和<code>port</code>的参数要填什么以及<code>Client</code>该如何使用即可。</p>
<p>不过这段代码却出现了一条依赖链（<code>Client</code>依赖于<code>Protocol</code>，<code>Protocol</code>依赖于<code>Connection</code>)，同时客户端里面的不同层都把控了对下层对象的创建主动权，创建主动时机以及使用权，这样会造成上下层对象有很强的耦合，导致代码比较难维护。<br>比如要在<code>Connection</code>增加一个SSL功能，这个功能需要一些SSL参数，那么三层都要进行更改，使用者才可以把SSL参数传给<code>Connection</code>，如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> Any<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Connection</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, host: <span class="hljs-built_in">str</span>, port: <span class="hljs-built_in">int</span>, ssl: Any</span>):</span>  <span class="hljs-comment"># &lt;--</span><br>        self._host: <span class="hljs-built_in">str</span> = host<br>        self._port: <span class="hljs-built_in">int</span> = port<br>        self._ssl: Any = ssl<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">send</span>(<span class="hljs-params">self, data: Any</span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        <span class="hljs-string">&quot;&quot;&quot;发送数据到服务端&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">pass</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">read</span>(<span class="hljs-params">self</span>) -&gt; Any:</span><br>        <span class="hljs-string">&quot;&quot;&quot;从服务端接收数据&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">pass</span><br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Protocol</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, host: <span class="hljs-built_in">str</span>, port: <span class="hljs-built_in">int</span>, ssl: Any</span>):</span>  <span class="hljs-comment"># &lt;--</span><br>        self._conn: Connection = Connection(host, port, ssl)  <span class="hljs-comment"># &lt;--</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">request</span>(<span class="hljs-params">self, *args: Any, **kwargs: Any</span>) -&gt; Any:</span><br>        <span class="hljs-string">&quot;&quot;&quot;发送请求并等待响应&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">pass</span><br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, host: <span class="hljs-built_in">str</span>, port: <span class="hljs-built_in">int</span>, ssl: Any</span>):</span>  <span class="hljs-comment"># &lt;--</span><br>        self._protocol: Protocol = Protocol(host, port, Any)  <span class="hljs-comment"># &lt;--</span><br><br></code></pre></td></tr></table></figure>
<p>通过这段代码可以看到，为了让连接层支持SSL功能，需要从<code>Client</code>开始一层一层的把SSL功能的参数传递下去，这还好只是分了三层，比较容易操作，如果分的层次比较多，将会非常的难受，而且在工程项目中，一个类可能会被不同的类所依赖的，这意味着为一个基础类增减某些功能会导致其它依赖它的类也要进行修改，这会浪费大量的开发时间和测试时间，同时使依赖它的类都需要发生变动，这会增加系统出现BUG的风险。</p>
<p>为了解决这个问题，可以根据控制反转的思想，把上层对象创建下层对象的权利和创建时机转移给第三方来控制，仅保留上层对象对下层对象的使用权，修改完的代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> Any<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Connection</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, host: <span class="hljs-built_in">str</span>, port: <span class="hljs-built_in">int</span>, ssl: Any</span>):</span>  <span class="hljs-comment"># &lt;--</span><br>        self._host: <span class="hljs-built_in">str</span> = host<br>        self._port: <span class="hljs-built_in">int</span> = port<br>        self._ssl: Any = ssl<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">send</span>(<span class="hljs-params">self, data: Any</span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        <span class="hljs-string">&quot;&quot;&quot;发送数据到服务端&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">pass</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">read</span>(<span class="hljs-params">self</span>) -&gt; Any:</span><br>        <span class="hljs-string">&quot;&quot;&quot;从服务端接收数据&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">pass</span><br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Protocol</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, connection: Connection</span>):</span>  <span class="hljs-comment"># &lt;--</span><br>        self._conn: Connection = connection  <span class="hljs-comment"># &lt;--</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">request</span>(<span class="hljs-params">self, *args: Any, **kwargs: Any</span>) -&gt; Any:</span><br>        <span class="hljs-string">&quot;&quot;&quot;发送请求并等待响应&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">pass</span><br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, protocol: Protocol</span>):</span>  <span class="hljs-comment"># &lt;--</span><br>        self._protocol: Protocol = protocol   <span class="hljs-comment"># &lt;--</span><br></code></pre></td></tr></table></figure>
<p>可以发现，这段代码经过变更后，每一层只接收自己需要依赖的对象，在这种设计下可以在<code>Client</code>和<code>Protocol</code>代码没变动的情况下同时接收实现SSL功能和没实现SSL功能等实现了<code>send</code>和<code>read</code>方法的<code>Connection</code>对象。</p>
<p>接下来只要通过第三方来创建对象即可，代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python">client: Client = Client(<br>    protocol=Protocol(<br>        connection=Connection(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">8000</span>, <span class="hljs-built_in">object</span>())<br>    )<br>)<br><br>no_ssl_client: Client = Client(<br>    protocol=Protocol(<br>        connection=NoSslConnection(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">8000</span>)<br>    )<br>)<br></code></pre></td></tr></table></figure>

<p>这段代码中管理依赖对象的生命周期以及对象的关系全靠手动编写代码，使其在运行时完成对象绑定的，如果项目中分了很多层或者依赖关系比较复杂的话，手动处理会比较麻烦，也不方便后续的迭代。<br>这时就需要通过依赖注入框架来帮忙自动整理依赖关系以及注入到需要的对象中，比如在使用<code>dependency-injector</code>这个依赖注入框架后，代码就可以变为如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">from</span> dependency_injector <span class="hljs-keyword">import</span> containers, providers<br><span class="hljs-keyword">from</span> dependency_injector.wiring <span class="hljs-keyword">import</span> Provide, inject<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Container</span>(<span class="hljs-params">containers.DeclarativeContainer</span>):</span><br>    <span class="hljs-comment"># 依赖注入框架提供的容器，该容器会管理对象的创建</span><br><br>    <span class="hljs-comment"># 用于加载配置</span><br>    config = providers.Configuration()<br><br>    <span class="hljs-comment"># 通过`providers.Singleton`创建的对象在整个生命周期中会保持唯一(单例)</span><br>    conn = providers.Singleton(<br>        Connection ,<br>        host=config.host,<br>        port=config.port,<br>    )<br>    <span class="hljs-comment"># 创建protocol层的工厂函数</span><br>    protocol = providers.Factory(<br>        Protocol,<br>        connection=Connection,<br>    )<br><br>    <span class="hljs-comment"># 创建client层的工厂函数</span><br>    client = providers.Factory(<br>        Client,<br>        protocol=protocol,<br>    )<br><br><span class="hljs-comment"># 注入装饰器，可以自动的把对应的值注入到被装饰的函数中</span><br><span class="hljs-meta">@inject</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>(<span class="hljs-params">client: Client = Provide[Container.client]</span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>    ...<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    <span class="hljs-comment"># 初始化容器</span><br>    container = Container()<br>    <span class="hljs-comment"># 通过env加载配置</span><br>    container.config.api_key.from_env(<span class="hljs-string">&quot;host&quot;</span>, required=<span class="hljs-literal">True</span>)<br>    container.config.timeout.from_env(<span class="hljs-string">&quot;port&quot;</span>, as_=<span class="hljs-built_in">int</span>, default=<span class="hljs-number">4</span>)<br>    <span class="hljs-comment"># 通过wire把容器与模块连接起来，这样该模块的`inject`装饰器可以读到对应的容器</span><br>    container.wire(modules=[__name__])<br><br>    main()  <span class="hljs-comment"># 通过带有SSL功能的Connection运行代码</span><br><br>    <span class="hljs-keyword">with</span> container.conn.override(NoSslConnection(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">8000</span>)):<br>        main()  <span class="hljs-comment"># 通过没有SSL功能的Connection运行代码</span><br></code></pre></td></tr></table></figure>
<p>通过这段代码可以发现，每个对象都存在于容器<code>Container</code>中，并通过<code>inject</code>装饰器就可以自动的把依赖对象进行绑定，不再需要手动处理，在依赖层级比较深的时候能缓解开发者的心智负担，同时通过<code>override</code>语法可以很方便的在新的作用域替换其中的一个依赖对象。</p>
<h2 id="3-为何在Python生态中很少听到依赖注入"><a href="#3-为何在Python生态中很少听到依赖注入" class="headerlink" title="3.为何在Python生态中很少听到依赖注入"></a>3.为何在Python生态中很少听到依赖注入</h2><p>了解了依赖注入与控制反转后可以发现，在<code>Python</code>生态也会通过控制反转的方式去进行解耦，但是很少有人会直接说自己用了依赖注入来解决上述的问题。</p>
<p>会这样的第一个原因是大部分被依赖注入容器托管的对象都被要求是单例的，而<code>Python</code>的每个模块中的对象也都是单例的，这样一来实现工程项目就会比较方便，比如下面一个Web项目的例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-comment"># orm.py</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Orm</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-keyword">pass</span><br><br><br>orm: Orm = Orm()<br><br><span class="hljs-comment"># route.py</span><br><span class="hljs-keyword">from</span> starlette.requests <span class="hljs-keyword">import</span> Request<br><span class="hljs-keyword">from</span> starlette.responses <span class="hljs-keyword">import</span> PlainTextResponse<br><span class="hljs-keyword">from</span> orm <span class="hljs-keyword">import</span> orm<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">demo</span>(<span class="hljs-params">request: Request</span>) -&gt; PlainTextResponse:</span><br>    name: <span class="hljs-built_in">str</span> = request.query_params.get(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;&quot;</span>)<br>    _id: <span class="hljs-built_in">int</span> = orm.user.get(name)<br>    <span class="hljs-keyword">return</span> PlainTextResponse(<span class="hljs-string">f&quot;Hello <span class="hljs-subst">&#123;_id&#125;</span>!&quot;</span>)<br></code></pre></td></tr></table></figure>
<p>这个例子是<code>Python</code>开发者常用的开发模式，在这个例子中有<code>orm</code>和<code>route</code>两个模块，这时如果把<code>Python</code>的运行时环境认为是一个大的依赖注入容器，把<code>orm</code>模块和<code>route</code>模块认为是容器的托管的对象，把<code>route</code>模块引用到了<code>orm</code>模块则认为是依赖注入容器把orm注入到了<code>route</code>模块中时可以发现，<code>Python</code>开发者在不经意间就实现类似于静态语言的依赖注入了。</p>
<p>除此之外，还有重要的一点是在静态语言中，编译期，装载期和运行时期都是严格分离的，无法在运行期执行装载期的工作，这样就需要依赖注入容器通过反射来进行处理，比如<code>Java</code>的<code>Spring</code>框架，而<code>Python</code>是一门动态语言，它的运行时环境可以认为是一个大的依赖注入容器，所以<code>Python</code>可以在运行时替换某个对象，如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python">  <br><span class="hljs-keyword">import</span> requests  <br><span class="hljs-keyword">import</span> httpx  <br>  <br>  <br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span>  <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span>  <br>        self._get = requests.get  <br>  <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__call__</span>(<span class="hljs-params">self, *args, **kwargs</span>) -&gt; Any:</span>  <br>        <span class="hljs-keyword">return</span> self._get(*args, **kwargs)  <br>  <br>print(<span class="hljs-built_in">type</span>(Demo()(<span class="hljs-string">&quot;https://so1n.me&quot;</span>)))<br><span class="hljs-comment"># &gt;&gt;&gt; &lt;class &#x27;requests.models.Response&#x27;&gt;</span><br>requests.get = httpx.get  <br>print(<span class="hljs-built_in">type</span>(Demo()(<span class="hljs-string">&quot;https://so1n.me&quot;</span>)))<br><span class="hljs-comment"># &gt;&gt;&gt; &lt;class &#x27;httpx.Response&#x27;&gt;</span><br></code></pre></td></tr></table></figure>
<p>在这段代码中，由于<code>httpx</code>库采用了类似<code>requests</code>库的实现，所以在使用上差别不大，在<code>Python</code>中可以简单的对依赖对象进行替换，通过输出结果可以看出，没替换前返回的响应结果类型是<code>requests.model.Respnose</code>而替换后响应结果类型是<code>httpx.Response</code>，证明已经替换成功了。</p>
<p>所以<code>Python</code>开发者可以通过<code>Python</code>的语法特性快速的实现静态语言中依赖注入容器的相关功能了，可以认为在<code>Python</code>中依赖注入是很常见的，但是因为太常见了，而且只需要用到<code>Python</code>的语言特性就可以实现依赖注入容器的功能，导致没有那么多人知道自己已经使用了依赖注入，也没必要用到依赖注入框架，所以讨论的热度会比较低，这可能就是在<code>Python</code>生态中很少听到依赖注入的原因吧。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>可以看出通过控制反转可以很方便的把对象之中的依赖进行解耦，方便项目的迭代开发，而依赖注入是控制反转的具体实现，在静态语言中通过依赖注入可以将对象的索取从编译期和装载期移到了运行期。而<code>Python</code>由于本身是动态语言以及自己的语言特性，开发者会通过常见的开发模式来达到静态语言依赖注入的类似需求，所以在<code>Python</code>生态中很少听到依赖注入，不过对于DDD领域设计开发则是一个例外。</p>
]]></content>
      <categories>
        <category>依赖注入</category>
      </categories>
      <tags>
        <tag>依赖注入，控制反转</tag>
      </tags>
  </entry>
  <entry>
    <title>Python-gRPC实践(7)--gRPC的错误传递</title>
    <url>/2022/06/23/Python-gRPC%E5%AE%9E%E8%B7%B5(7)--gRPC%E9%94%99%E8%AF%AF%E4%BC%A0%E9%80%92/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前在文章<a href="https://so1n.me/2022/04/07/Python-gRPC%E5%AE%9E%E8%B7%B5(3)--%E4%BD%BF%E7%94%A8Python%E5%AE%9E%E7%8E%B0gRPC%E6%9C%8D%E5%8A%A1/">《Python-gRPC实践(3)–使用Python实现gRPC服务》</a>介绍的实现<code>gRPC</code>服务中使用了一套自定义的协议来传递错误，但这并不是一个优雅的解决方案，因为这种方案的兼容性很差，好在官方定义了一种解决方案，通过这种方案可以使不同的服务都能传递错误。</p>
<h2 id="1-自定义的错误传递"><a href="#1-自定义的错误传递" class="headerlink" title="1.自定义的错误传递"></a>1.自定义的错误传递</h2><p>在编写普通的HTTP/1.1接口时，我们都会定制一套业务相关的错误来与HTTP标注的错误区分开，比如通常都会返回这样一个结构体：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json">&#123;<br>    <span class="hljs-attr">&quot;code&quot;</span>: <span class="hljs-string">&quot;0&quot;</span>,<br>    <span class="hljs-attr">&quot;msg&quot;</span>: <span class="hljs-string">&quot;success&quot;</span>,<br>    <span class="hljs-attr">&quot;data&quot;</span>: &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这个结构体包含了<code>code</code>,<code>msg</code>和<code>data</code>三个字段，他们分别是错误码，错误信息，和要返回的结构。<br>客户端在收到响应后，会判断<code>code</code>的值是什么，如果属于定义的成功状态码则通过<code>data</code>提取数据，否则把<code>msg</code>信息通过异常抛出来。</p>
<p>在使用<code>gRPC</code>中更不例外，因为我们在使用<code>gRPC</code>调用时，就像调用一个普通函数一样，不过<code>gRPC</code>服务间是通过传递message数据来进行交互的，每个调用的请求message和响应message都已经被固定了，如果我们想返回一个错误信息，那么必定会跟响应结构体不一样，所以错误的信息的结构体一定要跟响应体匹配，否则只能另寻它路，比如在每个响应体嵌入错误信息的字段，如下:</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><code class="hljs protobuf"><span class="hljs-class"><span class="hljs-keyword">message</span> <span class="hljs-title">Demo</span> </span>&#123;<br>    <span class="hljs-built_in">string</span> a=<span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">int32</span> b=<span class="hljs-number">2</span>;<br><br>    <span class="hljs-built_in">int32</span> err_code=<span class="hljs-number">3</span>;<br>    <span class="hljs-built_in">string</span> err_msg=<span class="hljs-number">4</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>然后服务端判断调用执行出错就把错误转换为对应的<code>err_code</code>和<code>err_msg</code>再塞入到message中传给客户端，而客户端每收到调用响应就判断<code>err_code</code>是否有值，有则代表是异常请求，只把<code>err_code</code>和<code>err_msg</code>提取出来生成一个异常并抛给调用者，否则就正常返回数据。</p>
<p>采用这种方法可以兼容每一种调用，但是并不是十分的优雅，如果能通过别的协议容器把数据传给客户端，客户端通过对应的协议解析到错误信息并生产异常就好，在之前介绍的<code>gRPC</code>服务中，就是采用<code>gRPC.metadata</code>来传输数据。同时为了能自动处理服务端异常的捕获和客户端的异常生成，会分别在客户端和服务端设置一个顶层的拦截器，服务端的顶层拦截器代码如下(因为其它的拦截器可能会抛错，所以捕获错误的拦截器一定要放置在最顶层)：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-comment"># code url: https://github.com/so1n/grpc-example-common/blob/v0.1.5/grpc_example_common/interceptor/server_interceptor/customer_top.py</span><br><span class="hljs-keyword">import</span> logging<br><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> Any, Callable, List, Tuple<br><br><span class="hljs-keyword">import</span> grpc<br><br><span class="hljs-keyword">from</span> grpc_example_common.helper.context <span class="hljs-keyword">import</span> context_proxy<br><br><span class="hljs-keyword">from</span> .base <span class="hljs-keyword">import</span> BaseInterceptor<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomerTopInterceptor</span>(<span class="hljs-params">BaseInterceptor</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">intercept</span>(<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">        self,</span></span><br><span class="hljs-function"><span class="hljs-params">        next_handler_method: Callable,</span></span><br><span class="hljs-function"><span class="hljs-params">        request_proto_message: Any,</span></span><br><span class="hljs-function"><span class="hljs-params">        context: grpc.ServicerContext,</span></span><br><span class="hljs-function"><span class="hljs-params">    </span>) -&gt; Any:</span><br>        return_initial_metadata: List[Tuple] = [(<span class="hljs-string">&quot;customer-user-agent&quot;</span>, <span class="hljs-string">&quot;Python3&quot;</span>)]<br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-comment"># 执行gRPC的调用</span><br>            <span class="hljs-keyword">return</span> next_handler_method(request_proto_message, context)<br>        <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>            <span class="hljs-comment"># 限定客户端带有如下Key-Value的才设置错误信息</span><br>            <span class="hljs-keyword">if</span> self.metadata_dict.get(<span class="hljs-string">&quot;customer-user-agent&quot;</span>, <span class="hljs-string">&quot;&quot;</span>) == <span class="hljs-string">&quot;Python3&quot;</span>:<br>                return_initial_metadata.append((<span class="hljs-string">&quot;exc_name&quot;</span>, e.__class__.__name__))<br>                return_initial_metadata.append((<span class="hljs-string">&quot;exc_info&quot;</span>, <span class="hljs-built_in">str</span>(e)))<br>            <span class="hljs-comment"># 抛出异常，这样gRPC服务端就能捕获到对应的异常，方便服务端进行后续的处理</span><br>            <span class="hljs-keyword">raise</span> e<br>        <span class="hljs-keyword">finally</span>:<br>            <span class="hljs-comment"># 发送结束metadata流到客户端</span><br>            context.send_initial_metadata(return_initial_metadata)<br></code></pre></td></tr></table></figure>
<p>该拦截器会捕获调用的异常，然后把异常的方法名和异常信息存在metedata中，这里之所以把值设置到metadata中，而不通过<code>context.set_code</code>,<code>context.set_details</code>来设置错误码和错误信息是有原因的。</p>
<p>首先是<code>code</code>，<code>gRPC</code>限制了只能设置它允许的<code>code</code>，所以这会限制我们去自定义<code>code</code>，同时我们也不应该把业务的错误码设置到响应的错误码中，所以不在这里使用<code>context.set_code</code>；而对于<code>set_details</code>,则是因为<code>gRPC</code>服务端在捕获到异常后会解析对应的异常，然后把异常数据通过<code>context.set_details</code>设置到<code>details</code>中，如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_call_behavior</span>(<span class="hljs-params">rpc_event,</span></span><br><span class="hljs-function"><span class="hljs-params">                   state,</span></span><br><span class="hljs-function"><span class="hljs-params">                   behavior,</span></span><br><span class="hljs-function"><span class="hljs-params">                   argument,</span></span><br><span class="hljs-function"><span class="hljs-params">                   request_deserializer,</span></span><br><span class="hljs-function"><span class="hljs-params">                   send_response_callback=<span class="hljs-literal">None</span></span>):</span><br>    <span class="hljs-keyword">from</span> grpc <span class="hljs-keyword">import</span> _create_servicer_context<br>    <span class="hljs-keyword">with</span> _create_servicer_context(rpc_event, state,<br>                                  request_deserializer) <span class="hljs-keyword">as</span> context:<br>        <span class="hljs-keyword">try</span>:<br>            response_or_iterator = <span class="hljs-literal">None</span><br>            <span class="hljs-comment"># 调用请求</span><br>            <span class="hljs-keyword">if</span> send_response_callback <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>                response_or_iterator = behavior(argument, context,<br>                                                send_response_callback)<br>            <span class="hljs-keyword">else</span>:<br>                response_or_iterator = behavior(argument, context)<br>            <span class="hljs-keyword">return</span> response_or_iterator, <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> exception:  <span class="hljs-comment"># pylint: disable=broad-except</span><br>            <span class="hljs-keyword">with</span> state.condition:<br>                <span class="hljs-keyword">if</span> state.aborted:<br>                    _abort(state, rpc_event.call, cygrpc.StatusCode.unknown,<br>                           <span class="hljs-string">b&#x27;RPC Aborted&#x27;</span>)<br>                <span class="hljs-keyword">elif</span> exception <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> state.rpc_errors:<br>                    <span class="hljs-comment"># 这里判断并不属于grpc的错误，则会把错误信息设置到details</span><br>                    details = <span class="hljs-string">&#x27;Exception calling application: &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(<br>                        exception)<br>                    _LOGGER.exception(details)<br>                    _abort(state, rpc_event.call, cygrpc.StatusCode.unknown,<br>                           _common.encode(details))<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>, <span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure>
<p>这就意味着我们即使在拦截器设置了<code>details</code>，但是由于抛出来的异常并不属于<code>gRPC</code>的异常，所以<code>details</code>最终被异常信息覆盖了。</p>
<p>了解完了服务端的拦截器实现，接下来看看客户端的拦截器实现，代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># code url: https://github.com/so1n/grpc-example-common/blob/v0.1.5/grpc_example_common/interceptor/client_interceptor/customer_top.py</span><br><span class="hljs-keyword">import</span> inspect<br><span class="hljs-keyword">import</span> logging<br><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> Any, Callable, Dict, List, Optional, Type<br><br><br><span class="hljs-keyword">from</span> .base <span class="hljs-keyword">import</span> GRPC_RESPONSE, BaseInterceptor, ClientCallDetailsType<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomerTopInterceptor</span>(<span class="hljs-params">BaseInterceptor</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, exc_list: Optional[List[Type[Exception]]] = <span class="hljs-literal">None</span></span>):</span><br>        self.exc_dict: Dict[<span class="hljs-built_in">str</span>, Type[Exception]] = &#123;&#125;<br>        <span class="hljs-keyword">for</span> key, exc <span class="hljs-keyword">in</span> <span class="hljs-built_in">globals</span>()[<span class="hljs-string">&quot;__builtins__&quot;</span>].items():<br>            <span class="hljs-comment"># 注册Python自带的异常</span><br>            <span class="hljs-keyword">if</span> inspect.isclass(exc) <span class="hljs-keyword">and</span> <span class="hljs-built_in">issubclass</span>(exc, Exception):<br>                self.exc_dict[key] = exc<br><br>        <span class="hljs-keyword">if</span> exc_list:<br>            <span class="hljs-comment"># 注册用户指定的异常</span><br>            <span class="hljs-keyword">for</span> exc <span class="hljs-keyword">in</span> exc_list:<br>                <span class="hljs-keyword">if</span> <span class="hljs-built_in">issubclass</span>(exc, Exception):<br>                    self.exc_dict[exc.__name__] = exc<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">intercept</span>(<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">        self,</span></span><br><span class="hljs-function"><span class="hljs-params">        method: Callable,</span></span><br><span class="hljs-function"><span class="hljs-params">        request_or_iterator: Any,</span></span><br><span class="hljs-function"><span class="hljs-params">        call_details: ClientCallDetailsType,</span></span><br><span class="hljs-function"><span class="hljs-params">    </span>) -&gt; GRPC_RESPONSE:</span><br>        <span class="hljs-keyword">if</span> call_details.metadata <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-comment"># 添加协定的信息 </span><br>            call_details.metadata.append((<span class="hljs-string">&quot;customer-user-agent&quot;</span>, <span class="hljs-string">&quot;Python3&quot;</span>))  <span class="hljs-comment"># type: ignore</span><br>        response: GRPC_RESPONSE = method(call_details, request_or_iterator)<br>        metadata_dict: <span class="hljs-built_in">dict</span> = &#123;item.key: item.value <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> response.initial_metadata()&#125;<br>        <span class="hljs-keyword">if</span> metadata_dict.get(<span class="hljs-string">&quot;customer-user-agent&quot;</span>) == <span class="hljs-string">&quot;Python3&quot;</span>:<br>            <span class="hljs-comment"># 提取异常信息</span><br>            exc_name: <span class="hljs-built_in">str</span> = metadata_dict.get(<span class="hljs-string">&quot;exc_name&quot;</span>, <span class="hljs-string">&quot;&quot;</span>)<br>            exc_info: <span class="hljs-built_in">str</span> = metadata_dict.get(<span class="hljs-string">&quot;exc_info&quot;</span>, <span class="hljs-string">&quot;&quot;</span>)<br>            <span class="hljs-comment"># 通过exc_name查找异常</span><br>            exc: Optional[Type[Exception]] = self.exc_dict.get(exc_name)<br>            <span class="hljs-keyword">if</span> exc:<br>                <span class="hljs-comment"># 抛出异常</span><br>                <span class="hljs-keyword">raise</span> exc(exc_info)<br>        <span class="hljs-keyword">return</span> response<br></code></pre></td></tr></table></figure>
<p>可以看出客户端拦截器通过获取服务端返回的metada来判断是否有异常信息，如果有就提取出并抛出错误，否则就正常返回响应。这样一来只要客户端服务端都设置了正确的拦截器，客户端就能获得到服务端的错误信息并抛出异常，不过这种实现方式是依赖<code>gRPC.metadata</code>传输数据的，而<code>gRPC.metadata</code>的值必须是ASCII或者规范的字节，不然就不给传输甚至还会卡住请求，这就意味着我们需要对错误信息进行一些序列化。</p>
<h2 id="2-基于官方协定的错误传输实现"><a href="#2-基于官方协定的错误传输实现" class="headerlink" title="2.基于官方协定的错误传输实现"></a>2.基于官方协定的错误传输实现</h2><p>由于上面的实现不是很优雅，于是就上网冲浪寻找一个官方的实现，后面终于在<code>Github</code>中找到了<a href="https://github.com/grpc/grpc/tree/master/examples/python/errors">官方的错误传输示例</a>，其中官方的服务端示例代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">create_greet_limit_exceed_error_status</span>(<span class="hljs-params">name</span>):</span><br>    <span class="hljs-comment"># 创建一个Message对象</span><br>    detail = any_pb2.Any()<br>    <span class="hljs-comment"># 把一个自定义的错误转为一个Any的对象，这样收发消息时就不会出现校验不通过的情况了</span><br>    detail.Pack(<br>        error_details_pb2.QuotaFailure(violations=[<br>            error_details_pb2.QuotaFailure.Violation(<br>                subject=<span class="hljs-string">&quot;name: %s&quot;</span> % name,<br>                description=<span class="hljs-string">&quot;Limit one greeting per person&quot;</span>,<br>            )<br>        ],))<br>    <span class="hljs-comment"># 生成一个Status对象，这个对象包括了code,message,details三个字段</span><br>    <span class="hljs-keyword">return</span> status_pb2.Status(<br>        code=code_pb2.RESOURCE_EXHAUSTED,<br>        message=<span class="hljs-string">&#x27;Request limit exceeded.&#x27;</span>,<br>        <span class="hljs-comment"># 错误对象数组</span><br>        details=[detail],<br>    )<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LimitedGreeter</span>(<span class="hljs-params">helloworld_pb2_grpc.GreeterServicer</span>):</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        self._lock = threading.RLock()<br>        self._greeted = <span class="hljs-built_in">set</span>()<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">SayHello</span>(<span class="hljs-params">self, request, context</span>):</span><br>        <span class="hljs-comment"># 对应的gRPC调用</span><br>        <span class="hljs-keyword">with</span> self._lock:<br>            <span class="hljs-keyword">if</span> request.name <span class="hljs-keyword">in</span> self._greeted:<br>                rich_status = create_greet_limit_exceed_error_status(<br>                    request.name)<br>                context.abort_with_status(rpc_status.to_status(rich_status))<br>            <span class="hljs-keyword">else</span>:<br>                self._greeted.add(request.name)<br>        <span class="hljs-keyword">return</span> helloworld_pb2.HelloReply(message=<span class="hljs-string">&#x27;Hello, %s!&#x27;</span> % request.name)<br></code></pre></td></tr></table></figure>
<p>该示例代码中的<code>SayHello</code>方法逻辑非常简单，它判断如果<code>name</code>不存在，就把<code>name</code>添加到集合中，并正常返回，如果已经存在，则先生成一个<code>Status</code>对象，再通过<code>to_status</code>方法生成 一个<code>_Status</code>对象， 最后通过<code>abort_with_stauts</code>方法把<code>_Status</code>对象传进去，这样就把错误数据传输到了客户端。</p>
<p>其中<code>abort_with_stauts</code>方法会使请求引发异常并以非正常状态终止，再把用户指定的<code>Status</code>对象传给客户端，而<code>to_status</code>的源码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">to_status</span>(<span class="hljs-params">status</span>):</span><br>    <span class="hljs-keyword">return</span> _Status(code=code_to_grpc_status_code(status.code),<br>                   details=status.message,<br>                   trailing_metadata=((GRPC_DETAILS_METADATA_KEY,<br>                                       status.SerializeToString()),))<br></code></pre></td></tr></table></figure>
<p>通过源码可以看出这个函数就是把<code>status.code</code>转为<code>gRPC</code>响应的<code>code</code>，把<code>status.message</code>转为<code>gRPC</code>的<code>details</code>，最后把<code>status</code>转为合法的字符串，并通过<code>GRPC_DETAILS_METADATA_KEY</code>把字符串设置到metadata中。</p>
<p>而对于客户端则比较简单，源码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">process</span>(<span class="hljs-params">stub</span>):</span><br>    <span class="hljs-keyword">try</span>:<br>        response = stub.SayHello(helloworld_pb2.HelloRequest(name=<span class="hljs-string">&#x27;Alice&#x27;</span>))<br>        _LOGGER.info(<span class="hljs-string">&#x27;Call success: %s&#x27;</span>, response.message)<br>    <span class="hljs-keyword">except</span> grpc.RpcError <span class="hljs-keyword">as</span> rpc_error:<br>        _LOGGER.error(<span class="hljs-string">&#x27;Call failure: %s&#x27;</span>, rpc_error)<br>        <span class="hljs-comment"># 通过`grpc.RpcError`提取Status对象</span><br>        status = rpc_status.from_call(rpc_error)<br>        <span class="hljs-keyword">for</span> detail <span class="hljs-keyword">in</span> status.details:<br>            <span class="hljs-comment"># 读取detail里面的对象，并判断是不是对应的message，如果是则打印一条错误日志，如果不是则抛错</span><br>            <span class="hljs-keyword">if</span> detail.Is(error_details_pb2.QuotaFailure.DESCRIPTOR):<br>                info = error_details_pb2.QuotaFailure()<br>                detail.Unpack(info)<br>                _LOGGER.error(<span class="hljs-string">&#x27;Quota failure: %s&#x27;</span>, info)<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">raise</span> RuntimeError(<span class="hljs-string">&#x27;Unexpected failure: %s&#x27;</span> % detail)<br></code></pre></td></tr></table></figure>
<p>这段代码中，如果是正常响应，则打印响应体，而如果是异常，客户端会发现响应体的<code>code</code>并不是正常的状态码，所以会抛出一个<code>grpc.RpcError</code>异常，然后通过<code>rpc_status.from_call</code>函数提取异常, 这个函数的逻辑非常简单，源码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">from_call</span>(<span class="hljs-params">call</span>):</span><br>    <span class="hljs-comment"># 如果没有metadata数据就直接返回空</span><br>    <span class="hljs-keyword">if</span> call.trailing_metadata() <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>    <span class="hljs-comment"># 有数据就遍历数据</span><br>    <span class="hljs-keyword">for</span> key, value <span class="hljs-keyword">in</span> call.trailing_metadata():<br>        <span class="hljs-comment"># 如果Key为官方指定的Key，就进入提取数据逻辑</span><br>        <span class="hljs-keyword">if</span> key == GRPC_DETAILS_METADATA_KEY:<br>            <span class="hljs-comment"># 把数据反序列化成一个message对象</span><br>            rich_status = status_pb2.Status.FromString(value)<br>            <span class="hljs-comment"># 校验对象数据是否跟响应体一样</span><br>            <span class="hljs-keyword">if</span> call.code().value[<span class="hljs-number">0</span>] != rich_status.code:<br>                <span class="hljs-keyword">raise</span> ValueError(<br>                    <span class="hljs-string">&#x27;Code in Status proto (%s) doesn\&#x27;t match status code (%s)&#x27;</span><br>                    % (code_to_grpc_status_code(rich_status.code), call.code()))<br>            <span class="hljs-keyword">if</span> call.details() != rich_status.message:<br>                <span class="hljs-keyword">raise</span> ValueError(<br>                    <span class="hljs-string">&#x27;Message in Status proto (%s) doesn\&#x27;t match status details (%s)&#x27;</span><br>                    % (rich_status.message, call.details()))<br>            <span class="hljs-keyword">return</span> rich_status<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br></code></pre></td></tr></table></figure>
<p>通过源码看出这个逻辑和自定义的错误传递一样，也是通过<code>metadata</code>提取数据然后拼成一个异常对象。不过，需要注意的是<code>from_call</code>的<code>call</code>参数不仅支持<code>grpc.RpcError</code>，它还支持客户端拦截器中得到的<code>response</code>对象，因为<code>call</code>参数在<code>form_call</code>中用到了<code>trailing_metadata</code>，<code>code</code>和<code>details</code>方法都是<code>grpc.RpcError</code>和<code>response</code>对象共同拥有的方法。</p>
<p>在简单的了解了<code>gRPC</code>的错误传递示例后可以发现，官方的方法与自定义的错误传递很类似，只不过它定义了一个规范的Key，这样一来大家都会认为这个Key对应的值是一个<code>Status</code>对象的序列化成的字符串（由于序列化了，就不用担心存在非ASCII字符的问题）。而这个<code>Status</code>对象中包含了<code>code</code>,<code>message</code>和<code>detail</code>三个字段，分别对应着上面所说的错误结构体:</p>
<figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json">&#123;<br>    <span class="hljs-attr">&quot;code&quot;</span>: <span class="hljs-string">&quot;0&quot;</span>,<br>    <span class="hljs-attr">&quot;msg&quot;</span>: <span class="hljs-string">&quot;success&quot;</span>,<br>    <span class="hljs-attr">&quot;data&quot;</span>: &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>中的<code>code</code>,<code>msg</code>和<code>data</code>，不过需要注意的是<code>detail</code>是一个数组，它可以存放多个自定义的<code>Message</code>对象。</p>
<h2 id="3-重新设计错误传递实现"><a href="#3-重新设计错误传递实现" class="headerlink" title="3.重新设计错误传递实现"></a>3.重新设计错误传递实现</h2><p>通过官方的错误传输实现可以发现，这个例子需要服务端的业务逻辑主动通过<code>context.abort_with_status</code>逻辑来主动把错误信息设置到<code>metadata</code>中，同时也需要客户端捕获<code>grpc.RpcError</code>异常再打印出来，这样对业务层来说是非常啰嗦的，于是就尝试把官方协定的错误传输实现与自定义的错误传递结合起来。</p>
<p>首先是定义一个内部统一的<code>message</code>：</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><code class="hljs protobuf"><span class="hljs-class"><span class="hljs-keyword">message</span> <span class="hljs-title">Exec</span></span>&#123;<br>  <span class="hljs-built_in">string</span> name = <span class="hljs-number">1</span>; <span class="hljs-comment">// 异常名</span><br>  <span class="hljs-built_in">string</span> msg = <span class="hljs-number">2</span>;  <span class="hljs-comment">// 异常信息</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>这个Message只用于内部业务服务，如果该服务端有开发给其它部门使用，且他们没有兼容这个<code>message</code>，他们也可以通过<code>code</code>和<code>detail</code>知道大概是什么样的错误。</p>
<p>然后就开始折腾服务端的顶层拦截器，这个拦截器只要改造捕获异常部分的代码即可，源码如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-comment"># code url: https://github.com/so1n/grpc-example-common/blob/v0.1.7/grpc_example_common/interceptor/server_interceptor/customer_top.py</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomerTopInterceptor</span>(<span class="hljs-params">BaseInterceptor</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">intercept</span>(<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">        self,</span></span><br><span class="hljs-function"><span class="hljs-params">        next_handler_method: Callable,</span></span><br><span class="hljs-function"><span class="hljs-params">        request_proto_message: Any,</span></span><br><span class="hljs-function"><span class="hljs-params">        context: grpc.ServicerContext,</span></span><br><span class="hljs-function"><span class="hljs-params">    </span>) -&gt; Any:</span><br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-comment"># 服务调用</span><br>            <span class="hljs-keyword">return</span> next_handler_method(request_proto_message, context)<br>        <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>            <span class="hljs-comment"># 创建一个Message对象</span><br>            detail = any_pb2.Any()<br>            <span class="hljs-comment"># 把一个自定义的错误转为一个Any的对象，这样收发消息时就不会出现校验不通过的情况了</span><br>            <span class="hljs-comment"># 需要注意的是，这里是我们自己定义的message.Exec</span><br>            detail.Pack(<br>                Exec(<br>                    name=e.__class__.__name__,<br>                    msg=<span class="hljs-built_in">str</span>(e)<br>                )<br>            )<br>            <span class="hljs-comment"># 通过abort_with_status把数据通过metadata传给客户端</span><br>            context.abort_with_status(<br>                rpc_status.to_status(<br>                    status_pb2.Status(<br>                        code=code_pb2.RESOURCE_EXHAUSTED,  <span class="hljs-comment"># 这里只允许填写gRPC的错误码，就像我们定义了业务的错误码为2001，但是HTTP的状态码还是200一样</span><br>                        message=<span class="hljs-built_in">str</span>(e),<br>                        details=[detail], <span class="hljs-comment"># 这里是一个数组，所以这里可以定义多套异常的对象去兼容不同的系统，不过在内部调用中尽量统一只有一套方法</span><br>                    )<br>                )<br>            )<br>            <span class="hljs-comment"># 抛出异常，不过gRPC服务端判断该调用已经被标记为abort，不会继续处理</span><br>            <span class="hljs-comment"># 但是对于其它的功能却是有用的，比如opentelemetry的官方实现是在channel外再套用一个channel，所以它需要捕获异常并生成对应的Event</span><br>            <span class="hljs-keyword">raise</span> e<br></code></pre></td></tr></table></figure>
<p>接着就折腾客户端的顶层拦截器，同样的它只需要改一下数据的获取就可以了，源码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-comment"># code url: https://github.com/so1n/grpc-example-common/blob/v0.1.7/grpc_example_common/interceptor/client_interceptor/customer_top.py</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomerTopInterceptor</span>(<span class="hljs-params">BaseInterceptor</span>):</span><br><br>    <span class="hljs-comment"># 注册异常的带按摩略</span><br>    ...<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">intercept</span>(<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">        self,</span></span><br><span class="hljs-function"><span class="hljs-params">        method: Callable,</span></span><br><span class="hljs-function"><span class="hljs-params">        request_or_iterator: Any,</span></span><br><span class="hljs-function"><span class="hljs-params">        call_details: ClientCallDetailsType,</span></span><br><span class="hljs-function"><span class="hljs-params">    </span>) -&gt; GRPC_RESPONSE:</span><br>        response: GRPC_RESPONSE = method(call_details, request_or_iterator)<br>        <span class="hljs-comment"># 前面说到`from_call`也支持客户端拦截器里通过`method`方法得到的response对象</span><br>        status: Optional[status_pb2.Status] = rpc_status.from_call(response)<br>        <span class="hljs-comment"># 如果不为None,则证明得到了异常数据</span><br>        <span class="hljs-keyword">if</span> status:<br>            <span class="hljs-keyword">for</span> detail <span class="hljs-keyword">in</span> status.details:<br>                <span class="hljs-comment"># 判断这个detail是不是我们要的Message</span><br>                <span class="hljs-keyword">if</span> detail.Is(Exec.DESCRIPTOR):<br>                    <span class="hljs-comment"># 通过反序列化获取数据</span><br>                    exec_instance: Exec = Exec()<br>                    detail.Unpack(exec_instance)<br>                    <span class="hljs-comment"># 生成异常并抛出</span><br>                    exec_class: Type[Exception] = self.exc_dict.get(exec_instance.name) <span class="hljs-keyword">or</span> RuntimeError<br>                    <span class="hljs-keyword">raise</span> exec_class(exec_instance.msg)<br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-keyword">raise</span> RuntimeError(<span class="hljs-string">&#x27;Unexpected failure: %s&#x27;</span> % detail)<br>        <span class="hljs-keyword">return</span> response<br></code></pre></td></tr></table></figure>
<p>这样一来，新的错误传递实现已经完成了，现在通过一个简单的demo来验证成果，demo代码如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-comment"># grpc_example_common url:https://github.com/so1n/grpc-example-common/tree/v0.1.7</span><br><span class="hljs-comment"># 服务端代码</span><br><span class="hljs-keyword">from</span> concurrent <span class="hljs-keyword">import</span> futures<br><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> List<br><br><span class="hljs-keyword">import</span> grpc<br><span class="hljs-keyword">from</span> grpc_example_common.interceptor.server_interceptor.base <span class="hljs-keyword">import</span> BaseInterceptor<br><span class="hljs-keyword">from</span> google.protobuf.empty_pb2 <span class="hljs-keyword">import</span> Empty  <span class="hljs-comment"># type: ignore</span><br><span class="hljs-keyword">from</span> grpc_example_common.protos.user <span class="hljs-keyword">import</span> user_pb2 <span class="hljs-keyword">as</span> user_message<br><span class="hljs-keyword">from</span> grpc_example_common.interceptor.server_interceptor.customer_top <span class="hljs-keyword">import</span> CustomerTopInterceptor<br><br><span class="hljs-keyword">from</span> grpc_example_common.protos.user <span class="hljs-keyword">import</span> user_pb2_grpc <span class="hljs-keyword">as</span> user_service<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserService</span>(<span class="hljs-params">user_service.UserServicer</span>):</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">delete_user</span>(<span class="hljs-params">self, request: user_message.DeleteUserRequest,</span></span><br><span class="hljs-function"><span class="hljs-params">                    context: grpc.ServicerContext</span>) -&gt; Empty:</span><br>        uid: <span class="hljs-built_in">str</span> = request.uid<br>        <span class="hljs-keyword">if</span> uid == <span class="hljs-string">&quot;123&quot;</span>:<br>            <span class="hljs-keyword">return</span> Empty()<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">f&quot;Not found user:<span class="hljs-subst">&#123;uid&#125;</span>&quot;</span>)<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>(<span class="hljs-params">host: <span class="hljs-built_in">str</span> = <span class="hljs-string">&quot;127.0.0.1&quot;</span>, port: <span class="hljs-built_in">str</span> = <span class="hljs-string">&quot;9000&quot;</span></span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>    interceptor_list: List[BaseInterceptor] = [CustomerTopInterceptor()]<br>    server: grpc.server = grpc.server(<br>        futures.ThreadPoolExecutor(max_workers=<span class="hljs-number">10</span>),<br>        interceptors=interceptor_list,<br>    )<br>    user_service.add_UserServicer_to_server(UserService(), server)<br>    server.add_insecure_port(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;host&#125;</span>:<span class="hljs-subst">&#123;port&#125;</span>&quot;</span>)<br>    server.start()<br>    <span class="hljs-keyword">try</span>:<br>        server.wait_for_termination()<br>    <span class="hljs-keyword">except</span> KeyboardInterrupt:<br>        server.stop(<span class="hljs-number">0</span>)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    main()<br><br><span class="hljs-comment"># 客户端代码</span><br><span class="hljs-keyword">import</span> grpc<br><span class="hljs-keyword">from</span> grpc_example_common.protos.user <span class="hljs-keyword">import</span> user_pb2 <span class="hljs-keyword">as</span> user_message<br><span class="hljs-keyword">from</span> grpc_example_common.protos.user <span class="hljs-keyword">import</span> user_pb2_grpc <span class="hljs-keyword">as</span> user_service<br><span class="hljs-keyword">from</span> grpc_example_common.interceptor.client_interceptor.customer_top <span class="hljs-keyword">import</span> CustomerTopInterceptor<br><br>channel: grpc.Channel = grpc.intercept_channel(<br>    grpc.insecure_channel(<span class="hljs-string">&quot;127.0.0.1:9000&quot;</span>), CustomerTopInterceptor()<br>)<br>user_stub: user_service.UserStub = user_service.UserStub(channel)<br>user_stub.delete_user(user_message.DeleteUserRequest(uid=<span class="hljs-string">&quot;123&quot;</span>))<br>user_stub.delete_user(user_message.DeleteUserRequest(uid=<span class="hljs-string">&quot;456&quot;</span>))<br></code></pre></td></tr></table></figure>
<p>编写完demo后开始运行，运行后客户端抛出如下错误信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">Traceback (most recent call last):<br>  File <span class="hljs-string">&quot;/home/so1n/github/grpc-example-project/grpc-example-api-backend-service/demo.py&quot;</span>, line 11, <span class="hljs-keyword">in</span> &lt;module&gt;<br>    user_stub.delete_user(user_message.DeleteUserRequest(uid=<span class="hljs-string">&quot;456&quot;</span>))<br>  File <span class="hljs-string">&quot;/home/so1n/github/grpc-example-project/grpc-example-api-backend-service/.venv/lib/python3.8/site-packages/grpc/_interceptor.py&quot;</span>, line 216, <span class="hljs-keyword">in</span> __call__<br>    response, ignored_call = self._with_call(request,<br>  File <span class="hljs-string">&quot;/home/so1n/github/grpc-example-project/grpc-example-api-backend-service/.venv/lib/python3.8/site-packages/grpc/_interceptor.py&quot;</span>, line 254, <span class="hljs-keyword">in</span> _with_call<br>    call = self._interceptor.intercept_unary_unary(continuation,<br>  File <span class="hljs-string">&quot;/home/so1n/github/grpc-example-project/grpc-example-api-backend-service/.venv/lib/python3.8/site-packages/grpc_example_common/interceptor/client_interceptor/base.py&quot;</span>, line 74, <span class="hljs-keyword">in</span> intercept_unary_unary<br>    <span class="hljs-built_in">return</span> self.intercept(continuation, request, call_details)<br>  File <span class="hljs-string">&quot;/home/so1n/github/grpc-example-project/grpc-example-api-backend-service/.venv/lib/python3.8/site-packages/grpc_example_common/interceptor/client_interceptor/customer_top.py&quot;</span>, line 44, <span class="hljs-keyword">in</span> intercept<br>    raise exec_class(exec_instance.msg)<br>ValueError: Not found user:456<br></code></pre></td></tr></table></figure>
<p>通过信息可以发现，重新设计的错误传递实现完美运行。</p>
]]></content>
      <categories>
        <category>Python-gRPC实践</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>gRPC</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 3.11 Asyncio新增的两个高级类</title>
    <url>/2022/06/13/two_functional_implementations_based_on_asyncio.Task_extensions/</url>
    <content><![CDATA[<h2 id="前记"><a href="#前记" class="headerlink" title="前记"></a>前记</h2><p><code>Python Asyncio</code>提供了很多基础的API以及对应的对象，如果只用于编写简单的HTTP API处理函数，那么这些<code>Python Asyncio</code>是足够的，但在面对一些复杂点多的需求或者编写网络相关框架时，就需要基于<code>Python Asyncio</code>的基础API封装成高级对象。目前比较常用的高级对象有两个，一个是用于管理代码域超时的<code>timeout</code>以及一个用于结构化并发的<code>TaskGroup</code>，它们最先出现在<a href="https://github.com/python-trio/trio">Trio</a>这个协程库中，后来<a href="https://github.com/agronholm/anyio">Anyio</a>库也支持这两个对象，现在，准备发布Python 3.11中<code>Asyncio</code>库也包括这两个功能。</p>
<span id="more"></span>
<blockquote>
<p>注： 正常情况下，调用经过封装的高级对象的耗时肯定会大于直接调用基础API的耗时，但是高级对象能使代码结构更加优美。比如<code>starlette</code>框架在集成<code>anyio</code>后，性能降低了4.5%，具体见:<a href="https://github.com/encode/starlette/pull/1157">https://github.com/encode/starlette/pull/1157</a></p>
</blockquote>
<h2 id="1-人性化的超时"><a href="#1-人性化的超时" class="headerlink" title="1.人性化的超时"></a>1.人性化的超时</h2><p>通常情况下，我们的代码调用结果只有成功或者是失败，但是对于客户端的网络调用来说还存在另外一种情况，就是网络调用可能会永远挂起，不会响应成功或者失败，然后就一直占用着文件描述符等系统资源。所以大多数的客户端都会实现超时机制来解决这个问题，但是客户端支持的超时API都是只针对自己的对应调用，比如<code>httpx</code>这个库，它的对应调用如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-comment"># 使用get方法请求， 超时时间为9秒</span><br><span class="hljs-keyword">import</span> asyncio<br><span class="hljs-keyword">import</span> httpx<br><br>asyncio.run(httpx.AsyncClient().get(url=<span class="hljs-string">&quot;http://so1n.me&quot;</span>, timeout=<span class="hljs-number">9</span>))<br></code></pre></td></tr></table></figure>
<p>这个调用会请求到<code>http://so1n.me</code>，然后等待响应，如果该网站超过9秒仍未返回响应或者由于网络原因导致该调用没有返回响应，那么就会抛出一个超时错误。<br>这种设计的非常OK的，使用起来非常简单，但如果现在要求的更改为在9秒内请求两次<code>http://so1n.me</code>后还按照上面的写法，就会变得很糟糕，代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> asyncio<br><span class="hljs-keyword">import</span> httpx<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">demo</span>() -&gt; <span class="hljs-keyword">None</span>:</span><br>    <span class="hljs-keyword">await</span> httpx.AsyncClient().get(url=<span class="hljs-string">&quot;http://so1n.me&quot;</span>, timeout=<span class="hljs-number">9</span>)<br>    <span class="hljs-keyword">await</span> httpx.AsyncClient().get(url=<span class="hljs-string">&quot;http://so1n.me&quot;</span>, timeout=<span class="hljs-number">9</span>)<br></code></pre></td></tr></table></figure>
<p>这种情况下假设该方法的每个请求时长为8秒， 那么他的总请求时长为16秒， 已经超出总的超时时长为9秒的要求的, 但每个请求都没有触发超时机制，所以并不会抛出异常。<br>不过这时我们可以换个思路， 因为超时的原本意思是在n秒后中断此次请求, 也就是在某个时刻时终止请求， 那么我们只要在调用时计算出距离超时时刻还有多少时间差，并设置到timeout参数中，就可以使<code>demo</code>调用符合我们的要求了，代码改写后如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> asyncio<br><span class="hljs-keyword">import</span> httpx<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">demo</span>(<span class="hljs-params">timeout: <span class="hljs-built_in">int</span> = <span class="hljs-number">9</span></span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>    deadline: <span class="hljs-built_in">float</span> = time.time() + <span class="hljs-number">9</span><br>    <span class="hljs-keyword">await</span> httpx.AsyncClient().get(url=<span class="hljs-string">&quot;http://so1n.me&quot;</span>, timeout=time.time() - deadline)<br>    <span class="hljs-keyword">await</span> httpx.AsyncClient().get(url=<span class="hljs-string">&quot;http://so1n.me&quot;</span>, timeout=time.time() - deadline)<br></code></pre></td></tr></table></figure>
<p>这段代码可以完美的工作， 假设第一个请求的时长为5秒， 那么第二次请求的超时参数的值会是4秒， 这是非常ok， 代码也依然保持简单。 不过目前还是有个缺点， 就是每次都计算一次超时时间， 然后再显示传进去, 这个超时是不可传递的， 如果有一个抽象能方便的使用， 那是非常好的，比如像使用<code>wait_for</code>后的代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> asyncio<br><span class="hljs-keyword">import</span> httpx<br><span class="hljs-keyword">import</span> time<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sub_demo</span>() -&gt; <span class="hljs-keyword">None</span>:</span><br>    <span class="hljs-keyword">await</span> httpx.AsyncClient().get(url=<span class="hljs-string">&quot;http://so1n.me&quot;</span>)<br>    <span class="hljs-keyword">await</span> httpx.AsyncClient().get(url=<span class="hljs-string">&quot;http://so1n.me&quot;</span>)<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">demo</span>() -&gt; <span class="hljs-keyword">None</span>:</span><br>    <span class="hljs-keyword">await</span> asyncio.wait_for(sub_demo(), timeout=<span class="hljs-number">9</span>)<br><br><br>asyncio.run(demo())<br></code></pre></td></tr></table></figure>
<p>这段代码通过<code>wait_for</code>使一个函数内的调用共享一个截止时间，当抵达截止时间时， 无论执行当前已经执行到哪个函数， 都会触发超时异常。不过这样的实现会差点意思， 因为每有一个共享截止时间的代码范围， 就需要把对应的逻辑独立出来成一个新的函数, 这样的代码不是特别的优雅， 而且当需要传的参数比较多时， 这简直就是灾难了(当然也可以写成闭包的形式)。</p>
<p>好在<code>Python</code>通过<code>with</code>语句提供了一个代码范围的管理，所以我们可以尝试通过<code>with</code>语句来管理这片代码范围的执行超时，那该如何实现呢？熟悉<code>with</code>语句的开发者都知道，<code>with</code>语句实际上是一个带有<code>__enter__</code>方法和<code>__exit__</code>方法的类，这两个方法分别提供了进入代码范围和退出代码范围的调用，对于超时这个需求在结合<code>with</code>语句后，只需要在进入代码范围初始化一个计时器，退出时关闭计时器，如果计时器数完（也就是超时了）且尚未被退出逻辑关闭，则会引发超时，并取消代码范围的协程，大概的伪逻辑如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">demo</span>() -&gt; <span class="hljs-keyword">None</span>:</span><br>    <span class="hljs-comment"># 该代码只为了演示逻辑，实际上无法正常运行</span><br>    timer = Timer(<span class="hljs-number">9</span>)<br>    <span class="hljs-keyword">await</span> httpx.AsyncClient().get(url=<span class="hljs-string">&quot;http://so1n.me&quot;</span>)<br>    <span class="hljs-keyword">await</span> httpx.AsyncClient().get(url=<span class="hljs-string">&quot;http://so1n.me&quot;</span>)<br>    timer.close()<br></code></pre></td></tr></table></figure>
<p>通过伪代码逻辑可以看出两个运行的协程并跟timer并没有任何联系，timer无法管理到这两个协程的，所以timer超时时，两个协程还能正常运行，那该如何与他们建立联系呢？文章<a href="https://so1n.me/2022/04/11/python's_waitable_objects_in_asyncio">《Python的可等待对象在Asyncio的作用》</a>中讲到在一个协程函数中通过<code>await</code>执行的子协程，是交给执行该协程函数对应的<code>task</code>对象管理的，也就是我们对执行协程函数的<code>task</code>对象进行的任何操作都是会传播到对应的子协程的，所以我们只要在进入代码范围时捕获到当前的<code>task</code>，然后通过<code>loop.call_at</code>方法在指定时间调用<code>task.cancel</code>取消<code>task</code>对象，并由<code>task</code>对象传播到被调用的子协程，如下代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> asyncio<br><span class="hljs-keyword">import</span> httpx<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">demo</span>() -&gt; <span class="hljs-keyword">None</span>:</span><br>    current_task: asyncio.Task = asyncio.Task.current_task()<br>    loop: asyncio.AbstractEventLoop = asyncio.get_event_loop()<br>    <span class="hljs-comment"># 设置9秒后超时</span><br>    timer: asyncio.events.TimerHandle = loop.call_at(loop.time() + <span class="hljs-number">9</span>, <span class="hljs-keyword">lambda</span>: current_task.cancel())持续创作，加速成长！这是我参与「掘金日新计划 · <span class="hljs-number">6</span> 月更文挑战」的第<span class="hljs-number">2</span>天，点击查看活动详情<br><br><br>    <span class="hljs-keyword">await</span> httpx.AsyncClient().get(url=<span class="hljs-string">&quot;http://so1n.me&quot;</span>)<br>    <span class="hljs-keyword">await</span> httpx.AsyncClient().get(url=<span class="hljs-string">&quot;http://so1n.me&quot;</span>)<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> timer.cancelled():<br>        timer.cancel()<br>    <br></code></pre></td></tr></table></figure>
<p>这段是可以正常运行的，接下来我们就需要把这段逻辑封装到一个类里面，这样调用者只需要简单的调用就可以实现整块代码域的超时管理，对应的代码如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-comment"># 这是一个简化版本的伪代码, 存在一些逻辑漏洞, 但是都包含了主要流程了，</span><br><br><span class="hljs-keyword">import</span> asyncio<br><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> Optional, Type<br><span class="hljs-keyword">from</span> types <span class="hljs-keyword">import</span> TracebackType<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Deadline</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">        self,</span></span><br><span class="hljs-function"><span class="hljs-params">        delay: Optional[<span class="hljs-built_in">float</span>],</span></span><br><span class="hljs-function"><span class="hljs-params">        loop: Optional[asyncio.AbstractEventLoop] = <span class="hljs-literal">None</span>,</span></span><br><span class="hljs-function"><span class="hljs-params">        timeout_exc: Optional[Exception] = <span class="hljs-literal">None</span>,</span></span><br><span class="hljs-function"><span class="hljs-params">    </span>):</span><br>        <span class="hljs-comment"># 代表多少秒后超时</span><br>        self._delay: Optional[<span class="hljs-built_in">float</span>] = delay<br>        <span class="hljs-comment"># asyncio需要的事件循环</span><br>        self._loop = loop <span class="hljs-keyword">or</span> asyncio.get_event_loop()<br>        <span class="hljs-comment"># 当超时时，如何抛异常</span><br>        self._timeout_exc: Exception = timeout_exc <span class="hljs-keyword">or</span> asyncio.TimeoutError()<br><br>        <span class="hljs-comment"># 控制结束的future</span><br>        self._deadline_future: asyncio.Future = asyncio.Future()<br>        <span class="hljs-comment"># 注册with语句捕获的future</span><br>        self._with_scope_future: Optional[asyncio.Future] = <span class="hljs-literal">None</span> <br>        <span class="hljs-keyword">if</span> self._delay <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-comment"># 计算截止时间和注册截止时间回调，通知event loop在截止时间执行超时机制</span><br>            self._loop.call_at(self._loop.time() + self._delay, self._set_deadline_future_result)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_set_deadline_future_result</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        <span class="hljs-comment"># 当到截止时间时， 设置执行结束， 并对还在执行的with future进行cancel操作</span><br>        self._deadline_future.set_result(<span class="hljs-literal">True</span>)<br>        <span class="hljs-keyword">if</span> self._with_scope_future <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> self._with_scope_future.cancelled():<br>            self._with_scope_future.cancel()<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__enter__</span>(<span class="hljs-params">self</span>) -&gt; &quot;Deadline&quot;:</span><br>        <span class="hljs-comment"># 进入with语句范围</span><br>        <span class="hljs-keyword">if</span> self._with_scope_future:<br>            <span class="hljs-comment"># 一个实例同时只能调用一次， 多次调用会出错</span><br>            <span class="hljs-keyword">raise</span> RuntimeError(<span class="hljs-string">&quot;`with` can only be called once&quot;</span>)<br>        <span class="hljs-keyword">if</span> self._delay <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-comment"># 启动了超时机制</span><br><br>            <span class="hljs-comment"># 获取当前运行的task</span><br>            main_task: Optional[asyncio.Task] = asyncio.Task.current_task(self._loop)<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> main_task:<br>                <span class="hljs-keyword">raise</span> RuntimeError(<span class="hljs-string">&quot;Can not found current task&quot;</span>)<br>            <span class="hljs-comment"># 注册with语句所在的future</span><br>            self._with_scope_future = main_task<br>        <span class="hljs-keyword">return</span> self<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__exit__</span>(<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">        self,</span></span><br><span class="hljs-function"><span class="hljs-params">        exc_type: Optional[Type[BaseException]],</span></span><br><span class="hljs-function"><span class="hljs-params">        exc_val: Optional[BaseException],</span></span><br><span class="hljs-function"><span class="hljs-params">        exc_tb: Optional[TracebackType],</span></span><br><span class="hljs-function"><span class="hljs-params">    </span>) -&gt; Optional[bool]:</span><br>        <span class="hljs-comment"># 由于执行完成或者是异常退出with语句范围</span><br>        <span class="hljs-keyword">if</span> self._with_scope_future:<br>            self._with_scope_future = <span class="hljs-literal">None</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br><br>        <span class="hljs-keyword">if</span> self._deadline_future.done():<br>            <span class="hljs-comment"># 如果控制结束的future已经结束， 代表此次with语句范围的代码执行超时了</span><br>            <span class="hljs-keyword">raise</span> self._timeout_exc<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br></code></pre></td></tr></table></figure>
<p>现在超时类编写完成，它的使用方法如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> asyncio<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">demo</span>() -&gt; <span class="hljs-keyword">None</span>:</span><br>    <span class="hljs-keyword">with</span> Deadline(delay=<span class="hljs-number">9</span>):<br>        <span class="hljs-keyword">await</span> httpx.AsyncClient().get(url=<span class="hljs-string">&quot;http://so1n.me&quot;</span>)<br>        <span class="hljs-keyword">await</span> httpx.AsyncClient().get(url=<span class="hljs-string">&quot;http://so1n.me&quot;</span>)<br><br><br>asyncio.run(demo())<br></code></pre></td></tr></table></figure>
<p>可以看到，这样的使用方法非常方便，不过这个功能在<code>Python</code>3.11已经提供了，可以通过<a href="https://github.com/python/cpython/blob/v3.11.0b3/Lib/asyncio/timeouts.py%E4%BA%86%E8%A7%A3Python%E6%8F%90%E4%BE%9B%E7%9A%84timeout%E5%AE%9E%E7%8E%B0%E3%80%82">https://github.com/python/cpython/blob/v3.11.0b3/Lib/asyncio/timeouts.py了解Python提供的timeout实现。</a></p>
<h2 id="2-结构化并发"><a href="#2-结构化并发" class="headerlink" title="2.结构化并发"></a>2.结构化并发</h2><p>结构化并发借鉴了结构化编程这一名词，它的作用就是确保调用者进行了一个调用后还能控制这个调用过程，或者是得到调用结果，具体的结构化并发描述见<a href="https://vorpus.org/blog/notes-on-structured-concurrency-or-go-statement-considered-harmful/">Notes on structured concurrency, or: Go statement considered harmful</a>或者译文<a href="https://juejin.cn/post/6844904146424823816">【译】「结构化并发」简析，或：有害的go语句</a>。</p>
<p>在使用<code>Python Asyncio</code>编写代码时，会为了提高并发能力而通过<code>asyncio.create</code>创建很多Task运行，这种情况下可能导致调用者无法得到协程的运行结果，比如一个服务端为了提高并发能力，在接收到请求时通常都会分发给其它协程去处理，这时就可能导致代码不属于结构化并发， 下面通过一个生产消费者来模拟这一个行为，代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> asyncio<br><span class="hljs-keyword">import</span> random<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">request_handle</span>(<span class="hljs-params">data</span>):</span><br>    <span class="hljs-comment"># 处理请求</span><br>    print(data)<br>    <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">1</span>)<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">recv_request</span>(<span class="hljs-params">queue: asyncio.Queue</span>):</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        <span class="hljs-comment"># 接收请求</span><br>        data = <span class="hljs-keyword">await</span> queue.get()<br>        <span class="hljs-comment"># 分发给其它协程处理</span><br>        asyncio.create_task(request_handle(data))<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">send_request</span>(<span class="hljs-params">queue: asyncio.Queue</span>):</span><br>    <span class="hljs-comment"># 发送请求</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        <span class="hljs-keyword">await</span> queue.put(random.randint(<span class="hljs-number">0</span>, <span class="hljs-number">100</span>))<br>        <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">0.01</span>)<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    queue: asyncio.Queue = asyncio.Queue()<br>    asyncio.create_task(recv_request(queue))<br>    <span class="hljs-keyword">await</span> (send_request(queue))<br><br>asyncio.run(main())<br><br></code></pre></td></tr></table></figure>
<p>这段代码首先是通过<code>asyncio.create_task</code>创建一个发送者在后台运行着，然后通过<code>await</code>等待<code>send_request</code>调用运行结束，不过<code>send_request</code>是不会结束的，它会一直运行下去，并且每隔0.01秒就会发送一个数据到queue里面。同时在后台运行的<code>recv_request</code>就会从queue获取到数据，并且为了不阻塞自己的处理逻辑，会通过<code>create_task</code>创建一个请求处理者来处理这个请求。</p>
<p>这段程序可以一直运行着，但是调用者不知道后台运行的任务是否一直在正常的运行着，而且可能需要他们在运行出错时捕获到对应的错误，并把错误抛出来，于是需要对<code>main</code>函数进行一些改造：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    queue: asyncio.Queue = asyncio.Queue()<br>    recv_coro = recv_request(queue)<br>    send_coro = send_request(queue)<br>    <span class="hljs-keyword">await</span> asyncio.gather(recv_coro, send_coro)<br></code></pre></td></tr></table></figure>
<p>这样就能捕获到发送消息的协程和接收消息的协程的异常，并把错误抛出来了，不过对于接收消息并分发给其它协程这段逻辑却无法通过<code>asyncio.gather</code>来管理，因为该逻辑是收到消息就会创建一个协程来处理的，这是实时创建的，而<code>asyncio.gather</code>只能管理已经创建的Corotinue。</p>
<p>如果有一个类，可以像<code>timeout</code>管理这个作用域的所有派生出来的协程，捕获派送协程的异常，那就很棒了。而在<code>Python</code>3.11或者是<code>Anyio</code>中可以通过<code>TaskGroup</code>解决这个问题，在使用<code>TaskGroup</code>后，<code>recv_request</code>代码改写为如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> asyncio<br><span class="hljs-keyword">import</span> random<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">request_handle</span>(<span class="hljs-params">data</span>):</span><br>    <span class="hljs-comment"># 处理请求</span><br>    print(data)<br>    <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">1</span>)<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">recv_request</span>(<span class="hljs-params">queue: asyncio.Queue</span>):</span><br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> asyncio.task_group.TaskGroup() <span class="hljs-keyword">as</span> tg:<br>        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>            <span class="hljs-comment"># 接收请求</span><br>            data = <span class="hljs-keyword">await</span> queue.get()<br>            <span class="hljs-comment"># 分发给其它协程处理</span><br>            tg.create_task(request_handle(data))<br></code></pre></td></tr></table></figure>
<p>可以看到这个代码改动不大，首先是通过<code>asyncio.task_group.TaskGroup</code>创建一个对象并开启一个代码域，然后通过<code>tg</code>这个对象的<code>create_task</code>方法派生一个协程来处理数据，这个用法跟<code>asyncio.create_task</code>很像，但是通过<code>tg.create_task</code>创建的协程是会被<code>tg</code>管理的。<br>这时，如果<code>request_handle</code>对应的协程抛出来异常，<code>tg</code>对象也会退出并抛出对应的异常，同时这个代码域执行完毕后，也不会退出这片代码域，而是需要等所有通过<code>tg.create_task</code>创建的协程执行完毕后才会退出。</p>
<p>通过上面的<code>timeout</code>可以猜到<code>TaskGroup</code>也是在<code>__aenter__</code>时获取当前<code>task</code>对象并在后续使用着，现在通过<a href="https://github.com/python/cpython/blob/v3.11.0b3/Lib/asyncio/taskgroups.py">taskgroups.py</a>了解<code>TaskGroup</code>是如何执行的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">from</span> asycnio <span class="hljs-keyword">import</span> events<br><span class="hljs-keyword">from</span> asycnio <span class="hljs-keyword">import</span> exceptions<br><span class="hljs-keyword">from</span> asycnio <span class="hljs-keyword">import</span> tasks<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TaskGroup</span>:</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        self._entered = <span class="hljs-literal">False</span><br>        self._exiting = <span class="hljs-literal">False</span><br>        self._aborting = <span class="hljs-literal">False</span><br>        self._loop = <span class="hljs-literal">None</span><br>        self._parent_task = <span class="hljs-literal">None</span><br>        self._parent_cancel_requested = <span class="hljs-literal">False</span><br>        self._tasks = <span class="hljs-built_in">set</span>()<br>        self._errors = []<br>        self._base_error = <span class="hljs-literal">None</span><br>        self._on_completed_fut = <span class="hljs-literal">None</span><br><br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__aenter__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-comment"># 限制只能调用一次</span><br>        <span class="hljs-keyword">if</span> self._entered:<br>            <span class="hljs-keyword">raise</span> RuntimeError(<br>                <span class="hljs-string">f&quot;TaskGroup <span class="hljs-subst">&#123;self!r&#125;</span> has been already entered&quot;</span>)<br>        self._entered = <span class="hljs-literal">True</span><br><br>        <span class="hljs-keyword">if</span> self._loop <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            self._loop = events.get_running_loop()<br><br>        <span class="hljs-comment"># 获取当前的task</span><br>        self._parent_task = tasks.current_task(self._loop)<br>        <span class="hljs-keyword">if</span> self._parent_task <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">raise</span> RuntimeError(<br>                <span class="hljs-string">f&#x27;TaskGroup <span class="hljs-subst">&#123;self!r&#125;</span> cannot determine the parent task&#x27;</span>)<br><br>        <span class="hljs-keyword">return</span> self<br><br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__aexit__</span>(<span class="hljs-params">self, et, exc, tb</span>):</span><br>        self._exiting = <span class="hljs-literal">True</span><br>        propagate_cancellation_error = <span class="hljs-literal">None</span><br><br>        <span class="hljs-keyword">if</span> (exc <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span><br>                self._is_base_error(exc) <span class="hljs-keyword">and</span><br>                self._base_error <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>):<br>            self._base_error = exc<br><br>        <span class="hljs-keyword">if</span> et <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">if</span> et <span class="hljs-keyword">is</span> exceptions.CancelledError:<br>                <span class="hljs-keyword">if</span> self._parent_cancel_requested <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> self._parent_task.uncancel():<br>                    <span class="hljs-comment"># Do nothing, i.e. swallow the error.</span><br>                    <span class="hljs-keyword">pass</span><br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-comment"># 如果有一个协程已经取消了，就设置取消的exc</span><br>                    propagate_cancellation_error = exc<br><br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self._aborting:<br>                <span class="hljs-comment"># 取消所有的task</span><br>                self._abort()<br><br>        <span class="hljs-comment"># 如果还有派生的协程来运行，就陷在这个逻辑中</span><br>        <span class="hljs-keyword">while</span> self._tasks:<br>            <span class="hljs-keyword">if</span> self._on_completed_fut <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>                self._on_completed_fut = self._loop.create_future()<br><br>            <span class="hljs-keyword">try</span>:<br>                <span class="hljs-comment"># 创建一个中间future来捕获所有派生协程的异常，并等待协程运行完毕</span><br>                <span class="hljs-keyword">await</span> self._on_completed_fut<br>            <span class="hljs-keyword">except</span> exceptions.CancelledError <span class="hljs-keyword">as</span> ex:<br>                <span class="hljs-comment"># TaskGroup不会使_on_completed_fut抛出取消异常，但是如果main_task被取消时，会传播到_on_completed_fut</span><br>                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self._aborting:<br>                    <span class="hljs-comment"># 与上面一样设置错误，并取消所有协程</span><br>                    propagate_cancellation_error = ex<br>                    self._abort()<br><br>            self._on_completed_fut = <span class="hljs-literal">None</span><br><br>        <span class="hljs-keyword">assert</span> <span class="hljs-keyword">not</span> self._tasks<br><br>        <span class="hljs-comment"># 如果有异常，则抛出</span><br>        <span class="hljs-keyword">if</span> self._base_error <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">raise</span> self._base_error<br><br>        <span class="hljs-keyword">if</span> propagate_cancellation_error <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">raise</span> propagate_cancellation_error<br><br>        <span class="hljs-keyword">if</span> et <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> et <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> exceptions.CancelledError:<br>            self._errors.append(exc)<br><br>        <span class="hljs-comment"># 抛出所有运行期间的异常</span><br>        <span class="hljs-keyword">if</span> self._errors:<br>            errors = self._errors<br>            self._errors = <span class="hljs-literal">None</span><br><br>            me = BaseExceptionGroup(<span class="hljs-string">&#x27;unhandled errors in a TaskGroup&#x27;</span>, errors)<br>            <span class="hljs-keyword">raise</span> me <span class="hljs-keyword">from</span> <span class="hljs-literal">None</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">create_task</span>(<span class="hljs-params">self, coro, *, name=<span class="hljs-literal">None</span>, context=<span class="hljs-literal">None</span></span>):</span><br>        <span class="hljs-comment"># 判断目前是否生效，如果不生效就无法派生协程</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self._entered:<br>            <span class="hljs-keyword">raise</span> RuntimeError(<span class="hljs-string">f&quot;TaskGroup <span class="hljs-subst">&#123;self!r&#125;</span> has not been entered&quot;</span>)<br>        <span class="hljs-keyword">if</span> self._exiting <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> self._tasks:<br>            <span class="hljs-keyword">raise</span> RuntimeError(<span class="hljs-string">f&quot;TaskGroup <span class="hljs-subst">&#123;self!r&#125;</span> is finished&quot;</span>)<br>        <span class="hljs-comment"># 通过事件循环创建协程</span><br>        <span class="hljs-keyword">if</span> context <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            task = self._loop.create_task(coro)<br>        <span class="hljs-keyword">else</span>:<br>            task = self._loop.create_task(coro, context=context)<br>        tasks._set_task_name(task, name)<br>        <span class="hljs-comment"># 添加task执行结果回调</span><br>        task.add_done_callback(self._on_task_done)<br>        <span class="hljs-comment"># 把task添加到对应的self._task，这样其它方法就会判断协程是否运行完毕了</span><br>        self._tasks.add(task)<br>        <span class="hljs-keyword">return</span> task<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_is_base_error</span>(<span class="hljs-params">self, exc: BaseException</span>) -&gt; bool:</span><br>        <span class="hljs-keyword">assert</span> <span class="hljs-built_in">isinstance</span>(exc, BaseException)<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">isinstance</span>(exc, (SystemExit, KeyboardInterrupt))<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_abort</span>(<span class="hljs-params">self</span>):</span><br>        self._aborting = <span class="hljs-literal">True</span><br><br>        <span class="hljs-comment"># 取消所有派生的协程</span><br>        <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> self._tasks:<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> t.done():<br>                t.cancel()<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_on_task_done</span>(<span class="hljs-params">self, task</span>):</span><br>        <span class="hljs-comment"># 安全的删除对应的task</span><br>        self._tasks.discard(task)<br><br>        <span class="hljs-keyword">if</span> self._on_completed_fut <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> self._tasks:<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self._on_completed_fut.done():<br>                <span class="hljs-comment"># 如果最后一个派生的协程运行结束，则设置中间future,这样TaskGroup.__aexit__的while循环就能继续执行了</span><br>                self._on_completed_fut.set_result(<span class="hljs-literal">True</span>)<br><br>        <span class="hljs-comment"># 如果task已经取消或者没有异常，则不走下面的逻辑</span><br>        <span class="hljs-keyword">if</span> task.cancelled():<br>            <span class="hljs-keyword">return</span><br>        exc = task.exception()<br>        <span class="hljs-keyword">if</span> exc <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">return</span><br><br>        <span class="hljs-comment"># 把异常添加到类中</span><br>        self._errors.append(exc)<br>        <span class="hljs-keyword">if</span> self._is_base_error(exc) <span class="hljs-keyword">and</span> self._base_error <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            self._base_error = exc<br><br>        <span class="hljs-comment"># 最后处理下当前task</span><br>        <span class="hljs-keyword">if</span> self._parent_task.done():<br>            <span class="hljs-comment"># Not sure if this case is possible, but we want to handle</span><br>            <span class="hljs-comment"># it anyways.</span><br>            self._loop.call_exception_handler(&#123;<br>                <span class="hljs-string">&#x27;message&#x27;</span>: <span class="hljs-string">f&#x27;Task <span class="hljs-subst">&#123;task!r&#125;</span> has errored out but its parent &#x27;</span><br>                           <span class="hljs-string">f&#x27;task <span class="hljs-subst">&#123;self._parent_task&#125;</span> is already completed&#x27;</span>,<br>                <span class="hljs-string">&#x27;exception&#x27;</span>: exc,<br>                <span class="hljs-string">&#x27;task&#x27;</span>: task,<br>            &#125;)<br>            <span class="hljs-keyword">return</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self._aborting <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> self._parent_cancel_requested:<br>            self._abort()<br>            self._parent_cancel_requested = <span class="hljs-literal">True</span><br>            self._parent_task.cancel()<br></code></pre></td></tr></table></figure>

<h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3.总结"></a>3.总结</h2><p>可以看到，这两个功能都是通过<code>task</code>把我们的调用向子协程进行传播，这样一来就可以通过<code>task</code>方便的控制对应的协程，但是这也有一个缺点，就是一处函数为<code>async</code>，则处处函数都是<code>async</code>（对于需要IO调用的函数来说），而<code>Go</code>语言的协程就没有这种担忧，但是<code>Go</code>语言创建的协程是无法被管理的，除非创建协程的时候把<code>Context</code>对象传进去，并在对应的协程中通过<code>channel</code>来捕获<code>Context</code>对象的方法，这就要求开发<code>Go</code>库的开发者需要有良好的开发能力，能考虑到使用者在调用时是否需要考虑到超时，结构化并发等需求。</p>
]]></content>
      <categories>
        <category>Python Asyncio</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Asyncio</tag>
      </tags>
  </entry>
  <entry>
    <title>Python Asyncio调度原理</title>
    <url>/2022/06/08/python_asyncio_schedule/</url>
    <content><![CDATA[<h2 id="前记"><a href="#前记" class="headerlink" title="前记"></a>前记</h2><p>在文章<a href="https://so1n.me/2022/04/11/python's_waitable_objects_in_asyncio/">《Python的可等待对象在Asyncio的作用》</a>中介绍了<code>Python</code>的可等待对象作用，特别是<code>Task</code>对象在启动的时候可以自我驱动，但是一个<code>Task</code>对象只能驱动一条执行链，如果要多条链执行（并发），还是需要<code>EventLoop</code>来安排驱动，接下来将通过<code>Python.Asyncio</code>库的源码来了解<code>EventLoop</code>是如何运作的。</p>
<span id="more"></span>
<h2 id="1-基本介绍"><a href="#1-基本介绍" class="headerlink" title="1.基本介绍"></a>1.基本介绍</h2><p><code>Python.Asyncio</code>是一个大而全的库，它包括很多功能，而跟核心调度相关的逻辑除了三种可等待对象外，还有其它一些功能，它们分别位于<code>runners.py</code>，<code>base_event.py</code>，<code>event.py</code>三个文件中。</p>
<p><code>runners.py</code>文件有一个主要的类–<code>Runner</code>，它的主要职责是做好进入协程模式的事件循环等到初始化工作，以及在退出协程模式时清理还在内存的协程，生成器等对象。</p>
<blockquote>
<p>协程模式只是为了能方便理解，对于计算机而言，并没有这样区分</p>
</blockquote>
<p><code>event.py</code>文件除了存放着<code>EventLoop</code>对象的接口以及获取和设置<code>EventLoop</code>的函数外，还有两个<code>EventLoop</code>可调度的对象，分别为<code>Handler</code>和<code>TimerHandler</code>，它们可以认为是<code>EvnetLoop</code>调用其它对象的容器，用于连接待调度对象和事件循环的关系，不过它们的实现非常简单，对于<code>Handler</code>，它的源码如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-comment"># 已经移除了一些不想关的代码</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Handle</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, callback, args, loop, context=<span class="hljs-literal">None</span></span>):</span><br>        <span class="hljs-comment"># 初始化上下文，确保执行的时候能找到Handle所在的上下文</span><br>        <span class="hljs-keyword">if</span> context <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            context = contextvars.copy_context()<br>        self._context = context<br>        self._loop = loop<br>        self._callback = callback<br>        self._args = args<br>        self._cancelled = <span class="hljs-literal">False</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">cancel</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-comment"># 设置当前Handle为取消状态</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self._cancelled:<br>            self._cancelled = <span class="hljs-literal">True</span><br>            self._callback = <span class="hljs-literal">None</span><br>            self._args = <span class="hljs-literal">None</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">cancelled</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> self._cancelled<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_run</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-comment"># 用于执行真正的函数，且通过context.run方法来确保在自己的上下文内执行。</span><br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-comment"># 保持在自己持有的上下文中执行对应的回调</span><br>            self._context.run(self._callback, *self._args)<br>        <span class="hljs-keyword">except</span> (SystemExit, KeyboardInterrupt):<br>            <span class="hljs-keyword">raise</span><br>        <span class="hljs-keyword">except</span> BaseException <span class="hljs-keyword">as</span> exc:<br>            cb = format_helpers._format_callback_source(<br>                self._callback, self._args)<br>            msg = <span class="hljs-string">f&#x27;Exception in callback <span class="hljs-subst">&#123;cb&#125;</span>&#x27;</span><br>            context = &#123;<br>                <span class="hljs-string">&#x27;message&#x27;</span>: msg,<br>                <span class="hljs-string">&#x27;exception&#x27;</span>: exc,<br>                <span class="hljs-string">&#x27;handle&#x27;</span>: self,<br>            &#125;<br>            self._loop.call_exception_handler(context)<br></code></pre></td></tr></table></figure>
<p>通过源码可以发现，<code>Handle</code>功能十分简单，提供了可以被取消以及可以在自己所处的上下文执行的功能，而<code>TimerHandle</code>继承于<code>Handle</code>比<code>Handle</code>多了一些和时间以及排序相关的参数，源码如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TimerHandle</span>(<span class="hljs-params">Handle</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, when, callback, args, loop, context=<span class="hljs-literal">None</span></span>):</span><br>        <span class="hljs-built_in">super</span>().__init__(callback, args, loop, context)<br>        self._when = when<br>        self._scheduled = <span class="hljs-literal">False</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__hash__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">hash</span>(self._when)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__lt__</span>(<span class="hljs-params">self, other</span>):</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(other, TimerHandle):<br>            <span class="hljs-keyword">return</span> self._when &lt; other._when<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NotImplemented</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__le__</span>(<span class="hljs-params">self, other</span>):</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(other, TimerHandle):<br>            <span class="hljs-keyword">return</span> self._when &lt; other._when <span class="hljs-keyword">or</span> self.__eq__(other)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NotImplemented</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__gt__</span>(<span class="hljs-params">self, other</span>):</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(other, TimerHandle):<br>            <span class="hljs-keyword">return</span> self._when &gt; other._when<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NotImplemented</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__ge__</span>(<span class="hljs-params">self, other</span>):</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(other, TimerHandle):<br>            <span class="hljs-keyword">return</span> self._when &gt; other._when <span class="hljs-keyword">or</span> self.__eq__(other)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NotImplemented</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__eq__</span>(<span class="hljs-params">self, other</span>):</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(other, TimerHandle):<br>            <span class="hljs-keyword">return</span> (self._when == other._when <span class="hljs-keyword">and</span><br>                    self._callback == other._callback <span class="hljs-keyword">and</span><br>                    self._args == other._args <span class="hljs-keyword">and</span><br>                    self._cancelled == other._cancelled)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NotImplemented</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">cancel</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self._cancelled:<br>            <span class="hljs-comment"># 用于通知事件循环当前Handle已经退出了</span><br>            self._loop._timer_handle_cancelled(self)<br>        <span class="hljs-built_in">super</span>().cancel()<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">when</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> self._when<br></code></pre></td></tr></table></figure>
<p>通过代码可以发现，这两个对象十分简单，而我们在使用<code>Python.Asyncio</code>时并不会直接使用到这两个对象，而是通过<code>loop.call_xxx</code>系列方法来把调用封装成<code>Handle</code>对象，然后等待<code>EventLoop</code>执行。<br>所以<code>loop.call_xxx</code>系列方法可以认为是<code>EventLoop</code>的注册操作，基本上所有非IO的异步操作都需要通过<code>loop.call_xxx</code>方法来把自己的调用注册到<code>EventLoop</code>中，比如<code>Task</code>对象就在初始化后通过调用<code>loop.call_soon</code>方法来注册到<code>EventLoop</code>中，<code>loop.call_sonn</code>的实现很简单，它的源码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseEventLoop</span>:</span><br>    ...<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">call_soon</span>(<span class="hljs-params">self, callback, *args, context=<span class="hljs-literal">None</span></span>):</span><br>        <span class="hljs-comment"># 检查是否事件循环是否关闭，如果是则直接抛出异常</span><br>        self._check_closed()<br>        handle = self._call_soon(callback, args, context)<br>        <span class="hljs-keyword">return</span> handle<br><br>   <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_call_soon</span>(<span class="hljs-params">self, callback, args, context</span>):</span><br>        <span class="hljs-comment"># 把调用封装成一个handle，这样方便被事件循环调用</span><br>        handle = events.Handle(callback, args, self, context)<br>        <span class="hljs-comment"># 添加一个handle到_ready，等待被调用</span><br>        self._ready.append(handle)<br>        <span class="hljs-keyword">return</span> handle<br></code></pre></td></tr></table></figure>
<p>可以看到<code>call_soon</code>真正相关的代码只有10几行，它负责把一个调用封装成一个<code>Handle</code>，并添加到<code>self._reday</code>中，从而实现把调用注册到事件循环之中。</p>
<p><code>loop.call_xxx</code>系列函数除了<code>loop.call_soon</code>系列函数外，还有另外两个方法–<code>loop.call_at</code>和<code>loop.call_later</code>，它们类似于<code>loop.call_soon</code>，不过多了一个时间参数，来告诉<code>EventLoop</code>在什么时间后才可以调用，同时通过<code>loop.call_at</code>和<code>loop.call_later</code>注册的调用会通过<code>Python</code>的堆排序模块<code>headpq</code>注册到<code>self._scheduled</code>变量中，具体代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseEventLoop</span>:</span><br>    ...<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">call_later</span>(<span class="hljs-params">self, delay, callback, *args, context=<span class="hljs-literal">None</span></span>):</span><br>        <span class="hljs-keyword">if</span> delay <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">raise</span> TypeError(<span class="hljs-string">&#x27;delay must not be None&#x27;</span>)<br>        timer = self.call_at(self.time() + delay, callback, *args, context=context)<br>        <span class="hljs-keyword">return</span> timer<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">call_at</span>(<span class="hljs-params">self, when, callback, *args, context=<span class="hljs-literal">None</span></span>):</span><br>        <span class="hljs-keyword">if</span> when <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">raise</span> TypeError(<span class="hljs-string">&quot;when cannot be None&quot;</span>)<br>        self._check_closed()<br>        <span class="hljs-comment"># 创建一个timer handle，然后添加到事件循环的_scheduled中，等待被调用</span><br>        timer = events.TimerHandle(when, callback, args, self, context)<br>        heapq.heappush(self._scheduled, timer)<br>        timer._scheduled = <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">return</span> timer<br></code></pre></td></tr></table></figure>

<h2 id="2-EventLoop的调度实现"><a href="#2-EventLoop的调度实现" class="headerlink" title="2.EventLoop的调度实现"></a>2.EventLoop的调度实现</h2><p>在文章<a href="https://so1n.me/2022/04/11/python's_waitable_objects_in_asyncio/">《Python的可等待对象在Asyncio的作用》</a>中已经分析到了<code>runner</code>会通过<code>loop.run_until_complete</code>来调用<code>main</code>Task从而开启<code>EventLoop</code>的调度，所以在分析<code>EventLoop</code>的调度时，应该先从<code>loop.run_until_complete</code>入手，对应的源码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseEventLoop</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run_until_complete</span>(<span class="hljs-params">self, future</span>):</span><br>        ...<br><br>        new_task = <span class="hljs-keyword">not</span> futures.isfuture(future)<br>        <span class="hljs-comment"># 把coroutine转换成task，这样事件循环就可以调度了，事件循环的最小调度单位为task</span><br>        <span class="hljs-comment"># 需要注意的是此时事件循环并没注册到全局变量中，所以需要显示的传进去，</span><br>        <span class="hljs-comment"># 同时Task对象注册的时候，已经通过loop.call_soon把自己注册到事件循环中，等待调度</span><br>        future = tasks.ensure_future(future, loop=self)<br>        <span class="hljs-keyword">if</span> new_task:<br>            <span class="hljs-comment"># An exception is raised if the future didn&#x27;t complete, so there</span><br>            <span class="hljs-comment"># is no need to log the &quot;destroy pending task&quot; message</span><br>            future._log_destroy_pending = <span class="hljs-literal">False</span><br><br>        <span class="hljs-comment"># 当该task完成时，意味着当前事件循环失去了调度对象，无法继续调度，所以需要关闭当前事件循环，程序会由协程模式返回到线程模式</span><br>        future.add_done_callback(_run_until_complete_cb)<br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-comment"># 事件循环开始运行</span><br>            self.run_forever()<br>        <span class="hljs-keyword">except</span>:<br>            <span class="hljs-keyword">if</span> new_task <span class="hljs-keyword">and</span> future.done() <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> future.cancelled():<br>                <span class="hljs-comment"># The coroutine raised a BaseException. Consume the exception</span><br>                <span class="hljs-comment"># to not log a warning, the caller doesn&#x27;t have access to the</span><br>                <span class="hljs-comment"># local task.</span><br>                future.exception()<br>            <span class="hljs-keyword">raise</span><br>        <span class="hljs-keyword">finally</span>:<br>            future.remove_done_callback(_run_until_complete_cb)<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> future.done():<br>            <span class="hljs-keyword">raise</span> RuntimeError(<span class="hljs-string">&#x27;Event loop stopped before Future completed.&#x27;</span>)<br><br>        <span class="hljs-keyword">return</span> future.result()<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run_forever</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-comment"># 进行一些初始化工作</span><br>        self._check_closed()<br>        self._check_running()<br>        self._set_coroutine_origin_tracking(self._debug)<br>        self._thread_id = threading.get_ident()<br><br>        old_agen_hooks = sys.get_asyncgen_hooks()<br>        <span class="hljs-comment"># 通过asyncgen钩子来自动关闭asyncgen函数，这样可以提醒用户生成器还未关闭</span><br>        sys.set_asyncgen_hooks(firstiter=self._asyncgen_firstiter_hook,<br>                               finalizer=self._asyncgen_finalizer_hook)<br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-comment"># 设置当前在运行的事件循环到全局变量中，这样就可以在任一阶段获取到当前的事件循环了</span><br>            events._set_running_loop(self)<br>            <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>                <span class="hljs-comment"># 正真执行任务的逻辑</span><br>                self._run_once()<br>                <span class="hljs-keyword">if</span> self._stopping:<br>                    <span class="hljs-keyword">break</span><br>        <span class="hljs-keyword">finally</span>:<br>            <span class="hljs-comment"># 关闭循环, 并且清理一些资源</span><br>            self._stopping = <span class="hljs-literal">False</span><br>            self._thread_id = <span class="hljs-literal">None</span><br>            events._set_running_loop(<span class="hljs-literal">None</span>)<br>            self._set_coroutine_origin_tracking(<span class="hljs-literal">False</span>)<br>            sys.set_asyncgen_hooks(*old_agen_hooks)<br></code></pre></td></tr></table></figure>
<p>这段源码并不复杂，它的主要逻辑是通过把<code>Corotinue</code>转为一个<code>Task</code>对象，然后通过<code>Task</code>对象初始化时调用<code>loop.call_sonn</code>方法把自己注册到<code>EventLoop</code>中，最后再通过<code>loop.run_forever</code>中的循环代码一直运行着，直到<code>_stopping</code>被标记为<code>True</code>:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    <span class="hljs-comment"># 正真执行任务的逻辑</span><br>    self._run_once()<br>    <span class="hljs-keyword">if</span> self._stopping:<br>        <span class="hljs-keyword">break</span><br></code></pre></td></tr></table></figure>
<p>可以看出，这段代码是确保事件循环能一直执行着，自动循环结束，而真正调度的核心是<code>_run_once</code>函数，它的源码如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseEventLoop</span>:</span><br>    ...<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_run_once</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-comment"># self._scheduled是一个列表，它只存放TimerHandle</span><br>        sched_count = <span class="hljs-built_in">len</span>(self._scheduled)<br>        <span class="hljs-comment">###############################</span><br>        <span class="hljs-comment"># 第一阶段，整理self._scheduled #</span><br>        <span class="hljs-comment">###############################</span><br>        <span class="hljs-keyword">if</span> (sched_count &gt; _MIN_SCHEDULED_TIMER_HANDLES <span class="hljs-keyword">and</span><br>            self._timer_cancelled_count / sched_count &gt; _MIN_CANCELLED_TIMER_HANDLES_FRACTION):<br>            <span class="hljs-comment"># 当待调度的任务数量超过100且待取消的任务占总任务的50%时，才进入这个逻辑</span><br>            <span class="hljs-comment"># 把需要取消的任务移除</span><br>            new_scheduled = []<br>            <span class="hljs-keyword">for</span> handle <span class="hljs-keyword">in</span> self._scheduled:<br>                <span class="hljs-keyword">if</span> handle._cancelled:<br>                    <span class="hljs-comment"># 设置handle的_cancelled为True，并且把handle从_scheduled中移除</span><br>                    handle._scheduled = <span class="hljs-literal">False</span><br>                <span class="hljs-keyword">else</span>:<br>                    new_scheduled.append(handle)<br><br>            <span class="hljs-comment"># 重新排列堆</span><br>            heapq.heapify(new_scheduled)<br>            self._scheduled = new_scheduled<br>            self._timer_cancelled_count = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-comment"># 需要取消的handle不多，则只会走这个逻辑，这里会把堆顶的handle弹出，并标记为不可调度，但不会访问整个堆</span><br>            <span class="hljs-keyword">while</span> self._scheduled <span class="hljs-keyword">and</span> self._scheduled[<span class="hljs-number">0</span>]._cancelled:<br>                self._timer_cancelled_count -= <span class="hljs-number">1</span><br>                handle = heapq.heappop(self._scheduled)<br>                handle._scheduled = <span class="hljs-literal">False</span><br><br>        <span class="hljs-comment">#################################</span><br>        <span class="hljs-comment"># 第二阶段，计算超时值以及等待事件IO #</span><br>        <span class="hljs-comment">#################################</span><br>        timeout = <span class="hljs-literal">None</span><br>        <span class="hljs-comment"># 当有准备调度的handle或者是正在关闭时，不等待，方便尽快的调度</span><br>        <span class="hljs-keyword">if</span> self._ready <span class="hljs-keyword">or</span> self._stopping:<br>            timeout = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">elif</span> self._scheduled:<br>            <span class="hljs-comment"># Compute the desired timeout.</span><br>            <span class="hljs-comment"># 如果堆有数据时，通过堆顶的handle计算最短的超时时间，但是最多不能超过MAXIMUM_SELECT_TIMEOUT，以免超过系统限制</span><br>            when = self._scheduled[<span class="hljs-number">0</span>]._when<br>            timeout = <span class="hljs-built_in">min</span>(<span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, when - self.time()), MAXIMUM_SELECT_TIMEOUT)<br><br>        <span class="hljs-comment"># 事件循环等待事件，直到有事件或者超时</span><br>        event_list = self._selector.select(timeout)<br><br>        <span class="hljs-comment">##################################################</span><br>        <span class="hljs-comment"># 第三阶段，把满足条件的TimeHandle放入到self._ready中 #</span><br>        <span class="hljs-comment">##################################################</span><br>        <span class="hljs-comment"># 获取得到的事件的回调，然后装填到_ready</span><br>        self._process_events(event_list)<br><br>        <span class="hljs-comment"># 把一些在self._scheduled且满足调度条件的handle放到_ready中，比如TimerHandle。</span><br>        <span class="hljs-comment"># end_time为当前时间+一个时间单位，猜测是能多处理一些这段时间内产生的事件</span><br>        end_time = self.time() + self._clock_resolution<br>        <span class="hljs-keyword">while</span> self._scheduled:<br>            handle = self._scheduled[<span class="hljs-number">0</span>]<br>            <span class="hljs-keyword">if</span> handle._when &gt;= end_time:<br>                <span class="hljs-keyword">break</span><br>            handle = heapq.heappop(self._scheduled)<br>            handle._scheduled = <span class="hljs-literal">False</span><br>            self._ready.append(handle)<br><br>        <span class="hljs-comment">################################################################################</span><br>        <span class="hljs-comment"># 第四阶段，遍历所有准备调度的handle，并且通过handle的context来执行handle对应的callback #</span><br>        <span class="hljs-comment">################################################################################</span><br>        ntodo = <span class="hljs-built_in">len</span>(self._ready)<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(ntodo):<br>            handle = self._ready.popleft()<br>            <span class="hljs-comment"># 如果handle已经被取消，则不调用</span><br>            <span class="hljs-keyword">if</span> handle._cancelled:<br>                <span class="hljs-keyword">continue</span><br>            <span class="hljs-keyword">if</span> self._debug:<br>                <span class="hljs-keyword">try</span>:<br>                    self._current_handle = handle<br>                    t0 = self.time()<br>                    handle._run()<br>                    dt = self.time() - t0<br>                    <span class="hljs-keyword">if</span> dt &gt;= self.slow_callback_duration:<br>                        <span class="hljs-comment"># 执行太久的回调，记录下来，这些需要开发者自己优化</span><br>                        logger.warning(<span class="hljs-string">&#x27;Executing %s took %.3f seconds&#x27;</span>,<br>                                       _format_handle(handle), dt)<br>                <span class="hljs-keyword">finally</span>:<br>                    self._current_handle = <span class="hljs-literal">None</span><br>            <span class="hljs-keyword">else</span>:<br>                handle._run()<br>        handle = <span class="hljs-literal">None</span>  <span class="hljs-comment"># Needed to break cycles when an exception occurs.</span><br></code></pre></td></tr></table></figure>
<p>通过源码分析，可以很明确的知道调度逻辑中第一步是先规整<code>self._scheduled</code>，在规整的过程是使用堆排序来进行的，因为堆排序在调度的场景下效率是非常高的，不过这段规整代码分成两种，我猜测是当需要取消的数量过多时直接遍历的效率会更高。<br>在规整<code>self._scheduled</code>后，就进入第二步，该步骤开始等待系统事件循环返回对应的事件，如果<code>self._ready</code>中有数据，就不做等待了，需要马上到下一步骤，以便能赶紧安排调度。<br>在得到系统事件循环得到的事件后，就进入到了第三步，该步骤会通过<code>self._process_events</code>方法处理对应的事件，并把事件对应的回调存放到了<code>self._ready</code>中，最后再遍历<code>self._ready</code>中的所有<code>Handle</code>并逐一执行(执行时可以认为<code>EventLoop</code>把控制权返回给对应的调用逻辑)，至此一个完整的调度逻辑就结束了，并进入下一个调度逻辑。</p>
<h2 id="3-网络IO事件的处理"><a href="#3-网络IO事件的处理" class="headerlink" title="3.网络IO事件的处理"></a>3.网络IO事件的处理</h2><blockquote>
<p>注：由于系统事件循环的限制，所以文件IO一般还是使用多线程来执行，具体见：<a href="https://github.com/python/asyncio/wiki/ThirdParty#filesystem">https://github.com/python/asyncio/wiki/ThirdParty#filesystem</a></p>
</blockquote>
<p>在分析<code>EventLoop</code>调度实现的时候忽略了<code>self._process_events</code>的具体实现逻辑，因为<code>_process_events</code>方法所在<code>asyncio.base_event.py</code>文件中的<code>BaseEventLoop</code>类并未有具体实现的，因为网络IO相关的需要系统的事件循环来帮忙处理，所以与系统事件循环相关的逻辑都在<code>asyncio.selector_events.py</code>中的<code>BaseSelectorEventLoop</code>类中。<code>BaseSelectorEventLoop</code>类封装了<code>selector</code>模块与系统事件循环交互，使调用者不需要去考虑sock的创建以及sock产生的文件描述符的监听与注销等操作，下面以<code>BaseSelectorEventLoop</code>中自带的pipe为例子，分析<code>BaseSelectorEventLoop</code>是如何进行网络IO事件处理的。</p>
<p>在分析之前，先看一个例子，代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> asyncio<br><span class="hljs-keyword">import</span> threading<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">task</span>():</span><br>    print(<span class="hljs-string">&quot;task&quot;</span>)<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run_loop_inside_thread</span>(<span class="hljs-params">loop</span>):</span><br>    loop.run_forever()<br><br><br>loop = asyncio.get_event_loop()<br>threading.Thread(target=run_loop_inside_thread, args=(loop,)).start()<br>loop.call_soon(task)<br></code></pre></td></tr></table></figure>
<p>如果直接运行这个例子，它并不会输出<code>task</code>（不过在IDE使用DEBUG模式下线程启动会慢一点，所以会输出的），因为在调用<code>loop.run_forever</code>后<code>EventLoop</code>会一直卡在这段逻辑中:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python">event_list = self._selector.select(timeout)<br></code></pre></td></tr></table></figure>
<p>所以调用<code>loop.call_soon</code>并不会使<code>EventLoop</code>马上安排调度，而如果把<code>call_soon</code>换成<code>call_soon_threadsafe</code>则可以正常输出，这是因为<code>call_soon_threadsafe</code>中多了一个<code>self._write_to_self</code>的调用，它的源码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseEventLoop</span>:</span><br>    ...<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">call_soon_threadsafe</span>(<span class="hljs-params">self, callback, *args, context=<span class="hljs-literal">None</span></span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;Like call_soon(), but thread-safe.&quot;&quot;&quot;</span><br>        self._check_closed()<br>        handle = self._call_soon(callback, args, context)<br>        self._write_to_self()<br>        <span class="hljs-keyword">return</span> handle<br></code></pre></td></tr></table></figure>
<p>由于这个调用是涉及到IO相关的，所以需要到<code>BaseSelectorEventLoop</code>类查看，接下来以pipe相关的网络IO操作来分析<code>EventLoop</code>是如何处理IO事件的(只演示reader对象，writer对象操作与reader类似)，对应的源码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseSelectorEventLoop</span>(<span class="hljs-params">base_events.BaseEventLoop</span>):</span><br><br>    <span class="hljs-comment">#######</span><br>    <span class="hljs-comment"># 创建 #</span><br>    <span class="hljs-comment">#######</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, selector=<span class="hljs-literal">None</span></span>):</span><br>        <span class="hljs-built_in">super</span>().__init__()<br><br>        <span class="hljs-keyword">if</span> selector <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-comment"># 获取最优的selector</span><br>            selector = selectors.DefaultSelector()<br>        self._selector = selector<br>        <span class="hljs-comment"># 创建pipe</span><br>        self._make_self_pipe()<br>        self._transports = weakref.WeakValueDictionary()<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_make_self_pipe</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-comment"># 创建Pipe对应的sock </span><br>        self._ssock, self._csock = socket.socketpair()<br>        <span class="hljs-comment"># 设置sock为非阻塞</span><br>        self._ssock.setblocking(<span class="hljs-literal">False</span>)<br>        self._csock.setblocking(<span class="hljs-literal">False</span>)<br>        self._internal_fds += <span class="hljs-number">1</span><br>        <span class="hljs-comment"># 阻塞服务端sock读事件对应的回调</span><br>        self._add_reader(self._ssock.fileno(), self._read_from_self)<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_add_reader</span>(<span class="hljs-params">self, fd, callback, *args</span>):</span><br>        <span class="hljs-comment"># 检查事件循环是否关闭</span><br>        self._check_closed()<br>        <span class="hljs-comment"># 封装回调为handle对象</span><br>        handle = events.Handle(callback, args, self, <span class="hljs-literal">None</span>)<br>        <span class="hljs-keyword">try</span>:<br>            key = self._selector.get_key(fd)<br>        <span class="hljs-keyword">except</span> KeyError:<br>            <span class="hljs-comment"># 如果没有注册到系统的事件循环，则注册</span><br>            self._selector.register(fd, selectors.EVENT_READ,<br>                                    (handle, <span class="hljs-literal">None</span>))<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-comment"># 如果已经注册过，则更新</span><br>            mask, (reader, writer) = key.events, key.data<br>            self._selector.modify(fd, mask | selectors.EVENT_READ,<br>                                  (handle, writer))<br>            <span class="hljs-keyword">if</span> reader <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>                reader.cancel()<br>        <span class="hljs-keyword">return</span> handle<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_read_from_self</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-comment"># 负责消费sock数据</span><br>        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>            <span class="hljs-keyword">try</span>:<br>                data = self._ssock.recv(<span class="hljs-number">4096</span>)<br>                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> data:<br>                    <span class="hljs-keyword">break</span><br>                self._process_self_data(data)<br>            <span class="hljs-keyword">except</span> InterruptedError:<br>                <span class="hljs-keyword">continue</span><br>            <span class="hljs-keyword">except</span> BlockingIOError:<br>                <span class="hljs-keyword">break</span><br><br>    <span class="hljs-comment">#######</span><br>    <span class="hljs-comment"># 删除 #</span><br>    <span class="hljs-comment">#######</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_close_self_pipe</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-comment"># 注销Pipe对应的描述符 </span><br>        self._remove_reader(self._ssock.fileno())<br>        <span class="hljs-comment"># 关闭sock</span><br>        self._ssock.close()<br>        self._ssock = <span class="hljs-literal">None</span><br>        self._csock.close()<br>        self._csock = <span class="hljs-literal">None</span><br>        self._internal_fds -= <span class="hljs-number">1</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_remove_reader</span>(<span class="hljs-params">self, fd</span>):</span><br>        <span class="hljs-comment"># 如果事件循环已经关闭了，就不用操作了</span><br>        <span class="hljs-keyword">if</span> self.is_closed():<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-comment"># 查询文件描述符是否在selector中</span><br>            key = self._selector.get_key(fd)<br>        <span class="hljs-keyword">except</span> KeyError:<br>            <span class="hljs-comment"># 不存在则返回</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-comment"># 存在则进入移除的工作</span><br>            mask, (reader, writer) = key.events, key.data<br>            <span class="hljs-comment"># 通过事件掩码判断是否有其它事件</span><br>            mask &amp;= ~selectors.EVENT_READ<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> mask:<br>                <span class="hljs-comment"># 移除已经注册到selector的文件描述符</span><br>                self._selector.unregister(fd)<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-comment"># 移除已经注册到selector的文件描述符，并注册新的事件</span><br>                self._selector.modify(fd, mask, (<span class="hljs-literal">None</span>, writer))<br><br>            <span class="hljs-comment"># 如果reader不为空，则取消reader</span><br>            <span class="hljs-keyword">if</span> reader <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>                reader.cancel()<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure>
<p>通过源码中的创建部分可以看到，<code>EventLoop</code>在启动的时候会创建一对建立通信的sock，并设置为非阻塞，然后把对应的回调封装成一个<code>Handle</code>对象并注册到系统事件循环中（删除则进行对应的反向操作），之后系统事件循环就会一直监听对应的事件，也就是<code>EventLoop</code>的执行逻辑会阻塞在下面的调用中，等待事件响应：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python">event_list = self._selector.select(timeout)<br></code></pre></td></tr></table></figure>
<p>这时如果执行<code>loop.call_soon_threadsafe</code>，那么会通过<code>write_to_self</code>写入一点信息：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_write_to_self</span>(<span class="hljs-params">self</span>):</span><br>    csock = self._csock<br>    <span class="hljs-keyword">if</span> csock <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>        <span class="hljs-keyword">return</span><br><br>    <span class="hljs-keyword">try</span>:<br>        csock.send(<span class="hljs-string">b&#x27;\0&#x27;</span>)<br>    <span class="hljs-keyword">except</span> OSError:<br>        <span class="hljs-keyword">if</span> self._debug:<br>            logger.debug(<span class="hljs-string">&quot;Fail to write a null byte into the self-pipe socket&quot;</span>, exc_info=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure>
<p>由于<code>csock</code>被写入了数据，那么它对应的<code>ssock</code>就会收到一个读事件，系统事件循环在收到这个事件通知后就会把数据返回，然后<code>EventLoop</code>就会获得到对应的数据，并交给<code>process_events</code>方法进行处理，它的相关代码如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseSelectorEventLoop</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_process_events</span>(<span class="hljs-params">self, event_list</span>):</span><br>        <span class="hljs-keyword">for</span> key, mask <span class="hljs-keyword">in</span> event_list:<br>            <span class="hljs-comment"># 从回调事件中获取到对应的数据，key.data在注册时是一个元祖，所以这里要对元祖进行解包</span><br>            fileobj, (reader, writer) = key.fileobj, key.data<br>            <span class="hljs-keyword">if</span> mask &amp; selectors.EVENT_READ <span class="hljs-keyword">and</span> reader <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>                <span class="hljs-comment"># 得到reader handle，如果是被标记为取消，就移除对应的文件描述符</span><br>                <span class="hljs-keyword">if</span> reader._cancelled:<br>                    self._remove_reader(fileobj)<br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-comment"># 如果没被标记为取消，则安排到self._ready中</span><br>                    self._add_callback(reader)<br>            <span class="hljs-keyword">if</span> mask &amp; selectors.EVENT_WRITE <span class="hljs-keyword">and</span> writer <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>                <span class="hljs-comment"># 对于写对象，也是同样的道理。</span><br>                <span class="hljs-keyword">if</span> writer._cancelled:<br>                    self._remove_writer(fileobj)<br>                <span class="hljs-keyword">else</span>:<br>                    self._add_callback(writer)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_add_callback</span>(<span class="hljs-params">self, handle</span>):</span><br>        <span class="hljs-comment"># 把回调的handle添加到_ready中</span><br>        <span class="hljs-keyword">assert</span> <span class="hljs-built_in">isinstance</span>(handle, events.Handle), <span class="hljs-string">&#x27;A Handle is required here&#x27;</span><br>        <span class="hljs-keyword">if</span> handle._cancelled:<br>            <span class="hljs-keyword">return</span><br>        <span class="hljs-keyword">assert</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">isinstance</span>(handle, events.TimerHandle)<br>        self._ready.append(handle)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_remove_reader</span>(<span class="hljs-params">self, fd</span>):</span><br>        <span class="hljs-comment"># 如果事件循环已经关闭了，就不用操作了</span><br>        <span class="hljs-keyword">if</span> self.is_closed():<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-comment"># 查询文件描述符是否在selector中</span><br>            key = self._selector.get_key(fd)<br>        <span class="hljs-keyword">except</span> KeyError:<br>            <span class="hljs-comment"># 不存在则返回</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-comment"># 存在则进入移除的工作</span><br>            mask, (reader, writer) = key.events, key.data<br>            mask &amp;= ~selectors.EVENT_READ<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> mask:<br>                <span class="hljs-comment"># 移除已经注册到selector的文件描述符</span><br>                self._selector.unregister(fd)<br>            <span class="hljs-keyword">else</span>:<br>                self._selector.modify(fd, mask, (<span class="hljs-literal">None</span>, writer))<br><br>            <span class="hljs-keyword">if</span> reader <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>                reader.cancel()<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure>
<p>从代码中可以看出<code>_process_events</code>会对事件对应的文件描述符进行处理，并从事件回调中获取到对应的<code>Handle</code>对象添加到<code>self._ready</code>中，由<code>EventLoop</code>在接下来遍历<code>self._ready</code>并执行。</p>
<p>可以看到网络IO事件的处理并不复杂，因为系统事件循环已经为我们做了很多工作了，但是用户所有与网络IO相关的操作都需要有一个类似的操作，这样是非常的繁琐的，幸好<code>asyncio</code>库已经为我们做了封装，我们只要调用就可以了，方便了很多。</p>
]]></content>
      <categories>
        <category>Python Asyncio</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Asyncio</tag>
      </tags>
  </entry>
  <entry>
    <title>Python-gRPC实践(6)--编写gRPC网关</title>
    <url>/2022/05/23/Python-gRPC%E5%AE%9E%E8%B7%B5(6)--%E7%BC%96%E5%86%99gRPC%E7%BD%91%E5%85%B3%20copy/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>就目前而言，在大多数场景中，用户侧的客户端和服务端还是通过HTTP进行交互，然后服务端内部各种服务再通过过各种协议进行交互，所以在采用了gRPC做内部服务的交互协议后，就需要一个网关来把gRPC的调用自动映射到HTTP应用上，方便客户端调用。</p>
<blockquote>
<p>注：本文只针对一对一的gRPC服务。</p>
<p>之前原本想当做一个简单的实现，后面发现可以与我编写的<a href="https://github.com/so1n/pait">pait</a>框架可以嵌到一起，这样也可以对多个Web框架提供Gateway功能，于是就把这个功能的实现嵌入到<a href="https://github.com/so1n/pait">pait</a>框架中，所以下面有些代码来自于我编写的<a href="https://github.com/so1n/pait">pait</a>框架，对应的gRPC网关文档使用说明见:<a href="https://so1n.me/pait-zh-doc/7_gRPC_gateway/">Pait gRPC Gateway</a></p>
</blockquote>
<h2 id="1-网关的基础实现思路"><a href="#1-网关的基础实现思路" class="headerlink" title="1.网关的基础实现思路"></a>1.网关的基础实现思路</h2><p>网关的思路很简单，就是把HTTP请求转发到了对应的gRPC服务，在<code>Go</code>生态中，已经出现了一个类似的框架–<a href="https://github.com/grpc-ecosystem/grpc-gateway">grpc-gateway</a>，它负责grpc服务自动的映射到HTTP服务中，同时它通过让HTTP服务和gRPC服务监听同一个端口来降低使用者的疑惑。</p>
<p>通过前面的文章我们了解到，gRPC采用的是HTTP/2做传输协议，而HTTP/2是对于HTTP/1.1的一个升级，这样的话服务端在接收socket的数据且转为HTTP数据后就可以判断Header中<code>Upgrade</code>字段对应的值来把数据分别分发到HTTP服务和gRPC服务。</p>
<p>但是，<code>Python</code>的gRPC是通过gRPC-C转译的，也就是它的底层是C实现的，所以<code>Python</code>的gRPC无法传socket来启动服务，而是只能通过指定ip:port的形式来启动服务，如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> grpc<br><span class="hljs-keyword">from</span> concurrent <span class="hljs-keyword">import</span> futures<br><br>grpc.server(<br>    futures.ThreadPoolExecutor(max_workers=<span class="hljs-number">10</span>),<br>).add_insecure_port(<span class="hljs-string">&quot;127.0.0.1:9000&quot;</span>)<br></code></pre></td></tr></table></figure>
<p>这样上述的做法就无法实现了，只能让HTTP服务和gRPC服务分别监听不同的端口，无法做到像<a href="https://github.com/grpc-ecosystem/grpc-gateway">Go grpc-gateway</a>那样，毕竟Go才是亲儿子。</p>
<p>最终只能以下面的方式实现：<br><img   class="lazyload" data-original="https://cdn.jsdelivr.net/gh/so1n/so1n_blog_photo@master/blog_photo/1653363969391gRPC-Gateway.jpg" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" ><br>图中客户端发起的请求会先发送到HTTP服务绑定的端口，HTTP服务收到请求后，会转发到gRPC客户端，交由gRPC客户端发送到gRPC服务端，这样一系列服务就串起来了。</p>
<blockquote>
<p>图中的示例HTTP服务与gRPC客户端在同一个进程，而gRPC服务在同台机器的另外一个进程，但是他们也可以在同一个进程内。</p>
</blockquote>
<h2 id="2-如何编写转发路由"><a href="#2-如何编写转发路由" class="headerlink" title="2.如何编写转发路由"></a>2.如何编写转发路由</h2><p>总体思路决定后，就开始细究路由的实现了，路由只负责转发，不做其它功能，通过前面文章<a href="https://so1n.me/2022/01/05/Python-gRPC%E5%AE%9E%E8%B7%B5(1)--%E7%AE%80%E4%BB%8B/">Python-gRPC实践（1）–gRPC简介</a>的捉包可以知道，gRPC传输数据时，采用的是HTTP/2来传输请求，用的是POST方法，同时使用Body传输数据，那么我们可以采用尽量相似的方法来接收请求，再通过gRPC客户端传到对应的服务端，如下的Proto文件:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs proto">syntax &#x3D; &quot;proto3&quot;;<br>package example;<br><br><br>message LoginUserRequest &#123;<br>  string uid &#x3D; 1;<br>  string password &#x3D; 2;<br>&#125;<br>message LoginUserResult &#123;<br>  string uid &#x3D; 1;<br>  string user_name &#x3D; 2;<br>  string token &#x3D; 3;<br>&#125;<br><br><br>service User &#123;<br>    rpc login_user(LoginUserRequest) returns (LoginUserResult);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>接着，以这种方法来创建一个路由来映射这个Proto文件的请求，这个路由采用POST方法然后解析对应的数据并通过对应的gRPC客户端传递到服务端，为了尽量的跟gRPC一致，所以HTTP服务与客户端通过Json进行交互，映射的路由代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> grpc<br><span class="hljs-keyword">from</span> starlette.applications <span class="hljs-keyword">import</span> Starlette<br><span class="hljs-keyword">from</span> starlette.routing <span class="hljs-keyword">import</span> Route<br><span class="hljs-keyword">from</span> starlette.requests <span class="hljs-keyword">import</span> Request<br><span class="hljs-keyword">from</span> starlette.responses <span class="hljs-keyword">import</span> JSONResponse<br><br><span class="hljs-comment"># pait项目的演示代码，由Proto文件生产的</span><br><span class="hljs-keyword">from</span> example.example_grpc.python_example_proto_code.example_proto.user <span class="hljs-keyword">import</span> user_pb2<br><span class="hljs-keyword">from</span> example.example_grpc.python_example_proto_code.example_proto.user <span class="hljs-keyword">import</span> user_pb2_grpc<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">login_route</span>(<span class="hljs-params">request: Request</span>) -&gt; JSONResponse:</span><br>    <span class="hljs-comment"># 接收请求</span><br>    request_dict: <span class="hljs-built_in">dict</span> = <span class="hljs-keyword">await</span> request.json()<br>    user_service: user_pb2_grpc.UserStub = request.app.state.user_service<br>    <span class="hljs-comment"># 发送请求到对应的gRPC服务端</span><br>    result: user_pb2.LoginUserResult = user_service.login_user(<br>        user_pb2.LoginUserRequest(uid=request_dict[<span class="hljs-string">&quot;uid&quot;</span>], password=request_dict[<span class="hljs-string">&quot;password&quot;</span>])<br>    )<br>    <span class="hljs-comment"># 返回对应的响应</span><br>    <span class="hljs-keyword">return</span> JSONResponse(<br>        &#123;<br>            <span class="hljs-string">&quot;uid&quot;</span>: result.uid,<br>            <span class="hljs-string">&quot;user_name&quot;</span>: result.user_name,<br>            <span class="hljs-string">&quot;token&quot;</span>: result.token,<br>        &#125;<br>    )<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">create_app</span>() -&gt; Starlette:</span><br>    <span class="hljs-comment"># 绑定路由</span><br>    app: Starlette = Starlette(routes=[Route(<span class="hljs-string">&quot;/api/login&quot;</span>, login_route, methods=[<span class="hljs-string">&quot;POST&quot;</span>])])<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_before_server_start</span>() -&gt; <span class="hljs-keyword">None</span>:</span><br>        <span class="hljs-comment"># 启动时绑定gRPC客户端到对应的实例</span><br>        app.state.user_service = user_pb2_grpc.UserStub(grpc.aio.insecure_channel(<span class="hljs-string">&quot;0.0.0.0:9000&quot;</span>))<br>    <br>    app.add_event_handler(<span class="hljs-string">&quot;startup&quot;</span>, _before_server_start)<br>    <span class="hljs-keyword">return</span> app<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    <span class="hljs-keyword">import</span> uvicorn  <span class="hljs-comment"># type: ignore</span><br><br>    uvicorn.run(create_app(), log_level=<span class="hljs-string">&quot;debug&quot;</span>)<br></code></pre></td></tr></table></figure>
<p>这样一个简单的转发就编写完毕了，但是目前是手动编写的代码，意味着每新增一个接口，我们就需有编写一个对应的路由函数，同时如果Protobuf文件发生了变更，那么我们需要定位到对应的代码再修改，非常麻烦，特别是我们在定义Protobuf文件时，已经很像在定义一个接口了，结果还要再编写路由函数，效率非常低，所以一个网关最关键的是需要通过Protobuf文件或者通过Protobuf的产物来自动生成路由函数并映射到对应的服务，这样一来，其它使用者后续只要修改Protobuf文件即可。</p>
<h2 id="3-提取路由需要的数据"><a href="#3-提取路由需要的数据" class="headerlink" title="3.提取路由需要的数据"></a>3.提取路由需要的数据</h2><p>为了自动生成路由，还需要一些数据，通过编写的转发路由可以发现，我们只需要收到用户的请求，解析数据，然后通过对应的gRPC客户端方法来发送数据即可，所以需要通过这个gRPC客户端的方法来找到所有需要的数据（尝试了多种方法，目前这种是最优的）。</p>
<p>以上面的Protobuf文件自动生成的<code>Python</code>代码中的<code>user_pb2_grpc.UserStub</code>为例子(可以通过<a href="https://github.com/so1n/pait/tree/master/example/example_grpc">pait/example/example_grpc</a>了解)，它的代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> grpc<br><br><span class="hljs-keyword">from</span> example.example_grpc.python_example_proto_code.example_proto.user <span class="hljs-keyword">import</span> user_pb2 <span class="hljs-keyword">as</span> example__proto_dot_user_dot_user__pb2<br><span class="hljs-keyword">from</span> google.protobuf <span class="hljs-keyword">import</span> empty_pb2 <span class="hljs-keyword">as</span> google_dot_protobuf_dot_empty__pb2<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserStub</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, channel</span>):</span><br>        self.get_uid_by_token = channel.unary_unary(<br>                <span class="hljs-string">&#x27;/user.User/get_uid_by_token&#x27;</span>,<br>                request_serializer=example__proto_dot_user_dot_user__pb2.GetUidByTokenRequest.SerializeToString,<br>                response_deserializer=example__proto_dot_user_dot_user__pb2.GetUidByTokenResult.FromString,<br>                )<br>        self.logout_user = channel.unary_unary(<br>                <span class="hljs-string">&#x27;/user.User/logout_user&#x27;</span>,<br>                request_serializer=example__proto_dot_user_dot_user__pb2.LogoutUserRequest.SerializeToString,<br>                response_deserializer=google_dot_protobuf_dot_empty__pb2.Empty.FromString,<br>                )<br>        self.login_user = channel.unary_unary(<br>                <span class="hljs-string">&#x27;/user.User/login_user&#x27;</span>,<br>                request_serializer=example__proto_dot_user_dot_user__pb2.LoginUserRequest.SerializeToString,<br>                response_deserializer=example__proto_dot_user_dot_user__pb2.LoginUserResult.FromString,<br>                )<br>        self.create_user = channel.unary_unary(<br>                <span class="hljs-string">&#x27;/user.User/create_user&#x27;</span>,<br>                request_serializer=example__proto_dot_user_dot_user__pb2.CreateUserRequest.SerializeToString,<br>                response_deserializer=google_dot_protobuf_dot_empty__pb2.Empty.FromString,<br>                )<br>        self.delete_user = channel.unary_unary(<br>                <span class="hljs-string">&#x27;/user.User/delete_user&#x27;</span>,<br>                request_serializer=example__proto_dot_user_dot_user__pb2.DeleteUserRequest.SerializeToString,<br>                response_deserializer=google_dot_protobuf_dot_empty__pb2.Empty.FromString,<br>                )<br></code></pre></td></tr></table></figure>
<p>通过这份生成的代码可以发现，这个对象类中包括了每个调用的url，请求体和响应体，这样再加上上面说了gRPC是以POST方法进行请求的，那么构成一个最小路由的条件都已经满足了。<br>但是，要通过这份代码提取数据却比较麻烦，由于都是在<code>__init__</code>方法后才初始化各个gRPC的调用方法，所以没办法通过<code>dir(UserStub)</code>获取到对应的gRPC调用方法，只能通过<code>UserStub(channel).__dict__</code>来获取gRPC的调用方法，不过<code>channel</code>最好需要在对应的HTTP服务启动时再初始化，特别是对于uvicorn来说，如果grpc.aio.channel提前初始化，那么他们使用的不是同一个事件循环，这意味着就必须在Web实例启动后再注册路由，但由于<code>Sanic</code>等框架是不支持实例启动后再注册路由的，所以这个方法行不通。此外，示例代码中的请求体，响应体都是调用对应的方法再加载到<code>channel.unary_unary</code>中，之后我们没办法在运行时通过<code>UserStub</code>的实例来直接获取。</p>
<p>幸运的是，由Proto文件生成的<code>UserStub</code>对象是有规则的，所以可以在程序运行时获取到<code>UserStub</code>的源码，然后通过一定的规则把数据提取出来，分析上面的源码，可以发现有如下几个规则：</p>
<ul>
<li>1.<code>self.xxx</code>中是gRPC调用的方法名，同时<code>channel.unary_unary</code>代表了这是一对一的请求。</li>
<li>2.<code>self.xxx</code>的下面第一行是gRPC方法对应的url</li>
<li>3.<code>self.xxx</code>的下面第二行出现了gRPC方法的请求对象，这一行是以<code>request_serializer=</code>开头，以<code>.SerializeToString</code>结尾，可以通过正则提取中间的对象字符串，然后可以在运行时通过解析字符串从<code>UserStub</code>所在的模块中提取到正确的请求对象。</li>
<li>4.<code>self.xxx</code>的下面第三行则是gRPC方法的响应对象，处理方法跟请求对象类似。</li>
</ul>
<p>发现了规则后就可以通过规则提取对应的数据，具体代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> inspect<br><span class="hljs-keyword">import</span> re<br><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> Any, List, Generator, Optional, Type<br><span class="hljs-keyword">from</span> types <span class="hljs-keyword">import</span> ModuleType<br><span class="hljs-keyword">from</span> google.protobuf.message <span class="hljs-keyword">import</span> Message<br><br><span class="hljs-keyword">from</span> example.example_grpc.python_example_proto_code.example_proto.user <span class="hljs-keyword">import</span> user_pb2_grpc<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_gen_message</span>(<span class="hljs-params">class_module: ModuleType, line: <span class="hljs-built_in">str</span>, match_str: <span class="hljs-built_in">str</span></span>) -&gt; Type[Message]:</span><br>    <span class="hljs-comment"># 通过正则提取对应的字符串</span><br>    module_path_find_list = re.findall(match_str, line)<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(module_path_find_list) != <span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&quot;module path not found&quot;</span>)<br>    module_path: <span class="hljs-built_in">str</span> = module_path_find_list[<span class="hljs-number">0</span>]<br>    module_path_list: List[<span class="hljs-built_in">str</span>] = module_path.split(<span class="hljs-string">&quot;.&quot;</span>)<br>    <span class="hljs-comment"># 通过UserStub模块获取到消息体对应的模块</span><br>    message_module: ModuleType = <span class="hljs-built_in">getattr</span>(class_module, module_path_list[<span class="hljs-number">0</span>])<br>    <span class="hljs-comment"># 从模块提取到对应的对象</span><br>    message_model: Type[Message] = <span class="hljs-built_in">getattr</span>(message_module, module_path_list[<span class="hljs-number">1</span>])<br><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">issubclass</span>(message_model, Message):<br>        <span class="hljs-keyword">raise</span> RuntimeError(<span class="hljs-string">&quot;Can not found message&quot;</span>)<br>    <span class="hljs-keyword">return</span> message_model<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">parse</span>(<span class="hljs-params">stub: Any</span>) -&gt; Generator[tuple, <span class="hljs-keyword">None</span>, <span class="hljs-keyword">None</span>]:</span><br>    <span class="hljs-comment"># 提取对应对象的源码，以`\n`切分成每一行</span><br>    line_list: List[<span class="hljs-built_in">str</span>] = inspect.getsource(stub).split(<span class="hljs-string">&quot;\n&quot;</span>)<br><br>    <span class="hljs-comment"># 获取对象的模块，这样就能知道这个模块引用了什么包，方便后面提取请求和响应对象</span><br>    class_module: Optional[ModuleType] = inspect.getmodule(stub)<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> class_module:<br>        <span class="hljs-keyword">raise</span> RuntimeError(<span class="hljs-string">f&quot;Can not found <span class="hljs-subst">&#123;stub&#125;</span> module&quot;</span>)<br>    <span class="hljs-comment"># 通过enumerate，可以获取到行数对应的索引</span><br>    <span class="hljs-keyword">for</span> index, line <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(line_list):<br>        <span class="hljs-comment"># 不是self.所在的行，就跳过</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;self.&quot;</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> line:<br>            <span class="hljs-keyword">continue</span><br>        <span class="hljs-comment"># 只映射一对一的gRPC请求，其它gRPC请求则忽略</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;channel.unary_unary&quot;</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> line:<br>            <span class="hljs-keyword">continue</span><br><br>        <span class="hljs-comment"># 通过这一行提取gRPC调用端方法名</span><br>        invoke_name: <span class="hljs-built_in">str</span> = line.split(<span class="hljs-string">&quot;=&quot;</span>)[<span class="hljs-number">0</span>].replace(<span class="hljs-string">&quot;self.&quot;</span>, <span class="hljs-string">&quot;&quot;</span>).strip()<br>        <span class="hljs-comment"># 从下一行提取url</span><br>        method: <span class="hljs-built_in">str</span> = line_list[index + <span class="hljs-number">1</span>].strip()[<span class="hljs-number">1</span>:-<span class="hljs-number">2</span>]<br>        <span class="hljs-comment"># 从下两行提取请求对象</span><br>        request: Type[Message] = _gen_message(<br>            class_module, line_list[index + <span class="hljs-number">2</span>], <span class="hljs-string">r&quot;request_serializer=(.+).SerializeToString&quot;</span><br>        )<br>        <span class="hljs-comment"># 从下三行提取响应对象</span><br>        response: Type[Message] = _gen_message(<br>            class_module, line_list[index + <span class="hljs-number">3</span>], <span class="hljs-string">r&quot;response_deserializer=(.+).FromString&quot;</span><br>        )<br>        <span class="hljs-comment"># 返回提取的数据</span><br>        <span class="hljs-keyword">yield</span> invoke_name, method, request, response<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> parse(user_pb2_grpc.UserStub):<br>        print(i)<br><br><br></code></pre></td></tr></table></figure>
<p>这段代码执行后就会输出以下结果，可以发现，这段代码正常的从<code>UserStub</code>中提取到了我们想要的数据。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">(<span class="hljs-string">&#x27;get_uid_by_token&#x27;</span>, <span class="hljs-string">&#x27;/user.User/get_uid_by_token&#x27;</span>, &lt;class <span class="hljs-string">&#x27;example_proto.user.user_pb2.GetUidByTokenRequest&#x27;</span>&gt;, &lt;class <span class="hljs-string">&#x27;example_proto.user.user_pb2.GetUidByTokenResult&#x27;</span>&gt;)<br>(<span class="hljs-string">&#x27;logout_user&#x27;</span>, <span class="hljs-string">&#x27;/user.User/logout_user&#x27;</span>, &lt;class <span class="hljs-string">&#x27;example_proto.user.user_pb2.LogoutUserRequest&#x27;</span>&gt;, &lt;class <span class="hljs-string">&#x27;google.protobuf.empty_pb2.Empty&#x27;</span>&gt;)<br>(<span class="hljs-string">&#x27;login_user&#x27;</span>, <span class="hljs-string">&#x27;/user.User/login_user&#x27;</span>, &lt;class <span class="hljs-string">&#x27;example_proto.user.user_pb2.LoginUserRequest&#x27;</span>&gt;, &lt;class <span class="hljs-string">&#x27;example_proto.user.user_pb2.LoginUserResult&#x27;</span>&gt;)<br>(<span class="hljs-string">&#x27;create_user&#x27;</span>, <span class="hljs-string">&#x27;/user.User/create_user&#x27;</span>, &lt;class <span class="hljs-string">&#x27;example_proto.user.user_pb2.CreateUserRequest&#x27;</span>&gt;, &lt;class <span class="hljs-string">&#x27;google.protobuf.empty_pb2.Empty&#x27;</span>&gt;)<br>(<span class="hljs-string">&#x27;delete_user&#x27;</span>, <span class="hljs-string">&#x27;/user.User/delete_user&#x27;</span>, &lt;class <span class="hljs-string">&#x27;example_proto.user.user_pb2.DeleteUserRequest&#x27;</span>&gt;, &lt;class <span class="hljs-string">&#x27;google.protobuf.empty_pb2.Empty&#x27;</span>&gt;)<br></code></pre></td></tr></table></figure>

<p>不过这还不够，比如使用者可能想自定义这个请求映射的URL，或者是控制这个gRPC请求方法是否要映射等等，这些功能是无法通过Proto文件来控制的，如果写在另一个文件配置又非常麻烦，最后决定通过Proto文件的注释来实现这些功能，比如下面的Proto代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs proto">service User &#123;<br>  &#x2F;&#x2F; The interface should not be exposed for external use<br>  &#x2F;&#x2F; pait: &#123;&quot;enable&quot;: false&#125;<br>  rpc get_uid_by_token (GetUidByTokenRequest) returns (GetUidByTokenResult);<br>  &#x2F;&#x2F; pait: &#123;&quot;tag&quot;: [[&quot;grpc-user&quot;, &quot;grpc_user_service&quot;], [&quot;grpc-user-system&quot;, &quot;grpc_user_service&quot;]]&#125;<br>  &#x2F;&#x2F; pait: &#123;&quot;summary&quot;: &quot;Create users through the system&quot;, &quot;url&quot;: &quot;&#x2F;user&#x2F;create&quot;&#125;<br>  rpc create_user(CreateUserRequest) returns (google.protobuf.Empty);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这段代码有一个标准的<code>pait:</code>开头，这样在解析时，就可以知道这一行是需要解析的文本，然后就会去解析后面跟着的一串Json字符串，就可以知道<code>get_uid_by_token</code>设置了<code>enable</code>为<code>false</code>，而<code>create_user</code>设置了url为<code>/user/create</code>。不过，默认生成的代码中，客户端对象是没有携带Proto文件的注释信息的，只有他们对应的服务端对象才有携带，比如<code>UserStub</code>没有携带注释信息，而<code>UserStub</code>对应的<code>User</code>对象则携带，所以需要从<code>User</code>中提取数据。</p>
<p>此外，对于请求对象和响应对象也可以采用这样的思路，但是<code>Python</code>的gRPC库通过Proto文件生成<code>Python</code>代码时，Proto文件中为Message编写的注释是不会一起跟过来的，需要自己编写一个插件，或者通过<code>mypy-proto</code>插件生成的文件来获取。由于这部分的代码比较长且繁杂，这里只做简单说明，具体源码见<a href="https://github.com/so1n/pait/blob/master/pait/util/grpc_inspect/stub.py">pait.util.groc_inspect.stub.py</a></p>
<h2 id="4-自动映射路由"><a href="#4-自动映射路由" class="headerlink" title="4.自动映射路由"></a>4.自动映射路由</h2><p>至此，url，请求方法，请求体和响应体都获取到了，现在可以自动映射路由了，还是以<code>starlette</code>框架为例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> grpc<br><span class="hljs-keyword">from</span> starlette.applications <span class="hljs-keyword">import</span> Starlette<br><span class="hljs-keyword">from</span> starlette.requests <span class="hljs-keyword">import</span> Request<br><span class="hljs-keyword">from</span> starlette.responses <span class="hljs-keyword">import</span> JSONResponse<br><span class="hljs-keyword">from</span> google.protobuf.message <span class="hljs-keyword">import</span> Message<br><span class="hljs-keyword">from</span> google.protobuf.json_format <span class="hljs-keyword">import</span> MessageToDict<br><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> Any, Callable<br><br><span class="hljs-comment"># pait项目的演示代码，由Proto文件生产的</span><br><span class="hljs-keyword">from</span> example.example_grpc.python_example_proto_code.example_proto.user <span class="hljs-keyword">import</span> user_pb2<br><span class="hljs-keyword">from</span> example.example_grpc.python_example_proto_code.example_proto.user <span class="hljs-keyword">import</span> user_pb2_grpc<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">gen_route</span>(<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">    app: Starlette,</span></span><br><span class="hljs-function"><span class="hljs-params">    stub: Any,</span></span><br><span class="hljs-function"><span class="hljs-params">    url: <span class="hljs-built_in">str</span>,</span></span><br><span class="hljs-function"><span class="hljs-params">    invoke_name: <span class="hljs-built_in">str</span>,</span></span><br><span class="hljs-function"><span class="hljs-params">    grpc_request: Message,</span></span><br><span class="hljs-function"><span class="hljs-params">    grpc_response: Message,</span></span><br><span class="hljs-function"><span class="hljs-params"></span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    :param app: Starlette实例</span><br><span class="hljs-string">    :param stub: gRPC客户端对应的类</span><br><span class="hljs-string">    :param url: url</span><br><span class="hljs-string">    :param invoke_name: gRPC调用的方法名</span><br><span class="hljs-string">    :param grpc_request: gRPC请求体</span><br><span class="hljs-string">    :param grpc_response: gRPC响应体，可以发现它没有被使用</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_route</span>(<span class="hljs-params">request: Request</span>) -&gt; JSONResponse:</span><br>        resp_dict: <span class="hljs-built_in">dict</span> = <span class="hljs-keyword">await</span> request.json()<br>        <span class="hljs-comment"># 通过app实例携带的channel来调用gRPC服务</span><br>        func: Callable = <span class="hljs-built_in">getattr</span>(stub(app.state.channel), invoke_name)<br>        <span class="hljs-comment"># 把gRPC响应数据专为json响应</span><br>        <span class="hljs-keyword">return</span> JSONResponse(MessageToDict(<span class="hljs-keyword">await</span> func(grpc_request(**resp_dict))))<br><br>    <span class="hljs-comment"># 注册路由</span><br>    app.add_route(url, _route, methods=[<span class="hljs-string">&quot;POST&quot;</span>])<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">create_app</span>() -&gt; Starlette:</span><br>    <span class="hljs-comment"># 绑定路由</span><br>    app: Starlette = Starlette()<br><br>    <span class="hljs-comment"># 通过调用上面段parse函数得到了gRPC对应的数据再通过gen_route来自动注册路由</span><br>    <span class="hljs-keyword">for</span> parse_result_list <span class="hljs-keyword">in</span> parse(user_pb2_grpc.UserStub):<br>        gen_route(<br>            app,<br>            user_pb2_grpc.UserStub,<br>            *parse_result_list,<br>        )<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_before_server_start</span>() -&gt; <span class="hljs-keyword">None</span>:</span><br>        <span class="hljs-comment"># 启动时绑定gRPC客户端对应的channel</span><br>        app.state.channel = grpc.aio.insecure_channel(<span class="hljs-string">&quot;0.0.0.0:9000&quot;</span>)<br><br>    app.add_event_handler(<span class="hljs-string">&quot;startup&quot;</span>, _before_server_start)<br>    <span class="hljs-keyword">return</span> app<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    <span class="hljs-keyword">import</span> uvicorn  <span class="hljs-comment"># type: ignore</span><br><br>    uvicorn.run(create_app(), log_level=<span class="hljs-string">&quot;debug&quot;</span>)<br></code></pre></td></tr></table></figure>
<h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5.总结"></a>5.总结</h2><p>至此，gRPC网关的最核心的实现已经编写完成了，不过可以发现gRPC的响应体并没有被使用，同时这个实现非常简单，不容易拓展，可以通过<a href="https://so1n.me/pait-zh-doc/7_gRPC_gateway/#6gateway-route">自定义Gateway Route路由函数</a>了解更多的拓展。</p>
]]></content>
      <categories>
        <category>Python-gRPC实践</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>gRPC</tag>
      </tags>
  </entry>
  <entry>
    <title>Python-gRPC实践(5)--简述gRPC的高级用法</title>
    <url>/2022/04/16/Python-gRPC%E5%AE%9E%E8%B7%B5(5)--%E7%AE%80%E8%BF%B0gRPC%E7%9A%84%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><a href="https://so1n.me/2022/04/07/Python-gRPC%E5%AE%9E%E8%B7%B5(3)--%E4%BD%BF%E7%94%A8Python%E5%AE%9E%E7%8E%B0gRPC%E6%9C%8D%E5%8A%A1/">Python-gRPC实践(3)–使用Python实现gRPC服务</a><br>讲述了如何编写和使用gRPC服务，而本文主要讲述一些业务之外的gRPC用法。</p>
<h2 id="1-优雅的重启服务"><a href="#1-优雅的重启服务" class="headerlink" title="1.优雅的重启服务"></a>1.优雅的重启服务</h2><p>线上运行的服务永远都不会一尘不变的，特别是对于微服务，服务的更新频率越来越快，需要重启的次数也就变多了，而每次重启都会导致服务正在处理的请求被强行关闭，所以我们需要优雅的重启服务，确保在滚动更新服务的时候不会影响到客户端，好在gRPC自带了一个类似的功能，代码例子如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">from</span> signal <span class="hljs-keyword">import</span> signal, SIGTERM<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">serve</span>():</span><br>    <span class="hljs-comment"># 启动端口配置，默认为启用</span><br>    options = [(<span class="hljs-string">&quot;grpc.so_reuseport&quot;</span>, <span class="hljs-number">1</span>)]<br>    <span class="hljs-comment"># 正常的运行服务</span><br>    server = grpc.server(futures.ThreadPoolExecutor(max_workers=<span class="hljs-number">10</span>), options=options)<br>    ...<br>    server.add_insecure_port(<span class="hljs-string">&quot;0.0.0.0:9000&quot;</span>)<br>    server.start()<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sig_handle</span>(<span class="hljs-params">*args</span>):</span><br>        <span class="hljs-comment"># 调用server.stop函数，调用stop(30)后，该服务会拒绝客户端新的请求，并返回一个threading.Event</span><br>        event = server.stop(<span class="hljs-number">30</span>)<br>        <span class="hljs-comment"># 调用event.wait()后，服务会一直等着，直到30秒后服务才会关闭，关闭之前服务还是能正常处理请求</span><br>        event.wait()<br>    <br>    <span class="hljs-comment"># 接收一个SIGTERM信号的注册</span><br>    signal(SIGTERM, sig_handle)<br>    <span class="hljs-comment"># 等待服务停止</span><br>    server.wait_for_termination()<br></code></pre></td></tr></table></figure>
<p>这个代码假设gRPC服务以端口复用模式运行(默认启用), 代码通过加上<code>SIGTERM</code>信号的对应回调后，我们的更新服务的逻辑就可以进行一些调整。首先是运行一个全新的gRPC服务在9000端口，这时候请求会分流到新和旧的gRPC服务，然后我们主动向旧的服务进程发送<code>SIGTERM</code>信号，这时旧服务就能开始拒绝新的请求，请求只会流向新的gRPC服务，之后我们只需要等服务自动关闭即可。</p>
<p>不过光这种方法还是不够，还需要注册中心等，具体实现逻辑可以通过<a href="https://so1n.me/2021/08/28/RPC%E6%A1%86%E6%9E%B6%E7%BC%96%E5%86%99%E5%AE%9E%E8%B7%B5--%E4%BC%98%E9%9B%85%E7%9A%84%E9%87%8D%E5%90%AF/">RPC框架编写实践–服务的优雅的重启</a>了解。</p>
<blockquote>
<p>代码中的options是用于配置gRPC服务的一些功能，可以从gRPC c源码中获悉<a href="https://github.com/grpc/grpc/blob/v1.38.x/include/grpc/impl/codegen/grpc_types.h">grpc_types.h</a>,也可以通过代码生成的页面获取比较容易看到的<a href="https://grpc.github.io/grpc/core/group__grpc__arg__keys.html#gaa3f69f6e1e789e36d2d9c6083fec0257">说明文档</a>。此外还有一些配置是需要传入一个Dict对象，可以参考<a href="https://github.com/grpc/grpc-proto/blob/master/grpc/service_config/service_config.proto">service_config.proto</a></p>
</blockquote>
<blockquote>
<p>更多优雅的重启说明见<a href="https://github.com/grpc/proposal/blob/master/L54-python-server-wait.md">gRPC Python Server Wait API</a></p>
</blockquote>
<h2 id="2-重试机制"><a href="#2-重试机制" class="headerlink" title="2.重试机制"></a>2.重试机制</h2><p>gRPC服务是通过网络来传输请求的，所以可能会因为网络波动等原因造成请求失败，这时候就需要重试机制来使请求能成功通信了，但是引入重试机制后可能会带来一些负面的问题：</p>
<ul>
<li>比如服务端已经扛不住了，而客户端还一直重试，造成持续的增加服务端压力</li>
<li>接口不是幂等，某个请求实际上已经处理完了，但是由于网络问题导致客户端认为服务端返回了错误，从而客户端进行了重试，最后导致服务端又再次处理请求，导致对应的数据发生了改变。</li>
</ul>
<p>于是，gRPC抽象出一套重试机制，使用户可以灵活为自己想要的方法应用对应的重试机制，这个重试机制包括的最大重试次数，指数退避，可重试状态码等等，比如下面的代码:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BookGrpcService</span>(<span class="hljs-params">BookSocialGrpcServiceMixin, BookManagerGrpcServiceMixin</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, host: <span class="hljs-built_in">str</span>, port: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        service_config_json = json.dumps(&#123;<br>            <span class="hljs-string">&quot;methodConfig&quot;</span>: [&#123;<br>                <span class="hljs-string">&quot;name&quot;</span>: [<br>                    &#123;<br>                        <span class="hljs-string">&quot;service&quot;</span>: <span class="hljs-string">&quot;book_manager.BookManager&quot;</span>,<br>                        <span class="hljs-string">&quot;method&quot;</span>: <span class="hljs-string">&quot;create_book&quot;</span><br>                    &#125;,<br>                    &#123;<br>                        <span class="hljs-string">&quot;service&quot;</span>: <span class="hljs-string">&quot;book_manager.BookManager&quot;</span>,<br>                        <span class="hljs-string">&quot;method&quot;</span>: <span class="hljs-string">&quot;delete_book&quot;</span><br>                    &#125;,<br>                ],<br>                <span class="hljs-string">&quot;retryPolicy&quot;</span>: &#123;<br>                    <span class="hljs-string">&quot;maxAttempts&quot;</span>: <span class="hljs-number">5</span>,<br>                    <span class="hljs-string">&quot;initialBackoff&quot;</span>: <span class="hljs-string">&quot;0.1s&quot;</span>,<br>                    <span class="hljs-string">&quot;maxBackoff&quot;</span>: <span class="hljs-string">&quot;1s&quot;</span>,<br>                    <span class="hljs-string">&quot;backoffMultiplier&quot;</span>: <span class="hljs-number">2</span>,<br>                    <span class="hljs-string">&quot;retryableStatusCodes&quot;</span>: [<span class="hljs-string">&quot;UNAVAILABLE&quot;</span>],<br>                &#125;,<br>            &#125;]<br>        &#125;)<br>        options = []<br>        <span class="hljs-comment"># <span class="hljs-doctag">NOTE:</span> 启动重试模式， 默认在v1.40.0后自动启用</span><br>        options.append((<span class="hljs-string">&quot;grpc.enable_retries&quot;</span>, <span class="hljs-number">1</span>))<br>        <span class="hljs-comment"># 重试的一些参数配置</span><br>        options.append((<span class="hljs-string">&quot;grpc.service_config&quot;</span>, service_config_json))<br><br><br>        self.channel: grpc.Channel = grpc.intercept_channel(<br>            grpc.insecure_channel(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;host&#125;</span>:<span class="hljs-subst">&#123;port&#125;</span>&quot;</span>), CustomerTopInterceptor(), options=options<br>        )<br>        BookSocialGrpcServiceMixin.__init__(self, self.channel)<br>        BookManagerGrpcServiceMixin.__init__(self, self.channel)<br></code></pre></td></tr></table></figure>
<p>该代码复制于<a href="https://github.com/so1n/grpc-example-api-backend-service/blob/part-1/grpc_service/book_service.py#L68">grpc-example-api-backend-service</a>，并进行一点拓展，可以看到在调用<code>grpc.intercept_channel</code>进行初始化时，传入了一个options参数，这样在创建channel时会自动应用到对应的配置。</p>
<p>这个配置中，<code>grpc.enable_retries</code>为1代表启用了重试，而<code>grpc.service_config</code>接收到的是一个服务配置方法，具体可以访问<a href="https://github.com/grpc/grpc-proto/blob/ec886024c2f7b7f597ba89d5b7d60c3f94627b17/grpc/service_config/service_config.proto#L38">service_config.proto</a>了解，不过需要注意的是，在传入<code>grpc.service_config</code>时，传的是一个Dict的对应json序列化字符串。</p>
<p>接下来就在<code>grpc.service_config</code>的<code>methodConfig</code>中，我们传入了一个数组，这个数组里面只有一个Dict，这个Dict通过<code>name</code>指定了只有<code>book_manager.BookManager</code>的<code>create_book</code>方法和<code>delete_book</code>方法会应用到重试的规则，如果这个配置为:</p>
<figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json">&#123;<br>    <span class="hljs-attr">&quot;methodConfig&quot;</span>: [&#123;<br>        <span class="hljs-attr">&quot;name&quot;</span>: [&#123;&#125;],<br>        <span class="hljs-attr">&quot;retryPolicy&quot;</span>: &#123;<br>            <span class="hljs-attr">&quot;maxAttempts&quot;</span>: <span class="hljs-number">5</span>,<br>            <span class="hljs-attr">&quot;initialBackoff&quot;</span>: <span class="hljs-string">&quot;0.1s&quot;</span>,<br>            <span class="hljs-attr">&quot;maxBackoff&quot;</span>: <span class="hljs-string">&quot;1s&quot;</span>,<br>            <span class="hljs-attr">&quot;backoffMultiplier&quot;</span>: <span class="hljs-number">2</span>,<br>            <span class="hljs-attr">&quot;retryableStatusCodes&quot;</span>: [<span class="hljs-string">&quot;UNAVAILABLE&quot;</span>],<br>        &#125;,<br>    &#125;]<br>&#125;<br></code></pre></td></tr></table></figure>
<p>则会应用到所有的方法中。<br>在这个配置中，<code>name</code>负责指定应用范围，而<code>retryPolicy</code>负责指定应用规则，方便用户调整重试逻辑，他们的含义如下:</p>
<ul>
<li>maxAttempts: 最大的重试次数，必须大于，如果大于5则他的值为5</li>
<li>Backoff系列: 指数退避参数，第一次重试是在random(0, initalBackoff)秒后进行的，而后续的重试间隔计算为min(initial_backoff*backoff_multiplier**(n-1), max_backoff)).</li>
<li>retryableStatusCodes: 指定什么样的响应状态码才需要重试，具体参照gRPC状态码文档。</li>
</ul>
<p>开发者只要合理的进行配置，那么就能简单的应用重试机制，但是光看这点配置还是没办法解决重试导致机器过载的问题，所以gRPC还包含另外一组参数重试限流策略–<a href="https://github.com/grpc/grpc-proto/blob/ec886024c2f7b7f597ba89d5b7d60c3f94627b17/grpc/service_config/service_config.proto#L436">retryThrottling</a>来解决这个问题，这个配置的含义是当客户端的失败和成功超过某个阈值时，gRPC会通过金庸重试策略来防止由于重试导致服务器过载，使用方法如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BookGrpcService</span>(<span class="hljs-params">BookSocialGrpcServiceMixin, BookManagerGrpcServiceMixin</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, host: <span class="hljs-built_in">str</span>, port: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        service_config_json = json.dumps(&#123;<br>            <span class="hljs-string">&quot;methodConfig&quot;</span>: [&#123;<br>                <span class="hljs-string">&quot;name&quot;</span>: [<br>                    &#123;<br>                        <span class="hljs-string">&quot;service&quot;</span>: <span class="hljs-string">&quot;book_manager.BookManager&quot;</span>,<br>                        <span class="hljs-string">&quot;method&quot;</span>: <span class="hljs-string">&quot;create_book&quot;</span><br>                    &#125;,<br>                    &#123;<br>                        <span class="hljs-string">&quot;service&quot;</span>: <span class="hljs-string">&quot;book_manager.BookManager&quot;</span>,<br>                        <span class="hljs-string">&quot;method&quot;</span>: <span class="hljs-string">&quot;delete_book&quot;</span><br>                    &#125;,<br>                ],<br>                <span class="hljs-string">&quot;retryPolicy&quot;</span>: &#123;<br>                    <span class="hljs-string">&quot;maxAttempts&quot;</span>: <span class="hljs-number">5</span>,<br>                    <span class="hljs-string">&quot;initialBackoff&quot;</span>: <span class="hljs-string">&quot;0.1s&quot;</span>,<br>                    <span class="hljs-string">&quot;maxBackoff&quot;</span>: <span class="hljs-string">&quot;1s&quot;</span>,<br>                    <span class="hljs-string">&quot;backoffMultiplier&quot;</span>: <span class="hljs-number">2</span>,<br>                    <span class="hljs-string">&quot;retryableStatusCodes&quot;</span>: [<span class="hljs-string">&quot;UNAVAILABLE&quot;</span>],<br>                &#125;,<br>            &#125;],<br>            <span class="hljs-string">&quot;retryThrottling&quot;</span>: &#123;<br>                <span class="hljs-string">&quot;maxTokens&quot;</span>: <span class="hljs-number">10</span>,<br>                <span class="hljs-string">&quot;tokenRatio&quot;</span>: <span class="hljs-number">0.1</span><br>            &#125;<br>        &#125;)<br>        options = []<br>        <span class="hljs-comment"># <span class="hljs-doctag">NOTE:</span> 启动重试模式， 默认在v1.40.0后自动启用</span><br>        options.append((<span class="hljs-string">&quot;grpc.enable_retries&quot;</span>, <span class="hljs-number">1</span>))<br>        <span class="hljs-comment"># 重试的一些参数配置</span><br>        options.append((<span class="hljs-string">&quot;grpc.service_config&quot;</span>, service_config_json))<br><br><br>        self.channel: grpc.Channel = grpc.intercept_channel(<br>            grpc.insecure_channel(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;host&#125;</span>:<span class="hljs-subst">&#123;port&#125;</span>&quot;</span>), CustomerTopInterceptor(), options=options<br>        )<br>        BookSocialGrpcServiceMixin.__init__(self, self.channel)<br>        BookManagerGrpcServiceMixin.__init__(self, self.channel)<br></code></pre></td></tr></table></figure>
<p>在这段代码中，通过引入与<code>methodConfig</code>同级的<code>retryThrottling</code>配置，之后gRPC客户端会维护一个tokenCount的变量，它的初始值为maxToken,值得范围在0-maxToken波动，之后每一次请求成功时，tokenCount都会递增<code>tokenRatio</code>的值，每次请求失败时，tokenCount都会递减1，之后在重试之前如果发现tokaneCount小于或等于maxToken/2时，gRPC客户端不会进行重试且不会进行对冲。需要注意的是<code>tokenRatio</code>的设定范围只能在0-1之间，且只支持小数点后3位，如0.5466将为视为0.546，而MmaxTOkens的取值范围为0-1000的整数值。</p>
<blockquote>
<p>目前Python gRPC不支持对冲，更多gRPC重试内容和设计见<a href="https://github.com/grpc/proposal/blob/master/A6-client-retries.md">A6-client-retries</a></p>
</blockquote>
<h2 id="3-调用时参数"><a href="#3-调用时参数" class="headerlink" title="3.调用时参数"></a>3.调用时参数</h2><h2 id="3-1-超时"><a href="#3-1-超时" class="headerlink" title="3.1.超时"></a>3.1.超时</h2><p>超时机制， 是一个简单又方便的控制网络请求异常的一种方法， 它可以保证服务稳定(本质是快速失败)， 良好的超时控制策略可以尽快的释放高延迟的请求，避免请求堆积。对于一般的HTTP请求，只需要在客户端添加一个超时参数，然后客户端检查在超时时间范围内还没收到对应的网络请求时，就会单方面关闭请求，这种处理方法在大多数情况下是没问题的，但在遇到阻塞性调用等情况时，客户端单方面关闭了请求，但服务端还在继续处理请求，并做出响应，不过客户端已经关闭了连接了，它无法收到该响应，这样就造成了服务端都性能浪费了。要解决这个问题，就需要引入一个超时传递的机制，使服务端能获取到本次请求的指定超时时间，并做出响应的操作。</p>
<p>好在gRPC已经自带了超时和超时传递的功能了，只需要在调用时添加timeout参数即可，如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserGrpcServiceMixin</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, channel: grpc.Channel</span>):</span><br>        self.user_stub: user_service.UserStub = user_service.UserStub(channel)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">create_user</span>(<span class="hljs-params">self, *, uid: <span class="hljs-built_in">str</span>, user_name: <span class="hljs-built_in">str</span>, password: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        self.user_stub.create_user(user_message.CreateUserRequest(uid=uid, user_name=user_name, password=password), timeout=<span class="hljs-number">10</span>)<br></code></pre></td></tr></table></figure>
<p>这样一来，客户端在调用的时候，就会进行倒计时，如果10秒内任然没有收到响应，那么它就会抛出超时异常，而服务端可以通过<code>context.time_remaining()</code>获取到还有多少剩余时间，并在主要逻辑代码使用，如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserService</span>(<span class="hljs-params">user_service.UserServicer</span>):</span><br><span class="hljs-meta">    @conn_proxy()</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">create_user</span>(<span class="hljs-params">self, request: user_message.CreateUserRequest, context: grpc.ServicerContext</span>) -&gt; Empty:</span><br>        <span class="hljs-keyword">with</span> TimeoutContext(context.time_remaining()):<br>            user_dal.create_user(uid=request.uid, user_name=request.user_name, password=request.password)<br>        <span class="hljs-keyword">return</span> Empty()<br></code></pre></td></tr></table></figure>
<p>该代码引入一个TimeoutContext对象，这个对象会托管该作用域，如果该作用域的运行时长超多指定的时间，则会直接抛出错误，具体见<a href="https://so1n.me/2021/10/22/RPC%E6%A1%86%E6%9E%B6%E7%BC%96%E5%86%99%E5%AE%9E%E8%B7%B5--%E8%B6%85%E6%97%B6%E4%B8%8E%E8%B6%85%E6%97%B6%E4%BC%A0%E9%80%92">RPC框架编写实践–超时与超时传递</a></p>
<h2 id="3-2-等待服务就绪"><a href="#3-2-等待服务就绪" class="headerlink" title="3.2.等待服务就绪"></a>3.2.等待服务就绪</h2><p>一般的gRPC客户端在请求服务端都时候，如果发现服务端无法及时传输数据，比如channel处于<code>TRANSIENT_FAILURE</code>或<code>SHUTDOWN</code>状态时，客户端应该马上响应失败，这种方法被称为快速失败，但是服务端还有其它的状态如<code>CONNECTING</code>、<code>READY</code>或<code>IDLE</code>，这时候channel处于准备状态，还无法提供服务，但是在稍后将可以提供服务，比如客户端服务端同时启动，但因为短暂的网络故障导致服务端不可用等场景。这时候就可以使用<code>wait-for-ready</code>功能，使用<code>wait-for-ready</code>的调用将自动等待，直到服务器准备好接受请求时再发送，如下例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserGrpcServiceMixin</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, channel: grpc.Channel</span>):</span><br>        self.user_stub: user_service.UserStub = user_service.UserStub(channel)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">create_user</span>(<span class="hljs-params">self, *, uid: <span class="hljs-built_in">str</span>, user_name: <span class="hljs-built_in">str</span>, password: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        self.user_stub.create_user(user_message.CreateUserRequest(uid=uid, user_name=user_name, password=password), wait_for_ready=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure>
<p>这样一来在调用<code>create_user</code>时，如果服务端还处于准备阶段，那么他会一直等待，直到服务端处于运行状态，需要注意的是，等待时间不会超过timeout指定的时间。</p>
<h2 id="4-数据类型的转换"><a href="#4-数据类型的转换" class="headerlink" title="4.数据类型的转换"></a>4.数据类型的转换</h2><p>在演示的代码<a href="https://github.com/so1n/grpc-example-common/blob/part-1/grpc_example_common/helper/field.py">grpc_example_common.helper.field</a>中，我编写了几个参数，用于做Protobuf文件的数据类型转换，这些实现是非常简陋的，有些类型并没有考虑到，不过官方提供好了数据类型的转换，这些功能都位于<a href="https://googleapis.dev/python/protobuf/latest/google/protobuf/json_format.html">google.protobuf.json_format</a>之中，大多数我们只要用<code>json_format.ParseDict</code>或者是<code>json_format.MessageToDict</code>即可，不过有些时候我们需要进行一些定制化，但是json_format并没有开放出对应的接口，我们只能使用一些奇怪的方法来定制化，比如<code>json_format.ParseDict</code>，我们只要重置<code>json_format._ConvertScalarFieldValue</code>方法即可，用法如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">from</span> decimal <span class="hljs-keyword">import</span> Decimal<br><span class="hljs-keyword">from</span> google.protobuf <span class="hljs-keyword">import</span> json_format<br><span class="hljs-keyword">from</span> grpc_example_common.protos.book.social_pb2 <span class="hljs-keyword">import</span> GetBookLikesResult<br><br><br><span class="hljs-comment"># 获取到原来的用法</span><br>_ConvertScalarFieldValue = json_format._ConvertScalarFieldValue<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">ConvertScalarFieldValue</span>(<span class="hljs-params">value, field, path, require_str=<span class="hljs-literal">False</span></span>):</span><br>    <span class="hljs-comment"># 制定我们的规则</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(value, <span class="hljs-built_in">str</span>):<br>        <span class="hljs-comment"># 字符串添加一个faker</span><br>        value = <span class="hljs-string">&quot;faker&quot;</span> + value<br>    <span class="hljs-keyword">elif</span> <span class="hljs-built_in">isinstance</span>(value, Decimal):<br>        <span class="hljs-comment"># Decimal就+10</span><br>        value = <span class="hljs-built_in">int</span>(value) + <span class="hljs-number">10</span><br>    <span class="hljs-comment"># 最后再交给原来的方法处理</span><br>    <span class="hljs-keyword">return</span> _ConvertScalarFieldValue(value, field, path, require_str)<br><br><span class="hljs-built_in">setattr</span>(json_format, <span class="hljs-string">&#x27;_ConvertScalarFieldValue&#x27;</span>, ConvertScalarFieldValue)<br><br><br>parse_message = json_format.ParseDict(&#123;<span class="hljs-string">&quot;isbn&quot;</span>: <span class="hljs-string">&quot;xxx&quot;</span>, <span class="hljs-string">&quot;book_like&quot;</span>: Decimal(<span class="hljs-string">&quot;2.0&quot;</span>)&#125;, GetBookLikesResult)<br><span class="hljs-comment"># 输出符合我们的预期</span><br>print(parse_message.book_like)<br><span class="hljs-comment"># --&gt; 12</span><br>print(parse_message.isbn)<br><span class="hljs-comment"># --&gt; fakerxxx</span><br></code></pre></td></tr></table></figure>
<p>可以看到输出与符合我们定义的规则，而对于<code>json_format.MessageToDict</code>，可以直接修改它使用的<code>_Printer</code>中的<code>_FieldToJsonObject</code>方法，并创建一个全新的<code>MessageToDict</code>来调用到我们编写的<code>Printer</code>的类，代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">from</span> google.protobuf <span class="hljs-keyword">import</span> json_format<br><span class="hljs-keyword">from</span> grpc_example_common.protos.book.social_pb2 <span class="hljs-keyword">import</span> GetBookLikesResult<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Printer</span>(<span class="hljs-params">json_format._Printer</span>):</span>  <span class="hljs-comment"># noqa</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_FieldToJsonObject</span>(<span class="hljs-params">self, field, value</span>):</span><br>        <span class="hljs-comment"># 如果是int类型，就加10</span><br>        <span class="hljs-keyword">if</span> field.cpp_type <span class="hljs-keyword">in</span> json_format._INT_TYPES:<br>            <span class="hljs-keyword">return</span> value+<span class="hljs-number">10</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>()._FieldToJsonObject(field, value)<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">MessageToDict</span>(<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">    message,</span></span><br><span class="hljs-function"><span class="hljs-params">    including_default_value_fields=<span class="hljs-literal">False</span>,</span></span><br><span class="hljs-function"><span class="hljs-params">    preserving_proto_field_name=<span class="hljs-literal">False</span>,</span></span><br><span class="hljs-function"><span class="hljs-params">    use_integers_for_enums=<span class="hljs-literal">False</span>,</span></span><br><span class="hljs-function"><span class="hljs-params">    descriptor_pool=<span class="hljs-literal">None</span>,</span></span><br><span class="hljs-function"><span class="hljs-params">    float_precision=<span class="hljs-literal">None</span></span>):</span><br>    printer = Printer(<br>        including_default_value_fields,<br>        preserving_proto_field_name,<br>        use_integers_for_enums,<br>        descriptor_pool,<br>        float_precision=float_precision)<br>    <span class="hljs-comment"># pylint: disable=protected-access</span><br>    <span class="hljs-keyword">return</span> printer._MessageToJsonObject(message)<br><br><br>print(MessageToDict(GetBookLikesResult(book_like=<span class="hljs-number">10</span>)))<br><span class="hljs-comment"># --&gt; 20</span><br></code></pre></td></tr></table></figure>
<p>通过输出后可以发现，输出的结果是20，符合我们的定义的规则。</p>
]]></content>
      <categories>
        <category>Python-gRPC实践</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>gRPC</tag>
      </tags>
  </entry>
  <entry>
    <title>Python-gRPC实践(4)--简述gRPC拦截器</title>
    <url>/2022/04/13/Python-gRPC%E5%AE%9E%E8%B7%B5(4)--gRPC%E6%8B%A6%E6%88%AA%E5%99%A8/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>世界上没有百分之百不会挂的服务，只能人为的去增加服务的可用性，为了能让服务的可用性增加，需要为服务添加服务治理的功能，而在gRPC中，可以通过拦截器实现一些服务治理的功能。</p>
<span id="more"></span>

<h2 id="1-什么是拦截器"><a href="#1-什么是拦截器" class="headerlink" title="1.什么是拦截器"></a>1.什么是拦截器</h2><p>在<code>Python</code>中，很少有框架把自己的功能称为拦截器，反而都称为中间件或者是钩子，gRPC的拦截器功能与<code>Python</code>Web框架常用的中间件基本一样，它主要的功能是可以在调用函数之前，之后已经发生异常时能够捕获到对应的数据，比如如下代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">demo_rpc_method</span>():</span><br>    <span class="hljs-comment"># run before code</span><br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-keyword">pass</span>  <span class="hljs-comment"># rpc logic</span><br>    <span class="hljs-keyword">except</span> Exception:<br>        <span class="hljs-keyword">pass</span>  <span class="hljs-comment"># exc code</span><br>    <span class="hljs-keyword">finally</span>:<br>        <span class="hljs-comment"># run after code</span><br></code></pre></td></tr></table></figure>
<p>这段代码提现了拦截器的主要特点：</p>
<ul>
<li>1.裹住了一个RPC调用逻辑</li>
<li>2.能够在裹住的逻辑调用之前，之后以及调用异常的时候自定义数据</li>
</ul>
<p>对于<code>Python</code>开发人员来说，看到这思路后脑子里的第一个想法就是可以通过<code>Python</code>的装饰器轻松的实现<code>gRPC</code>拦截器的逻辑。</p>
<p>所以在官方尚未敲定拦截器实现的时候，大家也都是使用装饰器来实现拦截器的，比如下面这段代码（源码见<a href="https://github.com/so1n/grpc-example-common/blob/part-1/grpc_example_common/helper/grpc_wrapper.py#L25">grpc_example_common/helper/grpc_wrapper.py</a>）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">grpc_client_func_wrapper</span>(<span class="hljs-params">*args: Any, **kwargs: Any</span>) -&gt; Callable:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">wrapper</span>(<span class="hljs-params">func: Callable</span>) -&gt; Callable:</span><br>        <span class="hljs-comment"># func是装饰器装饰的一个方法</span><br><span class="hljs-meta">        @wraps(<span class="hljs-params">func</span>)</span><br>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_wrapper</span>(<span class="hljs-params">*_args: Any, **_kwargs: Any</span>) -&gt; Any:</span><br>            <span class="hljs-comment"># 查看调用段方法是否有指定metadata参数，如果没有就定义一个</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;metadata&quot;</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> _kwargs:<br>                _kwargs[<span class="hljs-string">&quot;metadata&quot;</span>] = []<br>            <span class="hljs-keyword">return</span> func(*_args, **_kwargs)<br><br>        <span class="hljs-keyword">return</span> _wrapper<br><br>    <span class="hljs-keyword">return</span> wrapper<br></code></pre></td></tr></table></figure>
<p>这是我目前还在用的一个通过装饰器实现的拦截器，因为目前gRPC的客户端在调用方法没定义<code>metadata</code>参数时，<code>gRPC</code>客户端拦截器是没办法去更改<code>metadata</code>参数的，强行修改还会报错，而<code>meatdata</code>参数类似于HTTP的Header参数，很多通过拦截器实现的功能如链路追踪，身份校验等功能的实现都需要通过拦截器更改或写入<code>metadata</code>参数来实现，所以这个装饰器一直保留着。</p>
<p>既然有了装饰器，那为什么gRPC最终还是选择拦截器这个方案呢，原因是装饰器虽然很灵活，但是本身有很多缺点：</p>
<ul>
<li>0.装饰器只能用于方法上，如果遇到一个无法调用到指定的方法的请求，那么这个请求就无法没监控到。</li>
<li>1.需要显式的为每个方法添加装饰器。</li>
<li>2.过多的装饰器会变得非常混乱。</li>
<li>3.上篇文章提到的由于装饰器导致需要延后声明才能使方法mock生效。</li>
</ul>
<blockquote>
<p>Note： 可以通过<a href="https://github.com/so1n/grpc-example-common/blob/part-1/grpc_example_common/helper/grpc_wrapper.py#L38">grpc_example_common/helper/grpc_wrapper.py</a>函数自动应用装饰器，使用方法见<a href="https://github.com/so1n/grpc-example-api-backend-service/blob/master/grpc_service/book_service.py#L19">grpc_service/book_service.py</a></p>
</blockquote>
<h2 id="2-如何使用拦截器"><a href="#2-如何使用拦截器" class="headerlink" title="2.如何使用拦截器"></a>2.如何使用拦截器</h2><p>由于装饰器自己带有一些缺点，所以<code>gRPC</code>最后自己定义了一个拦截器方案，不过<code>Python</code>实现gRPC拦截器API非常复杂，按照官方文档的指引，我们需要为每种请求类型定义一个拦截器，但是他们的代码却是相同的，这对开发人员来说非常的不友好，不过好在有一个<a href="https://github.com/d5h-foss/grpc-interceptor">grpc-interceptor</a>包进行了统一，使用起来非常方便，只用继承他提供的类，再覆盖intercept方法就可以同时为一对一，多对一，一对多的请求套上拦截器，比如我定义了一个可以把错误类型在不同基于<code>Python</code>实现的gRPC服务传播的拦截器：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-comment">##############</span><br><span class="hljs-comment"># 服务端拦截器 #</span><br><span class="hljs-comment">##############</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ServerCustomerTopInterceptor</span>(<span class="hljs-params">BaseInterceptor</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">intercept</span>(<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">        self,</span></span><br><span class="hljs-function"><span class="hljs-params">        next_handler_method: Callable,</span></span><br><span class="hljs-function"><span class="hljs-params">        request_proto_message: Any,</span></span><br><span class="hljs-function"><span class="hljs-params">        context: grpc.ServicerContext,</span></span><br><span class="hljs-function"><span class="hljs-params">    </span>) -&gt; Any:</span><br>        <span class="hljs-comment"># 在这个区域实现未调用方法的代码</span><br>        start_time: <span class="hljs-built_in">float</span> = time.time()<br>        return_initial_metadata: List[Tuple] = [(<span class="hljs-string">&quot;customer-user-agent&quot;</span>, <span class="hljs-string">&quot;Python3&quot;</span>)]<br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-comment"># 调用下一个拦截器或者是方法 </span><br>            <span class="hljs-keyword">return</span> next_handler_method(request_proto_message, context)<br>        <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>            <span class="hljs-comment"># 发生错误的处理，解析错误 </span><br>            <span class="hljs-keyword">if</span> self.metadata_dict.get(<span class="hljs-string">&quot;customer-user-agent&quot;</span>, <span class="hljs-string">&quot;&quot;</span>) == <span class="hljs-string">&quot;Python3&quot;</span>:<br>                return_initial_metadata.append((<span class="hljs-string">&quot;exc_name&quot;</span>, e.__class__.__name__))<br>                return_initial_metadata.append((<span class="hljs-string">&quot;exc_info&quot;</span>, <span class="hljs-built_in">str</span>(e)))<br>            logging.exception(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;context_proxy.method&#125;</span> request exc:<span class="hljs-subst">&#123;e.__class__.__name__&#125;</span> error:<span class="hljs-subst">&#123;e&#125;</span>&quot;</span>)<br>            <span class="hljs-comment"># 记住一定要把异常抛出来，这样才能走grpc的异常逻辑，否则客户端那边会解析到错误的body</span><br>            <span class="hljs-keyword">raise</span> e<br>        <span class="hljs-keyword">finally</span>:<br>            <span class="hljs-comment"># 调用方法后的逻辑，这里把metadata插入到context中</span><br>            context.send_initial_metadata(return_initial_metadata)<br>            <span class="hljs-comment"># 打印access log</span><br>            logging.info(<br>                <span class="hljs-string">f&quot;Got Request. method:<span class="hljs-subst">&#123;self.method&#125;</span>, code:<span class="hljs-subst">&#123;context.code()&#125;</span>, detail:<span class="hljs-subst">&#123;context.details()&#125;</span>, duration:<span class="hljs-subst">&#123;time.time() - start_time&#125;</span>&quot;</span><br>            )<br><span class="hljs-comment">##############</span><br><span class="hljs-comment"># 客户端拦截器 #</span><br><span class="hljs-comment">##############</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClientCustomerTopInterceptor</span>(<span class="hljs-params">BaseInterceptor</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, exc_list: Optional[List[Type[Exception]]] = <span class="hljs-literal">None</span></span>):</span><br>        <span class="hljs-comment"># 注入可用的异常</span><br>        self.exc_dict: Dict[<span class="hljs-built_in">str</span>, Type[Exception]] = &#123;&#125;<br>        <span class="hljs-keyword">for</span> key, exc <span class="hljs-keyword">in</span> <span class="hljs-built_in">globals</span>()[<span class="hljs-string">&quot;__builtins__&quot;</span>].items():<br>            <span class="hljs-keyword">if</span> inspect.isclass(exc) <span class="hljs-keyword">and</span> <span class="hljs-built_in">issubclass</span>(exc, Exception):<br>                self.exc_dict[key] = exc<br><br>        <span class="hljs-keyword">if</span> exc_list:<br>            <span class="hljs-keyword">for</span> exc <span class="hljs-keyword">in</span> exc_list:<br>                <span class="hljs-keyword">if</span> <span class="hljs-built_in">issubclass</span>(exc, Exception):<br>                    self.exc_dict[exc.__name__] = exc<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">intercept</span>(<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">        self,</span></span><br><span class="hljs-function"><span class="hljs-params">        method: Callable,</span></span><br><span class="hljs-function"><span class="hljs-params">        request_or_iterator: Any,</span></span><br><span class="hljs-function"><span class="hljs-params">        call_details: ClientCallDetailsType,</span></span><br><span class="hljs-function"><span class="hljs-params">    </span>) -&gt; GRPC_RESPONSE:</span><br>        <span class="hljs-comment"># 调用方法之前的操作，注意一定要判断metadata是否为空，如果是的话，metadata是不可写的，强行写入会报错</span><br>        <span class="hljs-keyword">if</span> call_details.metadata <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            call_details.metadata.append((<span class="hljs-string">&quot;customer-user-agent&quot;</span>, <span class="hljs-string">&quot;Python3&quot;</span>))  <span class="hljs-comment"># type: ignore</span><br>            call_details.metadata.append((<span class="hljs-string">&quot;request_id&quot;</span>, context_proxy.request_id))<br>        <span class="hljs-comment"># 调用方法</span><br>        response: GRPC_RESPONSE = method(call_details, request_or_iterator)<br>        <span class="hljs-comment"># 调用完方法的对应操作</span><br>        metadata_dict: <span class="hljs-built_in">dict</span> = &#123;item.key: item.value <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> response.initial_metadata()&#125;<br>        <span class="hljs-keyword">if</span> metadata_dict.get(<span class="hljs-string">&quot;customer-user-agent&quot;</span>) == <span class="hljs-string">&quot;Python3&quot;</span>:<br>            exc_name: <span class="hljs-built_in">str</span> = metadata_dict.get(<span class="hljs-string">&quot;exc_name&quot;</span>, <span class="hljs-string">&quot;&quot;</span>)<br>            exc_info: <span class="hljs-built_in">str</span> = metadata_dict.get(<span class="hljs-string">&quot;exc_info&quot;</span>, <span class="hljs-string">&quot;&quot;</span>)<br>            exc: Optional[Type[Exception]] = self.exc_dict.get(exc_name)<br>            <span class="hljs-keyword">if</span> exc:<br>                <span class="hljs-keyword">raise</span> exc(exc_info)<br>        <span class="hljs-keyword">return</span> response<br></code></pre></td></tr></table></figure>

<p>可以看到源码中的拦截器都有调用之前，调用中，调用后三大逻辑，与我们前面说的一样，给予开发者极强的自定义能力，这样一来就可以通过拦截器来实现一些服务治理的功能，对于如何实现可见<a href="https://so1n.me/categories/RPC%E6%A1%86%E6%9E%B6%E7%BC%96%E5%86%99%E5%AE%9E%E8%B7%B5/">RPC框架编写实践系列</a></p>
<p>实现完拦截器后就需要应用到gRPC服务中，由于<a href="https://github.com/d5h-foss/grpc-interceptor">grpc-interceptor</a>是对官方拦截器的简单安装，所以可以像官方拦截器一样应用到服务中，服务端应用拦截器可参考<a href="https://github.com/so1n/grpc-example-book-grpc-service/blob/part-1/app.py#L21">grpc-example-book-grpc-service项目</a>在<code>grpc.Server</code>初始化时通过<code>interceptors</code>参数把拦截器列表传进去，简要代码如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>(<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">    host: <span class="hljs-built_in">str</span> = <span class="hljs-string">&quot;0.0.0.0&quot;</span>, port: <span class="hljs-built_in">str</span> = <span class="hljs-string">&quot;9000&quot;</span>, ssl_port: Optional[<span class="hljs-built_in">str</span>] = <span class="hljs-literal">None</span></span></span><br><span class="hljs-function"><span class="hljs-params"></span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>    interceptor_list: List[BaseInterceptor] = [CustomerTopInterceptor()]<br>    server: grpc.server = grpc.server(<br>        futures.ThreadPoolExecutor(max_workers=<span class="hljs-number">10</span>),<br>        interceptors=interceptor_list,<br>    )<br>    manager_service.add_BookManagerServicer_to_server(ManagerService(), server)<br>    social_service.add_BookSocialServicer_to_server(SocialService(), server)<br></code></pre></td></tr></table></figure>
<p>而对于客户端可以参考<a href="https://github.com/so1n/grpc-example-api-backend-service/blob/master/grpc_service/book_service.py#L68">grpc-example-api-backend-service项目</a>在通过生成<code>channel</code>时，把拦截器通过参数传进去</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BookGrpcService</span>(<span class="hljs-params">BookSocialGrpcServiceMixin, BookManagerGrpcServiceMixin</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, host: <span class="hljs-built_in">str</span>, port: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        self.channel: grpc.Channel = grpc.intercept_channel(<br>            grpc.insecure_channel(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;host&#125;</span>:<span class="hljs-subst">&#123;port&#125;</span>&quot;</span>), CustomerTopInterceptor()<br>        )<br>        BookSocialGrpcServiceMixin.__init__(self, self.channel)<br>        BookManagerGrpcServiceMixin.__init__(self, self.channel)<br></code></pre></td></tr></table></figure>
<p>拦截器编写完成后应该去测试它，但是大多数都拦截器都依赖于一些特定的服务，如Prometheus监控依赖Prometheus，链路追踪可能依赖到的jaeger等，所以很多时候都会在测试环境或者预发布环境进行测试，但是对于其它无服务依赖的拦截器则可以使用<code>grpc_interceptor</code>包实现的测试模块来进行测试，如官方的例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">from</span> grpc_interceptor <span class="hljs-keyword">import</span> ExceptionToStatusInterceptor<br><span class="hljs-keyword">from</span> grpc_interceptor.exceptions <span class="hljs-keyword">import</span> NotFound<br><span class="hljs-keyword">from</span> grpc_interceptor.testing <span class="hljs-keyword">import</span> dummy_client, DummyRequest, raises<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_exception</span>():</span><br>    special_cases = &#123;<span class="hljs-string">&quot;error&quot;</span>: raises(NotFound())&#125;<br>    <span class="hljs-comment"># 指定的拦截器</span><br>    interceptors = [ExceptionToStatusInterceptor()]<br>    <span class="hljs-comment"># 模拟一个客户端发起请求，该客户端响应的数据等于input时指定的数据</span><br>    <span class="hljs-comment"># 不过也可以通过special_cases来指定input数据对应的异常响应</span><br>    <span class="hljs-keyword">with</span> dummy_client(special_cases=special_cases, interceptors=interceptors) <span class="hljs-keyword">as</span> client:<br>        <span class="hljs-comment"># 输入input时必定会响应一个output</span><br>        <span class="hljs-keyword">assert</span> client.Execute(DummyRequest(<span class="hljs-built_in">input</span>=<span class="hljs-string">&quot;foo&quot;</span>)).output == <span class="hljs-string">&quot;foo&quot;</span><br>        <span class="hljs-comment"># 输入error时，会抛出一个对应的响应</span><br>        <span class="hljs-keyword">with</span> pytest.raises(grpc.RpcError) <span class="hljs-keyword">as</span> e:<br>            client.Execute(DummyRequest(<span class="hljs-built_in">input</span>=<span class="hljs-string">&quot;error&quot;</span>))<br>        <span class="hljs-keyword">assert</span> e.value.code() == grpc.StatusCode.NOT_FOUND<br></code></pre></td></tr></table></figure>
<p>通过该例子可以方便的实现一个正常请求和错误请求来测试拦截器的返回，但是对于一些内在逻辑最好通过pytest-mock或者是官方的unitest-mock来判断是否有调用到，调用几次，调用时的内容是否符合标准等等。</p>
]]></content>
      <categories>
        <category>Python-gRPC实践</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>gRPC</tag>
      </tags>
  </entry>
  <entry>
    <title>Python的可等待对象在Asyncio的作用</title>
    <url>/2022/04/11/python&#39;s_waitable_objects_in_asyncio/</url>
    <content><![CDATA[<h2 id="前记"><a href="#前记" class="headerlink" title="前记"></a>前记</h2><p>上一遍文章<a href="https://so1n.me/2021/11/08/%E5%88%9D%E8%AF%86Python%20Async%E7%9A%84%E5%AE%9E%E7%8E%B0/#3-%E5%9F%BA%E4%BA%8E%E7%94%9F%E6%88%90%E5%99%A8%E7%9A%84%E5%8D%8F%E7%A8%8B">《初识Python协程的实现》</a><br>介绍了Python是如何以生成器来实现协程的以及Python Asyncio通过Future和Task的封装来实现协程的调度，而在Python Asyncio之中Coroutines, Tasks和Future都属于可等待对象，在使用的Asyncio的过程中，经常涉及到三者的转换和调度，开发者容易在概念和作用上犯迷糊，本文主要阐述的是三者之间的关系以及他们的作用。</p>
<span id="more"></span>

<h2 id="1-Asyncio的入口"><a href="#1-Asyncio的入口" class="headerlink" title="1.Asyncio的入口"></a>1.Asyncio的入口</h2><p>协程是线程中的一种特例，协程的入口和切换都是靠事件循环来调度的，在新版的<code>Python</code>中协程的入口是<code>Asyncio.run</code>，当程序运行到<code>Asyncio.run</code>后，可以简单的理解为程序由线程模式切换为协程模式(只是方便理解，对于计算机而言，并没有这样区分)，以下是一个最小的协程例子代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> asyncio<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">0</span>)<br><br>asyncio.run(main())<br></code></pre></td></tr></table></figure>
<p>在这段代码中，<code>main</code>函数和<code>asyncio.sleep</code>都属于Coroutine，<code>main</code>是通过<code>asyncio.run</code>进行调用的，接下来程序也进入一个协程模式，<code>asyncio.run</code>的核心调用是<code>Runner.run</code>，它的代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Runner</span>:</span><br>    ...<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span>(<span class="hljs-params">self, coro, *, context=<span class="hljs-literal">None</span></span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;Run a coroutine inside the embedded event loop.&quot;&quot;&quot;</span><br>        <span class="hljs-comment"># 省略代码</span><br>        ...<br><br>        <span class="hljs-comment"># 把coroutine转为task</span><br>        task = self._loop.create_task(coro, context=context)<br><br>        <span class="hljs-comment"># 省略代码</span><br>        ...<br><br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-comment"># 如果传入的是Future或者coroutine，也会专为task</span><br>            <span class="hljs-keyword">return</span> self._loop.run_until_complete(task)<br>        <span class="hljs-keyword">except</span> exceptions.CancelledError:<br>        <br>        <span class="hljs-comment"># 省略代码</span><br>        ...<br></code></pre></td></tr></table></figure>
<p>这段代码中删去了部分其它功能和初始化的代码，可以看到这段函数的主要功能是通过<code>loop.create_task</code>方法把一个Coroutine对象转为一个Task对象，然后通过<code>loop.run_until_complete</code>等待这个Task运行结束。</p>
<blockquote>
<p>在<code>Python3.5</code>之后，<code>asycnio</code>改为C语言实现，所以本文的<code>asyncio</code>源码都来源于最后一个以<code>Python</code>实现的asycnio版本<a href="https://github.com/python/cpython/tree/v3.4.10/Lib/asyncio">Python3.4.10/Lib/asyncio</a></p>
</blockquote>
<p>可以看到，<code>Asycnio</code>并不会直接去调度Coroutine，而是把它转为Task再进行调度，这是因为在<code>Asyncio</code>中事件循环的最小调度对象就是Task。不过在<code>Asyncio</code>中并不是所有的Coroutine的调用都会先被转为Task对象再等待，比如示例代码中的<code>asyncio.sleep</code>，由于它是在<code>main</code>函数中直接await的，所以它不会被进行转换，而是直接等待，通过调用工具分析展示的图如下：<br><img   class="lazyload" data-original="https://cdn.jsdelivr.net/gh/so1n/so1n_blog_photo@master/blog_photo/16495805125721649580511667.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" ><br>在这个图示中，从<code>main</code>函数到<code>asyncio.sleep</code>函数中没有明显的<code>loop.create_task</code>等把Coroutine转为Task调用，这里之所以不用进行转换的原因不是做了一些特殊优化，而是本因如此， 这个<code>await asyncio.sleep</code>函数实际上还是会被<code>main</code>这个Coroutine转换成的<code>Task</code>继续调度到。</p>
<h2 id="2-两种Coroutine调用方法的区别"><a href="#2-两种Coroutine调用方法的区别" class="headerlink" title="2.两种Coroutine调用方法的区别"></a>2.两种Coroutine调用方法的区别</h2><p>在了解<code>Task</code>的调度原理之前，还是先回到最初的调用示例，看看直接用Task调用和直接用Coroutine调用的区别是什么。如下代码，我们显示的执行一个Coroutine转为Task的操作再等待，那么代码会变成下面这样:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> asyncio<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    <span class="hljs-keyword">await</span> asyncio.create_task(asyncio.sleep(<span class="hljs-number">0</span>))<br><br>asyncio.run(main())<br></code></pre></td></tr></table></figure>
<p>这样的代码看起来跟最初的调用示例很像，没啥区别，但是如果进行一些改变，比如增加一些休眠时间和Coroutine的调用，就能看出Task对象的作用了，现在编写两份文件，他们的代码如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-comment"># demo_coro.py</span><br><span class="hljs-keyword">import</span> asyncio<br><span class="hljs-keyword">import</span> time<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">2</span>)<br><br>s_t = time.time()<br>asyncio.run(main())<br>print(time.time() - s_t)<br><span class="hljs-comment"># // Output: 3.0028765201568604</span><br><br><span class="hljs-comment"># demo_task.py</span><br><span class="hljs-keyword">import</span> asyncio<br><span class="hljs-keyword">import</span> time<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    task_1 = asyncio.create_task(asyncio.sleep(<span class="hljs-number">1</span>))<br>    task_2 = asyncio.create_task(asyncio.sleep(<span class="hljs-number">2</span>))<br>    <span class="hljs-keyword">await</span> task_1<br>    <span class="hljs-keyword">await</span> task_2<br><br>s_t = time.time()<br>asyncio.run(main())<br>print(time.time() - s_t)<br><span class="hljs-comment"># // Output: 2.0027475357055664</span><br></code></pre></td></tr></table></figure>
<p>其中<code>demo_coro.py</code>进行了两次<code>await</code>调用，程序的运行总时长为3秒，而<code>demo_task.py</code>则是先把两个Coroutine对象转为Task对象，然后再进行两次<code>await</code>调用，程序的运行总时长为2秒。可以发现，<code>demo_task.py</code>的运行时长近似于其中运行最久的Task对象时长，而<code>demo_coro.py</code>的运行时长则是近似于两个Coroutine对象的总运行时长。</p>
<p>之所以会是这样的结果，是因为直接<code>await</code>Coroutine对象时，这段程序会一直等待，直到Coroutine对象执行完毕再继续往下走，而Task对象的不同之处就是在创建的那一刻，就已经把自己注册到事件循环之中等待被安排运行了，然后返回一个task对象供开发者等待，由于<code>asyncio.sleep</code>是一个纯IO类型的调用，所以在这个程序中，两个<code>asyncio.sleep</code>Coroutine被转为Task从而实现了并发调用。</p>
<h2 id="3-Task与Future"><a href="#3-Task与Future" class="headerlink" title="3.Task与Future"></a>3.Task与Future</h2><p>上述的代码之所以通过Task能实现并发调用，是因为Task中出现了一些与事件循环交互的函数，正是这些函数架起了Coroutine并发调用的可能， 不过Task是Future的一个子对象，所以在了解Task之前，需要先了解Future。</p>
<h2 id="3-1-Future"><a href="#3-1-Future" class="headerlink" title="3.1.Future"></a>3.1.Future</h2><p>与Coroutine只有让步和接收结果不同的是Future除了让步和接收结果功能外，它还是一个只会被动进行事件调用且带有状态的容器，它在初始化时就是<code>Pending</code>状态，这时可以被取消，被设置结果和设置异常。而在被设定对应的操作后，Future会被转化到一个不可逆的对应状态，并通过<code>loop.call_sonn</code>来调用所有注册到本身上的回调函数，同时它带有<code>__iter__</code>和<code>__await__</code>方法使其可以被<code>await</code>和<code>yield from</code>调用，它的主要代码如下： </p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Future</span>:</span><br>    ...<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">set_result</span>(<span class="hljs-params">self, result</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;设置结果，并安排下一个调用&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> self._state != _PENDING:<br>            <span class="hljs-keyword">raise</span> exceptions.InvalidStateError(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;self._state&#125;</span>: <span class="hljs-subst">&#123;self!r&#125;</span>&#x27;</span>)<br>        self._result = result<br>        self._state = _FINISHED<br>        self.__schedule_callbacks()<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">set_exception</span>(<span class="hljs-params">self, exception</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;设置异常，并安排下一个调用&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> self._state != _PENDING:<br>            <span class="hljs-keyword">raise</span> exceptions.InvalidStateError(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;self._state&#125;</span>: <span class="hljs-subst">&#123;self!r&#125;</span>&#x27;</span>)<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(exception, <span class="hljs-built_in">type</span>):<br>            exception = exception()<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">type</span>(exception) <span class="hljs-keyword">is</span> StopIteration:<br>            <span class="hljs-keyword">raise</span> TypeError(<span class="hljs-string">&quot;StopIteration interacts badly with generators &quot;</span><br>                            <span class="hljs-string">&quot;and cannot be raised into a Future&quot;</span>)<br>        self._exception = exception<br>        self._state = _FINISHED<br>        self.__schedule_callbacks()<br>        self.__log_traceback = <span class="hljs-literal">True</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__await__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;设置为blocking，并接受await或者yield from调用&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self.done():<br>            self._asyncio_future_blocking = <span class="hljs-literal">True</span><br>            <span class="hljs-keyword">yield</span> self  <span class="hljs-comment"># This tells Task to wait for completion.</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self.done():<br>            <span class="hljs-keyword">raise</span> RuntimeError(<span class="hljs-string">&quot;await wasn&#x27;t used with future&quot;</span>)<br>        <span class="hljs-keyword">return</span> self.result()  <span class="hljs-comment"># May raise too.</span><br><br>    __iter__ = __await__  <span class="hljs-comment"># make compatible with &#x27;yield from&#x27;.</span><br></code></pre></td></tr></table></figure>
<p>单看这段代码是很难理解为什么下面这个future被调用<code>set_result</code>后就能继续往下走:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">demo</span>(<span class="hljs-params">future: asyncio.Future</span>):</span><br>    <span class="hljs-keyword">await</span> future<br>    print(<span class="hljs-string">&quot;aha&quot;</span>)<br></code></pre></td></tr></table></figure>
<p>这是因为Future跟Coroutine一样，没有主动调度的能力，只能通过Task和事件循环联手被调度。</p>
<h2 id="3-2-Task"><a href="#3-2-Task" class="headerlink" title="3.2.Task"></a>3.2.Task</h2><p>Task是Future的子类，除了继承了Future的所有方法，它还多了两个重要的方法<code>__step</code>和<code>__wakeup</code>，通过这两个方法赋予了Task调度能力，这是Coroutine和Future没有的，Task的涉及到调度的主要代码如下(说明见注释):</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Task</span>(<span class="hljs-params">futures._PyFuture</span>):</span>  <span class="hljs-comment"># Inherit Python Task implementation</span><br>                                <span class="hljs-comment"># from a Python Future implementation.</span><br><br>    _log_destroy_pending = <span class="hljs-literal">True</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, coro, *, loop=<span class="hljs-literal">None</span>, name=<span class="hljs-literal">None</span>, context=<span class="hljs-literal">None</span></span>):</span><br>        <span class="hljs-built_in">super</span>().__init__(loop=loop)<br>        <span class="hljs-comment"># 省略部分初始化代码</span><br>        ...<br><br>        <span class="hljs-comment"># 托管的coroutine</span><br>        self._coro = coro<br>        <span class="hljs-keyword">if</span> context <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            self._context = contextvars.copy_context()<br>        <span class="hljs-keyword">else</span>:<br>            self._context = context<br><br>        <span class="hljs-comment"># 通过loop.call_sonn，在Task初始化后马上就通知事件循环在下次有空的时候执行自己的__step函数</span><br>        self._loop.call_soon(self.__step, context=self._context)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__step</span>(<span class="hljs-params">self, exc=<span class="hljs-literal">None</span></span>):</span><br>        coro = self._coro<br>        <span class="hljs-comment"># 方便asyncio自省</span><br>        _enter_task(self._loop, self)<br>        <span class="hljs-comment"># Call either coro.throw(exc) or coro.send(None).</span><br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-keyword">if</span> exc <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>                <span class="hljs-comment"># 通过send预激托管的coroutine</span><br>                <span class="hljs-comment"># 这时候只会得到coroutine yield回来的数据或者收到一个StopIteration的异常</span><br>                <span class="hljs-comment"># 对于Future或者Task返回的是Self</span><br>                result = coro.send(<span class="hljs-literal">None</span>)<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-comment"># 发送异常给coroutine </span><br>                result = coro.throw(exc)<br>        <span class="hljs-keyword">except</span> StopIteration <span class="hljs-keyword">as</span> exc:<br>            <span class="hljs-comment"># StopIteration代表Coroutine运行完毕</span><br>            <span class="hljs-keyword">if</span> self._must_cancel:<br>                <span class="hljs-comment"># coroutine在停止之前被执行了取消操作，则需要显示的执行取消操作</span><br>                self._must_cancel = <span class="hljs-literal">False</span><br>                <span class="hljs-built_in">super</span>().cancel(msg=self._cancel_message)<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-comment"># 把运行完毕的值发送到结果值中</span><br>                <span class="hljs-built_in">super</span>().set_result(exc.value)<br>        <span class="hljs-comment"># 省略其它异常封装</span><br>        ...<br><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-comment"># 如果没有异常抛出</span><br>            blocking = <span class="hljs-built_in">getattr</span>(result, <span class="hljs-string">&#x27;_asyncio_future_blocking&#x27;</span>, <span class="hljs-literal">None</span>)<br>            <span class="hljs-keyword">if</span> blocking <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>                <span class="hljs-comment"># 通过Future代码可以判断，如果带有_asyncio_future_blocking属性，则代表当前result是Future或者是Task</span><br>                <span class="hljs-comment"># 意味着这个Task里面裹着另外一个的Future或者Task</span><br>                <span class="hljs-comment"># 省略Future判断</span><br>                ...<br><br>                <span class="hljs-keyword">if</span> blocking:<br>                    <span class="hljs-comment"># 代表这这个Future或者Task处于卡住的状态，</span><br>                    <span class="hljs-comment"># 此时的Task放弃了自己对事件循环的控制权，等待这个卡住的Future或者Task执行完成时唤醒一下自己</span><br>                    result._asyncio_future_blocking = <span class="hljs-literal">False</span><br>                    result.add_done_callback(self.__wakeup, context=self._context)<br>                    self._fut_waiter = result<br>                    <span class="hljs-keyword">if</span> self._must_cancel:<br>                        <span class="hljs-keyword">if</span> self._fut_waiter.cancel(msg=self._cancel_message):<br>                            self._must_cancel = <span class="hljs-literal">False</span><br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-comment"># 不能被await两次</span><br>                    new_exc = RuntimeError(<br>                        <span class="hljs-string">f&#x27;yield was used instead of yield from &#x27;</span><br>                        <span class="hljs-string">f&#x27;in task <span class="hljs-subst">&#123;self!r&#125;</span> with <span class="hljs-subst">&#123;result!r&#125;</span>&#x27;</span>)<br>                    self._loop.call_soon(<br>                        self.__step, new_exc, context=self._context)<br><br>            <span class="hljs-keyword">elif</span> result <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>                <span class="hljs-comment"># 放弃了对事件循环的控制权，代表自己托管的coroutine可能有个coroutine在运行，接下来会把控制权交给他和事件循环 </span><br>                <span class="hljs-comment"># 当前的coroutine里面即使没有Future或者Task,但是子Future可能有</span><br>                self._loop.call_soon(self.__step, context=self._context)<br>        <span class="hljs-keyword">finally</span>:<br>            _leave_task(self._loop, self)<br>            self = <span class="hljs-literal">None</span>  <span class="hljs-comment"># Needed to break cycles when an exception occurs.</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__wakeup</span>(<span class="hljs-params">self, future</span>):</span><br>        <span class="hljs-comment"># 其它Task和Future完成后会调用到该函数，接下来进行一些处理</span><br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-comment"># 回收Future的状态，如果Future发生了异常，则把异常传回给自己</span><br>            future.result()<br>        <span class="hljs-keyword">except</span> BaseException <span class="hljs-keyword">as</span> exc:<br>            <span class="hljs-comment"># This may also be a cancellation.</span><br>            self.__step(exc)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-comment"># Task并不需要自己托管的Future的结果值，而且如下注释，这样能使调度变得更快</span><br><br>            <span class="hljs-comment"># Don&#x27;t pass the value of `future.result()` explicitly,</span><br>            <span class="hljs-comment"># as `Future.__iter__` and `Future.__await__` don&#x27;t need it.</span><br>            <span class="hljs-comment"># If we call `_step(value, None)` instead of `_step()`,</span><br>            <span class="hljs-comment"># Python eval loop would use `.send(value)` method call,</span><br>            <span class="hljs-comment"># instead of `__next__()`, which is slower for futures</span><br>            <span class="hljs-comment"># that return non-generator iterators from their `__iter__`.</span><br>            self.__step()<br>        self = <span class="hljs-literal">None</span>  <span class="hljs-comment"># Needed to break cycles when an exception occurs.</span><br></code></pre></td></tr></table></figure>
<p>这份源码的Task对象中的<code>__setp</code>方法比较长，经过精简后可以发现他主要做的工作有三个：</p>
<ul>
<li>1.通过<code>send</code>或者<code>throw</code>来驱动Coroutine进行下一步</li>
<li>2.通过给被自己托管的Future或者Task添加回调来获得完成的通知并重新获取控制权</li>
<li>3.通过<code>loop.call_soon</code>来让步，把控制权交给事件循环</li>
</ul>
<p>单通过源码分析可能很难明白， 以下是以<code>两种Coroutine</code>的代码为例子，简单的阐述Task与事件循环调度的过程，首先是<code>demo_coro</code>，这个例子中只有一个Task：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-comment"># demo_coro.py</span><br><span class="hljs-keyword">import</span> asyncio<br><span class="hljs-keyword">import</span> time<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">2</span>)<br><br>s_t = time.time()<br>asyncio.run(main())<br>print(time.time() - s_t)<br><span class="hljs-comment"># // Output: 3.0028765201568604</span><br></code></pre></td></tr></table></figure>
<p>这个例子中第一步是把<code>main</code>转为一个Task，然后调用到了对应的<code>__step</code>方法，这时候<code>__step</code>方法会会调用<code>main()</code>这个Coroutine的<code>send(None)</code>方法。<br>之后整个程序的逻辑会直接转到<code>main</code>函数中的<code>await asyncio.sleep(1)</code>这个Coroutine中，<code>await asyncio.sleep(1)</code>会先生成一个Future对象，并通过<code>loop.call_at</code>告诉事件循环在1秒后激活这个Future对象，然后把对象返回。这时候逻辑会重新回到Task的<code>__step</code>方法中，<code>__step</code>发现<code>send</code>调用得到的是一个Future对象，所以就在这个Future添加一个回调，让Future完成的时候来激活自己，然后放弃了对事件循环的控制权。接着就是事件循环在一秒后激活了这个Future对象，这时程序逻辑就会执行到Future的回调，也就是Task的<code>__wakeup</code>方法，于是Task的<code>__step</code>又被调用到了，而这次遇到的是后面的<code>await asyncio.sleep(2)</code>，于是又走了一遍上面的流程。当两个<code>asyncio.sleep</code>都执行完成后，Task的<code>__step</code>方法里在对Coroutine发送一个<code>send(None)</code>后就捕获到了<code>StopIteration</code>异常，这时候Task就会通过<code>set_result</code>设置结果，并结束自己的调度流程。</p>
<p>可以看到<code>demo_core.py</code>中只有一个Task在负责和事件循环一起调度，事件循环的开始一定是一个Task，并通过Task来调起一个Coroutine，通过<code>__step</code>方法把后续的Future，Task,Coroutine都当成一条链来运行，而<code>demo_task.py</code>则不一样了，它有两个Task，代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><br><span class="hljs-comment"># demo_task.py</span><br><span class="hljs-keyword">import</span> asyncio<br><span class="hljs-keyword">import</span> time<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    task_1 = asyncio.create_task(asyncio.sleep(<span class="hljs-number">1</span>))<br>    task_2 = asyncio.create_task(asyncio.sleep(<span class="hljs-number">2</span>))<br>    <span class="hljs-keyword">await</span> task_1<br>    <span class="hljs-keyword">await</span> task_2<br><br>s_t = time.time()<br>asyncio.run(main())<br>print(time.time() - s_t)<br><span class="hljs-comment"># // Output: 2.0027475357055664</span><br></code></pre></td></tr></table></figure>
<p>这个例子中第一步还是跟<code>demo_coro</code>一样，但跳转到<code>main</code>函数后就开始有区别了，首先在这函数中创建了task1和task2两个Task，他们分别都会通过<code>__step</code>方法中的<code>send</code>激活对应的<code>asyncio.sleep</code>Coroutine，然后等待对应的Future来通知自己已经完成了。而对于创建了这两个Task的main Task来说，通过<code>main</code>函数的<code>awati task_1</code>和<code>await task_2</code>来获取到他们的“控制权“。首先是通过<code>await task_1</code>语句，main Task中的<code>__step</code>方法里在调用<code>send</code>后得到的是task_1对应的Future，这时候就可以为这个Future添加一个回调，让他完成时通知自己，自己再走下一步，对于task_2也是如此。 直到最后两个task都执行完成，main Task也捕获到了<code>StopIteration</code>异常，通过<code>set_result</code>设置结果，并结束自己的调度流程。</p>
<p>可以看到<code>demo_task.py</code>与<code>demo_coro.py</code>有个明显的区别在于main Task在运行的生命周期中创建了两个Task，并通过<code>await</code>托管了两个Task，同时两个Task又能实现两个协程的并发，所以可以发现事件循环运行期间，当前协程的并发数永远小于事件循环中注册的Task数量。此外，如果在main Task中如果没有显式的进行<code>await</code>，那么子Task就会逃逸，不受main Task管理，如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><br><span class="hljs-comment"># demo_task.py</span><br><span class="hljs-keyword">import</span> asyncio<br><span class="hljs-keyword">import</span> time<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">mutli_task</span>():</span><br>    task_1 = asyncio.create_task(asyncio.sleep(<span class="hljs-number">1</span>))<br>    task_2 = asyncio.create_task(asyncio.sleep(<span class="hljs-number">2</span>))<br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    mutli_task()<br>    <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">1.5</span>) <br><br>s_t = time.time()<br>asyncio.run(main())<br>print(time.time() - s_t)<br><span class="hljs-comment"># // Output: 1.5027475357055664 </span><br></code></pre></td></tr></table></figure>
<p>在这段代码中，main Task在执行到<code>mutli_task</code>时，会创建出两个task，但是在<code>__step</code>中的<code>coro.send(None)</code>调用得到的结果却是<code>await asyncio.sleep(1.5)</code>返回的Future，所以main Task只能调用到这个Future的<code>add_don_callback</code>来装载自己的<code>__wakeup</code>方法，最终导致到main Task只能托管到<code>await asyncio.sleep(1.5)</code>的Future，而<code>mutli_task</code>创建的task则逃逸了，成为另一条链的顶点Task。</p>
<p>不过这个程序的事件循环只管理到了<code>main Task</code>所以事件循环会一直运行，直到<code>main Task</code>运行结束的时候才退出，这时程序会跟着一起退出，所以程序的运行时间只有1.5秒左右。<br>此外由于另外的Task也是注册到这个事件循环上面，所以事件循环会帮忙把task_1执行完毕，而task_2定义的休眠时间是2秒，程序退出之前事件循环会发现有个Task尚未执行完毕，于是会对这个Task进行清理并打印一条警报。</p>
<h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h2><p>在深入了Task，Future的源码了解后，了解了Task和Future在<code>Asyncio</code>的作用，同时也发现Task和Future都跟loop有一定的耦合，而loop也可以通过一定的方法来创建Task和Future，所以如果要真正的理解到<code>Asyncio</code>的调度原理，还需要更进入一步，通过<code>Asyncio</code>的源码来了解整个<code>Asyncio</code>的设计。</p>
]]></content>
      <categories>
        <category>Python Asyncio</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Asyncio</tag>
      </tags>
  </entry>
  <entry>
    <title>Python-gRPC实践(3)--使用Python实现gRPC服务</title>
    <url>/2022/04/07/Python-gRPC%E5%AE%9E%E8%B7%B5(3)--%E4%BD%BF%E7%94%A8Python%E5%AE%9E%E7%8E%B0gRPC%E6%9C%8D%E5%8A%A1/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>通过前面的文章了解到了<code>gRPC</code>是什么，以及清楚使用它的优缺点，现在终于可以开始实现一个<code>gRPC</code>服务了。</p>
<span id="more"></span>
<p>这里演示的是一个用户与书互动的项目，用户可以通过该项目进行注册，登录，注销等操作，同时也可以上传，查看和评论对应的书籍，通常情况下我们会由一个简单的Web应用来提供这些服务，现在，我们假设这个服务非常庞大，需要把他们按照功能拆分成不同的微服务了，这些服务与Web应用通过<code>gRPC</code>进行通信。</p>
<blockquote>
<p>注：由于篇幅原因，不会夹杂大量的源代码，需要跳转到<code>Github</code>中查看，同时对于业务逻辑也不会详细的介绍，所以可能需要一些接口开发经验才容易阅读懂。</p>
</blockquote>
<h2 id="1-初始化准备"><a href="#1-初始化准备" class="headerlink" title="1.初始化准备"></a>1.初始化准备</h2><p>在创建项目之前，我们需要确定我们的需求是什么，就像开发API接口一样，先了解需求，然后多方根据需求定义好接口，最后才为每个接口编写对应的代码，在这个项目中，我假定了拆分了两个服务，一个是与用户有关， 一个是与书籍有关，书籍部分又细分为书籍管理，书籍社交两部分。为此，先编写了Protobuf文件，之前在<a href="https://so1n.me/2022/02/05/Python-gRPC%E5%AE%9E%E8%B7%B5(2)--Protocol%20buffer/">Python-gRPC实践（2）–Protocol Buffer</a>中说过，我们创建<code>gRPC</code>对应的Protobuf文件应该放在一个公有的仓库中，这样就方便后续的Protobuf文件升级以及不同语言都能共享同一份Protobuf文件。</p>
<p>所以创建一个<code>gRPC</code>服务的第一步就是先创建一个包含Protobuf文件的仓库，我把它命名为<code>grpc-example-common</code>，具体源码可以通过<a href="https://github.com/so1n/grpc-example-common/tree/part-1">grpc-example-common</a>获取。</p>
<p>这个仓库中<code>pyproject.toml</code>文件的<code>tool.poetry.dependencies</code>部分如下:</p>
<figure class="highlight toml"><table><tr><td class="code"><pre><code class="hljs toml"><span class="hljs-section">[tool.poetry.dependencies]</span><br><span class="hljs-attr">python</span> = <span class="hljs-string">&quot;^3.8&quot;</span><br><span class="hljs-attr">grpcio</span> = <span class="hljs-string">&quot;^1.43.0&quot;</span><br><span class="hljs-attr">grpcio-tools</span> = <span class="hljs-string">&quot;^1.43.0&quot;</span><br></code></pre></td></tr></table></figure>
<p>通过这部分文件可以知道这个项目是基于<code>Python3.8</code>版本的，然后用到了2个依赖分别是<code>grpcio</code>以及<code>grpcio-tools</code>，其中<code>grpcio</code>是<code>Python</code>的<code>gRPC</code>实现，它是通过c语言翻译的，所以很多底层都是c实现的，如果在使用gRPC框架的过程中找不到对应的使用方法说明，那可以直接到gRPC的c项目中找到对应的函数并查看它的函数说明进而了解该函数的作用；而另一个库<code>grpcio-tools</code>的作用是把<code>proto</code>文件转译为<code>Python</code>代码，不过单靠<code>grpcio-tools</code>转译的代码很难使用，比如是这段代码:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">from</span> grpc_example_common.protos.user.user_pb2 <span class="hljs-keyword">import</span> LoginUserResult <br><br><br>login_user_result: LoginUserResult = LoginUserResult()<br></code></pre></td></tr></table></figure>
<p>这段代码引入了由<code>grpcio-tools</code>通过用户Protobuf文件生成的<code>LoginUserResult</code>对象，开发者在后续想要使用这个对象的时候，IDE是没办法提示你这个对象有什么属性的，只能凭自己的记忆进行填写，或者回到对应的Protobuf文件查看该对象的定义：</p>
<figure class="highlight plain"><figcaption><span>buffer</span></figcaption><table><tr><td class="code"><pre><code class="hljs Protocol">message LoginUserResult &#123;<br>  string uid &#x3D; 1;<br>  string user_name &#x3D; 2;<br>  string token &#x3D; 3;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>发现它有<code>uid</code>，<code>user_name</code>，<code>token</code>三个属性，然后才会在代码填写<code>LoginUserResult</code>对象的属性进行调用：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">from</span> grpc_example_common.protos.user.user_pb2 <span class="hljs-keyword">import</span> LoginUserResult <br><br><br>login_user_result: LoginUserResult = LoginUserResult(<br>    uid=<span class="hljs-string">&quot;123&quot;</span>,<br>    user_name=<span class="hljs-string">&quot;so1n&quot;</span>,<br>    token=<span class="hljs-string">&quot;aaa&quot;</span><br>)<br>print(login_user_result.uid)<br><span class="hljs-comment"># 123</span><br></code></pre></td></tr></table></figure>
<p>这时即使填错了，比如<code>uid</code>写为<code>uid1</code>IDE也不会提示有错误，我们需要等到运行时报错才知道是填错了。</p>
<p>这样一个场景是会让开发者非常难受的，明明都定义了一个Protobuf文件，文件中已经写了这个消息有什么属性了，结果生成对应的类却无法让IDE了解它有什么属性(跳进去源码也无法知道)，这时就需要通过<a href="https://github.com/nipunn1313/mypy-protobuf">mypy-protobuf</a>来解决这一个问题。<code>mypy-protobuf</code>会生成的一份独立的<code>.pyi</code>文件，这样一来IDE就可以帮忙提示这个对象有什么属性了，如图：<br><img    class="lazyload" data-original="https://cdn.jsdelivr.net/gh/so1n/so1n_blog_photo@master/blog_photo/16471860867391647186085970.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">IDE提醒</span><br>此外，通过<code>.pyi</code>文件可以使<code>mypy</code>等工具校验我们的代码类型是否正确，这样在运行前就能知道代码是否有问题。</p>
<p><code>mypy-protobuf</code>的使用方法十分的简单，它以<code>grpcio-tools</code>的一个插件来运行，具体的使用方法如下:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 定义生产文件的存放目录，通常都会在指定的目录下生成一个proto的文件夹</span><br>target_p = <span class="hljs-string">&quot;xxx&quot;</span><br><span class="hljs-comment"># 定义proto文件的目录</span><br>sourct_p = <span class="hljs-string">&quot;xxx&quot;</span><br>python -m grpc_tools.protoc \<br>    <span class="hljs-comment"># 指定xxx_pb2文件和xxx_pb2_grpc文件生成位置，通常我们都让他们在同一个文件夹生产</span><br>    --python_out=./<span class="hljs-variable">$target_p</span> \<br>    --grpc_python_out=./<span class="hljs-variable">$target_p</span> \<br>    <span class="hljs-comment"># 指定proto文件的位置</span><br>    -I. \<br>    <span class="hljs-variable">$source_p</span>/user/*.proto<br><span class="hljs-comment"># 上面是标准的grpcio-tools执行的标准语句</span><br>    <span class="hljs-comment"># 指定`mypy-protobuf`生成xxx_pb2和xxx_pb2_grpc对应的pyi文件的位置，必须与xxx_pb2和xxx_pb2_grpc位置保持一致</span><br>    --mypy_grpc_out=./<span class="hljs-variable">$target_p</span> \<br>    --mypy_out=./<span class="hljs-variable">$target_p</span> \<br></code></pre></td></tr></table></figure>
<p>只要运行了这段命令，<code>grpc_tools</code>就能在对应的路径下生成Protobuf对应的代码和对应的<code>pyi</code>文件，不过当前的<code>grpcio-tools</code>默认生成的代码所在的目录名是<code>protos</code>，它认为这个目录是在项目对应的根目录下生成的，如果我们指定在某个子目录下生产对应的代码，那么在运行程序时会直接报错，因为生成的代码文件中有一个大概长成这样的语句:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-comment"># xxx为proto文件的名</span><br><span class="hljs-keyword">from</span> protos.xxx <span class="hljs-keyword">import</span><br></code></pre></td></tr></table></figure>
<p>这意味着它永远都是从项目的根目录开始引入的<code>protos</code>包，但我们根目录却没有这个包，所以就会报错，这时就需要手动把生成的语句替换为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-comment"># xxx为proto文件的名</span><br><span class="hljs-keyword">from</span> .xxx <span class="hljs-keyword">import</span><br></code></pre></td></tr></table></figure>

<p>这样就可以完美运行了，但是每个文件手动改一下会非常的麻烦，因为每次生成代码后都要手动更改代码，同时由于项目存在多个Protobuf文件，每个文件都需要执行一次命令才能生成对应的代码。对于一个开发者来说，最讨厌的就是一直执行重复的工作，这种工作是非常烦心的， 所以需要编写了一个脚本来自动的把所有Protobuf文件转为<code>Python</code>代码(也就是项目中的<code>gen_rpc.sh</code>文件)，该脚本如下:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 设置脚本运行的Python环境 </span><br><span class="hljs-built_in">export</span> VENV_PREFIX=<span class="hljs-string">&quot;&quot;</span><br><span class="hljs-keyword">if</span> [ -d <span class="hljs-string">&#x27;venv&#x27;</span> ] ; <span class="hljs-keyword">then</span><br>    <span class="hljs-built_in">export</span> VENV_PREFIX=<span class="hljs-string">&quot;venv/bin/&quot;</span><br><span class="hljs-keyword">fi</span><br><span class="hljs-keyword">if</span> [ -d <span class="hljs-string">&#x27;.venv&#x27;</span> ] ; <span class="hljs-keyword">then</span><br>    <span class="hljs-built_in">export</span> VENV_PREFIX=<span class="hljs-string">&quot;.venv/bin/&quot;</span><br><span class="hljs-keyword">fi</span><br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;use venv path:&#x27;</span> <span class="hljs-variable">$&#123;VENV_PREFIX&#125;</span><br><br><span class="hljs-comment"># 设置生成的存放Python代码的proto文件夹的目录 </span><br>target_p=<span class="hljs-string">&#x27;grpc_example_common&#x27;</span><br><span class="hljs-comment"># 设置Proyobuf文件所在位置</span><br>source_p=<span class="hljs-string">&#x27;protos&#x27;</span><br><span class="hljs-comment"># 设置生成protobuf代码文件的文件名 </span><br>service_list=(<span class="hljs-string">&quot;book&quot;</span> <span class="hljs-string">&quot;user&quot;</span>)<br><br><span class="hljs-comment"># 清理之前生成的代码</span><br>rm -r <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;target_p:?&#125;</span>/<span class="hljs-variable">$&#123;source_p:?&#125;</span>&quot;</span>*<br><span class="hljs-comment"># 创建对应的文件夹</span><br>mkdir -p <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;target_p:?&#125;</span>/<span class="hljs-variable">$&#123;source_p:?&#125;</span>&quot;</span><br><br><span class="hljs-comment"># 批处理</span><br><span class="hljs-keyword">for</span> service <span class="hljs-keyword">in</span> <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;service_list[@]&#125;</span>&quot;</span><br><span class="hljs-keyword">do</span><br>  <span class="hljs-comment"># 生成proto文件对应的Python代码逻辑，每个proto文件执行一次</span><br>  mkdir -p <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;target_p:?&#125;</span>/<span class="hljs-variable">$&#123;source_p:?&#125;</span>/<span class="hljs-variable">$&#123;service:?&#125;</span>&quot;</span><br>  <span class="hljs-built_in">echo</span>  <span class="hljs-string">&quot;from proto file:&quot;</span> <span class="hljs-variable">$source_p</span>/<span class="hljs-string">&quot;<span class="hljs-variable">$service</span>&quot;</span>/*.proto <span class="hljs-string">&quot;gen proto py file to&quot;</span> <span class="hljs-variable">$target_p</span>/<span class="hljs-variable">$source_p</span><br>  <span class="hljs-variable">$&#123;VENV_PREFIX&#125;</span>python -m grpc_tools.protoc \<br>    --mypy_grpc_out=./<span class="hljs-variable">$target_p</span> \<br>    --mypy_out=./<span class="hljs-variable">$target_p</span> \<br>    --python_out=./<span class="hljs-variable">$target_p</span> \<br>    --grpc_python_out=./<span class="hljs-variable">$target_p</span> \<br>    -I. \<br>    <span class="hljs-variable">$source_p</span>/<span class="hljs-string">&quot;<span class="hljs-variable">$service</span>&quot;</span>/*.proto<br><br>  <span class="hljs-comment"># 创建一个__init__文件，这样一来这个文件夹就是一个包了，下面转换为from . import语句才能生效</span><br>  touch <span class="hljs-variable">$target_p</span>/<span class="hljs-variable">$source_p</span>/<span class="hljs-string">&quot;<span class="hljs-variable">$service</span>&quot;</span>/__init__.py<br>  <span class="hljs-comment"># fix grpc tools bug</span><br>  sed -i <span class="hljs-string">&quot;s/from protos.<span class="hljs-variable">$service</span> import/from . import/&quot;</span> <span class="hljs-variable">$target_p</span>/<span class="hljs-variable">$source_p</span>/<span class="hljs-variable">$service</span>/*.py<br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure>
<p>这样一来，我们通过Protobuf文件生成<code>Python</code>代码的操作就非常省心了，不管Protobuf文件有何改动，只要通过调用命令后就能在<code>grpc_example_common.protos</code>目录下看到已经生成的最新的<code>Python</code>代码，目前<code>grpc_example_common</code>的项目结构如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">├── grpc_example_common    <span class="hljs-comment"># Python与gRPC相关的调用</span><br>│   ├── helper<br>│   ├── __init__.py<br>│   ├── interceptor<br>│   └── protos             <span class="hljs-comment"># 生成的对应Python代码</span><br>├── protos                 <span class="hljs-comment"># Protobuf文件</span><br>│   ├── book<br>│   └── user<br>├──.flake8                 <span class="hljs-comment"># 格式化工具的配置</span><br>├──.pre-commit-config.yaml <span class="hljs-comment"># 格式化工具的配置</span><br>├── gen_rpc.sh             <span class="hljs-comment"># 通过proto文件生成Python gRPC调用代码的脚本</span><br>├── mypy.ini               <span class="hljs-comment"># 格式化工具的配置</span><br>├── pyproject.toml         <span class="hljs-comment"># Python项目配置文件</span><br>├── README.md<br>├── requirements-dev.txt   <span class="hljs-comment"># 测试环境的依赖文件</span><br>├── requirements.txt       <span class="hljs-comment"># 正式环境的依赖文件</span><br>└── setup.py <br></code></pre></td></tr></table></figure>
<p>通过项目结构可以看出还有其它的东西，这是我为了方便，我还在这个项目中添加一些<code>Python</code>与<code>gRPC</code>相关的调用封装，把它当做一个<code>Python</code>的自定义包。</p>
<p>需要注意的是，每修改一次Protobuf文件应该视为一次版本发布，当生成完Protobuf文件的对应代码后，我们需要提交代码并打上对应的tag，这样其它项目才能引用到对应的版本代码。</p>
<blockquote>
<p>对于格式化工具以及poetry包管理工具不了解的可以通过文章<a href="https://so1n.me/2021/08/10/%E4%BF%9D%E9%9A%9CPython%E9%A1%B9%E7%9B%AE%E8%B4%A8%E9%87%8F%E7%9A%84%E5%B7%A5%E5%85%B7/">保障Python项目质量的工具</a>了解。</p>
</blockquote>
<blockquote>
<p><code>grpc_example_common</code>目录下还有其它常用的封装，将会在后续章节介绍。</p>
</blockquote>
<h2 id="2-编写gRPC服务项目"><a href="#2-编写gRPC服务项目" class="headerlink" title="2.编写gRPC服务项目"></a>2.编写gRPC服务项目</h2><p>目前这个演示的项目有两个子gRPC项目，分别为<a href="https://github.com/so1n/grpc-example-book-grpc-service">grpc-example-book-grpc-service</a>和<a href="https://github.com/so1n/grpc-example-user-grpc-service">grpc-example-user-grpc-service</a>，他们的结构很像，所以这一节以<a href="https://github.com/so1n/grpc-example-user-grpc-service">grpc-example-user-grpc-service</a>来阐述如何创建一个gRPC服务。</p>
<p>该项目的代码结构如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">├── tests                 <span class="hljs-comment"># 存放测试用例</span><br>│   ├── __init__.py<br>│   └── test_user.py<br>├── user_grpc_service     <span class="hljs-comment"># 项目代码真正所在的位置</span><br>│   ├── dal               <span class="hljs-comment">#   service代码，一般用于查询Mysql,Redis的逻辑</span><br>│   ├── handler           <span class="hljs-comment">#   业务逻辑代码，继承对应Protobuf文件生成的类</span><br>│   ├── helper            <span class="hljs-comment">#   其它代码封装。</span><br>│   └── __init__.py<br>├── app.py                <span class="hljs-comment"># 项目代码入口</span><br>├── mypy.ini              <span class="hljs-comment"># mypy配置文件</span><br>├── pyproject.toml        <span class="hljs-comment"># 项目配置文件</span><br>└── user.sql              <span class="hljs-comment"># 项目初始化SQL</span><br></code></pre></td></tr></table></figure>
<p>首先，该项目会通过如下配置引入一些依赖：</p>
<figure class="highlight toml"><table><tr><td class="code"><pre><code class="hljs toml"><span class="hljs-section">[tool.poetry.dependencies]</span><br><span class="hljs-attr">python</span> = <span class="hljs-string">&quot;^3.8&quot;</span><br><span class="hljs-attr">DBUtils</span> = <span class="hljs-string">&quot;^3.0.0&quot;</span><br><span class="hljs-attr">PyMySQL</span> = <span class="hljs-string">&quot;^1.0.2&quot;</span><br><span class="hljs-attr">cryptography</span> = <span class="hljs-string">&quot;^36.0.1&quot;</span><br><span class="hljs-attr">grpc_example_common</span> = &#123; git = <span class="hljs-string">&quot;git@github.com:so1n/grpc-example-common.git&quot;</span>, tag=<span class="hljs-string">&quot;v0.1.2&quot;</span>&#125;<br></code></pre></td></tr></table></figure>
<p>其中<code>grpc_example_common</code>项目就是包括我们上面通过Protobuf生成的文件生产的代码，以及一些自定义的封装，通过引入依赖后，可以很方便的引用Protobuf文件生成的代码。</p>
<p>安装依赖后，就可以在项目中编写对应的gRPC服务了， 在这个项目里有一个比较简单的分层，所有的gRPC服务接口处理的函数都在放在<code>user_grpc_service.handler</code>目录中，而与数据库交互的则放在<code>user_grpc_service.dal</code>中。</p>
<p>编写服务的第一步，就是在<code>user_grpc_service.handler</code>编写对应的代码，先创建一个名为<code>user.py</code>的文件，该文件的代码值负责对User服务的调用，由于对于User服务只有一个子服务，里面只需要创建一个名为<code>UserServicer</code>的类，这个类似继承于Protobuf生成的<code>user_pb2_grpc.UserServicer</code>类，如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-comment"># 通过common包引入对应Protobuf文件生成的代码</span><br><span class="hljs-keyword">from</span> grpc_example_common.protos.user <span class="hljs-keyword">import</span> user_pb2_grpc <span class="hljs-keyword">as</span> user_service<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserServicer</span>(<span class="hljs-params">user_service.UserServicer</span>):</span><br>    <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure>
<p>这时候IDE会在<code>UserServicer</code>上显示波浪线，如果鼠标移到波浪线位置上，IDE会提示<code>类 User 必须实现所有 abstract 方法</code>，于是点击<code>实现abstract方法</code>后，就会自动生成类似于下面的代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">from</span> google.protobuf.empty_pb2 <span class="hljs-keyword">import</span> Empty  <span class="hljs-comment"># type: ignore</span><br><span class="hljs-keyword">from</span> grpc_example_common.protos.user <span class="hljs-keyword">import</span> user_pb2 <span class="hljs-keyword">as</span> user_message<br><span class="hljs-keyword">from</span> grpc_example_common.protos.user <span class="hljs-keyword">import</span> user_pb2_grpc <span class="hljs-keyword">as</span> user_service<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserServicer</span>(<span class="hljs-params">user_service.UserServicer</span>):</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">logout_user</span>(<span class="hljs-params">self, request: user_message.LogoutUserRequest,</span></span><br><span class="hljs-function"><span class="hljs-params">                    context: grpc.ServicerContext</span>) -&gt; Empty:</span><br>        <span class="hljs-keyword">pass</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">login_user</span>(<span class="hljs-params">self, request: user_message.LoginUserRequest,</span></span><br><span class="hljs-function"><span class="hljs-params">                   context: grpc.ServicerContext</span>) -&gt; user_message.LoginUserResult:</span><br>        <span class="hljs-keyword">pass</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">create_user</span>(<span class="hljs-params">self, request: user_message.CreateUserRequest,</span></span><br><span class="hljs-function"><span class="hljs-params">                    context: grpc.ServicerContext</span>) -&gt; Empty:</span><br>        <span class="hljs-keyword">pass</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">delete_user</span>(<span class="hljs-params">self, request: user_message.DeleteUserRequest,</span></span><br><span class="hljs-function"><span class="hljs-params">                    context: grpc.ServicerContext</span>) -&gt; Empty:</span><br>        <span class="hljs-keyword">pass</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">check_user_login</span>(<span class="hljs-params">self, request: user_message.LogoutUserRequest,</span></span><br><span class="hljs-function"><span class="hljs-params">                         context: grpc.ServicerContext</span>) -&gt; user_message.CheckLoginResult:</span><br>        <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure>
<p>这段代码就是<a href="https://github.com/so1n/grpc-example-common/blob/part-1/protos/user/user.proto">protos/user/user.proto</a>对应的<code>Python</code>代码表达，当客户端调用<code>UserServicer.logout_user</code>方法时，服务端就会自动转到该方法执行对应的逻辑，并返回结果给客户端，所以对于开发者来说只要专心完成好这几个接口的实现即可。开发者编写此处的业务逻辑代码与平时编写的API代码基本没什么差别，这里不多做阐述，具体的业务逻辑可见<a href="https://github.com/so1n/grpc-example-user-grpc-service/blob/part-1/user_grpc_service/handler/user.py">user_grpc_service/handler/user.py</a></p>
<p>不过需要注意的是从<code>request</code>中得到的数据对象并不是<code>Python</code>中常见的对象，而是gRPC封装的且类似于<code>Python</code>常见的对象，如果直接用于<code>pymysql</code>的类似代码:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">with</span> conn.cursor() <span class="hljs-keyword">as</span> cursor:<br>    cursor.execute(sql, param)<br></code></pre></td></tr></table></figure>
<p>那么execute可能会转码失败，导致拼接不了正确的SQL，这时候可以把<code>request</code>中得到的对象转为<code>Python</code>中场见的对象，比如<code>gRPC</code>的时间类型<code>Timestamp</code>与<code>Python</code>时间类型<code>datetime</code>转换如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> datetime<br><span class="hljs-keyword">from</span> dataclasses <span class="hljs-keyword">import</span> MISSING<br><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> Any, Optional<br><br><span class="hljs-keyword">from</span> google.protobuf.timestamp_pb2 <span class="hljs-keyword">import</span> Timestamp  <span class="hljs-comment"># type: ignore</span><br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">timestamp_to_datetime</span>(<span class="hljs-params">t: Timestamp, default: Any = MISSING</span>) -&gt; datetime.datetime:</span><br>    <span class="hljs-string">&quot;&quot;&quot;replace proto.timestamp to python datetime.datetime&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">if</span> t.seconds == <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> t.nanos == <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> default != MISSING:<br>        <span class="hljs-keyword">return</span> default<br>    <span class="hljs-keyword">return</span> t.ToDatetime()<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">datetime_to_timestamp</span>(<span class="hljs-params">d: Optional[datetime.datetime]</span>) -&gt; Timestamp:</span><br>    <span class="hljs-string">&quot;&quot;&quot;replace python datetime.datetime to proto.timestamp&quot;&quot;&quot;</span><br>    t: Timestamp = Timestamp()<br>    <span class="hljs-keyword">if</span> d:<br>        t.FromDatetime(d)<br>    <span class="hljs-keyword">return</span> t<br></code></pre></td></tr></table></figure>
<p>通过封装好的<code>timestamp_to_datetime</code>和<code>datetime_to_timestamp</code>可以方便的在业务逻辑中对<code>gRPC</code>和<code>Python</code>对象进行转换，更多类型转换见<a href="https://github.com/so1n/grpc-example-common/blob/part-1/grpc_example_common/helper/field.py">grpc_example_common/helper/field.py</a>，不过这种转换的实现是非常简单的，性能也不是很好，如果为了追求性能，可以尝试使用<a href="https://github.com/eigenein/protobuf">pure-protobuf</a>，它会带来一点复杂性，但是使用感受会非常好，性能也非常棒。</p>
<p>业务代码编写完后，需要绑定到对应的<code>Server</code>上面才能正常的提供服务，于是我们需要像创建<code>Flask Server</code>一样，先创建一个服务，然后把路由注册进去，对于<code>gRPC</code>的实现代码如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> logging<br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">from</span> concurrent <span class="hljs-keyword">import</span> futures<br><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> List, Optional<br><br><span class="hljs-keyword">import</span> grpc<br><span class="hljs-keyword">from</span> grpc_example_common.interceptor.server_interceptor.base <span class="hljs-keyword">import</span> BaseInterceptor<br><span class="hljs-keyword">from</span> grpc_example_common.interceptor.server_interceptor.customer_top <span class="hljs-keyword">import</span> CustomerTopInterceptor<br><br><span class="hljs-keyword">from</span> user_grpc_service.handler.user <span class="hljs-keyword">import</span> UserService, user_service<br><br>logging.basicConfig(<br>    <span class="hljs-built_in">format</span>=<span class="hljs-string">&quot;[%(asctime)s %(levelname)s] %(message)s&quot;</span>,<br>    datefmt=<span class="hljs-string">&quot;%y-%m-%d %H:%M:%S&quot;</span>,<br>    level=logging.DEBUG,<br>)<br>logger: logging.Logger = logging.getLogger()<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>(<span class="hljs-params">host: <span class="hljs-built_in">str</span> = <span class="hljs-string">&quot;127.0.0.1&quot;</span>, port: <span class="hljs-built_in">str</span> = <span class="hljs-string">&quot;9000&quot;</span>, ssl_port: Optional[<span class="hljs-built_in">str</span>] = <span class="hljs-literal">None</span></span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>    <span class="hljs-comment"># 拦截器列表</span><br>    interceptor_list: List[BaseInterceptor] = [CustomerTopInterceptor()]<br>    <span class="hljs-comment"># 创建一个gRPC服务</span><br>    server: grpc.server = grpc.server(<br>        futures.ThreadPoolExecutor(max_workers=<span class="hljs-number">10</span>),<br>        interceptors=interceptor_list,<br>    )<br>    <span class="hljs-comment"># 绑定我们的业务实现到服务上</span><br>    user_service.add_UserServicer_to_server(UserService(), server)<br><br>    <span class="hljs-keyword">if</span> ssl_port:<br>        <span class="hljs-comment"># 如果是启用了ssl,则读取文件，然后建立一个安全的连接</span><br>        port = ssl_port<br>        <span class="hljs-comment"># read in key and certificate</span><br>        <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(os.path.join(os.path.split(__file__)[<span class="hljs-number">0</span>], <span class="hljs-string">&quot;server.key&quot;</span>)) <span class="hljs-keyword">as</span> f:<br>            private_key = f.read().encode()<br>        <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(os.path.join(os.path.split(__file__)[<span class="hljs-number">0</span>], <span class="hljs-string">&quot;server.crt&quot;</span>)) <span class="hljs-keyword">as</span> f:<br>            certificate_chain = f.read().encode()<br>        <span class="hljs-comment"># create server credentials</span><br>        server_creds = grpc.ssl_server_credentials(<br>            (<br>                (<br>                    private_key,<br>                    certificate_chain,<br>                ),<br>            )<br>        )<br>        server.add_secure_port(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;host&#125;</span>:<span class="hljs-subst">&#123;port&#125;</span>&quot;</span>, server_creds)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-comment"># 否则建立一个普通的连接</span><br>        server.add_insecure_port(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;host&#125;</span>:<span class="hljs-subst">&#123;port&#125;</span>&quot;</span>)<br>    <span class="hljs-comment"># 启动服务</span><br>    server.start()<br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-comment"># 打印我们挂载了多少个子服务(也就是上面注册的服务)</span><br>        <span class="hljs-keyword">for</span> generic_handler <span class="hljs-keyword">in</span> server._state.generic_handlers:<br>            logger.info(<br>                <span class="hljs-string">f&quot;add service name:<span class="hljs-subst">&#123;generic_handler.service_name()&#125;</span> cnt:<span class="hljs-subst">&#123;<span class="hljs-built_in">len</span>(generic_handler._method_handlers)&#125;</span>&quot;</span><br>            )<br>        logger.info(<span class="hljs-string">f&quot;server run in <span class="hljs-subst">&#123;host&#125;</span>:<span class="hljs-subst">&#123;port&#125;</span>&quot;</span>)<br>        <span class="hljs-comment"># 一直运行，直到被关闭</span><br>        server.wait_for_termination()<br>    <span class="hljs-keyword">except</span> KeyboardInterrupt:<br>        <span class="hljs-comment"># 收到退出的信号，关闭服务</span><br>        server.stop(<span class="hljs-number">0</span>)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    main()<br></code></pre></td></tr></table></figure>
<p>可以看到这段代码非常简单， 但是他肩负了很多请求和连接的健康维护，会在后续的章节中详细介绍。</p>
<h2 id="3-测试编写的gRPC服务"><a href="#3-测试编写的gRPC服务" class="headerlink" title="3.测试编写的gRPC服务"></a>3.测试编写的gRPC服务</h2><p>代码编写完成后就应该发起请求，看看这个服务是否能正常运行，但是<code>gRPC</code>服务不像<code>HTTP</code>服务一样可以在浏览器等地方输入一个URL就能发起一个请求，所以为了能验证我们的服务能否正常的运行，我们应该编写一个测试用例。</p>
<p>在官方文档<a href="https://grpc.github.io/grpc/python/grpc_testing.html">gRPC Testing</a>中介绍了<code>gRPC</code>的测试用例编写方法，但是这个只覆盖到了业务代码，无法覆盖到拦截器，参数调优等逻辑，而我目前使用到了一个名为<code>CustomerTopInterceptor</code>的拦截器，它在发现业务代码有异常的时候会把异常通过<code>meta_data</code>传给客户端，然后客户端进行解析并抛出对应的异常(这种实现可能不是最优雅的，但是符合需求)，如果采用了官方的<code>gRPC Testing</code>，那在测试用例中山无法捕获到对应的异常的，所以只能采取其它的测试方法来编写一个覆盖范围更广的测试用例–<a href="https://pypi.org/project/pytest-grpc/">pytest-grpc</a>。</p>
<p>首先是安装好<a href="https://pypi.org/project/pytest-grpc/">pytest-grpc</a>，然后按照标准的测试用例编写习惯，在项目根目录创建一个名为<code>tests</code>的目录，(当然，我也在<code>pyproject.toml</code>指定了<code>pytest</code>的执行目录为<code>tests</code>)，然后在里面编写每个子服务的测试代码，一般来说一个子服务对应一个<code>Python</code>文件，接着在这个文件的最前面编写服务<a href="https://pypi.org/project/pytest-grpc/">pytest-grpc</a>要求的代码:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> Callable, List<br><br><span class="hljs-keyword">import</span> grpc<br><span class="hljs-keyword">from</span> grpc_example_common.interceptor.client_interceptor.customer_top <span class="hljs-keyword">import</span> (<br>    CustomerTopInterceptor <span class="hljs-keyword">as</span> ClientCustomerTopInterceptor,<br>)<br><span class="hljs-keyword">from</span> grpc_example_common.interceptor.server_interceptor.customer_top <span class="hljs-keyword">import</span> CustomerTopInterceptor<br><span class="hljs-keyword">from</span> grpc_example_common.protos.user <span class="hljs-keyword">import</span> user_pb2, user_pb2_grpc<br><br><span class="hljs-keyword">from</span> user_grpc_service.handler.user <span class="hljs-keyword">import</span> UserService<br><span class="hljs-keyword">from</span> user_grpc_service.helper.conn_proxy <span class="hljs-keyword">import</span> SteadyDBConnection, g_db_pool<br><br><span class="hljs-comment"># 应用的是整个文件的测试用例， 所以都需要写上@pytest.fixture(scope=&quot;module&quot;)</span><br><br><br><span class="hljs-meta">@pytest.fixture(<span class="hljs-params">scope=<span class="hljs-string">&quot;module&quot;</span></span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">grpc_add_to_server</span>() -&gt; Callable:</span><br>    <span class="hljs-comment"># 指定该子服务对应的添加服务接口</span><br>    <span class="hljs-keyword">return</span> user_pb2_grpc.add_UserServicer_to_server<br><br><br><span class="hljs-meta">@pytest.fixture(<span class="hljs-params">scope=<span class="hljs-string">&quot;module&quot;</span></span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">grpc_servicer</span>() -&gt; UserService:</span><br>    <span class="hljs-comment"># 指定我们编写该子服务的类</span><br>    <span class="hljs-keyword">return</span> UserService()<br><br><br><span class="hljs-meta">@pytest.fixture(<span class="hljs-params">scope=<span class="hljs-string">&quot;module&quot;</span></span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">grpc_interceptors</span>() -&gt; List[grpc.ServerInterceptor]:</span><br>    <span class="hljs-comment"># 指定服务端对应的拦截器</span><br>    <span class="hljs-keyword">return</span> [CustomerTopInterceptor()]<br><br><br><span class="hljs-meta">@pytest.fixture(<span class="hljs-params">scope=<span class="hljs-string">&quot;module&quot;</span></span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">grpc_stub</span>(<span class="hljs-params">grpc_channel: grpc.Channel</span>) -&gt; user_pb2_grpc.UserStub:</span><br>    <span class="hljs-comment"># 指定子服务对应的客户端</span><br>    <span class="hljs-comment"># 这里会先生成一个channel，该channel用于跟服务端通信，</span><br>    <span class="hljs-comment"># 同时它也有一个与服务端拦截器CustomerTopInterceptor对应的拦截器ClientCustomerTopInterceptor</span><br>    <span class="hljs-comment"># 最后把channel应用到对应的子服务Stub上面</span><br>    channel: grpc.Channel = grpc.intercept_channel(grpc_channel, ClientCustomerTopInterceptor())<br>    <span class="hljs-keyword">return</span> user_pb2_grpc.UserStub(channel)<br></code></pre></td></tr></table></figure>
<p>创建完成后我们就可以继续在该文件编写对应的测试用例代码了，这样在运行的时候都会自动加载上面代码，然后我们可以在每个测试用例都使用上面代码创建的客户端<code>grpc_stub</code>来发起请求进行测试。以创建用户和删除用户两个接口为例子，创建用户接口调用后会在数据库生成一条对应的数据，而删除用户接口会从数据库删除一条对应的数据，如果数据不存在于数据库，则会抛出<code>RuntimeError</code>异常（具体代码逻辑可见<a href="https://github.com/so1n/grpc-example-user-grpc-service/blob/part-1/user_grpc_service/handler/user.py">user_grpc_service/handler/user.py</a>），他们的测试用例代码如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">from</span> contextlib <span class="hljs-keyword">import</span> contextmanager<br><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> Callable, Generator, List<br><br><span class="hljs-meta">@contextmanager</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">mock_user</span>(<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">    uid: <span class="hljs-built_in">str</span> = <span class="hljs-string">&quot;666666&quot;</span>, </span></span><br><span class="hljs-function"><span class="hljs-params">    user_name: <span class="hljs-built_in">str</span> = <span class="hljs-string">&quot;so1n&quot;</span>, </span></span><br><span class="hljs-function"><span class="hljs-params">    password: <span class="hljs-built_in">str</span> = <span class="hljs-string">&quot;123456&quot;</span></span></span><br><span class="hljs-function"><span class="hljs-params"></span>) -&gt; Generator[<span class="hljs-keyword">None</span>, <span class="hljs-keyword">None</span>, <span class="hljs-keyword">None</span>]:</span><br>    <span class="hljs-string">&quot;&quot;&quot;通过contextmanager可以在对应的代码逻辑创建一个用户，并在结束时自动清除该用户信息&quot;&quot;&quot;</span><br>    conn: SteadyDBConnection = g_db_pool.connection()<br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-keyword">with</span> conn.cursor() <span class="hljs-keyword">as</span> cursor:<br>            cursor.execute(<br>                <span class="hljs-string">&quot;INSERT INTO user (uid, user_name, password) VALUES (%s, %s, %s)&quot;</span>,<br>                (uid, user_name, password),<br>            )<br>            conn.commit()<br>        <span class="hljs-keyword">yield</span><br>    <span class="hljs-keyword">finally</span>:<br>        <span class="hljs-keyword">with</span> conn.cursor() <span class="hljs-keyword">as</span> cursor:<br>            cursor.execute(<span class="hljs-string">&quot;DELETE FROM user WHERE uid=%s&quot;</span>, (uid,))<br>            conn.commit()<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestUser</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_create_user</span>(<span class="hljs-params">self, grpc_stub: user_pb2_grpc.UserStub</span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        <span class="hljs-string">&quot;&quot;&quot;创建用户调用的测试用例&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">try</span>:<br>            request: user_pb2.CreateUserRequest = user_pb2.CreateUserRequest(<br>                uid=<span class="hljs-string">&quot;666666&quot;</span>, user_name=<span class="hljs-string">&quot;so1n&quot;</span>, password=<span class="hljs-string">&quot;123456&quot;</span><br>            )<br>            <span class="hljs-comment"># 通过客户端带有的create_user方法发起请求，他会请求到我们的服务端代码</span><br>            <span class="hljs-comment"># 之后服务端的业务代码会在数据库创建一条对应的用户数据</span><br>            grpc_stub.create_user(request, metadata=[])<br>        <span class="hljs-keyword">finally</span>:<br>            conn: SteadyDBConnection = g_db_pool.connection()<br>            conn.begin()<br>            <span class="hljs-keyword">with</span> conn.cursor() <span class="hljs-keyword">as</span> cursor:<br>                <span class="hljs-comment"># 删除刚才创建的用户数据，返回删除的条目数量</span><br>                ret: <span class="hljs-built_in">int</span> = cursor.execute(<span class="hljs-string">&quot;DELETE FROM user WHERE uid=%s&quot;</span>, (<span class="hljs-string">&quot;666666&quot;</span>,))<br>            conn.commit()<br>            <span class="hljs-comment"># 判断是否成功删除一条用户数据，如果是，则代表刚才创建成功。 </span><br>            <span class="hljs-keyword">assert</span> ret == <span class="hljs-number">1</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_delete_user</span>(<span class="hljs-params">self, grpc_stub: user_pb2_grpc.UserStub</span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        <span class="hljs-string">&quot;&quot;&quot;删除用户调用的测试用例&quot;&quot;&quot;</span><br>        uid: <span class="hljs-built_in">str</span> = <span class="hljs-string">&quot;666666&quot;</span><br>        <span class="hljs-comment"># 创建delete_user对应的请求对象</span><br>        request: user_pb2.DeleteUserRequest = user_pb2.DeleteUserRequest(uid=uid)<br>        <span class="hljs-comment"># user not found</span><br>        <span class="hljs-keyword">with</span> pytest.raises(RuntimeError):<br>            <span class="hljs-comment"># 当前数据库没有对应的用户数据，会抛出RuntimeError异常，如果pytest能够捕获到这个异常，则证明拦截器生效了。</span><br>            grpc_stub.delete_user(request, metadata=[])<br>        <span class="hljs-keyword">with</span> mock_user(uid=uid):<br>            <span class="hljs-comment"># 在数据库存在对应的用户数据下，能正常删除数据，并不抛错</span><br>            grpc_stub.delete_user(request, metadata=[])<br></code></pre></td></tr></table></figure>
<p>运行测试用例可以发现测试通过了，接下来就可以编写我们的API服务，在API服务中调用我们的gRPC服务。</p>
<h2 id="4-编写API服务"><a href="#4-编写API服务" class="headerlink" title="4.编写API服务"></a>4.编写API服务</h2><p><code>gRPC</code>服务搭建完毕后，终于可以来编写API服务了，有了API服务后，才能把功能提供给了用户，API服务的项目结构如下:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">├── app_service                   <span class="hljs-comment"># API接口的服务，包括路由和调用封装</span><br>│   ├── social_book_route.py<br>│   ├── manager_book_route.py<br>│   ├── utils.py<br>│   ├── route.py<br>│   ├── user_route.py<br>│   └── __init__.py<br>├── grpc_service                  <span class="hljs-comment"># 调用gRPC的服务</span><br>│   ├── __init__.py<br>│   ├── user_service.py<br>│   └── book_service.py<br>├── tests                         <span class="hljs-comment"># 测试用例</span><br>│   ├── test_route<br>│   ├── __init__.py<br>│   └── conftest.py<br>├── app.py                        <span class="hljs-comment"># app代码</span><br>├── gunicorn.conf.py              <span class="hljs-comment"># gunicorn的配置文件</span><br>├── pyproject.toml<br>├── README.md<br>└── mypy.ini<br></code></pre></td></tr></table></figure>

<p>API服务与<code>gRPC</code>服务一样，通过<code>pyproject.toml</code>的配置:</p>
<figure class="highlight toml"><table><tr><td class="code"><pre><code class="hljs toml"><span class="hljs-section">[tool.poetry.dependencies]</span><br><span class="hljs-attr">python</span> = <span class="hljs-string">&quot;^3.8&quot;</span><br><span class="hljs-attr">grpc_example_common</span> = &#123; git = <span class="hljs-string">&quot;git@github.com:so1n/grpc-example-common.git&quot;</span>, tag=<span class="hljs-string">&quot;v0.1.4&quot;</span> &#125;<br><span class="hljs-attr">Flask</span> = <span class="hljs-string">&quot;^2.0.3&quot;</span><br></code></pre></td></tr></table></figure>
<p>引用了<code>grpc_example_common</code>的库， 然后在<code>grpc_service</code>中用到了该库，还是以用户服务为例子，用户服务的代码位于项目的<code>grpc_service.user_service.py</code>中，这个代码首先是创建一个<code>Mixin</code>的类：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserGrpcServiceMixin</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, channel: grpc.Channel</span>):</span><br>        self.user_stub: user_service.UserStub = user_service.UserStub(channel)<br>        <span class="hljs-comment"># 通过grpc_wrapper.grpc_client_func_wrapper为所有的请求带上matedate参数</span><br>        grpc_wrapper.auto_load_wrapper_by_stub(self.user_stub, grpc_wrapper.grpc_client_func_wrapper)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">create_user</span>(<span class="hljs-params">self, *, uid: <span class="hljs-built_in">str</span>, user_name: <span class="hljs-built_in">str</span>, password: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        self.user_stub.create_user(user_message.CreateUserRequest(uid=uid, user_name=user_name, password=password))<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">delete_user</span>(<span class="hljs-params">self, *, uid: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        self.user_stub.delete_user(user_message.DeleteUserRequest(uid=uid))<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">login_user</span>(<span class="hljs-params">self, *, uid: <span class="hljs-built_in">str</span>, password: <span class="hljs-built_in">str</span></span>) -&gt; user_message.LoginUserResult:</span><br>        <span class="hljs-keyword">return</span> self.user_stub.login_user(user_message.LoginUserRequest(uid=uid, password=password))<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">logout_user</span>(<span class="hljs-params">self, *, uid: <span class="hljs-built_in">str</span>, token: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        self.user_stub.logout_user(user_message.LogoutUserRequest(uid=uid, token=token))<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_uid_by_token</span>(<span class="hljs-params">self, *, token: <span class="hljs-built_in">str</span></span>) -&gt; str:</span><br>        result: user_message.GetUidByTokenResult = self.user_stub.get_uid_by_token(<br>            user_message.GetUidByTokenRequest(token=token)<br>        )<br>        <span class="hljs-keyword">return</span> result.uid<br></code></pre></td></tr></table></figure>
<p>这个类就是对<code>user_service.UserStub</code>的简单封装，可以看到方法名和参数与Protobuf保持一致，它只是接受一个负责通信的channel，然后传入到<code>user_stub</code>中，方便后续的方法对<code>user_stub</code>调用，同时这个类还负责一些数据的转换，如上面提到的<code>Protobuf</code>的<code>Timestamps</code>对象转为<code>Python</code>的<code>datetime</code>对象。</p>
<p>接着创建一个负责子服务管理的<code>UserGrpcSerevice</code>类，这个类负责建立通信和维护通信段稳定：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserGrpcService</span>(<span class="hljs-params">UserGrpcServiceMixin</span>):</span><br>    <span class="hljs-comment"># 如果有多个，则在这里继承多个mixin</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, host: <span class="hljs-built_in">str</span>, port: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        <span class="hljs-comment"># 初始化与服务端的通信</span><br>        self.channel: grpc.Channel = grpc.intercept_channel(<br>            grpc.insecure_channel(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;host&#125;</span>:<span class="hljs-subst">&#123;port&#125;</span>&quot;</span>), CustomerTopInterceptor()<br>        )<br>        <span class="hljs-comment"># 传入到对应的服务里</span><br>        UserGrpcServiceMixin.__init__(self, self.channel)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">channel_ready_future</span>(<span class="hljs-params">self, timeout: <span class="hljs-built_in">int</span> = <span class="hljs-number">10</span></span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        <span class="hljs-comment"># 用于检查是否与服务端建立起连接</span><br>        target: <span class="hljs-built_in">str</span> = (<br>            <span class="hljs-string">f&quot;<span class="hljs-subst">&#123;self.__class__.__name__&#125;</span>&quot;</span><br>            <span class="hljs-string">f&quot; <span class="hljs-subst">&#123;self.channel._channel._connectivity_state.channel.target().decode()&#125;</span>&quot;</span>  <span class="hljs-comment"># type: ignore</span><br>        )  <span class="hljs-comment"># type: ignore</span><br>        <span class="hljs-keyword">try</span>:<br>            grpc.channel_ready_future(self.channel).result(timeout=timeout)<br>        <span class="hljs-keyword">except</span> grpc.FutureTimeoutError:<br>            logger.exception(<span class="hljs-string">f&quot;channel:<span class="hljs-subst">&#123;target&#125;</span> connect timeout&quot;</span>)<br>            <span class="hljs-keyword">raise</span> RuntimeError(<span class="hljs-string">f&quot;channel:<span class="hljs-subst">&#123;target&#125;</span> connect timeout&quot;</span>)<br>        <span class="hljs-keyword">else</span>:<br>            logger.info(<span class="hljs-string">f&quot;channel:<span class="hljs-subst">&#123;target&#125;</span> connect success&quot;</span>)<br></code></pre></td></tr></table></figure>
<p>创建完毕后对于gRPC客户端调用服务端的逻辑已经封装完成了，接下来就是在路由函数中进行使用了，一般情况下都是使用单例的模式创建一个<code>UserGrpcService</code>的实例，但是我不太喜欢这样做，于是创建了一个中间件，然后通过<code>flask.g</code>传递创建app时初始化的<code>gRPC</code>服务示例，对应的中间件处理代码如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> Any, Union<br><br><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Blueprint, Flask, Response<br><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> g <span class="hljs-keyword">as</span> flask_g<br><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> jsonify, request<br><br><span class="hljs-keyword">from</span> grpc_service.book_service <span class="hljs-keyword">import</span> BookGrpcService<br><span class="hljs-keyword">from</span> grpc_service.user_service <span class="hljs-keyword">import</span> UserGrpcService<br><br>APP_TYPE = Union[Blueprint, Flask]<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomerGType</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;基于flasg.g的封装，这样就可以无忧的使用IDE的提示和重构功能了&quot;&quot;&quot;</span><br>    book_grpc_service: BookGrpcService<br>    user_grpc_service: UserGrpcService<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__getattr__</span>(<span class="hljs-params">self, key: <span class="hljs-built_in">str</span></span>) -&gt; Any:</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">getattr</span>(flask_g, key)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__setattr__</span>(<span class="hljs-params">self, key: <span class="hljs-built_in">str</span>, value: Any</span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        <span class="hljs-built_in">setattr</span>(flask_g, key, value)<br><br><br>g: CustomerGType = CustomerGType()<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ContextMiddleware</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;基于flask的before_request和after_request钩子创建的一个中间件类&quot;&quot;&quot;</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">        self, *, app: APP_TYPE, book_grpc_service: BookGrpcService, user_grpc_service: UserGrpcService</span></span><br><span class="hljs-function"><span class="hljs-params">    </span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        self._app = app<br>        self._app.before_request(self._before_requests)<br>        self._app.after_request(self._after_requests)<br><br>        self._book_grpc_service: BookGrpcService = book_grpc_service<br>        self._user_grpc_service: UserGrpcService = user_grpc_service<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_before_requests</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        <span class="hljs-comment"># 收到请求点时候把gRPC服务传到指定的变量中</span><br>        g.book_grpc_service = self._book_grpc_service<br>        g.user_grpc_service = self._user_grpc_service<br>        <span class="hljs-keyword">return</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_after_requests</span>(<span class="hljs-params">self, response: Response</span>) -&gt; Response:</span><br>        <span class="hljs-keyword">return</span> response<br></code></pre></td></tr></table></figure>
<p>中间件创建完成后，就可以在<code>create_app</code>工厂函数中创建对应的<code>gRPC</code>服务，然后赋值到对应的中间件中:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">from</span> flask.app <span class="hljs-keyword">import</span> Flask<br><br><span class="hljs-keyword">from</span> app_service.route <span class="hljs-keyword">import</span> manager_book_bp, social_book_bp, user_bp<br><span class="hljs-keyword">from</span> app_service.utils <span class="hljs-keyword">import</span> ContextMiddleware, api_exception<br><span class="hljs-keyword">from</span> grpc_service.book_service <span class="hljs-keyword">import</span> BookGrpcService<br><span class="hljs-keyword">from</span> grpc_service.user_service <span class="hljs-keyword">import</span> UserGrpcService<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">create_app</span>() -&gt; Flask:</span><br>    app: Flask = Flask(__name__)<br>    <span class="hljs-comment"># 注册对应的路由</span><br>    app.register_blueprint(manager_book_bp)<br>    app.register_blueprint(social_book_bp)<br>    app.register_blueprint(user_bp)<br><br>    <span class="hljs-comment"># 初始化对应的gRPC服务，并等待建立连接</span><br>    book_grpc_service: BookGrpcService = BookGrpcService(<span class="hljs-string">&quot;0.0.0.0&quot;</span>, <span class="hljs-number">9000</span>)<br>    book_grpc_service.channel_ready_future(timeout=<span class="hljs-number">3</span>)<br>    user_grpc_service: UserGrpcService = UserGrpcService(<span class="hljs-string">&quot;0.0.0.0&quot;</span>, <span class="hljs-number">9001</span>)<br>    user_grpc_service.channel_ready_future(timeout=<span class="hljs-number">3</span>)<br>    <span class="hljs-comment"># 把gRPC服务注入到中间件中</span><br>    ContextMiddleware(app=app, book_grpc_service=book_grpc_service, user_grpc_service=user_grpc_service)<br><br>    app.errorhandler(Exception)(api_exception)<br>    <span class="hljs-keyword">return</span> app<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    create_app().run(<span class="hljs-string">&quot;localhost&quot;</span>, port=<span class="hljs-number">8000</span>)<br><br></code></pre></td></tr></table></figure>
<p>最后，就可以在路由函数中使用对应的<code>gRPC</code>服务了，还是以创建用户和删除用户为例子:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Response, request<br><span class="hljs-keyword">from</span> grpc_example_common.protos.user <span class="hljs-keyword">import</span> user_pb2 <span class="hljs-keyword">as</span> user_message<br><br><span class="hljs-keyword">from</span> app_service.utils <span class="hljs-keyword">import</span> g, get_uid_by_token, make_response<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">create_user</span>() -&gt; Response:</span><br>    request_dict: <span class="hljs-built_in">dict</span> = request.json()<br>    g.user_grpc_service.create_user(<br>        uid=request_dict[<span class="hljs-string">&quot;uid&quot;</span>], user_name=request_dict[<span class="hljs-string">&quot;user_name&quot;</span>], password=request_dict[<span class="hljs-string">&quot;password&quot;</span>]<br>    )<br>    <span class="hljs-keyword">return</span> make_response()<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">delete_user</span>() -&gt; Response:</span><br>    request_dict: <span class="hljs-built_in">dict</span> = request.json()<br>    g.user_grpc_service.delete_user(uid=request_dict[<span class="hljs-string">&quot;uid&quot;</span>])<br>    <span class="hljs-keyword">return</span> make_response()<br></code></pre></td></tr></table></figure>
<p>这两个接口都是在收到请求后，再调用<code>gRPC</code>服务对应的方法来传递请求，其它服务调用的代码与创建用户和删除用户的例子相同，具体可以访问<a href="https://github.com/so1n/grpc-example-api-backend-service/tree/part-1/app_service">app_service</a>了解</p>
<p>需要注意的是，通常我们不会在生产环境直接运行<code>Flask</code>，而是采用<code>gunicorn</code>+<code>gevnet</code>来运行我们的API服务，从而增强服务的稳定性和性能，但是<code>gevent</code>是修改<code>Python</code>代码来达到全局代码都不阻塞的，而<code>gRPC</code>本身的调用是包含C代码，<code>gevent</code>无法修改到<code>gRPC</code>调用到的C代码，所以<code>gRPC</code>提供一个名为<code>grpc.experimental.gevent.init_gevent</code>的方法来解决这个问题，如下代码:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> socket<br><br><span class="hljs-keyword">try</span>:<br>    <span class="hljs-keyword">import</span> gevent<br><span class="hljs-keyword">except</span> ImportError:<br>    <span class="hljs-keyword">pass</span><br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-keyword">if</span> socket.socket <span class="hljs-keyword">is</span> gevent.socket.socket:<br>        <span class="hljs-keyword">import</span> grpc.experimental.gevent<br><br>        grpc.experimental.gevent.init_gevent()<br></code></pre></td></tr></table></figure>
<p>这段代码在初始化时可以通过判断是否启用<code>gevnet</code>来启用<code>grpc.experimental.gevent.init_gevent</code>，通常建议放在gunicorn的配置文件里，具体见<a href="https://github.com/so1n/grpc-example-api-backend-service/blob/part-1/gunicorn.conf.py">gunicorn.conf.py</a></p>
<p>至此，一个API服务就搭建完毕，可以直接运行后在浏览器进行测试。</p>
<h2 id="5-测试编写的API服务"><a href="#5-测试编写的API服务" class="headerlink" title="5.测试编写的API服务"></a>5.测试编写的API服务</h2><p>截止到目前，对于包含gRPC的API服务接口测试没有一个比较好的方法，因为单例测试是不考虑别的服务的，意味着需要对gRPC调用段响应进行Mock，然而用于调用段<code>Stub</code>类只有属性而没有方法，这样会导致mock不成功，所以需要先创建一个gRPC Stub的函数签名，以<code>UserStub</code>为例子，将会创建一个类似于gRPC UserStub的类：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> Any<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserStub</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, channel: Any</span>):</span><br>        <span class="hljs-keyword">pass</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_uid_by_token</span>(<span class="hljs-params">self, *args: Any, **kwargs: Any</span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        <span class="hljs-keyword">pass</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">logout_user</span>(<span class="hljs-params">self, *args: Any, **kwargs: Any</span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        <span class="hljs-keyword">pass</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">login_user</span>(<span class="hljs-params">self, *args: Any, **kwargs: Any</span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        <span class="hljs-keyword">pass</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">create_user</span>(<span class="hljs-params">self, *args: Any, **kwargs: Any</span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        <span class="hljs-keyword">pass</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">delete_user</span>(<span class="hljs-params">self, *args: Any, **kwargs: Any</span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>其它的见:<a href="https://github.com/so1n/grpc-example-api-backend-service/blob/part-1/tests/grpc_abc_stub.py">tests/grpc_abc_stub.py</a></p>
</blockquote>
<p>然后在<a href="https://github.com/so1n/grpc-example-api-backend-service/blob/part-1/tests/conftest.py">tests/conftest.py</a>编写一个全局的初始化，该初始化会把gRPC的检查连接方法屏蔽以及把对应的Stub类进行替换：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> pytest<br><span class="hljs-keyword">from</span> grpc <span class="hljs-keyword">import</span> _utilities<br><span class="hljs-keyword">from</span> grpc_example_common.protos.book <span class="hljs-keyword">import</span> manager_pb2_grpc, social_pb2_grpc<br><span class="hljs-keyword">from</span> grpc_example_common.protos.user <span class="hljs-keyword">import</span> user_pb2_grpc<br><br><span class="hljs-keyword">from</span> tests.grpc_abc_stub <span class="hljs-keyword">import</span> BookManagerStub, BookSocialStub, UserStub<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">result</span>(<span class="hljs-params">self: Any, timeout: Any = <span class="hljs-literal">None</span></span>) -&gt; Any:</span><br>    <span class="hljs-keyword">pass</span><br><br><br><span class="hljs-comment"># Blocking the start check of grpc service</span><br>_utilities._ChannelReadyFuture.result = result<br><br>user_pb2_grpc.UserStub = UserStub<br>user_pb2_grpc.UserStub = UserStub<br>social_pb2_grpc.BookSocialStub = BookSocialStub<br>manager_pb2_grpc.BookManagerStub = BookManagerStub<br></code></pre></td></tr></table></figure>
<p>这样就为测试用例初始化完成了， 但是我为每个Stub包装了一个功能，使他们永远会传递<code>metadata</code>变量：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserGrpcServiceMixin</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, channel: grpc.Channel</span>):</span><br>        self.user_stub: user_service.UserStub = user_service.UserStub(channel)<br>        grpc_wrapper.auto_load_wrapper_by_stub(self.user_stub, grpc_wrapper.grpc_client_func_wrapper)<br></code></pre></td></tr></table></figure>
<p>该方法会初始化一定要放在mock之后，否则mock无效，这意味着初始化<code>Flask.TestClient</code>的逻辑必须在测试代码里，于是先创建一个类似于<code>pytest.fixture</code>的初始化<code>Flask.TestClient</code>函数:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-meta">@contextmanager</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">customer_app</span>() -&gt; Generator[FlaskClient, <span class="hljs-keyword">None</span>, <span class="hljs-keyword">None</span>]:</span><br>    flask_app: Flask = create_app()<br>    <span class="hljs-comment"># Flask provides a way to test your application by exposing the Werkzeug test Client</span><br>    <span class="hljs-comment"># and handling the context locals for you.</span><br>    client: FlaskClient = flask_app.test_client()<br>    <span class="hljs-comment"># Establish an application context before running the tests.</span><br>    ctx: AppContext = flask_app.app_context()<br>    ctx.push()<br>    <span class="hljs-keyword">yield</span> client  <span class="hljs-comment"># this is where the testing happens!</span><br>    ctx.pop()<br></code></pre></td></tr></table></figure>
<p>为了偷懒，我把他放到了<code>conftest</code>文件。</p>
<blockquote>
<p>如果没有包装过stub的方法，则可以不用采用该步骤</p>
</blockquote>
<p>现在，所有初始化都编写完毕了，可以编写测试用例，以用户调用路由为例子(说明见注释):</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">from</span> google.protobuf.empty_pb2 <span class="hljs-keyword">import</span> Empty  <span class="hljs-comment"># type: ignore</span><br><span class="hljs-keyword">from</span> grpc_example_common.protos.user <span class="hljs-keyword">import</span> user_pb2 <span class="hljs-keyword">as</span> user_message<br><span class="hljs-keyword">from</span> pytest_mock <span class="hljs-keyword">import</span> MockFixture<br><span class="hljs-keyword">from</span> werkzeug.test <span class="hljs-keyword">import</span> TestResponse<br><br><span class="hljs-keyword">from</span> tests.conftest <span class="hljs-keyword">import</span> customer_app<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestUser</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_create_user</span>(<span class="hljs-params">self, mocker: MockFixture</span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        <span class="hljs-comment"># 该接口会调用到UserStub.create_user，我们把他mock掉，返回的是Empty</span><br>        mocker.patch(<span class="hljs-string">&quot;grpc_example_common.protos.user.user_pb2_grpc.UserStub.create_user&quot;</span>).return_value = Empty()<br>        <span class="hljs-keyword">with</span> customer_app() <span class="hljs-keyword">as</span> client:<br>            resp: TestResponse = client.post(<br>                <span class="hljs-string">&quot;/api/user/create&quot;</span>, json=&#123;<span class="hljs-string">&quot;uid&quot;</span>: <span class="hljs-string">&quot;123&quot;</span>, <span class="hljs-string">&quot;user_name&quot;</span>: <span class="hljs-string">&quot;so1n&quot;</span>, <span class="hljs-string">&quot;password&quot;</span>: <span class="hljs-string">&quot;aha&quot;</span>&#125;<br>            )<br>            <span class="hljs-keyword">assert</span> resp.json[<span class="hljs-string">&quot;code&quot;</span>] == <span class="hljs-number">0</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_delete_user</span>(<span class="hljs-params">self, mocker: MockFixture</span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        <span class="hljs-comment"># 该接口会调用到UserStub.delete_user，我们把他mock掉，返回的是Empty</span><br>        mocker.patch(<span class="hljs-string">&quot;grpc_example_common.protos.user.user_pb2_grpc.UserStub.delete_user&quot;</span>).return_value = Empty()<br>        <span class="hljs-keyword">with</span> customer_app() <span class="hljs-keyword">as</span> client:<br>            resp: TestResponse = client.post(<span class="hljs-string">&quot;/api/user/delete&quot;</span>, json=&#123;<span class="hljs-string">&quot;uid&quot;</span>: <span class="hljs-string">&quot;123&quot;</span>&#125;)<br>            <span class="hljs-keyword">assert</span> resp.json[<span class="hljs-string">&quot;code&quot;</span>] == <span class="hljs-number">0</span><br>        <span class="hljs-comment"># User.Stub.delete_user还有一个会抛错的方法,我们通过mock满足这个条件</span><br>        mocker.patch(<span class="hljs-string">&quot;grpc_example_common.protos.user.user_pb2_grpc.UserStub.delete_user&quot;</span>).side_effect = RuntimeError(<br>            <span class="hljs-string">&quot;test error&quot;</span><br>        )<br>        <span class="hljs-keyword">with</span> customer_app() <span class="hljs-keyword">as</span> client:<br>            resp = client.post(<span class="hljs-string">&quot;/api/user/delete&quot;</span>, json=&#123;<span class="hljs-string">&quot;uid&quot;</span>: <span class="hljs-string">&quot;123&quot;</span>&#125;)<br>            <span class="hljs-keyword">assert</span> resp.json[<span class="hljs-string">&quot;data&quot;</span>] == <span class="hljs-string">&quot;test error&quot;</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_login_user</span>(<span class="hljs-params">self, mocker: MockFixture</span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        <span class="hljs-comment"># 通过mock指定具体的返回数据，返回的数据类型一定要跟Protobuf生成的代码一致</span><br>        mocker.patch(<br>            <span class="hljs-string">&quot;grpc_example_common.protos.user.user_pb2_grpc.UserStub.login_user&quot;</span><br>        ).return_value = user_message.LoginUserResult(uid=<span class="hljs-string">&quot;123&quot;</span>, token=<span class="hljs-string">&quot;66666&quot;</span>)<br>        <span class="hljs-keyword">with</span> customer_app() <span class="hljs-keyword">as</span> client:<br>            resp: TestResponse = client.post(<span class="hljs-string">&quot;/api/user/login&quot;</span>, json=&#123;<span class="hljs-string">&quot;uid&quot;</span>: <span class="hljs-string">&quot;123&quot;</span>, <span class="hljs-string">&quot;password&quot;</span>: <span class="hljs-string">&quot;pw&quot;</span>&#125;)<br>            <span class="hljs-keyword">assert</span> resp.json[<span class="hljs-string">&quot;data&quot;</span>] == &#123;<span class="hljs-string">&quot;uid&quot;</span>: <span class="hljs-string">&quot;123&quot;</span>, <span class="hljs-string">&quot;token&quot;</span>: <span class="hljs-string">&quot;66666&quot;</span>&#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_logout</span>(<span class="hljs-params">self, mocker: MockFixture</span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        mocker.patch(<span class="hljs-string">&quot;grpc_example_common.protos.user.user_pb2_grpc.UserStub.logout_user&quot;</span>).return_value = Empty()<br>        mocker.patch(<br>            <span class="hljs-string">&quot;grpc_example_common.protos.user.user_pb2_grpc.UserStub.get_uid_by_token&quot;</span><br>        ).return_value = user_message.GetUidByTokenResult(uid=<span class="hljs-string">&quot;123&quot;</span>)<br>        <span class="hljs-keyword">with</span> customer_app() <span class="hljs-keyword">as</span> client:<br>            resp: TestResponse = client.post(<span class="hljs-string">&quot;/api/user/logout&quot;</span>, json=&#123;<span class="hljs-string">&quot;uid&quot;</span>: <span class="hljs-string">&quot;123&quot;</span>&#125;, headers=&#123;<span class="hljs-string">&quot;token&quot;</span>: <span class="hljs-string">&quot;666666&quot;</span>&#125;)<br>            <span class="hljs-keyword">assert</span> resp.json[<span class="hljs-string">&quot;code&quot;</span>] == <span class="hljs-number">0</span><br><br>        mocker.patch(<br>            <span class="hljs-string">&quot;grpc_example_common.protos.user.user_pb2_grpc.UserStub.get_uid_by_token&quot;</span><br>        ).return_value = user_message.GetUidByTokenResult(uid=<span class="hljs-string">&quot;1234&quot;</span>)<br>        <span class="hljs-keyword">with</span> customer_app() <span class="hljs-keyword">as</span> client:<br>            resp = client.post(<span class="hljs-string">&quot;/api/user/logout&quot;</span>, json=&#123;<span class="hljs-string">&quot;uid&quot;</span>: <span class="hljs-string">&quot;123&quot;</span>&#125;, headers=&#123;<span class="hljs-string">&quot;token&quot;</span>: <span class="hljs-string">&quot;666666&quot;</span>&#125;)<br>            <span class="hljs-keyword">assert</span> resp.json[<span class="hljs-string">&quot;data&quot;</span>] == <span class="hljs-string">&quot;Uid ERROR&quot;</span><br></code></pre></td></tr></table></figure>
<p>至此，已经实现了一个可以简单使用的gRPC服务，可以在电脑上起不同的进程并观察他们的调用情况，但是这只是一个开始，随着服务的扩大，服务间的维护和调优会变得十分麻烦，要想服务能够健壮的运行，我们需要继续深入。</p>
]]></content>
      <categories>
        <category>Python-gRPC实践</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>gRPC</tag>
      </tags>
  </entry>
  <entry>
    <title>在Python运行时修改业务代码的SQL</title>
    <url>/2022/03/11/modify-sql-in-python-runtime/</url>
    <content><![CDATA[<h2 id="前记"><a href="#前记" class="headerlink" title="前记"></a>前记</h2><p>在项目的演变过程中，有时可能会诞生一些需要奇怪的临时需求，这些需求会涉及到所有的SQL，但开发时间上却不允许整个项目的所有SQL进行重写，比如控制不同的人访问表的权限，或者是我面对的SASS化需求，这时就需要在运行时根据对应的条件来修改SQL语句。</p>
<span id="more"></span>
<h2 id="1-缘起"><a href="#1-缘起" class="headerlink" title="1.缘起"></a>1.缘起</h2><p>最近项目在准备搞SASS化，SASS化有一个特点就是多租户，且每个租户之间的数据都要隔离，对于数据库的隔离方案常见的有数据库隔离，表隔离，字段隔离，目前我只用到表隔离和字段隔离（数据库隔离的原理也是差不多）。<br>对于字段隔离比较简单，就是查询条件不同而已，比如像下面的SQL查询：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t_demo <span class="hljs-keyword">WHERE</span> tenant_id<span class="hljs-operator">=</span><span class="hljs-string">&#x27;xxx&#x27;</span> <span class="hljs-keyword">AND</span> is_del<span class="hljs-operator">=</span><span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>
<p>但是为了严谨，需求上需要在执行SQL之前检查对应的表是否带上<code>tenant_id</code>的查询字段。</p>
<p>对于表隔离就麻烦了一些，他需要做到在运行的时候根据对应的租户ID来处理某个数据表，举个例子，假如有下面这样的一条SQL查询:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t_demo <span class="hljs-keyword">WHERE</span> is_del<span class="hljs-operator">=</span><span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>
<p>在遇到租户A时，SQL查询将变为：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t_demo_a <span class="hljs-keyword">WHERE</span> is_del<span class="hljs-operator">=</span><span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>
<p>在遇到租户B时，SQL查询将变为：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t_demo_b <span class="hljs-keyword">WHERE</span> is_del<span class="hljs-operator">=</span><span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>
<p>如果商户数量固定时，一般在代码里编写<code>if-else</code>来判断就可以了，但是常见的SASS化应用的商户是会一直新增的，那么对于这个SQL逻辑就会变成这样:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sql_handle</span>(<span class="hljs-params">tenant_id: <span class="hljs-built_in">str</span></span>):</span><br>    table_name: <span class="hljs-built_in">str</span> = <span class="hljs-string">f&quot;t_demo_<span class="hljs-subst">&#123;tenant_id&#125;</span>&quot;</span><br>    sql: <span class="hljs-built_in">str</span> = <span class="hljs-string">f&quot;SELECT * FROM <span class="hljs-subst">&#123;table_name&#125;</span> WHERE is_del=0&quot;</span><br></code></pre></td></tr></table></figure>
<p>但是这有几个问题，对于ORM来说，一开始只创建一个<code>t_demo</code>对应的表对象就可以了，现在却要根据多个商户创建多个表对象，这是不现实的，其次如果是裸写SQL，一般会使用IDE的检查，而对于这样的SQL：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python">sql: <span class="hljs-built_in">str</span> = <span class="hljs-string">f&quot;SELECT * FROM <span class="hljs-subst">&#123;table_name&#125;</span> WHERE is_del=0&quot;</span><br></code></pre></td></tr></table></figure>
<p>IDE是没办法进行检查的，当然还有一个最为严重的问题，就是当前的项目已经非常庞大了，如果每个相关表的调用都进行适配更改的话，那工程量就非常庞大了，所以最好的方案就是在引擎库得到用户传过来的SQL语句后且还没发送到<code>MySQL</code>服务器之前自动的根据商户ID更改SQL, 而要达到这样的效果，就必须侵入到我们使用的<code>MySQL</code>的引擎库，修改里面的方法来兼容我们的需求。</p>
<blockquote>
<p>不管是使用<code>dbutils</code>还是<code>sqlalchemy</code>，都可以指定一个引擎库，目前常用的引擎库是<code>pymysql</code>，所以下文都将以<code>pymysql</code>为例进行阐述。</p>
</blockquote>
<h2 id="2-侵入库"><a href="#2-侵入库" class="headerlink" title="2.侵入库"></a>2.侵入库</h2><p>由于必须侵入到我们使用的引擎库，所以我们应该先判断我们需要修改引擎库的哪个方法，在经过源码阅读后，我判定只要更改<code>pymysql.cursors.Cursor</code>的<code>mogrify</code>方法:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">mogrify</span>(<span class="hljs-params">self, query, args=<span class="hljs-literal">None</span></span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    Returns the exact string that is sent to the database by calling the</span><br><span class="hljs-string">    execute() method.</span><br><span class="hljs-string"></span><br><span class="hljs-string">    This method follows the extension to the DB API 2.0 followed by Psycopg.</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    conn = self._get_db()<br><br>    <span class="hljs-keyword">if</span> args <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>        query = query % self._escape_args(args, conn)<br><br>    <span class="hljs-keyword">return</span> query<br></code></pre></td></tr></table></figure>
<p>这个方法的作用就是把用户传过来的SQL和参数进行整合，生成一个最终的SQL,刚好符合我们的需求，于是可以通过继承的思路来创建一个新的属于我们自己的<code>Cursor</code>类：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> pymysql<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cursor</span>(<span class="hljs-params">pymysql.cursors.Cursor</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">mogrify</span>(<span class="hljs-params">self, query: <span class="hljs-built_in">str</span>, args: Union[<span class="hljs-literal">None</span>, <span class="hljs-built_in">list</span>, <span class="hljs-built_in">dict</span>, <span class="hljs-built_in">tuple</span>] = <span class="hljs-literal">None</span></span>) -&gt; str:</span><br>        <span class="hljs-comment"># 在此可以编写处理还合成的SQL逻辑</span><br>        mogrify_sql: <span class="hljs-built_in">str</span> = <span class="hljs-built_in">super</span>().mogrify(query, args)<br>        <span class="hljs-comment"># 在此可以编写处理合成后的SQL逻辑</span><br>        <span class="hljs-keyword">return</span> mogrify_sql<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DictCursor</span>(<span class="hljs-params">pymysql.cursors.DictCursorMixin, Cursor</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;A cursor which returns results as a dictionary&quot;&quot;&quot;</span><br>    <span class="hljs-comment"># 直接修改Cursor类的`mogrify`方法并不会影响到`DictCursor`类，所以我们也要创建一个新的`Cursor`类。</span><br></code></pre></td></tr></table></figure>
<p>创建好了<code>Cursor</code>类后，就需要考虑如何在<code>pymysql</code>中应用我们自定义的<code>Cursor</code>类了，一般的<code>Mysql</code>连接库都支持我们传入自定义的<code>Cursor</code>类，比如<code>pymysql</code>:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> pymysql.cursors<br><br><span class="hljs-comment"># Connect to the database</span><br>connection = pymysql.connect(<br>    host=<span class="hljs-string">&#x27;localhost&#x27;</span>,<br>    user=<span class="hljs-string">&#x27;user&#x27;</span>,<br>    password=<span class="hljs-string">&#x27;passwd&#x27;</span>,<br>    database=<span class="hljs-string">&#x27;db&#x27;</span>,<br>    charset=<span class="hljs-string">&#x27;utf8mb4&#x27;</span>,<br>    cursorclass=pymysql.cursors.DictCursor<br>)<br></code></pre></td></tr></table></figure>
<p>我们可以通过<code>cursorclass</code>来指定我们的<code>Cursor</code>类,如果使用的库不支持或者是其它原因则需要使用猴子补丁的方法，具体的使用方法见<a href="https://so1n.me/2020/11/18/%E5%9F%BA%E4%BA%8EPython%E6%8E%A2%E9%92%88%E5%AE%8C%E6%88%90%E8%B0%83%E7%94%A8%E5%BA%93%E7%9A%84%E6%95%B0%E6%8D%AE%E6%8F%90%E5%8F%96/">基于Python探针完成调用库的数据提取</a>。</p>
<h2 id="3-获取商户ID"><a href="#3-获取商户ID" class="headerlink" title="3.获取商户ID"></a>3.获取商户ID</h2><p>现在我们已经搞定了在何处修改SQL的问题了，接下来就要思考如何在<code>mogrify</code>方法获取到商户ID以及那些表要进行替换，一般我们在进行一段代码调用时，有两种传参数的方法， 一种是传数组类型的参数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">with</span> conn.cursor() <span class="hljs-keyword">as</span> cursor:<br>    cursor.execute(<span class="hljs-string">&quot;SELECT * FROM t_demo WHERE is_del=%s&quot;</span>, (<span class="hljs-number">0</span>, ))<br></code></pre></td></tr></table></figure>
<p>一种是传字典类型的参数:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">with</span> conn.cursor() <span class="hljs-keyword">as</span> cursor:<br>    cursor.execute(<span class="hljs-string">&quot;SELECT * FROM t_demo WHERE is_del=%(is_del)s&quot;</span>, &#123;<span class="hljs-string">&quot;is_del&quot;</span>: <span class="hljs-number">0</span>&#125;)<br></code></pre></td></tr></table></figure>
<p>目前大多数的项目都存在这两种类型的编写习惯，而引擎库在执行<code>execute</code>时会经过处理后才把参数<code>sql</code>和<code>args</code>传给了<code>mogrify</code>，如果我们是使用字典类型的参数，那么可以在里面嵌入我们需要的参数，并在<code>mogrify</code>里面提取出来，但是使用了数组类型的参数或者是ORM库的话就比较难传递参数给<code>mogrify</code>方法了，这时可以通过<code>context</code>隐式的把参数传给<code>mogrify</code>方法，具体的分析和原理可见:<a href="https://so1n.me/2019/06/13/contextvars%E6%A8%A1%E5%9D%97/#3-%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E4%BD%BF%E7%94%A8contextvars">如何使用contextvars模块和源码分析</a>。</p>
<p><code>context</code>的使用方法很简单， 首先是创建一个<code>context</code>封装的类:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">from</span> contextvars <span class="hljs-keyword">import</span> ContextVar, Token<br><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> Any, Dict, Optional, Set<br><br>context: ContextVar[Dict[<span class="hljs-built_in">str</span>, Any]] = ContextVar(<span class="hljs-string">&quot;context&quot;</span>, default=&#123;&#125;)<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Context</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;基础的context调用，支持Type Hints检查&quot;&quot;&quot;</span><br>    tenant_id: <span class="hljs-built_in">str</span><br>    replace_table_set: Set[<span class="hljs-built_in">str</span>]<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__getattr__</span>(<span class="hljs-params">self, key: <span class="hljs-built_in">str</span></span>) -&gt; Any:</span><br>        value: Any = context.get().get(key)<br>        <span class="hljs-keyword">return</span> value<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__setattr__</span>(<span class="hljs-params">self, key: <span class="hljs-built_in">str</span>, value: Any</span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        context.get()[key] = value<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WithContext</span>(<span class="hljs-params">Context</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;简单的处理reset token逻辑，和context管理，只用在业务代码&quot;&quot;&quot;</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        self._token: Optional[Token] = <span class="hljs-literal">None</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__enter__</span>(<span class="hljs-params">self</span>) -&gt; &quot;WithContext&quot;:</span><br>        self._token = context.<span class="hljs-built_in">set</span>(&#123;&#125;)<br>        <span class="hljs-keyword">return</span> self<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__exit__</span>(<span class="hljs-params">self, exc_type: Any, exc_val: Any, exc_tb: Any</span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        <span class="hljs-keyword">if</span> self._token:<br>            context.reset(self._token)<br>            self._token = <span class="hljs-literal">None</span><br></code></pre></td></tr></table></figure>
<p>接下来在业务代码中，通过context传入当前业务对应的参数:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">with</span> WithContext <span class="hljs-keyword">as</span> context:<br>    context.tenant_id = <span class="hljs-string">&quot;xxx&quot;</span><br>    context.replace_table_set = &#123;<span class="hljs-string">&quot;t_demo&quot;</span>&#125;<br>    <span class="hljs-keyword">with</span> conn.cursor() <span class="hljs-keyword">as</span> cursor:<br>        cursor.execute(<span class="hljs-string">&quot;SELECT * FROM t_demo WHERE is_del=%s&quot;</span>, (<span class="hljs-number">0</span>, ))<br></code></pre></td></tr></table></figure>
<p>然后在<code>mogrify</code>中通过调用<code>context</code>即可获得对应的参数了：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> pymysql<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cursor</span>(<span class="hljs-params">pymysql.cursors.Cursor</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">mogrify</span>(<span class="hljs-params">self, query: <span class="hljs-built_in">str</span>, args: Union[<span class="hljs-literal">None</span>, <span class="hljs-built_in">list</span>, <span class="hljs-built_in">dict</span>, <span class="hljs-built_in">tuple</span>] = <span class="hljs-literal">None</span></span>) -&gt; str:</span><br>        tenant_id: <span class="hljs-built_in">str</span> = context.tenant_id<br>        replace_table_set: Set[<span class="hljs-built_in">str</span>] = context.replace_table_set<br>        <span class="hljs-comment"># 在此可以编写处理还合成的SQL逻辑</span><br>        mogrify_sql: <span class="hljs-built_in">str</span> = <span class="hljs-built_in">super</span>().mogrify(query, args)<br>        <span class="hljs-comment"># 在此可以编写处理合成后的SQL逻辑</span><br>        <span class="hljs-keyword">return</span> mogrify_sql<br></code></pre></td></tr></table></figure>
<h2 id="4-修改SQL"><a href="#4-修改SQL" class="headerlink" title="4.修改SQL"></a>4.修改SQL</h2><p>现在，万事俱备，只剩下修改SQL的逻辑，之前在做别的项目的时候，建的表都是十分的规范，它们是以<code>t_xxx</code>的格式给表命名，这样一来替换表名十分方便，只要进行两次替换就可以兼容大多数情况了，代码如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> pymysql<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cursor</span>(<span class="hljs-params">pymysql.cursors.Cursor</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">mogrify</span>(<span class="hljs-params">self, query: <span class="hljs-built_in">str</span>, args: Union[<span class="hljs-literal">None</span>, <span class="hljs-built_in">list</span>, <span class="hljs-built_in">dict</span>, <span class="hljs-built_in">tuple</span>] = <span class="hljs-literal">None</span></span>) -&gt; str:</span><br>        tenant_id: <span class="hljs-built_in">str</span> = context.tenant_id<br>        replace_table_set: Set[<span class="hljs-built_in">str</span>] = context.replace_table_set<br>        <span class="hljs-comment"># 简单示例，实际上正则的效率会更好</span><br>        <span class="hljs-keyword">for</span> replace_table <span class="hljs-keyword">in</span> replace_table_set:<br>            <span class="hljs-keyword">if</span> replace_table <span class="hljs-keyword">in</span> query:<br>                <span class="hljs-comment"># 替换表名</span><br>                query = query.replace(<span class="hljs-string">f&quot; <span class="hljs-subst">&#123;replace_table&#125;</span> &quot;</span>, <span class="hljs-string">f&quot; <span class="hljs-subst">&#123;replace_table&#125;</span>_<span class="hljs-subst">&#123;tenant_id&#125;</span> &quot;</span>)<br>                <span class="hljs-comment"># 替换查询条件中带有表名的</span><br>                query = query.replace(<span class="hljs-string">f&quot; <span class="hljs-subst">&#123;replace_table&#125;</span>.&quot;</span>, <span class="hljs-string">f&quot; <span class="hljs-subst">&#123;replace_table&#125;</span>_<span class="hljs-subst">&#123;tenant_id&#125;</span>.&quot;</span>)<br>        mogrify_sql: <span class="hljs-built_in">str</span> = <span class="hljs-built_in">super</span>().mogrify(query, args)<br>        <span class="hljs-comment"># 在此可以编写处理合成后的SQL逻辑</span><br>        <span class="hljs-keyword">return</span> mogrify_sql<br></code></pre></td></tr></table></figure>
<p>但是现在项目的SQL规范并不是很好，有些表名还是<code>MySQL</code>的关键字，所以靠简单的替换是行不通的，同时这个需求中，一些表只需要字段隔离，需要确保有带上对应的字段查询，这就意味着必须有一个库可以来解析<code>SQL</code>，并返回一些数据使我们可以比较方便的知道<code>SQL</code>中哪些是表名，哪些是查询字段了。</p>
<p>目前在Python中有一个比较知名的<code>SQL</code>解析库–<a href="https://github.com/andialbrecht/sqlparse">sqlparse</a>，它可以通过解析引擎把SQL解析成一个<code>Python对象</code>,之后我们就可以通过一些语法来判断哪些是<code>SQL</code>关键字， 哪些是表名，哪些是查询条件等等。但是这个库只实现一些底层的API，我们需要对他和SQL比较了解之后才能实现一些比较完备的功能，比如下面3种常见的SQL:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t_demo<br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t_demo <span class="hljs-keyword">as</span> demo<br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t_other <span class="hljs-keyword">as</span> other <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> t_demo demo <span class="hljs-keyword">on</span> demo.xxx<span class="hljs-operator">=</span><span class="hljs-operator">=</span>other.xxx<br></code></pre></td></tr></table></figure>
<p>如果我们要通过<code>sqlparse</code>来提取表名的话就需要处理这3种情况，而我们如果要每一个情况都编写出来的话，那将会非常费心费力，同时也可能存在遗漏的情况，这时就需要用到另外一个库–<a href="https://github.com/macbre/sql-metadata">sql_metadata</a>，这个库是基于<code>sqlparse</code>和正则的解析库，同时提供了大量的常见使用方法的封装，我们通过直接调用对应的函数就能知道<code>SQL</code>中有哪些表名，查询字段是什么了。</p>
<blockquote>
<p>目前已知这个库有一个缺陷，就是会自动去掉字段的符号， 比如表名为关键字时，我们需要使用`符号把它包起来：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> `<span class="hljs-keyword">case</span>`<br></code></pre></td></tr></table></figure>
<p>但在经过<code>sql_metadata</code>解析后得到的表名是<code>case</code>而不是`case`，需要人为的处理，但是我并不觉得这是一个BUG，自己不按规范创建表，能怪谁呢。</p>
</blockquote>
<p>接下来就可以通过<code>sql_metadata</code>的方法来实现我需要的功能了，在根据需求修改后，代码长这样(说明见注释)：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> Dict, Set, Tuple, Union<br><span class="hljs-keyword">import</span> pymysql<br><span class="hljs-keyword">import</span> sql_metadata<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cursor</span>(<span class="hljs-params">pymysql.cursors.Cursor</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">mogrify</span>(<span class="hljs-params">self, query: <span class="hljs-built_in">str</span>, args: Union[<span class="hljs-literal">None</span>, <span class="hljs-built_in">list</span>, <span class="hljs-built_in">dict</span>, <span class="hljs-built_in">tuple</span>] = <span class="hljs-literal">None</span></span>) -&gt; str:</span><br>        tenant_id: <span class="hljs-built_in">str</span> = context.tenant_id<br>        <span class="hljs-comment"># 生成一个解析完成的SQL对象</span><br>        sql_parse: sql_metadata.Parser = sql_metadata.Parser(query)<br><br>        <span class="hljs-comment"># 新加的一个属性，这里存下需要校验查询条件的表名</span><br>        check_flag = <span class="hljs-literal">False</span> <br>        where_table_set: Set[<span class="hljs-built_in">str</span>] = context.where_table_set<br>        <span class="hljs-comment"># 该方法会获取到SQL对应的table，返回的是一个table的数组</span><br>        <span class="hljs-keyword">for</span> table_name <span class="hljs-keyword">in</span> sql_parse.tables:<br>            <span class="hljs-keyword">if</span> table_name <span class="hljs-keyword">in</span> where_table_set:<br>                <span class="hljs-keyword">if</span> sql_parse.columns_dict:<br>                    <span class="hljs-comment"># 该方法会返回SQL对应的字段，其中分为select, join, where等，这里只用到了where</span><br>                    <span class="hljs-keyword">for</span> where_column <span class="hljs-keyword">in</span> sql_parse.columns_dict.get(<span class="hljs-string">&quot;where&quot;</span>, []):<br>                        <span class="hljs-comment"># 如果连表，里面存的是类似于t_demo.tenant_id，所以要兼容这一个情况</span><br>                        <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;tenant_id&quot;</span> <span class="hljs-keyword">in</span> where_column.lower().split(<span class="hljs-string">&quot;.&quot;</span>):<br>                            check_flag = <span class="hljs-literal">True</span><br>                            <span class="hljs-keyword">break</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> check_flag:<br>            <span class="hljs-comment"># 检查不通过就抛错</span><br>            <span class="hljs-keyword">raise</span> RuntimeError()<br><br><br>        <span class="hljs-comment"># 更换表名的逻辑</span><br>        replace_table_set: Set[<span class="hljs-built_in">str</span>] = context.replace_table_set<br>        new_query: <span class="hljs-built_in">str</span> = query<br>        <span class="hljs-keyword">for</span> table_name <span class="hljs-keyword">in</span> sql_parse.tables:<br>            <span class="hljs-keyword">if</span> table_name <span class="hljs-keyword">in</span> replace_table_set:<br>                new_query = <span class="hljs-string">&quot;&quot;</span><br>                <span class="hljs-comment"># tokens存放着解析完的数据，比如SELECT * FROM t_demo解析后是</span><br>                <span class="hljs-comment"># [SELECT, *, FROM, t_demo]四个token</span><br>                <span class="hljs-keyword">for</span> token <span class="hljs-keyword">in</span> sql_parse.tokens:<br>                    <span class="hljs-comment"># 判断token是否是表名  </span><br>                    <span class="hljs-keyword">if</span> token.is_potential_table_name:<br>                        <span class="hljs-comment"># 提取规范的表名</span><br>                        parse_table_name: <span class="hljs-built_in">str</span> = token.stringified_token.strip()<br>                        <span class="hljs-keyword">if</span> parse_table_name <span class="hljs-keyword">in</span> replace_table_set:<br>                            new_table_name: <span class="hljs-built_in">str</span> = <span class="hljs-string">f&quot; <span class="hljs-subst">&#123;parse_table_name&#125;</span>_<span class="hljs-subst">&#123;tenant_id&#125;</span>&quot;</span><br>                            <span class="hljs-comment"># next_token代表SQL的下一个字段</span><br>                            <span class="hljs-keyword">if</span> token.next_token.normalized != <span class="hljs-string">&quot;AS&quot;</span>:<br>                                <span class="hljs-comment"># 如果当前表没有设置别名</span><br>                                <span class="hljs-comment"># 通过AS把替换前的表名设置为新表名的别名，这样一来后面的表名即使没进行更改，也是能读到对应商户ID的表</span><br>                                new_table_name += <span class="hljs-string">f&quot; AS <span class="hljs-subst">&#123;parse_table_name&#125;</span>&quot;</span><br>                            query += new_table_name<br>                            <span class="hljs-keyword">continue</span><br>                    <span class="hljs-comment"># 通过stringified_token获取的数据会自动带空格，比如`FROM`得到的会是` FROM`，这样拼接的时候就不用考虑是否加空格了</span><br>                    new_query += token.stringified_token<br>        <br>        mogrify_sql: <span class="hljs-built_in">str</span> = <span class="hljs-built_in">super</span>().mogrify(new_query, args)<br>        <span class="hljs-comment"># 在此可以编写处理合成后的SQL逻辑</span><br>        <span class="hljs-keyword">return</span> mogrify_sql<br></code></pre></td></tr></table></figure>
<p>这份代码十分简单，它只做简单介绍，事实上这段逻辑会应用到所有的<code>SQL</code>查询中，我们应该要保证这段代码是没问题的，同时不要有太多的性能浪费，所以在使用的时候要考虑到代码拆分和优化。<br>比如在使用的过程中可以发现，我们的<code>SQL</code>转换和检查都是在父类的<code>Cursor.mogrify</code>之前进行的，这就意味着不管我们代码逻辑里<code>cursor.execute</code>传的参数是什么，对于同一个代码逻辑来说，传过来的<code>query</code>值是保持不变的，比如下面的代码:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_user_info</span>(<span class="hljs-params">uid: <span class="hljs-built_in">str</span></span>) -&gt; Dict[str, Any]:</span><br>    <span class="hljs-keyword">with</span> conn.cursor() <span class="hljs-keyword">as</span> cursor:<br>        cursor.execute(<span class="hljs-string">&quot;SELECT * FROM t_user WHERE uid=%(uid)s&quot;</span>, &#123;<span class="hljs-string">&quot;uid&quot;</span>: uid&#125;)<br>        <span class="hljs-keyword">return</span> cursor.fetchone() <span class="hljs-keyword">or</span> &#123;&#125;<br></code></pre></td></tr></table></figure>
<p>这段代码中传到<code>Cursor.mogrify</code>的query永远为<code>SELECT * FROM t_user WHERE uid=%(uid)s</code>，有变化的只是args中uid的不同。<br>有了这样的一个前提条件，那么我们就可以把<code>query</code>的校验结果和转换结果缓存下来，减少每次都需要解析<code>SQL</code>再校验造成的性能浪费。至于如何实现缓存则需要根据自己的项目来决定，比如项目中只有几百个<code>SQL</code>执行，那么直接用<code>Python</code>的<code>dict</code>来存放就可以了，如果项目中执行的<code>SQL</code>很多，同时有些执行的频率非常的高，有些执行的频率非常的低，那么可以考虑使用<code>LRU</code>来缓存。</p>
]]></content>
      <categories>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Pre-Worker服务模型问题的思考</title>
    <url>/2022/03/07/Pre-Worker%E6%9C%8D%E5%8A%A1%E6%A8%A1%E5%9E%8B%E9%97%AE%E9%A2%98%E7%9A%84%E6%80%9D%E8%80%83/</url>
    <content><![CDATA[<h2 id="前记"><a href="#前记" class="headerlink" title="前记"></a>前记</h2><p>目前TCP服务的工作模型有三种，但是开源的服务器基本上都是使用<code>Pre-Worker</code>模型，比如<code>Nginx</code>和<code>Gunicorn</code>。在阅读<code>Gunicorn</code>源码后我对<code>Gunicorn</code>为啥要采用这个模型感兴趣，所以查阅了一番资料并了解常见TCP服务工作模型的优缺点。</p>
<h2 id="1-TCP服务的请求处理模式"><a href="#1-TCP服务的请求处理模式" class="headerlink" title="1.TCP服务的请求处理模式"></a>1.TCP服务的请求处理模式</h2><p>大多数的TCP服务部署都是从单进程开始的，当请求数量逐渐变多后，单进程工作模型的服务就开始扛不住了， 这时就会想通过添加更多的进程来帮忙处理请求，于是就会诞生出另外两种基于多进程的工作模型， 这三种工作模型的特点如下（其中监听可以认为是调用<code>socket.listen</code>，处理可以认为调用<code>socket.accept</code>）：</p>
<ul>
<li><p>1.单个进程监听和处理<code>socket</code>。</p>
<p>  这是最简单的工作模型， 只有单个进程同时监听和执行同一个<code>socket.accpet</code>调用来接受新连接以及处理请求。</p>
</li>
<li><p>2.单个进程监听<code>socket</code>，多个工作进程处理<code>socket</code>（<code>Nginx</code>和<code>Gunicorn</code>的工作模式）。</p>
<p>  这是最常用的工作模式，整个进程组中有且只有一个<code>socket</code>，主进程负责监听<code>socket</code>，工作进程负责执行<code>socket.accept</code>调用来接受新连接和处理请求。（工作进程的负载均衡由系统决定）</p>
</li>
<li><p>3.多个工作进程，每个工作进程都有单独监听和处理的<code>socket</code>。</p>
<p>  每个工作进程都有一个独立的<code>socket</code>，并且通过<code>SO_REUSEPORT</code>标记使这类<code>socket</code>都能监听和处理相同的ip端口的请求。(工作进程的负负载均衡是由每个请求的hash决定)</p>
</li>
</ul>
<p>上面三种工作模式的主要不同点是监听和处理的方式不同，这是因为<code>Linux</code>采用<code>socket</code>对TCP， UDP进行了封装，并产生了一套独立的调用过程，而开发者在使用<code>socket</code>进行TCP的网络编程时一般有几个步骤：</p>
<ul>
<li><p>1.调用<code>socket.bind</code>，给该<code>socket</code>实例绑定一个IP和端口，这样后续内核会把收到该IP端口的网络流量转发给该<code>socket</code>。</p>
</li>
<li><p>2.调用<code>socket.listen</code>，该调用对应着TCP的<code>listen</code>状态，当调用这个函数后，服务端就会进入到这个状态，意味着可以开始处理客户端的请求了。</p>
<p>  调用<code>socket.listen</code>函数后，内核为该<code>socket</code>维护两个队列，一个是已经建立连接的队列，代表客户端与服务端的连接已经三次握手完毕；另外一个是还没有完全建立连接的队列，代表客户端已经与服务端开始尝试连接，但三次握手还没完成。</p>
</li>
<li><p>3.调用<code>socket.accept</code>，从已经建立连接的队列获取连接来处理，如果获取不到连接，则会一直等待直到内核把建立的连接返回给该进程调用，需要注意的是这时候返回的是另外一个<code>socket</code>，也就是监听的是一个<code>socket</code>，<code>accept</code>后是另一个<code>socket</code>，然后服务端就会通过调用新返回的<code>socket</code>的<code>socket.read</code>和<code>socket.write</code>方法来与客户端进行交互。</p>
</li>
</ul>
<p>其中第二第三交互步骤如图：<br><img    class="lazyload" data-original="https://cdn.jsdelivr.net/gh/so1n/so1n_blog_photo@master/blog_photo/1646586321755Pre-Worker%E6%9C%8D%E5%8A%A1%E6%A8%A1%E5%9E%8B%E9%97%AE%E9%A2%98%E7%9A%84%E6%80%9D%E8%80%83-socket%E4%BA%A4%E4%BA%92.jpg" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">Pre-Worker服务模型问题的思考-socket交互</span></p>
<p>了解完了<code>socket</code>的交互步骤后再回顾上面的三种工作模式可以发现，第一种工作模式是一个进程包了3个调用步骤，第二种工作模式则是主进程包了前面两个调用，工作进程包了第三个调用。之所以这样区分是因为第二种工作模式一般都是采用主进程来管理工作进程，通过拓展多个工作进程来处理更多的请求数量，但是<code>socket.accept</code>是一个阻塞操作，而且每个请求进来的时候，服务端都会<code>accept</code>一次， 如果把<code>socket.accept</code>调用放在主进程，那么<code>socket.accept</code>的阻塞操作就会成为服务的处理请求瓶颈，拓展再多的工作进程也无法提升服务端的处理性能。</p>
<p>但是第二种工作模式也无法一味的通过提升进程来提升服务端的处理性能，因为这种工作模式会出现惊群效应。</p>
<h2 id="2-惊群效应"><a href="#2-惊群效应" class="headerlink" title="2.惊群效应"></a>2.惊群效应</h2><p>对于<code>Pre-Worker</code>模型， 有一个最典型的问题就是惊群效应，惊群效应产生的原因是由于系统不知道网络数据包是何时到来，所以系统中对于网络数据包的接收都是采用异步进行的。</p>
<p>当服务端的<code>socket</code>处于listen状态之后就可以开始处理客户端的请求了，这时所有<code>Worker</code>进程都处于调用<code>socket.accept</code>后睡眠的状态中。而客户端发出的数据包会先抵达到网卡上，网卡就会通知内核数据包已经到了，内核就会开始将数据包填充到对应的<code>socket</code>队列并通知持有该<code>socket</code>的进程，由于目前没有进程来处理该请求，所以内核就会把所有持有该<code>socket</code>的进程全部都唤醒，但是最后只有一个进程能收到这个请求并执行后续的处理，其它的进程被唤醒后发现并没有数据可以接收则会继续睡眠。这些进程虽然被唤醒后没有执行任何操作，但是内核已经执行了对进程的调度和上下文的切换， 当并发量很大的时候，这几个步骤就会十分的影响服务性能，进而降低服务的并发能力。</p>
<p>可以看出，惊群效应就是多个进程抢夺一个资源而产生的问题，要解决这个问题，就需要解决资源的竞争，所以<code>Linux</code>内核通过引入一个名为<code>WQ_FLAG_EXCLUSIVE</code>的标记位来解决这个问题，当<code>Worker</code>进程调用<code>socket.accept</code>时，内核会发现这个操作带有<code>WQ_FLAG_EXCLUSIVE</code>的标记，就把他加入到一个<code>accept</code>队列的尾部， 每当有一个请求进来的时候，内核只会从这个队列的头部取出一个进程来处理请求，进程处理完成后内核再把它加入到队列的尾部，等待下次的请求到达。通过这样的设计，<code>Pre-Worker</code>就能避免了一个请求唤醒一片进程的情况。</p>
<h3 id="2-1-Event-Loop的惊群效应"><a href="#2-1-Event-Loop的惊群效应" class="headerlink" title="2.1.Event Loop的惊群效应"></a>2.1.Event Loop的惊群效应</h3><p>通过查阅资料发现<code>Linux</code>通过<code>WQ_FLAG_EXCLUSIVE</code>标记解决了<code>socket.accept</code>的惊群问题， 但是现在很多服务通过基于事件循环的方法来提供更高的并发能力。比如我线上运行的服务就是用到了<code>Gevent</code>，而<code>Gevent</code>用到的核心事件循环则是<code>Epoll</code>，它与<code>Select</code>, <code>Poll</code>并称为<code>Event Loop</code>。</p>
<p>对于任何工作模式来说， 使用<code>Event Loop</code>后，进程调用<code>socket.accept</code>后的行为逻辑就不一样了，具体的逻辑步骤如下：</p>
<ul>
<li>1.进程在调用<code>socket.accept</code>时，<code>Event Loop</code>会把进程挂在<code>socket</code>对应的文件描述符的等待队列上。</li>
<li>2.当<code>socket</code>的文件描述符有事件产生时，对应的驱动就会将等待队列上对应的进程进行唤醒。</li>
<li>3.被唤醒的进程会通过<code>Event Loop</code>检查事件是否就绪，如果事件就绪就会返回对应的事件给刚才的进程。</li>
<li>4.检查<code>accept</code>事件是否可调用， 如果可以就执行<code>accept</code>操作，并取得该四元组的对应<code>socket</code>。</li>
</ul>
<p>可以看到，之前进程是挂在网络驱动上等着被内核唤醒，而在使用<code>Event Loop</code>后进程是挂在对应文件描述符的等待队列上等待被<code>Event Loop</code>唤醒，对于<code>Pre-Worker</code>模型下的每个工作进程虽然都有自己专属的<code>Event Loop</code>，但是他们都是等待着同样的资源，于是当该文件描述符有事件产生时，就会唤醒所有工作进程对应的<code>Event Loop</code>来检查事件以及判断是否可以返回事件给工作进程, 而且由于是通过<code>Event Loop</code>的逻辑来执行<code>socket.accept</code>，这样会绕过上面所说的<code>WQ_FLAG_EXCLUSIVE</code>标记的限制，从而又产生了惊群效应。</p>
<p>可以看到，<code>Event Loop</code>产生惊群效应的原因跟进程直接调用<code>sock.accept</code>十分的像，所以他们的解决思路也很像，首先是给<code>Event Loop</code>增加一个名为<code>EPOLLEXCLUSIVE</code>的标记， 然后开发者在编程时可以在<code>Event Loop</code>实例化后注册对应的标记,当进程在调用<code>sock.accept</code>且系统检到<code>Event Loop</code>带有该标记时，就会把进程挂在文件描述符的队列尾部，等到事件产生时，内核会只唤醒该队列的第一个进程来处理对应的事件。</p>
<blockquote>
<p>关于标记<code>EPOLLEXCLUSIVE</code>的具体内容可见:<a href="https://lwn.net/Articles/632590/">Add epoll round robin wakeup mode</a>， 通过内容还可以知道还有一个标记<code>EPOLLROUNDROBIN</code>用来解决唤醒不均衡的情况，但是在<code>Python</code>中似乎没办法使用。</p>
</blockquote>
<h2 id="3-负载不均衡问题"><a href="#3-负载不均衡问题" class="headerlink" title="3.负载不均衡问题"></a>3.负载不均衡问题</h2><h3 id="3-1-一次线上日志的分析"><a href="#3-1-一次线上日志的分析" class="headerlink" title="3.1.一次线上日志的分析"></a>3.1.一次线上日志的分析</h3><p>目前线上其中一个服务的运行架构简化为下图：<br><img    class="lazyload" data-original="https://cdn.jsdelivr.net/gh/so1n/so1n_blog_photo@master/blog_photo/1646412224744Gunicorn%E8%BF%9B%E7%A8%8B%E9%A5%A5%E9%A5%BF%E7%9A%84%E6%80%9D%E8%80%83-%E7%BA%BF%E4%B8%8A%E6%9C%8D%E5%8A%A1%E6%A8%A1%E5%9E%8B.jpg" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">线上服务运行架构</span></p>
<p>这个服务前置了一台<code>Nginx</code>，并由<code>Nginx</code>均衡地转发给后面的两个<code>Gunicorn</code>绑定的端口，这两个<code>Gunicorn</code>的<code>Worker</code>都采用<code>Gevent Worker</code>，同时<code>Worker</code>设置的数量是10个。<br>另外服务的应用程序每收到一条请求都会打印一条请求日志，该日志带有<code>Worker</code>的<code>Pid</code>，于是通过请求日志中<code>Pid</code>出现的次数就可以知道该<code>Worker</code>接受的请求数量有多少，在进行分析后得到的数据如下:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 数据经过简单的人为排序</span><br><span class="hljs-comment"># 两个字段分别是处理数量  PID</span><br> 311245 2042<br> 311909 2034<br>  77711 2025<br>  78707 2041<br>  25023 2001<br>  25062 2022<br>  10017 2019<br>   9546 2020<br>   4239 2009<br>   4475 2010<br>   2629 2005<br>   2544 2033<br>   1077 2006<br>   1174 2026<br>   1608 1974<br>   1705 2003<br>    238 1898<br>    249 1977<br>    262 1896<br>    296 1897<br>    329 1928<br>    333 1994<br>    342 1903<br>    371 1915<br>    373 1950<br>    386 1917<br>    458 1909<br>    467 1934<br>    485 1972<br>    516 1927<br>    599 1963<br>    679 1916<br>    917 2008<br>    923 2004<br></code></pre></td></tr></table></figure>
<p>通过数据可以发现，每个<code>Worker</code>处理的请求数量都是不一致的，且每2个<code>Worker</code>处理的数量是接近的，在经过上面的服务运行架构可以发现有个数据特点：</p>
<ul>
<li>1.不同的实例下的<code>Worker</code>处理请求数量分布十分的接近。如PID 2042属于<code>Gunicorn</code>实例1的<code>Worker</code>, PID 2034属于<code>Gunicorn</code>实例2的<code>Worker</code>，他们处理的请求数量分别为311245和311909，相差不大，且远远超过了同实例下的其它<code>Worker</code>处理的请求数量。</li>
<li>2.不同的<code>Worker</code>处理的请求数量差别很大，处理请求数量最多的<code>Worker</code>比其它<code>Worker</code>处理请求的数量还多(同一实例情况下)</li>
</ul>
<p>通过第一点可以发现<code>Nginx</code>的负载均衡是生效的，因为每个实例接收到请求是相近的，且每个实例的<code>Worker</code>接收请求数量的分布十分的接近。。通过第二点可以发现不同<code>Worker</code>的请求数量差别非常的大，它们之间相差的最大倍数达到了100倍，这极有可能是<code>Gunicorn</code>导致分发给<code>Worker</code>的请求不均衡。</p>
<p>这样的数据标明了服务存在部分进程饿死的现象，即使加再多的<code>Worker</code>也很难去分担之前<code>Worker</code>的请求，反而会因为进程过多导致服务器上下文切换次数变多而性能下降。</p>
<p>由于之前一直在使用<code>Asyncio</code>，所以我知道<code>Event Loop</code>在收到对应文件描述符的事件时，它不是以雨露均沾的方式去唤醒进程/线程/协程，而是会优先唤醒第一个注册的进程/线程/协程，只有第一个进程/线程/协程繁忙的情况下才会去唤醒后面的进程/线程/协程，造成了唤醒倾斜的问题，所以我猜测是这个规则引发了负载不均衡的问题。以下是一个验证<code>Event Loop</code>唤醒规则的demo代码以及注释如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> asyncio<br><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> Counter<br><br><br><span class="hljs-comment"># 统计是协程对应的消费次数</span><br>cnt: Counter = Counter()<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">consumer</span>(<span class="hljs-params">aid: <span class="hljs-built_in">int</span>, queue: asyncio.Queue</span>):</span><br>    <span class="hljs-comment"># 消费者，用于消费队列的数据</span><br>    print(aid, <span class="hljs-string">&quot;init&quot;</span>)<br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        <span class="hljs-keyword">await</span> queue.get()<br>        cnt[aid] += <span class="hljs-number">1</span><br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sleep_consumer</span>(<span class="hljs-params">aid: <span class="hljs-built_in">int</span>, queue: asyncio.Queue</span>):</span><br>    <span class="hljs-comment"># 消费者，用于消费队列的数据</span><br>    print(aid, <span class="hljs-string">&quot;init&quot;</span>)<br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        <span class="hljs-keyword">await</span> queue.get()<br>        <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">0.1</span>)<br>        cnt[aid] += <span class="hljs-number">1</span><br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    <span class="hljs-comment"># 创建队列以及消费者协程</span><br>    a_queue: asyncio.Queue = asyncio.Queue()<br>    b_queue: asyncio.Queue = asyncio.Queue()<br>    <span class="hljs-keyword">for</span> a_id <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):<br>        <span class="hljs-keyword">if</span> a_id // <span class="hljs-number">2</span> == a_id / <span class="hljs-number">2</span>:<br>            asyncio.ensure_future(consumer(a_id, a_queue))<br>        <span class="hljs-keyword">else</span>:<br>            asyncio.ensure_future(sleep_consumer(a_id, b_queue))<br><br>    <span class="hljs-comment"># 等待所有消费者协程创建完成</span><br>    <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">0.01</span>)<br><br>    <span class="hljs-comment"># 推送数据到队列</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):<br>        <span class="hljs-keyword">if</span> i // <span class="hljs-number">2</span> == i / <span class="hljs-number">2</span>:<br>            a_queue.put_nowait(i)<br>        <span class="hljs-keyword">else</span>:<br>            b_queue.put_nowait(i)<br><br>    <span class="hljs-comment"># 等待都消费了才退出</span><br>    <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">1</span>)<br><br><br>asyncio.run(main())<br>print(cnt)<br></code></pre></td></tr></table></figure>
<p>该程序的消费者注册到<code>Event Loop</code>的先后顺序与他们的ID有关，该程序中有两个队列，它们对应着两种类型的消费者， 第一种消费者只做消费（序号为偶数的消费者），第二种消费者除了消费外还休眠了0.1秒(序号为奇数的消费者)， 在运行程序后，程序的输出结果如下:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">0 init<br>1 init<br>2 init<br>3 init<br>4 init<br>5 init<br>6 init<br>7 init<br>8 init<br>9 init<br>Counter(&#123;0: 5, 1: 1, 3: 1, 5: 1, 7: 1, 9: 1&#125;)<br></code></pre></td></tr></table></figure>
<p>通过输出结果可以发现，10个消费者协程已经创建了，<br>对于带有休眠的消费者(序号1,3,5,7,9)他们都消费了一条数据，但对于普通的消费者(0,2,4,6,8)，只有0号消费者有消费，这是因为在普通的消费者中，0号消费者是最早注册的，且这类型的消费者从队列获取数据所花费的CPU时间非常的少，所以0号消费者消费一次数据后又立即收到了<code>Event Loop</code>的调度继续消费，而带有休眠的消费者因为他们的休眠占用了一些时间，<code>Event Loop</code>调度了最先注册的消费者后想继续调度却发现它处于繁忙状态，这时就会调度下一个注册的消费者， 最终达到均匀的调度到每一个消费者。</p>
<p>不过这个例子只是单进程下跑出来的结果， 为了更更贴生产服务，我把<code>Gunicorn</code>的<code>Sync Worker</code>和<code>Gevent Worker</code>抽象为下面两个简单的TCP模型，他们的代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-comment">############################</span><br><span class="hljs-comment"># 模仿Sync Work工作模式的代码 #</span><br><span class="hljs-comment">############################</span><br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> socket<br><span class="hljs-keyword">import</span> time<br><br><span class="hljs-comment"># 初始化sock</span><br>sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)<br>sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, <span class="hljs-number">1</span>)<br>sock.bind((<span class="hljs-string">&#x27;127.0.0.1&#x27;</span>, <span class="hljs-number">8000</span>))<br>sock.listen()<br><span class="hljs-keyword">try</span>:<br>    <span class="hljs-comment"># fork 出3个进程</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>):<br>        pid = os.fork()<br>        <span class="hljs-keyword">if</span> pid == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>                <span class="hljs-comment"># 该循环是接收请求并把自己的pid发送给客户端</span><br>                cs_sock, _ = sock.accept()<br>                <span class="hljs-comment"># send方法不会阻塞</span><br>                cs_sock.send(<span class="hljs-built_in">str</span>(os.getpid()).encode())<br>                cs_sock.close()<br>                <span class="hljs-comment"># 模仿IO</span><br>                time.sleep(<span class="hljs-number">0.001</span>)<br>    os.wait()<br><span class="hljs-keyword">finally</span>:<br>    sock.close()<br><br><span class="hljs-comment">##############################</span><br><span class="hljs-comment"># 模仿Gevent Work工作模式的代码 #</span><br><span class="hljs-comment">##############################</span><br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> select<br><span class="hljs-keyword">import</span> socket<br><br><span class="hljs-comment"># 用于模仿IO的文件描述符</span><br>r, _ = os.pipe()<br><br><span class="hljs-comment"># 初始化sock</span><br>sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)<br>sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, <span class="hljs-number">1</span>)<br>sock.bind((<span class="hljs-string">&#x27;127.0.0.1&#x27;</span>, <span class="hljs-number">8000</span>))<br>sock.listen()<br>sock.setblocking(<span class="hljs-literal">False</span>)<br><span class="hljs-keyword">try</span>:<br>    <span class="hljs-comment"># fork 出3个进程</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>):<br>        pid = os.fork()<br>        <span class="hljs-keyword">if</span> pid == <span class="hljs-number">0</span>:<br>            <span class="hljs-comment"># 初始化两个epoll,一个用来处理请求一个用于模仿阻塞</span><br>            epoll = select.epoll()<br>            epoll.register(sock, select.EPOLLIN | select.EPOLLEXCLUSIVE)<br>            sleep_epoll = select.epoll()<br>            sleep_epoll.register(r, select.EPOLLIN | select.EPOLLEXCLUSIVE)<br>            <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>                <span class="hljs-keyword">try</span>:<br>                    <span class="hljs-comment"># 等待事件</span><br>                    epoll.poll()<br>                <span class="hljs-keyword">except</span> IOError:<br>                    <span class="hljs-keyword">continue</span><br><br>                <span class="hljs-comment"># 事件循环下调用`sock.accept`会报错</span><br>                <span class="hljs-keyword">try</span>:<br>                    cs_sock, _ = sock.accept()<br>                <span class="hljs-keyword">except</span> socket.error:<br>                    <span class="hljs-keyword">continue</span><br>                <span class="hljs-comment"># send方法不会阻塞</span><br>                cs_sock.send(<span class="hljs-built_in">str</span>(os.getpid()).encode())<br>                cs_sock.close()<br>                <span class="hljs-comment"># 模仿IO</span><br>                sleep_epoll.poll(timeout=<span class="hljs-number">0.001</span>)<br><br>    os.wait()<br><span class="hljs-keyword">finally</span>:<br>    sock.close()<br></code></pre></td></tr></table></figure>
<p>服务端代码创建完成了， 接下来可以使用客户端代码来进行测试并统计， 代码如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> asyncio<br><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> Counter<br><br><br><span class="hljs-comment"># 统计pid</span><br>cnt = Counter()<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">tcp_echo_client</span>():</span><br>    <span class="hljs-string">&quot;&quot;&quot;从Asyncio文档复制过来的最小TCP Client代码&quot;&quot;&quot;</span><br>    reader, writer = <span class="hljs-keyword">await</span> asyncio.open_connection(<span class="hljs-string">&#x27;127.0.0.1&#x27;</span>, <span class="hljs-number">8000</span>)<br>    data = <span class="hljs-keyword">await</span> reader.read(<span class="hljs-number">1024</span>)<br>    <span class="hljs-comment"># 获取服务端返回的Pid来统计数据</span><br>    cnt[data.decode()] += <span class="hljs-number">1</span><br>    writer.close()<br><br><span class="hljs-comment"># 模拟5000个并发</span><br>asyncio.get_event_loop().run_until_complete(<br>    asyncio.gather(*[tcp_echo_client() <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5000</span>)])<br>)<br>print(cnt)<br></code></pre></td></tr></table></figure>
<p>一切准备就绪，分别对两个模式的代码进行测试，结果如下:</p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><code class="hljs 1c"><span class="hljs-meta"># Sync Worker模型下测试的结果</span><br>Counter(&#123;&#x27;<span class="hljs-number">2410</span>2&#x27;: <span class="hljs-number">1668</span>, &#x27;<span class="hljs-number">2410</span>1&#x27;: <span class="hljs-number">1667</span>, &#x27;<span class="hljs-number">2410</span>3&#x27;: <span class="hljs-number">1665</span>&#125;)<br><span class="hljs-meta"># Gevent Worker模型下测试的结果</span><br>Counter(&#123;&#x27;<span class="hljs-number">2440</span>3&#x27;: <span class="hljs-number">1774</span>, &#x27;<span class="hljs-number">2440</span>4&#x27;: <span class="hljs-number">1738</span>, &#x27;<span class="hljs-number">2441</span>0&#x27;: <span class="hljs-number">1488</span>&#125;)<br></code></pre></td></tr></table></figure>
<p>通过结果可以看出<code>Sync Worker</code>的输出结果是三个工作进程得到请求的数量是相近的，而<code>Gevent Worker</code>的三个工作进程得到请求的数量是不均衡的，特别是第三个工作进程得到请求点数量比前两个还少（如果去掉模仿IO的代码，<code>Gevent Worker</code>模型下测试的结果只有一个工作进程得到了所有请求点数量）。</p>
<h2 id="4-两种问题的共同解决方案–SO-REUSEPORT"><a href="#4-两种问题的共同解决方案–SO-REUSEPORT" class="headerlink" title="4.两种问题的共同解决方案–SO_REUSEPORT"></a>4.两种问题的共同解决方案–SO_REUSEPORT</h2><p>现在回顾下这两种问题，他们的核心都是围绕着对同一个资源（文件描述符/事件）进行争夺，如果能解决这一点，那么两个问题都能得到解决。而之所以需要对同一个资源进行争夺是因为<code>Pre-Worker</code>模型下是由<code>Master</code>进程创建了用户指定IP端口的<code>socket</code>并在调用监听操作后才分给工作进程的，如果这些<code>socket</code>都能由工作进程创建，那就能解决问题了。<br>可是在进行网络编程时，经常能发现端口被占用导致服务无法启动的情况，这就意味着工作进程不能创建监听相同IP端口的<code>socket</code>，这时就需要<code>SO_REUSEPORT</code>了。</p>
<p>通过<code>SO_REUSEPORT</code>，操作系统允许多个工作进程的<code>socket</code>绑定到同一个端口，这时候服务的工作模式就变为上面所说的第三种，既多个工作进程，每个工作进程都有单独监听和处理的<code>socket</code>，这种工作模式下每个工作进程持有的文件描述符都是自己专有的，没人一起争夺,这样无论是<code>Synv Worker</code>调用<code>socket.accept</code>还是<code>Gevent Worker</code>调用的<code>socket.accept</code>,他们都不会出现争夺的问题而产生惊群效应，他们的交互变化如图:<br><img    class="lazyload" data-original="https://cdn.jsdelivr.net/gh/so1n/so1n_blog_photo@master/blog_photo/1646586327619Pre-Worker%E6%9C%8D%E5%8A%A1%E6%A8%A1%E5%9E%8B%E9%97%AE%E9%A2%98%E7%9A%84%E6%80%9D%E8%80%83-%E4%B8%8D%E5%90%8C%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F%E4%BA%A4%E4%BA%92%E5%9B%BE.jpg" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">Pre-Worker服务模型问题的思考-不同工作模式交互图</span><br>通过图可以看出，在使用<code>SO_REUSEPORT</code>后，对于同一个IP端口从单个Accept队列变为多个Accept队列，每个队列对于工作进程来说都是独有的，并且<code>Linux</code>会通过对四元组把请求hash到不同的Accept队列，最后使得每个<code>Worker</code>都能获得相同的连接数量，从而实现负载均衡。<br>为了验证<code>SO_REUSEPORT</code>是否发挥作用，现在基于上面<code>Gevent Workrt</code>模型的简易代码进行修改:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> select<br><span class="hljs-keyword">import</span> socket<br><br><span class="hljs-comment"># 用于模仿阻塞的文件描述符</span><br>r, w = os.pipe()<br><br><br><span class="hljs-keyword">try</span>:<br>    <span class="hljs-comment"># fork 出3个进程</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>):<br>        pid = os.fork()<br>        <span class="hljs-keyword">if</span> pid == <span class="hljs-number">0</span>:<br>            <span class="hljs-comment"># 把初始化sock挪到fork之后</span><br>            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)<br>            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, <span class="hljs-number">1</span>)<br>            <span class="hljs-comment"># 设置端口复用</span><br>            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEPORT, <span class="hljs-number">1</span>)<br>            sock.bind((<span class="hljs-string">&#x27;127.0.0.1&#x27;</span>, <span class="hljs-number">8000</span>))<br>            sock.listen()<br>            sock.setblocking(<span class="hljs-literal">False</span>)<br>            <span class="hljs-comment"># 初始化两个epoll,一个用来处理请求一个用于模仿阻塞</span><br>            epoll = select.epoll()<br>            epoll.register(sock, select.EPOLLIN | select.EPOLLEXCLUSIVE)<br>            sleep_epoll = select.epoll()<br>            sleep_epoll.register(r, select.EPOLLIN | select.EPOLLEXCLUSIVE)<br>            <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>                <span class="hljs-keyword">try</span>:<br>                    epoll.poll()<br>                <span class="hljs-keyword">except</span> IOError:<br>                    <span class="hljs-keyword">continue</span><br><br>                <span class="hljs-comment"># 事件循环下调用`sock.accept`会报错</span><br>                <span class="hljs-keyword">try</span>:<br>                    cs_sock, _ = sock.accept()<br>                <span class="hljs-keyword">except</span> socket.error:<br>                    <span class="hljs-keyword">continue</span><br>                <span class="hljs-comment"># send方法不会阻塞</span><br>                cs_sock.send(<span class="hljs-built_in">str</span>(os.getpid()).encode())<br>                cs_sock.close()<br>                <span class="hljs-comment"># 模仿阻塞</span><br>                sleep_epoll.poll(timeout=<span class="hljs-number">0.001</span>)<br><br>    os.wait()<br><span class="hljs-keyword">finally</span>:<br>    sock.close()<br></code></pre></td></tr></table></figure>
<p>修改完成后，再运行刚才的客户端测试脚本， 得到输出如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python">Counter(&#123;<span class="hljs-string">&#x27;16070&#x27;</span>: <span class="hljs-number">1686</span>, <span class="hljs-string">&#x27;16069&#x27;</span>: <span class="hljs-number">1682</span>, <span class="hljs-string">&#x27;16071&#x27;</span>: <span class="hljs-number">1632</span>&#125;)<br></code></pre></td></tr></table></figure>
<p>通过结果可以看出虽然第一个工作进程得到的数量还是最多的，但是三个工作进程之间的差距已经是非常的小了。</p>
<blockquote>
<p>Gunicorn虽然支持设置<code>SO_REUSEPORT</code>但是他自带的<code>Worker</code>类型仍然是以第二种工作模式运行着，所以我们需要去修改它的<code>Worker</code>，才能以第三种工作模式运行。</p>
</blockquote>
<p>不过，使用了<code>SO_REUSEPORT</code>后会带来两个新的问题，第一个也就是官方自己说的(如下)，如果绑定到同一个端口的<code>socket</code>数量发生变化时，hash就会有变动，这个时候如果有个请求处于三次握手期间，那么它将会被丢弃，这种情况下客户端会重置请求，但服务端仍然会留下一个孤独的请求结构。</p>
<blockquote>
<p><a href="https://lwn.net/Articles/542629/">The SO_REUSEPORT socket option</a>:</p>
<p>The other noteworthy point is that there is a defect in the current implementation of TCP SO_REUSEPORT. If the number of listening sockets bound to a port changes because new servers are started or existing servers terminate, it is possible that incoming connections can be dropped during the three-way handshake. The problem is that connection requests are tied to a specific listening socket when the initial SYN packet is received during the handshake. If the number of servers bound to the port changes, then the SO_REUSEPORT logic might not route the final ACK of the handshake to the correct listening socket. In this case, the client connection will be reset, and the server is left with an orphaned request structure. A solution to the problem is still being worked on, and may consist of implementing a connection request table that can be shared among multiple listening sockets.</p>
</blockquote>
<p>第二个问题则是请求延迟，在第二种工作模式下，所有请求都会进到同一个Accept队列，等待工作进程来从队列拉取数据，这种情况下所有请求都是先到先被处理；而在第三种工作模式下，请求会被hash到不同进程的Accept队列，等待被持有该队列的进程拉取数据，如果这时候有个进程发生了阻塞情况，那么该进程上的Accept队列的所有请求都会一直等待，直到进程阻塞结束，这种情况下该队列的请求可能比别的队列的请求先到，但是却比别的队列的请求晚处理， 这就是请求延迟到现象。</p>
<h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5.总结"></a>5.总结</h2><p>目前对于<code>Pre-Worker</code>问题都有了解决方案， 但是这些方案并不一定是完美的，他们可能存在着一些问题等待被解决，而我们可以根据自己的使用情况来选择不同的工作模型，在性能允许范围下规避一些已知的问题。</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>gunicorn源码分析</title>
    <url>/2022/02/22/gunicorn/</url>
    <content><![CDATA[<h2 id="前记"><a href="#前记" class="headerlink" title="前记"></a>前记</h2><p><code>Gunicorn</code>是一个基于<code>Python</code>实现的动态Web服务器，它通过Pre-Worker模型来实现并发，本身带有多种工作模式，基本上可以与所有基于<code>Python</code>的Web框架集成，并为他们带来一个多功能又稳定的服务器托管核心。</p>
<p>从学习<code>Python</code> Web的第一天就开始接触了<code>Gunicorn</code>,那时候还不知道他具体的作用是什么， 只知道在项目中使用他运行之后可以变得十分的稳定，高性能，从未研究它是如何实现的。随着使用时间的增长，越来越想知道它的运行原理是什么，特别是它性能为何会高，跟类Unix有什么特殊结合，<code>Pre-Worker</code>模型是如何通信的，如何设计一个比较好的<code>Pre-Worker</code>模型服务器？<br>于是，本文就是阅读源码之后的产物。</p>
<h2 id="1-简单了解"><a href="#1-简单了解" class="headerlink" title="1.简单了解"></a>1.简单了解</h2><p>通过<a href="https://github.com/benoitc/gunicorn/tree/20.x">Gunicorn代码仓库</a>把代码拉到本地，使用<code>Tree</code>命令可以简单的看到<code>Gunicorn</code>的代码结构，可以看出文件数量并不是很多，以下是<code>Gunicorn</code>的代码结构以及他们每个文件夹或者每个文件的说明:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">├── app             <span class="hljs-comment"># Gunicorn的运行实例,由该示例来运行arbiter，但在重启或者重新加载配置时，会由arbiter重新运行一个新的app实例</span><br>├── http            <span class="hljs-comment"># 用于Worker中处理客户端发送的HTTP请求</span><br>├── instrument      <span class="hljs-comment"># 使用statsd协议把自身信息发送到Statsd服务</span><br>├── workers         <span class="hljs-comment"># Pre-Worker模型中的Worker， 负责运行Web应用， 这些worker大部分都是基于WSGI协议封装的，但可以通过自定义协议封装来支持TCP传输</span><br>├── __init__.py<br>├── __main__.py<br>├── arbiter.py      <span class="hljs-comment"># Pre-Worker模型中的Master， 负责管理Worker, 配置重载，重新启动新的进程等。 </span><br>├── config.py       <span class="hljs-comment"># 加载配置相关</span><br>├── debug.py        <span class="hljs-comment"># 基于sys.settrace钩子实现的debug信息输出 </span><br>├── errors.py       <span class="hljs-comment"># Master错误的封装</span><br>├── glogging.py     <span class="hljs-comment"># 日志输出</span><br>├── pidfile.py      <span class="hljs-comment"># 进程PID文件管理 </span><br>├── reloader.py     <span class="hljs-comment"># 文件自动重载功能</span><br>├── sock.py         <span class="hljs-comment"># 对不同类型的socket做统一的封装</span><br>├── systemd.py      <span class="hljs-comment"># 激活systemd的socket，通过systemd文档即可知道如何交互，所以不做分析</span><br>└── util.py         <span class="hljs-comment"># 常用代码封装</span><br></code></pre></td></tr></table></figure>

<h2 id="2-开始入手"><a href="#2-开始入手" class="headerlink" title="2.开始入手"></a>2.开始入手</h2><p>了解完代码结构后接着从官方文档的示例开始入手：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ pip install gunicorn<br>$ cat myapp.py<br>  def app(environ, start_response):<br>      data = b<span class="hljs-string">&quot;Hello, World!\n&quot;</span><br>      start_response(<span class="hljs-string">&quot;200 OK&quot;</span>, [<br>          (<span class="hljs-string">&quot;Content-Type&quot;</span>, <span class="hljs-string">&quot;text/plain&quot;</span>),<br>          (<span class="hljs-string">&quot;Content-Length&quot;</span>, str(len(data)))<br>      ])<br>      <span class="hljs-built_in">return</span> iter([data])<br>$ gunicorn -w 4 myapp:app<br>[2014-09-10 10:22:28 +0000] [30869] [INFO] Listening at: http://127.0.0.1:8000 (30869)<br>[2014-09-10 10:22:28 +0000] [30869] [INFO] Using worker: sync<br>[2014-09-10 10:22:28 +0000] [30874] [INFO] Booting worker with pid: 30874<br>[2014-09-10 10:22:28 +0000] [30875] [INFO] Booting worker with pid: 30875<br>[2014-09-10 10:22:28 +0000] [30876] [INFO] Booting worker with pid: 30876<br>[2014-09-10 10:22:28 +0000] [30877] [INFO] Booting worker with pid: 30877<br></code></pre></td></tr></table></figure>
<p>这个示例演示了如何通过命令行来使<code>Gunicorn</code>来运行一个最小的<code>WSGI</code>Web应用，如果熟悉<code>Python</code>的打包规则的话，可以知道这个命令中的<code>gunicorn</code>实际上是在<code>setup.py</code>文件中定义好的， 重新打开仓库，找到<code>setup.py</code>:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">from</span> setuptools <span class="hljs-keyword">import</span> setup, find_packages<br><br><br>setup(<br>    entry_points=<span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    [console_scripts]</span><br><span class="hljs-string">    gunicorn=gunicorn.app.wsgiapp:run</span><br><span class="hljs-string">    &quot;&quot;&quot;</span>,<br>)<br></code></pre></td></tr></table></figure>
<p>这里移除了其它部分的代码，只保留了相关的代码，在这段代码中，指定了<code>gunicorn</code>的命令是命令<code>gunicorn.app.wsgiapp:run</code>的别名，所以这段代码实际上执行了<code>gunicorn.app.wsgiapp</code>文件中的<code>run</code>函数:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span>():</span><br>    <span class="hljs-keyword">from</span> gunicorn.app.wsgiapp <span class="hljs-keyword">import</span> WSGIApplication<br>    WSGIApplication(<span class="hljs-string">&quot;%(prog)s [OPTIONS] [APP_MODULE]&quot;</span>).run()<br></code></pre></td></tr></table></figure>

<p>而<code>run</code>函数的运行逻辑也是很简单， 它是直接实例化一个承于<code>gunicorn.app.base</code>文件的<code>BaseApplication</code>的<code>WSGIApplication</code>类， 这个类在实例化时会执行它的<code>do_load_config</code>方法，也就是在这时候会初始化实例的<code>cfg</code>变量，并调用<code>cfg.parse</code>，其中这个实例是<code>config.Config</code>的实例化，而<code>parse</code>方法是用来解析用户传入的参数并供后续的<code>Arbiter</code>以及<code>Worker</code>使用。</p>
<h2 id="3-加载配置"><a href="#3-加载配置" class="headerlink" title="3.加载配置"></a>3.加载配置</h2><p>一般项目中的加载配置是没有什么可以说的， 但是<code>Gunicorn</code>比较特殊， 在<code>config</code>文件中除了<code>Config</code>这个类和一些校验方法外，还存在大量类似于：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WorkerConnections</span>(<span class="hljs-params">Setting</span>):</span><br>    name = <span class="hljs-string">&quot;worker_connections&quot;</span><br>    section = <span class="hljs-string">&quot;Worker Processes&quot;</span><br>    cli = [<span class="hljs-string">&quot;--worker-connections&quot;</span>]<br>    meta = <span class="hljs-string">&quot;INT&quot;</span><br>    validator = validate_pos_int<br>    <span class="hljs-built_in">type</span> = <span class="hljs-built_in">int</span><br>    default = <span class="hljs-number">1000</span><br>    desc = <span class="hljs-string">&quot;&quot;&quot;\</span><br><span class="hljs-string">        The maximum number of simultaneous clients.</span><br><span class="hljs-string"></span><br><span class="hljs-string">        This setting only affects the Eventlet and Gevent worker types.</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br></code></pre></td></tr></table></figure>
<p>的类， 这些类就是<code>Gunicorn</code>支持的参数或配置值以及它对应的类型，校验规则，默认值和帮助文档等，这些类都按照一定的规范进行编写，同时又继承于<code>Setting</code>这个类，而<code>Setting</code>这个类又继承了<code>SettingMeta</code>,而<code>SettingMeta</code>的作用就是在程序运行的时候，把所有继承于<code>Setting</code>的类加入到<code>config</code>文件的<code>local</code>变量中，供<code>Gunicorn</code>来使用。</p>
<blockquote>
<p><code>Gunicorn</code>在启动时通过<code>config</code>模块把用户传入的命令进行初始化, 再通过环境变量来初始化配置，此时的配置会覆盖掉用户传入命令初始化时的配置，接着在判断用户是否有指定配置文件，如果有就加载配置文件的配置，再覆盖已经存在的配置。<br>也就是说，配置的优先级是配置文件最高，然后环境变量次之，用户通过命令行传入的配置最后会被配置文件的配置所覆盖，<br>但是读取配置文件路径的优先级是命令行最高，然后才是环境变量。</p>
</blockquote>
<h2 id="4-Gunicorn的核心–Arbiter-run"><a href="#4-Gunicorn的核心–Arbiter-run" class="headerlink" title="4.Gunicorn的核心–Arbiter.run"></a>4.Gunicorn的核心–Arbiter.run</h2><p><code>Application</code>实例化完成后，会调用<code>BaseApplication.run</code>方法, 该方法如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span>(<span class="hljs-params">self</span>):</span><br>    <span class="hljs-keyword">try</span>:<br>        Arbiter(self).run()<br>    <span class="hljs-keyword">except</span> RuntimeError <span class="hljs-keyword">as</span> e:<br>        print(<span class="hljs-string">&quot;\nError: %s\n&quot;</span> % e, file=sys.stderr)<br>        sys.stderr.flush()<br>        sys.exit(<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure>
<p>该方法会执行<code>gunicorn.arbiter</code>文件的<code>Arbiter</code>类，这个类是<code>gunicorn</code>的核心类，负责启动和管理所有运行的worker，而<code>Arbiter</code>的<code>run</code>方法则是核心中的核心，负责着整个服务的运行管理，同时又跟<code>Arbiter</code>的其它方法有交互，所以可以通过分析<code>run</code>方法进行分析，进而纵观整个<code>Arbiter</code>类, <code>run</code>的方法如下（具体说明见注释,其它具体分析见小章节）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span>(<span class="hljs-params">self</span>):</span><br>    <span class="hljs-string">&quot;Main master loop.&quot;</span><br>    <span class="hljs-comment"># 1.初始化实例，并信号监听以及sock</span><br>    self.start()<br>    util._setproctitle(<span class="hljs-string">&quot;master [%s]&quot;</span> % self.proc_name)<br><br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-comment"># 2.创建worker直到worker数量满足用户的指定条件，如果当前worker数量超过用户指定的条件，则会杀掉创建时间比较长的worker</span><br>        self.manage_workers()<br><br>        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>            <span class="hljs-comment"># 3.负责判断该进程是否是正真的master，如果是则提升为正真的master(这一块放在最后一部分进行分析)</span><br>            self.maybe_promote_master()<br><br>            <span class="hljs-comment"># 4.获取信号</span><br>            sig = self.SIG_QUEUE.pop(<span class="hljs-number">0</span>) <span class="hljs-keyword">if</span> self.SIG_QUEUE <span class="hljs-keyword">else</span> <span class="hljs-literal">None</span><br>            <span class="hljs-keyword">if</span> sig <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>                <span class="hljs-comment"># 5.利用select休眠1小时</span><br>                self.sleep()<br>                <span class="hljs-comment"># 6.判断worker是否超时，如果是则杀掉worker(将在Worker章节进行分析) </span><br>                self.murder_workers()<br>                self.manage_workers()<br>                <span class="hljs-keyword">continue</span><br><br>            <span class="hljs-keyword">if</span> sig <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> self.SIG_NAMES:<br>                self.log.info(<span class="hljs-string">&quot;Ignoring unknown signal: %s&quot;</span>, sig)<br>                <span class="hljs-keyword">continue</span><br><br>            signame = self.SIG_NAMES.get(sig)<br>            <span class="hljs-comment"># 调用对应的信号处理</span><br>            handler = <span class="hljs-built_in">getattr</span>(self, <span class="hljs-string">&quot;handle_%s&quot;</span> % signame, <span class="hljs-literal">None</span>)<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> handler:<br>                self.log.error(<span class="hljs-string">&quot;Unhandled signal: %s&quot;</span>, signame)<br>                <span class="hljs-keyword">continue</span><br>            self.log.info(<span class="hljs-string">&quot;Handling signal: %s&quot;</span>, signame)<br>            handler()<br>            <span class="hljs-comment"># 7.这样下次循环就不会等待一秒了</span><br>            self.wakeup()<br>    <span class="hljs-comment"># 8.服务异常，进行退出处理</span><br>    <span class="hljs-keyword">except</span> (StopIteration, KeyboardInterrupt):<br>        <span class="hljs-comment"># 收到用户的退出信号(按下CTRL+C) </span><br>        self.halt()<br>    <span class="hljs-keyword">except</span> HaltServer <span class="hljs-keyword">as</span> inst:<br>        <span class="hljs-comment"># Worker运行异常的时候</span><br>        self.halt(reason=inst.reason, exit_status=inst.exit_status)<br>    <span class="hljs-keyword">except</span> SystemExit:<br>        <span class="hljs-keyword">raise</span><br>    <span class="hljs-keyword">except</span> Exception:<br>        <span class="hljs-comment"># 其它的运行异常</span><br>        self.log.info(<span class="hljs-string">&quot;Unhandled exception in main loop&quot;</span>,<br>                      exc_info=<span class="hljs-literal">True</span>)<br>        self.stop(<span class="hljs-literal">False</span>)<br>        <span class="hljs-keyword">if</span> self.pidfile <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            self.pidfile.unlink()<br>        sys.exit(-<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure>

<h3 id="4-1初始化–Arbiter-start"><a href="#4-1初始化–Arbiter-start" class="headerlink" title="4.1初始化–Arbiter.start"></a>4.1初始化–Arbiter.start</h3><p><code>Arbiter.start</code>方法的第一步是进行初始化，首先是判断该进程是否是另一个进程启动的，这里是<code>Gunicorn</code>的<a href="https://docs.gunicorn.org/en/stable/signals.html#upgrading-to-a-new-binary-on-the-fly">Upgrading to a new binary on the fly</a>功能，将在后面统一说明，然后他通过<code>init_signals</code>方法初始化信号的回调, <code>init_signals</code>的源码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">init_signals</span>(<span class="hljs-params">self</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;\</span><br><span class="hljs-string">    Initialize master signal handling. Most of the signals</span><br><span class="hljs-string">    are queued. Child signals only wake up the master.</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-comment"># close old PIPE</span><br>    <span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> self.PIPE:<br>        os.close(p)<br><br>    <span class="hljs-comment"># initialize the pipe</span><br>    self.PIPE = pair = os.pipe()<br>    <span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> pair:<br>        util.set_non_blocking(p)<br>        util.close_on_exec(p)<br><br>    self.log.close_on_exec()<br><br>    <span class="hljs-comment"># initialize all signals</span><br>    <span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> self.SIGNALS:<br>        signal.signal(s, self.signal)<br>    <span class="hljs-comment"># 捕获子进程exit前发出的sigchld信号,然后函数里面通过waitpid来收拾，避免僵尸进程的存在</span><br>    signal.signal(signal.SIGCHLD, self.handle_chld)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">signal</span>(<span class="hljs-params">self, sig, frame</span>):</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(self.SIG_QUEUE) &lt; <span class="hljs-number">5</span>:<br>        self.SIG_QUEUE.append(sig)<br>        self.wakeup()<br><br></code></pre></td></tr></table></figure>
<p>这个方法做了两件事:</p>
<ul>
<li><p>1.首先是初始化<code>PIPE</code>, <code>Gunicorn</code>的<code>Master</code>是一个一直在循环的单进程，每次循环会<code>sleep</code>一秒防止空转，通过<code>PIPE</code>可以使<code>Master</code>进程从<code>sleep</code>阶段提前唤醒。<code>PIPE</code>在初始化时会先通过<code>util.set_non_blocking</code>方法来设置不阻塞来防止<code>PIPE</code>收到信号时，阻塞到<code>Master</code>进程的主流程。 </p>
<p>  然后通过<code>util.close_on_exec</code>来关闭子进程无用的描述符，之所以要这样处理是因为<code>Gunicorn</code>采用了<code>Pre-Worker</code>的模型，在运行的时候<code>Master</code>进程会通过<code>fork</code>的方法来创建<code>worker</code>进程，<code>fork</code>出来的子进程是通过写时复制来获得父进程的数据的，当子进程在<code>exec</code>阶段时就会创建一份新的资源引用，此时保存原来文件描述符的变量当然也不存在了，也就无法关闭无用的文件描述符了， 这意味着对于某个文件描述符多了一个引用，而<code>Linux</code>的文件描述符是等到都没有引用的时候才会删掉， 所以我们在使用的时候都会期望在<code>fork</code>阶段后，<code>exec</code>阶段之前直接关掉无用的物件描述符，这时候就可以用到<code>Linux</code>的<code>close-on-exec</code>功能。 </p>
<p>  在初始化文件描述符后， 通过直接对文件描述符设置<code>FD_CLOEXEC</code>标记， 这样在<code>fork</code>阶段后<code>exec</code>阶段前，<code>Linux</code>会自动关掉无用的文件描述符， 在<code>Gunicorn</code>中，会对所有文件描述符都调用<code>util.close_on_exec</code>。</p>
</li>
<li><p>2.初始化真正的信号监听， 注册了<code>Gunicortn</code>所有会用到的信号回调，该回调会把信息注册到一个名为<code>SIG_QUEUE</code>的队列中，同时会执行<code>wakeup</code>来唤醒<code>worker</code>的循环(将在run中的sleep介绍这个机制是怎么实现的)</p>
</li>
</ul>
<p>在完成了信号监听的注册后， 会开始创建<code>sock</code>,<code>Gunicorn</code>为各种类型的<code>sock</code>做了统一的封装， 它会判断用户配置要监听的<code>IP</code>端口来挑选一个合适的<code>sock</code>,然后进行初始化，其中最重要的初始化方法就是<code>BaseCocket</code>的<code>set_options</code>方法， 它的源码如下: </p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseSocket</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, address, conf, log, fd=<span class="hljs-literal">None</span></span>):</span><br>        ...<br>        <span class="hljs-comment"># 初始化sock</span><br>        self.sock = self.set_options(sock, bound=bound)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">set_options</span>(<span class="hljs-params">self, sock, bound=<span class="hljs-literal">False</span></span>):</span><br>        <span class="hljs-comment"># 设置sock的功能</span><br>        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">if</span> (self.conf.reuse_port<br>            <span class="hljs-keyword">and</span> <span class="hljs-built_in">hasattr</span>(socket, <span class="hljs-string">&#x27;SO_REUSEPORT&#x27;</span>)):  <span class="hljs-comment"># pragma: no cover</span><br>            <span class="hljs-keyword">try</span>:<br>                sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEPORT, <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">except</span> socket.error <span class="hljs-keyword">as</span> err:<br>                <span class="hljs-keyword">if</span> err.errno <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> (errno.ENOPROTOOPT, errno.EINVAL):<br>                    <span class="hljs-keyword">raise</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> bound:<br>            self.bind(sock)<br>        <span class="hljs-comment"># 设置不阻塞</span><br>        sock.setblocking(<span class="hljs-number">0</span>)<br><br>        <span class="hljs-comment"># make sure that the socket can be inherited</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">hasattr</span>(sock, <span class="hljs-string">&quot;set_inheritable&quot;</span>):<br>            sock.set_inheritable(<span class="hljs-literal">True</span>)<br>        <br>        <span class="hljs-comment"># 开始监听</span><br>        sock.listen(self.conf.backlog)<br>        <span class="hljs-keyword">return</span> sock<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">bind</span>(<span class="hljs-params">self, sock</span>):</span><br>        sock.bind(self.cfg_addr)<br></code></pre></td></tr></table></figure>
<p>在<code>Gunicorn</code>中，它创建的所有<code>Scoket</code>都是继承于<code>gunicorn.sock.BaseSocket</code>,所以<code>Gunicorn</code>在创建<code>scoket</code>后会调用<code>set_options</code>方法，这个方法默认会设置<code>SO_REUSEADDR</code>标记，然后再依赖配置设置<code>SO_REUSEPORT</code>标记， 设置<code>SO_REUSEPORT</code>标记可以解决部分惊群问题，同时也能解决不同进程收到请求的负载均衡问题，但是会带来响应请求的延迟，所以<code>Gunicorn</code>将这个配置设置为可选项（关于这几个参数以及惊群问题会另开文章说明）。 接着<code>Gunicorn</code>会调用<code>sock.bind</code>且设置<code>scoket</code>是不阻塞的，再进行监听，并返回给<code>Master</code>。 </p>
<p><code>Gunicorn</code>之所以这样做是因为<code>Gunicorn</code>是<code>Pre-Worker</code>模型的，在这个模型中， 所有的<code>scoket</code>都是由<code>Master</code>进程创建并监听，然后在通过<code>fork</code>子进程的时候把<code>scoket</code>传递给子进程，然后子进程可以通过该<code>scoket</code>可以进行<code>accept</code>获取到对应的请求。</p>
<h3 id="4-2-管理woeker数量–manage-workers"><a href="#4-2-管理woeker数量–manage-workers" class="headerlink" title="4.2.管理woeker数量–manage_workers"></a>4.2.管理woeker数量–manage_workers</h3><p>在<code>Gunicorn</code>的<code>Arbiter</code>中，通过<code>manage_workers</code>方法对<code>Worker</code>进行管理， 当前运行的<code>Worker</code>数量不满足与用户指定的数量时，会通过<code>spawn_workers</code>来调用<code>spawn_worker</code>创建<code>Worker</code>，<code>spawn_workers</code>是批量创建一批<code>Worker</code>，而<code>spawn_worker</code>是每次调用创建一个<code>Worker</code>,他们的代码十分简单, 具体说明见注释:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">spawn_worker</span>(<span class="hljs-params">self</span>):</span><br>    <span class="hljs-comment"># 每个新创建的Worker, age都加1, Worker越大，则代表越新</span><br>    self.worker_age += <span class="hljs-number">1</span><br>    <span class="hljs-comment"># 把一些参数传给worker</span><br>    worker = self.worker_class(self.worker_age, self.pid, self.LISTENERS,<br>                               self.app, self.timeout / <span class="hljs-number">2.0</span>,<br>                               self.cfg, self.log)<br>    self.cfg.pre_fork(self, worker)<br>    <span class="hljs-comment"># 开始Fork</span><br>    pid = os.fork()<br>    <span class="hljs-keyword">if</span> pid != <span class="hljs-number">0</span>:<br>        <span class="hljs-comment"># 对于主进程，记录创建的worker</span><br>        worker.pid = pid<br>        self.WORKERS[pid] = worker<br>        <span class="hljs-keyword">return</span> pid<br><br>    <span class="hljs-comment"># 对于创建的子进程</span><br>    <br>    <span class="hljs-comment"># 不继承其它worker的tmp文件</span><br>    <span class="hljs-keyword">for</span> sibling <span class="hljs-keyword">in</span> self.WORKERS.values():<br>        sibling.tmp.close()<br><br>    worker.pid = os.getpid()<br>    <span class="hljs-keyword">try</span>:<br>        util._setproctitle(<span class="hljs-string">&quot;worker [%s]&quot;</span> % self.proc_name)<br>        self.log.info(<span class="hljs-string">&quot;Booting worker with pid: %s&quot;</span>, worker.pid)<br>        self.cfg.post_fork(self, worker)<br>        <span class="hljs-comment"># 开始运行，在init_process方法编写worker的方法，因为__init__方法属于在主进程运行</span><br>        worker.init_process()<br>        <span class="hljs-comment"># exit 0 代表进程常退出</span><br>        sys.exit(<span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">except</span> SystemExit:<br>        <span class="hljs-keyword">raise</span><br>    <span class="hljs-keyword">except</span> AppImportError <span class="hljs-keyword">as</span> e:<br>        <span class="hljs-comment"># 初始化实例失败</span><br>        self.log.debug(<span class="hljs-string">&quot;Exception while loading the application&quot;</span>,<br>                       exc_info=<span class="hljs-literal">True</span>)<br>        print(<span class="hljs-string">&quot;%s&quot;</span> % e, file=sys.stderr)<br>        sys.stderr.flush()<br>        sys.exit(self.APP_LOAD_ERROR)<br>    <span class="hljs-keyword">except</span> Exception:<br>        <span class="hljs-comment"># 其它失败方法</span><br>        self.log.exception(<span class="hljs-string">&quot;Exception in worker process&quot;</span>)<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> worker.booted:<br>            sys.exit(self.WORKER_BOOT_ERROR)<br>        sys.exit(-<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">finally</span>:<br>        self.log.info(<span class="hljs-string">&quot;Worker exiting (pid: %s)&quot;</span>, worker.pid)<br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-comment"># 不管如何，都要关闭临时文件</span><br>            worker.tmp.close()<br>            self.cfg.worker_exit(self, worker)<br>        <span class="hljs-keyword">except</span> Exception:<br>            self.log.warning(<span class="hljs-string">&quot;Exception during worker exit:\n%s&quot;</span>,<br>                             traceback.format_exc())<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">spawn_workers</span>(<span class="hljs-params">self</span>):</span><br>    <span class="hljs-comment"># 判断现在还需要多少个worker, 并创建</span><br>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(self.num_workers - <span class="hljs-built_in">len</span>(self.WORKERS)):<br>        self.spawn_worker()<br>        <span class="hljs-comment"># 随机休息一段时间， 防止同时创建多个worker</span><br>        time.sleep(<span class="hljs-number">0.1</span> * random.random())<br></code></pre></td></tr></table></figure>
<p>在这里面中有两个注意点，第一个点是在<code>spawn_worker</code>中，会先初始化<code>worker</code>,接着在<code>fork</code>出子进程运行代码部分会先执行<code>worker.init_process</code>最后调用<code>sys.exit(0)</code>退出，所以我们最好不要在<code>worker.__init__</code>里面初始化数据，因为这部分是在<code>Master</code>进程中执行的。我们应该在<code>worker.init_process</code>中执行初始化,并在初始化代码执行后调用<code>super().init_process()</code>,如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">init_process</span>(<span class="hljs-params">self</span>):</span><br>    <span class="hljs-comment"># 初始化代码</span><br>    <span class="hljs-built_in">super</span>().init_process()<br></code></pre></td></tr></table></figure>
<p>这样做是因为<code>BaseWorker</code>会在自己的<code>init_process</code>方法中执行一些通用的初始化功能，然后再调用<code>BaseWorker.run</code>来运行<code>Worker</code>。</p>
<h3 id="4-3-核心循环与信号处理"><a href="#4-3-核心循环与信号处理" class="headerlink" title="4.3.核心循环与信号处理"></a>4.3.核心循环与信号处理</h3><p>在经过<code>manage_workers</code>后，<code>Worker</code>都已经以子进程的形式在运行了，但是<code>Master</code>进程还需要处理一些家务事，比如管理<code>Worker</code>进程是否存活以及用户在运行时指派给<code>Master</code>的一些工作等，而这些将通过信号来进行交互。</p>
<p>这个阶段的<code>Master</code>以一个循环不断的跑着， 如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    <span class="hljs-comment"># 3.负责判断该进程是否是正真的master，如果是则提升为正真的master(这一块放在最后一部分进行分析)</span><br>    self.maybe_promote_master()<br><br>    <span class="hljs-comment"># 4.获取信号</span><br>    sig = self.SIG_QUEUE.pop(<span class="hljs-number">0</span>) <span class="hljs-keyword">if</span> self.SIG_QUEUE <span class="hljs-keyword">else</span> <span class="hljs-literal">None</span><br>    <span class="hljs-keyword">if</span> sig <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>        <span class="hljs-comment"># 5.利用select休眠1小时</span><br>        self.sleep()<br>        <span class="hljs-comment"># 6.判断worker是否超时，如果是则杀掉worker(将在Worker章节进行分析) </span><br>        self.murder_workers()<br>        self.manage_workers()<br>        <span class="hljs-keyword">continue</span><br><br>    <span class="hljs-keyword">if</span> sig <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> self.SIG_NAMES:<br>        self.log.info(<span class="hljs-string">&quot;Ignoring unknown signal: %s&quot;</span>, sig)<br>        <span class="hljs-keyword">continue</span><br><br>    signame = self.SIG_NAMES.get(sig)<br>    <span class="hljs-comment"># 调用对应的信号处理</span><br>    handler = <span class="hljs-built_in">getattr</span>(self, <span class="hljs-string">&quot;handle_%s&quot;</span> % signame, <span class="hljs-literal">None</span>)<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> handler:<br>        self.log.error(<span class="hljs-string">&quot;Unhandled signal: %s&quot;</span>, signame)<br>        <span class="hljs-keyword">continue</span><br>    self.log.info(<span class="hljs-string">&quot;Handling signal: %s&quot;</span>, signame)<br>    handler()<br>    <span class="hljs-comment"># 7.这样下次循环就不会等待一秒了</span><br>    self.wakeup()<br></code></pre></td></tr></table></figure>
<p>它的运行逻辑很简单，首先是判断当前进程是不是真的主进程，如果是将晋升为主进程，然后就是获取信号，如果当前信号队列有信号存在就取最前的一个并执行对应的信号对用以及调用<code>wakeup</code>方法，防止下次循环还在睡眠；如果获取不到信号，就先休眠1秒，然后清除超时的<code>Worker</code>最后执行<code>manage_worker</code>并进入下个循环。</p>
<p>在<code>Gunicorn</code>中，它确保每个循环只执行一次操作，确保该循环要不就执行信号回调，要不就执行<code>Worker</code>管理，同时它还确保执行信号回调的优先级是最高的，但是<code>Gunicorn</code>对传入的信号的数量也有限制，通过<code>4.1.初始化--Arbiter.start</code>的源码:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">signal</span>(<span class="hljs-params">self, sig, frame</span>):</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(self.SIG_QUEUE) &lt; <span class="hljs-number">5</span>:<br>        self.SIG_QUEUE.append(sig)<br>        self.wakeup()<br></code></pre></td></tr></table></figure>
<p>中可以知道，<code>Gunicorn</code>只允许最多有5个信号在队列中，防止同一时刻执行太多了信号处理，同时可以看到在正常接收信号后会执行<code>wakeup</code>函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">wakeup</span>(<span class="hljs-params">self</span>):</span><br>    <span class="hljs-keyword">try</span>:<br>        os.write(self.PIPE[<span class="hljs-number">1</span>], <span class="hljs-string">b&#x27;.&#x27;</span>)<br>    <span class="hljs-keyword">except</span> IOError <span class="hljs-keyword">as</span> e:<br>        <span class="hljs-keyword">if</span> e.errno <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> [errno.EAGAIN, errno.EINTR]:<br>            <span class="hljs-keyword">raise</span><br></code></pre></td></tr></table></figure>
<p>这个函数十分简单，就是往管道<code>PIPE</code>写入了一个字节，这样就能快速唤醒<code>Gunicorn</code>继续运行循环，不会停留在<code>sleep</code>阶段。<br>单看<code>wakeup</code>函数是无法理解它为啥能唤醒<code>Gunicorn</code>的主循环的， 需要结合<code>Arbiter.sleep</code>源码来了解<code>Gunicorn</code>为何这样设计。</p>
<p>通常情况下，我们都会使用<code>Python</code>的标准函数<code>time.sleep</code>来实现进程睡眠，但是该函数是阻塞的，意味着该函数运行期间是没办法通过其它方法来进行打断，所以<code>Gunicorn</code>采用了事件循环的思路实现<code>Arbiter.sleep</code>，该通过使用<code>select.select</code>来读取<code>PIPE</code>,同时设置超时为1秒，<code>sleep</code>源码如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sleep</span>(<span class="hljs-params">self</span>):</span><br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-comment"># 等待事件返回</span><br>        ready = select.select([self.PIPE[<span class="hljs-number">0</span>]], [], [], <span class="hljs-number">1.0</span>)<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> ready[<span class="hljs-number">0</span>]:<br>            <span class="hljs-comment"># 没有事件代表超时了</span><br>            <span class="hljs-keyword">return</span><br>        <span class="hljs-comment"># 获取剩余的事件，不然下次的sleep是无效的</span><br>        <span class="hljs-keyword">while</span> os.read(self.PIPE[<span class="hljs-number">0</span>], <span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">pass</span><br>    <span class="hljs-keyword">except</span> (select.error, OSError) <span class="hljs-keyword">as</span> e:<br>        <span class="hljs-comment"># <span class="hljs-doctag">TODO:</span> select.error is a subclass of OSError since Python 3.3.</span><br>        error_number = <span class="hljs-built_in">getattr</span>(e, <span class="hljs-string">&#x27;errno&#x27;</span>, e.args[<span class="hljs-number">0</span>])<br>        <span class="hljs-comment"># 如果是中断或者重试错误，则直接return</span><br>        <span class="hljs-keyword">if</span> error_number <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> [errno.EAGAIN, errno.EINTR]:<br>            <span class="hljs-keyword">raise</span><br>    <span class="hljs-keyword">except</span> KeyboardInterrupt:<br>        sys.exit()<br></code></pre></td></tr></table></figure>
<p>在这段逻辑中，会把<code>PIPE</code>的读文件描述符传给<code>select.select</code>中,这样<code>select.select</code>会等待<code>PIPE</code>的事件再返回，同时它的最大等待时间为1秒，之后这段运行逻辑会停留在这里，但并不会阻塞当前进程，如果这时候进程有收到信号，进程还是可以正常接收信号, 并通过<code>wakeup</code>函数往<code>PIPE</code>写入一个字节，接着<code>select.select</code>就能通过<code>PIPE</code>捕获到事件并返回，这时候上面停留的代码逻辑就会继续执行，等于<code>sleep</code>函数可以提前结束等待，<code>Gunicorn</code>的主循环能继续转了。</p>
<blockquote>
<p>这一段主要是依赖于事件循环相关来防止主进程被阻塞，可以通过搜索<code>事件循环</code>，<code>epoll</code>来了解更多相关的。<br>如果想知道如何在阻塞代码中实现一个协程，可以通过文章–<a href="https://so1n.me/2021/11/08/%E5%88%9D%E8%AF%86Python%20Async%E7%9A%84%E5%AE%9E%E7%8E%B0/">初识Python协程的实现</a>了解</p>
</blockquote>
<h2 id="5-无感切换实例"><a href="#5-无感切换实例" class="headerlink" title="5.无感切换实例"></a>5.无感切换实例</h2><p>在分析<code>Arbiter</code>，有几处都是先忽略跳过不分析，这部分的功能我把他称为无感切换新实例，这里的无感是指与<code>Gunicorn</code>绑定的scoket交互的应用程序，如<code>Nginx</code>或者客户端等。<br>这个功能可以使<code>Gunicorn</code>的实例在运行的时候，重新开一个新的<code>Gunicorn</code>实例来运行我们指定的代码，这时候读取的代码和配置都是最新的，与我们当前正在运行的旧实例不一样，但是他们都能针对同一批socket处理请求(可用于滚动发布以及灰度发布)。</p>
<blockquote>
<p>为了方便阐述，我把一个<code>Master</code>进程与它fork出来的<code>Worker</code>进程统称为一个实例。</p>
</blockquote>
<p>实际上官方把这个功能称为：<a href="https://docs.gunicorn.org/en/stable/signals.html#upgrading-to-a-new-binary-on-the-fly">Upgrading to a new binary on the fly</a>，这个功能是大多数<code>Pre-Worker</code>模型的服务器都会支持的，不过这个功能需要多块不同生命周期的代码来结合才可以完成，所以单独拎出来分析。</p>
<p>根据文档：</p>
<blockquote>
<p>First, replace the old binary with a new one, then send a USR2 signal to the current master process. It executes a new binary whose PID file is postfixed with .2 (e.g. /var/run/gunicorn.pid.2), which in turn starts a new master process and new worker processes</p>
</blockquote>
<p>可以知道，<code>Master</code>进程在收到<code>USR2</code>的信号后，会创建一个新的实例，这部分的源代码如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">handle_usr2</span>(<span class="hljs-params">self</span>):</span><br>    <span class="hljs-comment"># 收到信号，执行对应的函数 </span><br>    self.reexec()<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reexec</span>(<span class="hljs-params">self</span>):</span><br>    <span class="hljs-comment"># 防止多个信号同时处理</span><br>    <span class="hljs-keyword">if</span> self.reexec_pid != <span class="hljs-number">0</span>:<br>        self.log.warning(<span class="hljs-string">&quot;USR2 signal ignored. Child exists.&quot;</span>)<br>        <span class="hljs-keyword">return</span><br><br>    <span class="hljs-keyword">if</span> self.master_pid != <span class="hljs-number">0</span>:<br>        self.log.warning(<span class="hljs-string">&quot;USR2 signal ignored. Parent exists.&quot;</span>)<br>        <span class="hljs-keyword">return</span><br><br>    master_pid = os.getpid()<br>    self.reexec_pid = os.fork()<br>    <span class="hljs-keyword">if</span> self.reexec_pid != <span class="hljs-number">0</span>:<br>        <span class="hljs-comment"># 对于主进程，不用再执行对应的代码</span><br>        <span class="hljs-keyword">return</span><br><br>    <span class="hljs-comment"># 对于fork出来的子进程，执行的代码逻辑</span><br>    self.cfg.pre_exec(self)<br><br>    <span class="hljs-comment"># 复制当前Master进程初始化时的环境变量（不被后面运行时的变量影响）</span><br>    environ = self.cfg.env_orig.copy()<br>    <span class="hljs-comment"># 设置当前Master进程的PID</span><br>    environ[<span class="hljs-string">&#x27;GUNICORN_PID&#x27;</span>] = <span class="hljs-built_in">str</span>(master_pid)<br><br>    <span class="hljs-comment"># 设置文件描述符地址到环境变量</span><br>    <span class="hljs-keyword">if</span> self.systemd:<br>        environ[<span class="hljs-string">&#x27;LISTEN_PID&#x27;</span>] = <span class="hljs-built_in">str</span>(os.getpid())<br>        environ[<span class="hljs-string">&#x27;LISTEN_FDS&#x27;</span>] = <span class="hljs-built_in">str</span>(<span class="hljs-built_in">len</span>(self.LISTENERS))<br>    <span class="hljs-keyword">else</span>:<br>        environ[<span class="hljs-string">&#x27;GUNICORN_FD&#x27;</span>] = <span class="hljs-string">&#x27;,&#x27;</span>.join(<br>            <span class="hljs-built_in">str</span>(l.fileno()) <span class="hljs-keyword">for</span> l <span class="hljs-keyword">in</span> self.LISTENERS)<br><br>    <span class="hljs-comment"># 更改cwd</span><br>    os.chdir(self.START_CTX[<span class="hljs-string">&#x27;cwd&#x27;</span>])<br><br>    <span class="hljs-comment"># exec the process using the original environment</span><br>    <span class="hljs-comment"># Gunicorn通过os.execvpe来运行一个新的Master进程</span><br>    <span class="hljs-comment"># execvpe会通过PATH环境变量来查找用户指定的程序，并用当前的Python运行环境来运行程序，同时使用的是指定的环境变量</span><br>    <span class="hljs-comment"># 其中用到的参数分别是：</span><br>    <span class="hljs-comment">#   0是当前的Python运行环境</span><br>    <span class="hljs-comment">#   args是参数</span><br>    <span class="hljs-comment">#   environ是环境变量</span><br>    os.execvpe(self.START_CTX[<span class="hljs-number">0</span>], self.START_CTX[<span class="hljs-string">&#x27;args&#x27;</span>], environ)<br></code></pre></td></tr></table></figure>
<p>按官方文档的示例，当<code>Gunicorn</code>执行完这段逻辑后，就有一个新的<code>Gunicorn</code>实例开始运行了，由于这个实例的环境变量中存在一个<code>GUNICORN_PID</code>的变量， 所以在运行时会有一些不一样， 比如在<code>Arbiter.start</code>进行初始化时会设置不一样的属性:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">start</span>(<span class="hljs-params">self</span>):</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;GUNICORN_PID&#x27;</span> <span class="hljs-keyword">in</span> os.environ:<br>        <span class="hljs-comment"># 代表这是一个被一个master进程创建的master进程</span><br>        self.master_pid = <span class="hljs-built_in">int</span>(os.environ.get(<span class="hljs-string">&#x27;GUNICORN_PID&#x27;</span>))<br>        self.proc_name = self.proc_name + <span class="hljs-string">&quot;.2&quot;</span><br>        self.master_name = <span class="hljs-string">&quot;Master.2&quot;</span><br><br>    self.pid = os.getpid()<br>    <span class="hljs-keyword">if</span> self.cfg.pidfile <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>        pidname = self.cfg.pidfile<br>        <span class="hljs-keyword">if</span> self.master_pid != <span class="hljs-number">0</span>:<br>            pidname += <span class="hljs-string">&quot;.2&quot;</span><br>            <span class="hljs-comment"># 重新启动时创建新的pidfile</span><br>        self.pidfile = Pidfile(pidname)<br>        self.pidfile.create(self.pid)<br></code></pre></td></tr></table></figure>
<p>同时，在初始化scoket时，还会沿用环境变量中名为<code>GUNICORN_FD</code>的值，这个值是创建这个实例的<code>Master</code>进程用到的文件描述符，新创建的实例通过复用相同的文件描述符，使其它也能读取到相同端口的网络请求数据：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">start</span>(<span class="hljs-params">self</span>):</span><br>    ...<br>    <span class="hljs-comment"># 省去之前的代码</span><br>    <span class="hljs-keyword">elif</span> self.master_pid:<br>        <span class="hljs-comment"># 获取之前进程的fd</span><br>        fds = []<br>        <span class="hljs-keyword">for</span> fd <span class="hljs-keyword">in</span> os.environ.pop(<span class="hljs-string">&#x27;GUNICORN_FD&#x27;</span>).split(<span class="hljs-string">&#x27;,&#x27;</span>):<br>            fds.append(<span class="hljs-built_in">int</span>(fd))<br><br>    self.LISTENERS = sock.create_sockets(self.cfg, self.log, fds)<br></code></pre></td></tr></table></figure>
<p>在新创建的实例运行后， 机器上的<code>Gunicorn</code>进程列表将变为这样子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-comment"># 来自官方文档</span><br>  PID USER      PR  NI  VIRT  RES  SHR S  %CPU %MEM    TIME+  COMMAND<br><span class="hljs-number">20844</span> benoitc   <span class="hljs-number">20</span>   <span class="hljs-number">0</span> <span class="hljs-number">54808</span>  11m <span class="hljs-number">3352</span> S   <span class="hljs-number">0.0</span>  <span class="hljs-number">0.1</span>   <span class="hljs-number">0</span>:<span class="hljs-number">00.36</span> gunicorn: master [test:app]<br><span class="hljs-number">20849</span> benoitc   <span class="hljs-number">20</span>   <span class="hljs-number">0</span> <span class="hljs-number">54808</span> <span class="hljs-number">9.9</span>m <span class="hljs-number">1500</span> S   <span class="hljs-number">0.0</span>  <span class="hljs-number">0.1</span>   <span class="hljs-number">0</span>:<span class="hljs-number">00.02</span> gunicorn: worker [test:app]<br><span class="hljs-number">20850</span> benoitc   <span class="hljs-number">20</span>   <span class="hljs-number">0</span> <span class="hljs-number">54808</span> <span class="hljs-number">9.9</span>m <span class="hljs-number">1500</span> S   <span class="hljs-number">0.0</span>  <span class="hljs-number">0.1</span>   <span class="hljs-number">0</span>:<span class="hljs-number">00.01</span> gunicorn: worker [test:app]<br><span class="hljs-number">20851</span> benoitc   <span class="hljs-number">20</span>   <span class="hljs-number">0</span> <span class="hljs-number">54808</span> <span class="hljs-number">9.9</span>m <span class="hljs-number">1500</span> S   <span class="hljs-number">0.0</span>  <span class="hljs-number">0.1</span>   <span class="hljs-number">0</span>:<span class="hljs-number">00.01</span> gunicorn: worker [test:app]<br><span class="hljs-number">20854</span> benoitc   <span class="hljs-number">20</span>   <span class="hljs-number">0</span> <span class="hljs-number">55748</span>  12m <span class="hljs-number">3348</span> S   <span class="hljs-number">0.0</span>  <span class="hljs-number">0.2</span>   <span class="hljs-number">0</span>:<span class="hljs-number">00.35</span> gunicorn: master [test:app]<br><span class="hljs-number">20859</span> benoitc   <span class="hljs-number">20</span>   <span class="hljs-number">0</span> <span class="hljs-number">55748</span>  11m <span class="hljs-number">1500</span> S   <span class="hljs-number">0.0</span>  <span class="hljs-number">0.1</span>   <span class="hljs-number">0</span>:<span class="hljs-number">00.01</span> gunicorn: worker [test:app]<br><span class="hljs-number">20860</span> benoitc   <span class="hljs-number">20</span>   <span class="hljs-number">0</span> <span class="hljs-number">55748</span>  11m <span class="hljs-number">1500</span> S   <span class="hljs-number">0.0</span>  <span class="hljs-number">0.1</span>   <span class="hljs-number">0</span>:<span class="hljs-number">00.00</span> gunicorn: worker [test:app]<br><span class="hljs-number">20861</span> benoitc   <span class="hljs-number">20</span>   <span class="hljs-number">0</span> <span class="hljs-number">55748</span>  11m <span class="hljs-number">1500</span> S   <span class="hljs-number">0.0</span>  <span class="hljs-number">0.1</span>   <span class="hljs-number">0</span>:<span class="hljs-number">00.01</span> gunicorn: worker [test:app]<br></code></pre></td></tr></table></figure>
<p>从这个进程列表可以发现目前有两个<code>Master</code>进程，他们分别有3个<code>Worker</code>子进程，这时候两个实例是一起运行的，如果指定的代码文件没有进行修改，指定的配置也没变，那么这两个实例的逻辑可以认为是等效的。</p>
<p>当用户判断新的实例能正常处理请求后， 可以发送信号<code>TERM</code>给旧实例的<code>Master</code>，让它开始优雅的关闭<code>Worker</code>并退出，然后新创建的实例的<code>Master</code>进程会在核心循环中发现创建自己的父进程已经退出了， 就让自己晋升为真正名义上的<code>Master</code>进程，源码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">maybe_promote_master</span>(<span class="hljs-params">self</span>):</span><br>    <span class="hljs-keyword">if</span> self.master_pid == <span class="hljs-number">0</span>:<br>        <span class="hljs-comment"># 已经是真正的`Master`进程，直接返回</span><br>        <span class="hljs-keyword">return</span><br><br>    <span class="hljs-keyword">if</span> self.master_pid != os.getppid():<br>        <span class="hljs-comment"># 该进程是从之前的主进程派生的，获取不到父进程id证明父进程被kill了  这时自己将晋升为主进程</span><br>        self.log.info(<span class="hljs-string">&quot;Master has been promoted.&quot;</span>)<br>        <span class="hljs-comment"># 设置属性，标明自己是正真的Master</span><br>        <span class="hljs-comment"># reset master infos</span><br>        self.master_name = <span class="hljs-string">&quot;Master&quot;</span><br>        self.master_pid = <span class="hljs-number">0</span><br>        self.proc_name = self.cfg.proc_name<br>        <span class="hljs-keyword">del</span> os.environ[<span class="hljs-string">&#x27;GUNICORN_PID&#x27;</span>]<br>        <span class="hljs-comment"># rename the pidfile</span><br>        <span class="hljs-keyword">if</span> self.pidfile <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            self.pidfile.rename(self.cfg.pidfile)<br>        <span class="hljs-comment"># reset proctitle</span><br>        util._setproctitle(<span class="hljs-string">&quot;master [%s]&quot;</span> % self.proc_name)<br></code></pre></td></tr></table></figure>
<p>通过源码可以发现，无论新实例有没有通过<code>may_be_promote_master</code>晋升为名义上的<code>Master</code>进程， 总体上的逻辑跟原先的<code>Master</code>进程是一样的，只不过是没办法通过接受<code>USR2</code>信号来创建新的实例。</p>
<blockquote>
<p>通过这种方式可以无感的升级应用代码，结合其它的信号，在升级失败时也能关闭新创建的实例，切回到旧实例，具体可以通过<a href="https://docs.gunicorn.org/en/stable/signals.html#upgrading-to-a-new-binary-on-the-fly">Upgrading to a new binary on the fly</a>了解。</p>
</blockquote>
<h2 id="6-Worker与Master的交互"><a href="#6-Worker与Master的交互" class="headerlink" title="6.Worker与Master的交互"></a>6.Worker与Master的交互</h2><p>分析完了<code>Arbiter</code>后，整个<code>Gunicorn</code>的核心还剩下<code>Worker</code>尚未分析，<code>Gunicorn</code>中带了多种<code>Worker</code>，比如用在<code>gevent</code>场景的<code>Worker.ggevent.GeventWorker</code>，用在<code>Tornado</code>的<code>Worker.gtornado.TornadoWorker</code>。这些<code>Worker</code>除了一些与<code>Arbiter</code>交互的方法外， 还有一些方法用来通过读取<code>scoket</code>的数据并转化为<code>WSGI</code>协议发给挂在后面的<code>WSGI</code>应用，这意味着<code>Gunicorn</code>不仅用于<code>WSGI</code>场景，还可以通过自己编写<code>Worker</code>来对接其它的场景，比如<code>Uvicorn.Worker</code>就是对接<code>ASGI</code>应用等。</p>
<blockquote>
<p>由于我在分析<code>Gunicorn</code>时，我是抱着使用<code>Gunicorn</code>来托管我的TCP服务的，所以我是着重了解<code>Worker</code>与<code>Arbiter</code>的交互，对于自带的其它<code>Worker</code>,则不多做说明(通过了解<code>WSGI</code>协议也能了解它们的执行逻辑)。</p>
</blockquote>
<p><code>Worker</code>与<code>Arbiter</code>的交互可以简化为如下图:</p>
<p><img    class="lazyload" data-original="https://s2.loli.net/2022/03/01/arnM8u2DIfjxHU7.jpg" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">Gunicorn源码分析-Worker与Arbiter交互</span></p>
<p>图中蓝色和绿色线条代表两种类型的信号交互，黑色代表其它的<code>Master</code>进程与<code>Worker</code>进程的交互。</p>
<h3 id="6-1-基于信号的交互"><a href="#6-1-基于信号的交互" class="headerlink" title="6.1.基于信号的交互"></a>6.1.基于信号的交互</h3><p>在图中见到了已经在<code>4.2.管理worker数量--manager-workers</code>说过的<code>manage_workers</code>，它除了在<code>Arbiter</code>中会调用<code>manage_workers</code>进行<code>Worker</code>初始化，之后会在接收到用户发起信号的时候调用<code>manage_worker</code>来进行增减。这类型信号更改<code>Worker</code>数量有两种， 一种是修改配置的<code>Worker</code>数量， 然后通过信号<code>HUP</code>重载配置:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">handle_hup</span>(<span class="hljs-params">self</span>):</span><br>    self.log.info(<span class="hljs-string">&quot;Hang up: %s&quot;</span>, self.master_name)<br>    self.reload()<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reload</span>(<span class="hljs-params">self</span>):</span><br>    ...<br>    <span class="hljs-comment"># 省略其它代码</span><br><br>    <span class="hljs-comment"># spawn new workers</span><br>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(self.cfg.workers):<br>        self.spawn_worker()<br><br>    <span class="hljs-comment"># manage workers</span><br>    self.manage_workers()<br></code></pre></td></tr></table></figure>

<p>另外一种就是通过信号<code>TTIN</code>和<code>TTOU</code>来更改数量的加减：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">handle_ttin</span>(<span class="hljs-params">self</span>):</span><br>    self.num_workers += <span class="hljs-number">1</span><br>    self.manage_workers()<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">handle_ttou</span>(<span class="hljs-params">self</span>):</span><br>    <span class="hljs-keyword">if</span> self.num_workers &lt;= <span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">return</span><br>    self.num_workers -= <span class="hljs-number">1</span><br>    self.manage_workers()<br></code></pre></td></tr></table></figure>

<p>此外，<code>Master</code>除了接收用户的信号外，还接收自己创建的<code>Worker</code>进程的信号，当<code>Worker</code>进程退出时，会发送信号<code>CHLD</code>给<code>Master</code>进程，<code>Master</code>进程会调用<code>reap_worker</code>来回收对应<code>Worker</code>的进程资源, <code>reap_worker</code>源码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reap_workers</span>(<span class="hljs-params">self</span>):</span><br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-comment"># 注意信号不排队的问题，你可以循环检查waitpid()子进程的状态. </span><br>        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>            <span class="hljs-comment"># 获取僵死子进程的信息</span><br>            wpid, status = os.waitpid(-<span class="hljs-number">1</span>, os.WNOHANG)<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> wpid:<br>                <span class="hljs-keyword">break</span><br>            <span class="hljs-keyword">if</span> self.reexec_pid == wpid:<br>                self.reexec_pid = <span class="hljs-number">0</span><br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-comment"># A worker was terminated. If the termination reason was</span><br>                <span class="hljs-comment"># that it could not boot, we&#x27;ll shut it down to avoid</span><br>                <span class="hljs-comment"># infinite start/stop cycles.</span><br>                exitcode = status &gt;&gt; <span class="hljs-number">8</span><br>                <span class="hljs-keyword">if</span> exitcode == self.WORKER_BOOT_ERROR:<br>                    reason = <span class="hljs-string">&quot;Worker failed to boot.&quot;</span><br>                    <span class="hljs-keyword">raise</span> HaltServer(reason, self.WORKER_BOOT_ERROR)<br>                <span class="hljs-keyword">if</span> exitcode == self.APP_LOAD_ERROR:<br>                    reason = <span class="hljs-string">&quot;App failed to load.&quot;</span><br>                    <span class="hljs-keyword">raise</span> HaltServer(reason, self.APP_LOAD_ERROR)<br>                <span class="hljs-comment"># WIFSIGNALED(status)为非0表明进程异常终止，记录异常信息。 </span><br>                <span class="hljs-keyword">if</span> os.WIFSIGNALED(status):<br>                    self.log.warning(<br>                        <span class="hljs-string">&quot;Worker with pid %s was terminated due to signal %s&quot;</span>,<br>                        wpid,<br>                        os.WTERMSIG(status)<br>                    )<br><br>                <span class="hljs-comment"># 清除Master进程的数据</span><br>                worker = self.WORKERS.pop(wpid, <span class="hljs-literal">None</span>)<br>                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> worker:<br>                    <span class="hljs-keyword">continue</span><br>                <span class="hljs-comment"># 关闭临时文件</span><br>                worker.tmp.close()<br>                self.cfg.child_exit(self, worker)<br>    <span class="hljs-keyword">except</span> OSError <span class="hljs-keyword">as</span> e:<br>        <span class="hljs-comment"># errno.ECHILD代表调用进程没有任何子进程，该类型的错误不应该报错</span><br>        <span class="hljs-keyword">if</span> e.errno != errno.ECHILD:<br>            <span class="hljs-keyword">raise</span><br></code></pre></td></tr></table></figure>
<p>这段代码实际上是为了解决一个类Unix系统等待终止子进程的问题， 该问题是如果子进程在终止过程中，子进程完全消失了，就没有给父进程留下任何可以来了解子进程的东西,父进程没办法清理与子进程相关的数据，所以类Unix系统有这样一个设计：如果子进程在父进程之前结束会先发送信号给父进程，然后内核会把子进程设置为一个特殊的状态，处于这个状态的进程叫做僵尸进程，这类进程只保留最小的概要信息并等待分进程来查询自己的信息，只要父进程获取了子进程的信息后，子进程就会消失，否则会一直保持僵死状态(zombie)。其中父进程获取子进程的信息有多种方式，在<code>Gunicorn</code>是采用<code>waitpid</code>来获取子进程的信息，而<code>reap_workers</code>的主要责任就是通过<code>waitpid</code>获取子进程信息并做出响应。</p>
<p>在<code>Gunicorn</code>中，采用<code>waitpid</code>来获取僵死进程的状态和信息，但是直接使用<code>waitpid</code>会暂时停止目前进程的执行，直到有信号来到或者有子进程结束，所以使用了<code>WHOHANG</code>标记，该标记表示如果没有任何已经结束的子进程也马上返回结果，不等待。<code>Gunicorn</code>通过使用该标记以及循环的方式来解决可能同时出现多个进程变为僵死状态的问题。</p>
<p>此外<code>Gunicorn</code>在<code>waitpid</code>中传了一个参数值<code>-1</code>,这个参数的名为<code>pid</code>，输入不同的值有不同的意义：</p>
<ul>
<li>pid&gt;0时，只等待进程ID等于pid的子进程，不管其它已经有多少子进程运行结束退出了，只要指定的子进程还没有结束，waitpid就会一直等下去。</li>
<li>pid=-1时，等待任何一个子进程退出，没有任何限制，此时waitpid和wait的作用一模一样。</li>
<li>pid=0时，等待同一个进程组中的任何子进程，如果子进程已经加入了别的进程组，waitpid不会处理它。</li>
<li>pid&lt;-1时，等待一个指定进程组中的任何子进程，这个进程组的ID等于pid的绝对值。</li>
</ul>
<p><code>Gunicorn</code>在通过<code>waitpid</code>获取到的返回信息中第一个pid代表退出进程的pid, 如果为空就代表没有子进程退出，应该直接退出逻辑返回到循环中，第二个status它包含了一些子进程的附加信息，该参数的高8位记录进程调用exit退出的状态，低8位记录进程接收到的信号，如果是正常退出，高8位数为退出状态，低8位数为0,如果是非正常退出，高8位数为0，低8位数为信号id，所以<code>Gunicorn</code>会通过<code>status &gt;&gt; 8</code>来获取低8位的数据，且当它不为0时就判断是否是自己定义的特殊信号，如果是则按照信号进行抛异常。</p>
<h3 id="6-2-Master进程主动检测"><a href="#6-2-Master进程主动检测" class="headerlink" title="6.2.Master进程主动检测"></a>6.2.Master进程主动检测</h3><p>上面说到<code>Master</code>进程虽然可以收到子进程退出时发出的<code>CHLD</code>信号，但是并不是所有子进程退出时都能发出<code>CHLD</code>信号，所以<code>Master</code>进程还需要做到主动检测，<code>Gunicorn</code>在主动检查中用到了一个比较奇特的方法–临时文件的最后修改时间，该方法是通过<code>Worker</code>进程每隔一段时间更新临时文件的最后修改时间，<code>Master</code>进程每隔一段时间就去检测最后修改时间是否在一段范围内， 如果不合法就剔除这个<code>Worker</code>进程。</p>
<blockquote>
<p>这种方式挺让人困惑的，同时容易引起性能问题，具体见<a href="https://docs.gunicorn.org/en/stable/faq.html#how-do-i-avoid-gunicorn-excessively-blocking-in-os-fchmod">How do I avoid Gunicorn excessively blocking in os.fchmod?</a>，目前官方表示可能会进行改进， 见<code>Gunicorn</code>中的一条<a href="https://github.com/benoitc/gunicorn/issues/1305">issue</a></p>
</blockquote>
<p>这个检测是思路通过<code>WorkerTmp</code>类来实现，它的源码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WorkerTmp</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, cfg</span>):</span><br>        ...<br>        <span class="hljs-comment"># 省略代码，这一步只是做初始化 </span><br>        self.spinner = <span class="hljs-number">0</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">notify</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-comment"># 通过更改权限的方式更新修改时间</span><br>        self.spinner = (self.spinner + <span class="hljs-number">1</span>) % <span class="hljs-number">2</span><br>        os.fchmod(self._tmp.fileno(), self.spinner)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">last_update</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-comment"># 获取文件描述符的修改时间</span><br>        <span class="hljs-keyword">return</span> os.fstat(self._tmp.fileno()).st_ctime<br></code></pre></td></tr></table></figure>
<p>它会在<code>Worker</code>初始化时实例化为<code>Worker.tmp</code>属性，对于<code>Worker</code>进程，必须在<code>self.timeout / 2</code>的时间间隔调用<code>tmp.notify</code>来更新修改文件的更新时间；对于<code>Master</code>则通过<code>tmp.last_update</code>来获取临时文件的最后修改时间，以此判断<code>Worker</code>是否还存活，这部分就是示例图中的<code>murder_workers</code>,它的源码如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">murder_workers</span>(<span class="hljs-params">self</span>):</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self.timeout:<br>        <span class="hljs-keyword">return</span><br>    workers = <span class="hljs-built_in">list</span>(self.WORKERS.items())<br>    <span class="hljs-keyword">for</span> (pid, worker) <span class="hljs-keyword">in</span> workers:<br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-comment"># 通过临时文件的最后更新时间判断是否合法</span><br>            <span class="hljs-keyword">if</span> time.time() - worker.tmp.last_update() &lt;= self.timeout:<br>                <span class="hljs-keyword">continue</span><br>        <span class="hljs-keyword">except</span> (OSError, ValueError):<br>            <span class="hljs-keyword">continue</span><br><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> worker.aborted:<br>            <span class="hljs-comment"># 第一次发现不合法，发送警告指令</span><br>            self.log.critical(<span class="hljs-string">&quot;WORKER TIMEOUT (pid:%s)&quot;</span>, pid)<br>            worker.aborted = <span class="hljs-literal">True</span><br>            <span class="hljs-comment"># 发送ABRT信号</span><br>            self.kill_worker(pid, signal.SIGABRT)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-comment"># 第二次发现不合法，关闭进程</span><br>            self.kill_worker(pid, signal.SIGKILL)<br></code></pre></td></tr></table></figure>

<h2 id="7-总结"><a href="#7-总结" class="headerlink" title="7.总结"></a>7.总结</h2><p>至此，<code>Gunicorn</code>的主核心逻辑源码分析已经分析完毕了，可以发现<code>Gunicorn</code>就是一个大管家，会把获取网络请求的功能下放给下面工作的<code>Worker</code>，自己只负责一些<code>Worker</code>的管理等功能。 同时可以发现<code>Gunicorn</code>并不只是<code>WSGI</code>服务，通过自定义<code>Worker</code>，它也可以挂载TCP之类的应用。</p>
]]></content>
      <categories>
        <category>源码分析</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python-gRPC实践（2）--Protocol Buffer</title>
    <url>/2022/02/05/Python-gRPC%E5%AE%9E%E8%B7%B5(2)--Protocol%20buffer/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在上一文<a href="https://so1n.me/2022/01/05/Python-gRPC%E5%AE%9E%E8%B7%B5(1)--%E7%AE%80%E4%BB%8B/">Python-gRPC实践（1）–gRPC简介</a>简单的介绍了<code>gRPC</code>采用了<code>HTTP2</code>作为它的传输协议，以及<code>gRPC</code>是如何通过<code>HTTP2</code>传输数据的，而本文则着重介绍<code>gRPC</code>所采用的序列化协议–<code>Protocol Buffer</code>。</p>
<span id="more"></span>
<h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.介绍"></a>1.介绍</h2><h3 id="1-1-什么是Protocol-Buffer"><a href="#1-1-什么是Protocol-Buffer" class="headerlink" title="1.1.什么是Protocol Buffer"></a>1.1.什么是Protocol Buffer</h3><p>Protobuf(Google Protocol Buffers)是Google开发的跨语言，跨平台，可扩展，用于序列化结构化数据的数据传输协议，目前已经被广泛用于服务端和客户端间的数据传输，要在项目中把<code>gRPC</code>用得好就必须先清晰理解Protocol Buffer的使用以及语法。</p>
<blockquote>
<p>NOTE: Protobuf就像Json一样可以独立使用,不局限于<code>gRPC</code>这个场景之中，我们可以基于Protobuf实现自己的数据序列化/反序列化。</p>
</blockquote>
<h3 id="1-2-gRPC为什么要采用Protocol-Buffer做序列化协议"><a href="#1-2-gRPC为什么要采用Protocol-Buffer做序列化协议" class="headerlink" title="1.2.gRPC为什么要采用Protocol Buffer做序列化协议"></a>1.2.gRPC为什么要采用Protocol Buffer做序列化协议</h3><p><code>gRPC</code>早期只支持Protobuf，最新的版本已经开始支持Json了，但是没有多少人使用。为什么<code>gRPC</code>一开始要选择Protobuf呢，有一个很重要的原因是Protobuf同样也是谷歌自己的产品，这样<code>gRPC</code>在进行功能升级的时候，Protobuf也能及时的迭代， 目前Protobuf的版本已经迭代到第3版，但是大家能接触到的只有第二版和第三版，因为第一版是谷歌之前内部使用的。<br>不过<code>gRPC</code>采用Protobuf的重要的原因是在常见的场景下，<code>gRPC</code>的效率要比现在大家用到的Json高一些，Protobuf的效率为什么会高呢？天下是没有免费的午餐的，有得既有失，在理解Protobuf之前我们先来看一段Json数据:</p>
<figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs Json">&#123;<br>  <span class="hljs-attr">&quot;project&quot;</span>: <span class="hljs-string">&quot;Test&quot;</span>, <br>  <span class="hljs-attr">&quot;timestamp&quot;</span>: <span class="hljs-number">1600000000</span>, <br>  <span class="hljs-attr">&quot;status&quot;</span>: <span class="hljs-literal">true</span>,<br>  <span class="hljs-attr">&quot;data&quot;</span>: [<br>    &#123;<br>      <span class="hljs-attr">&quot;demo_key&quot;</span>: <span class="hljs-string">&quot;fake_value&quot;</span>,<br>    &#125;,<br>    &#123;<br>      <span class="hljs-attr">&quot;demo_key&quot;</span>: <span class="hljs-string">&quot;fake_value&quot;</span>,<br>    &#125;,<br>    &#123;<br>      <span class="hljs-attr">&quot;demo_key&quot;</span>: <span class="hljs-string">&quot;fake_value&quot;</span>,<br>    &#125;<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这段Json数据是一段文本， 这就是Json效率低下的第一个点–编码低效。比如字段<code>status</code>对应的值<code>true</code>在内存中只占用1个字节，但在这个数据中却占用了4个字节, 再比如字段<code>timestamp</code>的值是int类型，int类型在内存中占用的空间并不大，但是在Json数据中却是以字符串呈现会占用更多的空间。<br>此外我们可以很快的通过这段数据看得出里面有什么内容，这是Json的一个优点，但也带来了另一个缺点–信息冗余。比如字段<code>data</code>的数据是一个数组，但是里面的结构是一致的，这样就会重复多传了n次的字段名。</p>
<p>Protobuf为了解决这些问题，首先引进了一些带有优化的编码方案，解决了编码低效的问题， 比如针对数字引入了VarInts对数字进行编码解码， 这个方案能节省数字的空间占用，同时使用的是位运算来编码解码，效率非常的高，具体可以通过<a href="https://segmentfault.com/a/1190000020500985">详解varint编码原理</a>进行了解。<br>而另一方面的改进则是去掉字段名了，改用字段编号代替，传输的时候只传输编号，这样就可以解决了冗余问题，但是这时候需要双方有一个记录编号的翻译本从而可以通过字段编号来得到真实的字段名，就像莫斯电码通信一样，而在Protobuf中proto文件就是这样的一个密码本，它记录了字段和编号的关系以及这个请求是属于哪个调用的接口和服务。<br>以上文<a href="https://so1n.me/2022/01/05/Python-gRPC%E5%AE%9E%E8%B7%B5(1)--%E7%AE%80%E4%BB%8B/">Python-gRPC实践（1）–gRPC简介</a>中的捉包结果<img    class="lazyload" data-original="https://ftp.bmp.ovh/imgs/2022/01/0adf7176d3f129a9.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">images</span><br>为例子，图中展示的是与proto文件:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs proto">syntax &#x3D; &quot;proto3&quot;;<br>package user;<br>import &quot;google&#x2F;protobuf&#x2F;empty.proto&quot;;<br><br>&#x2F;&#x2F; delete user<br>message DeleteUserRequest &#123;<br>  string uid &#x3D; 1;<br>&#125;<br><br><br>service User &#123;<br>  rpc delete_user(DeleteUserRequest) returns (google.protobuf.Empty);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>有关的请求，请求中表明<code>Field</code>为1，值为999, 接受端收到请求后就会先从proto文件查数据， 通过URL得出这个请求是service为<code>User</code>， rpc为<code>delete_user</code>的请求， 那么请求的message就是<code>DeleteUserRequest</code>，接下来就能知道<code>Field</code>为1实际的字段名是<code>uid</code>。</p>
<h2 id="2-使用Protocol-Buffer"><a href="#2-使用Protocol-Buffer" class="headerlink" title="2.使用Protocol Buffer"></a>2.使用Protocol Buffer</h2><p>Protobuf的编码原理是值得一看的，目前网上资料有很多，这里就先略过直接到如何使用Protobuf(实际上我目前对Protobuf的编码了解的也不是很多- -)。</p>
<p>从上面的示例可以看出<code>gRPC</code>在运行的时候需要proto文件来反查得出真正的字段数据，而<code>gRPC</code>是支持多语言的，那么每个语言的<code>gRPC</code>是如何通过proto文件来查出数据呢。</p>
<p>我们在编写项目时，大多都会通过一份接口代码就来生成对应的OpenAPI文件，然后其它工具如Swagger就能通过读取该文件渲染出一个API文档。而proto文件的作用也跟OpenAPI文件类似，只不过不是代码生成，而是由开发者编写的，然后开发者再通过不同的工具来根据proto文件生成不同语言的代码并放到项目工程中使用，所以要用好<code>gRPC</code>需要先知道如何编写proto文件(通常在使用gRPC时，也是基于Protobuf文件生成对应的调用代码)。</p>
<h3 id="2-1-Protobuf语法"><a href="#2-1-Protobuf语法" class="headerlink" title="2.1.Protobuf语法"></a>2.1.Protobuf语法</h3><p>在介绍语法之前，先看看proto文件都内容有什么，首先我们再回头看一看上面说的proto文件:</p>
<figure class="highlight plain"><figcaption><span>Buffer</span></figcaption><table><tr><td class="code"><pre><code class="hljs Protocol">syntax &#x3D; &quot;proto3&quot;;<br>package user;<br>import &quot;google&#x2F;protobuf&#x2F;empty.proto&quot;;<br><br>&#x2F;&#x2F; delete user<br>message DeleteUserRequest &#123;<br>  string uid &#x3D; 1;<br>&#125;<br><br><br>service User &#123;<br>  rpc delete_user(DeleteUserRequest) returns (google.protobuf.Empty);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>标准的proto文件就像这份示例文件一样可以分为三部分， 第一部分是前三行，这部分是proto文件的声明区，其中第一行标明当前proto文件的语法是proto3(没有特别说明，本文所介绍的语法都是proto3)，第二行表示该文件的包名为user，这样会方便别的文件引入这个文件的定义，第三行表示导入<code>empty.proto</code>文件，接下来在这个文件都可以使用<code>empty.proto</code>文件定义的东西。</p>
<p>第二部分是5-8行， 这部分是消息体区， 这里定义了一个名为<code>DeleteUserRequest</code>的消息体，这个消息体中定义了一个名为uid的字段，且它的类型是<code>string</code>，字段排序是1。在实际开发中，大部分的变动都是在这一部分中发生， 且需要关注的点比较多。</p>
<p>第三部分是11-13行，这部分是服务定义区， 这里定义了一个名为<code>User</code>的服务，该服务中有一个名为<code>delete_user</code>的方法，且该方法接受的请求是<code>DeleteUserRequest</code>消息体，响应的是<code>Empty</code>消息体。可以简单的理解为这部分是定义一个类， 同时为每个类定义一些方法，而这些方法只拥有函数签名，没有具体实现。</p>
<p>了解完了Proto文件结构后，可以开始了解Protobuf语法。</p>
<h4 id="2-1-1-字段编号"><a href="#2-1-1-字段编号" class="headerlink" title="2.1.1.字段编号"></a>2.1.1.字段编号</h4><p>在编写消息体时， 最重要的一点就是字段编号， 从前面的说明可以看出， Protobuf的序列化是通过字段编号进行翻译的，所以我们要保证字段编号和字段是一一对应的， 一般的情况下我们都要遵循字段编号从1开始逐渐递增， 比如下面这个消息体:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs proto">message DemoRequest &#123;<br>  string uid &#x3D; 1;<br>  string mobile &#x3D; 2;<br>  int32 age &#x3D; 3;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>它的字段编号都是逐渐递增的，后面在新增字段时也要按照递增的方法指定字段编号，绝不能复用之前曾经存在的字段编号，即使是把某个字段进行重构，比如把上述的消息体进行更改:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs proto">&#x2F;&#x2F; 通常不删除已经使用的字段， 这里只做演示<br>message DemoRequest &#123;<br>  string uid &#x3D; 1;<br>  string mobile &#x3D; 2;<br>  int32 brithday &#x3D; 4; &#x2F;&#x2F; 统一使用时间戳表示日期<br>&#125;<br></code></pre></td></tr></table></figure>
<p>虽然更改后的消息体里面的age字段被brithday替换了， 但是brithday的字段编号还是递增了1，这样做是可以防止旧版本客户端在没更随服务端变动时造成数据解析异常。</p>
<p>不过使用字段编号递增的方法可以让开发者知道之前的编号用到哪里，但这些都是需要依赖团队的规范去实现才不会出现问题，为此Protobuf提供了<code>reserved</code>字段，供我们来屏蔽一些后续不能再使用的字段编号，使用例子如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs proto">message DemoRequest &#123;<br>  string uid &#x3D; 1;<br>  string mobile &#x3D; 2;<br>  reserved 3;<br>  int32 brithday &#x3D; 4; &#x2F;&#x2F; 统一使用时间戳表示日期<br>  reserved 5, 6, 10 to 15 &#x2F;&#x2F; reserved也可以一下子限制多个字段编号，他们以&#96;,&#96;分开， 也可以使用&#96;xx to xx&#96;来限制一段连续的字段编号。<br>&#125;<br></code></pre></td></tr></table></figure>
<p>该例子可以避免后续的字段用到了字段编号3, 即使用到了Protobuf编译器也会报错，在源头防止问题的发生。</p>
<blockquote>
<p>NOTE<br>之所以要求字段编号从1开始递增是因为Protobuf从message编码成二进制消息体时，字段编号1-15将会占用1个字节，16-2047将占用两个字节，优先使用1-15的字段编号将会减少数据的传输， 如果在一开始消息体的字段就比较多时， 则需要把常用的字段的字段编号安排在1-15之间。此外，19000到19999是给protocol buffers实现保留的字段标号，定义message时不能使用，如果使用了这些编号，Protobuf编译器将会报错。</p>
</blockquote>
<h4 id="2-1-2-如何使用"><a href="#2-1-2-如何使用" class="headerlink" title="2.1.2.如何使用"></a>2.1.2.如何使用</h4><p>在Protobuf的消息体中，每个字段的类型都是固定的， 因为传输固定的类型才能减少传输资源的占用，所以我们在定义消息体的字段时，一定要结合业务需求来定义字段的类型， 以下是一个常见的Protobuf基础字段类型与Python类型的对照表:<br>|Protobuf类型|Python类型|Protobuf类型说明|<br>|–|–|–|<br>|double|float||<br>|float|float||<br>|int32|int|使用变长编码,该类型不擅长处理负值的数字，需要使用sint32代替|<br>|int64|int|使用变长编码,该类型不擅长处理负值的数字，需要使用sint64代替|<br>|unit32|int|使用变长编码|<br>|unit64|int|使用变长编码|<br>|snit32|int|擅长处理负值的数字，当该字段可能出现负值数字时，需要把int32改为该类型|<br>|snit64|int|擅长处理负值的数字，当该字段可能出现负值数字时，需要把int64改为该类型|<br>|fixed32|int|总是4个字节，如果数值总是比总是比228大的话，这个类型会比uint32高效，它等于int32,uint32,float的并集|<br>|fixed64|int|总是8个字节，如果数值总是比总是比256大的话，这个类型会比uint64高效，它等于int64,uint64,double的并集|<br>|bool|bool||<br>|string|str||<br>|bytes|bytes|</p>
<p>需要注意的是，我们虽然声明的字段没有标明他的值是多少，但是他们都有默认值：</p>
<ul>
<li>字符串类型：空字符串</li>
<li>字节类型：空字节</li>
<li>数字类型： 0</li>
<li>enum: 默认值的第一个元素，且值必须为0</li>
</ul>
<p>同时，定义的消息体也是Protobuf中的一个类型，这种类型称为<code>Message</code>，它可以嵌套在别的<code>Message</code>中， Protobuf语法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs proto">message DemoSubRequest &#123;<br>  string a &#x3D; 1;<br>  int32 b &#x3D; 2;<br>&#125;<br>message DemoRequest &#123;<br>  DemoRequest result &#x3D; 1;<br>&#125; <br></code></pre></td></tr></table></figure>
<p>它也可以通过import的语法，从a文件引入消息体到b文件，并被b文件使用， 比如在文件夹下<code>project</code>有a文件和b文件， 其中a文件如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs proto">&#x2F;&#x2F; 声明包名为demo_a<br>package demo_a;<br><br>&#x2F;&#x2F; 定义一个消息体<br>message DemoRequest &#123;<br>  DemoRequest result &#x3D; 1;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>而b文件引用了a文件的消息体，具体代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs proto">&#x2F;&#x2F; 声明包名为demo_b<br>package demo_b<br>import &quot;project&#x2F;demo_a.proto&quot;;<br><br>message DemoRequest &#123;<br>  &#x2F;&#x2F; 引用a文件的消息体<br>  project.demo_a.DemoRequest result &#x3D; 1;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>此外， Protobuf还支持定义其它类型，这些类型具有跟Python等价类型的用法，但是在使用的时候还是有些区别：</p>
<h4 id="Timestamp"><a href="#Timestamp" class="headerlink" title="Timestamp:"></a>Timestamp:</h4><p>Timestamp是Protobuf中的时间类型，Protobuf使用语法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs proto">import &quot;google&#x2F;protobuf&#x2F;timestamp.proto&quot;;<br><br>message DemoRequest &#123;<br>  google.protobuf.Timestamp timestamp &#x3D; 1;<br>&#125; <br></code></pre></td></tr></table></figure>
<p>该类型实际上是timestamp的封装，它的默认值是timestamp=0（对应到的日期是1970-01-01），在Python代码中，可以通过语法<code>ToDatetime</code>转为datetime，也可以通过语法<code>FormDatetime</code>把datetime转为Protobuf的Timestamp:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">from</span> google.protobuf.timestamp_pb2 <span class="hljs-keyword">import</span> Timestamp<br><br>Timestamp().ToDatetime()<br><br><span class="hljs-keyword">from</span> datetime <span class="hljs-keyword">import</span> datetime<br><br>Timestamp().FormDatetime(datetime.now())<br></code></pre></td></tr></table></figure>

<h4 id="Repeated："><a href="#Repeated：" class="headerlink" title="Repeated："></a>Repeated：</h4><p>Repeated 可以使该字段表重复任意次数，就像Python的Sequence对象，但是实际上可以认为是Python的List对象，Protobuf使用Repeated语法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs proto">message DemoRequest &#123;<br>  repeated int32 demo_list &#x3D; 1;<br>&#125; <br><br>&#x2F;&#x2F; demo_list value like json<br>&#x2F;&#x2F; [1, 2, 3, 4, 5, 6] <br></code></pre></td></tr></table></figure>
<p>该消息体定义了一个<code>demo_list</code>字段， 该字段是repeated且内部类型是int32，在Python中使用Repeated字段的方法跟使用List方法一样，但是它不是继承于List的，在部分库可能需要转换为List才能使用，比如<code>pymysql</code>。</p>
<h4 id="Map："><a href="#Map：" class="headerlink" title="Map："></a>Map：</h4><p>虽然我们大多数都是以明确的Key-Value来定义消息体， 但是Protobuf也提供了一个类似于dict的Map，Protobuf使用Map语法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs proto">message DemoRequest &#123;<br>  map&lt;string, int32&gt; demo_map &#x3D; 1;<br>&#125; <br><br>&#x2F;&#x2F; demo_map value like json<br>&#x2F;&#x2F; &#123;<br>&#x2F;&#x2F;    &quot;aaa&quot;: 123,<br>&#x2F;&#x2F;    &quot;bbb&quot;: 456 <br>&#x2F;&#x2F; &#125;<br></code></pre></td></tr></table></figure>
<p>该消息体定义了一个<code>demo_map</code>字段， 该字段是map类型且key类型为字符串，value类型为int32，在Python中使用Map的方法跟使用dict方法一样，但是它不是继承于dict的，在部分库可能需要转换为dict才能使用，比如<code>pymysql</code>。</p>
<blockquote>
<p>NOTE: </p>
<ul>
<li>Map类型的字段不能是Repeated， 因为Repeated是可变的，就像Python中Dict的Key不能是List一样。</li>
<li>Map的字段是无序的。</li>
<li>如果有重复的字段，则使用最后都有一个。</li>
</ul>
</blockquote>
<h4 id="Empty："><a href="#Empty：" class="headerlink" title="Empty："></a>Empty：</h4><p>Empty是Protobuf中代表空的类型，跟Python中的None一样, 一般不用在消息体中， 而是用来标明某个rpc方法返回了空，Protobuf语法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs proto">import &quot;google&#x2F;protobuf&#x2F;empty.proto&quot;;<br><br>service Demo &#123;<br>  rpc demo (DemoRequest) returns (google.protobuf.Empty);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在Python中可以通过<code>from google.protobuf.empty_pb2 import Empty</code>导入<code>Empty</code>对象并使用，不过在Python代码中最好不要把<code>Empty</code>转为Python的None对象, 因为<code>Empty</code>只是用来代表该请求点响应为空。</p>
<h4 id="Enum："><a href="#Enum：" class="headerlink" title="Enum："></a>Enum：</h4><p>在定义消息类型时， 可能希望其中一个字段只有一个预定义的值，这时就会用到枚举类型，Protobuf使用Enum语法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs proto">message DemoRequest &#123;<br>  enum Status &#123;<br>    open &#x3D; 0;<br>    half_open &#x3D; 1;<br>    close &#x3D; 2;<br>  &#125;<br>  Status status &#x3D; 1;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>如语法所示， 首先在消息体创建一个名称为<code>Status</code>的枚举类型，然后定义类型为<code>Status</code>的字段<code>status</code>， 值得注意的是枚举定义都需要包含一个常量映射到0并且作为定义的首行，这是因为Protobuf要求定义的枚举值中必须有字段的值为0，当引用到这个类型的字段没有定义默认值时，它的默认值就是枚举类型中值为0的字段。</p>
<h3 id="2-2-Proto文件管理与使用规范"><a href="#2-2-Proto文件管理与使用规范" class="headerlink" title="2.2.Proto文件管理与使用规范"></a>2.2.Proto文件管理与使用规范</h3><p>实际使用gRPC来串联服务时，这些服务并不是只用一门编程语言，可能有的服务是用Python写的，有的服务是Java写的，有的服务则是用Go写的。<br>同时，我们在发布功能时也不是所有服务都需有更新，有的服务只需要用老接口就可以了， 比如一个服务端接口进行了更新， 这个服务端对应了很多个客户端，如果没有规范管理proto文件的话，就可能所有客户端都要进行升级，而不是只升级需要升级的客户端， 所以我们需要根据规范来管理proto文件，减少管理上带来的负担。</p>
<h4 id="2-2-1-方案选择"><a href="#2-2-1-方案选择" class="headerlink" title="2.2.1.方案选择"></a>2.2.1.方案选择</h4><p>在一开始的时候，我选用的方案是最简单的文件拷贝，这也是大多数人入门时的使用方法，它使用起来非常简单，但是代码复用率很低，项目多了之后复制文件会成为负担， 有时还需要用diff工具去对比，十分麻烦。</p>
<p>于是，在后续就开始考虑用版本管理工具来进行管理，由于proto文件是项目的子集，在选择方案的时候就会先联想到Git Submodul, 但是这种方案存在回滚故障点风险，同时需要为每个项目各自生产对应的proto，比较麻烦。</p>
<p>最后确定的方案是新建一个git仓库来存放proto文件，并以tag来区分不同的版本。<br>使用git仓库还有一个优势就可以利用CI/CD来自动根据proto文件生成对应语言的代码以及打包，省去的一些手动的步骤。</p>
<h4 id="2-2-2-使用"><a href="#2-2-2-使用" class="headerlink" title="2.2.2.使用"></a>2.2.2.使用</h4><p>首先我们需要创建一个Git仓库，把每个服务端项目的Proto文件移出来独立成一个仓库，接着就根据<a href="https://danielkummer.github.io/git-flow-cheatsheet/index.zh_CN.html">git flow</a>流程来更新proto文件，不过在更新Proto文件时需要遵循下面几条规范：</p>
<ul>
<li>proto文件只增不减</li>
<li>proto文件的接口只增不减</li>
<li>proto文件的message字段只增不减</li>
<li>proto文件中的message字段类型和序号不得修改</li>
</ul>
<p>这几条规范的共性就是不对源文件进行删除，每次都只做到新增，从而保证即使proto文件发生了更改， 旧的服务在不更新的情况下也还能正常的使用。</p>
<p>更新完后就可以给其它项目使用了， 比如这个库当前的版本为1.0.0，我们根据<a href="https://danielkummer.github.io/git-flow-cheatsheet/index.zh_CN.html">git flow</a>流程来更新proto文件并生成对应语言的代码或者release包，最后打上了对应的tag标签， 对于Python可以使用该方法来安装或更新依赖：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">pip install https://gitlab.xxx.com/proto/aaa@v1.0.0<br></code></pre></td></tr></table></figure>
<p>而对于Java这类的则可以使用打包成一个release版本交给maven使用。</p>
<h2 id="3-最后"><a href="#3-最后" class="headerlink" title="3.最后"></a>3.最后</h2><p>现在已经初步的了解了<code>gRPC</code>以及Protobuf的使用方法，接下来将通过一个简单的项目来演示如何使用<code>gRPC</code></p>
]]></content>
      <categories>
        <category>Python-gRPC实践</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>gRPC</tag>
      </tags>
  </entry>
  <entry>
    <title>Python-gRPC实践（1）--gRPC简介</title>
    <url>/2022/01/05/Python-gRPC%E5%AE%9E%E8%B7%B5(1)--%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>接触<code>gRPC</code>比较早， 但我不怎么喜欢在<code>Python</code>中使用<code>gRPC</code>， 因为<code>Python</code>中的官方<code>gRPC</code>框架易用性太烂了， 只提供基本功能， 附带的其他功能要不就不完善， 要不文档就只有简单几句话， 啥东西都得去原本的项目找, 用起来都不顺心（毕竟不是Goole的亲儿子，支持的力度肯定比较少）。</p>
<blockquote>
<p>而且在<code>Python</code>项目中引入<code>gRPC</code>框架后， 项目就很难去维护了， 所以我基本不用， 为此我自己还开发了一款用于<code>asyncio</code>的<code>RPC</code>框架–<a href="https://github.com/so1n/rap">rap</a>， 如果你恰好是基于<code>asyncio</code>生态构建项目， 且需要用到<code>gRPC</code>框架的，那么推荐接触下非官方的<code>gRPC</code>项目–<a href="https://github.com/danielgtaylor/python-betterproto">python-betterproto</a>。</p>
</blockquote>
<p>吐槽归吐糟， 但是还是得用， 因为其他语言的项目都用了<code>gRPC</code>, 不同团队服务的通信需要依赖<code>gRPC</code>进行通信， 所以这块硬骨头还是得啃下去。 在啃的过程非常艰辛， 因为官方文档太少了， 相关文章也不多， 中文社区零零散散， 英文社区的文章会比较多， 但很多搜索出来的都是<code>Go-gRPC</code>相关的， 这就很扎心了， 而这个系列文章就是我啃完的一个总结。</p>
<p>好了， 唠嗑完毕， 以下是文章的正式内容。</p>
<span id="more"></span>

<h2 id="1-什么是RPC"><a href="#1-什么是RPC" class="headerlink" title="1.什么是RPC"></a>1.什么是RPC</h2><p>在了解<code>gRPC</code>之前， 先了解什么叫RPC, RPC是Remote Procedure Call的简称， 中文称为远程过程调用， 它允许不同的进程或者不同的机器的程序互相调用。 其实按照这个定义，平时使用的HTTP（Restful API）请求也算RPC， 因为主流的HTTP（Restful API）在不同的服务之间兼容性虽是最棒的, 也有成熟的生态， 所以很多公司的内部服务还是以HTTP来互相调用， 但是由于传输体积很大， 这种方式的请求速度并不是很快， 传输性能不佳。 </p>
<p>不过现在很多公司的内部服务间的调用越来越多， 调用链变长， 如果还用HTTP（Restful API）的方式做内部服务的调用， 那整个调用链的时间就变长, 同时增加了系统开销, 需要一些别的方案来解决这些问题;同时由于这些服务通常都是在内网， 这些服务只要内部协议兼容就行, 不用过多的去考虑外部因素， 追求的是更小的传输体积， 更快的传输速度（所以内网间用UDP也是可以的）， 同时对系统的性能消耗较低， 所以就有了各种RPC协议诞生。</p>
<p>目前市面上各种RPC协议虽然互不兼容， 但是他们基本上只有在传输协议和序列化协议有较大的不同， 传输协议和序列化这两点恰好就是与传输体积， 传输速度和系统性能消耗的问题有关。<br>其中传输协议是为了解决传输体积和传输速度的问题， 一般使用的是TCP， UDP传输协议或者是直接基于HTTP自定义的应用层协议， 而序列化协议主要解决的是<code>通用性</code>， <code>流行性</code>， <code>成熟性</code>, <code>空间占用</code>，<code>时间占用</code>， 一般RPC定制的序列化, 都追求较少的空间占用（减少网络传输压力）和时间占用（减少机器的序列化时间）， 其次再满足其它3个特性， 兼容其它语言等。</p>
<blockquote>
<p>由于本文的重点是在于<code>gRPC</code>, 关于RPC以及RPC传输协议和序列化协议的说明可以通过我的另一篇文章<a href="https://so1n.me/2021/08/19/RPC%E6%A1%86%E6%9E%B6%E7%BC%96%E5%86%99%E5%AE%9E%E8%B7%B5--%E6%9C%80%E5%B0%8FRPC%E6%A1%86%E6%9E%B6%E7%9A%84%E4%BE%9D%E8%B5%96/#/4-%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96">RPC框架编写实践–最小RPC框架的依赖</a>进行了解</p>
</blockquote>
<h2 id="2-gRPC"><a href="#2-gRPC" class="headerlink" title="2.gRPC"></a>2.gRPC</h2><p><code>gRPC</code>是Google开源的高性能、通用的RPC框架， 前面的g在不同的版本都有对应的意思（<a href="https://pythonhunter.org/episodes/ep28#t=00:10:19">戳这了解</a>）, 但是我觉得就是<code>Google</code>的意思， 毕竟在它的亲儿子<code>Go</code>使用<code>gRPC</code>太方便了， 基本上是开箱即用。<br><code>gRPC</code>的特点是：</p>
<ul>
<li>gRPC使用HTTP/2协议，HTTP/2解决并优化了HTTP1.1的一些缺陷， 带来了更多强大功能，如多路复用、二进制帧、头部压缩、推送机制。这些功能给设备带来重大益处，如节省带宽、降低TCP连接次数、节省CPU使用等。而且目前很多框架都提供对HTTP的支持（如Nginx）， 所以适用范围广；</li>
<li>默认使用谷歌开源的<code>Protocol Buffer</code>(类似于XML、JSON的数据序列化结构协议)，传输速率、解析速度都很快、压缩率高，性能整体都比XML和JSON好， 同时支持类型声明，可以生成良好的文档和示例。</li>
<li>语言中立（功能提供上确实算中立…），支持各种流行语言(C++、C#、Java、Go、Python等)都能用，轻松实现跨语言通信；本身不限于任何平台。</li>
<li>基于 IDL 文件定义服务，通过 proto3 工具生成指定语言的数据结构、服务端接口以及客户端 Stub；</li>
<li>除了HTTP（Restful API）的一请求一响应外， 还支持单向，双向的流API。</li>
</ul>
<p>不过由于这些特点， 造成了<code>gRPC</code>的通用性和自解析性差， 所以比较适合与移动端和内部应用以及一些偏内部合作的场景， 而不太适用了网页端这种追求通用的场景（因为通用的场景一般没办法快速的升级到新的协议）。</p>
<h2 id="3-gRPC的请求过程"><a href="#3-gRPC的请求过程" class="headerlink" title="3.gRPC的请求过程"></a>3.gRPC的请求过程</h2><p><code>gRPC</code>的传输协议是基于HTTP协议， 前面说到HTTP协议的性能不咋样， 那为什么<code>gRPC</code>还采用它呢， 这是因为<code>gRPC</code>采用的是HTTP/2, 它相对于我们常用的HTTP/1.1有了很大的提升和改进。 </p>
<p>我们常用HTTP的请求形式是<code>one-by-one</code>, 这种请求只会请求一次响应一次， 如果没有进行优化， 每次请求都会经历创建TCP， 进行请求，读取响应， 销毁TCP四个阶段， 而TCP的创建和销毁是非常浪费性能并且会增加很多调用时间开支, 同时对于服务端来说会占用更多的文件描述符， 这样也会影响到服务器的性能的。 所以到了HTTP/1.1时就做了一点改进， 首先是支持了连接复用， 也就是持久化链接， 这种方式可以让客户端对同一域名持有一个或多个不会用完即段的TCP连接， 减少频繁创建和销毁连接带来了开销, 以及过多TCP链接带来的系统资源占用。<br>但是在这种模式下收发请求的形式上类似于一个FIFO队列， 只有前面请求处理完了， 后续的请求才会发送出去， 不然就只能一直等着， 如果前面的请求一直卡住， 后面的请求就无法发送出去， 造成队首阻塞的问题。要解决这样的问题很简单， 但需要更改协议。由于HTTP本来就是基于TCP的， 所以它也能像流一样进行传输， HTTP/2针对这一点做了一些改动, 使其支持流传输， 此外HTTP/2规定了帧是HTTP/2中最小的信息单位， 这个帧可以用来描述各种数据， 比如请求的Header、Body或者是用来做控制标识， 如打开关闭连接等。同时每个帧都附带了一个流ID来标识这个帧是属于哪个流， 这样就能解决HTTP/2提到的队首阻塞问题， 客户端可以根据标识ID将不同的响应与请求一一匹配， 从而解决了无法识别同一连接在同一时刻收到两个请求的问题, 提升请求效率， 这个涉及到HTTP/2的最重要的技术特征–多路复用。</p>
<blockquote>
<p>这里只做必要性的说明， 具体说明可以通过我的另一篇文章<a href="https://so1n.me/2021/08/19/RPC%E6%A1%86%E6%9E%B6%E7%BC%96%E5%86%99%E5%AE%9E%E8%B7%B5--%E6%9C%80%E5%B0%8FRPC%E6%A1%86%E6%9E%B6%E7%9A%84%E4%BE%9D%E8%B5%96/#/4-%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96">RPC框架编写实践–最小RPC框架的依赖</a>进行了解。</p>
</blockquote>
<p>简单的文字说明可能有点难以理解， 可以直接通过捉包来分析HTTP/1.1和HTTP/2之间的不同：</p>
<h3 id="3-1-HTTP调用捉包分析"><a href="#3-1-HTTP调用捉包分析" class="headerlink" title="3.1.HTTP调用捉包分析"></a>3.1.HTTP调用捉包分析</h3><p>首先是HTTP/1, 我先基于<code>Flask</code>启动一个Web服务, Web服务代码如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Flask<br><br>app = Flask(__name__)<br><br><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&quot;/&quot;</span></span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">demo</span>() -&gt; str:</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;ok&quot;</span><br><br><br>app.run(port=<span class="hljs-number">8000</span>)<br></code></pre></td></tr></table></figure>
<p>该服务监听端口8000， 当收到”/“的访问时，会返回”ok”的文本到客户端， 然后启动捉包工具并在命令行执行如下命令:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">➜  ~ curl 127.0.0.1:8000/<br>ok%<br>➜  ~ curl 127.0.0.1:8000/<br>ok% <br></code></pre></td></tr></table></figure>
<p>通过命令可以发现请求了两次Web服务的”/“链接， 并都得到响应体:”OK”, 现在我们来看看捉包结果：<br><img   class="lazyload" data-original="https://ftp.bmp.ovh/imgs/2022/01/7876ebc6b6e3aeaf.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" ><br>从图中可以看到有四条绿色的且<code>Protocol</code>字段为<code>HTTP</code>的数据， 这代表两次请求中各自的一发一收， 同时可以看到<code>INFO</code>字段中的<code>[SYN]</code>,<code>[FIN]</code>成对出现两次， 第一次的发送端口是33480, 第二次的发送端口是33450, 由于四元组的不同， 所以他们并不是同一个TCP请求。同时通过数据行数可以发现， 为了实现这两个请求（共4个HTTP数据），TCP在背后做了大量的准备和善后工作。</p>
<p>接着我们来看看其中的一条请求包数据详情(也就是上图中No.158的数据):<br><img   class="lazyload" data-original="https://ftp.bmp.ovh/imgs/2022/01/5abfb3cee70d755a.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" ><br>图中<code>Hypertext Transfer Protocol</code>就是本次的请求数据（上面那些是更底层的TCP数据， 与本文无关）， 通过数据可以看到该请求是我通过了<code>GET</code>方法调用了url:<code>/</code>, 同时使用的是HTTP/1.1协议， 此外还有UA, <code>Accept</code>等Header数据。</p>
<p>接下来再看看No.158对应的响应数据No.164数据包详情:<br><img   class="lazyload" data-original="https://ftp.bmp.ovh/imgs/2022/01/3163a29f97e965d2.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" ><br>同样只看<code>Hypertext Transfer Protocol</code>的数据， 可以发现里面存放着服务器返回的各种Header数据， 并在<code>Line-based text data</code>中则显示我们的响应体”ok”。</p>
<p>现在简单的HTTP捉包分析先告一段落， 转而去看看<code>gRPC</code>的捉包有何不同。</p>
<h3 id="3-2-gRPC调用捉包分析"><a href="#3-2-gRPC调用捉包分析" class="headerlink" title="3.2.gRPC调用捉包分析"></a>3.2.gRPC调用捉包分析</h3><p><code>gRPC</code>的测试接口是用到了后面示例的<code>gRPC</code>项目中的<code>user.delete_user</code>接口, 其中客户端调用的参数是<code>uid=999</code>, 但由于找不到用户， 服务端会在metadata写入Python的异常数据, 然后返回的是标准的<code>gRPC</code>异常。</p>
<blockquote>
<p>具体请求方法和内容后面再详细阐述，proto文件可以参考<a href="https://github.com/so1n/grpc-example-common/blob/master/protos/user/user.proto">user.proto</a>。 </p>
</blockquote>
<p>本次的<code>gRPC</code>的测试执行顺序是先启动服务端， 然后启动服务端并进行两次请求，最后先关闭客户端再关闭服务端， 具体的捉包数据如图：<br><img   class="lazyload" data-original="https://ftp.bmp.ovh/imgs/2022/01/2581fb8461397c1f.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" ><br>通过整个捉包数据可以简单的发现， <code>Protocol</code>字段里面有<code>TCP</code>, <code>HTTP2</code>, <code>gRPC</code>三种，其中里面有2行<code>Protocol</code>字段为<code>GRPC</code>的数据， 这两行数据的INFO中带有<code>POST /user.User/delete_user</code>（在<code>gRPC</code>的规定中， URL按<code>/$&#123;包名&#125;.$&#123;服务名&#125;/$&#123;接口名&#125;</code>格式命名）， 可以认为这两行就是两次调用， 但是整个数据包里面只出现过一次<code>[SYN]</code>和一次<code>[FIN]</code>， 代表这两次请求只创建过一个TCP链接， 也只使用了一个TCP链接。</p>
<p>接下来看一下<code>gRPC</code>的第一个请求传输流程的相关流：</p>
<ul>
<li>1:No.494客户端发送用户的请求到服务端</li>
<li>2:No.496客户端发送一个HTTP2的PING给服务端</li>
<li>3:No.498服务端返回一个HTTP2的PING给客户端</li>
<li>4:No.512服务端返回HTTP2的Header给客户端</li>
<li>5:No.514服务端返回HTTP2的Body给客户端</li>
</ul>
<p>从相关流中可以发现， 为了维持健壮性， HTTP2会有一些其它的机制， 如No.496和No.498的PING， 而且服务端返回数据时也可以拆成Header和Body两个数据流返回， 需要注意的是HTTP/2没有要求一定要先返回Header再返回Body, 它可以先返回一个Header, 再返回多个Body, 最后再返回Header, 就像<code>gRPC</code>的流响应中， 会先返回Header，告知HTTP状态， 然后返回Body传输信息， 最后再返回Header告知<code>gRPC</code>状态。</p>
<p>接下来查看跟请求相关的No.494, No.512以及No.514三个包， 首先是No.494:<br><img   class="lazyload" data-original="https://ftp.bmp.ovh/imgs/2022/01/0adf7176d3f129a9.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" ><br>可以看到HTTP2的包比较复杂， 现在看到的都是我指定<code>Wireshark</code>解码为HTTP2后展示出来的， 其中里面的<code>Stream ID:1</code>是指明这个帧的归属ID, 然后里面展示出来的Header都是本次请求的信息， 如<code>scheme</code>,<code>method</code>, <code>path</code>等以及我自定义的Header:<code>customer-user-agent</code>, <code>request_id</code>等其它Header, 可以看到这些都与我们常用的HTTP/1.1很像， 同时他们占用的字节数很多，达到了281。 而再往下看到的<code>GRPC Message</code>和<code>Protocol Buffers</code>分别占用了5字节和5字节， 其中<code>GRPC Message</code>的长度5字节是固定的， 因为<code>gRPC</code>要求在<code>Protobuf</code>字节流前面加一个五字节的前缀，第一个字节表示字节流是否被压缩，后四个字节叫作<code>Length-Prefixed Message</code>, 它的作用是存储数据长度。如果熟悉HTTP协议，会知道HTTP可以使用<code>Content-Encoding</code>表示压缩算法，使用<code>Content-Length</code>指定数据长度， 那么<code>gRPC</code>为啥还要另起炉灶重新定义是否压缩和长度呢， 这是因为<code>gRPC</code>除了支持常见的<code>one-by-one</code>请求类型外， 还支持如下几种类型：</p>
<ul>
<li>请求流：客户端可以不断发送新的请求消息。 该类型的典型使用场景是客户端发推送或者上报埋点。</li>
<li>响应流：建立连接后，服务端一直返回消息。 该类型的典型使用场景是服务端的订阅推送。</li>
<li>双向流：类似于HTTP中的WebSocket, 双端可以同时收发消息。 该类型的典型使用场景是类似于聊天室之类的信息交互。</li>
</ul>
<p>而流传输都是同享同一个HTTP Header信息的， 然后就会出现这样一个场景: 先传了一条Header信息， 接着再传两条<code>gRPC</code>的内容信息， 如果按照HTTP中<code>Content-Length</code>的长度获取内容数据的话， 就会出现获取内容跟实际发送的内容不一致， 所以只能给每个信息单独加上一个字节的前缀来表示压缩和长度信息了。</p>
<p>了解完了<code>GRPC Message</code>的规定后， 再次回到请求体的分析， 由于我没有配置proto文件， 解码后的<code>Protocol Buffers</code>并没有展示出是哪个Message, 但依然能看到Field的值为1, value的长度为3， 值为999（解码错了， 393939实际上是999）， 结合我的proto文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs proto">&#x2F;&#x2F; delete user<br>message DeleteUserRequest &#123;<br>  string uid &#x3D; 1;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>可以看出gRPC只传输了值和值对应的编号， 然后对应端收到数据后会根据编号进行序列化， 转化为各语言对应的值。</p>
<p>最后就是我们的响应数据分析了， 我示例的响应是一个比较特殊的响应， 由于服务端找不到用户， 会直接抛出<code>Python</code>的异常， 然后我在里面实现了一个拦截器， 这个拦截器发现函数异常了， 就把异常数据放在<code>gRPC</code>的<code>metadate</code>里面通过Header返回， 然后返回一个<code>gRPC</code>的标准异常响应Header， 所以由于没有返回内容， 该响应并不会返回Body数据。<br>通过上面的流程分析可以知道， 本次响应会分开两次返回， 第一个返回的数据是<code>gRPC</code>的<code>metadata</code>数据， 也就是HTTP2的Header数据， 里面有我定义的字段<code>exc_name</code>和<code>exc_info</code>以及其它常见的HTTP header:<br><img   class="lazyload" data-original="https://ftp.bmp.ovh/imgs/2022/01/5e20f4453642a418.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" ><br>然后由于本次并没有<code>Prococol</code>数据， 所以在本次捉包数据没有发现， 只有另一条Header数据， Header里面包含<code>grpc-status</code>以及<code>grpc-message</code>字段：<br><img   class="lazyload" data-original="https://ftp.bmp.ovh/imgs/2022/01/3d1d1136d7c30044.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" ></p>
<p>至此<code>gRPC</code>响应的数据分析已经结束了， 可以发现<code>gRPC</code>的包比HTTP/1.1的包复杂一些， 功能也更多， 同时都能复用同一条连接， 接下来我们再来简单的看看<code>gRPC</code>的简要请求流程。</p>
<h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3.总结"></a>3.总结</h2><p>正因为这些， <code>gRPC</code>在选用HTTP协议时， 才不会担忧性能的问题， 同时又能使用一些现成的HTTP生态如<code>Nginx</code>， 也能方便的通过一个端口来支持HTTP/1.1请求和HTTP/2请求(Golang有自带实现， Python就没 T_T)。此外， 在看完请求过程后， 可以看到<code>gRPC</code>传输协议只是一个基于HTTP/2拓展传输的协议， 它只解决了RPC中的传输问题， 剩下的序列化问题还需要<code>Protocol Buffer</code>来解决， 而且份量也很大， 将在下一节介绍它。</p>
]]></content>
      <categories>
        <category>Python-gRPC实践</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>gRPC</tag>
      </tags>
  </entry>
  <entry>
    <title>RPC框架编写实践--简介注册与发现的</title>
    <url>/2021/11/15/RPC%E6%A1%86%E6%9E%B6%E7%BC%96%E5%86%99%E5%AE%9E%E8%B7%B5--%E9%99%90%E6%B5%81/</url>
    <content><![CDATA[<h2 id="前记"><a href="#前记" class="headerlink" title="前记"></a>前记</h2><p>微服务比正常的单体服务的主要差别是小而多， 同时每个小服务的上下线频率也比较高， 经常会根据服务的使用量来增减服务， 使得整体服务能在不同的并发量情况下时刻保持着稳定， 同时也不会造成服务空闲。<br>但是如果每次都是手动的配置服务的连接地址， 那将会非常的繁琐，且无法自动化， 这时就需要通过注册中心来实现服务与发现功能了。</p>
<h2 id="1-注册与发现"><a href="#1-注册与发现" class="headerlink" title="1.注册与发现"></a>1.注册与发现</h2><h3 id="1-1什么是注册与发现"><a href="#1-1什么是注册与发现" class="headerlink" title="1.1什么是注册与发现"></a>1.1什么是注册与发现</h3><p>服务调用端在调用服务之前必须要得到服务提供方的地址， 在单体应用场景下， 服务端的地址基本上是不变的, 如果调用端和服务端都是位于同一个内网， 那么服务调用端一般都是通过写死配置的形式来获取服务提供方的地址， 但这对于处于不同网络环境的调用端和服务端的情况是非常的不友好， 因为机器的ip可能会发生改变， 同时用户也不一定会记住ip， 所以这时候就出现了基于DNS的服务与发现， 调用端只需要填写一个域名， 在请求的时候经过解析器解析就可以得到服务端的真实地址， 进而通过这个地址访问到了服务端。<br>在这个过程中，DNS服务充当着一个信息存储的载体， 它存放着域名与服务端真实地址的映射关系， 我们可以把DNS简单的认为是一个服务发现的组件， 运维人员把操作ip和域名的绑定可以认为是服务注册， 而客户端通过DNS解析域名得到的ip地址的操作认为是服务发现。</p>
<h3 id="1-2微服务的注册与发现"><a href="#1-2微服务的注册与发现" class="headerlink" title="1.2微服务的注册与发现"></a>1.2微服务的注册与发现</h3><p>DNS虽然很稳健也好用， 但是他有一个缓存的问题， 而对于微服务来说， 它的变动的十分频繁的， 它需要马上知道服务端的动态， 不然会出现服务端已经启动了， 但没有客户端连接上来以及服务端崩溃了， 客户端还一直请求的情况。<br>第一种情况还好， 不会造成请求异常， 但是对于提供这个服务的服务集群来说， 会跟负载不均衡一样， 而第二种则会造成请求异常， 如果没有其他服务治理功能， 影响范围会比较大， 同时这两种情况结合起来后可以发现， 不适合让这个提供整个服务的集群进行滚动更新， 所以微服务需要一个能针对自己需求的注册与发现功能， 功能与DNS一样， 只不过能实时监听到对应服务的变动， 这时就需要依赖到一个组件–注册中心。</p>
<p>目前有很多种注册中心组件， 他们的主要功能基本上都是一样的， 提供了注册服务地址，注销服务地址以及监听对应的服务地址变动的功能, 在与服务结合后的简单结构图如下：<br><img   class="lazyload" data-original="https://ftp.bmp.ovh/imgs/2021/11/0553790fcb85e14f.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" ><br>在实际场景中，图中的注册中心一般都是3个以上的节点组成的集群， 通过集群提供了一个稳定的服务， 服务端在启动的时候会把自己的监听端口通过对应的协议发送到注册中心， 而客户端会在启动的时候从注册中心获取到对应的地址放在内存中， 用户每次调用服务的时候客户端都会从内存中获取对应的地址， 并通过负载均衡等服务治理功能后把请求发送到某个服务中。<br>此外， 客户端在启动的时候会请求到注册中心并hold住（如果是HTTP协议则是注册中心hold住这个请求， 如果是gRPC则是建立一个长连接通道）， 如果服务端发生变动时， 注册中心会通知客户端具体的变动信息， 客户端根据这个信息增减内存中保存的地址。</p>
<h3 id="1-3-服务端职责–服务注册"><a href="#1-3-服务端职责–服务注册" class="headerlink" title="1.3.服务端职责–服务注册"></a>1.3.服务端职责–服务注册</h3><p>服务注册是针对服务端的， 服务端进程一般有3个生命周期： 启动，运行中，停止， 分别对应注册的三个阶段启动注册， 定时续期， 停止注销。</p>
<p>当一个服务节点启动后，会把自己的IP，端口注册到注册中心上面， 并且设置了一个有效期， 告诉注册中心过了多少时间后自动注销这个注册的值， 防止异常退出后注册中心依然保留着服务端的IP端口。<br>服务端在运行过程中， 会定时的告诉注册中心自己还活着， 客户端依然可以通过注册中心获取服务端的IP和端口并连接到服务端。<br>最后是停止注销阶段， 服务端在退出之前，主动告诉注册中心自己即将退出， 客户端不能在通过注册中心获取到服务端的IP和端口了， 不过这一步是有延时的， 服务端最好还能通过广播自动的告诉客户端自己即将退出， 客户端需要赶紧处理自己的事情， 然后关闭连接， 具体见<a href="https://so1n.me/2021/08/28/RPC%E6%A1%86%E6%9E%B6%E7%BC%96%E5%86%99%E5%AE%9E%E8%B7%B5--%E4%BC%98%E9%9B%85%E7%9A%84%E9%87%8D%E5%90%AF/">RPC框架编写实践–优雅的重启</a></p>
<h3 id="1-4-客户端职责–服务发现"><a href="#1-4-客户端职责–服务发现" class="headerlink" title="1.4.客户端职责–服务发现"></a>1.4.客户端职责–服务发现</h3><p>服务发现是针对客户端的， 客户端的发现具体体现在启动的时候的发现以及运行中的增量发现。客户端启动的时候会通过注册中心获得自己要连接的服务的所有连接信息， 并建立连接， 在运行的时候根据注册中心返回的信息变化， 自动增加和删除连接。<br>但是注册中心不一定是可靠的， 随时都可能崩溃， 客户端还需要把注册中心的数据保存在自己的内存中， 当注册中心崩溃时， 还可以冻结当前的节点信息， 保持服务继续可用。</p>
<h2 id="2-注册中心的选型"><a href="#2-注册中心的选型" class="headerlink" title="2.注册中心的选型"></a>2.注册中心的选型</h2><p>在微服务中，注册中心作为一个存储所有服务中心的地方必然不可能是单机的。因为如果注册中心无法使用，那么服务提供者就无法对外暴露自己的服务，消费者也无法获取自己需要调用的服务的具体地址，整个应用将会崩溃， 所以需要保证的就是注册中心的高可用。<br>这就涉及到经典的<code>CAP</code>理论了， 由于只能在一致性， 可用性， 分区容错性三选二， 而注册中心无法容忍单点故障, 所以分区容错是不可避免的（一般的分布式系统都需要确保分区容错性）， 注册中心一般只会采用<code>CP</code>(优先保持一致性)或者<code>AP</code>（优先保持可用性）， 使用者需要根据场景来进行选择， 由于我实现的客户端是支持冻结注册中心信息的， 所以注册中心在短时间内挂掉对服务的影响也不大， 所以我是优先选择<code>CP</code>类型的注册中心， 常见的<code>CP</code>类型的注册中心有<code>etcd</code>, <code>consul</code>以及<code>ZooKeeper</code>, 不过我对<code>ZooKeeper</code>不太熟悉， 这里就不做更多的讨论了。</p>
<h3 id="2-1etcd"><a href="#2-1etcd" class="headerlink" title="2.1etcd"></a>2.1etcd</h3><p> etcd名字是由 <code>/etc</code> 文件夹和”d”分布式系统组成。<code>/etc</code>文件夹是用来存储单系统配置数据的，而 <code>etcd</code>用于存储大规模分布式系统的配置数据，etcd集群可提供高稳定性，高可靠性，高伸缩性和高性能的分布式KV存储服务。etcd是基于复制状态机实现的，由Raft一致性模块，日志模块，基于boltdb持久化存储的状态机组成，可应用于分布式系统的配置管理，服务发现，分布式一致性等等。<br>etcd的特点:</p>
<ul>
<li>完全复制：集群中的每个节点都可以使用完整的存档</li>
<li>高可用性：Etcd可用于避免硬件的单点故障或网络问题</li>
<li>一致性：每次读取都会返回跨多主机的最新写入</li>
<li>简单：包括一个定义良好、面向用户的API</li>
<li>安全：实现了带有可选的客户端证书身份验证的自动化TLS</li>
<li>可靠：使用Raft算法实现了强一致、高可用的服务存储目录<h3 id="2-2consul"><a href="#2-2consul" class="headerlink" title="2.2consul"></a>2.2consul</h3>Consul与etcd解决的是不同的问题，etcd用于分布式一致性KV存储，而Consul侧重于端到端的服务发现，它提供了内置的健康检查，失败检测和DNS服务等注册中心功能，另外Consul通过RESTfulHTTPAPIs提供KV存储能力.但是当KV使用量达到百万级时，会出现高延迟和内存压力等问题。 不过由于<code>Consul</code>使用的<code>Gossip</code>一致性算法， 它然支持多数据中心，但是多数据中心内的服务数据并不会跨数据中心同步，各个数据中心的 Server 集群是独立的,Consul 提供了 Prepared Query 功能，它支持根据一定的策略返回多数据中心下的最佳的服务实例地址，使你的服务具备跨数据中心容灾。</li>
</ul>
<p><code>Etcd</code>和<code>Consule</code>两者很像， 他们的具体对照表如下(来源于网上):<br>||etcd|consul|<br>|–|–|–|<br>|并发原语|支持|支持|<br>|线性读|支持|支持|<br>|多版本控制|支持|不支持|<br>|事务|支持|支持|<br>|变更通知|支持|支持|<br>|用户权限|RBAC|ACLs|<br>|HTTP|支持|支持|<br>|成员变更|支持|支持|<br>|一致性算法|Raft|Gossip|<br>|CAP|CP|CP|<br>|高负载读写性能|高|低|<br>|部署运维|简单|简单|<br>|监控|支持metric监控|支持metric监控|</p>
<p>可以看出， 两者的差异不是太大， 但是为了注册中心能一直保存高可用， 它也需要一些维护成本的， 所以一般来说公司有什么现成的配置中心， 就用什么什么配置中心， 在其他情况， 想要高性能的就采用<code>etcd</code>， 想要自带完备注册中新功能的以及多数据中心的则选择<code>Consul</code></p>
<blockquote>
<p>注册中心的调用接口很简单， 通常只有几个接口， 而微服务一般涉及到了多语言的调用， 为了能兼容多语言， 一般都要挑选支持<code>HTTP</code>协议的注册中心， 如果需要性能强劲的， 只需要挑选支持其他通讯协议的注册中心（当然， 生态完善的注册中心即使采用私有协议， 当它提供了众多语言的Sdk， 也是可以挑选的）。</p>
</blockquote>
]]></content>
      <categories>
        <category>RPC框架编写实践</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>RPC</tag>
      </tags>
  </entry>
  <entry>
    <title>RPC框架编写实践-RPC常见限流方法的实现</title>
    <url>/2021/11/15/RPC%E6%A1%86%E6%9E%B6%E7%BC%96%E5%86%99%E5%AE%9E%E8%B7%B5--%E5%B8%B8%E8%A7%81%E9%99%90%E6%B5%81%E6%96%B9%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h2 id="前记"><a href="#前记" class="headerlink" title="前记"></a>前记</h2><p>在微服务中， 虽然服务间的调用都是可信的， 但是服务端也需要堤防一些流量， 防止被意外的流量击垮， 而通过限流可以防止问题的发生。此外， 使用不同的限流规则还能根据系统间不同服务的请求进行限制， 解决某个函数被频繁调用而拖垮整个系统的问题。</p>
<blockquote>
<p>NOTE: 虽然本文是在编写RPC框架有感而发， 但是也适用于常见的Web服务等有流量进出的场景。</p>
</blockquote>
<h2 id="1-限流的简介"><a href="#1-限流的简介" class="headerlink" title="1 限流的简介"></a>1 限流的简介</h2><h3 id="1-1-限流的作用和场景"><a href="#1-1-限流的作用和场景" class="headerlink" title="1.1 限流的作用和场景"></a>1.1 限流的作用和场景</h3><p>对于后端服务来说， 他们提供的服务都有一个极限的QPS(除代码逻辑外，也跟机器配置有关)， 当服务端的压力超过这个极限值的时候， 服务端的响应性能就会快速的下降, 然后无法提供服务， 所以服务端需要一个类似于可以限制请求数的功能， 使服务端能牺牲掉部分请求， 保证还能处理一定量的请求， 防止服务端出现压力瓶颈，无法处理所有请求。 </p>
<p>不过这个功能还需要尽量的智能， 在设计时可以根据流量场景不同来做有差别的限制， 使其在不影响其它请求的情况下， 实现部分请求的网络流量整形， 达到减少系统资源消耗的效果， 常见的几种需要做差别限制的场景如下：</p>
<table>
<thead>
<tr>
<th>场景</th>
<th>可能造成的影响</th>
<th>限流的作用</th>
</tr>
</thead>
<tbody><tr>
<td>总体的API有大量的并发调用， 导致系统QPS超过设计值</td>
<td>机器可能会扛不住， 造成系统崩溃</td>
<td>减少进入业务的流量， 保证QPS被限制在某个合理值， 其它请求会被丢弃</td>
</tr>
<tr>
<td>某个API耗时比较长， 其它API的QPS位于合理范围内</td>
<td>由于API耗时较长， 该API的调用次数变多的情况下， 会明显消耗系统资源， 同时也可能造成数据竞争的情况</td>
<td>针对性的限制耗时API， 防止该API引起系统崩溃</td>
</tr>
<tr>
<td>总体API的QPS位于合理范围内， 但是有部分参数会引起较大的系统资源消耗</td>
<td>比如某个筛选参数造成查全表的情况， 此时可能造成数据库处理能力下降，进而造成后端服务无响应</td>
<td>针对性的根据耗时API的参数进行限制限制， 防止该API引起系统崩溃</td>
</tr>
<tr>
<td>总体API的QPS位于合理范围内， 但某个API的某个参数被大多数人调用， 导致整个API无法提供服务， 比如微博的话题功能， 如果有个爆炸性话题， 这个话题就会成为热点参数</td>
<td>造成整个API无法使用， 严重时会造成整个服务不可用</td>
<td>通过对热点参数的限制， 保证其它功能能正常使用</td>
</tr>
</tbody></table>
<h3 id="1-2-限流的组件"><a href="#1-2-限流的组件" class="headerlink" title="1.2 限流的组件"></a>1.2 限流的组件</h3><p>通过上述场景可以看到， 在这些场景中限流的作用是差不多的, 一般只涉及到两个维度：</p>
<ul>
<li>时间： 对某个时间窗口进行限流</li>
<li>资源： 针对某个API或者某个API的参数进行限流，达到保护后方对应的资源。</li>
</ul>
<p>限流可以保证在某段时间内的某个资源的请求数量不会超过设计值， 达到保护系统的作用， 不过不同场景主要差别是限制的资源维度不一样， 资源维度的变化从总体服务到某个API到某个API的某个参数, 资源维度越来越细， 而这个资源维度区分也就是我们要实现限流的第一步–流量匹配， 只要流量匹配了， 限流系统就可以开始工作了， 一般的限流系统流程图如下(其中他服务核心代表微服务核心)：</p>
<p><img    class="lazyload" data-original="https://ftp.bmp.ovh/imgs/2021/12/ca851690f268cb53.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">限流</span></p>
<p>流程图中第一步是规则匹配， 它会通过一个函数把流量提取出来， 当做Key， 这个Key等于某个资源, 然后判断这个Key是否匹配到规则， 如果命中规则就开始执行规则并结合这段规则和限流算法来判断该流量是否限流， 如果限流就丢弃或者等待， 如果没被限流， 就直接放行。</p>
<p>此外， 流程图的最下层有一个很大的Backend， 它可以用来存储规则以及存储一些限流相关的计算变量。<br>其中，限流相关的计算变量都是跟时间相关的, 且每次都要进行读写， 最好的情况是放在内存之中，不过它不能跟请求绑定在一起， 因为跟当前请求的生命周期不一样， 不能在发送请求结束后就把变量回收了， 这些变量也需要有个容器可以存储, 供不同的请求读写， 但是在一个集群服务中， 每个机器都只存储自己的计算变量则会导致多台机器没办法共享数据而造成限流失败。</p>
<p>比如针对某个用户可以调用某个API的规则是一秒内可以请求十次， 目前有十台机器， 他们不会互相共享自己的限流计算变量， 那么在最坏的情况下， 用户可以在1秒内访问100次请求而不被限流， 这样是达不了限流的效果的， 所以限流必定是一个中心化的应用。<br>目前两个比较主流的限流方案分别是网关限流和中间件限流， 网关限流场景下所有入站流量都会经过网关这个单体， 然后由网关决定是否放行;而中间件限流则是把计算变量都存在某个中间件存储中， 然后每个服务的限流组件都可以从中间件实时写入和读取数据, 其中最常用的中间件是<code>Redis</code>, 因为<code>Redis</code>的速度快， 能让限流组件很快的判断是否需要限流， 对机器的性能开销占比也不是很多， 同时<code>Redis</code>支持的数据结构和功能非常的多， 我们可以很容易的基于它来实现不同的限流算法。</p>
<p>至于限流的规则， 由于它只要写入一次， 后面都是以读为主， 所以在网关场景下都存在于内存之中， 但在中间件场景下规则都是存在一个集中式存储中， 如<code>Etcd</code>， 然后每个服务会同步集中式存储的规则， 并写入到自己的内存中。</p>
<p>在实际的落地要选择网关限流还是中间件限流主要还是取决于是服务的应用场景， 比如接口外层都有加一层网关， 那采用网关限流即可， 如果是内部服务或者该服务的通信协议是自定义的， 则采用中间件方式， 有比较强的自定义性。</p>
<blockquote>
<p>在使用<code>Redis</code>下的某些情况下(取决于搭建方式)， 有可能造成数据不准的情况， 但是限流的频率是允许有些许误差的， 比如限流的规则是1秒可以访问100次， 但在某些时候只实现了1秒访问110次也是没太大关系的。</p>
</blockquote>
<h3 id="1-3-限流算法"><a href="#1-3-限流算法" class="headerlink" title="1.3 限流算法"></a>1.3 限流算法</h3><p>上面所说的都是一些简单的概念， 而限流的核心是在于限流算法的实现， 常见的限流算法有以下几种(由于大多数都限流backend默认是<code>Redis</code>， 所以以可以在<code>Redis</code>运行的lua代码示例):</p>
<h4 id="1-3-1-固定窗口"><a href="#1-3-1-固定窗口" class="headerlink" title="1.3.1 固定窗口"></a>1.3.1 固定窗口</h4><p>固定窗口的原理比较简单，就是将时间切分成若干个时间片，每个时间片内固定处理若干个请求。比如限流规则是10秒内最多处理5个请求， 那么就会有一个容器来统计这10秒内的请求数， 如果容器的统计数量大于5, 那么后续的请求都会被拒绝， 然后每隔10秒重置这个容器的统计。<br>这种实现非常简单， 但不是非常严谨， 假如限制规则是1秒限制100个， 但在最坏的情况下， 在第一个窗口的0.5秒后到第二个窗口的0.5秒前的这个时间点共计会放行200个请求， 所以固定窗口只适用于一些要求不严格的场景, 通过下图的左图可以看到限流的流程， 通过下图的右图可以看到整个限流曲线不平滑。</p>
<p><img    class="lazyload" data-original="https://ftp.bmp.ovh/imgs/2021/12/56af316f141b421e.jpg" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">固定窗口</span></p>
<p>固定窗口的实现很简单， 在<code>Redis</code>中的lua代码如下:</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">-- keys为传入的命令， 其中keys[1]为限流的key </span><br><span class="hljs-comment">-- argv为传入的参数, ARGV[1]为窗口限制量， ARGV[2]为窗口时间 </span><br><span class="hljs-keyword">local</span> count<br><span class="hljs-keyword">local</span> limit ＝ ARGV[<span class="hljs-number">1</span>]<br>count = redis.call(<span class="hljs-string">&quot;incr&quot;</span>,KEYS[<span class="hljs-number">1</span>])<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">tonumber</span>(count) == <span class="hljs-number">1</span> <span class="hljs-keyword">then</span><br>    <span class="hljs-comment">-- 返回1代表是第一个， 该key刚被创建， 需要设置过期时间</span><br>    redis.call(<span class="hljs-string">&quot;expire&quot;</span>,KEYS[<span class="hljs-number">1</span>], ARGV[<span class="hljs-number">2</span>]])<br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">return</span> count＜limit <br></code></pre></td></tr></table></figure>
<h4 id="1-3-2-滑动窗口"><a href="#1-3-2-滑动窗口" class="headerlink" title="1.3.2 滑动窗口"></a>1.3.2 滑动窗口</h4><p>滑动窗口是固定窗口的改进方法, 他是通过增加窗口数量使限流算法更顺滑, 本身从一个窗口变为一个先进先出的队列， 队列的内容是更加精细的窗口，比如原来是10秒一个窗口， 现在会改为1秒一个窗口， 然后每隔一秒钟滑动一个窗口。 只写入最新的窗口而读取判断时都是取最近10个窗口， 这样就可以通过减小粒度来让限流算法更加精细， 可以看到波动幅度会变小(取决于精细程度)：<br><img    class="lazyload" data-original="https://ftp.bmp.ovh/imgs/2021/12/903fd7f707c3e735.jpg" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">滑动窗口</span><br>滑动窗口的实现也是很简单的， 具体见:<a href="https://so1n.me/2021/08/24/RPC%E6%A1%86%E6%9E%B6%E7%BC%96%E5%86%99%E5%AE%9E%E8%B7%B5--%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86%E7%9A%84%E5%9F%BA%E7%9F%B3/">RPC框架编写实践–服务治理的基石</a>, 在<code>Redis</code>可以采用<code>Zset</code>数据结构进行实现, 这里就不做代码示例了。 滑动窗口是牺牲一定的内存来让限流变得平滑，窗口数量越多, 限流速率越精细， 占用的内存就越大， 同时获取数据时都是获取一批窗口的数据， 相比于固定窗口来说，它的时间复杂度也会跟着变多(O(k))。</p>
<h4 id="1-3-3-漏桶"><a href="#1-3-3-漏桶" class="headerlink" title="1.3.3 漏桶"></a>1.3.3 漏桶</h4><p>漏桶的出现可以完美的解决参差不齐的速率限制问题, 漏桶算法的核心原理是进入漏桶的请求量不限制， 但能漏出去的速率请求是恒定的， 这样就能完美的控制请求的速率， 如果桶满了， 在漏桶里的请求就会溢出去, 达到丢弃请求的目的， 如下图， 整个请求的速率都是很平滑的， 没有多少毛尖：<br><img    class="lazyload" data-original="https://ftp.bmp.ovh/imgs/2021/12/a3d92cf918c189a5.jpg" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">漏桶</span></p>
<p>从图中可以看到， 漏桶的原理很像一个FIFO队列， 然后有个定时器会以恒定的速率把请求取出来， 使用<code>Python</code>代码实现如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> asyncio<br><br><span class="hljs-comment"># 假设容量只有10</span><br><span class="hljs-keyword">import</span> time<br><br>leaky_bucket: asyncio.Queue = asyncio.Queue(<span class="hljs-number">10</span>)<br>loop: asyncio.AbstractEventLoop = asyncio.get_event_loop()<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">demo_request</span>(<span class="hljs-params">cnt: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>    <span class="hljs-string">&quot;&quot;&quot;模仿请求&quot;&quot;&quot;</span><br>    msg: <span class="hljs-built_in">str</span> = <span class="hljs-string">f&quot;I&#x27;m mock request:<span class="hljs-subst">&#123;cnt&#125;</span>&quot;</span><br>    future: asyncio.Future = asyncio.Future()<br>    <span class="hljs-keyword">try</span>:<br>        leaky_bucket.put_nowait(future)<br>    <span class="hljs-keyword">except</span> asyncio.QueueFull:<br>        <span class="hljs-comment"># 代表桶满了， 溢出来， 该请求要提前抛弃</span><br>        print(<span class="hljs-string">f&quot;Fail Request:<span class="hljs-subst">&#123;msg&#125;</span>&quot;</span>)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-comment"># 等待放行</span><br>        <span class="hljs-keyword">await</span> future<br>        print(time.time(), msg)<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">timer</span>() -&gt; <span class="hljs-keyword">None</span>:</span><br>    <span class="hljs-string">&quot;&quot;&quot;定时放行请求&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-comment"># 放行该请求</span><br>        future: asyncio.Future = leaky_bucket.get_nowait()<br>        future.set_result(<span class="hljs-literal">True</span>)<br>    <span class="hljs-keyword">except</span> asyncio.QueueEmpty:<br>        <span class="hljs-keyword">pass</span><br>    <span class="hljs-comment"># 一秒执行一次</span><br>    loop.call_later(<span class="hljs-number">1</span>, timer)<br><br>timer()<br><span class="hljs-comment"># 模拟并发12个请求</span><br>loop.run_until_complete(asyncio.gather(*[demo_request(i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">12</span>)]))<br></code></pre></td></tr></table></figure>
<p>但是， 这样实现的漏桶算法依然需要占用一些空间用来存储等待放行的请求， 直到放行才被释放。 为了解决空间占用的问题， 可以采用GCRA算法， 它从另外一个角度看起来跟漏桶算法很像（GRRA应该被认为是计量器实现的漏桶版本， 而不是上面所说的队列形漏桶）, 但很省空间占用， 因为无论漏桶多大， 它的空间占用都是恒定的, 只需要存漏水速率（可以认为是该时间段可以放行的请求量）以及桶目前的容量即可。 </p>
<p>使用GCRA算法之所以能这样省空间， 主要还是它是基于虚拟调度实现的， 它只需要存一个漏水速率，然后每次有请求进来时判断现在可否可以漏水， 如果可以就放行， 如果不可以则判断桶是否满， 满则抛弃请求， 没满则让请求等待， 直到可以放行为止。<br>常见的GCRA限流实现一般都考虑使用<a href="https://github.com/brandur/redis-cell">redis-cell</a>, 它的使用方法如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 第一个参数为命令， 第二个参数是要限流的key, 第三个参数是桶容量， 第四第五综合起来为漏桶速率， 第五个为每次漏多少</span><br><br><span class="hljs-comment"># 第一次请求放行， 可以发现容量变多了一个</span><br>127.0.0.1:6379&gt; CL.THROTTLE demo_leaky_bucket 2 1 10 1<br>1) <span class="hljs-string">&quot;0&quot;</span>     <span class="hljs-comment"># 0表示允许， 1表示拒绝</span><br>2) <span class="hljs-string">&quot;3&quot;</span>     <span class="hljs-comment"># 漏桶容量(会比输入的多1)</span><br>3) <span class="hljs-string">&quot;2&quot;</span>     <span class="hljs-comment"># 漏斗剩余空间</span><br>4) <span class="hljs-string">&quot;-1&quot;</span>    <span class="hljs-comment"># 如果拒绝， 需要多长时间后重试, 单位秒</span><br>5) <span class="hljs-string">&quot;10&quot;</span>    <span class="hljs-comment"># 多少时间后，漏桶完全空了, 单位秒</span><br><br><span class="hljs-comment"># 第二次请求被放行， 但是漏斗已经被占了一个空位</span><br>127.0.0.1:6379&gt; CL.THROTTLE demo_leaky_bucket 2 1 10 1<br>1) <span class="hljs-string">&quot;0&quot;</span><br>2) <span class="hljs-string">&quot;3&quot;</span><br>3) <span class="hljs-string">&quot;1&quot;</span><br>4) <span class="hljs-string">&quot;-1&quot;</span><br>5) <span class="hljs-string">&quot;18&quot;</span><br><span class="hljs-comment"># 第三次请求被放行， 但是漏斗已经被占了两个个空位</span><br>127.0.0.1:6379&gt; CL.THROTTLE demo_leaky_bucket 2 1 10 1<br>1) <span class="hljs-string">&quot;0&quot;</span><br>2) <span class="hljs-string">&quot;3&quot;</span><br>3) <span class="hljs-string">&quot;0&quot;</span><br>4) <span class="hljs-string">&quot;-1&quot;</span><br>5) <span class="hljs-string">&quot;27&quot;</span><br><span class="hljs-comment"># 第四次请求不被放行， 但是漏斗没有空位了</span><br>127.0.0.1:6379&gt; CL.THROTTLE demo_leaky_bucket 2 1 10 1<br>1) <span class="hljs-string">&quot;1&quot;</span><br>2) <span class="hljs-string">&quot;3&quot;</span><br>3) <span class="hljs-string">&quot;0&quot;</span><br>4) <span class="hljs-string">&quot;6&quot;</span><br>5) <span class="hljs-string">&quot;26&quot;</span><br></code></pre></td></tr></table></figure>
<p>从命令可以看出, 即使漏斗中还有数据没漏出去， 返回值得第一个也还是0， 表示放行， 这样并不是一个完善的GCRA。 为了实现一个完备的GCRA， 我们需要额外的在代码判断漏桶是否全空， 如果放行且桶不是全空， 则需要在代码判断多久后才能会为空， 这个时间也就是请求的等待放行时间, 在等待这段时间后才能放行请求， 如果不是放行， 则直接丢弃请求即可。</p>
<p>不过， 如果不做任何判断， 直接使用返回值的第一个值来判断是否放行请求， 那这个实现就很像下面所说的令牌桶的实现。 </p>
<h4 id="1-3-4-令牌桶"><a href="#1-3-4-令牌桶" class="headerlink" title="1.3.4 令牌桶"></a>1.3.4 令牌桶</h4><p>漏桶能很好的控制速率， 使其变得平滑， 但是它没办法应对突发流量， 比如我们把规则定义为10秒内可以请求10次， 对于漏桶来说， 它会控制为1秒放行一个请求， 如果同时收到10个请求时它则会分开10秒放行每个请求。 然而10秒内可以请求10次的含义是10秒内总共可以请求10次， 也就是允许在这10秒内的某个瞬间同时放行10个请求, 对于这个问题可以使用令牌桶来解决, 令牌桶和漏桶很像， 只是漏桶控制的是请求， 令牌桶控制的是令牌发放速度。 </p>
<p>令牌桶算法规定每个请求需要从桶里拿到并消耗一个令牌才可以放行， 拿不到则会被抛弃， 同时令牌桶本身会以恒定的速率产生令牌， 直到桶满为止， 这样就可以保证限流的平缓， 同时又能应对突发请求， 令牌桶的原理图和限流曲线图如下， 其中限流曲线图表示初始时桶里面放满了令牌， 所以放行的请求很多， 随着令牌被逐渐消耗并消耗光了， 限流的曲率会稳定在一条线上, 也就是令牌的生产速率：<br><img    class="lazyload" data-original="https://ftp.bmp.ovh/imgs/2021/12/6717929962afbe1d.jpg" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">令牌桶</span></p>
<p>同样的， 在实现令牌桶时为了减少空间的占用， 也会使用虚拟调度方法， 只存一个时间和容量到内存中， 每次收到请求时都会根据请求的时间和在内存中的时间差值再乘以速率计算这段时间应该产生的令牌数量并存到内存中， 然后再判断是否有足够的令牌来判断是否放行请求， 具体的<code>Redis</code> lua代码实现如下：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> key = KEYS[<span class="hljs-number">1</span>] <span class="hljs-comment">-- key</span><br><span class="hljs-keyword">local</span> current_time = redis.call(<span class="hljs-string">&#x27;TIME&#x27;</span>)[<span class="hljs-number">1</span>] <span class="hljs-comment">-- redis时间戳</span><br><span class="hljs-keyword">local</span> interval_per_token = <span class="hljs-built_in">tonumber</span>(ARGV[<span class="hljs-number">1</span>]) <span class="hljs-comment">--每个单位产生多少个token</span><br><span class="hljs-keyword">local</span> max_token = <span class="hljs-built_in">tonumber</span>(ARGV[<span class="hljs-number">2</span>]) <span class="hljs-comment">-- 桶最大的量</span><br><span class="hljs-keyword">local</span> init_token = <span class="hljs-built_in">tonumber</span>(ARGV[<span class="hljs-number">3</span>]) <span class="hljs-comment">-- 桶初始量</span><br><span class="hljs-keyword">local</span> tokens<br><span class="hljs-comment">-- 上次请求时保留的桶数据</span><br><span class="hljs-keyword">local</span> bucket = redis.call(<span class="hljs-string">&quot;hmget&quot;</span>, key, <span class="hljs-string">&quot;last_time&quot;</span>, <span class="hljs-string">&quot;last_token&quot;</span>)<br><span class="hljs-keyword">local</span> last_time= bucket[<span class="hljs-number">1</span>]<br><span class="hljs-keyword">local</span> last_token = bucket[<span class="hljs-number">2</span>]<br><span class="hljs-keyword">if</span> last_time == <span class="hljs-literal">false</span> <span class="hljs-keyword">or</span> last_token == <span class="hljs-literal">false</span> <span class="hljs-keyword">then</span><br>    <span class="hljs-comment">-- 如果没数据， 则代表该资源是第一次访问， 进行初始化</span><br>    tokens = init_token<br>    redis.call(<span class="hljs-string">&#x27;hset&#x27;</span>, key, <span class="hljs-string">&#x27;last_time&#x27;</span>, current_time)<br><span class="hljs-keyword">else</span><br>    <span class="hljs-comment">-- 算出间隔时间</span><br>    <span class="hljs-keyword">local</span> this_interval = current_time - <span class="hljs-built_in">tonumber</span>(last_time)<br>    <span class="hljs-keyword">if</span> this_interval &gt; <span class="hljs-number">1</span> <span class="hljs-keyword">then</span><br>        <span class="hljs-comment">-- 算出该时间应该产生的令牌</span><br>        <span class="hljs-keyword">local</span> tokens_to_add = <span class="hljs-built_in">math</span>.<span class="hljs-built_in">floor</span>(this_interval * interval_per_token)<br>        <span class="hljs-comment">-- 算出真实可以拥有的令牌</span><br>        tokens = <span class="hljs-built_in">math</span>.<span class="hljs-built_in">min</span>(last_token + tokens_to_add, max_token)<br>        <span class="hljs-comment">-- 保存数据</span><br>        redis.call(<span class="hljs-string">&#x27;hset&#x27;</span>, key, <span class="hljs-string">&#x27;last_time&#x27;</span>, current_time)<br>    <span class="hljs-keyword">else</span><br>        tokens = <span class="hljs-built_in">tonumber</span>(last_token)<br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">if</span> tokens &lt; <span class="hljs-number">1</span> <span class="hljs-keyword">then</span><br>    <span class="hljs-comment">-- 令牌不够消费</span><br>    redis.call(<span class="hljs-string">&#x27;hset&#x27;</span>, key, <span class="hljs-string">&#x27;last_token&#x27;</span>, tokens)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br><span class="hljs-keyword">else</span><br>    <span class="hljs-comment">-- 消费令牌并返回令牌数, 代表可以消费</span><br>    tokens = tokens - <span class="hljs-number">1</span><br>    redis.call(<span class="hljs-string">&#x27;hset&#x27;</span>, key, <span class="hljs-string">&#x27;last_token&#x27;</span>, tokens)<br>    <span class="hljs-keyword">return</span> tokens<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure>
<h2 id="2-具体实现"><a href="#2-具体实现" class="headerlink" title="2.具体实现"></a>2.具体实现</h2><p>上面说完了算法实现后， 接下来来看看该如何结合算法进行实现， 由于代码会随时更新，具体源码更新见： <a href="https://github.com/so1n/rap/tree/master/rap/server/plugin/processor/limit">https://github.com/so1n/rap/tree/master/rap/server/plugin/processor/limit</a></p>
<p>项目的代码结构如下, 在常见的后端服务中需要占用空间少， 然后速度尽量快点限流组件， 所以一般只用漏桶或者令牌桶且基于<code>Redis</code>的实现, 这里就不会去实现窗口相关的限流了:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">├── backend  <span class="hljs-comment"># 算法</span><br>│   ├── base.py  <span class="hljs-comment"># 封装的协议</span><br>│   └── redis.py  <span class="hljs-comment"># 基于redis当做banckend的算法实现</span><br>├── core.py  <span class="hljs-comment"># 核心判断代码， 实际上是一个中间流量处理</span><br>├── rule.py  <span class="hljs-comment"># 规则声明</span><br>└── util.py  <span class="hljs-comment"># 其它小代码</span><br></code></pre></td></tr></table></figure>
<p>首先是<code>rule.py</code>里的规则类, 它主要是声明了限流速率， 初始化token数量， 最多的tokens数量以及停用时间， 其中停用时间是用来防止恶意用户频繁刷新， 它的逻辑是当漏桶已经满了或者令牌桶没有令牌的时候， 限流组件会在停用时间内不再提供服务。</p>
<p>然后就是<code>backend.base.py</code>, 它是一个限流算法的统一封装， 代码如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> Any, Coroutine, Union<br><br><span class="hljs-keyword">from</span> rap.server.plugin.processor.limit.rule <span class="hljs-keyword">import</span> Rule<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseLimitBackend</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">can_requests</span>(<span class="hljs-params">self, key: <span class="hljs-built_in">str</span>, rule: Rule, token_num: <span class="hljs-built_in">int</span> = <span class="hljs-number">1</span></span>) -&gt; Union[bool, Coroutine[Any, Any, bool]]:</span><br>        <span class="hljs-keyword">raise</span> NotImplementedError<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">expected_time</span>(<span class="hljs-params">self, key: <span class="hljs-built_in">str</span>, rule: Rule</span>) -&gt; Union[float, Coroutine[Any, Any, float]]:</span><br>        <span class="hljs-keyword">raise</span> NotImplementedError<br></code></pre></td></tr></table></figure>
<p>这个类它声明了两个方法， 一个是<code>can_request</code>, 它会根据算法来判断是否放行， 如果需要等待， 则会在这个方法里进行等待， 直到到时间后才返回放行标记, 其中<code>can_request</code>还内嵌了一个<code>block_time</code>的逻辑； 另外一个是<code>expected_time</code>， 用来获取下次可用的时间, 具体的实现以<code>RedisCellBackend</code>为例子， 它是一个子类。</p>
<p>它的最上层实现是<code>BaseLimitBackend</code>, 然后就是继承于<code>BaseLimitBackend</code>的<code>BaseRedisBackend</code>, 这个组件<code>Redis</code>限流算法的基础实现， 主要是实现了一个停用时间的逻辑， 当发现不放行请求的时候， 会启用停用逻辑， 以停用后续相同key的请求：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseRedisBackend</span>(<span class="hljs-params">BaseLimitBackend, ABC</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, redis: Union[StrictRedis, StrictRedisCluster]</span>):</span><br>        <span class="hljs-comment"># 初始化Redis模块</span><br>        self._redis: <span class="hljs-string">&quot;Union[StrictRedis, StrictRedisCluster]&quot;</span> = redis<br><br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_block_time_handle</span>(<span class="hljs-params">self, key: <span class="hljs-built_in">str</span>, rule: Rule, func: Callable[..., Awaitable[<span class="hljs-built_in">bool</span>]]</span>) -&gt; bool:</span><br>        <span class="hljs-string">&quot;&quot;&quot;处理block_time逻辑&quot;&quot;&quot;</span><br>        block_time_key: <span class="hljs-built_in">str</span> = <span class="hljs-string">f&quot;<span class="hljs-subst">&#123;key&#125;</span>:block_time&quot;</span><br>        bucket_block_time: Optional[<span class="hljs-built_in">int</span>] = rule.block_time<br><br>        <span class="hljs-keyword">if</span> bucket_block_time <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">await</span> self._redis.exists(block_time_key):<br>            <span class="hljs-comment"># 启用block_time逻辑， 且key已经存在， 那么直接返回False告诉该请求应该被拒绝 </span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br>        <span class="hljs-comment"># 执行正真的判断是否限流逻辑</span><br>        can_requests: <span class="hljs-built_in">bool</span> = <span class="hljs-keyword">await</span> func()<br><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> can_requests <span class="hljs-keyword">and</span> bucket_block_time <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-comment"># 启用block_time逻辑且被限流时, 正式启用block time逻辑 </span><br>            <span class="hljs-keyword">await</span> self._redis.<span class="hljs-built_in">set</span>(block_time_key, bucket_block_time, ex=bucket_block_time)<br><br>        <span class="hljs-keyword">return</span> can_requests<br></code></pre></td></tr></table></figure>
<p>接着就是继承于<code>BaseRedisBackend</code>的<code>BaseRedisCellBackend</code>, 它主要是提供一个命令调用的封装以及获取还有多久后才能请求的封装：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseRedisCellBackend</span>(<span class="hljs-params">BaseRedisBackend</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    use redis-cell module</span><br><span class="hljs-string">    learn more:https://github.com/brandur/redis-cell</span><br><span class="hljs-string"></span><br><span class="hljs-string">    input: CL.THROTTLE user123 15 30 60 1</span><br><span class="hljs-string">        # param  |  desc</span><br><span class="hljs-string">        # user123 key</span><br><span class="hljs-string">        # 15 maxburst</span><br><span class="hljs-string">        # 30 token</span><br><span class="hljs-string">        # 60 seconds</span><br><span class="hljs-string">        # 1 apply 1token</span><br><span class="hljs-string">    output:</span><br><span class="hljs-string">        1) (integer) 0        # is allowed</span><br><span class="hljs-string">        2) (integer) 16       # total bucket num</span><br><span class="hljs-string">        3) (integer) 15       # the remaining limit of the key.</span><br><span class="hljs-string">        4) (integer) -1       # the number of seconds until the user should retry,</span><br><span class="hljs-string">                              #   and always -1 if the action was allowed.</span><br><span class="hljs-string">        5) (integer) 2        # The number of seconds until the limit will reset to its maximum capacity</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br><br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_call_cell</span>(<span class="hljs-params">self, key: <span class="hljs-built_in">str</span>, rule: Rule, token_num: <span class="hljs-built_in">int</span> = <span class="hljs-number">1</span></span>) -&gt; List[int]:</span><br>        <span class="hljs-string">&quot;&quot;&quot;调用redis_cell&quot;&quot;&quot;</span><br>        result: List[<span class="hljs-built_in">int</span>] = <span class="hljs-keyword">await</span> self._redis.execute_command(<br>            <span class="hljs-string">&quot;CL.THROTTLE&quot;</span>, key, rule.max_token - <span class="hljs-number">1</span>, rule.gen_token, <span class="hljs-built_in">int</span>(rule.total_second), token_num<br>        )<br>        <span class="hljs-keyword">return</span> result<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">expected_time</span>(<span class="hljs-params">self, key: <span class="hljs-built_in">str</span>, rule: Rule</span>) -&gt; Union[float, Coroutine[Any, Any, float]]:</span><br>        <span class="hljs-string">&quot;&quot;&quot;获取下次可请求时间&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_expected_time</span>() -&gt; float:</span><br>            block_time_key: <span class="hljs-built_in">str</span> = key + <span class="hljs-string">&quot;:block_time&quot;</span><br>            block_time = <span class="hljs-keyword">await</span> self._redis.get(block_time_key)<br>            <span class="hljs-keyword">if</span> block_time:<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> self._redis.ttl(block_time_key)<br><br>            result: List[<span class="hljs-built_in">int</span>] = <span class="hljs-keyword">await</span> self._call_cell(key, rule, <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">float</span>(<span class="hljs-built_in">max</span>(result[<span class="hljs-number">3</span>], <span class="hljs-number">0</span>))<br><br>        <span class="hljs-keyword">return</span> _expected_time()<br></code></pre></td></tr></table></figure>
<p>最后就是真正的对外使用的限流组件实现， 这个实现是基于漏桶算法的， 它继承于<code>BaseRedisCellBackend</code>（另外一个继承于<code>BaseRedisCellBackend</code>的实现是基于令牌桶算法的， 可以通过源码了解）, 可以看到非常的简单， 本质上是基于<code>redis-cell</code>的返回判断是否放行。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedisCellBackend</span>(<span class="hljs-params">BaseRedisCellBackend</span>):</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">can_requests</span>(<span class="hljs-params">self, key: <span class="hljs-built_in">str</span>, rule: Rule, token_num: <span class="hljs-built_in">int</span> = <span class="hljs-number">1</span></span>) -&gt; Union[bool, Coroutine[Any, Any, bool]]:</span><br>        <span class="hljs-string">&quot;&quot;&quot;通过redis-cell判断是否可以请求，以及是否需要休眠等待， 如果需要则休眠固定的时间后再放行&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_can_requests</span>() -&gt; bool:</span><br>            result: List[<span class="hljs-built_in">int</span>] = <span class="hljs-keyword">await</span> self._call_cell(key, rule, token_num)<br>            can_requests: <span class="hljs-built_in">bool</span> = result[<span class="hljs-number">0</span>] == <span class="hljs-number">0</span><br>            <span class="hljs-keyword">if</span> can_requests <span class="hljs-keyword">and</span> result[<span class="hljs-number">4</span>]:<br>                <span class="hljs-keyword">await</span> asyncio.sleep(result[<span class="hljs-number">4</span>])<br>            <span class="hljs-keyword">return</span> can_requests<br><br>        <span class="hljs-keyword">return</span> self._block_time_handle(key, rule, _can_requests)<br></code></pre></td></tr></table></figure>
<p>了解完算法的实现后， 接下来就是核心的判断逻辑, 具体见注释:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LimitProcessor</span>(<span class="hljs-params">BaseProcessor</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, backend: BaseLimitBackend, rule_list: List[Tuple[RULE_FUNC_TYPE, Rule]]</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;初始化规则和算法逻辑， 这里的规则之所以是使用传参的方式是仅供参考， 后续整个框架的配置都会抽离成一个config， 供其它组件调用&quot;&quot;&quot;</span><br>        self._backend: BaseLimitBackend = backend<br>        self._rule_list: List[Tuple[RULE_FUNC_TYPE, Rule]] = rule_list<br><br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">process_request</span>(<span class="hljs-params">self, request: Request</span>) -&gt; Request:</span><br>        <span class="hljs-comment"># not limit client event</span><br>        <span class="hljs-keyword">if</span> request.msg_type == constant.CLIENT_EVENT:<br>            <span class="hljs-comment"># 屏蔽event请求</span><br>            <span class="hljs-keyword">return</span> request<br><br>        <span class="hljs-keyword">for</span> func, rule <span class="hljs-keyword">in</span> self._rule_list:<br>            <span class="hljs-comment"># 获取该请求的key</span><br>            <span class="hljs-keyword">if</span> inspect.iscoroutinefunction(func):<br>                key, is_ignore_limit = <span class="hljs-keyword">await</span> func(request)  <span class="hljs-comment"># type: ignore</span><br>            <span class="hljs-keyword">else</span>:<br>                key, is_ignore_limit = func(request)<br>            <span class="hljs-keyword">if</span> is_ignore_limit:<br>                <span class="hljs-comment"># 如果该请求不应该限流， 直接跳过限流逻辑</span><br>                <span class="hljs-keyword">return</span> request<br>            <span class="hljs-keyword">if</span> key:<br>                <span class="hljs-comment"># 匹配到key， 进入限流逻辑</span><br>                <span class="hljs-keyword">break</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">raise</span> TooManyRequest()<br><br>        <span class="hljs-comment"># 通过backend判断是否限流</span><br>        key = <span class="hljs-string">f&quot;rap:processor:<span class="hljs-subst">&#123;self.__class__.__name__&#125;</span>:<span class="hljs-subst">&#123;key&#125;</span>&quot;</span><br>        can_requests: Union[<span class="hljs-built_in">bool</span>, Awaitable[<span class="hljs-built_in">bool</span>]] = self._backend.can_requests(key, rule)<br>        <span class="hljs-keyword">if</span> inspect.isawaitable(can_requests):<br>            can_requests = <span class="hljs-keyword">await</span> can_requests  <span class="hljs-comment"># type: ignore</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> can_requests:<br>            <span class="hljs-comment"># 如果被限流， 返回异常， 并告知要何时后才可以再次请求</span><br>            expected_time: Union[<span class="hljs-built_in">float</span>, Awaitable[<span class="hljs-built_in">float</span>]] = self._backend.expected_time(key, rule)<br>            <span class="hljs-keyword">if</span> inspect.isawaitable(expected_time):<br>                expected_time = <span class="hljs-keyword">await</span> expected_time  <span class="hljs-comment"># type: ignore</span><br>            <span class="hljs-keyword">raise</span> TooManyRequest(extra_msg=<span class="hljs-string">f&quot;expected time: <span class="hljs-subst">&#123;expected_time&#125;</span>&quot;</span>)<br>        <span class="hljs-keyword">return</span> request<br></code></pre></td></tr></table></figure>
<p>至此， 整个限流逻辑实现完毕, 本章内容完。</p>
<h2 id="3-其它碎碎念"><a href="#3-其它碎碎念" class="headerlink" title="3.其它碎碎念"></a>3.其它碎碎念</h2><h3 id="3-1-热点参数实现"><a href="#3-1-热点参数实现" class="headerlink" title="3.1.热点参数实现"></a>3.1.热点参数实现</h3><p>由于大部分的限流实现的backend都只要依赖于<code>Redis</code>, 所以代码仓里面只有<code>Redis</code>一种类型的backend，但是有一些限流实现需要依赖于一些特殊的backend，比如热点参数限流, 还有蜜罐之类的场景。</p>
<p>以热点参数限流场景为例子， 热点参数是一个写大于读的应用场景， 而且跟时间强相关， 所以选用时序数据库做backend，之前选用过<code>Graphite</code>当做backend, 具体实现如图后端服务会把每次请求参数都记录到时序数据库中， 并使用一个定时脚本每隔一段时间把最近的热点参数数据拉取到缓存中， 供后端服务的限流组件判断是否该放行。 其中， 这个间隔一般控制在1秒左右， 所以这是一个近实时的实现, 具体的实现图如下：<br><img   class="lazyload" data-original="https://ftp.bmp.ovh/imgs/2022/01/4ec83cd3eaff271f.jpg" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" ><br>当请求进来的时候， 限流中间件会通过异步的方法把数据记录到时序数据库中， 比如一个请求为<code>http://127.0.0.1:80?q=1&amp;b=2</code>，中间件就会发送一个以<code>&#123;prefix&#125;.hot_param.b=2&amp;b=2</code>为key, value为1的标准<code>Statsd</code>的count类型数据到<code>Statsd</code>组件中。</p>
<blockquote>
<p>这个Key采用标准的<code>Statsd</code>命令, 以<code>.</code>分割有三个值， 第一个是前缀它与业务相关, 如业务名， 函数名，namespace等等; 第二个是代表是热点参数的业务； 第三个是参数Key, 这里以<code>&amp;</code>为分割号， 然后按Key顺序排序，重新拼接为一个字符串， 这样即使请求时顺序不一致也能识别到时同种请求。</p>
</blockquote>
<p><code>Statsd</code>组件收到了数据后会自行进行统计， 统计一个时间区间都数据并写入到<code>Graphite</code>中， 然后通过定时脚本使用<code>Graphite API</code>拉取统计次数大于条件的数据写入到<code>Redis</code>缓存中， 其中<code>Statsd</code>组件的时间区间和定时脚本的定时时间都会控制在一秒左右， 所以这是一个近实时的实现， 在计算性能消耗和实现效果直接做取舍。</p>
<p>数据写入到<code>Redis</code>后， 这个写入数据和统计的异步流程就结束了， 中间件在记录数据后， 会通过<code>Redis</code>判断是否是热点参数， 并根据规则判断是否放行， 到了这里就跟上面的限流流程差不多了。</p>
<h3 id="3-2-限流算法拓展"><a href="#3-2-限流算法拓展" class="headerlink" title="3.2.限流算法拓展"></a>3.2.限流算法拓展</h3><p>限流算法不止是用于算法， 也可以用于别的地方，比如有一些游戏活动，体力值满时为5, 然后玩家每次出发活动会减少1个体力值, 然后可以使用限流算法每隔一个固定时间则增加一个体力值等等。 在遇到业务需求有跟时间相关且像上述所说的体力值会恢复的情况时， 可以往限流算法思考。</p>
]]></content>
      <categories>
        <category>RPC框架编写实践</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>限流</tag>
      </tags>
  </entry>
  <entry>
    <title>starlette源码分析</title>
    <url>/2021/11/15/starlette_source_code_analysis/</url>
    <content><![CDATA[<h2 id="前记"><a href="#前记" class="headerlink" title="前记"></a>前记</h2><p>上一篇分析了<code>uvicorn</code>， 但是<code>uvicorn</code>只是一个ASGI容器， 真正处理请求的是ASGI应用程序，而<code>starlette</code>是最出名也是最标准的ASGI应用程序， 通过了解<code>starlette</code>, 可以了解到每个组件都是ASGI APP的设计理念， 了解ASGI APP的兼容性， 能更完整的理解ASGI生态。</p>
<blockquote>
<p>NOTE: 使用了几年的<code>starlette</code>以来， 简单了翻过了几次源码， 觉得<code>starlette</code>堪称工艺品， 设计很完美， 各种逻辑实现起来很简单(也可能是我一开始就使用了sanic框架)， 从使用至今， 除了初始化中间件， 在中间件读取body以及官方示例文档比较少这些缺点外， 感觉不出有其他的槽点。</p>
</blockquote>
<span id="more"></span>
<blockquote>
<p>NOTE: 本文偏代码+注释比较多</p>
</blockquote>
<h2 id="1-starlette的应用"><a href="#1-starlette的应用" class="headerlink" title="1.starlette的应用"></a>1.starlette的应用</h2><p>在之前的<a href="https://so1n.me/2021/08/19/uvicorn/">文章</a>了解过， <code>Uvicron</code>通过一个通用的协定接口与ASGI应用程序交互， 应用程序只要实现如下代码， 即可通过<code>Uvicorn</code>发送和接收信息：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">app</span>(<span class="hljs-params">scope, receive, send</span>):</span><br>    <span class="hljs-comment"># 一个最简单的ASGI应用程序</span><br>    <span class="hljs-keyword">assert</span> scope[<span class="hljs-string">&#x27;type&#x27;</span>] == <span class="hljs-string">&#x27;http&#x27;</span><br>    <span class="hljs-keyword">await</span> send(&#123;<br>        <span class="hljs-string">&#x27;type&#x27;</span>: <span class="hljs-string">&#x27;http.response.start&#x27;</span>,<br>        <span class="hljs-string">&#x27;status&#x27;</span>: <span class="hljs-number">200</span>,<br>        <span class="hljs-string">&#x27;headers&#x27;</span>: [<br>            [<span class="hljs-string">b&#x27;content-type&#x27;</span>, <span class="hljs-string">b&#x27;text/plain&#x27;</span>],<br>        ]<br>    &#125;)<br>    <span class="hljs-keyword">await</span> send(&#123;<br>        <span class="hljs-string">&#x27;type&#x27;</span>: <span class="hljs-string">&#x27;http.response.body&#x27;</span>,<br>        <span class="hljs-string">&#x27;body&#x27;</span>: <span class="hljs-string">b&#x27;Hello, world!&#x27;</span>,<br>    &#125;)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    <span class="hljs-comment"># uvicorn服务</span><br>    <span class="hljs-keyword">import</span> uvicorn<br>    uvicorn.run(app, host=<span class="hljs-string">&quot;127.0.0.1&quot;</span>, port=<span class="hljs-number">5000</span>, log_level=<span class="hljs-string">&quot;info&quot;</span>)<br></code></pre></td></tr></table></figure>
<p>而使用<code>uvicorn</code>启动<code>starlette</code>的方式是：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">from</span> starlette.applications <span class="hljs-keyword">import</span> Starlette<br><span class="hljs-keyword">from</span> starlette.middleware.gzip <span class="hljs-keyword">import</span> GZipMiddleware<br><br><br>app: Starlette = Starlette()<br><br><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&quot;/&quot;</span></span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">demo_route</span>() -&gt; <span class="hljs-keyword">None</span>:</span> <span class="hljs-keyword">pass</span><br><br><br><span class="hljs-meta">@app.websocket_route(<span class="hljs-params"><span class="hljs-string">&quot;/&quot;</span></span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">demo_websocket_route</span>() -&gt; <span class="hljs-keyword">None</span>:</span> <span class="hljs-keyword">pass</span><br><br><br><span class="hljs-meta">@app.add_exception_handlers(<span class="hljs-params"><span class="hljs-number">404</span></span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">not_found_route</span>() -&gt; <span class="hljs-keyword">None</span>:</span> <span class="hljs-keyword">pass</span><br><br><br><span class="hljs-meta">@app.on_event(<span class="hljs-params"><span class="hljs-string">&quot;startup&quot;</span></span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">startup_event_demo</span>() -&gt; <span class="hljs-keyword">None</span>:</span> <span class="hljs-keyword">pass</span><br><br><br><span class="hljs-meta">@app.on_event(<span class="hljs-params"><span class="hljs-string">&quot;shutdown&quot;</span></span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">shutdown_event_demo</span>() -&gt; <span class="hljs-keyword">None</span>:</span> <span class="hljs-keyword">pass</span><br><br><br>app.add_middleware(GZipMiddleware)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    <span class="hljs-keyword">import</span> uvicorn<br>    uvicorn.run(app, host=<span class="hljs-string">&quot;127.0.0.1&quot;</span>, port=<span class="hljs-number">5000</span>)<br><br></code></pre></td></tr></table></figure>
<p>这段代码<code>Starlette</code>先执行了初始化, 然后注册路由，异常处理， 事件，中间件到自身， 然后传给<code>uvicorn.run</code>, <code>uvicorn.run</code>通过调用<code>starlette</code>的<code>__call__</code>的方法传递请求数据。</p>
<p>简单的了解完启动后， 先从<code>starlette</code>初始化看是分析：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Starlette</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">        self,</span></span><br><span class="hljs-function"><span class="hljs-params">        debug: <span class="hljs-built_in">bool</span> = <span class="hljs-literal">False</span>,</span></span><br><span class="hljs-function"><span class="hljs-params">        routes: typing.Sequence[BaseRoute] = <span class="hljs-literal">None</span>,</span></span><br><span class="hljs-function"><span class="hljs-params">        middleware: typing.Sequence[Middleware] = <span class="hljs-literal">None</span>,</span></span><br><span class="hljs-function"><span class="hljs-params">        exception_handlers: typing.Dict[</span></span><br><span class="hljs-function"><span class="hljs-params">            typing.Union[<span class="hljs-built_in">int</span>, typing.Type[Exception]], typing.Callable</span></span><br><span class="hljs-function"><span class="hljs-params">        ] = <span class="hljs-literal">None</span>,</span></span><br><span class="hljs-function"><span class="hljs-params">        on_startup: typing.Sequence[typing.Callable] = <span class="hljs-literal">None</span>,</span></span><br><span class="hljs-function"><span class="hljs-params">        on_shutdown: typing.Sequence[typing.Callable] = <span class="hljs-literal">None</span>,</span></span><br><span class="hljs-function"><span class="hljs-params">        lifespan: typing.Callable[[<span class="hljs-string">&quot;Starlette&quot;</span>], typing.AsyncGenerator] = <span class="hljs-literal">None</span>,</span></span><br><span class="hljs-function"><span class="hljs-params">    </span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :param debug: 决定是否启用debug功能</span><br><span class="hljs-string">        :param route: 一个路由列表, 提供HTTP和WebSocket服务.</span><br><span class="hljs-string">        :param middleware: 中间件列表， 应用于每个请求</span><br><span class="hljs-string">        :param exception_handler: 存放异常回调的字典， 键为HTTP状态码， 值为回调函数</span><br><span class="hljs-string">        :on_startup: 启动时调用的回调函数</span><br><span class="hljs-string">        :on_shutdown: 关闭时的回调函数</span><br><span class="hljs-string">        :lifespan: ASGI中的lifespan功能</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br><br>        <span class="hljs-comment"># 这里表示如果有传入lifespan， 则不可传入on_startup以及on_shutdown</span><br>        <span class="hljs-comment"># 因为本质上starlette的通过把on_start_up和on_shutdown转为一个lifespan来接收uvicorn调用的</span><br>        <span class="hljs-keyword">assert</span> lifespan <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">or</span> (<br>            on_startup <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> on_shutdown <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span><br>        ), <span class="hljs-string">&quot;Use either &#x27;lifespan&#x27; or &#x27;on_startup&#x27;/&#x27;on_shutdown&#x27;, not both.&quot;</span><br><br>        <span class="hljs-comment"># 初始化变量</span><br>        self._debug = debug<br>        self.state = State()<br>        self.router = Router(<br>            routes, on_startup=on_startup, on_shutdown=on_shutdown, lifespan=lifespan<br>        )<br>        self.exception_handlers = (<br>            &#123;&#125; <span class="hljs-keyword">if</span> exception_handlers <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">else</span> <span class="hljs-built_in">dict</span>(exception_handlers)<br>        )<br>        self.user_middleware = [] <span class="hljs-keyword">if</span> middleware <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">else</span> <span class="hljs-built_in">list</span>(middleware)<br>        <span class="hljs-comment"># 构建中间件</span><br>        self.middleware_stack = self.build_middleware_stack()<br></code></pre></td></tr></table></figure>
<p>通过代码可以看到初始化这里已经满足了大多数功能了, 不过还有一个构建中间件的函数, 需要进一步分析:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Starlette</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">build_middleware_stack</span>(<span class="hljs-params">self</span>) -&gt; ASGIApp:</span><br>        debug = self.debug<br>        error_handler = <span class="hljs-literal">None</span><br>        exception_handlers = &#123;&#125;<br><br>        <span class="hljs-comment"># 解析异常处理的回调， 分别存放在error_handler和exception_handlers</span><br>        <span class="hljs-comment"># 只有HTTP状态码为500的才会存入到error_handler</span><br>        <span class="hljs-keyword">for</span> key, value <span class="hljs-keyword">in</span> self.exception_handlers.items():<br>            <span class="hljs-keyword">if</span> key <span class="hljs-keyword">in</span> (<span class="hljs-number">500</span>, Exception):<br>                error_handler = value<br>            <span class="hljs-keyword">else</span>:<br>                exception_handlers[key] = value<br><br>        <span class="hljs-comment"># 为不同种类的中间件排好顺序</span><br>        <span class="hljs-comment"># 第一层为ServerErrorMiddleware, 它能在发现异常的时候打印错误堆栈， 或者在debug模式的时候展示错误页面， 方便调试</span><br>        <span class="hljs-comment"># 第二层是用户中间件层， 用户自己注册的所有中间件都会存放在这里</span><br>        <span class="hljs-comment"># 第三层是ExceptionMiddleware, 它是异常处理层, 它会处理路由执行时抛出的所有异常</span><br>        middleware = (<br>            [Middleware(ServerErrorMiddleware, handler=error_handler, debug=debug)]<br>            + self.user_middleware<br>            + [<br>                Middleware(<br>                    ExceptionMiddleware, handlers=exception_handlers, debug=debug<br>                )<br>            ]<br>        )<br><br>        <span class="hljs-comment"># 最后把中间件装填到app中</span><br>        app = self.router<br>        <span class="hljs-keyword">for</span> cls, options <span class="hljs-keyword">in</span> <span class="hljs-built_in">reversed</span>(middleware):<br>            <span class="hljs-comment"># cls是中间件类本身， options也就是我们传的参数</span><br>            <span class="hljs-comment"># 可以看出中间件本身也是一个ASGIAPP， 装填中间件就是一个ASGI APP套上另外一个ASGI APP， 一直套娃。</span><br>            app = cls(app=app, **options)<br>        <br>        <span class="hljs-comment"># 由于中间件的装填方式是不断的套娃， 而调用是不断的通过`call_next`调用装填它的上级ASGI APP， 所以要采用逆序的方法</span><br>        <span class="hljs-keyword">return</span> app<br></code></pre></td></tr></table></figure>
<p>构建完中间件后， 初始化就算完成了， 接着就会通过<code>uvicorn.run</code>方法从而调用到<code>__call__</code>方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Starlette</span>:</span><br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__call__</span>(<span class="hljs-params">self, scope: Scope, receive: Receive, send: Send</span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        scope[<span class="hljs-string">&quot;app&quot;</span>] = self<br>        <span class="hljs-keyword">await</span> self.middleware_stack(scope, receive, send)<br></code></pre></td></tr></table></figure>
<p>这个方法很简单， 就是通过scope， 把app设置到请求流程中， 方便后续调用， 然后通过调用<code>middleware_stack</code>开始请求的处理。 通过这个方法和中间件的初始化可以看出， <code>starlette</code>中的中间件本身也是一个ASGI APP（也可以看出route是一个ASGI APP， 处于调用栈的最后一层）， 同时<code>starlette</code>也把异常的处理也交给了中间件处理， 这在其他的Web应用框架很少见到， 可以看出<code>starlette</code>的设计是每个组件都尽量是ASGI APP。</p>
<blockquote>
<p>虽然<code>starlette</code>中间件的设计是非常不错的， 但是它的这种初始化方式我不太喜欢， 因为在编写的时候IDE无法帮你传入的参数做校验， 比如上面示例的<code>GZip</code>中间件, 你知道需要传<code>minimum_size</code>参数， 但是你有可能打错， 只是没到运行时的时候， 压根不知道它是否有异常:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python">app.add_middleware(GZipMiddleware, minimum_size = <span class="hljs-number">500</span>)<br></code></pre></td></tr></table></figure>
<p>我在设计我的rpc框架<a href="https://github.com/so1n/rap">rap</a>时也参考了<code>startlette</code>的中间件设计， 但是在这一块进行了优化， 不过与本篇文章关系不大， 有兴趣可以参考:<a href="https://github.com/so1n/rap/blob/master/rap/server/plugin/middleware/base.py">https://github.com/so1n/rap/blob/master/rap/server/plugin/middleware/base.py</a></p>
</blockquote>
<h2 id="2-中间件"><a href="#2-中间件" class="headerlink" title="2.中间件"></a>2.中间件</h2><p>上面说到， 在<code>startlette</code>中， 中间件是一个ASGI APP， 所以在<code>startlette</code>的所有中间件都必定是一个满足如下形式的类：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseMiddleware</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, app: ASGIApp</span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        <span class="hljs-keyword">pass</span><br><br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__call__</span>(<span class="hljs-params">self, scope: Scope, receive: Receive, send: Send</span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure>

<p>在<code>starlette.middleware</code>中， 有很多的中间件实现， 他们都满足这一点， 不过本章节不会讲所有的中间件， 只会挑选几个有代表性的中间件从最靠近<code>Route</code>到远进行分析。</p>
<h3 id="2-1-异常处理中间件-ExceptionMiddleware"><a href="#2-1-异常处理中间件-ExceptionMiddleware" class="headerlink" title="2.1.异常处理中间件-ExceptionMiddleware"></a>2.1.异常处理中间件-ExceptionMiddleware</h3><p>第一个就是ExceptionMiddleware中间件, 这个中间件用户是不会直接接触到的(所以没有放在<code>starlette.middleware</code>里面)， 而是通过下面的这个方法间接的接触到:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-meta">@app.app_exception_handlers(<span class="hljs-params"><span class="hljs-number">404</span></span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">not_found_route</span>() -&gt; <span class="hljs-keyword">None</span>:</span> <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure>
<p>当用户使用这个方法时， <code>startlette</code>会把回调函数挂在对应的字典里面， 这个字典以HTTP状态码为key, 回调函数为value。<br>当ExceptionMiddleware发现<code>Route</code>请求处理异常时， 可以通过异常的响应HTTP状态码找到对应的回调函数， 并把请求和异常传给用户挂载的对应的回调函数, 最后把用户的回调函数结果抛回上一个ASGI APP。<br>此外ExceptionMiddleware还支持异常注册， 当<code>Route</code>抛出的异常与注册的异常匹配时， 调用该异常注册的对应的回调函数。<br>该类的源码和注释如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExceptionMiddleware</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">        self, app: ASGIApp, handlers: <span class="hljs-built_in">dict</span> = <span class="hljs-literal">None</span>, debug: <span class="hljs-built_in">bool</span> = <span class="hljs-literal">False</span></span></span><br><span class="hljs-function"><span class="hljs-params">    </span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        self.app = app<br>        self.debug = debug  <span class="hljs-comment"># <span class="hljs-doctag">TODO:</span> We ought to handle 404 cases if debug is set.</span><br>        <span class="hljs-comment"># startletter是支持HTTP状态码和Exception两种类型</span><br>        self._status_handlers = &#123;&#125;  <span class="hljs-comment"># type: typing.Dict[int, typing.Callable]</span><br>        self._exception_handlers = &#123;<br>            HTTPException: self.http_exception<br>        &#125;  <span class="hljs-comment"># type: typing.Dict[typing.Type[Exception], typing.Callable]</span><br>        <span class="hljs-keyword">if</span> handlers <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">for</span> key, value <span class="hljs-keyword">in</span> handlers.items():<br>                self.add_exception_handler(key, value)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add_exception_handler</span>(<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">        self,</span></span><br><span class="hljs-function"><span class="hljs-params">        exc_class_or_status_code: typing.Union[<span class="hljs-built_in">int</span>, typing.Type[Exception]],</span></span><br><span class="hljs-function"><span class="hljs-params">        handler: typing.Callable,</span></span><br><span class="hljs-function"><span class="hljs-params">    </span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        <span class="hljs-comment"># 用户通过调用startlette app的方法挂载的异常回调最后都是通过该方法挂载到类里面的_status_handlers或者是_exception_handler里面</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(exc_class_or_status_code, <span class="hljs-built_in">int</span>):<br>            self._status_handlers[exc_class_or_status_code] = handler<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">assert</span> <span class="hljs-built_in">issubclass</span>(exc_class_or_status_code, Exception)<br>            self._exception_handlers[exc_class_or_status_code] = handler<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_lookup_exception_handler</span>(<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">        self, exc: Exception</span></span><br><span class="hljs-function"><span class="hljs-params">    </span>) -&gt; typing.Optional[typing.Callable]:</span><br>        <span class="hljs-comment"># 查找注册异常相关的回调函数, 通过mro发现异常的对应回调函数</span><br>        <span class="hljs-comment"># </span><br>        <span class="hljs-comment"># 用户挂载的可能是一个基类， 后续在遇到挂载异常的子类时， 也会调用基类注册的回调</span><br>        <span class="hljs-comment"># 比如用户注册了一个基类， 然后会有用户异常和系统异常两个异常都继承于这个基类</span><br>        <span class="hljs-comment"># 后续函数抛出用户异常或系统异常时， 都会执行到基类注册的对应回调</span><br>        <span class="hljs-keyword">for</span> cls <span class="hljs-keyword">in</span> <span class="hljs-built_in">type</span>(exc).__mro__:<br>            <span class="hljs-keyword">if</span> cls <span class="hljs-keyword">in</span> self._exception_handlers:<br>                <span class="hljs-keyword">return</span> self._exception_handlers[cls]<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br><br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__call__</span>(<span class="hljs-params">self, scope: Scope, receive: Receive, send: Send</span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        <span class="hljs-comment"># 熟悉的ASGI 调用方法</span><br>        <span class="hljs-keyword">if</span> scope[<span class="hljs-string">&quot;type&quot;</span>] != <span class="hljs-string">&quot;http&quot;</span>:<br>            <span class="hljs-comment"># 不支持websocket请求</span><br>            <span class="hljs-keyword">await</span> self.app(scope, receive, send)<br>            <span class="hljs-keyword">return</span><br><br>        <span class="hljs-comment"># 防止同一个响应产生多个异常</span><br>        response_started = <span class="hljs-literal">False</span><br><br>        <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sender</span>(<span class="hljs-params">message: Message</span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>            <span class="hljs-keyword">nonlocal</span> response_started<br><br>            <span class="hljs-keyword">if</span> message[<span class="hljs-string">&quot;type&quot;</span>] == <span class="hljs-string">&quot;http.response.start&quot;</span>:<br>                response_started = <span class="hljs-literal">True</span><br>            <span class="hljs-keyword">await</span> send(message)<br><br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-comment"># 调用下一个ASGI APP</span><br>            <span class="hljs-keyword">await</span> self.app(scope, receive, sender)<br>        <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> exc:<br>            handler = <span class="hljs-literal">None</span><br><br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(exc, HTTPException):<br>                <span class="hljs-comment"># 如果是HTTPException异常， 则从注册HTTP回调字典中寻找</span><br>                handler = self._status_handlers.get(exc.status_code)<br><br>            <span class="hljs-keyword">if</span> handler <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>                <span class="hljs-comment"># 如果是普通的异常， 则从异常回调字典去寻找</span><br>                handler = self._lookup_exception_handler(exc)<br><br>            <span class="hljs-keyword">if</span> handler <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>                <span class="hljs-comment"># 找不到对应的异常， 则往上面抛</span><br>                <span class="hljs-keyword">raise</span> exc <span class="hljs-keyword">from</span> <span class="hljs-literal">None</span><br><br>            <span class="hljs-comment"># 一个响应只接收一次异常处理</span><br>            <span class="hljs-keyword">if</span> response_started:<br>                msg = <span class="hljs-string">&quot;Caught handled exception, but response already started.&quot;</span><br>                <span class="hljs-keyword">raise</span> RuntimeError(msg) <span class="hljs-keyword">from</span> exc<br><br>            request = Request(scope, receive=receive)<br>            <span class="hljs-keyword">if</span> asyncio.iscoroutinefunction(handler):<br>                response = <span class="hljs-keyword">await</span> handler(request, exc)<br>            <span class="hljs-keyword">else</span>:<br>                response = <span class="hljs-keyword">await</span> run_in_threadpool(handler, request, exc)<br>            <span class="hljs-comment"># 通过回调函数生成的response处理请求</span><br>            <span class="hljs-keyword">await</span> response(scope, receive, sender)<br></code></pre></td></tr></table></figure>

<h3 id="2-2-用户中间件"><a href="#2-2-用户中间件" class="headerlink" title="2.2.用户中间件"></a>2.2.用户中间件</h3><p>接着就是用户中间件了， 这个也是我们接触最多的中间件， 在使用<code>starlette.middleware</code>时， 我们都会继承于一个叫<code>BaseHTTPMiddleware</code>的中间件， 然后基于如下代码进行拓展：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DemoMiddleware</span>(<span class="hljs-params">BaseHTTPMiddleware</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">        self,</span></span><br><span class="hljs-function"><span class="hljs-params">        app: ASGIApp,</span></span><br><span class="hljs-function"><span class="hljs-params">    </span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        <span class="hljs-built_in">super</span>(DemoMiddleware, self).__init__(app)<br><br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dispatch</span>(<span class="hljs-params">self, request: Request, call_next: RequestResponseEndpoint</span>) -&gt; Response:</span><br>        <span class="hljs-comment"># before</span><br>        response: Response = <span class="hljs-keyword">await</span> call_next(request)<br>        <span class="hljs-comment"># after</span><br>        <span class="hljs-keyword">return</span> response<br></code></pre></td></tr></table></figure>
<p>如果在请求之前进行预处理， 就在before块编写相关代码，如果要在请求之后进行处理的， 就在after块编写代码， 使用非常简单， 而且他们是处于同一个作用域的， 这就意味着该方法里面的变量不用通过上下文或者动态变量来传播（如果你接触了Django或者Flask的类中间件实现， 也就懂得了starlette这种实现的优雅）。</p>
<p>接下来就来看看它是怎么实现的， 代码非常简单， 大概60行左右, 不过我注释写了很多:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseHTTPMiddleware</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, app: ASGIApp, dispatch: DispatchFunction = <span class="hljs-literal">None</span></span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        <span class="hljs-comment"># 赋值下一级的ASGI app</span><br>        self.app = app<br>        <span class="hljs-comment"># 如果用户有传dispatch， 就使用用户传的函数， 否则使用自身的dispatch</span><br>        <span class="hljs-comment"># 一般用户都是继承于BaseHTTPMiddleware, 然后复写dispatch方法</span><br>        self.dispatch_func = self.dispatch <span class="hljs-keyword">if</span> dispatch <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">else</span> dispatch<br><br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__call__</span>(<span class="hljs-params">self, scope: Scope, receive: Receive, send: Send</span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        ASGI 标准的函数签名函数， 代表着ASGI的请求会从这里进来</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> scope[<span class="hljs-string">&quot;type&quot;</span>] != <span class="hljs-string">&quot;http&quot;</span>:<br>            <span class="hljs-comment"># 如果类型不是http的， 则不会走中间件(也就是websocket的不支持)</span><br>            <span class="hljs-comment"># 要支持websocket的话， 中间件就很难这样实现了， 我在实现rap框架时， 为了支持类websocket的流量中间件处理， 牺牲了一些功能才可以实现</span><br>            <span class="hljs-keyword">await</span> self.app(scope, receive, send)<br>            <span class="hljs-keyword">return</span><br><br>        <span class="hljs-comment"># 通过scope生成request对象</span><br>        request = Request(scope, receive=receive)<br>        <span class="hljs-comment"># 进入dispatch逻辑， 也就是用户的处理逻辑</span><br>        <span class="hljs-comment"># 这个逻辑得到的respone实际上是call_next函数生成的， dispatch函数只做了传递的作用</span><br>        response = <span class="hljs-keyword">await</span> self.dispatch_func(request, self.call_next)<br>        <span class="hljs-comment"># 根据生成的response, 返回数据到上一层</span><br>        <span class="hljs-keyword">await</span> response(scope, receive, send)<br><br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">call_next</span>(<span class="hljs-params">self, request: Request</span>) -&gt; Response:</span><br>        loop = asyncio.get_event_loop()<br>        <span class="hljs-comment"># 通过queue生产消费模式来获取下一级的消息</span><br>        queue: <span class="hljs-string">&quot;asyncio.Queue[typing.Optional[Message]]&quot;</span> = asyncio.Queue()<br><br>        scope = request.scope<br>        <span class="hljs-comment"># 通过request.receive对象把uvicorn的receive对象传过来</span><br>        <span class="hljs-comment"># 这里用到的receive对象还是uvicorn初始化时的receive对象</span><br>        receive = request.receive<br>        send = queue.put<br><br>        <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">coro</span>() -&gt; <span class="hljs-keyword">None</span>:</span><br>            <span class="hljs-keyword">try</span>:<br>                <span class="hljs-keyword">await</span> self.app(scope, receive, send)<br>            <span class="hljs-keyword">finally</span>:<br>                <span class="hljs-comment"># 这个put操作能确保get那边不会被卡死</span><br>                <span class="hljs-keyword">await</span> queue.put(<span class="hljs-literal">None</span>)<br><br>        <span class="hljs-comment"># 通过loop.create_task， 在另一个协程跑下一个ASGI APP</span><br>        task = loop.create_task(coro())<br>        <span class="hljs-comment"># 等待下一个ASGI APP的返回</span><br>        message = <span class="hljs-keyword">await</span> queue.get()<br>        <span class="hljs-keyword">if</span> message <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-comment"># 如果拿到是空的， 则代表下一个ASGI APP没有返回响应， 这时可能出错， </span><br>            <span class="hljs-comment"># 通过调用task.result()， 如果该协程出现异常, 则会把该协程的错误抛出来</span><br>            task.result()<br>            <span class="hljs-comment"># 如果没有异常抛出来， 就可能是用户写错等原因， 返回了一个空响应, </span><br>            <span class="hljs-comment"># 这时候是没办法返回响应给客户端的， 需要自己制造一个异常， 方便后续生成一个500的响应</span><br>            <span class="hljs-keyword">raise</span> RuntimeError(<span class="hljs-string">&quot;No response returned.&quot;</span>)<br>        <br>        <span class="hljs-comment"># ASGI处理响应的时候会分多步走， 正常情况下， 上面的queue.get， 是获取响应的第一步</span><br>        <span class="hljs-keyword">assert</span> message[<span class="hljs-string">&quot;type&quot;</span>] == <span class="hljs-string">&quot;http.response.start&quot;</span><br><br>        <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">body_stream</span>() -&gt; typing.AsyncGenerator[bytes, <span class="hljs-keyword">None</span>]:</span><br>            <span class="hljs-comment"># 其他的处理会交给body_stream函数处理</span><br>            <span class="hljs-comment"># 这个方法所做的就是一直返回数据流</span><br>            <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>                message = <span class="hljs-keyword">await</span> queue.get()<br>                <span class="hljs-keyword">if</span> message <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>                    <span class="hljs-keyword">break</span><br>                <span class="hljs-keyword">assert</span> message[<span class="hljs-string">&quot;type&quot;</span>] == <span class="hljs-string">&quot;http.response.body&quot;</span><br>                <span class="hljs-keyword">yield</span> message.get(<span class="hljs-string">&quot;body&quot;</span>, <span class="hljs-string">b&quot;&quot;</span>)<br>            task.result()<br><br>        <span class="hljs-comment"># 将body_stream函数放到Response方法中</span><br>        <span class="hljs-comment"># response本身也是一个类ASGI APP的类， 用户根据教程， 在dispatch方法中通过call_next获得response对象， </span><br>        <span class="hljs-comment"># 并在最后返回， 所以这个reponse对象将会交给__call__方法中进行处理。</span><br>        response = StreamingResponse(<br>            status_code=message[<span class="hljs-string">&quot;status&quot;</span>], content=body_stream()<br>        )<br>        response.raw_headers = message[<span class="hljs-string">&quot;headers&quot;</span>]<br>        <span class="hljs-keyword">return</span> response<br><br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dispatch</span>(<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">        self, request: Request, call_next: RequestResponseEndpoint</span></span><br><span class="hljs-function"><span class="hljs-params">    </span>) -&gt; Response:</span><br>        <span class="hljs-keyword">raise</span> NotImplementedError()  <span class="hljs-comment"># pragma: no cover</span><br></code></pre></td></tr></table></figure>
<h3 id="2-3-ServerErrorMiddleware"><a href="#2-3-ServerErrorMiddleware" class="headerlink" title="2.3.ServerErrorMiddleware"></a>2.3.ServerErrorMiddleware</h3><p>ServerErrorMiddleware跟ExceptionMiddleware很像(所以这一part也不做更多的说明), 整个逻辑基本上都是一致的， 不过ExceptionMiddleware负责的是把用户的路由异常进行捕获处理， ServerErrorMiddleware主要负责是做兜底， 确保返回的一定是合法的HTTP响应。</p>
<p>ServerErrorMiddleware的间接调用函数也跟ExceptionMiddleware一样, 不过只有注册的HTTP状态码为500时， 才会把回调注册到ServerErrorMiddleware中：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-meta">@app.exception_handlers(<span class="hljs-params"><span class="hljs-number">500</span></span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">not_found_route</span>() -&gt; <span class="hljs-keyword">None</span>:</span> <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure>
<p>ServerErrorMiddleware是处于ASGI APP中的最顶级， 它负责异常兜底的工作， 它要做的事情很简单， 如果下一级ASGI APP处理发生异常， 就进入兜底逻辑：</p>
<ul>
<li>1.如果启用debug, 则返回debug页面</li>
<li>2.如果有注册回调， 则执行注册回调</li>
<li>3.如果都没则返回500响应</li>
</ul>
<h2 id="3-Route"><a href="#3-Route" class="headerlink" title="3.Route"></a>3.Route</h2><p>在<code>starlette</code>中， <code>Route</code>分为两部分， 一部分我把它称为<code>Real App</code>的<code>Router</code>， 它处于中间件的下一层级， 但它负责的是<code>Starlette</code>除中间件外的所有事情， 主要包括路由查找匹配， APP启动关闭处理等， 另外一部分则是注册到<code>Router</code>的路由。</p>
<h3 id="3-1-Router"><a href="#3-1-Router" class="headerlink" title="3.1.Router"></a>3.1.Router</h3><p><code>Router</code>很简单， 他的主要责任就是装载路由和匹配路由， 以下是除装载路由外的源码和注释：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Router</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">        self,</span></span><br><span class="hljs-function"><span class="hljs-params">        routes: typing.Sequence[BaseRoute] = <span class="hljs-literal">None</span>,</span></span><br><span class="hljs-function"><span class="hljs-params">        redirect_slashes: <span class="hljs-built_in">bool</span> = <span class="hljs-literal">True</span>,</span></span><br><span class="hljs-function"><span class="hljs-params">        default: ASGIApp = <span class="hljs-literal">None</span>,</span></span><br><span class="hljs-function"><span class="hljs-params">        on_startup: typing.Sequence[typing.Callable] = <span class="hljs-literal">None</span>,</span></span><br><span class="hljs-function"><span class="hljs-params">        on_shutdown: typing.Sequence[typing.Callable] = <span class="hljs-literal">None</span>,</span></span><br><span class="hljs-function"><span class="hljs-params">        lifespan: typing.Callable[[typing.Any], typing.AsyncGenerator] = <span class="hljs-literal">None</span>,</span></span><br><span class="hljs-function"><span class="hljs-params">    </span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        <span class="hljs-comment"># 装填starlette初始化时的信息</span><br>        self.routes = [] <span class="hljs-keyword">if</span> routes <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">else</span> <span class="hljs-built_in">list</span>(routes)<br>        self.redirect_slashes = redirect_slashes<br>        self.default = self.not_found <span class="hljs-keyword">if</span> default <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">else</span> default<br>        self.on_startup = [] <span class="hljs-keyword">if</span> on_startup <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">else</span> <span class="hljs-built_in">list</span>(on_startup)<br>        self.on_shutdown = [] <span class="hljs-keyword">if</span> on_shutdown <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">else</span> <span class="hljs-built_in">list</span>(on_shutdown)<br><br>        <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">default_lifespan</span>(<span class="hljs-params">app: typing.Any</span>) -&gt; typing.AsyncGenerator:</span><br>            <span class="hljs-keyword">await</span> self.startup()<br>            <span class="hljs-keyword">yield</span><br>            <span class="hljs-keyword">await</span> self.shutdown()<br><br>        <span class="hljs-comment"># 如果初始化lifespan为空， 则把on_startup和on_shuatdown转化为lifespan</span><br>        self.lifespan_context = default_lifespan <span class="hljs-keyword">if</span> lifespan <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">else</span> lifespan<br><br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">not_found</span>(<span class="hljs-params">self, scope: Scope, receive: Receive, send: Send</span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        <span class="hljs-string">&quot;&quot;&quot;匹配不到路由执行的逻辑&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> scope[<span class="hljs-string">&quot;type&quot;</span>] == <span class="hljs-string">&quot;websocket&quot;</span>:<br>            <span class="hljs-comment"># websocket匹配失败</span><br>            websocket_close = WebSocketClose()<br>            <span class="hljs-keyword">await</span> websocket_close(scope, receive, send)<br>            <span class="hljs-keyword">return</span><br><br>        <span class="hljs-comment"># If we&#x27;re running inside a starlette application then raise an</span><br>        <span class="hljs-comment"># exception, so that the configurable exception handler can deal with</span><br>        <span class="hljs-comment"># returning the response. For plain ASGI apps, just return the response.</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;app&quot;</span> <span class="hljs-keyword">in</span> scope:<br>            <span class="hljs-comment"># 在starlette.applications的__call__方法可以看到starlette把自身存入scope中</span><br>            <span class="hljs-comment"># 这里抛出异常后， 可以被ServerErrorMiddleware捕获</span><br>            <span class="hljs-keyword">raise</span> HTTPException(status_code=<span class="hljs-number">404</span>)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-comment"># 对于不是starlette调用的， 直接返回错误</span><br>            response = PlainTextResponse(<span class="hljs-string">&quot;Not Found&quot;</span>, status_code=<span class="hljs-number">404</span>)<br>        <span class="hljs-keyword">await</span> response(scope, receive, send)<br><br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">lifespan</span>(<span class="hljs-params">self, scope: Scope, receive: Receive, send: Send</span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        Handle ASGI lifespan messages, which allows us to manage application</span><br><span class="hljs-string">        startup and shutdown events.</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-comment"># lifespan执行的逻辑， 在执行的时候starlette会与ASGI服务器进行通信， 但目前这样的代码估计还有一些待开发的功能</span><br>        first = <span class="hljs-literal">True</span><br>        app = scope.get(<span class="hljs-string">&quot;app&quot;</span>)<br>        <span class="hljs-keyword">await</span> receive()<br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-keyword">if</span> inspect.isasyncgenfunction(self.lifespan_context):<br>                <span class="hljs-keyword">async</span> <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> self.lifespan_context(app):<br>                    <span class="hljs-keyword">assert</span> first, <span class="hljs-string">&quot;Lifespan context yielded multiple times.&quot;</span><br>                    first = <span class="hljs-literal">False</span><br>                    <span class="hljs-keyword">await</span> send(&#123;<span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;lifespan.startup.complete&quot;</span>&#125;)<br>                    <span class="hljs-keyword">await</span> receive()<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> self.lifespan_context(app):  <span class="hljs-comment"># type: ignore</span><br>                    <span class="hljs-keyword">assert</span> first, <span class="hljs-string">&quot;Lifespan context yielded multiple times.&quot;</span><br>                    first = <span class="hljs-literal">False</span><br>                    <span class="hljs-keyword">await</span> send(&#123;<span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;lifespan.startup.complete&quot;</span>&#125;)<br>                    <span class="hljs-keyword">await</span> receive()<br>        <span class="hljs-keyword">except</span> BaseException:<br>            <span class="hljs-keyword">if</span> first:<br>                exc_text = traceback.format_exc()<br>                <span class="hljs-keyword">await</span> send(&#123;<span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;lifespan.startup.failed&quot;</span>, <span class="hljs-string">&quot;message&quot;</span>: exc_text&#125;)<br>            <span class="hljs-keyword">raise</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">await</span> send(&#123;<span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;lifespan.shutdown.complete&quot;</span>&#125;)<br><br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__call__</span>(<span class="hljs-params">self, scope: Scope, receive: Receive, send: Send</span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        The main entry point to the Router class.</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-comment"># 匹配以及执行路由的主要函数</span><br>        <span class="hljs-comment"># 目前只支持http, websocket, lifespan三种类型</span><br>        <span class="hljs-keyword">assert</span> scope[<span class="hljs-string">&quot;type&quot;</span>] <span class="hljs-keyword">in</span> (<span class="hljs-string">&quot;http&quot;</span>, <span class="hljs-string">&quot;websocket&quot;</span>, <span class="hljs-string">&quot;lifespan&quot;</span>)<br><br>        <span class="hljs-comment"># 初始化router到scope中</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;router&quot;</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> scope:<br>            scope[<span class="hljs-string">&quot;router&quot;</span>] = self<br><br>        <span class="hljs-keyword">if</span> scope[<span class="hljs-string">&quot;type&quot;</span>] == <span class="hljs-string">&quot;lifespan&quot;</span>:<br>            <span class="hljs-comment"># 执行lifespan逻辑</span><br>            <span class="hljs-keyword">await</span> self.lifespan(scope, receive, send)<br>            <span class="hljs-keyword">return</span><br><br>        partial = <span class="hljs-literal">None</span><br><br>        <span class="hljs-comment"># 进行路由匹配</span><br>        <span class="hljs-keyword">for</span> route <span class="hljs-keyword">in</span> self.routes:<br>            match, child_scope = route.matches(scope)<br>            <span class="hljs-keyword">if</span> match == Match.FULL:<br>                <span class="hljs-comment"># 如果是完整匹配（url匹配， method匹配）</span><br>                <span class="hljs-comment"># 则进行路由正常处理</span><br>                scope.update(child_scope)<br>                <span class="hljs-keyword">await</span> route.handle(scope, receive, send)<br>                <span class="hljs-keyword">return</span><br>            <span class="hljs-keyword">elif</span> match == Match.PARTIAL <span class="hljs-keyword">and</span> partial <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>                <span class="hljs-comment"># 如果是不完整匹配（url匹配， method不匹配）</span><br>                <span class="hljs-comment"># 则保留值， 继续匹配</span><br>                partial = route<br>                partial_scope = child_scope<br><br>        <span class="hljs-keyword">if</span> partial <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-comment"># 如果存在不完整匹配的路由, 也继续执行， 但这时路由会响应HTTP 方法不对的错误</span><br>            scope.update(partial_scope)<br>            <span class="hljs-keyword">await</span> partial.handle(scope, receive, send)<br>            <span class="hljs-keyword">return</span><br><br>        <span class="hljs-keyword">if</span> scope[<span class="hljs-string">&quot;type&quot;</span>] == <span class="hljs-string">&quot;http&quot;</span> <span class="hljs-keyword">and</span> self.redirect_slashes <span class="hljs-keyword">and</span> scope[<span class="hljs-string">&quot;path&quot;</span>] != <span class="hljs-string">&quot;/&quot;</span>:<br>            <span class="hljs-comment"># 未匹配的情况, 判断重定向</span><br>            redirect_scope = <span class="hljs-built_in">dict</span>(scope)<br>            <span class="hljs-keyword">if</span> scope[<span class="hljs-string">&quot;path&quot;</span>].endswith(<span class="hljs-string">&quot;/&quot;</span>):<br>                redirect_scope[<span class="hljs-string">&quot;path&quot;</span>] = redirect_scope[<span class="hljs-string">&quot;path&quot;</span>].rstrip(<span class="hljs-string">&quot;/&quot;</span>)<br>            <span class="hljs-keyword">else</span>:<br>                redirect_scope[<span class="hljs-string">&quot;path&quot;</span>] = redirect_scope[<span class="hljs-string">&quot;path&quot;</span>] + <span class="hljs-string">&quot;/&quot;</span><br><br>            <span class="hljs-keyword">for</span> route <span class="hljs-keyword">in</span> self.routes:<br>                match, child_scope = route.matches(redirect_scope)<br>                <span class="hljs-keyword">if</span> match != Match.NONE:<br>                    <span class="hljs-comment"># 再次进行匹配, 如果结果不为空, 则发送重定向response</span><br>                    redirect_url = URL(scope=redirect_scope)<br>                    response = RedirectResponse(url=<span class="hljs-built_in">str</span>(redirect_url))<br>                    <span class="hljs-keyword">await</span> response(scope, receive, send)<br>                    <span class="hljs-keyword">return</span><br><br>        <span class="hljs-comment"># 上面流程都没命中时， 则代表没有找到任务路由， 这时候会执行默认路由， 默认的默认路由是404 not found</span><br>        <span class="hljs-keyword">await</span> self.default(scope, receive, send)<br></code></pre></td></tr></table></figure>
<p>可以看出<code>Router</code>的代码非常的简单， 主要的代码都集中在<code>__call__</code>中， 但是在这里出现了多次遍历查询路由且每个路由都是执行一遍正则表达式来判断是否匹配。可能会有人觉得这样的执行速度会很慢,<br>我曾经也觉得这样的路由查找很慢， 然后就实现了一个路由树来代替它详见<a href="https://github.com/so1n/fast-tools/blob/master/fast_tools/base/route_trie.py">route_trie.py</a>, 然而在我实现后做了一次性能测试， 发现在路由没超过50个的情况下， 循环匹配性能是优于路由树的， 在没超过100条的情况下， 两者是相当的， 而在正常情况下， 我们指定的路由都不会超过100个， 所以不用去担心这部分路由的匹配性能， 如果还是很担心， 那么可以使用<code>Mount</code>来对路由进行分组， 使匹配的次数减少。</p>
<h3 id="3-2-其他Route"><a href="#3-2-其他Route" class="headerlink" title="3.2.其他Route"></a>3.2.其他Route</h3><p><code>Moute</code>是继承于<code>BaseRoute</code>, 其它的<code>Route</code>, <code>HostRoute</code>, <code>WebsocketRoute</code>也是一样继承于<code>BaseRoute</code>, 它们提供的方法都差不多， 只是具体实现略有差别而已(主要是初始化，路由匹配和反向查找略有区别)， 我们先来看看<code>BaseRoute</code>:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseRoute</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">matches</span>(<span class="hljs-params">self, scope: Scope</span>) -&gt; typing.Tuple[Match, Scope]:</span><br>        <span class="hljs-comment"># 一个标准的匹配函数签名， 每个Route都要返回一个(Match, Scope)的元祖</span><br>        <span class="hljs-comment"># Match有3种， 分别是</span><br>        <span class="hljs-comment">#   NONE： 没有匹配到</span><br>        <span class="hljs-comment">#   PARTIAL： 部分匹配（url匹配了， method匹配失败）</span><br>        <span class="hljs-comment">#   FULL： 完全匹配（url和method都匹配成功）</span><br>        <span class="hljs-comment"># Scope基本上都会返回如下格式, 不过Mount返回的内容更多：</span><br>        <span class="hljs-comment">#   &#123;&quot;endpoint&quot;: self.endpoint, &quot;path_params&quot;: path_params&#125;</span><br>        <span class="hljs-keyword">raise</span> NotImplementedError()  <span class="hljs-comment"># pragma: no cover</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">url_path_for</span>(<span class="hljs-params">self, name: <span class="hljs-built_in">str</span>, **path_params: <span class="hljs-built_in">str</span></span>) -&gt; URLPath:</span><br>        <span class="hljs-comment"># 根据名字生成反向查找</span><br>        <span class="hljs-keyword">raise</span> NotImplementedError()  <span class="hljs-comment"># pragma: no cover</span><br><br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">handle</span>(<span class="hljs-params">self, scope: Scope, receive: Receive, send: Send</span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        <span class="hljs-comment"># 被Router匹配后可以调用的函数</span><br>        <span class="hljs-keyword">raise</span> NotImplementedError()  <span class="hljs-comment"># pragma: no cover</span><br><br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__call__</span>(<span class="hljs-params">self, scope: Scope, receive: Receive, send: Send</span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        A route may be used in isolation as a stand-alone ASGI app.</span><br><span class="hljs-string">        This is a somewhat contrived case, as they&#x27;ll almost always be used</span><br><span class="hljs-string">        within a Router, but could be useful for some tooling and minimal apps.</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-comment"># 如果该路由被当做ASGI APP单独调用， 则自己进行匹配并响应结果</span><br>        match, child_scope = self.matches(scope)<br>        <span class="hljs-keyword">if</span> match == Match.NONE:<br>            <span class="hljs-keyword">if</span> scope[<span class="hljs-string">&quot;type&quot;</span>] == <span class="hljs-string">&quot;http&quot;</span>:<br>                response = PlainTextResponse(<span class="hljs-string">&quot;Not Found&quot;</span>, status_code=<span class="hljs-number">404</span>)<br>                <span class="hljs-keyword">await</span> response(scope, receive, send)<br>            <span class="hljs-keyword">elif</span> scope[<span class="hljs-string">&quot;type&quot;</span>] == <span class="hljs-string">&quot;websocket&quot;</span>:<br>                websocket_close = WebSocketClose()<br>                <span class="hljs-keyword">await</span> websocket_close(scope, receive, send)<br>            <span class="hljs-keyword">return</span><br><br>        scope.update(child_scope)<br>        <span class="hljs-keyword">await</span> self.handle(scope, receive, send)<br></code></pre></td></tr></table></figure>
<p>可以看到<code>BaseRoute</code>提供的功能不多， 其他的路由则是基于<code>BaseRoute</code>进行拓展：</p>
<ul>
<li>Route: 标准的HTTP路由， 负责通过HTTP URL和HTTP Method进行路由匹配， 然后提供调用HTTP路由的方法</li>
<li>WebSocketRoute: 标准的WebSocketRoute， 根据HTTP URL进行路由匹配, 然后通过<code>starlette.websocket</code>的WebSocket生成session再传入对应的函数</li>
<li>Mount: 一个路由的套娃封装， 他的匹配方法是URL的前缀匹配, 把请求转发给符合规则的下一级ASGI  APP， 当他的下一级ASGI APP是<code>Router</code>时, 他的调用链可能会像这样<code>Router-&gt;Mount-&gt;Router-&gt;Mount-&gt;Router-&gt;Route</code>， 通过使用Mount可以对路由进行分组， 同时也能加快匹配速度， 推荐使用。 不过， 它还支持把请求分发给其他ASGI APP， 也可以做到如<code>Starlette-&gt;ASGI Middleware-&gt;Mount-&gt;Other Starlette-&gt;...</code></li>
<li>Host: 它会根据用户请求的Host分发到对应的ASGI APP， 可以选择<code>Route</code>, <code>Mount</code>， 中间件等等ASGI APP</li>
</ul>
<h2 id="4-其它组件"><a href="#4-其它组件" class="headerlink" title="4.其它组件"></a>4.其它组件</h2><p>从上面可以看到， <code>starlette</code>中的组件基本上都设计成ASGI APP， 可以任意的兼容， 这种设计是非常棒的， 虽然会牺牲一点点性能， 但是它的兼容性非常的强, 而其他的组件也都或多或少的设计得像ASGI APP一样， 在介绍其他组件之前， 先看看整个<code>starlette</code>的整个项目结构:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python">├── middleware                       <span class="hljs-comment"># 中间件</span><br>├── applications.py                  <span class="hljs-comment"># 启动的应用程序</span><br>├── authentication.py                <span class="hljs-comment"># 验证相关</span><br>├── background.py                    <span class="hljs-comment"># 封装后台任务， 会在返回响应后执行</span><br>├── concurrency.py                   <span class="hljs-comment"># 一些小的asyncio相关的封装， 在新版本中， 直接使用了anyio库来代替</span><br>├── config.py                        <span class="hljs-comment"># 配置</span><br>├── convertors.py                    <span class="hljs-comment"># 一些类型的转换方法</span><br>├── datastructures.py                <span class="hljs-comment"># 一些数据结构， 比如Url, Header, Form, QueryParam, State等等</span><br>├── endpoints.py                     <span class="hljs-comment"># 支持cbv的路由以及一个稍微高级点的Websocket封装</span><br>├── exceptions.py                    <span class="hljs-comment"># 异常处理</span><br>├── formparsers.py                   <span class="hljs-comment"># Form，File之类的解析</span><br>├── graphql.py                       <span class="hljs-comment"># 负责处理graphql相关的</span><br>├── __init__.py<br>├── py.typed                         <span class="hljs-comment"># starlette需要用到的TypeHints</span><br>├── requests.py                      <span class="hljs-comment"># 请求, 供用户获取数据</span><br>├── responses.py                     <span class="hljs-comment"># 响应, 负责初始化Header和Cookies， 同时根据不同的Respnose类生成响应数据， 然后有个类ASGI调用接口， 该接口会发送ASGI协议到uvicorn服务， 发送完后如果有backgroud task, 则执行backgroud task， 直到执行完成， 该响应流程才结束。</span><br>├── routing.py                       <span class="hljs-comment"># 路由</span><br>├── schemas.py                       <span class="hljs-comment"># OpenApi相关的Schemas</span><br>├── staticfiles.py                   <span class="hljs-comment"># 静态文件</span><br>├── status.py                        <span class="hljs-comment"># HTTP状态码</span><br>├── templating.py                    <span class="hljs-comment"># 基于jinja的模板响应</span><br>├── testclient.py                    <span class="hljs-comment"># 测试客户端</span><br>├── types.py                         <span class="hljs-comment"># 类型</span><br>└── websockets.py                    <span class="hljs-comment"># websocket</span><br></code></pre></td></tr></table></figure>
<p>上面的文件有很多， 有些比较简单就直接略过。</p>
<h3 id="4-1-Request"><a href="#4-1-Request" class="headerlink" title="4.1.Request"></a>4.1.Request</h3><p><code>Request</code>非常的简单， 它继承于<code>HttpConnection</code>, 这个类主要是通过ASGI协议传过来的Scope进行解析， 提取如url, method等信息， 而<code>Request</code>增加了读取请求数据和返回数据(HTTP1.1支持服务端push数据给客户端)的功能， 其中， 读取数据都依赖于一个核心函数–<code>stram</code>，它的源码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">stream</span>(<span class="hljs-params">self</span>) -&gt; typing.AsyncGenerator[bytes, <span class="hljs-keyword">None</span>]:</span><br>    <span class="hljs-comment"># 如果已经读取过的， 则从缓存中获取数据</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">hasattr</span>(self, <span class="hljs-string">&quot;_body&quot;</span>):<br>        <span class="hljs-keyword">yield</span> self._body<br>        <span class="hljs-keyword">yield</span> <span class="hljs-string">b&quot;&quot;</span><br>        <span class="hljs-keyword">return</span><br><br>    <span class="hljs-keyword">if</span> self._stream_consumed:<br>        <span class="hljs-keyword">raise</span> RuntimeError(<span class="hljs-string">&quot;Stream consumed&quot;</span>)<br><br>    self._stream_consumed = <span class="hljs-literal">True</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        <span class="hljs-comment"># 从ASGI容器的receive循环获取数据</span><br>        message = <span class="hljs-keyword">await</span> self._receive()<br>        <span class="hljs-keyword">if</span> message[<span class="hljs-string">&quot;type&quot;</span>] == <span class="hljs-string">&quot;http.request&quot;</span>:<br>            body = message.get(<span class="hljs-string">&quot;body&quot;</span>, <span class="hljs-string">b&quot;&quot;</span>)<br>            <span class="hljs-keyword">if</span> body:<br>                <span class="hljs-comment"># 获取的数据不为空就返回数据</span><br>                <span class="hljs-keyword">yield</span> body<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> message.get(<span class="hljs-string">&quot;more_body&quot;</span>, <span class="hljs-literal">False</span>):<br>                <span class="hljs-comment"># 代表body数据已经被获取完</span><br>                <span class="hljs-keyword">break</span><br>        <span class="hljs-keyword">elif</span> message[<span class="hljs-string">&quot;type&quot;</span>] == <span class="hljs-string">&quot;http.disconnect&quot;</span>:<br>            <span class="hljs-comment"># 代表与客户端的连接已经关闭了</span><br>            self._is_disconnected = <span class="hljs-literal">True</span><br>            <span class="hljs-comment"># 抛出异常， 用户调用await request.body()   await request.json()之类的会抛出异常</span><br>            <span class="hljs-keyword">raise</span> ClientDisconnect()<br>    <span class="hljs-comment"># 返回空字节，标记结束</span><br>    <span class="hljs-keyword">yield</span> <span class="hljs-string">b&quot;&quot;</span><br></code></pre></td></tr></table></figure>
<p>这个实现非常简单， 但是却有一个小bug, 如果有了解<code>Nginx</code>或者其他Web服务的都会知道， 一般的中间服务器是不会处理body数据的, 只做传递。ASGI也是如此, <code>uvicorn</code>在处理完url和header后就开始调用ASGI APP， 并把<code>send</code>和<code>receive</code>对象传递下去, 这两个对象会在经过多个ASGI APP后，抵达路由这个ASGI APP， 并在函数里供用户使用，， 所以Request接收的<code>receive</code>对象是<code>uvicorn</code>生成的。 而<code>receive</code>的数据源是源自于是一个<code>asyncio.Queue</code>队列， 从中间件的分析可以知道， 每个ASGI APP都依据<code>scope</code>, <code>receive</code>来生成一个<code>Request</code>对象, 意味着每层ASGI APP的<code>Request</code>对象是不一致的, 如果在中间件调用<code>Request</code>对象读取Body的话， 就会提前消费通过<code>receive</code>消费了队列的数据， 导致后续的ASGI APP无法通过<code>Request</code>对象读取Body数据， 该问题示例代码如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> asyncio<br><span class="hljs-keyword">from</span> starlette.applications <span class="hljs-keyword">import</span> Starlette<br><span class="hljs-keyword">from</span> starlette.middleware.base <span class="hljs-keyword">import</span> BaseHTTPMiddleware, RequestResponseEndpoint<br><span class="hljs-keyword">from</span> starlette.requests <span class="hljs-keyword">import</span> Request<br><span class="hljs-keyword">from</span> starlette.responses <span class="hljs-keyword">import</span> JSONResponse, Response<br><br>app: Starlette = Starlette()<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DemoMiddleware</span>(<span class="hljs-params">BaseHTTPMiddleware</span>):</span><br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dispatch</span>(<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">        self, request: Request, call_next: RequestResponseEndpoint</span></span><br><span class="hljs-function"><span class="hljs-params">    </span>) -&gt; Response:</span><br>        print(request, <span class="hljs-keyword">await</span> request.body())<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> call_next(request)<br><br><br>app.add_middleware(DemoMiddleware)<br><br><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&quot;/&quot;</span></span>)</span><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">demo</span>(<span class="hljs-params">request: Request</span>) -&gt; JSONResponse:</span><br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-keyword">await</span> asyncio.wait_for(request.body(), <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> JSONResponse(&#123;<span class="hljs-string">&quot;result&quot;</span>: <span class="hljs-literal">True</span>&#125;)<br>    <span class="hljs-keyword">except</span> asyncio.TimeoutError:<br>        <span class="hljs-keyword">return</span> JSONResponse(&#123;<span class="hljs-string">&quot;result&quot;</span>: <span class="hljs-literal">False</span>&#125;)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    <span class="hljs-keyword">import</span> uvicorn  <span class="hljs-comment"># type: ignore</span><br><br>    uvicorn.run(app)<br></code></pre></td></tr></table></figure>
<p>运行后执行请求查看结果:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs Bash">-&gt; curl http://127.0.0.1:8000<br>&#123;<span class="hljs-string">&quot;result&quot;</span>:<span class="hljs-literal">false</span>&#125; <br></code></pre></td></tr></table></figure>
<p>可以看到执行的结果是<code>false</code>, 意味着执行<code>request.body</code>超时了， 因为此时<code>receive</code>队列已经空了， 是拿不到数据的， 如果不加超时的话这个请求就会一直卡主。<br>那么要怎么去解决问题呢， 先看看<code>Request</code>获取是如何获取body的， 因为用户可以同时获取多次body, 但一直都是相同的数据， 它的实现思路是获取数据后， 把数据缓存到一个变量里面， 我们也可以采取这个思路, 由于数据都是通过<code>receive</code>获取的， 那么可以在在读取数据后， 构造一个<code>receive</code>函数， 该函数返回类似于ASGI的通信协议的数据， 并且有完整的body数据(满足Request.stream获取body的构造)， 代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">proxy_get_body</span>(<span class="hljs-params">request: Request</span>) -&gt; bytes:</span><br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">receive</span>() -&gt; Message:</span><br>        <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;http.request&quot;</span>, <span class="hljs-string">&quot;body&quot;</span>: body&#125;<br><br>    body = <span class="hljs-keyword">await</span> request.body()<br>    request._receive = receive<br>    <span class="hljs-keyword">return</span> body<br></code></pre></td></tr></table></figure>
<p>之后任意层级的ASGI APP如果需要获取Body数据的话， 就可以调用该函数来获取Body数据， 同时又不影响后续的ASGI APP获取Body数据。</p>
<h3 id="4-2-TestClient"><a href="#4-2-TestClient" class="headerlink" title="4.2.TestClient"></a>4.2.TestClient</h3><p>在基于<code>TestCLient</code>的测试用例运行时， 没有流量转发， 而是通过请求调用到路由函数， 并根据返回数据转化为一个响应对象。<br>同时， 它还能会自动运行<code>on_startup</code>和<code>on_shutdown</code>挂载的函数以及挂载的中间件, 我在一开始接触时， 我很好奇它是怎么实现的， 因为大多数的测试用例框架都很难做到直接调用到路由函数， 同时又满足于框架的其他中间件, <code>on_startup</code>和<code>on_shutdown</code>的功能(特别是Python的gRPC自带的测试用例封装…)。</p>
<p>在了解<code>TestClient</code>的运行原理之前， 先看看<code>TestClient</code>的使用用例如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">from</span> starlette.testclient <span class="hljs-keyword">import</span> TestClient<br><span class="hljs-keyword">from</span> requests <span class="hljs-keyword">import</span> Response  <span class="hljs-comment"># type: ignore</span><br><br><br>app: Starlette = Starlette()<br><span class="hljs-keyword">with</span> TestClient(app) <span class="hljs-keyword">as</span> client:<br>    response: Response = client.get(<span class="hljs-string">&quot;/&quot;</span>)<br></code></pre></td></tr></table></figure>
<p>这段代码中， 分为几步走: </p>
<ul>
<li>1:初始化一个app对象</li>
<li>2:把app对象传入<code>TestClient</code>中, 并通过<code>with</code>语法启动一个上下文</li>
<li>3:通过返回的client进行调用， 最后返回一个<code>requests.Response</code>对象。</li>
</ul>
<p>其中第一点非常简单， 我们也分析过了， 对于第二点， 很难明白为什么要<code>with</code>上下文， 在官方文档说明是可以这样直接运行:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python">response: Response = TestClient(app).get(<span class="hljs-string">&quot;/&quot;</span>)<br></code></pre></td></tr></table></figure>
<p>但是没办法执行<code>on_startup</code>和<code>on_shutdown</code>这两个事件挂载的函数， 所以初步判定<code>with</code>语法与它们有关， 而至于第三步则很难猜透<code>starlette</code>是怎么实现的， 但是返回的是<code>requests.Respnose</code>的对象， 那么一定跟<code>requests</code>这个框架有一些关联， 具体需要分析源码才能知道。</p>
<p>接下来就开始带着问题分析源码, 首先是类和<code>__init__</code>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestClient</span>(<span class="hljs-params">requests.Session</span>):</span><br>    __test__ = <span class="hljs-literal">False</span>  <span class="hljs-comment"># For pytest to not discover this up.</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">        self,</span></span><br><span class="hljs-function"><span class="hljs-params">        app: typing.Union[ASGI2App, ASGI3App],</span></span><br><span class="hljs-function"><span class="hljs-params">        base_url: <span class="hljs-built_in">str</span> = <span class="hljs-string">&quot;http://testserver&quot;</span>,</span></span><br><span class="hljs-function"><span class="hljs-params">        raise_server_exceptions: <span class="hljs-built_in">bool</span> = <span class="hljs-literal">True</span>,</span></span><br><span class="hljs-function"><span class="hljs-params">        root_path: <span class="hljs-built_in">str</span> = <span class="hljs-string">&quot;&quot;</span>,</span></span><br><span class="hljs-function"><span class="hljs-params">    </span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        <span class="hljs-built_in">super</span>(TestClient, self).__init__()<br>        <span class="hljs-keyword">if</span> _is_asgi3(app):<br>            app = typing.cast(ASGI3App, app)<br>            asgi_app = app<br>        <span class="hljs-keyword">else</span>:<br>            app = typing.cast(ASGI2App, app)<br>            asgi_app = _WrapASGI2(app)  <span class="hljs-comment">#  type: ignore</span><br>        <span class="hljs-comment"># 使用了request的Adapter功能， </span><br>        adapter = _ASGIAdapter(<br>            asgi_app,<br>            raise_server_exceptions=raise_server_exceptions,<br>            root_path=root_path,<br>        )<br>        self.mount(<span class="hljs-string">&quot;http://&quot;</span>, adapter)<br>        self.mount(<span class="hljs-string">&quot;https://&quot;</span>, adapter)<br>        self.mount(<span class="hljs-string">&quot;ws://&quot;</span>, adapter)<br>        self.mount(<span class="hljs-string">&quot;wss://&quot;</span>, adapter)<br>        self.headers.update(&#123;<span class="hljs-string">&quot;user-agent&quot;</span>: <span class="hljs-string">&quot;testclient&quot;</span>&#125;)<br>        self.app = asgi_app<br>        self.base_url = base_url<br></code></pre></td></tr></table></figure>
<p>从这个可以看出， TestClient继承于requests.Session的方法， 证明可以在编写测试用例时， 直接调用到requests.Session的相关的方法。然后在<code>__init__</code>方法中实例化了一个<code>adapter</code>, 这里是使用了<code>requests</code>的adapter机制， 通过adpater机制， 可以拦截请求的数据和响应的数据。<br><code>_ASGIdapter</code>的代码比较多， 但是它的实现逻辑很简单， 它重载了<code>Adapter</code>的<code>send</code>方法， 当执行到<code>send</code>方法时， 它会变成执行<code>app(scope, receive, send)</code>, 其中<code>receive</code>是负责把请求的数据转换为ASGI协议，供下一级ASGI APP调用。而<code>send</code>(位于<code>Adapter.send</code>里面的闭包函数)则获取ASGI APP返回的数据并存放到字典中， 当ASGI APP执行完毕的时候， <code>Adapter</code>的<code>send</code>方法会根据执行是否异常以及存放数据的字典转化为一个<code>request.Response</code>的实例返回给用户。</p>
<p>通过<code>_ASGIdapter</code>了解了<code>starlette</code>是如何解决第三个问题的， 接下来是<code>with</code>语法相关的<code>__enter__</code>, <code>__exit__</code>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestClient</span>(<span class="hljs-params">requests.Session</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__enter__</span>(<span class="hljs-params">self</span>) -&gt; &quot;TestClient&quot;:</span><br>        loop = asyncio.get_event_loop()<br>        self.send_queue = asyncio.Queue()  <span class="hljs-comment"># type: asyncio.Queue</span><br>        self.receive_queue = asyncio.Queue()  <span class="hljs-comment"># type: asyncio.Queue</span><br>        self.task = loop.create_task(self.lifespan())<br>        loop.run_until_complete(self.wait_startup())<br>        <span class="hljs-keyword">return</span> self<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__exit__</span>(<span class="hljs-params">self, *args: typing.Any</span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        loop = asyncio.get_event_loop()<br>        loop.run_until_complete(self.wait_shutdown())<br></code></pre></td></tr></table></figure>
<p>可以看出， 在使用进入上下文和退出上下文时， 自动调用了<code>lifespan</code>方法， 然后通过<code>lifespan</code>机制来实现<code>on_startup</code>和<code>on_shutdown</code>功能, 具体的源码和注释如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestClient</span>(<span class="hljs-params">requests.Session</span>):</span><br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">lifespan</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        <span class="hljs-comment"># 构造lifespan的scope</span><br>        scope = &#123;<span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;lifespan&quot;</span>&#125;<br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-comment"># 发送到starlette, 然后starlette就会根据receive执行对应的事件</span><br>            <span class="hljs-keyword">await</span> self.app(scope, self.receive_queue.get, self.send_queue.put)<br>        <span class="hljs-keyword">finally</span>:<br>            <span class="hljs-keyword">await</span> self.send_queue.put(<span class="hljs-literal">None</span>)<br><br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">wait_startup</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        <span class="hljs-comment"># 发送lifespan开始信息</span><br>        <span class="hljs-keyword">await</span> self.receive_queue.put(&#123;<span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;lifespan.startup&quot;</span>&#125;)<br>        <span class="hljs-comment"># 监听starlette返回的lifespan信息, 并判断信息是否正确</span><br>        message = <span class="hljs-keyword">await</span> self.send_queue.get()<br>        <span class="hljs-keyword">if</span> message <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            self.task.result()<br>        <span class="hljs-keyword">assert</span> message[<span class="hljs-string">&quot;type&quot;</span>] <span class="hljs-keyword">in</span> (<br>            <span class="hljs-string">&quot;lifespan.startup.complete&quot;</span>,<br>            <span class="hljs-string">&quot;lifespan.startup.failed&quot;</span>,<br>        )<br>        <span class="hljs-comment"># 如果错误， 则消费task.result</span><br>        <span class="hljs-keyword">if</span> message[<span class="hljs-string">&quot;type&quot;</span>] == <span class="hljs-string">&quot;lifespan.startup.failed&quot;</span>:<br>            message = <span class="hljs-keyword">await</span> self.send_queue.get()<br>            <span class="hljs-keyword">if</span> message <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>                self.task.result()<br><br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">wait_shutdown</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        <span class="hljs-comment"># 发送lifespan关闭信息</span><br>        <span class="hljs-keyword">await</span> self.receive_queue.put(&#123;<span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;lifespan.shutdown&quot;</span>&#125;)<br>        message = <span class="hljs-keyword">await</span> self.send_queue.get()<br>        <span class="hljs-keyword">if</span> message <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            self.task.result()<br>        <span class="hljs-keyword">assert</span> message[<span class="hljs-string">&quot;type&quot;</span>] == <span class="hljs-string">&quot;lifespan.shutdown.complete&quot;</span><br>        <span class="hljs-comment"># 等待starlette的lifespan执行结束</span><br>        <span class="hljs-keyword">await</span> self.task<br></code></pre></td></tr></table></figure>
<h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5.总结"></a>5.总结</h2><p>至此， <code>starlette</code>的几个重要的功能代码都分析完了， <code>starlette</code>是一个非常棒的库， 它的设计思路也是非常的棒， 建议大家自己读一遍<code>starlette</code>的源代码， 对以后自己写框架是有帮助的。</p>
]]></content>
      <categories>
        <category>源码分析</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>初识Python协程的实现</title>
    <url>/2021/11/08/%E5%88%9D%E8%AF%86Python%20Async%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h2 id="前记"><a href="#前记" class="headerlink" title="前记"></a>前记</h2><p><a href="https://so1n.me/2021/10/29/Python%E7%9A%84Sync%E4%B8%8EAsync%E6%89%A7%E8%A1%8C%E9%80%9F%E5%BA%A6%E7%9A%84%E5%BF%AB%E6%85%A2/">上一遍文章</a>简单的介绍了<code>Python</code>的通过<code>Async</code>语法实现协程的优劣性以及它的特点， 在io比较多的场景中， <code>Async</code>语法编写的程序会以更少的时间， 更少的资源来完成相同的任务， 这篇文章则是介绍了<code>Python</code>的<code>Async</code>语法的协程是如何实现的。</p>
<span id="more"></span>
<h2 id="1-传统的Sync语法请求例子"><a href="#1-传统的Sync语法请求例子" class="headerlink" title="1.传统的Sync语法请求例子"></a>1.传统的Sync语法请求例子</h2><p>还是一样， 在了解<code>Async</code>语法的实现之前， 先从一个<code>Sync</code>的语法例子开始， 现在假设有一个HTTP请求， 这个程序会通过这个请求获取对应的响应内容， 并打印出来, 代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> socket<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">request</span>(<span class="hljs-params">host: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>    <span class="hljs-string">&quot;&quot;&quot;模拟请求并打印响应体&quot;&quot;&quot;</span><br>    url: <span class="hljs-built_in">str</span> = <span class="hljs-string">f&quot;http://<span class="hljs-subst">&#123;host&#125;</span>&quot;</span><br>    sock: socket.SocketType = socket.socket()<br>    sock.connect((host, <span class="hljs-number">80</span>))<br>    sock.send(<span class="hljs-string">f&quot;GET <span class="hljs-subst">&#123;url&#125;</span> HTTP/1.0\r\nHost: <span class="hljs-subst">&#123;host&#125;</span>\r\n\r\n&quot;</span>.encode(<span class="hljs-string">&quot;ascii&quot;</span>))<br><br>    response_bytes: <span class="hljs-built_in">bytes</span> = <span class="hljs-string">b&quot;&quot;</span><br>    chunk: <span class="hljs-built_in">bytes</span> = sock.recv(<span class="hljs-number">4096</span>)<br>    <span class="hljs-keyword">while</span> chunk:<br>        response_bytes += chunk<br>        chunk = sock.recv(<span class="hljs-number">4096</span>)<br>    print(<span class="hljs-string">&quot;\n&quot;</span>.join([i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> response_bytes.decode().split(<span class="hljs-string">&quot;\r\n&quot;</span>)]))<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    request(<span class="hljs-string">&quot;so1n.me&quot;</span>)<br></code></pre></td></tr></table></figure>
<p>运行程序， 程序能够正常输出, 上部分打印了对应的HTTP响应Header, 下部分打印了HTTP响应体, , 可以看到服务端叫我们以https的形式重新请求， 输出结果如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">HTTP/1.1 301 Moved Permanently<br>Server: GitHub.com<br>Content-Type: text/html<br>Location: https://so1n.me/<br>X-GitHub-Request-Id: A744:3871:4136AF:48BD9F:6188DB50<br>Content-Length: 162<br>Accept-Ranges: bytes<br>Date: Mon, 08 Nov 2021 08:11:37 GMT<br>Via: 1.1 varnish<br>Age: 104<br>Connection: close<br>X-Served-By: cache-qpg1272-QPG<br>X-Cache: HIT<br>X-Cache-Hits: 2<br>X-Timer: S1636359097.026094,VS0,VE0<br>Vary: Accept-Encoding<br>X-Fastly-Request-ID: 22fa337f777553d33503cee5282598c6a293fb5e<br><br>&lt;html&gt;<br>&lt;head&gt;&lt;title&gt;301 Moved Permanently&lt;/title&gt;&lt;/head&gt;<br>&lt;body&gt;<br>&lt;center&gt;&lt;h1&gt;301 Moved Permanently&lt;/h1&gt;&lt;/center&gt;<br>&lt;hr&gt;&lt;center&gt;nginx&lt;/center&gt;<br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure>
<p>不过这里并不是想说HTTP请求是如何实现的， 具体我也不太了解， 在这个代码中， socket的默认调用是阻塞的， 当线程调用<code>connect</code>或者<code>recv</code>时(<code>send</code>是不用等待的， 但在高并发下需要先等待<code>drain</code>后才可以<code>send</code>, 小demo不需要用到<code>drain</code>方法)， 程序将会暂停直到操作完成。 当一次要下载很多网页的话， 这将会如上篇文章所说的一样， 大部分的等待时间都花在io上面， cpu却一直空闲时， 而使用线程池虽然可以解决这个问题， 但是开销是很大的， 同时操作系统往往会限制一个进程，用户或者机器可以使用的线程数， 而协程却没有这些限制， 占用的资源少， 也没有系统限制瓶颈。</p>
<h2 id="2-异步的请求"><a href="#2-异步的请求" class="headerlink" title="2.异步的请求"></a>2.异步的请求</h2><p>异步可以让一个单独的线程处理并发的操作， 不过在上面已经说过了， socket是默认阻塞的， 所以需要把socket设置为非阻塞的, socket提供了<code>setblocking</code>这个方法供开发者选择是否阻塞， 在设置了非阻塞后， <code>connect</code>和<code>recv</code>方法也要进行更改。</p>
<p>由于没有了阻塞， 程序在调用了<code>connect</code>后会马上返回， 只不过<code>Python</code>的底层是<code>C</code>, 这段代码在<code>C</code>中调用非阻塞的socket.connect后会抛出一个异常， 我们需要捕获它， 就像这样：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> socket<br><br>sock: socket.SocketType = socket.socket()<br>sock.setblocking(Flase)<br><span class="hljs-keyword">try</span>:<br>    sock.connect((<span class="hljs-string">&quot;so1n.me&quot;</span>, <span class="hljs-number">80</span>))<br><span class="hljs-keyword">except</span> BlockingIOError:<br>    <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure>
<p>经过一顿操作后， 就开始申请建立连接了， 但是我们还不知道连接啥时候完成建立， 由于连接没建立时调用<code>send</code>会报错， 所以可以一直轮询调用<code>send</code>直到没报错就认为是成功（真实代码需要加超时）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    <span class="hljs-keyword">try</span>: <br>        sock.send(request)<br>        <span class="hljs-keyword">break</span><br>    <span class="hljs-keyword">except</span> OSError <span class="hljs-keyword">as</span> e:<br>        <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure>
<p>但是这样让CPU空转太浪费性能了， 而且期间还不能做别的事情， 就像我们点外卖后一直打电话过去问饭菜做好了没有， 十分浪费电话费用， 要是饭菜做完了就打电话告诉我们， 那就只产生了一笔费用， 非常的省钱（正常情况下也是这样子）。<br>这时就需要事件循环登场了，在类UNIX中， 有一个叫<code>select</code>的功能， 它可以等待事件发生后再调用监听的函数， 不过一开始的实现性能不是很好， 在<code>Linux</code>上被<code>epoll</code>取代， 不过接口是类似的， 所在在<code>Python</code>中把这几个不同的事件循环都封装在<code>selectors</code>库中， 同时可以通过<code>DefaultSelector</code>从系统中挑出最好的类<code>select</code>函数。<br>这里先暂时不说事件循环的原理， 事件循环最主要的是他名字的两部分， 一个是事件， 一个是循环， 在<code>Python</code>中， 可以通过如下方法把事件注册到事件循环中：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">demo</span>():</span> <span class="hljs-keyword">pass</span><br><br>selector.register(fd, EVENT_WRITE, demo)<br></code></pre></td></tr></table></figure>
<p>这样这个事件循环就会监听对应的文件描述符fd, 当这个文件描述符触发写入事件(EVENT_WRITE)时，事件循环就会告诉我们可以去调用注册的函数<code>demo</code>。不过如果把上面的代码都改为这种方法去运行的话就会发现， 程序好像没跑就结束了， 但程序其实是有跑的， 只不过他们是完成的了注册， 然后就等待开发者接收事件循环的事件进行下一步的操作， 所以我们只需要在代码的最后面写上如下代码:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    <span class="hljs-keyword">for</span> key, mask <span class="hljs-keyword">in</span> selector.select():<br>        key.data()<br></code></pre></td></tr></table></figure>
<p>这样程序就会一直运行, 当捕获到事件的时候， 就会通过for循环告诉我们， 其中<code>key.data</code>是我们注册的回调函数， 当事件发生时， 就会通知我们， 我们可以通过拿到回调函数然后就运行, 了解完毕后， 我们可以来编写我们的第一个并发程序， 他实现了一个简单的I/O复用的小逻辑, 代码和注释如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> socket<br><span class="hljs-keyword">from</span> selectors <span class="hljs-keyword">import</span> DefaultSelector, EVENT_READ, EVENT_WRITE<br><br><br><span class="hljs-comment"># 选择事件循环</span><br>selector: DefaultSelector = DefaultSelector()<br><span class="hljs-comment"># 用于判断是否有事件在运行</span><br>running_cnt: <span class="hljs-built_in">int</span> = <span class="hljs-number">0</span><br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">request</span>(<span class="hljs-params">host: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>    <span class="hljs-string">&quot;&quot;&quot;模拟请求并打印响应体&quot;&quot;&quot;</span><br>    <span class="hljs-comment"># 告诉主函数， 自己的事件还在运行</span><br>    <span class="hljs-keyword">global</span> running_cnt<br>    running_cnt += <span class="hljs-number">1</span><br>    <br>    <span class="hljs-comment"># 初始化socket</span><br>    url: <span class="hljs-built_in">str</span> = <span class="hljs-string">f&quot;http://<span class="hljs-subst">&#123;host&#125;</span>&quot;</span><br>    sock: socket.SocketType = socket.socket()<br>    sock.setblocking(<span class="hljs-literal">False</span>)<br>    <span class="hljs-keyword">try</span>:<br>        sock.connect((host, <span class="hljs-number">80</span>))<br>    <span class="hljs-keyword">except</span> BlockingIOError:<br>        <span class="hljs-keyword">pass</span><br><br>    response_bytes: <span class="hljs-built_in">bytes</span> = <span class="hljs-string">b&quot;&quot;</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">read_response</span>() -&gt; <span class="hljs-keyword">None</span>:</span><br>        <span class="hljs-string">&quot;&quot;&quot;接收响应参数， 并判断请求是否结束&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">nonlocal</span> response_bytes<br>        chunk: <span class="hljs-built_in">bytes</span> = sock.recv(<span class="hljs-number">4096</span>)<br>        print(<span class="hljs-string">f&quot;recv <span class="hljs-subst">&#123;host&#125;</span> body success&quot;</span>)<br>        <span class="hljs-keyword">if</span> chunk:<br>            response_bytes += chunk<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-comment"># 没有数据代表请求结束了， 注销监听</span><br>            selector.unregister(sock.fileno())<br>            <span class="hljs-keyword">global</span> running_cnt<br>            running_cnt -= <span class="hljs-number">1</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">connected</span>() -&gt; <span class="hljs-keyword">None</span>:</span><br>        <span class="hljs-string">&quot;&quot;&quot;socket建立连接时的回调&quot;&quot;&quot;</span><br>        <span class="hljs-comment"># 取消监听</span><br>        selector.unregister(sock.fileno())<br>        print(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;host&#125;</span> connect success&quot;</span>)<br>        <span class="hljs-comment"># 发送请求， 并监听读事件， 以及注册对应的接收响应函数</span><br>        sock.send(<span class="hljs-string">f&quot;GET <span class="hljs-subst">&#123;url&#125;</span> HTTP/1.0\r\nHost: <span class="hljs-subst">&#123;host&#125;</span>\r\n\r\n&quot;</span>.encode(<span class="hljs-string">&quot;ascii&quot;</span>))<br>        selector.register(sock.fileno(), EVENT_READ, read_response)<br><br>    selector.register(sock.fileno(), EVENT_WRITE, connected)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    <span class="hljs-comment"># 同时多个请求</span><br>    request(<span class="hljs-string">&quot;so1n.me&quot;</span>)<br>    request(<span class="hljs-string">&quot;github.com&quot;</span>)<br>    request(<span class="hljs-string">&quot;google.com&quot;</span>)<br>    request(<span class="hljs-string">&quot;baidu.com&quot;</span>)<br>    <span class="hljs-comment"># 监听是否有事件在运行</span><br>    <span class="hljs-keyword">while</span> running_cnt &gt; <span class="hljs-number">0</span>:<br>        <span class="hljs-comment"># 等待事件循环通知事件是否已经完成</span><br>        <span class="hljs-keyword">for</span> key, mask <span class="hljs-keyword">in</span> selector.select():<br>            key.data()<br></code></pre></td></tr></table></figure>
<p>这段代码接近同时注册了4个请求并注册建立连接回调， 然后就进入事件循环逻辑， 也就是把控制权交给事件循环， 直到事件循环告诉程序说收到了socket建立的通知， 程序就会取消注册的回调然后发送请求， 并注册一个读的事件回调， 然后又把控制权交给事件循环， 直到收到了响应的结果才进入处理响应结果函数并且只有收完所有响应结果才会退出程序。 下面是我其中的一次执行结果</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">so1n.me connect success<br>github.com connect success<br>google.com connect success<br>recv google.com body success<br>recv google.com body success<br>baidu.com connect success<br>recv github.com body success<br>recv github.com body success<br>recv baidu.com body success<br>recv baidu.com body success<br>recv so1n.me body success<br>recv so1n.me body success<br></code></pre></td></tr></table></figure>
<p>可以看到他们的执行顺序是随机的， 不是严格的按照<code>so1n.me</code>, <code>github.com</code>, <code>google.com</code>, <code>baidu.com</code>顺序执行， 同时他们执行速度很快， 这个程序的耗时约等于响应时长最长的函数耗时。<br>但是可以看出， 这个程序里面出现了两个回调， 回调会让代码变得非常的奇怪, 降低可读性， 也容易造成回调地狱， 而且当回调发生报错的时候， 我们是很难知道这是由于什么导致的错误， 因为它的上下文丢失了， 这样子排查问题十分的困惑。 作为程序员， 一般都不止满足于速度快的代码， 真正想要的是又快， 又能像<code>Sync</code>的代码一样简单, 可读性强, 也能容易排查问题的代码, 这种组合形式的代码的设计模式就叫协程。</p>
<p>协程出现得很早， 它不像线程一样， 被系统调度， 而是能自主的暂停， 并等待事件循环通知恢复。由于协程是软件层面实现的， 所以它的实现方式有很多种， 这里要说的是基于生成器的协程， 因为生成器跟协程一样， 都有暂停让步和恢复的方法(还可以通过<code>throw</code>来抛错）， 同时它跟<code>Async</code>语法的协程很像， 通过了解基于生成器的协程， 可以了解<code>Async</code>的协程是如何实现的。</p>
<h2 id="3-基于生成器的协程"><a href="#3-基于生成器的协程" class="headerlink" title="3.基于生成器的协程"></a>3.基于生成器的协程</h2><h3 id="3-1生成器"><a href="#3-1生成器" class="headerlink" title="3.1生成器"></a>3.1生成器</h3><p>在了解基于生成器的协程之前， 需要先了解下生成器， <code>Python</code>的生成器函数与普通的函数会有一些不同, 只有普通函数中带有关键字<code>yield</code>， 那么它就是生成器函数， 具体有什么不同可以通过他们的字节码来了解：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python">In [<span class="hljs-number">1</span>]: <span class="hljs-keyword">import</span> dis<br><br><span class="hljs-comment"># 普通函数</span><br>In [<span class="hljs-number">2</span>]: <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">aaa</span>():</span> <span class="hljs-keyword">pass</span><br><br>In [<span class="hljs-number">3</span>]: dis.dis(aaa)<br>                                                                                                                                                                                <br>  <span class="hljs-number">1</span>           <span class="hljs-number">0</span> LOAD_CONST               <span class="hljs-number">0</span> (<span class="hljs-literal">None</span>)<br>              <span class="hljs-number">2</span> RETURN_VALUE<br><br><span class="hljs-comment"># 普通函数调用函数</span><br>In [<span class="hljs-number">4</span>]: <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">bbb</span>():</span> <br>   ...:     aaa() <br>   ...:<br><br><br>In [<span class="hljs-number">5</span>]: dis.dis(bbb)<br><br>  <span class="hljs-number">2</span>           <span class="hljs-number">0</span> LOAD_GLOBAL              <span class="hljs-number">0</span> (aaa)<br>              <span class="hljs-number">2</span> CALL_FUNCTION            <span class="hljs-number">0</span><br>              <span class="hljs-number">4</span> POP_TOP<br>              <span class="hljs-number">6</span> LOAD_CONST               <span class="hljs-number">0</span> (<span class="hljs-literal">None</span>)<br>              <span class="hljs-number">8</span> RETURN_VALUE<br><br><span class="hljs-comment"># 普通生成器函数</span><br>In [<span class="hljs-number">6</span>]: <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">ccc</span>():</span> <span class="hljs-keyword">yield</span><br><br>In [<span class="hljs-number">7</span>]: dis.dis(ccc)<br>                                                                                                                                                                                <br>  <span class="hljs-number">1</span>           <span class="hljs-number">0</span> LOAD_CONST               <span class="hljs-number">0</span> (<span class="hljs-literal">None</span>)<br>              <span class="hljs-number">2</span> YIELD_VALUE<br>              <span class="hljs-number">4</span> POP_TOP<br>              <span class="hljs-number">6</span> LOAD_CONST               <span class="hljs-number">0</span> (<span class="hljs-literal">None</span>)<br>              <span class="hljs-number">8</span> RETURN_VALUE<br></code></pre></td></tr></table></figure>
<p>上面分别是普通函数， 普通函数调用函数和普通生成器函数的字节码， 从字节码可以看出来， 最简单的函数只需要<code>LOAD_CONST</code>来加载变量None压入自己的栈， 然后通过<code>RETURN_VALUE</code>来返回值， 而有函数调用的普通函数则先加载变量， 把全局变量的函数<code>aaa</code>加载到自己的栈里面， 然后通过<code>CALL_FUNCTION</code>来调用函数， 最后通过<code>POP_TOP</code>把函数的返回值从栈里抛出来， 再把通过<code>LOAD_CONST</code>把None压入自己的栈， 最后返回值。<br>而生成器函数则不一样， 它会先通过<code>LOAD_CONST</code>来加载变量None压入自己的栈， 然后通过<code>YIELD_VALUE</code>返回值， 接着通过<code>POP_TOP</code>弹出刚才的栈并重新把变量None压入自己的栈， 最后通过<code>RETURN_VALUE</code>来返回值。从字节码来分析可以很清楚的看到， 生成器能够在<code>yield</code>区分两个栈帧, 一个函数调用可以分为多次返回， 很符合协程多次等待的特点。</p>
<p>接着来看看生成器的一个使用, 这个生成器会有两次<code>yield</code>调用, 并在最后返回字符串<code>&#39;None&#39;</code>， 代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python">In [<span class="hljs-number">8</span>]: <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">demo</span>():</span> <br>   ...:     a = <span class="hljs-number">1</span> <br>   ...:     b = <span class="hljs-number">2</span> <br>   ...:     print(<span class="hljs-string">&#x27;aaa&#x27;</span>, <span class="hljs-built_in">locals</span>()) <br>   ...:     <span class="hljs-keyword">yield</span> <span class="hljs-number">1</span> <br>   ...:     print(<span class="hljs-string">&#x27;bbb&#x27;</span>, <span class="hljs-built_in">locals</span>()) <br>   ...:     <span class="hljs-keyword">yield</span> <span class="hljs-number">2</span> <br>   ...:     <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;None&#x27;</span> <br>   ...:<br>                                                                                                                                                                                                   <br>In [<span class="hljs-number">9</span>]: demo_gen = demo()<br><br>In [<span class="hljs-number">10</span>]: demo_gen.send(<span class="hljs-literal">None</span>)<br><br>aaa &#123;<span class="hljs-string">&#x27;a&#x27;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;b&#x27;</span>: <span class="hljs-number">2</span>&#125;<br>Out[<span class="hljs-number">10</span>]: <span class="hljs-number">1</span><br><br>In [<span class="hljs-number">11</span>]: demo_gen.send(<span class="hljs-literal">None</span>)<br><br>bbb &#123;<span class="hljs-string">&#x27;a&#x27;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;b&#x27;</span>: <span class="hljs-number">2</span>&#125;<br>Out[<span class="hljs-number">11</span>]: <span class="hljs-number">2</span><br><br>In [<span class="hljs-number">12</span>]: demo_gen.send(<span class="hljs-literal">None</span>)<br><br>---------------------------------------------------------------------------<br>StopIteration                             Traceback (most recent call last)<br>&lt;ipython-<span class="hljs-built_in">input</span>-<span class="hljs-number">12</span>-8f8cb075d6af&gt; <span class="hljs-keyword">in</span> &lt;module&gt;<br>----&gt; 1 demo_gen.send(None)<br><br>StopIteration: <span class="hljs-literal">None</span><br><br></code></pre></td></tr></table></figure>
<p>这段代码首先通过函数调用生成一个<code>demo_gen</code>的生成器对象, 然后第一次<code>send</code>调用时返回值1， 第二次<code>send</code>调用时返回值2， 第三次<code>send</code>调用则抛出<code>StopIteration</code>异常， 异常提示为<code>None</code>, 同时可以看到第一次打印<code>aaa</code>和第二次打印<code>bbb</code>时， 他们都能打印到当前的函数局部变量， 可以发现在即使在不同的栈帧中， 他们读取到当前的局部函数内的局部变量是一致的， 这意味着如果使用生成器来模拟协程时， 它还是会一直读取到当前上下文的， 非常的完美。</p>
<p>此外， <code>Python</code>还支持通过<code>yield from</code>语法来返回一个生成器, 代码如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python">In [<span class="hljs-number">1</span>]: <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">demo_gen_1</span>():</span> <br>   ...:     <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>): <br>   ...:         <span class="hljs-keyword">yield</span> i <br>   ...:<br><br>In [<span class="hljs-number">2</span>]: <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">demo_gen_2</span>():</span> <br>   ...:     <span class="hljs-keyword">yield</span> <span class="hljs-keyword">from</span> demo_gen_1() <br>   ...:<br><br>In [<span class="hljs-number">3</span>]: demo_gen_obj = demo_gen_2()<br><br>In [<span class="hljs-number">4</span>]: demo_gen_obj.send(<span class="hljs-literal">None</span>)<br>                                                                                                                                                                     <br>Out[<span class="hljs-number">4</span>]: <span class="hljs-number">0</span><br><br>In [<span class="hljs-number">5</span>]: demo_gen_obj.send(<span class="hljs-literal">None</span>)<br><br>Out[<span class="hljs-number">5</span>]: <span class="hljs-number">1</span><br><br>In [<span class="hljs-number">6</span>]: demo_gen_obj.send(<span class="hljs-literal">None</span>)<br><br>Out[<span class="hljs-number">6</span>]: <span class="hljs-number">2</span><br><br>In [<span class="hljs-number">7</span>]: demo_gen_obj.send(<span class="hljs-literal">None</span>)<br>                                                                                                                                    <br>---------------------------------------------------------------------------<br>StopIteration                             Traceback (most recent call last)<br>&lt;ipython-<span class="hljs-built_in">input</span>-<span class="hljs-number">7</span>-f9922a2f64c9&gt; <span class="hljs-keyword">in</span> &lt;module&gt;<br>----&gt; 1 demo_gen_obj.send(None)<br><br>StopIteration: <br><br><br></code></pre></td></tr></table></figure>
<p>通过<code>yield from</code>就可以很方便的支持生成器调用， 假如把每个生成器函数都当做一个协程， 那通过<code>yield from</code>就可以很方便的实现协程间的调用， 此外生成器的抛出异常后的提醒非常人性化， 也支持<code>throw</code>来抛出异常， 这样我们就可以实现在协程运行时设置异常， 比如<code>Cancel</code>，演示代码如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python">In [<span class="hljs-number">1</span>]: <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">demo_exc</span>():</span> <br>   ...:     <span class="hljs-keyword">yield</span> <span class="hljs-number">1</span> <br>   ...:     <span class="hljs-keyword">raise</span> RuntimeError() <br>   ...:<br><br>In [<span class="hljs-number">2</span>]: <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">demo_exc_1</span>():</span> <br>   ...:     <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>): <br>   ...:         <span class="hljs-keyword">yield</span> i <br>   ...:<br><br>In [<span class="hljs-number">3</span>]: demo_exc_gen = demo_exc()<br><br>In [<span class="hljs-number">4</span>]: demo_exc_gen.send(<span class="hljs-literal">None</span>)<br>                                                                                                                                                                     <br>Out[<span class="hljs-number">4</span>]: <span class="hljs-number">1</span><br><br>In [<span class="hljs-number">5</span>]: demo_exc_gen.send(<span class="hljs-literal">None</span>)<br>                                                                                                                                     <br>---------------------------------------------------------------------------<br>RuntimeError                              Traceback (most recent call last)<br>&lt;ipython-<span class="hljs-built_in">input</span>-<span class="hljs-number">5</span>-09fbb75fdf7d&gt; <span class="hljs-keyword">in</span> &lt;module&gt;<br>----&gt; 1 demo_exc_gen.send(None)<br><br>&lt;ipython-<span class="hljs-built_in">input</span>-<span class="hljs-number">1</span>-69afbc1f9c19&gt; <span class="hljs-keyword">in</span> demo_exc()<br>      <span class="hljs-number">1</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">demo_exc</span>():</span><br>      <span class="hljs-number">2</span>     <span class="hljs-keyword">yield</span> <span class="hljs-number">1</span><br>----&gt; 3     raise RuntimeError()<br>      <span class="hljs-number">4</span> <br><br>RuntimeError: <br><br>In [<span class="hljs-number">6</span>]: demo_exc_gen_1 = demo_exc_1()<br><br>In [<span class="hljs-number">7</span>]: demo_exc_gen_1.send(<span class="hljs-literal">None</span>)<br>                                                                                                                                        Out[<span class="hljs-number">7</span>]: <span class="hljs-number">0</span><br><br>In [<span class="hljs-number">8</span>]: demo_exc_gen_1.send(<span class="hljs-literal">None</span>)<br>                                                                                                                                        Out[<span class="hljs-number">8</span>]: <span class="hljs-number">1</span><br><br>In [<span class="hljs-number">9</span>]: demo_exc_gen_1.throw(RuntimeError)<br>                                                                                                                                        ---------------------------------------------------------------------------<br>RuntimeError                              Traceback (most recent call last)<br>&lt;ipython-<span class="hljs-built_in">input</span>-<span class="hljs-number">9</span>-1a1cc55d71f4&gt; <span class="hljs-keyword">in</span> &lt;module&gt;<br>----&gt; 1 demo_exc_gen_1.throw(RuntimeError)<br><br>&lt;ipython-<span class="hljs-built_in">input</span>-<span class="hljs-number">2</span>-2617b2366dce&gt; <span class="hljs-keyword">in</span> demo_exc_1()<br>      <span class="hljs-number">1</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">demo_exc_1</span>():</span><br>      <span class="hljs-number">2</span>     <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>):<br>----&gt; 3         yield i<br>      <span class="hljs-number">4</span> <br><br>RuntimeError: <br></code></pre></td></tr></table></figure>
<p>从中可以看到在运行中抛出异常时， 会有一个非常清楚的抛错， 可以明显看出错误堆栈， 同时<code>throw</code>指定异常后， 会在下一处<code>yield</code>抛出异常(所以协程调用<code>Cancel</code>后不会马上取消， 而是下一次调用的时候才被取消)。</p>
<h3 id="3-2用生成器实现协程"><a href="#3-2用生成器实现协程" class="headerlink" title="3.2用生成器实现协程"></a>3.2用生成器实现协程</h3><p>我们已经简单的了解到了生成器是非常的贴合协程的编程模型， 同时也知道哪些生成器API是我们需要的API， 接下来可以模仿<code>Asyncio</code>的接口来实现一个简单的协程。</p>
<p>首先是在<code>Asyncio</code>中有一个封装叫<code>Feature</code>, 它用来表示协程正在等待将来时的结果, 以下是我根据<code>asyncio.Feature</code>封装的一个简单的<code>Feature</code>, 它的API没有<code>asyncio.Feature</code>全, 代码和注释如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Status</span>:</span><br>    <span class="hljs-string">&quot;&quot;&quot;用于判断Future状态&quot;&quot;&quot;</span><br>    pending: <span class="hljs-built_in">int</span> = <span class="hljs-number">1</span><br>    finished: <span class="hljs-built_in">int</span> = <span class="hljs-number">2</span><br>    cancelled: <span class="hljs-built_in">int</span> = <span class="hljs-number">3</span><br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Future</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        <span class="hljs-string">&quot;&quot;&quot;初始化时， Feature处理pending状态， 等待set result&quot;&quot;&quot;</span><br>        self.status: <span class="hljs-built_in">int</span> = Status.pending<br>        self._result: Any = <span class="hljs-literal">None</span><br>        self._exception: Optional[Exception] = <span class="hljs-literal">None</span><br>        self._callbacks: List[Callable[[<span class="hljs-string">&#x27;Future&#x27;</span>], <span class="hljs-literal">None</span>]] = []<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add_done_callback</span>(<span class="hljs-params">self, fn: [[<span class="hljs-string">&#x27;Future&#x27;</span>], <span class="hljs-literal">None</span>]Callable</span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        <span class="hljs-string">&quot;&quot;&quot;添加完成时的回调&quot;&quot;&quot;</span><br>        self._callbacks.append(fn)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">cancel</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;取消当前的Feature&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> self.status != Status.pending:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        self.status = Status.cancelled<br>        <span class="hljs-keyword">for</span> fn <span class="hljs-keyword">in</span> self._callbacks:<br>            fn(self)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">set_exception</span>(<span class="hljs-params">self, exc: Exception</span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        <span class="hljs-string">&quot;&quot;&quot;设置异常&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> self.status != Status.pending:<br>            <span class="hljs-keyword">raise</span> RuntimeError(<span class="hljs-string">&quot;Can not set exc&quot;</span>)<br>        self._exception = exc<br>        self.status = Status.finished<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">set_result</span>(<span class="hljs-params">self, result: Any</span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        <span class="hljs-string">&quot;&quot;&quot;设置结果&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> self.status != Status.pending:<br>            <span class="hljs-keyword">raise</span> RuntimeError(<span class="hljs-string">&quot;Can not set result&quot;</span>)<br>        self.status = Status.finished<br>        self._result = result<br>        <span class="hljs-keyword">for</span> fn <span class="hljs-keyword">in</span> self._callbacks:<br>            fn(self)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">result</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;获取结果&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> self.status == Status.cancelled:<br>            <span class="hljs-keyword">raise</span> asyncio.CancelledError<br>        <span class="hljs-keyword">elif</span> self.status != Status.finished:<br>            <span class="hljs-keyword">raise</span> RuntimeError(<span class="hljs-string">&quot;Result is not read&quot;</span>)<br>        <span class="hljs-keyword">elif</span> self._exception <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">raise</span> self._exception<br>        <span class="hljs-keyword">return</span> self._result<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__iter__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;通过生成器来模拟协程， 当收到结果通知时， 会返回结果&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> self.status == Status.pending:<br>            <span class="hljs-keyword">yield</span> self<br>        <span class="hljs-keyword">return</span> self.result()<br></code></pre></td></tr></table></figure>
<p>在理解<code>Future</code>时， 可以把它假想为一个状态机， 在启动初始化的时候是<code>peding</code>状态， 在运行的时候我们可以切换它的状态, 并且通过<code>__iter__</code>方法来支持调用者使用<code>yield from Future()</code>来等待<code>Future</code>本身， 直到收到了事件通知时， 可以得到结果。</p>
<p>但是可以发现这个<code>Future</code>是无法自我驱动, 调用了<code>__iter__</code>的程序不知道何时被调用了<code>set_result</code>， 在<code>Asyncio</code>中是通过一个叫<code>Task</code>的类来驱动<code>Future</code>, 它将一个协程的执行过程安排好， 并负责在事件循环中执行该协程。它主要有两个方法:</p>
<ul>
<li>1.初始化时， 会先通过<code>send</code>方法激活生成器</li>
<li>2.后续被调度后马上安排下一次等待， 除非抛出<code>StopIteration</code>异常</li>
</ul>
<p>还有一个支持取消运行托管协程的方法(在原代码中， <code>Task</code>是继承于<code>Future</code>, 所以<code>Future</code>有的它都有), 经过简化后的代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Task</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, coro: Generator</span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        <span class="hljs-comment"># 初始化状态</span><br>        self.cancelled: <span class="hljs-built_in">bool</span> = <span class="hljs-literal">False</span><br>        self.coro: Generator = coro<br>        <span class="hljs-comment"># 预激一个普通的future</span><br>        f: Future = Future()<br>        f.set_result(<span class="hljs-literal">None</span>)<br>        self.step(f)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">cancel</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        <span class="hljs-string">&quot;&quot;&quot;用于取消托管的coro&quot;&quot;&quot;</span><br>        self.coro.throw(asyncio.CancelledError)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">step</span>(<span class="hljs-params">self, f: Future</span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        <span class="hljs-string">&quot;&quot;&quot;用于调用coro的下一步, 从第一次激活开始， 每次都添加完成时的回调， 直到遇到取消或者StopIteration异常&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">try</span>:<br>            _future = self.coro.send(f.result())<br>        <span class="hljs-keyword">except</span> asyncio.CancelledError:<br>            self.cancelled = <span class="hljs-literal">True</span><br>            <span class="hljs-keyword">return</span><br>        <span class="hljs-keyword">except</span> StopIteration:<br>            <span class="hljs-keyword">return</span><br><br>        _future.add_done_callback(self.step)<br></code></pre></td></tr></table></figure>
<p>这样<code>Future</code>和<code>Task</code>就封装好了， 可以简单的试一试效果如何:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python">In [<span class="hljs-number">2</span>]:<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">wait_future</span>(<span class="hljs-params">f: Future, flag_int: <span class="hljs-built_in">int</span></span>) -&gt; Generator[Future, <span class="hljs-keyword">None</span>, <span class="hljs-keyword">None</span>]:</span> <br>   ...:    result = <span class="hljs-keyword">yield</span> <span class="hljs-keyword">from</span> f <br>   ...:    print(flag_int, result) <br>   ...:<br>   ...:future: Future = Future() <br>   ...:<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>): <br>   ...:    coro = wait_future(future, i) <br>   ...:    <span class="hljs-comment"># 托管wait_future这个协程， 里面的Future也会通过yield from被托管 </span><br>   ...:    Task(coro) <br>   ...:<br>   ...:print(<span class="hljs-string">&#x27;ready&#x27;</span>) <br>   ...:future.set_result(<span class="hljs-string">&#x27;ok&#x27;</span>) <br>   ...:<br>   ...:future = Future() <br>   ...:Task(wait_future(future, <span class="hljs-number">3</span>)).cancel() <br>   ...: <br>                                                                                                                                        ready<br><span class="hljs-number">0</span> ok<br><span class="hljs-number">1</span> ok<br><span class="hljs-number">2</span> ok<br>---------------------------------------------------------------------------<br>CancelledError                            Traceback (most recent call last)<br>&lt;ipython-<span class="hljs-built_in">input</span>-<span class="hljs-number">2</span>-2d1b04db2604&gt; <span class="hljs-keyword">in</span> &lt;module&gt;<br>     <span class="hljs-number">12</span> <br>     <span class="hljs-number">13</span> future = Future()<br>---&gt; 14 Task(wait_future(future, 3)).cancel()<br><br>&lt;ipython-<span class="hljs-built_in">input</span>-<span class="hljs-number">1</span>-ec3831082a88&gt; <span class="hljs-keyword">in</span> cancel(self)<br>     <span class="hljs-number">81</span> <br>     <span class="hljs-number">82</span>     <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">cancel</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>---&gt; 83         self.coro.throw(asyncio.CancelledError)<br>     <span class="hljs-number">84</span> <br>     <span class="hljs-number">85</span>     <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">step</span>(<span class="hljs-params">self, f: Future</span>) -&gt; <span class="hljs-keyword">None</span>:</span><br><br>&lt;ipython-<span class="hljs-built_in">input</span>-<span class="hljs-number">2</span>-2d1b04db2604&gt; <span class="hljs-keyword">in</span> wait_future(f, flag_int)<br>      <span class="hljs-number">1</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">wait_future</span>(<span class="hljs-params">f: Future, flag_int: <span class="hljs-built_in">int</span></span>) -&gt; Generator[Future, <span class="hljs-keyword">None</span>, <span class="hljs-keyword">None</span>]:</span><br>----&gt; 2     result = yield from f<br>      <span class="hljs-number">3</span>     print(flag_int, result)<br>      <span class="hljs-number">4</span> <br>      <span class="hljs-number">5</span> future: Future = Future()<br><br>&lt;ipython-<span class="hljs-built_in">input</span>-<span class="hljs-number">1</span>-ec3831082a88&gt; <span class="hljs-keyword">in</span> __iter__(self)<br>     <span class="hljs-number">68</span>         <span class="hljs-string">&quot;&quot;&quot;通过生成器来模拟协程， 当收到结果通知时， 会返回结果&quot;&quot;&quot;</span><br>     <span class="hljs-number">69</span>         <span class="hljs-keyword">if</span> self.status == Status.pending:<br>---&gt; 70             yield self<br>     <span class="hljs-number">71</span>         <span class="hljs-keyword">return</span> self.result()<br>     <span class="hljs-number">72</span> <br><br>CancelledError: <br></code></pre></td></tr></table></figure>
<p>这段程序会先初始化<code>Future</code>, 并把<code>Future</code>传给<code>wait_future</code>并生成生成器, 再交由给<code>Task</code>托管， 预激,  由于<code>Future</code>是在生成器函数<code>wait_future</code>中通过<code>yield from</code>与函数绑定的， 真正被预激的其实是<code>Future</code>的<code>__iter__</code>方法中的<code>yield self</code>, 此时代码逻辑会暂停在<code>yield self</code>并返回。<br>在全部预激后， 通过调用<code>Future</code>的<code>set_result</code>方法， 使<code>Future</code>变为结束状态， 由于<code>set_result</code>会执行注册的回调， 这时它就会执行托管它的<code>Task</code>的<code>step</code>方法中的<code>send</code>方法, 代码逻辑回到<code>Future</code>的<code>__iter__</code>方法中的<code>yield self</code>， 并继续往下走， 然后遇到<code>return</code>返回结果, 并继续走下去, 从输出可以发现程序封装完成且打印了<code>ready</code>后， 会依次打印对应的返回结果， 而在最后一个的测试<code>cancel</code>方法中可以看到，<code>Future</code>抛出异常了， 同时这些异常很容易看懂， 能够追随到调用的地方。</p>
<p>现在<code>Future</code>和<code>Task</code>正常运行了， 可以跟我们一开始执行的程序进行整合, 代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HttpRequest</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, host: <span class="hljs-built_in">str</span></span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;初始化变量和sock&quot;&quot;&quot;</span><br>        self._host: <span class="hljs-built_in">str</span> = host<br>        <span class="hljs-keyword">global</span> running_cnt<br>        running_cnt += <span class="hljs-number">1</span><br>        self.url: <span class="hljs-built_in">str</span> = <span class="hljs-string">f&quot;http://<span class="hljs-subst">&#123;host&#125;</span>&quot;</span><br>        self.sock: socket.SocketType = socket.socket()<br>        self.sock.setblocking(<span class="hljs-literal">False</span>)<br>        <span class="hljs-keyword">try</span>:<br>            self.sock.connect((host, <span class="hljs-number">80</span>))<br>        <span class="hljs-keyword">except</span> BlockingIOError:<br>            <span class="hljs-keyword">pass</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">read</span>(<span class="hljs-params">self</span>) -&gt; Generator[Future, <span class="hljs-keyword">None</span>, bytes]:</span><br>        <span class="hljs-string">&quot;&quot;&quot;从socket获取响应数据， 并set到Future中， 并通过Future.__iter__方法或得到数据并通过变量chunk_future返回&quot;&quot;&quot;</span><br>        f: Future = Future()<br>        selector.register(self.sock.fileno(), EVENT_READ, <span class="hljs-keyword">lambda</span>: f.set_result(self.sock.recv(<span class="hljs-number">4096</span>)))<br>        chunk_future = <span class="hljs-keyword">yield</span> <span class="hljs-keyword">from</span> f<br>        selector.unregister(self.sock.fileno())<br>        <span class="hljs-keyword">return</span> chunk_future  <span class="hljs-comment"># type: ignore</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">read_response</span>(<span class="hljs-params">self</span>) -&gt; Generator[Future, <span class="hljs-keyword">None</span>, bytes]:</span><br>        <span class="hljs-string">&quot;&quot;&quot;接收响应参数， 并判断请求是否结束&quot;&quot;&quot;</span><br>        response_bytes: <span class="hljs-built_in">bytes</span> = <span class="hljs-string">b&quot;&quot;</span><br>        chunk = <span class="hljs-keyword">yield</span> <span class="hljs-keyword">from</span> self.read()<br>        <span class="hljs-keyword">while</span> chunk:<br>            response_bytes += chunk<br>            chunk = <span class="hljs-keyword">yield</span> <span class="hljs-keyword">from</span> self.read()<br>        <span class="hljs-keyword">return</span> response_bytes<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">connected</span>(<span class="hljs-params">self</span>) -&gt; Generator[Future, <span class="hljs-keyword">None</span>, <span class="hljs-keyword">None</span>]:</span><br>        <span class="hljs-string">&quot;&quot;&quot;socket建立连接时的回调&quot;&quot;&quot;</span><br>        <span class="hljs-comment"># 取消监听</span><br>        f: Future = Future()<br>        selector.register(self.sock.fileno(), EVENT_WRITE, <span class="hljs-keyword">lambda</span>: f.set_result(<span class="hljs-literal">None</span>))<br>        <span class="hljs-keyword">yield</span> f<br>        selector.unregister(self.sock.fileno())<br>        print(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;self._host&#125;</span> connect success&quot;</span>)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">request</span>(<span class="hljs-params">self</span>) -&gt; Generator[Future, <span class="hljs-keyword">None</span>, <span class="hljs-keyword">None</span>]:</span><br>        <span class="hljs-comment"># 发送请求， 并监听读事件， 以及注册对应的接收响应函数</span><br>        <span class="hljs-keyword">yield</span> <span class="hljs-keyword">from</span> self.connected()<br>        self.sock.send(<span class="hljs-string">f&quot;GET <span class="hljs-subst">&#123;self.url&#125;</span> HTTP/1.0\r\nHost: <span class="hljs-subst">&#123;self._host&#125;</span>\r\n\r\n&quot;</span>.encode(<span class="hljs-string">&quot;ascii&quot;</span>))<br>        response = <span class="hljs-keyword">yield</span> <span class="hljs-keyword">from</span> self.read_response()<br>        print(<span class="hljs-string">f&quot;request <span class="hljs-subst">&#123;self._host&#125;</span> success, length:<span class="hljs-subst">&#123;<span class="hljs-built_in">len</span>(response)&#125;</span>&quot;</span>)<br>        <span class="hljs-keyword">global</span> running_cnt<br>        running_cnt -= <span class="hljs-number">1</span><br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    <span class="hljs-comment"># 同时多个请求</span><br>    Task(HttpRequest(<span class="hljs-string">&quot;so1n.me&quot;</span>).request())<br>    Task(HttpRequest(<span class="hljs-string">&quot;github.com&quot;</span>).request())<br>    Task(HttpRequest(<span class="hljs-string">&quot;google.com&quot;</span>).request())<br>    Task(HttpRequest(<span class="hljs-string">&quot;baidu.com&quot;</span>).request())<br>    <span class="hljs-comment"># 监听是否有事件在运行</span><br>    <span class="hljs-keyword">while</span> running_cnt &gt; <span class="hljs-number">0</span>:<br>        <span class="hljs-comment"># 等待事件循环通知事件是否已经完成</span><br>        <span class="hljs-keyword">for</span> key, mask <span class="hljs-keyword">in</span> selector.select():<br>            key.data()<br></code></pre></td></tr></table></figure>
<p>这段代码通过<code>Future</code>和生成器方法尽量的解耦回调函数， 如果忽略了<code>HttpRequest</code>中的<code>connected</code>和<code>read</code>方法则可以发现整段代码跟同步的代码基本上是一样的, 只是通过<code>yield</code>和<code>yield from</code>交出控制权和通过事件循环恢复控制权。 同时通过上面的异常例子可以发现异常排查非常的方便， 这样一来就没有了回调的各种糟糕的事情， 开发者只需要按照同步的思路进行开发即可， 不过我们的事件循环是一个非常简单的事件循环例子， 同时对于socket相关都没有进行封装， 也缺失一些常用的API， 而这些都会被<code>Python</code>官方封装到<code>Asyncio</code>这个库中， 通过该库， 我们可以近乎完美的编写<code>Async</code>语法的代码。</p>
<blockquote>
<p>NOTE: 由于生成器协程中无法通过<code>yield from</code>语法使用生成器， 所以<code>Python</code>在3.5之后使用了<code>Await</code>的原生协程。</p>
</blockquote>
]]></content>
      <categories>
        <category>Python Asyncio</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Asyncio</tag>
      </tags>
  </entry>
  <entry>
    <title>Python的Sync与Async执行速度的快慢</title>
    <url>/2021/11/04/Python%E7%9A%84Sync%E4%B8%8EAsync%E6%89%A7%E8%A1%8C%E9%80%9F%E5%BA%A6%E7%9A%84%E5%BF%AB%E6%85%A2/</url>
    <content><![CDATA[<h2 id="前记"><a href="#前记" class="headerlink" title="前记"></a>前记</h2><p>Python新的版本中支持了<code>async/await</code>语法， 很多文章都在说这种语法的实现代码会变得很快， 但是这种快是有场景限制的。这篇文章将尝试简单的解释为何<code>Async</code>的代码在某些场景比<code>Sync</code>的代码快。</p>
<span id="more"></span>
<h2 id="1-一个简单的例子"><a href="#1-一个简单的例子" class="headerlink" title="1.一个简单的例子"></a>1.一个简单的例子</h2><p>首先先从一个例子了解两种调用方法的差别, 为了能清晰的看出他们的运行时长差别， 都让他们重复运行10000次， 具体代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> asyncio<br><span class="hljs-keyword">import</span> time<br><br><br>n_call = <span class="hljs-number">10000</span><br><br><br><span class="hljs-comment"># sync的调用时长</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">demo</span>(<span class="hljs-params">n: <span class="hljs-built_in">int</span></span>) -&gt; int:</span><br>    <span class="hljs-keyword">return</span> n ** n<br><br>s_time = time.time()<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n_call):<br>    demo(i)<br>print(time.time() - s_time)<br><br><span class="hljs-comment"># async的调用时长</span><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sub_demo</span>(<span class="hljs-params">n: <span class="hljs-built_in">int</span></span>) -&gt; int:</span><br>    <span class="hljs-keyword">return</span> n ** n<br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">async_main</span>() -&gt; <span class="hljs-keyword">None</span>:</span> <br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n_call):<br>        <span class="hljs-keyword">await</span> sub_demo(i)<br><br>loop = asyncio.get_event_loop()<br>s_time = time.time()<br>loop.run_until_complete(async_main())<br>print(time.time() - s_time)<br><br><span class="hljs-comment"># 输出</span><br><span class="hljs-comment"># 5.310615682601929</span><br><span class="hljs-comment"># 5.614157438278198</span><br></code></pre></td></tr></table></figure>
<p>可以看得出来， <code>sync</code>的语法大家都是很熟悉， 而<code>async</code>的语法比较不一样， 函数需要使用<code>async def</code>开头， 同时调用<code>async def</code>函数需要使用<code>await</code>语法， 运行的时候需要先获取线程的事件循环， 然后在通过事件循环来运行<code>async_main</code>函数来达到一样的效果， 但是从运行结果的输出可以看得出,  <code>sync</code>的语法在这个场景中比<code>async</code>的语法速度快了一些些（由于Python的GIL原因， 这里无法使用多核的性能， 只能以单核来跑）。</p>
<p>造成这样的原因是同样由同一个线程执行的情况下(cpu单核心)，<code>async</code>的调用还需要经过一些事件循环的额外调用， 这会产生一些小开销， 从而运行时间会比<code>sync</code>的慢， 同时这是一个纯cpu运算的示例， 而<code>async</code>的的优势在于网络io运算， 在这个场景无法发挥优势， 但会在高并发场景则会大放光彩, 造成这样的原因则是因为<code>async</code>是以协程运行的， <code>sync</code>是以线程运行的。</p>
<blockquote>
<p>NOTE: 目前所说的<code>async</code>语法都是支持网络io， 而文件系统的异步io还不是非常的完善， 所以文件系统的异步读写是通过封装交给多线程去处理， 而不是协程。<br>具体可见: <a href="https://github.com/python/asyncio/wiki/ThirdParty#filesystem">https://github.com/python/asyncio/wiki/ThirdParty#filesystem</a></p>
</blockquote>
<h2 id="2-一个io的例子"><a href="#2-一个io的例子" class="headerlink" title="2.一个io的例子"></a>2.一个io的例子</h2><p>为了了解<code>async</code>在io场景下的运行优势， 先假定有一个io场景–Web后台服务通常需要处理许多请求， 所有请求都是从不同的客户端发出的， 示例如图：<br><img    class="lazyload" data-original="https://ftp.bmp.ovh/imgs/2021/11/42b835643bb64c94.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">io场景</span></p>
<p>在这种场景下， 客户端请求都是在短时间内发出的。 而服务端为了能够在短时间内处理大量的请求， 防止处理延迟， 都会以某种方式来支持并发或者并行。 </p>
<blockquote>
<p>NOTE: 并发，在操作系统中，是指一个时间段中有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在同一个处理机上运行，但任一个时刻点上只有一个程序在处理机上运行。<br>并行是计算机系统中能同时执行两个或多个处理的一种计算方法。 </p>
</blockquote>
<p>对于<code>sync</code>语法来说， 这个Web后台可以通过进程， 线程或者两者结合来实现， 他们的提供并发/并行的能力会局限于woker的数量， 比如当有5个客户端同时请求而服务端只有4个worker时， 有一个请求会进入阻塞等待阶段, 直到运行的4个worker有一个被处理完毕。 为了让服务器能提供更好的服务， 我们都会提供足够多的worker, 同时由于进程具有良好的隔离性且比较每起一个进程都会占用一份独立的资源， 所以都是以几个进程+大量线程的形式来提供服务。</p>
<blockquote>
<p>NOTE： 进程是最小的资源分配单位, 过多的进程会占用很多系统资源， 一般的后台服务启用的进程数量不会很多， 同时线程是最小的调度单位， 所以以下的调度我都以线程来描述。</p>
</blockquote>
<p>但是这种方式是很耗系统的资源的(相对于协程来说), 因为线程的运行都是靠cpu来执行的， 而cpu是有限的， 同一时刻只能支持固定的几个worker运行, 其他线程则得等待被调度, 这样就意味着每个线程都只能工作一个时间分片， 之后就会被调度系统控制进入阻塞或者就绪阶段， 让位给其他线程， 直到下次获取时间分片时才可以继续运行。 为了能模拟出同一时刻内， 多个线程同时运行， 且防止其他线程饿死的情况， 线程每次获得的运行时间很短， 线程间的调度切换很频繁， 当启用更多的进程和更多的线程时， 调度就会更加的频繁。</p>
<p>不过调度线程的开销还不算大， 比较大的开销是调度线程而产生的下文切换和竞争条件(具体可以参考《计算机导论》中进程调度相关的资料， 我这里只是简单说明)， cpu在执行代码时，它需要把数据加载到cpu的缓存中去的再运行， 当cpu运行的线程在这个时间分片内执行完成时， 该线程的最新运行数据就会保存起来， 然后cpu会去加载准备被调度的线程的数据， 并运行。 虽然这部分暂存数据是保存在比内存更快， 比内存更靠近cpu的寄存器上， 但是寄存器的访问速度也没有cpu缓存的访问速度快， 所以cpu在切换运行的线程时， 都会花上一部分时间用来装载数据上还有装载缓存时的竞争问题。</p>
<p>对比线程的调度产生的上下文切换与抢占式， <code>async</code>语法实现的协程是非抢占式的， 协程的调度是依赖于一个循环来控制， 这个循环是一个非常常高效的任务管理器和调度器,  由于调度的是一段代码的实现逻辑， 所以cpu的执行代码并不用切换， 也就没有上下文切换的开销, 同时， 也不用考虑装载缓存的竞争问题。<br>还是以上面那个图为例子， 在服务开始启动时， 会先启动一个事件循环， 当收到请求时， 它会创建一个任务来处理客户端发送过来的请求， 这个任务会从事件循环获取到了执行权，独占整个线程资源并一直执行， 直到遇到需要等待外部事件， 比如等待数据库返回数据的事件， 这时任务会告诉事件循环自己在等待这个事件， 然后交出执行权， 事件循环就会把执行权传递给最需要运行的任务。 当刚才交出执行权的任务在后续收到数据库事件响应时， 事件循环会把它安排到就绪列表的第一个(不同的事件循环实现可能不一样)并在下一次切换执行权时， 把执行权返回给他, 让他继续执行， 直到遇到下一个等待事件。</p>
<p>这种切换协程的方式称为协作式多任务处理， 由于只会在单个进程或者单个线程中运行， 切换协程时上下文是不用改变的， cpu不用重新读写缓存， 所以会节省一些开销。 从上面可以看出协作式切换执行权是基于协程自己主动让出的, 而线程是抢占式的， 线程在没遇到io事件时， 也可能从运行状态转为就绪状态， 直到再次被调用, 这样会多出很多调度带来的开销, 而协程是会一直运行， 直到遇到让步事件才切换， 所以协程调度的次数会比线程少很多。 同时可以看出协程的何时调度是由开发者指定（比如上面所说的等等数据库返回事件）， 而且是非抢占式的, 这就意味着某个协程在运行时， 其他协程是没办法运行的， 只能等到运行的协程交出执行权， 所以开发者要确保不能让任务在cpu上停留太长时间，否则剩余的任务就会饿死。</p>
<h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3.总结"></a>3.总结</h2><p>在io场景下， io的开销比cpu执行代码逻辑外的开销大很多， 从这里也可以换个想法思考， 在遇到io的开销时， 代码逻辑需要进行等待， 而cpu是空闲的， 于是就通过协程/线程的方式对于cpu的多路复用， 压榨cpu。<br>假设<code>sync</code>语法和<code>async</code>语法执行的代码逻辑是一样的， 那么他们执行速度快慢的对比可以转换为协程与多进程/线程的开销对比, 也就是协程事件循环调度开销与多进程/线程的调度的开销逻辑对比， 而事件循环调度的开销是基本不变(或者变化不大)，多进程/线程的开销除了比事件循环调度的开销大外，还会随着worker的量变多而变多， 当并发量高到一定程度时， 多进程/多线程的开销会大于协程切换的开销， 这时<code>async</code>语法的执行速度就会快于<code>sync</code>语法。<br>所以在普通场景下， <code>sync</code>语法的执行速度会快于<code>async</code>语法的执行速度， 但在io计算大于cpu计算且高并发场景下时， <code>async</code>语法的执行速度会比<code>sync</code>语法速度还快。</p>
]]></content>
      <categories>
        <category>Python Asyncio</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Asyncio</tag>
      </tags>
  </entry>
  <entry>
    <title>RPC框架编写实践--优化框架性能流水日记</title>
    <url>/2021/10/29/RPC%E6%A1%86%E6%9E%B6%E7%BC%96%E5%86%99%E5%AE%9E%E8%B7%B5--%E4%BC%98%E5%8C%96%E6%A1%86%E6%9E%B6%E6%80%A7%E8%83%BD%E6%B5%81%E6%B0%B4%E6%97%A5%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="前记"><a href="#前记" class="headerlink" title="前记"></a>前记</h2><p>所有提供服务的框架都需要跑性能测试， 经过性能测试来发现了解服务的qps有多少， 是否有人为的因素导致性能不足以及是否有需要优化的代码。</p>
<p>一般来说，服务框架的性能测试都需要跟同类的框架一起做比较， 我在编写<a href="https://github.com/so1n/rap">rap</a>之前， 用的是<a href="https://github.com/choleraehyq/aiorpc">aiorpc</a>, 所以在设计<a href="https://github.com/so1n/rap">rap</a>时参考了<a href="https://github.com/choleraehyq/aiorpc">aiorpc</a>, 最后进行性能测试的时候也是跟<a href="https://github.com/choleraehyq/aiorpc">aiorpc</a>进行比较。</p>
<p>由于我引入了单连接复用的功能， 所以在预想中我编写的框架性能应该是比<a href="https://github.com/choleraehyq/aiorpc">aiorpc</a>性能好， 可是最后的测试结果却是不如意的， 所以就开始了优化之旅。</p>
<span id="more"></span>

<h2 id="1-性能对比"><a href="#1-性能对比" class="headerlink" title="1.性能对比"></a>1.性能对比</h2><p>在<a href="https://github.com/choleraehyq/aiorpc">aiorpc</a>简介中列出作者对几个相关框架压测的qps数据对比, 如下:</p>
<table>
<thead>
<tr>
<th>aiorpc</th>
<th>Official MesssagePack RPC</th>
<th>ZeroRPC</th>
</tr>
</thead>
<tbody><tr>
<td>2236</td>
<td>3112</td>
<td>352</td>
</tr>
</tbody></table>
<p>可以看到<code>aiorpc</code>比<code>Official MesssagePack RPC</code>性能差一些， 但两者相近， 所以我就以<a href="https://github.com/choleraehyq/aiorpc">aiorpc</a>为模板， 同时复制了他的代码， 在本地一起压测, 压测结果如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># aiorpc的性能数据</span><br><span class="hljs-comment"># aiorpc的压测具体见：https://github.com/choleraehyq/aiorpc/blob/master/benchmarks/benchmark_aiorpc_inet.py</span><br>➜  rap git:(master) ✗ py run python example/benchmark/benchmark_aiorpc.py                                                                <br>call: 12182 qps<br><span class="hljs-comment"># rap的性能数据(忽略代码中的await asyncio.sleep(0.01))</span><br>➜  rap git:(master) ✗ py run python example/benchmark/benchmark_rap.py   <br>call: 1654 qps<br><span class="hljs-comment"># rap单连接复用的性能数据(忽略代码中的await asyncio.sleep(0.01))</span><br>➜  rap git:(master) ✗ py run python example/benchmark/benchmark_rap_by_single_conn_multiplexing.py <br>call: 3898 qps<br></code></pre></td></tr></table></figure>
<p>通过结果可以发现[rap]的性能也太拉跨了， 同样的实现, 同样的原理， 性能却是[aiorpc]的10分之一， 即使用了单连接复用后， 性能也只有[aiorpc]的3分之一, 急需优化， 同时也可以看出有大量的优化空间。 </p>
<h2 id="2-优化性能工具"><a href="#2-优化性能工具" class="headerlink" title="2.优化性能工具"></a>2.优化性能工具</h2><p>性能优化首先要找到瓶颈在什么地方，才能做针对性的优化， 但是函数的调用链非常的长， 我们需要借助一些工具来帮忙剖析调用情况， 在<code>Python</code>生态中， 现有且还有更新的性能剖析方法有官方自带的<a href="https://docs.python.org/2/library/profile.html">cProfile</a>和<a href="https://github.com/joerick/pyinstrument">pyinstrument</a>, 他们都是非侵入式的， 在官方实现的模块能满足我的需求的时候， 我都会优先使用官方的模块, 同时他的数据是最准确的， 所以本次选用的性能剖析工具是<code>cProfile</code>。</p>
<blockquote>
<p>NOTE: 性能剖析工具分为<code>Deterministic profiler</code>和<code>Sampling profiler</code>两大类, cProfile是基于<code>Deterministic Profiling</code>实现的，这类型是通过<a href="https://docs.python.org/3.10/library/sys.html#sys.settrace">sys.settrance</a>在各个调用的函数打点，并在运行时记录所有函数每次的执行状况， 所以开销会比较大, 数据也比较准确。<br>而<code>pyinstrument</code>是通过<code>Sampling profiler</code>实现的， 这类型是调用<code>POSIX Interval timer</code>每隔一段时间中端进程获取整个堆栈信息，以此来估计每个函数的执行时间和开销，性能开销比较小， 但记录可能不会准确。</p>
</blockquote>
<h3 id="2-1-cProfile"><a href="#2-1-cProfile" class="headerlink" title="2.1.cProfile"></a>2.1.cProfile</h3><p><code>cProfile</code>是<code>Python</code>标准库中内置的性能分析模块，基于C的扩展，非侵入式，不需要修改代码。它的使用方法是:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python">python -m cProfile [-s sort_order] main.py<br></code></pre></td></tr></table></figure>
<p>其中<code>-s</code>指定输出的排序方法, 有<code>ncalls</code>, <code>tottime</code>, <code>cumtime</code>几个字段可选,于是我就按照使用方法运行程序， 输出如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python">➜  rap git:(master) ✗ py run python -m cProfile -s cumtime example/benchmark/benchmark_rap_by_single_conn_multiplexing.py<br>call: <span class="hljs-number">2853</span> qps<br>         <span class="hljs-number">2583236</span> function calls (<span class="hljs-number">2569633</span> primitive calls) <span class="hljs-keyword">in</span> <span class="hljs-number">4.668</span> seconds<br><br>   Ordered by: cumulative time<br><br>   ncalls  tottime  percall  cumtime  percall filename:lineno(function)<br>    <span class="hljs-number">319</span>/<span class="hljs-number">1</span>    <span class="hljs-number">0.004</span>    <span class="hljs-number">0.000</span>    <span class="hljs-number">4.682</span>    <span class="hljs-number">4.682</span> &#123;built-<span class="hljs-keyword">in</span> method builtins.<span class="hljs-built_in">exec</span>&#125;<br>        <span class="hljs-number">1</span>    <span class="hljs-number">0.000</span>    <span class="hljs-number">0.000</span>    <span class="hljs-number">4.682</span>    <span class="hljs-number">4.682</span> benchmark_rap_by_single_conn_multiplexing.py:<span class="hljs-number">1</span>(&lt;module&gt;)<br>        <span class="hljs-number">1</span>    <span class="hljs-number">0.000</span>    <span class="hljs-number">0.000</span>    <span class="hljs-number">3.517</span>    <span class="hljs-number">3.517</span> benchmark_rap_by_single_conn_multiplexing.py:<span class="hljs-number">26</span>(run_client)<br>        <span class="hljs-number">3</span>    <span class="hljs-number">1.584</span>    <span class="hljs-number">0.528</span>    <span class="hljs-number">3.516</span>    <span class="hljs-number">1.172</span> &#123;method <span class="hljs-string">&#x27;run_until_complete&#x27;</span> of <span class="hljs-string">&#x27;uvloop.loop.Loop&#x27;</span> objects&#125;<br>    <span class="hljs-number">29900</span>    <span class="hljs-number">0.019</span>    <span class="hljs-number">0.000</span>    <span class="hljs-number">1.537</span>    <span class="hljs-number">0.000</span> tasks.py:<span class="hljs-number">596</span>(_wrap_awaitable)<br>    <span class="hljs-number">29900</span>    <span class="hljs-number">0.039</span>    <span class="hljs-number">0.000</span>    <span class="hljs-number">1.501</span>    <span class="hljs-number">0.000</span> core.py:<span class="hljs-number">124</span>(wrapper)<br>    <span class="hljs-number">29900</span>    <span class="hljs-number">0.048</span>    <span class="hljs-number">0.000</span>    <span class="hljs-number">1.150</span>    <span class="hljs-number">0.000</span> core.py:<span class="hljs-number">178</span>(raw_invoke)<br>        <span class="hljs-number">1</span>    <span class="hljs-number">1.001</span>    <span class="hljs-number">1.001</span>    <span class="hljs-number">1.001</span>    <span class="hljs-number">1.001</span> &#123;built-<span class="hljs-keyword">in</span> method time.sleep&#125;<br>    <span class="hljs-number">20000</span>    <span class="hljs-number">0.041</span>    <span class="hljs-number">0.000</span>    <span class="hljs-number">0.953</span>    <span class="hljs-number">0.000</span> transport.py:<span class="hljs-number">286</span>(request)<br>    <span class="hljs-number">20008</span>    <span class="hljs-number">0.091</span>    <span class="hljs-number">0.000</span>    <span class="hljs-number">0.864</span>    <span class="hljs-number">0.000</span> transport.py:<span class="hljs-number">237</span>(_base_request)<br>    <span class="hljs-number">20008</span>    <span class="hljs-number">0.026</span>    <span class="hljs-number">0.000</span>    <span class="hljs-number">0.361</span>    <span class="hljs-number">0.000</span> asyncio_helper.py:<span class="hljs-number">61</span>(as_first_completed)<br>       <span class="hljs-number">28</span>    <span class="hljs-number">0.000</span>    <span class="hljs-number">0.000</span>    <span class="hljs-number">0.345</span>    <span class="hljs-number">0.012</span> __init__.py:<span class="hljs-number">1</span>(&lt;module&gt;)<br>    <span class="hljs-number">20010</span>    <span class="hljs-number">0.113</span>    <span class="hljs-number">0.000</span>    <span class="hljs-number">0.331</span>    <span class="hljs-number">0.000</span> tasks.py:<span class="hljs-number">335</span>(wait)<br>    <span class="hljs-number">10005</span>    <span class="hljs-number">0.047</span>    <span class="hljs-number">0.000</span>    <span class="hljs-number">0.305</span>    <span class="hljs-number">0.000</span> transport.py:<span class="hljs-number">267</span>(write_to_conn)<br>    <span class="hljs-number">10000</span>    <span class="hljs-number">0.032</span>    <span class="hljs-number">0.000</span>    <span class="hljs-number">0.281</span>    <span class="hljs-number">0.000</span> utils.py:<span class="hljs-number">121</span>(param_handle)<br>      <span class="hljs-number">277</span>    <span class="hljs-number">0.010</span>    <span class="hljs-number">0.000</span>    <span class="hljs-number">0.222</span>    <span class="hljs-number">0.001</span> base.py:<span class="hljs-number">114</span>(_listen_conn)<br>    <span class="hljs-number">10282</span>    <span class="hljs-number">0.031</span>    <span class="hljs-number">0.000</span>    <span class="hljs-number">0.198</span>    <span class="hljs-number">0.000</span> transport.py:<span class="hljs-number">93</span>(dispatch_resp_from_conn)<br>...<br>...<br>...<br></code></pre></td></tr></table></figure>
<p>这段输出会显示很多数据， 每个字段都有不同的含义：</p>
<ul>
<li>ncalls:每个函数被调用次数</li>
<li>tottime:表示该函数本身的执行时间，不包括该函数调用的子函数</li>
<li>cumtime:表示该函数累计执行时间，包括该函数调用的子函数</li>
<li>percall: 第一个<code>percall</code>表示 <code>tottime/ncalls</code>, 第二个<code>percall</code>表示<code>cumtime/primitive calls</code>，<code>primitive calls</code>表示除去递归后本函数被调用次数。</li>
</ul>
<p>虽然输出很详细， 但是这样看数据排查问题也太废眼睛了， 我看没几分钟就开始受不了， 也觉得麻烦。</p>
<h3 id="2-2-火焰图"><a href="#2-2-火焰图" class="headerlink" title="2.2.火焰图"></a>2.2.火焰图</h3><p><code>cProfile</code>输出了很多内容， 但是很难从终端输出直观的看出主要是开销是哪些函数， 这时就需要一些Gui工具来帮忙快速发现问题函数了。</p>
<p>工具<a href="https://github.com/baverman/flameprof">flameprof</a>可以通过解析<code>cProfile</code>生成的prof文件来生成火焰图, 火焰图能直观的反应函数的调用关系与调用时长， 使用命令如下： </p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python">python -m cProfile -o demo.prof main.py<br>flameprof demo.prof &gt; demo.svg<br></code></pre></td></tr></table></figure>
<p>于是我调用命令生成火焰图：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python">python -m cProfile  -o aaa.prof example/benchmark/benchmark_rap_by_single_conn_multiplexing.py<br>flameprof aaa.prof aaa.svg<br></code></pre></td></tr></table></figure>
<p><img   class="lazyload" data-original="https://ftp.bmp.ovh/imgs/2021/10/3bc7c2767f1a5ef8.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" ><br>这个火焰图分为上下两部分， 上部的图是按照函数调用栈和执行时间排列。下部反方向的图按照函数执行时间比例从大到小排列。上部的图中<code>run_client</code>是最顶层的函数，往上是它调用的子函数，直到调用链最底层的函数。宽度表示每个函数的执行时间占用的比例，越宽表示越耗时。 可以看出来火焰图比<code>cProfile</code>直观一些, 可视化有助于我们快速发现问题函数， 但是这种火焰图只局限于展示， 没有提供更多的操作， 当调用层级较高时（也就是火焰图最上面的调用数据展示）， 上面的函数就很难一下子看懂了, 在经过一番搜索后发现了<a href="https://jiffyclub.github.io/snakeviz/">snakeviz</a>， 它基于prof文件生成一个火焰图页面， 使用者可以在火焰图页面做一些交互操作， 更容易发现问题函数。</p>
<h2 id="3-分析问题"><a href="#3-分析问题" class="headerlink" title="3.分析问题"></a>3.分析问题</h2><p>工具搞定了， 就可以开始分析问题了， 首先看<a href="https://github.com/so1n/rap">aiorpc</a>的运行火焰图:<br><img    class="lazyload" data-original="https://ftp.bmp.ovh/imgs/2021/10/84e19d3b27bae5b8.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">aiorpc火焰图</span><br>结合代码发现它的主要调用方法<code>call</code>只用了0.394秒, 而我的框架的主要调用火焰图如下:<br><img    class="lazyload" data-original="https://ftp.bmp.ovh/imgs/2021/10/ebcfa7225df6d373.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">rap火焰图</span><br>主要调用方法<code>core.py:122(wrapper)</code>方法用了1.43s,是<a href="https://github.com/so1n/rap">aiorpc</a>的三倍， 其中参数调用方法<code>param_handle</code>耗时为0.53，请求方法<code>raw_invoke</code>耗时0.82, 这时候想要往下看<code>param_handle</code>会发现展示区域太小了， 可以点击<code>param_handle</code>块，然后就会跳转到以<code>param_handle</code>为顶层的页面，展示的数据更多了:<br><img    class="lazyload" data-original="https://ftp.bmp.ovh/imgs/2021/10/1d727c65ed4a423a.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">rap param_handle火焰图</span></p>
<p>通过火焰图可以发现，<code>param_handle</code>的火焰图中包含大量的<code>inspect</code>模块的相关使用以及<code>check_func_type</code>函数, 所以他们的运行性能会影响到<code>param_handle</code>的运行性能, 其中<code>inspect.signature</code>最耗时间, 这时需要从源码进行分析， 它们的代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">check_func_type</span>(<span class="hljs-params">func: Callable, param_list: Sequence[Any], default_param_dict: Dict[<span class="hljs-built_in">str</span>, Any]</span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>    <span class="hljs-string">&quot;&quot;&quot;Check whether the input parameter type is consistent with the function parameter type&quot;&quot;&quot;</span><br>    func_sig: inspect.Signature = inspect.signature(func)<br>    <span class="hljs-keyword">for</span> index, parameter_tuple <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(func_sig.parameters.items()):<br>        name, parameter = parameter_tuple<br>        <span class="hljs-keyword">if</span> parameter.default <span class="hljs-keyword">is</span> parameter.empty:<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> is_type(<span class="hljs-built_in">type</span>(param_list[index]), parameter.annotation):<br>                <span class="hljs-keyword">raise</span> TypeError(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;param_list[index]&#125;</span> type must: <span class="hljs-subst">&#123;parameter.annotation&#125;</span>&quot;</span>)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> is_type(<span class="hljs-built_in">type</span>(default_param_dict.get(name, parameter.default)), parameter.annotation):<br>                <span class="hljs-keyword">raise</span> TypeError(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;default_param_dict[name]&#125;</span> type must: <span class="hljs-subst">&#123;parameter.annotation&#125;</span>&quot;</span>)<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">param_handle</span>(<span class="hljs-params">func: Callable, param_list: Sequence[Any], default_param_dict: Dict[<span class="hljs-built_in">str</span>, Any]</span>) -&gt; Tuple[Any, ...]:</span><br>    <span class="hljs-string">&quot;&quot;&quot;Check whether the parameter is legal and whether the parameter type is correct&quot;&quot;&quot;</span><br>    new_param_list: Tuple[Any, ...] = inspect.signature(func).bind(*param_list, **default_param_dict).args<br>    check_func_type(func, param_list, default_param_dict)<br>    <span class="hljs-keyword">return</span> new_param_list<br></code></pre></td></tr></table></figure>
<p>通过代码可以发现<code>inspect.signature</code>的所在位置, 它的功能是用于生成函数签名， 但是函数签名这个东西是不会变动的， 同时调用端基本上都使用了<code>Python</code>的装饰器， 在启动的时候就可以生成函数签名了， 所以这个函数可以逻辑可以改为只接收<code>inspect.Signature</code>对象， 减少重复生成开销, 修改后如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">check_func_type</span>(<span class="hljs-params">func_sig: inspect.Signature, param_list: Sequence[Any], default_param_dict: Dict[<span class="hljs-built_in">str</span>, Any]</span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>    <span class="hljs-string">&quot;&quot;&quot;Check whether the input parameter type is consistent with the function parameter type&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">for</span> index, parameter_tuple <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(func_sig.parameters.items()):<br>        name, parameter = parameter_tuple<br>        <span class="hljs-keyword">if</span> parameter.default <span class="hljs-keyword">is</span> parameter.empty:<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> is_type(<span class="hljs-built_in">type</span>(param_list[index]), parameter.annotation):<br>                <span class="hljs-keyword">raise</span> TypeError(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;param_list[index]&#125;</span> type must: <span class="hljs-subst">&#123;parameter.annotation&#125;</span>&quot;</span>)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> is_type(<span class="hljs-built_in">type</span>(default_param_dict.get(name, parameter.default)), parameter.annotation):<br>                <span class="hljs-keyword">raise</span> TypeError(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;default_param_dict[name]&#125;</span> type must: <span class="hljs-subst">&#123;parameter.annotation&#125;</span>&quot;</span>)<br><br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">param_handle</span>(<span class="hljs-params">func_sig: inspect.Signature, param_list: Sequence[Any], default_param_dict: Dict[<span class="hljs-built_in">str</span>, Any]</span>) -&gt; Tuple[Any, ...]:</span><br>    <span class="hljs-string">&quot;&quot;&quot;Check whether the parameter is legal and whether the parameter type is correct&quot;&quot;&quot;</span><br>    new_param_list: Tuple[Any, ...] = func_sig.bind(*param_list, **default_param_dict).args<br>    check_func_type(func_sig, param_list, default_param_dict)<br>    <span class="hljs-keyword">return</span> new_param_list<br></code></pre></td></tr></table></figure>
<p>其次就是<code>check_func_type</code>这个函数了， 里面都是我自己通过<code>debug</code>慢慢调试出来写的校验参数的代码， 没多少优化空间了， 只能转战下一个地方， 现在点击右上角的<code>Call  Stack</code>选择回到一开始的界面， 重新选择请求流程的另外一块<code>raw_invoke</code>:<br><img   class="lazyload" data-original="https://ftp.bmp.ovh/imgs/2021/10/9a85fc9a8037a2d8.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" ></p>
<p>通过火焰图可以看到，请求流程<code>raw_invoke</code>的总耗时0.857秒, 其中主要占用为<code>request</code>的0.675耗时， 其他没显示出来的具体是选择连接<code>pick</code>(0.07s), 信号量封装(共计0.05s)， 这两个基本上没有多少优化的空间了， 除非是不需要健全的服务调用功能。</p>
<p>所以我的排查重点来到了<code>transport.py</code>的<code>_base_request</code>调用, 其中蓝色箭头所指的是获取雪花id的函数调用<code>async_get_snowflake_id</code>：<br><img   class="lazyload" data-original="https://ftp.bmp.ovh/imgs/2021/10/c708d6afce024124.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" ><br>可以发现主要的时间消耗是<code>as_first_completed</code>, <code>write_to_conn</code>和<code>async_get_snowflake_id</code>, <code>_base_request</code>函数， 它们的源代码如下， 可以看到三个函数所处的位置:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_base_request</span>(<span class="hljs-params">self, request: Request, conn: Connection</span>) -&gt; Response:</span><br>    <span class="hljs-string">&quot;&quot;&quot;Send data to the server and get the response from the server.</span><br><span class="hljs-string">    :param request: client request obj</span><br><span class="hljs-string">    :param conn: client conn</span><br><span class="hljs-string"></span><br><span class="hljs-string">    :return: return server response</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-comment"># 函数1</span><br>    request.correlation_id = <span class="hljs-built_in">str</span>(<span class="hljs-keyword">await</span> async_get_snowflake_id())<br>    resp_future_id: <span class="hljs-built_in">str</span> = <span class="hljs-string">f&quot;<span class="hljs-subst">&#123;conn.sock_tuple&#125;</span>:<span class="hljs-subst">&#123;request.correlation_id&#125;</span>&quot;</span><br>    <span class="hljs-keyword">try</span>:<br>        response_future: asyncio.Future[Response] = asyncio.Future()<br>        self._resp_future_dict[resp_future_id] = response_future<br>        deadline: Optional[Deadline] = deadline_context.get()<br>        <span class="hljs-keyword">if</span> self.app.through_deadline <span class="hljs-keyword">and</span> deadline:<br>            request.header[<span class="hljs-string">&quot;X-rap-deadline&quot;</span>] = deadline.end_timestamp<br>        <span class="hljs-comment"># 函数2</span><br>        <span class="hljs-keyword">await</span> self.write_to_conn(request, conn)<br>        <span class="hljs-comment"># 函数3</span><br>        response: Response = <span class="hljs-keyword">await</span> as_first_completed(<br>            [response_future],<br>            not_cancel_future_list=[conn.conn_future],<br>        )<br>        response.state = request.state<br>        <span class="hljs-keyword">return</span> response<br>    <span class="hljs-keyword">finally</span>:<br>        pop_future: Optional[asyncio.Future] = self._resp_future_dict.pop(resp_future_id, <span class="hljs-literal">None</span>)<br>        <span class="hljs-keyword">if</span> pop_future:<br>            safe_del_future(pop_future)<br></code></pre></td></tr></table></figure>
<p>从函数开头开始分析， 首先有个获取<code>correlation_id</code>的函数<code>async_get_snowflake_id</code>, 本来想进行优化的， 后面发现下面的uuid4获取耗时比它还差一点点， 对比后就不想优化了。然后是<code>write_to_conn</code>, 它的主要耗时在序列化， 等待连接drain，打印日志等等, 大部分都是内置函数， 很难再优化下去的， 最后的<code>as_first_completed</code>函数也是一些系统调用，没多少优化机会， 都是应有的流程， 这时我开始怀疑是我排查路径出现问题，于是我就重新对比两个调用过程：<br>|类别|rap|aiorpc|<br>|—|—|—|<br>|调用图|<img    class="lazyload" data-original="https://ftp.bmp.ovh/imgs/2021/10/065f6d33eee6ddbc.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">rpc调用图</span> |<img    class="lazyload" data-original="https://ftp.bmp.ovh/imgs/2021/10/950d63d5592edeaf.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">aiorpc请求调用图</span> |<br>|发送时长|0.2333s|0.146s|<br>|接收时长|0.235s|0.153s|</p>
<p>从表格的数据和图可以发现我实现的框架无论是发送时长还是接收时长，都会比<code>aiorpc</code>长一些， 在经过梳理后发现这些影响时长的调用大部分都是为了增加一些可用性等功能才添加的， 拆分为一小块一小块的分析时发现问题也不大， 这时我就十分纳闷了， 按道理我单连接复用会比没复用的快很多啊， 怎么跑出来的结果不仅不一样， 还慢很多呢？ 于是我重新查看火焰图， 看到<code>aiorpc</code>火焰图client.py:69(call)的时间也就是请求消耗时间为0.394， 而<code>rap</code>同为请求的火焰图块core.py:112(wrapper)显示的时间为1.43s， 他们的差距大概在3倍左右， 与压测跑的qps相差倍数是一样的, 我猜想这个压测代码的主要耗时都是函数调用耗时， 而io耗时占比非常的少。 于是我重新看了压测代码， 这时才发现， server的调用代码是纯cpu计算， 没有io耗时的相关代码, 代码如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run_server</span>() -&gt; <span class="hljs-keyword">None</span>:</span><br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_sum</span>(<span class="hljs-params">a: <span class="hljs-built_in">int</span>, b: <span class="hljs-built_in">int</span></span>) -&gt; int:</span><br>        <span class="hljs-keyword">return</span> a + b<br><br>    loop: asyncio.AbstractEventLoop = uvloop.new_event_loop()<br>    asyncio.set_event_loop(loop)<br>    rpc_server: Server = Server(<span class="hljs-string">&quot;example&quot;</span>)<br>    rpc_server.register(test_sum)<br>    loop.run_until_complete(rpc_server.run_forever())<br></code></pre></td></tr></table></figure>
<p>这段代码没有任何io耗时， 本质上框架io相关的代码也不多， 同时是在本地压测， 网络数据没有经过拆解包和路由跳转等， 网络io相关的也不多， 这时client与server的调用就像本地间的函数调用一样, 基本上无须等待网络io, 主要耗时都是在函数的封装调用上， 所以单路复用的优势并没有体现出来。<br>于是， 我都给他们的服务器执行函数增加一个模拟的io操作， 休眠0.01秒：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run_server</span>() -&gt; <span class="hljs-keyword">None</span>:</span><br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_sum</span>(<span class="hljs-params">a: <span class="hljs-built_in">int</span>, b: <span class="hljs-built_in">int</span></span>) -&gt; int:</span><br>        <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">0.01</span>)<br>        <span class="hljs-keyword">return</span> a + b<br><br>    loop: asyncio.AbstractEventLoop = uvloop.new_event_loop()<br>    asyncio.set_event_loop(loop)<br>    rpc_server: Server = Server(<span class="hljs-string">&quot;example&quot;</span>)<br>    rpc_server.register(test_sum)<br>    loop.run_until_complete(rpc_server.run_forever())<br></code></pre></td></tr></table></figure>
<p>然后重新跑代码， 执行结果如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">➜  rap git:(master) ✗ py run python example/benchmark/benchmark_rap.py<br>call: 92 qps<br>➜  rap git:(master) ✗ py run python example/benchmark/benchmark_aiorpc.py <br>call: 95 qps<br>➜  rap git:(master) ✗ py run python example/benchmark/benchmark_rap_by_single_conn_multiplexing.py <br>call: 4265 qps<br></code></pre></td></tr></table></figure>
<p>这时可以明显的看出来， <code>aiorpc</code>与的<code>rap</code>框架的qps都很低， 在90左右， 而<code>rap</code>的单连接复用版本的qps基本上不变。</p>
<h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3.总结"></a>3.总结</h2><p>本次简单学习和运用了性能分析优化， 但是整个框架的主体优化不多， 可能是运行的压测代码覆盖范围不够。 不过倒是学习了一个重要的点， 就是压测的代码要尽量的去模拟真实的环境， 大多数<code>Hello World</code>级别的压测代码很难去反应真实的数据结果， 同时在挑选框架时， 不要只看看文章介绍的性能对比， 也要去了解下压测代码， 看他的实现是否符合真实环境， 压测的结果是否有价值。</p>
<blockquote>
<p>NOTE: 在Python的Asyncio生态中， 曾经有一段时间有大量的Asyncio Web框架出现， 他们的压测结果都是十分的美好， 但是都是<code>Hello World</code>级别的压测代码， 所以很多人都不认可这些框架， 当然这些框架也就慢慢的沉没在历史的大海里。</p>
</blockquote>
]]></content>
      <categories>
        <category>RPC框架编写实践</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>RPC</tag>
      </tags>
  </entry>
  <entry>
    <title>RPC框架编写实践--超时与超时传递</title>
    <url>/2021/10/22/RPC%E6%A1%86%E6%9E%B6%E7%BC%96%E5%86%99%E5%AE%9E%E8%B7%B5--%E8%B6%85%E6%97%B6%E4%B8%8E%E8%B6%85%E6%97%B6%E4%BC%A0%E9%80%92/</url>
    <content><![CDATA[<h2 id="前记"><a href="#前记" class="headerlink" title="前记"></a>前记</h2><p>接触开发以来发现很多连锁故障的场景的一个常用问题都是多端调用时，服务端正在消耗处理的时间过长或者网络传输异常导致服务端无法及时响应， 造成客户端一直等待，无法释放当前请求响应导致的， 而这种方法可以通过超时机制来进行解决。</p>
<p>超时机制， 是一个简单又方便的控制网络请求异常的一种方法， 它可以保证服务稳定(本质是快速失败)， 良好的超时控制策略可以尽快的释放高延迟的请求，避免请求堆积, 而设计不合理的超时会导致整个服务架构出问题。</p>
<span id="more"></span>

<h2 id="1-常见超时机制的弊端"><a href="#1-常见超时机制的弊端" class="headerlink" title="1.常见超时机制的弊端"></a>1.常见超时机制的弊端</h2><p>编写的服务端代码是不可能一直不会失败的， 因为它会进行网络通信， 而这个网络世界并不是完美的。 常见的客户端在进行网络请求的时候都会有一个超时机制， 以<code>Python</code>中一个著名的请求库<code>httpx</code>为例子, 它比常用的<code>requests</code>更优秀, 也支持通过timeout实现超时机制， 在使用时如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-comment"># 使用get方法请求， 超时时间为9秒</span><br><span class="hljs-keyword">import</span> asyncio<br><span class="hljs-keyword">import</span> httpx<br><br>asyncio.run(httpx.AsyncClient().get(url=<span class="hljs-string">&quot;http://so1n.me&quot;</span>, timeout=<span class="hljs-number">9</span>))<br></code></pre></td></tr></table></figure>
<p>可以看到这个使用方法非常的简单， 也通俗易懂, 但是这个方法在使用起来会有一个弊端。 假设现在有一个方法<code>demo</code>， 它总的超时时间为9秒, 但是需要请求两次， 如果还是按照原来那么写， 会十分糟糕, 代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> asyncio<br><span class="hljs-keyword">import</span> httpx<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">demo</span>() -&gt; <span class="hljs-keyword">None</span>:</span><br>    <span class="hljs-keyword">await</span> httpx.AsyncClient().get(url=<span class="hljs-string">&quot;http://so1n.me&quot;</span>, timeout=<span class="hljs-number">9</span>)<br>    <span class="hljs-keyword">await</span> httpx.AsyncClient().get(url=<span class="hljs-string">&quot;http://so1n.me&quot;</span>, timeout=<span class="hljs-number">9</span>)<br></code></pre></td></tr></table></figure>
<p>这种情况下假设该方法的每个请求时长为8秒， 那么他的总请求时长为16秒， 已经超出要求的总的超时时长为9秒的要求的, 但每个请求都没有触发超时机制。 可以看出， 超时是简单易懂的， 但是在某些情况下它并不能很好的胜任工作。 </p>
<p>不过在超时无法胜任某些工作时， 我们可以换个思路， 超时的原本意思是， 在n秒后中断此次请求, 也就是在某个时刻时终止请求， 那么代码可以改写如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> asyncio<br><span class="hljs-keyword">import</span> httpx<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">demo</span>(<span class="hljs-params">timeout: <span class="hljs-built_in">int</span> = <span class="hljs-number">9</span></span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>    deadline: <span class="hljs-built_in">float</span> = time.time() + <span class="hljs-number">9</span><br>    <span class="hljs-keyword">await</span> httpx.AsyncClient().get(url=<span class="hljs-string">&quot;http://so1n.me&quot;</span>, timeout=time.time() - deadline)<br>    <span class="hljs-keyword">await</span> httpx.AsyncClient().get(url=<span class="hljs-string">&quot;http://so1n.me&quot;</span>, timeout=time.time() - deadline)<br></code></pre></td></tr></table></figure>
<p>这段代码可以完美的工作， 假设第一个请求的时长为5秒， 那么第二次请求的超时参数的值会是4秒， 这是非常ok， 代码也依然保持简单。 不过目前还是有个缺点， 就是每次都要手写一遍， 然后显示传进去, 这个超时是不可传递的， 如果有一个抽象能方便的使用， 那是非常好的。</p>
<h2 id="2-可传递的超时对象–deadline"><a href="#2-可传递的超时对象–deadline" class="headerlink" title="2.可传递的超时对象–deadline"></a>2.可传递的超时对象–deadline</h2><p>从上面的例子可以看出， 我们正真需要的是在某片代码范围内(如上面就是在一个<code>demo</code>函数里面)， 所有的函数调用共享一个截止时间， 当抵达截止时间时， 无论执行到那个函数调用， 都会触发超时异常。 通常如果要管理一个代码范围， 通常都是写一个函数调用， 并在外部使用超时控制， 代码则变成如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> asyncio<br><span class="hljs-keyword">import</span> httpx<br><span class="hljs-keyword">import</span> time<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sub_demo</span>() -&gt; <span class="hljs-keyword">None</span>:</span><br>    <span class="hljs-keyword">await</span> httpx.AsyncClient().get(url=<span class="hljs-string">&quot;http://so1n.me&quot;</span>)<br>    <span class="hljs-keyword">await</span> httpx.AsyncClient().get(url=<span class="hljs-string">&quot;http://so1n.me&quot;</span>)<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">demo</span>() -&gt; <span class="hljs-keyword">None</span>:</span><br>    <span class="hljs-keyword">await</span> asyncio.wait_for(sub_demo(), timeout=<span class="hljs-number">9</span>)<br><br><br>asyncio.run(demo())<br></code></pre></td></tr></table></figure>
<p>但是， 这样的实现总觉得会差点意思， 每有一个共享截止时间的代码范围， 就需要写一个函数出来, 会觉得写出来的代码不是特别的优雅， 同时如果需要传的参数比较多， 那简直就是灾难了。好在<code>Python</code>提供了<code>with</code>语句， 凡是在<code>with</code>语句裹着的， 都属于该代码范围里面， 所以一个deadline抽象的使用会变为如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-comment"># 伪代码</span><br><span class="hljs-keyword">import</span> asyncio<br><span class="hljs-keyword">import</span> httpx<br><span class="hljs-keyword">import</span> time<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">demo</span>(<span class="hljs-params">timeout: <span class="hljs-built_in">int</span> = <span class="hljs-number">9</span></span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>    <span class="hljs-keyword">with</span> Deadline(timeout=<span class="hljs-number">9</span>):<br>        <span class="hljs-keyword">await</span> httpx.AsyncClient().get(url=<span class="hljs-string">&quot;http://so1n.me&quot;</span>)<br>        <span class="hljs-keyword">await</span> httpx.AsyncClient().get(url=<span class="hljs-string">&quot;http://so1n.me&quot;</span>)<br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">bad_demo</span>(<span class="hljs-params">timeout: <span class="hljs-built_in">int</span> = <span class="hljs-number">9</span></span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>    <span class="hljs-keyword">with</span> Deadline(timeout=<span class="hljs-number">9</span>) <span class="hljs-keyword">as</span> d:<br>        <span class="hljs-keyword">await</span> httpx.AsyncClient().get(url=<span class="hljs-string">&quot;http://so1n.me&quot;</span>, timeout=d.timeout)<br>        <span class="hljs-keyword">await</span> httpx.AsyncClient().get(url=<span class="hljs-string">&quot;http://so1n.me&quot;</span>, timeout=d.timeout)<br></code></pre></td></tr></table></figure>
<p>可以看到请求的<code>get</code>调用能享用到<code>demo</code>作用域下的所有参数， 但是<code>bad_demo</code>的实现还是回到一开始的每次调用都要传参的问题。可以看到<code>demo</code>非常的优雅， 实现也非常方便， 只是这里<code>deadline</code>与get调用是没有任何交互的， 不清楚它是如何去终止这些超时请求， 也就是超时的机制变为隐形了。</p>
<p>在经过查阅资料后， 发现了<code>Python</code>协程的两个方法：<br>-1.在<code>event loop</code>运行中可以通过<code>asyncio.current_task</code>来获取当前正在运行的协程。<br>-2.在对某个协程发起<code>cancel</code>时， 会递归到该协程的正在运行的子协程， 然后抛出<code>Cancel</code>的错误（认为<code>demo</code>是<code>with</code>捕获的协程， 两次请求是<code>demo</code>的子协程）</p>
<p>那么可以在通过<code>with</code>语句捕获当前的协程， 并存放在对应的内存区域中， 并启动通知<code>event loop</code>在n秒后执行取消捕获的协程， 然后就把控制权转给使用者。 这样当使用者的代码在指定时间内没完成时， 就会马上抛出超时异常， 以下是我的<code>Deadline</code>的抽象实现：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-comment"># 这是一个简化版本的伪代码, 存在一些逻辑漏洞, 但是都包含了主要流程了，</span><br><span class="hljs-comment"># 完整版见：https://github.com/so1n/rap/blob/master/rap/common/asyncio_helper.py</span><br><span class="hljs-comment"># 中的Deadline方法</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Deadline</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">        self,</span></span><br><span class="hljs-function"><span class="hljs-params">        delay: Optional[<span class="hljs-built_in">float</span>],</span></span><br><span class="hljs-function"><span class="hljs-params">        loop: Optional[asyncio.AbstractEventLoop] = <span class="hljs-literal">None</span>,</span></span><br><span class="hljs-function"><span class="hljs-params">        timeout_exc: Optional[Exception] = <span class="hljs-literal">None</span>,</span></span><br><span class="hljs-function"><span class="hljs-params">    </span>):</span><br>        <span class="hljs-comment"># 代表多少秒后超时</span><br>        self._delay: Optional[<span class="hljs-built_in">float</span>] = delay<br>        <span class="hljs-comment"># asyncio需要的事件循环</span><br>        self._loop = loop <span class="hljs-keyword">or</span> get_event_loop()<br>        <span class="hljs-comment"># 当超时时，如何抛异常</span><br>        self._timeout_exc: Exception = timeout_exc <span class="hljs-keyword">or</span> asyncio.TimeoutError()<br><br>        <span class="hljs-comment"># 是否进入with语境</span><br>        self._is_active: <span class="hljs-built_in">bool</span> = <span class="hljs-literal">False</span><br>        <span class="hljs-comment"># 控制结束的future</span><br>        self._deadline_future: asyncio.Future = asyncio.Future()<br>        <span class="hljs-comment"># 注册with语句捕获的future</span><br>        self._with_scope_future: Optional[asyncio.Future] = <span class="hljs-literal">None</span> <br>        <span class="hljs-keyword">if</span> self._delay <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-comment"># 计算截止时间和注册截止时间回调</span><br>            self._end_timestamp: Optional[<span class="hljs-built_in">float</span>] = time.time() + self._delay<br>            self._end_loop_time: Optional[<span class="hljs-built_in">float</span>] = self._loop.time() + self._delay<br>            <span class="hljs-comment"># 通知event loop在截止时间执行超时机制</span><br>            self._loop.call_at(self._end_loop_time, self._set_deadline_future_result)<br>        <span class="hljs-keyword">else</span>:<br>            self._end_timestamp = <span class="hljs-literal">None</span><br>            self._end_loop_time = <span class="hljs-literal">None</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_set_deadline_future_result</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        <span class="hljs-comment"># 当到截止时间时， 设置执行结束， 并对还在执行的with future进行cancel操作</span><br>        self._deadline_future.set_result(<span class="hljs-literal">True</span>)<br>        <span class="hljs-keyword">if</span> self._with_scope_future <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> self._with_scope_future.cancelled():<br>            self._with_scope_future.cancel()<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__enter__</span>(<span class="hljs-params">self</span>) -&gt; &quot;Deadline&quot;:</span><br>        <span class="hljs-comment"># 进入with语句范围</span><br>        <span class="hljs-keyword">if</span> self._with_scope_future:<br>            <span class="hljs-comment"># 一个实例同时只能调用一次， 多次调用会出错</span><br>            <span class="hljs-keyword">raise</span> RuntimeError(<span class="hljs-string">&quot;`with` can only be called once&quot;</span>)<br>        <span class="hljs-keyword">if</span> self._delay <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-comment"># 启动了超时机制</span><br><br>            <span class="hljs-comment"># 获取当前运行的协程</span><br>            main_task: Optional[asyncio.Task] = current_task(self._loop)<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> main_task:<br>                <span class="hljs-keyword">raise</span> RuntimeError(<span class="hljs-string">&quot;Can not found current task&quot;</span>)<br>            <span class="hljs-comment"># 注册with语句所在的future</span><br>            self._with_scope_future = main_task<br>        <span class="hljs-keyword">return</span> self<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__exit__</span>(<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">        self,</span></span><br><span class="hljs-function"><span class="hljs-params">        exc_type: Optional[Type[BaseException]],</span></span><br><span class="hljs-function"><span class="hljs-params">        exc_val: Optional[BaseException],</span></span><br><span class="hljs-function"><span class="hljs-params">        exc_tb: Optional[TracebackType],</span></span><br><span class="hljs-function"><span class="hljs-params">    </span>) -&gt; Optional[bool]:</span><br>        <span class="hljs-comment"># 由于执行完成或者是异常退出with语句范围</span><br>        <span class="hljs-keyword">if</span> self._with_scope_future:<br>            self._with_scope_future = <span class="hljs-literal">None</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br><br>        <span class="hljs-keyword">if</span> self._deadline_future.done():<br>            <span class="hljs-comment"># 如果控制结束的future已经结束， 代表此次with语句范围的代码执行超时了</span><br>            <span class="hljs-keyword">if</span> exc_type:<br>                <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(self._timeout_exc, IgnoreDeadlineTimeoutExc):<br>                    <span class="hljs-comment"># 如果初始化时声明忽略异常， 那么在退出with语句范围时不会抛出异常</span><br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>            <span class="hljs-comment"># 捕获到异常了， 准备退出...</span><br>            <span class="hljs-keyword">raise</span> self._timeout_exc<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br></code></pre></td></tr></table></figure>
<p>可以看到， <code>Deadline</code>的实现十分简单， 但是还会遇到层层调用传递的情况， 如果觉得显示传递的很烦的话， 还可以使用<code>contextvars</code>模块进行封装从而可以隐式调用, 只需要改造<code>__enter__</code>和<code>__exit__</code>方法即可, 具体看完整版代码。</p>
<blockquote>
<p>Note: <code>contextvars</code>模块使用具体见<a href="https://so1n.me/2019/06/13/contextvars%E6%A8%A1%E5%9D%97/">如何使用contextvars模块和源码分析</a></p>
</blockquote>
<h3 id="3-服务间的传递"><a href="#3-服务间的传递" class="headerlink" title="3.服务间的传递"></a>3.服务间的传递</h3><p>到了微服务时， 超时的影响更加严重， 因为在微服务架构里面， 一次请求可能要经过一个很长的链路，跨多个服务调用后才能返回结果， 如果能提前触发超时机制的话， 则可以省下一些不必要的后续调用, 减少机器的计算和网络开销， 防止服务雪崩等问题。<br>但是超时用不好时， 也会带来一些副作用， 我在编写<code>rap</code>框架时， 为了支持更快的请求和<code>channel</code>双通道机制， 使用了单连接复用的思路， 客户端在发送请求抵达服务端请求后， 就一直在等待服务端返回数据， 当服务端超时返回数据时， 客户端会对本次请求抛出超时异常， 但是不会关闭连接, 客户端伪代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-comment"># 伪代码</span><br><span class="hljs-comment"># 确定好传输的为 id, header, body</span><br><span class="hljs-comment"># 响应体传输的为 id, header, status_code, body</span><br><span class="hljs-comment"># 两者的id用来识别属于哪个请求</span><br><span class="hljs-comment"># 只要确保每个请求有不一样的id就可以实现了连接复用了</span><br><br><span class="hljs-comment"># 首先有个dict用于存放已经发送请求,但没收到响应的future(asyncio.Future())</span><br>future_dict = <span class="hljs-built_in">dict</span>()<br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">response</span>():</span><br>    <span class="hljs-comment"># 统一处理响应, 会有一个程序让他后台运行</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    	<span class="hljs-keyword">try</span>:<br>    		<span class="hljs-comment"># 按照协议从连接取出响应数据</span><br>    	    msg_id, header, status_code, body = <span class="hljs-keyword">await</span> conn.read() <br>    	<span class="hljs-keyword">except</span> ValueError:<br>    	    <span class="hljs-keyword">return</span><br>    	<span class="hljs-comment"># 把结果存入future中,这样request就能收到响应了</span><br>        <span class="hljs-keyword">if</span> msg_id <span class="hljs-keyword">in</span> future_dict:<br>    		future_dict[msg_id].set_result(Response(msg_id, header, status_code, body))<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">request</span>():</span><br>    <span class="hljs-comment"># 请求体</span><br>    request = (msg_id, header, body)<br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-comment"># 设置等待响应的future</span><br>        future_dict[msg_id] = asyncio.Future()<br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-comment"># 表示通过连接conn发送请求</span><br>            <span class="hljs-keyword">await</span> conn.write(request)<br>        <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>            <span class="hljs-keyword">raise</span> e<br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-comment"># 等待响应,超过9秒没响应则报请求超时</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> asyncio.wait_for(future_dict[msg_id], <span class="hljs-number">9</span>)<br>        <span class="hljs-keyword">except</span> asyncio.TimeoutError:<br>            <span class="hljs-keyword">raise</span> asyncio.TimeoutError(<span class="hljs-string">f&quot;msg_id:<span class="hljs-subst">&#123;msg_id&#125;</span> request timeout&quot;</span>)<br>    <span class="hljs-keyword">finally</span>:<br>        <span class="hljs-comment"># 删除future, 回收资源</span><br>        future_dict.pop(msg_id, <span class="hljs-literal">None</span>)<br></code></pre></td></tr></table></figure>
<p>可以发现在这种情况会忽略几个问题：</p>
<ul>
<li>1.客户端已经丢弃请求了， 但服务端可能还在处理数据， 并在完成的时候返回数据， 但是这时候服务端返回的数据会被客户端丢弃的。 </li>
<li>2.如果客户端带有重试机制， 那么客户端会继续发送请求，此时服务端除了会同时多处理多个问题外， 在接口没做幂等性处理时还会出现脏数据的问题。</li>
<li>3.如果客户端带有重试机制， 客户端会发送多个请求到服务端，服务端的压力会变大， 导致整个服务链路异常进而造成服务雪崩。 </li>
</ul>
<p>可以发现， 客户端在这种情况下发生超时时， 除了自己抛异常外， 还要通知服务端进行超时处理， 而不是让服务端继续处理下去， 从而影响服务端性能， 但是通知服务端超时的请求也可能发生异常导致通知失败， 也会占用部分网络资源， 所以最好的方法是把截止时间跟随请求传到服务端(如果是一个超时参数， 则传递参数后， 服务端无法知道真实所剩的超时时间)， 服务端通过截止时间来判断何时结束这个调用, 这种方法很简单， 在<code>rap</code>中就是这样处理的, 首先是客户端：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_base_request</span>(<span class="hljs-params">self, request: Request, conn: Connection</span>) -&gt; Response:</span><br>    <span class="hljs-comment"># 生成请求id</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> request.correlation_id:<br>        request.correlation_id = <span class="hljs-built_in">str</span>(async_get_snowflake_id())<br>    resp_future_id: <span class="hljs-built_in">str</span> = <span class="hljs-string">f&quot;<span class="hljs-subst">&#123;conn.sock_tuple&#125;</span>:<span class="hljs-subst">&#123;request.correlation_id&#125;</span>&quot;</span><br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-comment"># 注册一个等待响应的future</span><br>        response_future: asyncio.Future[Response] = asyncio.Future()<br>        self._resp_future_dict[resp_future_id] = response_future<br><br>        <span class="hljs-comment"># 通过asyncio的context获取到当前的Deadline对象</span><br>        deadline: Optional[Deadline] = deadline_context.get()<br>        <span class="hljs-keyword">if</span> self.app.through_deadline <span class="hljs-keyword">and</span> deadline:<br>            <span class="hljs-comment"># 把Deadline对象的截止时间end_timestamp放在名为X-rap-deadline的Header字段中</span><br>            request.header[<span class="hljs-string">&quot;X-rap-deadline&quot;</span>] = deadline.end_timestamp<br>        <span class="hljs-comment"># 发送请求</span><br>        <span class="hljs-keyword">await</span> self.write_to_conn(request, conn)<br>        <span class="hljs-comment"># 接收请求</span><br>        response: Response = <span class="hljs-keyword">await</span> as_first_completed(<br>            [response_future],<br>            not_cancel_future_list=[conn.conn_future],<br>        )<br>        response.state = request.state<br>        <span class="hljs-keyword">return</span> response<br>    <span class="hljs-keyword">finally</span>:<br>        <span class="hljs-comment"># 回收资源</span><br>        pop_future: Optional[asyncio.Future] = self._resp_future_dict.pop(resp_future_id, <span class="hljs-literal">None</span>)<br>        <span class="hljs-keyword">if</span> pop_future:<br>            safe_del_future(pop_future)<br></code></pre></td></tr></table></figure>
<p>然后是服务端， 服务端也非常简单， 直接从Header获取值， 再应用到超时函数即可</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">try</span>:<br>    <span class="hljs-comment"># 通过header获取截止时间</span><br>    deadline_timestamp: <span class="hljs-built_in">int</span> = request.header.get(<span class="hljs-string">&quot;X-rap-deadline&quot;</span>, <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">if</span> deadline_timestamp:<br>        timeout: <span class="hljs-built_in">int</span> = <span class="hljs-built_in">int</span>(time.time() - deadline_timestamp)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-comment"># 如果获取不到就按照默认的时间</span><br>        timeout = self._run_timeout<br>    <span class="hljs-comment"># 执行任务， 如果超时会抛出timeout的错误</span><br>    result: Any = <span class="hljs-keyword">await</span> asyncio.wait_for(coroutine, timeout)<br><span class="hljs-keyword">except</span> asyncio.TimeoutError:<br>    <span class="hljs-comment"># 捕获错误</span><br>    <span class="hljs-keyword">return</span> call_id, RpcRunTimeError(<span class="hljs-string">f&quot;Call <span class="hljs-subst">&#123;func_model.func.__name__&#125;</span> timeout&quot;</span>)<br><span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>    <span class="hljs-keyword">return</span> call_id, e<br></code></pre></td></tr></table></figure>
<p>这样即可完成跨进程跨服务的超时传递， 不过这种实现是有一个前提， 就是所有机器的时间得保持一致的（或者说只差一点点）， 而微服务基本上都满足这种前提， 他们基本上都在同一个内网里面， 或者同个公司管理的跨区域机器里面。</p>
]]></content>
      <categories>
        <category>RPC框架编写实践</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>RPC</tag>
      </tags>
  </entry>
  <entry>
    <title>RPC框架编写实践--自动负载均衡</title>
    <url>/2021/10/19/RPC%E6%A1%86%E6%9E%B6%E7%BC%96%E5%86%99%E5%AE%9E%E8%B7%B5--%E8%87%AA%E5%8A%A8%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/</url>
    <content><![CDATA[<h2 id="前记"><a href="#前记" class="headerlink" title="前记"></a>前记</h2><p>在业务早期，业务比较简单， 流量也比较少，单台机器就可以抗下所有请求流量， 但随着业务的增长， 一些中间件会单独占有一台机器， 业务代码也会逐渐拆分， 整个架构会慢慢的从单机的单体架构变为多机的微服务架构。而对于用户来说， 他不知道自己的请求会分流到哪个机器， 但返回的结果必定要一致的， 其中承担用户流量分流到不同机器的技术组件会称为负载均衡。</p>
<span id="more"></span>

<h2 id="1-不同网络层的负载均衡组件"><a href="#1-不同网络层的负载均衡组件" class="headerlink" title="1.不同网络层的负载均衡组件"></a>1.不同网络层的负载均衡组件</h2><p>现在后端开发常见的负载均衡组件是<code>Nginx</code>, 即使没用过也有听过, 基本上所有的服务都会与<code>Nginx</code>交互。 此外还有另外一个负载均衡， 基本上所有请求都会接触它–<code>DNS</code>， 因为用户访问目标域名时， 会由<code>DNS</code>解析域名， 并由用户所在地区， 后端服务器情况来得到对应的最佳ip, 然后用户的客户端会通过该ip请求到对应的服务器, 所以<code>DNS</code>也是属于一种负载均衡技术, 可见一般用户的请求都会经历<code>DNS</code>和<code>Nginx</code>两次负载均衡。<br>不过真正的大型系统中负载均衡往往是多级的， 比如用户流量会先访问域名， 然后<code>DNS</code>开始解析， 把用户的请求分发到最近的机器A， 接着又会被机器A的四层负载均衡会把流量分到对应的机器B， 最后由机器B上的<code>Nginx</code>把流量分发到对应的web应用服务。</p>
<p>除了<code>DNS</code>和<code>CDN</code>这种大厂才有的负载均衡服务外， 我们常见的负载均衡可以分为四层负载均衡和七层负载均衡， 这里的四层和七层指的是经典OSI七层模式（见计算机网络相关书籍）中的第4层传输层和第7层应用层。 需要注意的是“四层”是说这些工作模式的共同特点是维持同一个TCP连接，而不是说它只工作在第四层, 事实上，这些模式还包括了第二层数据链路层（改写MAC地址）和第三层网络层（改写IP地址）。<br>第四层负载均衡主要只做转发流量， 流量都是在单独一个TCP链接中流动，而第七层则是代理流量， 客户端，负载均衡组件， 服务端三者之间通过两条TCP连接传输着流量。<br>其中第四层性能比第七层高， 因为流量经过机器时， 机器不需要解过多的包， 只要识别MAC地址之类的就可以进行负载均衡转发， 同时这种模式适用于’单臂模式’， 流量从目标机器返回时，可以不直接经过负载均衡机器直接返回到请求机器中， 少走一个节点， 如下图：<br><img    class="lazyload" data-original="https://files.catbox.moe/g169of.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">image</span><br>这种方式可以使流量不用跨越太多的机器， 增加传输性能， 但是这种方案也带来了一定的限制， 比如负载均衡机器与节点可能要处于同一个子网， 无法跨VLAN。</p>
<p>可以看到第四层主要注重于性能以及简单的转发， 可定制性和功能也没有第七层的强和多， 适用场景少, 同时由于TCP协议的缺陷， 第四层负载均衡容易收到攻击， 所以一般的负载均衡实现方案都是四层负载和七层负载一起用， 并把第四层负载均衡放置在第七层负载均衡前面。</p>
<h2 id="2-七层负载均衡功能"><a href="#2-七层负载均衡功能" class="headerlink" title="2.七层负载均衡功能"></a>2.七层负载均衡功能</h2><p>第七层负载均衡的主要职能是选择哪个后台应用来处理网络请求， 由于后台应用比较多， 负载均衡必须确保每个请求都能去到最优的服务器， 让用户得到最好的网络响应， 为此出现了很多负载均衡策略， 常见的有：</p>
<ul>
<li>轮训均衡负载： 每一次来自网络的请求轮流分配给内部的服务器，从1至N然后重新开始， 讲究的是最均衡的分配， 每个机器最终处理的请求数量一致。</li>
<li>权重轮训负载均衡： 与轮训负载均衡很像， 但可以配置权重， 把请求更有倾向性的分配到不同的机器， 一般用于后端有多个性能不同的机器。</li>
<li>随机负载： 每次请求都随机负载到某个机器， 在数据量大时， 每个机器处理的请求数很相近</li>
<li>一致性哈希均衡： 根据请求的特征（token， ip）等等作为特征进行计算， 再根据计算结果把请求分配到某个机器上， 一般用于让某个用户只能访问一个机器的情况。</li>
<li>响应速度均衡： 根据过去一段时间内每个机器的响应速度进行计算， 优先把请求转发给响应时间短的机器</li>
<li>最少连接均衡：根据过去一段时间内每个机器的连接数进行计算， 优先把请求转发给处理请求数少的机器。</li>
</ul>
<p>为了上述的负载均衡策略得以实现， 负载均衡组件通常还必须拥有健康检查功能， 检查每个服务是否可用，同时也需要服务发现功能， 在节点变多后， 通过服务发现来动态修改后端节点。</p>
<p>此外， 常用的负载均衡组件， 如<code>Nginx</code>除了代理流量外， 还会承担一些静态文件请求， 以及缓存， 内容分发, 以及带有一些流量复制， 流量监控等等的功能。</p>
<h2 id="3-微服务的负载均衡组件"><a href="#3-微服务的负载均衡组件" class="headerlink" title="3.微服务的负载均衡组件"></a>3.微服务的负载均衡组件</h2><p>一般在一开始接触<code>Nginx</code>时， 我们都会以一台<code>Nginx</code>来处理所有流量, 这种方法叫集中式的负载均衡， 这种负载均衡方法很致命的问题就是单点依赖问题, 在单点问题场景中， 当单点组件挂的时候， 后台所有服务都无法处理客户端的请求。<br>可见单点依赖问题很严重， 我们应当尽量避免这个情况, 在流量从客户端到后台应用的链路中， 所有组件应尽可能的避免使用单点组件。 由于微服务基本上都处于在一个内网之中， 可以不用考虑有个网关之类的服务来过滤非法请求, 也不怕被外网攻击， 同时在微服务设计中， 所有的服务都尽可能的拆成自己单一的服务， 此时若还依赖<code>Nginx</code>来做单点负载均衡， 则很容易使所有微服务由于<code>Nginx</code>出现问题而无法处理请求, 同时所有流量都需要经过一层<code>Nginx</code>进行转发， 会浪费机器资源, 所以微服务最好不去使用这种负载均衡模式， 那微服务的负载均衡该怎么做呢？</p>
<p>由于微服务有个明显的特征， 就是它处理的请求都是在内部集群中流转， 不像传统负载均衡一样需要处理外部的请求, 从微服务客户端请求的数据基本是可信的(代码是自己写的， 在发起请求前就能自动过滤掉非法的请求), 那么可以采用称为客户端负载均衡模式的分布式负载均衡， 这种模式是每个微服务都内置了自己的一个负载均衡实现， 把一个单一的负载均衡变为分布式的负载均衡， 这种方式十分灵活，每个服务都可以单独设置单种负载均衡方式，以及附加的功能， 同时可以避免单一组件的危险， 减少流量要在集群内部绕圈圈的局面。 但是这种方案也是有局限性的，它跟服务是同一个进程， 意味着它的实现必须与服务同一个语言，负载均衡的稳定性也会影响到同一个进程的CPU，内存等资源（所以就出现了服务网格与边车代理， 但不是本文的相关内容）。不过，这种模式只负责做负责均衡， 没办法自动发现有多少个可用节点， 还是会依赖一个单一组件–配置中心， 它需要通过配置中心来了解这个服务对应的集群ip是多少， 以及服务是否上下线。</p>
<h2 id="4-自动负载均衡的实现"><a href="#4-自动负载均衡的实现" class="headerlink" title="4.自动负载均衡的实现"></a>4.自动负载均衡的实现</h2><p>上面说了很多了， 那负载均衡该如何实现呢， 首先要明确自己的要求是什么：</p>
<ul>
<li>1.客户端能够自动感应服务端节点的上下线。</li>
<li>2.在没人工干预的情况下， 能自动隔离故障的节点， 并在节点恢复的时候自动恢复。</li>
<li>3.每次选择节点时，选取到的节点都是距离当前服务最近的，响应尽可能快, 负载尽可能小的。</li>
<li>4.不会因为负载均衡造成羊群效应， 一切的变动都是非常及时的。</li>
</ul>
<p>对于第一个要求， 则需要依赖于注册/配置中心， 通过注册中心来自动获取/感知对应服务的上下线， 通过配置中心来更改权重值等配置， 这会在注册中心的文章进行介绍。</p>
<p>对于第二个要求， 则采用健康检查的思路， 客户端会每隔一个时间后发送一个ping信息到对应的目标服务， 根据ping的成功率来决定是否要自动隔离目标节点以及恢复， 比如最近3次都ping失败就可以判断对应的节点已经故障， 可用性为0， 不再分发请求到该节点， 直到最近3次Ping都成功为止。</p>
<p>而第三种和第四种， 就是最复杂， 也是最重要的了, 是自动负载均衡的核心部分， 我的RPC务框架的客户端实现一定程度参考了<code>kratos</code>框架的1.x版本。 这个实现简单的说就是从连接池中挑选对应的多个连接， 通过打分的形式综合自己当前的连接状态和服务端的情况进行打分， 然后判断哪个连接的分数比较高， 并选取分数最高的连接作为本次请求的连接，其中涉及到的名词有从多个连接选取最想要的一个–p2c, 反映近期数值变化的加权平均数–EWMA和主观批评方法–mos。接下来将从离自动负载均衡最远到近一个一个参数进行介绍。</p>
<h3 id="4-1-mos"><a href="#4-1-mos" class="headerlink" title="4.1.mos"></a>4.1.mos</h3><p>首先是mos, mos是衡量服务端当前压力的值, 这是我在RTCP通话质量分析里面学到的词， 这个值只会在0-5波动, 0代表不可用， 5代表最佳。 为了减少资源消耗， 服务端会实时记录请求数据指标， 通过滑动窗口每隔一段时间计算一次mos值, 并保存在内存中, 或者更新内存中的值(详见<a href="https://so1n.me/2021/08/24/RPC%E6%A1%86%E6%9E%B6%E7%BC%96%E5%86%99%E5%AE%9E%E8%B7%B5--%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86%E7%9A%84%E5%9F%BA%E7%9F%B3/">服务治理的基石</a>)。<br>然后在客户端通过ping-pong请求发送ping到服务端时， 服务端会把位于内存的mos值放在响应体中返回给客户端, 客户端并不需要知道这个值是怎么来的, 是依赖哪些指标生成的， 只需要知道在自动负载均衡中对应的服务的mos值越高， 就更应该连接到这个服务。</p>
<blockquote>
<p>NOTE: <code>Kratos</code>框架会在每次请求都返回最新的服务端压力指标, 如cpu使用率，并发数等等，然后客户端收到指标数据后会实时的根据这些指标进行计算。 我在实践的时候感觉这样做作用不大，同时又很废网络流量，故而只通过ping-pong的请求来获取指标，减少客户端的计算量和网络传输资源的占用。</p>
</blockquote>
<p>那服务端依赖哪些指标来生成mos值呢， 前面说道， 这类型的值主要作用是用来衡量服务端当前的压力， 比如Linux系统有一个叫load的变量， 来衡量机器的负载， 而对于服务端来说， 可以衡量的值比较多， 具体需要根据场景来选用， 常用的有：</p>
<ul>
<li>QPS-每秒请求数， 意味着每秒收到的请求数量。此外还有一个叫预估峰值QPS, 原理是每天80%的访问集中在20%的时间里，这20%时间叫做峰值时间，而峰值QPS的计算是(每天的请求数<em>80%)/(每天秒数</em>20%)，假设每天的请求数为100W，那么峰值QPS为46。</li>
<li>TPS-每秒处理的事务数，系统整体处理能力取决于处理能力最低模块的TPS值。</li>
<li>RT-系统对请求作出响应的时间， 这个值对于用户来说是最直观的， 所以该值也是非常的重要。</li>
<li>并发数-该机器同一时刻的处理量， 该值越高，机器压力越大。</li>
<li>CPU使用率-CPU的使用量， 对于CPU密集型的应用来说， CPU使用率是一个很重要的指标。</li>
<li>请求错误数-一般来说，当服务出现错误时，可能会伴随这其他系统资源的占用并且没来得及释放， 当请求错误数变多时，可以假想机器的压力变大。</li>
</ul>
<p>我在为框架写一个通用的mos计算时， 去掉了一些业务相关的压力指标依赖， 选择了一些通用的压力指标如cpu使用率，请求数，响应数，错误数，当前正在处理请求数， 当前channel数量， 这些指标经过计算最后只会在0到1直接波动， 通过这些指标与5进行计算, 最后取值范围在0-5之间，具体代码见:<a href="https://github.com/so1n/rap/blob/master/rap/server/plugin/processor/mos.py">https://github.com/so1n/rap/blob/master/rap/server/plugin/processor/mos.py</a></p>
<p>需要注意的是， 光靠上面是数值会很容易的陷入到数值陷阱中， 因为随着服务的变化， 这些数值的影响力也会发生变化， 我们需要过段时间就更改数值。 此外，在真正应用到生产环境时， mos的计算方法还是要根据对应的工作环境来制定， 因为每个服务的要求都是不同的， 有些服务的最高成本请求会比最低成本请求多消耗1000倍的资源， 如果没办法区分， 负载均衡策略就会造成误判。 同时还有一些比较特别的服务， 他们可能会强依赖单一的组件， 比如<code>MySQL</code>， 当<code>MySQL</code>挂的时候， 整个服务是不可能的， 应当快速的把mos设置为0。</p>
<h3 id="4-2-EWMA"><a href="#4-2-EWMA" class="headerlink" title="4.2.EWMA"></a>4.2.EWMA</h3><p>客户端在获取了服务端的mos值后，客户端可以把mos与自己的指标进行计算去得出一个负载均衡的评分， 但是服务端的mos并不是实时获取出来的， 通常都会有一段延时， 这样算出来的评分可能没办法反映真实的情况， 需要一个算法来适当的修正， 而EWMA的修正则是可以让这个mos值变得更加的真实。</p>
<p>EWMA全称为Exponentially Weighted Averages，中文意思为指数移动加权平均， 它体现的是一段时间内的平均值，此算法是对观察值分别给予不同的权数，按不同权数求得移动平均值，并以最后的移动平均值为基础，确定预测值的方法。 采用加权移动平均法，是因为观察期的近期观察值对预测值有较大影响，它更能反映近期变化的趋势， 同时它不需要保存过去的所有数值， 计算量也不大， 适合经常更新数据的服务， 同时对于网络抖动比较敏感。</p>
<p>EWMA的公式如下：<br>$$V_t=w*V_{t-1} + (1-w)*T_{t}$$</p>
<p>这个公式中，Vt代表第t次请求时的EWMA值，Vt-1代表第t-1次请求的EWMA值，Tt代表第t次请求的实际耗时, 先把EWMA相关的值忽略当为1可以发现， 公式中参数<code>w</code>是跟请求频率相关的， 我们可以通过控制这个值来迅速的监控到网络毛刺， 比如当请求频繁时，说明节点负载变高了，我们就需要相对的调小该值，如果请求不频繁， 则可以调大该值， 这样计算出来的EWMA就越接近平均值。 在经过一番查找后， 发现可以运用牛顿冷却定律的衰减函数模型（见<a href="https://blog.51cto.com/u_9269309/1865554">基于牛顿冷却定律的时间衰减函数模型</a>）来进行计算， 从而生成符合该条件的<code>w</code>值， 而牛顿冷却定律的时间衰减公式为：<code>w=1/e^(k*△t) </code>, 其中可以把<code>△t</code>认为是两次请求的间隔， 而e, k为常变量, 通常一个是1，另外一个需要自己根据响应时间的平均时长来进行计算。</p>
<p>了解完EWMA后就可以开始实现了， 代码如下(具体见：<a href="https://github.com/so1n/rap/blob/master/rap/client/transport/transport.py#L193)%EF%BC%9A">https://github.com/so1n/rap/blob/master/rap/client/transport/transport.py#L193)：</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">ping</span>(<span class="hljs-params">self, conn: Connection, deadline: Deadline</span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>    start_time: <span class="hljs-built_in">float</span> = time.time()<br>    <span class="hljs-comment"># 初始化mos和延迟rtt</span><br>    mos: <span class="hljs-built_in">int</span> = <span class="hljs-number">5</span><br>    rtt: <span class="hljs-built_in">float</span> = <span class="hljs-number">0</span><br><br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_ping</span>() -&gt; <span class="hljs-keyword">None</span>:</span><br>        <span class="hljs-comment"># 发送ping请求， 并处理ping的响应体， 从而得出响应时长和服务端返回的mos</span><br>        <span class="hljs-keyword">nonlocal</span> mos<br>        <span class="hljs-keyword">nonlocal</span> rtt<br>        response: Response = <span class="hljs-keyword">await</span> self._base_request(Request.from_event(self.app, event.PingEvent(&#123;&#125;)), conn)<br>        rtt += time.time() - start_time<br>        mos += response.body.get(<span class="hljs-string">&quot;mos&quot;</span>, <span class="hljs-number">5</span>)<br><br>    <span class="hljs-comment"># 发送3次ping请求</span><br>    <span class="hljs-keyword">with</span> deadline.inherit():<br>        <span class="hljs-keyword">await</span> asyncio.gather(*[_ping(), _ping(), _ping()])<br><br>    <span class="hljs-comment"># 算出这3次请求的平均值</span><br>    mos = mos // <span class="hljs-number">3</span><br>    rtt = rtt / <span class="hljs-number">3</span><br><br>    <span class="hljs-comment"># 获取初始值与上次请求的值</span><br>    now_time: <span class="hljs-built_in">float</span> = time.time()<br>    old_last_ping_timestamp: <span class="hljs-built_in">float</span> = conn.last_ping_timestamp<br>    old_rtt: <span class="hljs-built_in">float</span> = conn.rtt<br>    old_mos: <span class="hljs-built_in">int</span> = conn.mos<br><br>    <span class="hljs-comment"># 计算两次请求间隔， 从而计算出w, 由于我的ping是随机间隔1-3秒， 所以self._decay_time设定在600左右 </span><br>    td: <span class="hljs-built_in">float</span> = now_time - old_last_ping_timestamp<br>    w: <span class="hljs-built_in">float</span> = math.exp(-td / self._decay_time)<br><br>    <span class="hljs-keyword">if</span> rtt &lt; <span class="hljs-number">0</span>:<br>        rtt = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">if</span> old_rtt &lt;= <span class="hljs-number">0</span>:<br>        w = <span class="hljs-number">0</span><br><br>    <span class="hljs-comment"># 通过EWMA公式来计算rtt和mos</span><br>    conn.rtt = old_rtt * w + rtt * (<span class="hljs-number">1</span> - w)<br>    conn.mos = <span class="hljs-built_in">int</span>(old_mos * w + mos * (<span class="hljs-number">1</span> - w))<br>    conn.last_ping_timestamp = now_time<br>    <span class="hljs-comment"># 通过本次rtt, mos以及用户指定的权重值进行计算打分， 得出对应的分数</span><br>    conn.score = (conn.weight * mos) / conn.rtt<br></code></pre></td></tr></table></figure>
<h3 id="4-3-选择最佳节点"><a href="#4-3-选择最佳节点" class="headerlink" title="4.3.选择最佳节点"></a>4.3.选择最佳节点</h3><p>一般来说， 为了增加服务的可用性， 同一个服务会由多个服务端来提供， 这样对于客户端来说会有很多可选节点， 如果客户端每次请求都从所有节点进行比较, 再选出最合适的连接来进行请求则会比较消耗计算资源与时间，这是没必要的。 因为大部分节点在大部分时间内的状态都是正常的, 只有在一些特殊情况才会发生异常状况， 而我们要做到的就是在有异常情况的时候尽量的不要去选择有问题的连接， 这时就需要P2C。 P2C很容易理解， 就是从多个节点中随机选择两个节点， 通过随机选取的方式， 可以在占用极小的计算资源的情况下选取合适的连接， 同时尽量的避免在异常情况下选到不可用的连接（都选到的不可用的连接的概率非常的小, 即使选到了， 也可以通过其他服务治理来规避问题）， 除了随机外， 也支可以持其他方式（当然， 这种方式需要尽量的简单）， 类似于2里面说的负载均衡，具体实现代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">picker</span>(<span class="hljs-params">self, cnt: Optional[<span class="hljs-built_in">int</span>] = <span class="hljs-literal">None</span></span>) -&gt; Picker:</span><br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    自动算出需要一次获取多少个连接数， P2C默认是获取2个， 我这里则是默认获取3次， 因为获取的连接有可能是不可用的</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> cnt:<br>        <span class="hljs-keyword">if</span> self._connected_cnt &lt;= <span class="hljs-number">3</span>:<br>            cnt = self._connected_cnt<br>        <span class="hljs-keyword">else</span>:<br>            cnt = <span class="hljs-number">3</span><br>    <span class="hljs-keyword">if</span> cnt &lt;= <span class="hljs-number">0</span>:<br>        cnt = <span class="hljs-number">1</span><br><br>    conn_list: List[Connection] = self._pick_conn(cnt)<br>    <span class="hljs-keyword">return</span> Picker(conn_list)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_pick_conn</span>(<span class="hljs-params">self, cnt: <span class="hljs-built_in">int</span></span>) -&gt; List[Connection]:</span><br>    <span class="hljs-string">&quot;&quot;&quot;默认的获取连接方法， 通过启动配置可以配置成下面对应的获取连接方法&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">pass</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_random_pick_conn</span>(<span class="hljs-params">self, cnt: <span class="hljs-built_in">int</span></span>) -&gt; List[Connection]:</span><br>    <span class="hljs-string">&quot;&quot;&quot;随机获取连接的方法， 一般来说获取的连接都是无规律的&quot;&quot;&quot;</span><br>    cnt = <span class="hljs-built_in">min</span>(cnt, <span class="hljs-built_in">len</span>(self._conn_dict))<br>    key_list: List[<span class="hljs-built_in">tuple</span>] = <span class="hljs-built_in">list</span>(self._conn_dict.keys())<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> key_list:<br>        <span class="hljs-keyword">raise</span> ConnectionError(<span class="hljs-string">&quot;Endpoint Can not found available conn&quot;</span>)<br>    conn_list: List[Connection] = []<br>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(cnt):<br>        key: <span class="hljs-built_in">tuple</span> = random.choice(key_list)<br>        conn: Connection = self._conn_dict[key]<br>        <span class="hljs-keyword">if</span> conn.available:<br>            conn_list.append(conn)<br><br>    <span class="hljs-keyword">return</span> conn_list<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_round_robin_pick_conn</span>(<span class="hljs-params">self, cnt: <span class="hljs-built_in">int</span></span>) -&gt; List[Connection]:</span><br>    <span class="hljs-string">&quot;&quot;&quot;轮训获取连接的方法， 不加锁可能导致获取的连接是不连续的， 但是影响不大&quot;&quot;&quot;</span><br>    conn_list: List[Connection] = []<br>    key_list: List[<span class="hljs-built_in">tuple</span>] = <span class="hljs-built_in">list</span>(self._conn_dict.keys())<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> key_list:<br>        <span class="hljs-keyword">raise</span> ConnectionError(<span class="hljs-string">&quot;Endpoint Can not found available conn&quot;</span>)<br>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(cnt):<br>        self._round_robin_index += <span class="hljs-number">1</span><br>        index = self._round_robin_index % (<span class="hljs-built_in">len</span>(self._conn_dict))<br>        conn: Connection = self._conn_dict[key_list[index]]<br>        <span class="hljs-keyword">if</span> conn.available:<br>            conn_list.append(conn)<br>    <span class="hljs-keyword">return</span> conn_list<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_pick_faster_conn</span>(<span class="hljs-params">self, cnt: <span class="hljs-built_in">int</span></span>) -&gt; List[Connection]:</span><br>    <span class="hljs-string">&quot;&quot;&quot;根据响应时间来获取连接， 通常来说会经常使用响应速度最快的连接， 不太推荐&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">sorted</span>([i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> self._conn_dict.values() <span class="hljs-keyword">if</span> i.available], key=<span class="hljs-keyword">lambda</span> c: c.rtt)[:cnt]<br></code></pre></td></tr></table></figure>

<p>选择完了连接后， 就需要依赖打分机制来决定最终需要选谁了， 上面说过，客户端可以通过ping-pong机制获取到服务对应的mos值, 并进行打分， 但是ping-pong的间隔是随机的1-3秒, 所以客户端更新对应服务的分数的间隔时间也是随机的1-3秒， 这样的更新频率并不快, 如果直接使用该值做自动化负载均衡的话， 那就会造成短时间内流量都跑到该更新时间周期内压力最少的机器上面， 从而产生羊群效应，造成这些机器短时间内产生极大的压力， 整个内部网络环境的流量也是极不均衡的， 所以还需要客户端依赖自己的一些连接数据来生成最后的打分情况。<br>这个值就是客户端与每个服务的正在请求数, 通过连接数可以衡量当前客户端会把流量发送到哪里， 如果发现发送的量不均衡， 那么正在请求的数会变得不均衡, 在<code>rap</code>这个框架中， 负责这个功能的类叫<code>Picker</code>, 它除了管理获取最佳连接外， 还通过信号量来管理每个连接的使用情况， 包括当前连接有多少个请求， 是否超过使用量等等， 具体代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Picker</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, conn_list: List[Connection]</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;该类是由上面picker函数创建的, 所以这些值也就是那个阶段中确定了&quot;&quot;&quot;</span><br>        self._conn: Connection = self._pick(conn_list)<br>        self._start_time: <span class="hljs-built_in">float</span> = time.time()<br><br><span class="hljs-meta">    @staticmethod</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_pick</span>(<span class="hljs-params">conn_list: List[Connection]</span>) -&gt; Connection:</span><br>        <span class="hljs-string">&quot;&quot;&quot;pick by score&quot;&quot;&quot;</span><br>        pick_conn: Optional[Connection] = <span class="hljs-literal">None</span><br>        conn_len: <span class="hljs-built_in">int</span> = <span class="hljs-built_in">len</span>(conn_list)<br>        <span class="hljs-keyword">if</span> conn_len == <span class="hljs-number">1</span>:<br>            <span class="hljs-comment"># 如果只有一个可用的连接， 则不用进行对比， 直接采用</span><br>            pick_conn = conn_list[<span class="hljs-number">0</span>]<br>        <span class="hljs-keyword">elif</span> conn_len &gt; <span class="hljs-number">1</span>:<br>            <span class="hljs-comment"># 如果可用连接多于一个， 就开始进入对比阶段</span><br>            score: <span class="hljs-built_in">float</span> = <span class="hljs-number">0.0</span><br>            <span class="hljs-keyword">for</span> conn <span class="hljs-keyword">in</span> conn_list:<br>                <span class="hljs-comment"># 通过信号量获取当前正在使用连接的量</span><br>                conn_inflight: <span class="hljs-built_in">float</span> = conn.semaphore.inflight<br>                <span class="hljs-comment"># 服务端返回的值计算出的评分</span><br>                _score: <span class="hljs-built_in">float</span> = conn.score<br>                <span class="hljs-keyword">if</span> conn_inflight:<br>                    <span class="hljs-comment"># 通过正在使用连接的量计算正真的评分 </span><br>                    _score = _score / conn_inflight<br>                logging.debug(<span class="hljs-string">&quot;conn:%s available:%s rtt:%s score:%s&quot;</span>, conn.peer_tuple, conn.available, conn.rtt, _score)<br>                <span class="hljs-keyword">if</span> _score &gt; score:<br>                    score = _score<br>                    pick_conn = conn<br>        <span class="hljs-comment"># 如果没有可用连接，则报错</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> pick_conn:<br>            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&quot;Can not found available conn&quot;</span>)<br>        <span class="hljs-keyword">return</span> pick_conn<br><br>    <span class="hljs-comment"># 通过__aenter__和__aexit__限制了调用端只能通过async with pick来获取可用的连接， 以此方便通过信号量来管理连接的使用量</span><br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__aenter__</span>(<span class="hljs-params">self</span>) -&gt; Connection:</span><br>        <span class="hljs-keyword">await</span> self._conn.semaphore.acquire()<br>        <span class="hljs-keyword">return</span> self._conn<br><br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__aexit__</span>(<span class="hljs-params">self, exc_type: Any, exc_val: Any, exc_tb: Any</span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        self._conn.semaphore.release()<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br></code></pre></td></tr></table></figure>
<h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5.总结"></a>5.总结</h2><p>第一次调差自动负载均衡的资料时， 理解了很久， 但在经过实践后， 发现只要理解了EWMA的方法并去理解它同时自动化负载均衡的原理十分简单， 就是在正常的情况下尽可能的平均的去请求到服务端， 同时保证在某个服务端压力变大时， 尽量的不去选取它即可。 但是上面实现起来有一个弊端， 就是自动化负载均衡跟客户端是在同一个进程内的， 所以跨语言的话就得重新开发一个， 负载均衡的实现好坏也会影响到客户端对应的性能， 所以更好的方法是采用边车代理的方式来实现自动负载均衡。</p>
]]></content>
      <categories>
        <category>RPC框架编写实践</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>RPC</tag>
      </tags>
  </entry>
  <entry>
    <title>RPC框架编写实践--服务的优雅的重启</title>
    <url>/2021/08/28/RPC%E6%A1%86%E6%9E%B6%E7%BC%96%E5%86%99%E5%AE%9E%E8%B7%B5--%E4%BC%98%E9%9B%85%E7%9A%84%E9%87%8D%E5%90%AF/</url>
    <content><![CDATA[<h2 id="前记"><a href="#前记" class="headerlink" title="前记"></a>前记</h2><p>无论是微服务， 还是普通的API服务器， 他们都是进程， 服务在发布的时候， 必定会重启， 这时候会先杀掉旧进程， 再启用新的进程， 但旧的服务还在进行通信， 这时候强制杀掉这些旧进程， 会造成脏数据， 以及客户端端连接到服务的连接中断。要解决这些问题， 就要做到服务能优雅的关闭或重启的时候可以保障整个总体服务零宕机。</p>
<span id="more"></span>
<blockquote>
<p><a href="https://so1n.me/categories/RPC%E6%A1%86%E6%9E%B6%E7%BC%96%E5%86%99%E5%AE%9E%E8%B7%B5/">RPC框架编写实践</a>系列文章是我编写框架<a href="https://github.com/so1n/rap">rap</a>的想法和总结。</p>
</blockquote>
<h2 id="1-API服务的实现"><a href="#1-API服务的实现" class="headerlink" title="1.API服务的实现"></a>1.API服务的实现</h2><p>我的实现逻辑是通过参考<a href="https://www.uvicorn.org/">uvicorn</a>而来的， 它用于Python的异步API服务， 所以这里也以一个常见的API服务发布流程来介绍, 常见的API服务架构如下：</p>
<p><img    class="lazyload" data-original="https://i.loli.net/2021/08/28/Sdm7MxNkpo8bqDh.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">uTools_1630140082901.png</span></p>
<p>这个服务十分的简单， 就是用户通过客户端访问到客户端指定的<code>Nginx</code>服务器，然后<code>Nginx</code>根据<code>UpStream</code>的配置， 把数据转发到对应的<code>Api Server 1</code>或者<code>Api Server 2</code>, 他们的提供的服务是一样的。</p>
<p>如果在某段时间， 我们在对服务端程序<code>Api Server 1</code>或者<code>Api Server 2</code>进行更新或重启时，如果我们直接使用<code>kill -9</code>杀掉旧进程并启动新进程， 则会有以下几个问题：</p>
<ul>
<li>1.请求正在处理中， 可能只执行一半的变更， 然后直接出错。</li>
<li>2.旧的请求还未处理完，如果服务端直接关闭退出，会造成客户端中断。</li>
<li>3.新的请求通过<code>Nginx</code>分发过来的时候， 服务还未重启完毕， 这时会由<code>Nginx</code>直接返回错误。</li>
</ul>
<p>那么要怎么解决问题呢？</p>
<h2 id="1-2-Nginx动态更改"><a href="#1-2-Nginx动态更改" class="headerlink" title="1.2.Nginx动态更改"></a>1.2.Nginx动态更改</h2><p>在发布时， 我们一般会使用滚动更新， 就是先重启<code>Api Server 1</code>再重启<code>Api Server 2</code>, 这个步骤是：</p>
<ul>
<li>1.更改<code>Nginx</code>的<code>UpStream</code>配置， 流量只能发到<code>Api Server 2</code>, 然后重启<code>Api Server 1</code>。</li>
<li>2.<code>Api Server 1</code>重启完成后， 更改<code>Nginx</code>的<code>UpStream</code>配置， 流量只能发到<code>Api Server 1</code>, 然后重启<code>Api Server 2</code>。</li>
<li>3.<code>Api Server 2</code>重启完成后， 更改<code>Nginx</code>的<code>UpStream</code>配置， 流量会发送到<code>Api Server 1</code>和<code>Api Server 2</code>。</li>
</ul>
<p>可以看到这个动作是非常的繁琐的， 就连我描述的文字都有大量的重复， 所以就会追求让这个步骤自动化， 比如引用了<code>Nginx</code> + <code>etcd</code> + <code>confd</code>的组合， 但是当服务需要频繁重启时， 就会发现这个组合性能不好。 这时就会转向<code>OpenResty</code>+<code>etcd</code>或者<code>Nginx</code> + <code>etcd</code> + <code>Upsync</code>， 它们的大致原理都是一样的， 首先是依赖于<code>Etcd</code>(也可以是其他配置中心)， 来提供配置服务， 并由其他工具如<code>CI/CD</code>来控制配置， 并由<code>conf</code>, <code>Upsync</code>或者是<code>OpenResty</code>的<code>lua</code>来根据配置中心的变动动态更新<code>Nginx</code>的<code>UpStream</code>配置。</p>
<h2 id="1-3-优雅的退出服务"><a href="#1-3-优雅的退出服务" class="headerlink" title="1.3.优雅的退出服务"></a>1.3.优雅的退出服务</h2><p>重启必定会涉及启动和退出， 启动很简单， 只要能确保服务启动时能将自己的信息注册到注册中心即可， 而对于服务退出， 则多了几个步骤。</p>
<p>如果比较熟悉<code>Supervisor</code>， 就会知道它有个配置<code>stopwaitsecs</code>, 这个配置就是最大等待进程关闭是时间（单位：秒）， 为了程序能健康退出， 我们需要按照我们的业务需求来配置这个参数， 这个参数会用在关闭进程的逻辑中。</p>
<p><code>Supervisor</code>的关闭进程实现原理是发送信号<code>SIGINT</code>或者是<code>SIGTERM</code>给进程， 进程收到信号会开始停止接收连接， 然后等待现有链接关闭完成后再自己退出， 但是难免会有一些特殊的情况， 导致连接关闭的时间过久， 这些情况是非常的异常的， 我们也不可能一直等着， 所以<code>Supervisor</code>会等待<code>stopwaitsecs</code>秒后强制关闭进程。</p>
<p>而程序内部是怎么实现的呢， 我从<a href="https://www.uvicorn.org/">uvicorn</a>中偷师， <a href="https://github.com/encode/uvicorn/blob/master/uvicorn/server.py">uvicorn.server</a>是uvicorn的服务代码， 只负责启动和关闭服务， 非常简单。</p>
<p><a href="https://github.com/encode/uvicorn/blob/master/uvicorn/server.py">uvicorn.server</a>代码的一开始, 就声明了要监控的信号是<code>SIGINT</code>和<code>SIGTERM</code>, 通过注释可以看出这两个信号分别是我们执行<code>Ctrl+C</code>和<code>Kill</code>命令触发的信号：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-comment"># 35-38行</span><br>HANDLED_SIGNALS = (<br>    signal.SIGINT,  <span class="hljs-comment"># Unix signal 2. Sent by Ctrl+C.</span><br>    signal.SIGTERM,  <span class="hljs-comment"># Unix signal 15. Sent by `kill &lt;pid&gt;`.</span><br>)<br></code></pre></td></tr></table></figure>
<p>这个信号会在通过<code>serve</code>方法中的<code>install_signal_handlers</code>来启用监听的， 并且挂载了对应的触发函数<code>handle_exit</code>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">handle_exit</span>(<span class="hljs-params">self, sig: signal.Signals, frame: FrameType</span>) -&gt; <span class="hljs-keyword">None</span>:</span><br><br>    <span class="hljs-keyword">if</span> self.should_exit:<br>        self.force_exit = <span class="hljs-literal">True</span><br>    <span class="hljs-keyword">else</span>:<br>        self.should_exit = <span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure>
<p>这个函数十分简单， 就是更改类里面的<code>should_exit</code>和<code>force_exit</code>属性。</p>
<p>而<code>serve</code>的方法是启动服务时调用的， 也就意味着在启动的时候监听信号, 此外<code>serve</code>在初始化后会执行<code>main_loop</code>, 这个方法通过<code>on_tick</code>来按照初始化要求来判断要返回<code>self.should_exit</code>或者是<code>force_exit</code>的状态， 如果状态为True就会一直循环下去， 否则就会退出循环（当然<code>on_tick</code>还做了其它与当前分析无关的事情）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main_loop</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>    counter = <span class="hljs-number">0</span><br>    should_exit = <span class="hljs-keyword">await</span> self.on_tick(counter)<br>    <span class="hljs-keyword">while</span> <span class="hljs-keyword">not</span> should_exit:<br>        counter += <span class="hljs-number">1</span><br>        counter = counter % <span class="hljs-number">864000</span><br>        <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">0.1</span>)<br>        should_exit = <span class="hljs-keyword">await</span> self.on_tick(counter)<br></code></pre></td></tr></table></figure>
<p>在<code>main_loop</code>执行完毕之后， 会执行<code>shutdown</code>的方法:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">shutdown</span>(<span class="hljs-params">self, sockets: Optional[List[socket.socket]] = <span class="hljs-literal">None</span></span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>    logger.info(<span class="hljs-string">&quot;Shutting down&quot;</span>)<br><br>    <span class="hljs-comment"># Stop accepting new connections.</span><br>    <span class="hljs-keyword">for</span> server <span class="hljs-keyword">in</span> self.servers:<br>        server.close()<br>    <span class="hljs-keyword">for</span> sock <span class="hljs-keyword">in</span> sockets <span class="hljs-keyword">or</span> []:<br>        sock.close()<br>    <span class="hljs-keyword">for</span> server <span class="hljs-keyword">in</span> self.servers:<br>        <span class="hljs-keyword">await</span> server.wait_closed()<br><br>    <span class="hljs-comment"># Request shutdown on all existing connections.</span><br>    <span class="hljs-keyword">for</span> connection <span class="hljs-keyword">in</span> <span class="hljs-built_in">list</span>(self.server_state.connections):<br>        connection.shutdown()<br>    <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">0.1</span>)<br><br>    <span class="hljs-comment"># Wait for existing connections to finish sending responses.</span><br>    <span class="hljs-keyword">if</span> self.server_state.connections <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> self.force_exit:<br>        msg = <span class="hljs-string">&quot;Waiting for connections to close. (CTRL+C to force quit)&quot;</span><br>        logger.info(msg)<br>        <span class="hljs-keyword">while</span> self.server_state.connections <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> self.force_exit:<br>            <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">0.1</span>)<br>    <span class="hljs-comment"># -----------------------</span><br>    <span class="hljs-comment"># 以下与本次分析无关</span><br></code></pre></td></tr></table></figure>
<p>从方法中的注释可以很清晰的知道， 这个方法主要做的是几件事：</p>
<ul>
<li>1.停止接收新的连接建立</li>
<li>2.调用关闭连接的方法（该方法不会马上关闭连接， 而是逐渐等请求完成）</li>
<li>3.等待所有请求完成响应</li>
</ul>
<p>最后整个流程整合如下图：<br><img    class="lazyload" data-original="https://i.loli.net/2021/08/28/zaZuXC9OHbvn6Yk.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">uTools_1630145321990.png</span></p>
<h2 id="2-如何实现"><a href="#2-如何实现" class="headerlink" title="2.如何实现"></a>2.如何实现</h2><p>上面说的逻辑可以整合成下图， 后台控制是CI/CD， 当提交代码后合并到<code>master</code>分支时， 就按照CI/CD脚本去控制配置中心更改配置以及重启对应的服务进程：<br><img    class="lazyload" data-original="https://i.loli.net/2021/08/28/wSO83bQmt2CLWB9.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">uTools_1630140104665.png</span></p>
<p>但是我在实现RPC框架时， 想到的场景是多个服务互相调用的情况， 而他们只依赖于配置中心一个第三方的系统， 于是我需要对上面的逻辑进行更改， 逻辑图如下：</p>
<p><img    class="lazyload" data-original="https://i.loli.net/2021/08/28/tJvKNbnLITB938R.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">uTools_1630164548242.png</span></p>
<p>首先对于客户端， 客户端会提供一个连接选择器，可以把它认为是一个简化版的网关， 它会从配置中心同步对应的服务信息。客户端发送请求时， 会先生成请求， 然后根据连接选择器， 从中挑选有用的连接(也就是自适应负载均衡)，并通过该连接把请求发送到对应的服务器。</p>
<p>而对于服务端， 会在启动的时候注册一个退出通知事件、注册一个信号通知回调以及向配置中心注册自己的连接信息， 并提供服务， 这时客户端的连接选择器就能同步到服务端的信息， 然后与服务端建立连接。</p>
<p>当服务端进程收到<code>SIGINT</code>或者是<code>SIGTERM</code>的信号时， 会触发回调， 服务端监听的socket会停止接收小心的请求， 同时向所有客户端连接广播自己即将关闭的消息（兼容没有使用配置中心的客户端）， 然后一直等待所有连接的请求已经处理完毕或超时，再调用退出事件， 使服务退出。至此， 整个优雅的重启逻辑搞定了。（代码比较分散， 且与<code>uvicorn</code>一样， 就不贴出来了）</p>
]]></content>
      <categories>
        <category>RPC框架编写实践</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>RPC</tag>
      </tags>
  </entry>
  <entry>
    <title>RPC框架编写实践--熔断器</title>
    <url>/2021/08/27/RPC%E6%A1%86%E6%9E%B6%E7%BC%96%E5%86%99%E5%AE%9E%E8%B7%B5--%E7%86%94%E6%96%AD%E5%99%A8/</url>
    <content><![CDATA[<h2 id="前记"><a href="#前记" class="headerlink" title="前记"></a>前记</h2><p>当依赖的服务已经出现故障时，熔断器会主动阻止本服务对依赖服务的请求，从而保证自身服务的正常运行不受依赖服务影响, 也减少依赖服务异常期间的压力，防止服务雪崩效应。</p>
<span id="more"></span>
<blockquote>
<p><a href="https://so1n.me/categories/RPC%E6%A1%86%E6%9E%B6%E7%BC%96%E5%86%99%E5%AE%9E%E8%B7%B5/">RPC框架编写实践</a>系列文章是我编写框架<a href="https://github.com/so1n/rap">rap</a>的想法和总结。</p>
</blockquote>
<h2 id="1-服务雪崩问题"><a href="#1-服务雪崩问题" class="headerlink" title="1.服务雪崩问题"></a>1.服务雪崩问题</h2><p>服务雪崩， 是一个非常严重的问题， 它描述的是一个短时间内大量服务相继不可用的场景， 而引起服务雪崩的原因基本上都是很简单的， 比如一个超时问题。</p>
<p>如图， 这是一个简单的服务调用图， 服务A1会调用服务B1和服务B2, 服务A2也会调用服务B1和服务B2， 而客户端会连接到服务A1和服务A2， 服务B1和服务B2各自连接一个专属的MySQL服务， 正常情况下， 他们都能正常的工作着， 而且也没什么异常情况发生， 响应时间很短， 在0.00x秒左右， 吞吐率也OK。<br>假设有一天， 突然请求量开始上来了， 服务B1某个方法连接的MySQL出现问题， 所在的机器CPU直接飚满了， 此时服务B1的响应时间会越来越久。而在正常情况下， 我们对服务间的调用超时会设置在3秒左右， 当服务A1请求到这个有问题的方法且发现B1的服务没有在3秒内响应时， 就会断开重新请求， 但是服务B1还在执行刚才的调用过程， 随着时间的推移， 服务B1积累正在处理的请求数会越来越多， 也越来越力不从心， 即使服务A1和B2的其他请求没有涉及到数据库， 服务B1也没有办法在短时间内做出响应。<br>这时候服务A1和服务A2也会积累着很多请求， 服务A1和A2慢慢的也会被拖垮， 而且它们是是客户端调用的接收端， 客户端会非常多， 这时候可能会出现占用大量文件描述符的情况， 导致无法处理客户端的请求， 最后从客户端的使用者来看就是整个服务不可用了。<br><img    class="lazyload" data-original="https://i.loli.net/2021/08/27/dzrpt6Bb7iHfKUg.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">uTools_1630052386741.png</span></p>
<p>可以看出上面的服务雪崩的例子是由于服务B1处理请求太久，而服务A1以为是网络出现问题，进行大量重试而造成的。如果能让服务A1失败时快速重试， 或者是多个服务互相调用时， 能透传超时参数， 那么这个问题是能被缓解的， 但是超时的参数很难被设置好， 而且要确定什么时候重试， 重试多久失败， 重试间隔多少也非常的难。最好的情况就是服务A1知道服务B1当前不可用， 先不请求它， 直接返回错误， 直到服务B1恢复到正常状态， 而这样的一个实现就是本文要说的熔断器。（在电路中， 如果负载突然飚到很高， 熔断器就会自动熔断， 等待人工去恢复）</p>
<h2 id="2-熔断的几种方式"><a href="#2-熔断的几种方式" class="headerlink" title="2.熔断的几种方式"></a>2.熔断的几种方式</h2><p>熔断是服务自我保护的一种方式，用于确保服务不会受请求突增影响变得不可用，至少确保服务不会奔溃, 常见的熔断方式有：开关熔断、限流熔断、客户端动态熔断。</p>
<ul>
<li><p>开关熔断是一个最简单的熔断方式， 通常是把配置放在一台第三方服务器， 客户端在调用某个服务之前， 会先通过第三方的配置服务器了解这个服务是否还在使用， 如果有就正常请求， 没有的话就不请求直接返回失败。</p>
<p>  通常这种场景用在于一些电商项目， 比如某个大促节日的时候， 都会通过配置的方式把某些无关紧要的服务先变为不可用， 把部分机器性能让给主要服务， 通常这种熔断的状态只有开和关， 可以手工和定时去更改配置。</p>
<p>  一般情况下为了提升性能， 同时在服务多的时候会引用网关或者配置中心， 那么这个开关熔断实现起来就会更简便， 同时也能减少重复调用的网络请求。 如通过配置中心实现的开关熔断， 调用服务会在内存存一份与配置中心同步的配置， 但配置中心的配置发送更改时， 通知服务更改内存的配置， 程序在调用服务前直接通过内存的配置数据进行判断， 决定是否要调用服务。 </p>
</li>
<li><p>限流熔断<br>  是一种特殊的熔断， 它本身是负责限流的功能， 但是由于限流会使请求量达到一定的程度时开始拒绝请求， 所以可以认为是一种特殊的熔断。不过限流除了直接拒绝请求外， 还可以实现均速排队的功能， 如在某一时刻有大量的请求到来，而接下来的一段时间都处于空闲状态，我们会希望系统能够在接下来的空闲期间处理这些请求，而不是在第一秒直接拒绝多余的请求。对于限流的具体实现则在下一篇文章再叙述</p>
</li>
<li><p>客户端动态熔断</p>
<p>  客户端在调用服务端的时候可以自己统计数据， 当发现过去某个阶段请求了100次， 但有70次失败， 它就可以预估接下来的失败概率会越来越高， 不再请求服务了， 而是直接返回错误。 不过服务端也不可能一直不可用， 所以客户端也需要能感知到服务端已经变得可用了。 </p>
</li>
</ul>
<p>上面3种实现中， 只有客户端动态熔断是全自动， 同时也是根据是否有错误来判断的， 同时这个熔断是放在客户端的， 在服务间网络出现异常时， 也能正常熔断， 可用性会更高。</p>
<h2 id="3-熔断器的实现原理"><a href="#3-熔断器的实现原理" class="headerlink" title="3.熔断器的实现原理"></a>3.熔断器的实现原理</h2><p>熔断器的本质上是一个包含了熔断检测， 熔断开关， 数据统计三个功能的状态机， 它通过收集统计数据来更改熔断开关， 每次有新的请求就会通过熔断检测判断当前请求可否放行， 它的3种状态分别是：</p>
<ul>
<li>全开  此时熔断器打开， 使用快速失败返回， 请求不会请求到服务端</li>
<li>半开  当熔断器开启到一定的阶段后， 会到了尝试阶段， 此时的熔断器会允许少量的请求通过， 并通过这些请求来判断下一步的状态</li>
<li>关  此时熔断器关闭， 所有请求可以正常的到达服务端。</li>
</ul>
<p>这几种状态的切换是有针对性的， 如下图， 全开只能切换到半开， 半开可以按条件切换为全开或者关， 而关只能切换到全开。</p>
<p><img    class="lazyload" data-original="https://i.loli.net/2021/08/27/LH8uPGjpYdQ9B4J.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">uTools_1630058698458.png</span></p>
<p>这些状态切换的条件全取决于最近一段时间内的统计指标， 客户端服务在调用阶段会收集一些请求和响应数据， 这些数据是具有近实时性的， 比如最近10秒或者最近一分钟的数据才被认为是有效的， 然后会按照固定的阶段时间获取有效的数据并统计得出如服务错误率的指标（采用滑动窗口的方式， 具体实现可见<a href="https://so1n.me/2021/08/24/RPC%E6%A1%86%E6%9E%B6%E7%BC%96%E5%86%99%E5%AE%9E%E8%B7%B5--%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86%E7%9A%84%E5%9F%BA%E7%9F%B3/">RPC框架编写实践–服务治理的基石</a>， 避免了毛刺现象）， 并根据指标判断当前应该是全开、半开还是关闭阶段。</p>
<p>不过， 上面这种实现的半开关不是很灵活， 从全开切换为半开需要一个固定的休眠时间， 而服务的恢复时长是不确定， 如果有一种机制能实时知道的话， 那就更好了。Google Sre的策略实现就是避免了这样的一个问题，它的思路非常简单， 就是每个窗口期计算一次当前的请求成功率， 并按照这个成功率来决定应该放行多少请求量， 同时确保即使成功率为0的时候也有少量的请求被放行， 这些被放行的少量请求就是用于探测服务是否可以用的， 它们的量级不多， 不足以让远端服务崩溃。</p>
<p>该算法理解起来简单， 实现起来也简单， 这个算法依赖于两种指标， 一个是客户端请求数， 一个是客户端请求成功的数量， 然后根据这两个指标过去两分钟内的数据判断熔断器的状态：</p>
<ul>
<li>通常客户端请求数等于客户端请求成功的数量， 此时为全开模式</li>
<li>客户端请求服务端开始出现异常，请求成功的数量逐渐减少， 此时为全开模式</li>
<li>客户端请求服务端持续的异常， 请求成功数依然来逐渐减少， 直到请求成数大于K变量乘以请求成功的量时， 进入半开模式， 会按照两个指标计算出来的概率进行限流。</li>
<li>客户端请求服务端持续的异常， 同时部分请求直接被拦截， 主动丢弃， 请求成功数的占比越来越少， 计算得出拦截的概率也在逐渐变大， 直到最大值（请求数/（请求数+1））, 此时只有极少的流量通过。</li>
<li>客户端请求服务端的异常逐步减少， 拦截的频率也逐渐变少，直到等于0， 至此， 当前的限流阶段结束， 重新进入全开模式。</li>
</ul>
<p>流程里面涉及到的概率计算则是基于以下的公式：<br>$$max(0,\frac{requests-K*accepts}{requests+1})$$</p>
<p>公式中<code>K</code>的默认值是2， 但是可以根据自己的情况进行调整， 降低<code>K</code>值会让客户端更快的进入半开模式， 增加<code>K</code>值则相反。 这个公式十分简单， 计算起来也不复杂， 即使是实时计算， 也不会怎么浪费CPU的性能， 而且Google文档中描述该算法在实际使用效果极为良好， 可以使整体上保持一个非常稳定的请求速率。</p>
<blockquote>
<p>关于K默认值为2的官方说明:</p>
<p>一般来说推荐采用K=2，通过允许后端接收到比期望值更多的请求，浪费了一定数量的后端资源，但是却加快了后端状态到客户端的传递速度。</p>
<p>举例来说，后端停止拒绝该客户端的请求之后，所有客户端检测到这个变化的耗时就会减小。另外一个考量是，客户端节流可能不适用于那些请求频率很低的客户端。在这种情况下，客户端对后端状态的记录非常有限，任何想提高状态可见度的手段相对来说成本都较高。</p>
</blockquote>
<blockquote>
<p>Google Sre对于公式的描述见:<a href="https://sre.google/sre-book/handling-overload/#eq2101">https://sre.google/sre-book/handling-overload/#eq2101</a></p>
<p>中文版见《SRE： Google运维解密》第21章客户端侧的节流机制</p>
</blockquote>
<h2 id="4-代码实现"><a href="#4-代码实现" class="headerlink" title="4.代码实现"></a>4.代码实现</h2><p>通过分析可以得出<code>Google SRE</code>弹性熔断是根据成功率动态调整的， 实现简单， 让新手简单易懂， 同时可以自动探测服务是否恢复， 也满足了自动化的特点， 所以我采用了该方法实现熔断器。</p>
<p>由于我的框架是支持双工模式的， 所以不是像HTTP/1.0的框架一样使用中间件， 而是重新定义了一个叫处理者的方案， 处理者提供了<code>process_request</code>和<code>process_exc</code>分别处理客户端请求和服务端的异常响应， 我只要统计<code>process_request</code>的调用次数即可得出请求数， 统计<code>process_exc</code>以及<code>process_request</code>的特定异常得出错误数， 并用请求数减去错误数就能得出请求成功数， 其中的特定异常是指框架里面自己封装的<code>status</code>属性值大于等于500的异常。<br>同时， 框架已经实现了一个窗口统计的类， 我是基于这个类统计的，详见文章:<a href="https://so1n.me/2021/08/24/RPC%E6%A1%86%E6%9E%B6%E7%BC%96%E5%86%99%E5%AE%9E%E8%B7%B5--%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86%E7%9A%84%E5%9F%BA%E7%9F%B3/">RPC框架编写实践–服务治理的基石</a>,以下是具体的代码实现(最新代码见<a href="https://github.com/so1n/rap/blob/master/rap/client/processor/circuit_breaker.py">circuit_breaker.py</a>)：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-comment"># 引用的库</span><br><span class="hljs-keyword">import</span> random<br><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> TYPE_CHECKING, Any, Dict, List, Optional, Tuple<br><br><span class="hljs-keyword">from</span> rap.client.model <span class="hljs-keyword">import</span> Request, Response<br><span class="hljs-keyword">from</span> rap.client.processor.base <span class="hljs-keyword">import</span> BaseProcessor<br><span class="hljs-keyword">from</span> rap.client.types <span class="hljs-keyword">import</span> CLIENT_EVENT_FN<br><span class="hljs-keyword">from</span> rap.common.collect_statistics <span class="hljs-keyword">import</span> WindowStatistics<br><span class="hljs-keyword">from</span> rap.common.exceptions <span class="hljs-keyword">import</span> BaseRapError<br><span class="hljs-keyword">from</span> rap.common.utils <span class="hljs-keyword">import</span> Constant, EventEnum<br><br><span class="hljs-keyword">if</span> TYPE_CHECKING:<br>    <span class="hljs-keyword">from</span> rap.client.core <span class="hljs-keyword">import</span> BaseClient<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CircuitBreakerExc</span>(<span class="hljs-params">Exception</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;熔断时的异常类型&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">pass</span><br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseCircuitBreakerProcessor</span>(<span class="hljs-params">BaseProcessor</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;基础熔断封装&quot;&quot;&quot;</span><br><br>    exc: Exception = NotImplementedError()<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">        self,</span></span><br><span class="hljs-function"><span class="hljs-params">        k: <span class="hljs-built_in">float</span> = <span class="hljs-number">2.0</span>,  <span class="hljs-comment"># google sre default</span></span></span><br><span class="hljs-function"><span class="hljs-params">        expire: <span class="hljs-built_in">int</span> = <span class="hljs-number">180</span>,</span></span><br><span class="hljs-function"><span class="hljs-params">        interval: <span class="hljs-built_in">int</span> = <span class="hljs-number">120</span>,  <span class="hljs-comment"># google sre default</span></span></span><br><span class="hljs-function"><span class="hljs-params">        prefix: <span class="hljs-built_in">str</span> = <span class="hljs-string">&quot;circuit_breaker&quot;</span>,</span></span><br><span class="hljs-function"><span class="hljs-params">        window_statistics: Optional[WindowStatistics] = <span class="hljs-literal">None</span>,</span></span><br><span class="hljs-function"><span class="hljs-params">    </span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        k 公式中k的值</span><br><span class="hljs-string">        expire 每个指标数据在内存中的过期时间， 每次请求都会刷新</span><br><span class="hljs-string">        interval 统计窗口时间</span><br><span class="hljs-string">        prefix 以及 window statistics是内部存储实现</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        self._prefix: <span class="hljs-built_in">str</span> = prefix<br>        self._expire: <span class="hljs-built_in">int</span> = expire<br>        self._interval: <span class="hljs-built_in">int</span> = interval<br>        self._window_statistics: WindowStatistics = window_statistics <span class="hljs-keyword">or</span> WindowStatistics()<br>        self._probability_dict: Dict[<span class="hljs-built_in">str</span>, <span class="hljs-built_in">float</span>] = &#123;&#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">upload_probability</span>(<span class="hljs-params">stats_dict: Dict[Any, <span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>            <span class="hljs-comment"># 内部存储实现， 每隔一段时间会刷新数据</span><br>            <span class="hljs-comment"># 收到统计好的数据后， 根据公式统计每个指标的概率</span><br>            _dict: Dict[<span class="hljs-built_in">str</span>, Dict[<span class="hljs-built_in">str</span>, <span class="hljs-built_in">int</span>]] = &#123;&#125;<br>            <span class="hljs-keyword">for</span> key, value <span class="hljs-keyword">in</span> stats_dict.items():<br>                <span class="hljs-keyword">if</span> key.startswith(self._prefix):<br>                    _, index, type_ = key.split(<span class="hljs-string">&quot;|&quot;</span>)<br>                    <span class="hljs-keyword">if</span> index <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> _dict:<br>                        _dict[index] = &#123;&#125;<br>                    _dict[index][type_] = value<br>            <span class="hljs-keyword">for</span> index, metric_dict <span class="hljs-keyword">in</span> _dict.items():<br>                total: <span class="hljs-built_in">int</span> = metric_dict.get(<span class="hljs-string">&quot;total&quot;</span>, <span class="hljs-number">0</span>)<br>                error_cnt: <span class="hljs-built_in">int</span> = metric_dict.get(<span class="hljs-string">&quot;error&quot;</span>, <span class="hljs-number">0</span>)<br>                self._probability_dict[index] = <span class="hljs-built_in">max</span>(<span class="hljs-number">0.0</span>, (total - k * (total - error_cnt)) / (total + <span class="hljs-number">1</span>))<br><br>        self._window_statistics.add_priority_callback(upload_probability)<br>        self.event_dict: Dict[EventEnum, List[CLIENT_EVENT_FN]] = &#123;<br>            EventEnum.after_start: [self.start_event_handle],<br>            EventEnum.before_end: [self.stop_event_handle],<br>        &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_index_from_request</span>(<span class="hljs-params">self, request: Request</span>) -&gt; str:</span><br>        <span class="hljs-string">&quot;&quot;&quot;从request获取指标的值&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">raise</span> NotImplementedError<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_index_from_response</span>(<span class="hljs-params">self, response: Response</span>) -&gt; str:</span><br>        <span class="hljs-string">&quot;&quot;&quot;从response获取指标的值&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">raise</span> NotImplementedError<br><br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">process_request</span>(<span class="hljs-params">self, request: Request</span>) -&gt; Request:</span><br>        <span class="hljs-keyword">if</span> request.msg_type == Constant.CLIENT_EVENT:<br>            <span class="hljs-comment"># 忽略掉系统探测的请求</span><br>            <span class="hljs-keyword">return</span> request<br>        index: <span class="hljs-built_in">str</span> = self.get_index_from_request(request)<br>        total_key: <span class="hljs-built_in">str</span> = <span class="hljs-string">f&quot;<span class="hljs-subst">&#123;self._prefix&#125;</span>|<span class="hljs-subst">&#123;index&#125;</span>|total&quot;</span><br>        <span class="hljs-comment"># 记录请求数</span><br>        self._window_statistics.set_gauge_value(total_key, self._expire, self._interval)<br>        <span class="hljs-keyword">if</span> random.randint(<span class="hljs-number">0</span>, <span class="hljs-number">100</span>) &lt; self._probability_dict.get(index, <span class="hljs-number">0.0</span>) * <span class="hljs-number">100</span>:<br>            <span class="hljs-comment"># 判断是否可以放行， 如果不可放行， 则记录失败信息</span><br>            error_key: <span class="hljs-built_in">str</span> = <span class="hljs-string">f&quot;<span class="hljs-subst">&#123;self._prefix&#125;</span>|<span class="hljs-subst">&#123;index&#125;</span>|error&quot;</span><br>            <span class="hljs-comment"># 内部存储的方法， 类似于Prometheus的gauge</span><br>            self._window_statistics.set_gauge_value(error_key, self._expire, self._interval)<br>            <span class="hljs-keyword">raise</span> self.exc<br>        <span class="hljs-keyword">return</span> request<br><br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">process_exc</span>(<span class="hljs-params">self, response: Response, exc: Exception</span>) -&gt; Tuple[Response, Exception]:</span><br>        <span class="hljs-comment"># 如果是Python的异常或者是自定义中状态码大于等于500的异常，则记录失败信息</span><br>        <span class="hljs-keyword">if</span> request.msg_type != Constant.CLIENT_EVENT \<br>            <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> (<span class="hljs-built_in">isinstance</span>(exc, BaseRapError) <span class="hljs-keyword">and</span> exc.status_code &lt; <span class="hljs-number">500</span>):<br>            error_key: <span class="hljs-built_in">str</span> = <span class="hljs-string">f&quot;<span class="hljs-subst">&#123;self._prefix&#125;</span>|<span class="hljs-subst">&#123;self.get_index_from_response(response)&#125;</span>|error&quot;</span><br>            <span class="hljs-comment"># 内部存储的方法， 类似于Prometheus的gauge</span><br>            self._window_statistics.set_gauge_value(error_key, self._expire, self._interval)<br>        <span class="hljs-keyword">return</span> response, exc<br>    <br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HostCircuitBreakerProcessor</span>(<span class="hljs-params">BaseCircuitBreakerProcessor</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;以host为维度的异常&quot;&quot;&quot;</span><br><br>    exc: Exception = CircuitBreakerExc(<span class="hljs-string">&quot;Service Unavailable&quot;</span>)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_index_from_request</span>(<span class="hljs-params">self, request: Request</span>) -&gt; str:</span><br>        <span class="hljs-keyword">return</span> request.header[<span class="hljs-string">&quot;host&quot;</span>][<span class="hljs-number">0</span>]<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_index_from_response</span>(<span class="hljs-params">self, response: Response</span>) -&gt; str:</span><br>        <span class="hljs-keyword">return</span> response.conn.peer_tuple[<span class="hljs-number">0</span>]<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FuncCircuitBreakerProcessor</span>(<span class="hljs-params">BaseCircuitBreakerProcessor</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;以函数名为维度的异常&quot;&quot;&quot;</span><br><br>    exc: Exception = CircuitBreakerExc(<span class="hljs-string">&quot;Service&#x27;s func Unavailable&quot;</span>)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_index_from_request</span>(<span class="hljs-params">self, request: Request</span>) -&gt; str:</span><br>        <span class="hljs-keyword">return</span> request.target<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_index_from_response</span>(<span class="hljs-params">self, response: Response</span>) -&gt; str:</span><br>        <span class="hljs-keyword">return</span> response.target<br><br></code></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>RPC框架编写实践</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>RPC</tag>
      </tags>
  </entry>
  <entry>
    <title>RPC框架编写实践--服务治理的基石</title>
    <url>/2021/08/24/RPC%E6%A1%86%E6%9E%B6%E7%BC%96%E5%86%99%E5%AE%9E%E8%B7%B5--%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86%E7%9A%84%E5%9F%BA%E7%9F%B3/</url>
    <content><![CDATA[<h2 id="前记"><a href="#前记" class="headerlink" title="前记"></a>前记</h2><p>由于服务的调用是通过网络间来调用了， 服务并不在同一个进程内， 程序可能崩溃、节点可能宕机、网络可能中断，这些意外情况其实全部都在意料之中, 微服务的一个思想就是， 所有假设会出错的东西一定会出现， 而且没办法完全避免， 只能通过一些功能去增加容错性， 稳定性和可用性， 这类功能被统称为服务治理， 大部分功能都会利用过去一段时间产生的数据来决策接下来的请求该怎么做， 而这些数据就是服务治理的基石。</p>
<span id="more"></span>
<blockquote>
<p><a href="https://so1n.me/categories/RPC%E6%A1%86%E6%9E%B6%E7%BC%96%E5%86%99%E5%AE%9E%E8%B7%B5/">RPC框架编写实践</a>系列文章是我编写框架<a href="https://github.com/so1n/rap">rap</a>的想法和总结。</p>
</blockquote>
<h2 id="1-指标数据"><a href="#1-指标数据" class="headerlink" title="1.指标数据"></a>1.指标数据</h2><p>在服务治理中的一些常见功能如限流、 负载均衡、 熔断器、监控统计等等都需要一些指标数据（Metric）, 有了这些数据， 大部分的服务治理功能才得以实践。</p>
<p>指标数据在服务治理中的位置非常重要， 它是过去一段时间内收集再统计的数据, 不是实时数据。 不直接使用实时数据是有原因的， 比如每秒QPS之类统计好的数据， 如果每次使用时都统计一次， 不仅麻烦， 还浪费性能， 而且每秒QPS的关键点是每秒， 意味它的间隔要精确到秒， 实时数据的话间隔不可控的可能大于或者小于秒； 再比如监控的数据， 它是一个单位时间内的数据汇总，而不是实时数据, 因为实时的数据会带来较大的计算开销。 对于一个监控系统来说， 实时地收集数据会让机器的CPU没有停歇的时间， 同时硬盘会被写满大量的数据， 但是有很多数据都是没用到的， 所以最好的方法就是每隔一段时间写入该时间区间内的汇总数据， 而间隔时间的大小则取决于监控的精度和计算性能之间做取舍。 </p>
<p>由指标数据的变化可以看出这些数据会经历汇聚， 固定两个阶段， 汇聚阶段只能写入/更新数据， 不可读， 固定数据只可读不可写入， 同时机器一切的资源都是有限的， 我们不会无限的存储汇总数据， 所以指标数据还会有销毁阶段， 这三个阶段每个阶段都有自己的特点：</p>
<ul>
<li>汇聚阶段（可写）： 当前的数据不可用， 会随着时间发生变化， 比如被重新设定一个新值， 或者被累加累减等</li>
<li>固定阶段（可读）： 当前的数据仅可读而不可写入。</li>
<li>销毁阶段（不可写不可读）： 当前的数据不可读不可写， 只能等待被清理。</li>
</ul>
<p>此外指标数据的状态是不可逆的， 而且会跟随着触发条件而发送变动， 当条件触发时， 固定阶段的状态会变为销毁阶段， 汇聚阶段的状态会变为固定阶段， 然后重新诞生一个新的汇聚阶段来收集数据。</p>
<h2 id="2-通过滑动窗口实现一段时间内的数据收集统计"><a href="#2-通过滑动窗口实现一段时间内的数据收集统计" class="headerlink" title="2.通过滑动窗口实现一段时间内的数据收集统计"></a>2.通过滑动窗口实现一段时间内的数据收集统计</h2><p>假设把每个指标数据的状态当成一个槽， 这个槽可以存很多<code>Metric</code>， 而且会随着固定的时间定向变动， 那么这时它的原理就会跟滑动窗口一模一样， 如下图， 指针指到的槽为汇聚阶段， 指针-1的槽为固定阶段， 指针-2的槽为销毁阶段：<br><img    class="lazyload" data-original="https://i.loli.net/2021/08/23/Yly1rP7Av6fDmC2.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">image.png</span><br>从图中可以看到， 一开始指针指向的是<code>1600000020</code>这个窗口， 当下一个窗口时间时， 指针指向<code>1600000030</code>, 而<code>1600000000</code>的窗口已经消失了。</p>
<p>同时从图中可以发现， 这个时间窗口只有3个， 而最后一个是待回收的， 没有别的操作， 对于带有GC的语言来说， 直接移除该对象的引用后就会被GC统一回收， 十分方便, 我们在实现的时候可以把固定阶段切换为销毁阶段的方法变为指定该槽的指针被移除， 随后槽就会被GC移除， 这时候需要操作的就只剩两个槽了， 而两个槽的实现就非常简单， 直接把指针进行替换即可， 以下是一个简单的实现：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> Any<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        <span class="hljs-comment"># 汇聚桶 </span><br>        self.temp_dict: <span class="hljs-built_in">dict</span> = &#123;&#125;<br>        <span class="hljs-comment"># 固定桶</span><br>        self.fixed_dict: <span class="hljs-built_in">dict</span> = &#123;&#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">set</span>(<span class="hljs-params">self, key: Any, value: Any</span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        self.temp_dict[key] = value<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get</span>(<span class="hljs-params">self, key: Any</span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        <span class="hljs-keyword">return</span> self.fixed_dict.get(key)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">replace_dict</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        <span class="hljs-comment"># 切换逻辑</span><br>        self.fixed_dict = self.temp_dict<br>        self.temp_dict = &#123;&#125;<br></code></pre></td></tr></table></figure>
<p>里面有三个方法， <code>set</code>负责把数据存入到汇聚桶中， <code>get</code>负责从固定桶获取数据， 两个方法调用的是不同的桶， 而<code>replace_dict</code>的方法就是负责替换桶。 那么， 该怎么确保每个窗口时间到的时候进行切换呢， 由于我的RPC框架是基于<code>Asyncio</code>的， 所以会考虑用到<code>Asyncio</code>来进行调度，在<code>Asyncio</code>中有个<code>loop.call_at</code>的方法， 用于指定几时执行这个函数, 假设间隔时间为10秒， 可以把方法改为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> asyncio<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        <span class="hljs-comment"># 汇聚桶 </span><br>        self.temp_dict: <span class="hljs-built_in">dict</span> = &#123;&#125;<br>        <span class="hljs-comment"># 固定桶</span><br>        self.fixed_dict: <span class="hljs-built_in">dict</span> = &#123;&#125;<br>        self.loop: asyncio.AbstractEventLoop = asyncio.get_event_loop()<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">set</span>(<span class="hljs-params">self, key: Any, value: Any</span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        self.temp_dict[key] = value<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get</span>(<span class="hljs-params">self, key: Any</span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        <span class="hljs-keyword">return</span> self.fixed_dict.get(key)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">replace_dict</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        <span class="hljs-comment"># 切换逻辑</span><br>        self.fixed_dict = self.temp_dict<br>        self.temp_dict = &#123;&#125;<br>        <span class="hljs-comment"># 表示10秒后调用replace_dict这个函数</span><br>        self.loop.call_at(self.loop.time() + <span class="hljs-number">10</span>, self.replace_dict)<br></code></pre></td></tr></table></figure>
<p>之后只要事件循环一直在运行， <code>replace_dict</code>从第一次被调用后就会被一直运行， 而且是通过事件循环运行的， 还不会出现最大递归的问题。</p>
<p>但是这里会暴露出两个问题， 一个是当窗口时间非常小时， 比如1秒， 这时候事件循环调度的误差会被扩大， 因为调度是非常复杂的， 它只能尽量的确定在那个时间点附近能调用到， 误差有多少会由很多的复杂因素共同决定的（对于线程调度等也是一样的原理）；另一个问题是当这个窗口时间被限定为1秒时， 如果要统计2秒的数据， 只能另开一个时间窗口为2秒的统计， 如果要统计3秒的数据， 就只能再开一个时间窗口为3的统计…以此类推， 会非常麻烦， 需要一种好的统一的方法来处理。</p>
<blockquote>
<p>启用一个线程在后台循环， 每隔n秒自动切换这个方案看似没问题， 但是线程也是由调用器来调度的， 当时间窗口再小一些时，也会暴露一些问题。同时我会在切换数据那里会调用一些钩子函数， 所以也会增加间隔的误差， 该方案不可采纳。</p>
</blockquote>
<h2 id="3-通过时间轮实现一段时间内的数据收集统计"><a href="#3-通过时间轮实现一段时间内的数据收集统计" class="headerlink" title="3.通过时间轮实现一段时间内的数据收集统计"></a>3.通过时间轮实现一段时间内的数据收集统计</h2><p>上面说到， 滑动窗口的方案会暴露出两个问题，导致使用体验上没那么好， 需要解决掉。</p>
<p>首先是第一个问题： 交由调度在自动切换时会存在一些调用误差。 这个问题的核心是， 数据跟时间是强相关的， 所以一定会依赖于时间, 数据的读写必须要跟时间相关， 而上面时间窗口的方案使用的是被动切换的， 他会降低时间的准确性， 那被动方案不行就可以反过来， 使用主动切换。 </p>
<p>主动切换的逻辑是根据操作时的时间来判断要操作哪个槽， 再读取数据或者写入数据（性能会稍微降低）, 这个方案需要把读写的逻辑改一下：</p>
<ul>
<li>1.首先存储的数组要把销毁阶段的槽复原，不然在极端的情况下写入和读取的下标可能会一致的， 这时候这个数组的长度为3， 然后记录一个开始时间。</li>
<li>2.假设间隔为1秒， 每次读写数据时， 就会根据当前时间与起始时间的差除以1再与数组长度求出余数， 余数的范围在0， 1， 2之中，而这个0， 1， 2刚好是存数据的数组的下标范围， 随着时间的推移， 得到的下标会一直以0， 1， 2， 0， 1， 2一直循环变化着。</li>
<li>3.基本逻辑都搞定了， 但是每次读取数据的时间是不固定的， 比如第一次写入数据时， 刚好命中下标0， 第二次写入数据时， 刚好命中下标2，如果刚好遇到读数据1, 这时候要识别这里1的数据并不是有效的， 同时0， 1， 2这样一直循环着， 1可能已经走到第二轮了， 2还是第一轮的数据， 所以这时候就需要有个变量来标记轮数， 而轮数也很简单， 就是当前时间与起始时间相差再于时间间隔取商。</li>
</ul>
<p>大概逻辑了解完了， 可以把上面的代码进行改写， 改写完代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> Dict, List, Tuple<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        <span class="hljs-comment"># 首先那个销毁的桶要复原, 不然在极端情况下会导致放置和获取的下标是一致的， 然后就像真正的滑动窗口一样变为一个数组 </span><br>        <span class="hljs-comment"># 元素中cnt代表这是第几轮的数据</span><br>        self.bucket_list: List[Tuple[<span class="hljs-built_in">dict</span>]] = [&#123;<span class="hljs-string">&#x27;cnt&#x27;</span>: <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-string">&#x27;cnt&#x27;</span>: <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-string">&#x27;cnt&#x27;</span>: <span class="hljs-number">0</span>&#125;]<br>        <span class="hljs-comment"># 总长度</span><br>        self.bucket_len: <span class="hljs-built_in">int</span> = <span class="hljs-built_in">len</span>(self.bucket_list)<br>        <span class="hljs-comment"># 设置一个变量， 记录开始时间 </span><br>        self.start_timestamp: <span class="hljs-built_in">float</span> = time.time()<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_index</span>(<span class="hljs-params">self</span>) -&gt; Tuple[int, int]:</span><br>        <span class="hljs-comment"># *1000是兼容有些间隔是毫秒的</span><br>        <span class="hljs-comment"># 返回的数据中， 第一个为数组下标(也就是指针)， 第二个代表第几轮</span><br>        diff: <span class="hljs-built_in">int</span> = <span class="hljs-built_in">int</span>((time.time() - self.start_timestamp) * <span class="hljs-number">1000</span>)<br>        <span class="hljs-keyword">return</span> diff % self.bucket_len, diff // self.bucket_len<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">set</span>(<span class="hljs-params">self, key: Any, value: Any</span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        index, cnt = self.get_index()<br>        bucket: <span class="hljs-built_in">dict</span> = self.bucket_list[index]<br>        <span class="hljs-keyword">if</span> bucket[<span class="hljs-string">&#x27;cnt&#x27;</span>] != cnt:<br>            <span class="hljs-comment"># 轮次不一样需要初始化</span><br>            bucket = &#123;key: value, <span class="hljs-string">&#x27;cnt&#x27;</span>: cnt&#125;<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-comment"># 轮次一样更新数据</span><br>            bucket[key] = value<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get</span>(<span class="hljs-params">self, key: Any</span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        index, cnt = self.get_index()<br>        index = index - <span class="hljs-number">1</span><br>        <span class="hljs-comment"># 获取的数据要小于当前的指针</span><br>        <span class="hljs-keyword">if</span> index == -<span class="hljs-number">1</span>:<br>            index = self.bucket_len - <span class="hljs-number">1</span><br>        bucket: <span class="hljs-built_in">dict</span> = self.bucket_list[index]<br>        <span class="hljs-keyword">if</span> bucket[<span class="hljs-string">&#x27;cnt&#x27;</span>] != cnt:<br>            <span class="hljs-comment"># 轮次不一样, 代表数据不存在</span><br>            <span class="hljs-keyword">raise</span> KeyError(key)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-comment"># 轮次一样更新数据</span><br>            <span class="hljs-keyword">return</span> bucket.get(key)<br></code></pre></td></tr></table></figure>
<p>代码非常简单， 移除了<code>replace_dict</code>这个被动切换的逻辑， 改为每次<code>set</code>和<code>get</code>来计算应该落到哪个区间。 这样第一个问题就解决了， 可以来考虑第二个问题， 从问题一中的代码可以发现里面的<code>bucket_list</code>虽然是一个数组， 但通过时间和数组长度算出的商来获得下标会一直以0， 1， 2， 0， 1，2循环， 所以实际运行起来就像一个时间轮一直转着，新的轮次的数据会覆盖旧的轮次， 而这个时间轮的槽总量不变的， 如下图（draw.io画出来的有点点丑）:</p>
<p><img    class="lazyload" data-original="https://i.loli.net/2021/08/24/gyLDAPQCzHk21NM.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">uTools_1629791108206.png</span></p>
<p>而时间轮也是刚好可以解决问题二的一个方案， 首先假设我们的时间间隔为60秒， 如果要兼容1秒， 2秒，3秒，4秒，5秒等多种的时间间隔统计， 那么就可以取他们的最小公因数1作为一个子间隔， 它需要60个槽位, 我们可以把时间轮当成一个整体， 然后把这个时间轮切为60个等份的槽， 再通过时间来算出指针要指向哪个槽位（指针会跟着操作时间与时间轮总槽数取的余数来变化）， 写数据时会写入指针指定的槽位， 这个槽位也就是汇聚数据槽， 而指针逆时针方向后面的槽位根据是否有数据来区分固定槽和空槽（初始化时， 所有槽位都是空槽， 第一次写了数据后就只能成为固定槽或者汇聚槽）， 取数据只能取当前指针后面的， 且是本轮的数据且不为空槽的数据 。 </p>
<p>然后1秒间隔的统计只取指针后面一格的槽数据， 2秒间隔的统计只取指针后面两格的槽数据求和， 3秒间隔的统计只取指针间隔后面三格的槽数据求和， 以次类推， 这样就能以一个类来兼容多种时间间隔的统计了。不过这个方案有个缺点， 就是上述的时间轮有60个槽位， 一个槽被定义会数据汇聚槽， 那剩下的最多只有59个固定槽可以获取数据， 还缺少一个槽位， 这时候就需要进行补槽处理， 比如60个槽就可以拓展为65个槽， 然后限制只能获取最近的60个槽即可， 剩下的5个槽可以用来当做缓冲位， 重新更改后的代码如下：</p>
<blockquote>
<p>这个方案是兼容小范围的数据， 使用1分钟的时间间隔来兼容秒级的时钟间隔， 如果要兼容大范围的时间间隔， 比如5分钟， 10分钟，15分钟等等， 则可以采用指针式时钟一样的方案。 如果你了解<code>Kafka</code>的时间轮设计， 就可以知道<code>Kafka</code>有多层时间轮， 小层转动一层， 大层就转动一格（就像秒指针跑完一圈， 分指针就动一格一样）， 等到大层的数据的到期时间范围小于等于小层时， 数据就会流向小层。不过服务治理的数据还是需要尽量的有效， 所以它的时间跨度一般不会超过一分钟。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> Dict, List, Tuple<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, max_interval: <span class="hljs-built_in">int</span> = <span class="hljs-number">60</span>, min_interval: <span class="hljs-built_in">int</span> = <span class="hljs-number">1</span></span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        self.max_interval = max_interval<br>        <span class="hljs-comment"># 算出有多少个槽</span><br>        self.bucket_len: <span class="hljs-built_in">int</span> = (max_interval // min_interval) + <span class="hljs-number">5</span><br>        <span class="hljs-comment"># 设置槽，元素中第一位代表这是第几轮的数据， 方便覆盖</span><br>        self.bucket_list: List[<span class="hljs-built_in">dict</span>] = [&#123;<span class="hljs-string">&#x27;cnt&#x27;</span>: <span class="hljs-number">0</span>&#125; <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(self.bucket_len)]<br>        <span class="hljs-comment"># 设置一个变量， 记录开始时间 </span><br>        self.start_timestamp: <span class="hljs-built_in">float</span> = time.time()<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_index</span>(<span class="hljs-params">self</span>) -&gt; Tuple[int, int]:</span><br>        <span class="hljs-comment"># *1000是兼容有些间隔是毫秒的</span><br>        <span class="hljs-comment"># 返回的数据中， 第一个为数组下标(也就是指针)， 第二个代表第几轮</span><br>        diff: <span class="hljs-built_in">int</span> = <span class="hljs-built_in">int</span>((time.time() - self.start_timestamp) * <span class="hljs-number">1000</span>)<br>        <span class="hljs-keyword">return</span> diff % self.bucket_len, diff // self.bucket_len<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">set</span>(<span class="hljs-params">self, key: Any, value: Any</span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        index, cnt = self.get_index()<br>        bucket: <span class="hljs-built_in">dict</span> = self.bucket_list[index]<br>        <span class="hljs-keyword">if</span> bucket[<span class="hljs-string">&#x27;cnt&#x27;</span>] != cnt:<br>            <span class="hljs-comment"># 轮次不一样需要初始化</span><br>            bucket = &#123;<span class="hljs-string">&#x27;cnt&#x27;</span>: cnt, key: value&#125;<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-comment"># 轮次一样更新数据</span><br>            bucket[<span class="hljs-number">1</span>][key] = value<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get</span>(<span class="hljs-params">self, key: Any, diff: <span class="hljs-built_in">int</span> = <span class="hljs-number">0</span></span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        <span class="hljs-comment"># 新增diff参数， 用于指定要获取从指针后到第几个槽的数据</span><br>        <span class="hljs-keyword">if</span> diff &gt; max_interval:<br>            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">f&quot;diff:<span class="hljs-subst">&#123;diff&#125;</span> &gt; <span class="hljs-subst">&#123;max_interval&#125;</span>&quot;</span>)<br>        index, cnt = self.get_index()<br>        value: <span class="hljs-built_in">int</span> = <span class="hljs-number">0</span><br><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(diff):<br>            bucket: <span class="hljs-built_in">dict</span> = self.bucket_list[index - i]<br>            <span class="hljs-keyword">if</span> bucket[<span class="hljs-string">&#x27;cnt&#x27;</span>] != cnt:<br>                <span class="hljs-keyword">break</span><br>            value += bucket.get(key, <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> value<br></code></pre></td></tr></table></figure>
<p>上面的代码是一个简单的实现， 为了做到可用， 还需要增加一些逻辑, 以及优化读写的一些性能， 同时还可以根据自己的需求增加一些功能， 比如我在实现时就增加了一些功能：</p>
<ul>
<li>在指标数据中， 会区分<code>Gauge</code>和<code>Count</code>两种， 一种是稳定实时变化的， 对应的只获取最新的固定数据槽的数据即可， 一种是累加的， 要把这段时间的所有槽位数据都累加起来， 为了能做到区分， 需要为每种数据都加上类型标识。</li>
<li><code>get</code>的方式比较繁琐， 如果能缓存起来会好一些， 减少读取时的性能损耗。或者有些数据需要被动的等待推送， 这时候还是可以调用上面的callback模式， 比如每5秒调用一次， 虽然5秒执行一次数据， 但是由于时间轮的存在， 这时候还是可以获取最近一轮的数据的。</li>
</ul>
<p>最后实现起来的代码会比较长， 可以访问我在<a href="https://github.com/so1n/rap">rap</a>框架中实现的代码<a href="https://github.com/so1n/rap/blob/master/rap/common/collect_statistics.py">collect_statistics.py</a></p>
]]></content>
      <categories>
        <category>RPC框架编写实践</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>RPC</tag>
      </tags>
  </entry>
  <entry>
    <title>RPC框架编写实践--最小RPC框架的依赖</title>
    <url>/2021/08/19/RPC%E6%A1%86%E6%9E%B6%E7%BC%96%E5%86%99%E5%AE%9E%E8%B7%B5--%E6%9C%80%E5%B0%8FRPC%E6%A1%86%E6%9E%B6%E7%9A%84%E4%BE%9D%E8%B5%96/</url>
    <content><![CDATA[<h2 id="前记"><a href="#前记" class="headerlink" title="前记"></a>前记</h2><p>在2019上半年时， 项目需要用到<code>RPC</code>来为不同服务间建立连接, 便开始调研<code>RPC</code>相关的内容， 由于项目本身是基于<code>Asyncio</code>生态的， 所以就开始找基于<code>asyncio</code>生态的<code>RPC</code>框架， 那时候<code>Python</code>上关于<code>Asyncio</code>的<code>RPC</code>框架比较少, 只有一个<a href="https://github.com/choleraehyq/aiorpc">aiorpc</a>, 它能满足<code>RPC</code>的基本功能, 但缺少了其他的<code>RPC</code>框架带有的服务治理功能(称为服务管理会不会更好点???), 所以在那时候开始， 我就想开始造一个<code>Python Asyncio</code>生态的<code>RPC</code>框架–<a href="https://github.com/so1n/rap">rap</a>, 这个项目除了满足在任一语言的<code>RPC</code>的功能外(虽然其他语言的没编写…), 还要满足快;核心功能简单;可以单独为python提供高阶功能; 在没其他服务依赖的情况下就能单独使用, 同时又可以通过插件的形式进行功能拓展。<br>而<a href="https://so1n.me/categories/RPC%E6%A1%86%E6%9E%B6%E7%BC%96%E5%86%99%E5%AE%9E%E8%B7%B5/">RPC框架编写实践</a>系列文章是我编写这个框架时的想法和总结。</p>
<span id="more"></span>
<blockquote>
<p>注：由于用到了<code>Asyncio</code>所以他有一些<a href="https://python-gino.org/docs/zh/1.1b2/explanation/async.html#pros-and-cons">利弊</a></p>
</blockquote>
<h2 id="1-RPC框架需要什么"><a href="#1-RPC框架需要什么" class="headerlink" title="1.RPC框架需要什么"></a>1.RPC框架需要什么</h2><p>毫无疑问， RPC框架最重要的部分就是RPC, RPC的全称为远程过程调用, 它的本质是客户端把用户的本地调用转化成一个消息， 通过一个连接发送到服务端, 而服务端根据收到的消息进行解析, 并根据消息调用函数再计算结果， 最后把结果返回给客户端， 并由客户端返回给用户的过程。</p>
<p>而RPC框架则是上述调用过程的封装， 使得调用者可以通过RPC框架像调用本地函数一样调用远程的函数， 从而无须关注底层细节。<br>那这个调用过程需要什么呢？ 我先设想了一个最简单的业务–用户调用一个<code>foo</code>函数:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span>(<span class="hljs-params">a: <span class="hljs-built_in">int</span>, b: <span class="hljs-built_in">int</span></span>) -&gt; int:</span><br>    <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure>
<p>然后再把这个业务的调用转换为一个设想的RPC请求流程， 便是如下图：<br><img    class="lazyload" data-original="https://i.loli.net/2021/08/20/nFvkjBZrUIXRoe3.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">image.png</span><br>可以看出RPC框架需要先把调用的函数签名根据应用层协议进行转换， 通过连接把数据传输到服务端； 服务端在收到请求后根据应用层协议提取信息， 并根据信息查找对应的函数再进行调用， 最后把生成的结果返回给客户端， 由客户端处理后返回给用户。此外， 由于要传输信息， 序列化和反序列化是必不可少的。<br>从整个流程可以发现， 一个RPC框架起码要拥有应用层协议， 序列化与反序列化， 以及网络传输, 完成了这几点， 就能编写出一个最简单的RPC框架。</p>
<h2 id="2-传输层协议"><a href="#2-传输层协议" class="headerlink" title="2.传输层协议"></a>2.传输层协议</h2><p>目前RPC框架的协议一般都是多种协议组合在一起的， 有传输层协议， 应用层协议等等（采用OSI模型分层， 下同）。<br>目前传输层协议有两种， 一种是TCP, 它传输稳定可靠，能尽量的保障信息不丢包。 而另一种是UDP， 它的可定制性很强， 传输的性能开销小， 但跨网络时会有可能丢包。<br>而RPC框架要做到适用性和可用性都比较强， 所以目前的RPC框架的传输层协议都是选用了TCP协议(只有用在内网网络的才会去考虑UDP)， 而我也选择了TCP作为了我的传输协议。</p>
<h2 id="3-应用层协议"><a href="#3-应用层协议" class="headerlink" title="3.应用层协议"></a>3.应用层协议</h2><p>通过调研发现， 目前是开源RPC框架要不就是基于TCP协议来开发自己的应用层协议， 要不就是直接使用HTTP来作为自己的应用层协议。这两种方式都各有各的优势， 选用HTTP作为应用层协议， 就能拥有成熟的生态，可以使用<code>Nginx</code>等中间件， 但是HTTP请求会传输很多字段， 有些字段可能是永远都用不到了，会浪费传输性能， 而选择了自己定制应用层协议， 则不能使用一些成熟的中间件， 但能尽量的使请求体保持简单， 在经过综合考虑后， 我选择了自己定制应用层协议。</p>
<p>在定制应用层协议之前， 需要先想清楚需要基于应用层协议来实现哪些功能，在查阅了一些RPC框架后， 我确定了几个基本的功能：</p>
<ul>
<li><code>one-by-one</code>形式的收发消息： 这个功能用于最基础的收发消息。</li>
<li>双工形式的收发消息： 目前市面上的RPC框架都支持该类型的消息， HTTP也通过WebSocket来支持双工收发消息， 我也想让我的框架支持这种消息， 并且命名为<code>Channel</code></li>
<li>控制连接状态的消息： 为了让连接保持稳定以及及时发现错误， 需要通过<code>Keep-Alive</code>机制来保活， 而这类消息是独立在用户调用的消息之外的。</li>
<li>加快传输速度： 由于RPC框架会承担很大的流量， 同时要为用户保障性能和足够低的响应时间， 所以就需要尽量的加快传输速度， 同时也不要增加太多系统占用。</li>
</ul>
<p>确定好了基本功能后就可以开始制定协议了， 好的协议必须拥有良好的拓展性和简洁性, 由于我也是第一次订制私有协议, 还在探索中, 所以就从HTTP协议里面吸取一些灵感(少部分从AMQP协议吸取灵感)。</p>
<p>首先是HTTP/1, 也就是用得最多的HTTP请求形式–<code>one-by-one</code>， 这种请求只会请求一次响应一次， 如果没有进行优化， 每次请求都会经历创建TCP， 进行请求， 读取响应，销毁TCP四个阶段， 而TCP的创建和销毁是非常浪费性能并且会增加很多时间。 所以到了后面HTTP就开始支持连接复用， 也就是持久化连接， 这种方式可以让客户端对同一域名长期持有一个或多个不会用完即断的TCP连接， 典型的做法就是客户端维护一个FIFO队列， 在每次取完数据之后一段时间先不自动断开连接, 而是放回队列里，以便在获取下一个资源时直接复用，省去了TCP创建销毁的成本。<br>但是， 连接复用这一技术并不完美， 它最明显的副作用就是<code>队首阻塞</code>的问题， 比如有两个请求A和B，他们使用了同一个TCP连接， 当A请求发送后且对应的服务端一直没有响应时， B请求就得一直等待， 直到TCP连接收到了A请求的响应。 实际上TCP连接是可以近乎同时发送A请求和B请求, 也可以近乎同时收到A响应和B响应， 但是HTTP/1.0并无法识别这个响应是那个请求产生的。<br>到了HTTP/2, 它就开始利用TCP的流机制， 在HTTP/2中， 帧是最小粒度的信息单位，它可以用来描述各种数据，譬如请求的Headers、Body，或者用来做控制标识，譬如打开，关闭连接等。 同时每个帧都附带了一个流ID以标识这个帧是属于哪个流， 这样子客户端就可以根据标识ID将不同的响应与请求一一配对，从而解决了无法识别同一连接在同一时刻收到两个请求的问题。 这个设计的HTTP/2的最重要的技术特征之一，它被称为HTTP/2多路复用。</p>
<blockquote>
<p>在习惯<code>one-by-one</code>后初识HTTP/2的多路复用可能很难转变过来， 我在理解的时候， 会把一个HTTP连接比作一条河流, 每个请求相当于一个货物， 发送者发送货物时会给货物打上自己的标记， 然后交由船来运输， 有的船都会载上货物从A地驶向B地， 有的船会载上货物从B地驶向A地， 他们不用关心货物是什么， 而货物都有自己的一个标识， 码头根据标识就可以知道这个货物是那个请求发出， 要收回什么请求。</p>
</blockquote>
<p>从HTTP协议的迭代史可以发现， HTTP是在逐渐的提高对TCP连接的复用, 从而减少资源的浪费， 而对于RPC来说, 它天生需要极好的传输性能和较少的机器成本开销， 同时从客户端建立连接时创建的连接会一直存在， 直到双方有一方出现异常等原因才会断开连接， 所有请求通过连接来传输数据， 场景十分简单， 所以它会更需要多路复用。</p>
<p>那要怎么实现多路复用呢? 大概步骤如下：</p>
<ul>
<li>请求函数在进行请求之前会分配到一个唯一的标签， 然后会通过标签在一个共享容器创建一个空位置等待数据的到来， 接着会按照协议把标签放到请求体里面, 并发送给服务端。</li>
<li>服务端收到请求生成响应时就会按照协议把该标签放入到响应体中并返回数据到客户端的连接。</li>
<li>客户端的连接在创建的时候会启动一个后台任务, 这个任务会一直从连接读取数据， 如果有数据来了， 就会解析数据， 根据协议提取标签并把数据放到容器的指定位置， 如果没有找到对应的位置则需要丢弃数据（证明这个连接没发送过该标签的数据）。</li>
<li>请求函数从空位置中等到数据的到来， 会返回给用户， 并且删除该位置， 防止内存溢出。</li>
</ul>
<p>以下是简单的伪代码说明（具体源码可以见：<a href="https://github.com/so1n/rap/blob/master/rap/client/transport/transport.py%EF%BC%89">https://github.com/so1n/rap/blob/master/rap/client/transport/transport.py）</a>:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-comment"># 伪代码</span><br><span class="hljs-comment"># 确定好传输的为 id, header, body</span><br><span class="hljs-comment"># 响应体传输的为 id, header, status_code, body</span><br><span class="hljs-comment"># 两者的id用来识别属于哪个请求</span><br><span class="hljs-comment"># 只要确保每个请求有不一样的id就可以实现了连接复用了</span><br><br><span class="hljs-comment"># 首先有个dict用于存放已经发送请求,但没收到响应的future(asyncio.Future())</span><br>future_dict = <span class="hljs-built_in">dict</span>()<br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">response</span>():</span><br>    <span class="hljs-comment"># 统一处理响应, 会有一个程序让他后台运行</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    	<span class="hljs-keyword">try</span>:<br>    		<span class="hljs-comment"># 按照协议从连接取出响应数据</span><br>    	    msg_id, header, status_code, body = <span class="hljs-keyword">await</span> conn.read() <br>    	<span class="hljs-keyword">except</span> ValueError:<br>    	    <span class="hljs-keyword">return</span><br>    	<span class="hljs-comment"># 把结果存入future中,这样request就能收到响应了</span><br>        <span class="hljs-keyword">if</span> msg_id <span class="hljs-keyword">in</span> future_dict:<br>    		future_dict[msg_id].set_result(Response(msg_id, header, status_code, body))<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">request</span>():</span><br>    <span class="hljs-comment"># 请求体</span><br>    request = (msg_id, header, body)<br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-comment"># 设置等待响应的future</span><br>        future_dict[msg_id] = asyncio.Future()<br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-comment"># 表示通过连接conn发送请求</span><br>            <span class="hljs-keyword">await</span> conn.write(request)<br>        <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>            <span class="hljs-keyword">raise</span> e<br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-comment"># 等待响应,超过9秒没响应则报请求超时</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> asyncio.wait_for(future_dict[msg_id], <span class="hljs-number">9</span>)<br>        <span class="hljs-keyword">except</span> asyncio.TimeoutError:<br>            <span class="hljs-keyword">raise</span> asyncio.TimeoutError(<span class="hljs-string">f&quot;msg_id:<span class="hljs-subst">&#123;msg_id&#125;</span> request timeout&quot;</span>)<br>    <span class="hljs-keyword">finally</span>:<br>        <span class="hljs-comment"># 删除future, 回收资源</span><br>        future_dict.pop(msg_id, <span class="hljs-literal">None</span>)<br></code></pre></td></tr></table></figure>

<p>了解完了多路复用可以发现， 协议中有一个必不可少的字段， 这个字段就是上面所说的消息标签， 这个字段我在协议中命名为相关id, 此外在了解连接复用的时候， 我也顺便了解了HTTP协议的设计， 通过HTTP协议的设计， 我从中提取了几个字段, 最后整合成以下几个字段：</p>
<ul>
<li>消息id： 这个消息id是单调递增的， 可以让双方知道是否有消息重发以及为以后功能做拓展。</li>
<li>协议版本： 一般协议都会随着迭代而发生变化， 所以需要一个字段来标识当前的协议版本是哪个， 方便客户端和服务端针对性的识别。同时， 这个字段应该尽量的处在协议的最前面， 因为它是最不可能发生更改的。</li>
<li>消息类型： 从HTTP/2的设计可以看出， HTTP/2会单独传送一个请求来控制打开和关闭连接， 此外还会发送<code>keep alive</code>请求来保持与服务端的连通， 这类请求与普通的<code>one-by-one</code>请求是不一样的。 而且我还希望有类型<code>websocket</code>的场景， 他也与上述两种请求类型不一样的， 所以就需要一个字段来区分他们的类型, 具体的类型如下：<ul>
<li><code>event</code>: 这类消息用来控制传输的连接状态和行为, 这类请求允许客户端和服务端都可以收发，比如<code>ping</code>, <code>pong</code>以及确定连接生命周期的<code>declare</code>, <code>msg</code>, <code>drop</code>等等。</li>
<li><code>msg</code>: 这类消息跟传统HTTP/1很像, 也是最经典常见的消息模型，他只接受一发一收，收发的相关id必须一致</li>
<li><code>channel</code>： 这类消息可以类似于<code>Websocket</code>, 是一种可以同时双向收发的消息模型， 也可以改为一发多收或者多发一收， 完全由实现者自己定义。</li>
</ul>
</li>
<li>相关id: 这个值的存在就是为了实现上面所说的多路复用， 客户端通过相关id可以找到这个响应是哪个请求的响应。</li>
<li>目标url: 这个字段就像HTTP的URL一样, 客户端可以通过url找到服务端对应的路由函数。 不过对于RPC来说url没必要那么长， 一般rpc的目标函数匹配都是通过哪个组， 组里面的哪个函数来查找， 所以url会以<code>/&#123;group&#125;/&#123;func name&#125;</code>来表示。  </li>
<li>header： 协议的设计不仅要精简， 也要容易拓展， HTTP中的header就很方便用户自定义拓展, 所以我也采用了header字段</li>
<li>body： 该字段存的是响应体和请求体，也是类似于HTTP.body。</li>
<li>status code： 该字段跟HTTP一样，只有响应的时候才有的， 小于300的为正常请求， 大于300小于400的为功能上的拓展， 大于400小于500的为异常请求， 大于500则是有破坏性的异常。</li>
</ul>
<p>需要的字段确定完后， 就可以排列成一个协议， 按照简单和变动比较少的放前面的原则， 最终请求消息协议定义为:</p>
<figure class="highlight d"><table><tr><td class="code"><pre><code class="hljs d"># 消息id, 协议版本, 消息类型， 相关id, 目标url, header, <span class="hljs-keyword">body</span><br>msg_id, <span class="hljs-keyword">version</span>, msg_type, correlation_id, target, header, <span class="hljs-keyword">body</span><br></code></pre></td></tr></table></figure>
<p>响应消息协议则定义为：</p>
<figure class="highlight d"><table><tr><td class="code"><pre><code class="hljs d"># 消息id, 协议版本, 消息类型， 相关id, 目标url, status_code, header, <span class="hljs-keyword">body</span><br>msg_id, <span class="hljs-keyword">version</span>, msg_type, correlation_id, target, status_code, header, <span class="hljs-keyword">body</span><br></code></pre></td></tr></table></figure>
<p>现在， 应用层协议终于定制完了， 但是还是不够， 因为程序里的在读写的协议实际上还都是存在内存中的数据结构或对象， 然而网络传输只传输二进制编码, 同时不同的语言中的对象类型的表达方式是不一样的， 所以需要一种通用的且能把数据结构或对象转换为二进制编码的方法–序列化, 以及反向操作–反序列化。</p>
<h2 id="4-序列化与反序列化"><a href="#4-序列化与反序列化" class="headerlink" title="4.序列化与反序列化"></a>4.序列化与反序列化</h2><p>序列化与反序列化是网络传输中的重中之重, 本质上也是一个协议， 大概处于OSI模型的表示层。<br>一般人接触最多的序列化协议是Json, 它通用， 成熟， 调试起来也非常方便， 但是占用空间大， 序列化时也会比较久， 从而影响了传输的性能， 所以我并没有挑选Json作为我的序列化协议(之前在使用<code>starlette</code>框架时知道<code>Python</code>中有<code>ujson</code>和<code>ojson</code>两个库, 它们本质上也都是Json, 但是通过特定的方法减少了序列化时对CPU的性能影响）。<br>但是我没有能力开发一个成熟稳定的序列化协议， 所以只能在开源协议中挑选， 开源的序列化协议每种都有优点和缺点，它们在设计之初有自己独特的应用场景， 而在挑选序列化协议时， 我根据以下几点进行分析：</p>
<ul>
<li>通用性： 也就是这种协议是否支持跨平台， 跨语言， 不过不支持， 那通用性就会大大降低。</li>
<li>流行性： 流行性主要是用的人多不多， 如果用的人不多， 资料会比较少， 解决坑的速度也会变慢。</li>
<li>成熟性： 协议是否成熟， 部分序列化协议诞生的时候性能很强， 但功能不多， 同时也不稳定， 不安全， 如果想要做一个稳定的RPC框架， 使用的序列化协议也必须成熟稳定。</li>
<li>空间占用： 如果序列化后占用的空间还是比较多， 会增加网络的传输压力， 减少响应时间。</li>
<li>时间占用： 如果序列化协议比较复杂， 那解析时间就会比较久， 占用更多的CPU时间， 由于我使用<code>Python asyncio</code>生态进行开发， 复杂的协议会导致占用CPU时间比较多, 会降低QPS， 所以这类协议不能挑选。<br>除此之外还有一个是可读性， 人们容易阅读可读性高的序列化协议， 这样的话调试会十分方便， 但增加可读性必定会导致空间占用大， CPU解析时间久， 所以这一特性不纳入我的考虑范围内。</li>
</ul>
<p>在经过寻找后， 我发现了<code>msgpack</code>这个序列化协议， 它是一个二进制的Json序列化协议， 与Json很像， 但是还是有一些区别, 如下图：<br><img    class="lazyload" data-original="https://i.loli.net/2021/08/20/3NjxH86bgmGh9uo.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">uTools_1629389662645.png</span><br>这是官网的一个截图， 它介绍一个数据结构序列化后Json和<code>msgpack</code>的占用空间大小和结果， 可以看出它针对网络传输进行了设计， 序列化的结果本身非常的紧凑， 体积减小了很多， 这样可以减少网络传输的流量， 提高了传输的性能， 同时通过它的文档了解到它的使用方法跟Json差不多， 对使用者而言它的使用方法跟Json差不多， 没多少学习成本, 对于我的需要来说简直是完美搭配的。</p>
<blockquote>
<p>对于序列化的一些见解， 以及一些序列化的对比可见<a href="https://tech.meituan.com/2015/02/26/serialization-vs-deserialization.html">序列化和反序列化</a></p>
</blockquote>
<blockquote>
<p><code>maspcak</code>基准测试可以见：<a href="https://github.com/alecthomas/go_serialization_benchmarks">https://github.com/alecthomas/go_serialization_benchmarks</a> 或者是：<a href="https://github.com/endel/msgpack-benchmark">https://github.com/endel/msgpack-benchmark</a></p>
</blockquote>
<h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5.总结"></a>5.总结</h2><p>调研完了传输协议， 序列化协议， 以及定制好了自己的传输协议后， 就可以开始写一个最简单的RPC框架了, 但是展示所有代码会占用大量篇幅， 所以这里会以图展示一个简单的请求流程， 首先是连接的生命周期流程：<br><img    class="lazyload" data-original="https://i.loli.net/2021/08/21/ZTOr8FhIecp7GEt.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">image.png</span><br>然后是每个请求的流程（与一开始构想的流程很像）：<br><img    class="lazyload" data-original="https://i.loli.net/2021/08/21/Ej3dvTzMVRycZ1t.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">image.png</span></p>
<p>从图里可以看出， 图里除了上面描述的东西外， 还多了一些钩子， 这是因为图里所示只是完成一个最基本的RPC框架， 它只满足了最简单的远程过程调用功能。 但是RPC涉及到了网络传输， 有了很多不确定的因素， 所以框架还需要一些服务治理的相关功能, 而这些功能大部分将通过钩子进行拓展， 后面将慢慢介绍这些服务治理的相关功能， 有些是单独出现， 有些是组合出现。</p>
]]></content>
      <categories>
        <category>RPC框架编写实践</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>RPC</tag>
      </tags>
  </entry>
  <entry>
    <title>uvicorn源码分析</title>
    <url>/2021/08/19/uvicorn/</url>
    <content><![CDATA[<h2 id="前记"><a href="#前记" class="headerlink" title="前记"></a>前记</h2><p><code>Uvicorn</code>是一个基于<code>uvloop</code>和<code>httptools</code>的ASGI服务器, 性能比较强劲， 通过它可以与使用ASGI规范的<code>Python</code>应用程序进行交互。ASGI与WSGI很像， 只不过ASGI原生支持HTTP2.0和WebSocket， 同时更多的是支持<code>Python</code>的<code>Asyncio</code>生态的WEB应用程序。通过了解<code>Uvicron</code>，能知道一个稳定的Web服务器的工作方式以及能更好的去了解其他基于ASGI的WEB应用程序</p>
<span id="more"></span>
<p><code>Uvicron</code>通过一个通用的协定接口与ASGI应用程序交互， 应用程序只要实现如下代码， 即可通过<code>Uvicorn</code>发送和接收信息：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">app</span>(<span class="hljs-params">scope, receive, send</span>):</span><br>    <span class="hljs-comment"># 一个最简单的ASGI应用程序</span><br>    <span class="hljs-keyword">assert</span> scope[<span class="hljs-string">&#x27;type&#x27;</span>] == <span class="hljs-string">&#x27;http&#x27;</span><br>    <span class="hljs-keyword">await</span> send(&#123;<br>        <span class="hljs-string">&#x27;type&#x27;</span>: <span class="hljs-string">&#x27;http.response.start&#x27;</span>,<br>        <span class="hljs-string">&#x27;status&#x27;</span>: <span class="hljs-number">200</span>,<br>        <span class="hljs-string">&#x27;headers&#x27;</span>: [<br>            [<span class="hljs-string">b&#x27;content-type&#x27;</span>, <span class="hljs-string">b&#x27;text/plain&#x27;</span>],<br>        ]<br>    &#125;)<br>    <span class="hljs-keyword">await</span> send(&#123;<br>        <span class="hljs-string">&#x27;type&#x27;</span>: <span class="hljs-string">&#x27;http.response.body&#x27;</span>,<br>        <span class="hljs-string">&#x27;body&#x27;</span>: <span class="hljs-string">b&#x27;Hello, world!&#x27;</span>,<br>    &#125;)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    <span class="hljs-comment"># uvicorn服务</span><br>    <span class="hljs-keyword">import</span> uvicorn<br>    uvicorn.run(app, host=<span class="hljs-string">&quot;127.0.0.1&quot;</span>, port=<span class="hljs-number">5000</span>, log_level=<span class="hljs-string">&quot;info&quot;</span>)<br></code></pre></td></tr></table></figure>
<p>其中应用程序的<code>scope</code>代表有关传入连接信息的字典， <code>receive</code>是一个从服务器接收传入信息的通道, <code>send</code>是一个将消息发送到服务器的通道, 不过这不是本文的重点， 更多<code>scope</code>信息可以访问<a href="http://www.uvicorn.org/#the-asgi-interface">ASGI interface</a>了解, 接下来将从例子的<code>uvicorn.run</code>开始, 通过源码分析<code>uvicorn</code>工作原理。</p>
<h2 id="1-uvicorn主流程源码分析"><a href="#1-uvicorn主流程源码分析" class="headerlink" title="1.uvicorn主流程源码分析"></a>1.uvicorn主流程源码分析</h2><p>分析源码之前， 首先是了解它的源码结构， <code>uvicorn</code>的源码结构如下：<br>├── lifespan<br>├── loops<br>├── protocols<br>├── middleware<br>├── supervisors<br>├── config.py<br>├── importer.py<br>├── <strong>init</strong>.py<br>├── logging.py<br>├── <strong>main</strong>.py<br>├── main.py<br>├── server.py<br>├── subprocess.py<br>├── _types.py<br>└── workers.py</p>
<p><code>uvicron</code>做了很好的分类， 每个文件夹/文件都有自己的功能:</p>
<ul>
<li>lifespan<br>  告诉基于ASGI的应用程序<code>uvicorn</code>即将启动和停止的消息， <code>uvicorn</code>在启动的时候会初始化，然后发送初始化协议并等待ASGI应用程序返回， 如果ASGI应用程序返回<code>complele</code>则<code>uvicorn</code>会继续运行， 返回<code>failed</code>则报错退出。</li>
<li>loops<br>  自动加载事件循环， 优先加载<code>uvloop</code>， 这将会获得极大的性能提升</li>
<li>protocols<br>  里面存放着读取连接数据和解析消息体的协议， 如HTTP和WebSockets, 可以把他认为是一个序列化器。</li>
<li>middleware<br>  存放着一些简单通用的ASGI中间件</li>
<li>supervisors<br>  <code>uvicorn</code>本身是以一个进程启动的， 这个文件夹存放着<code>uvicorn</code>的几种启动方式， 如多进程启动，监控文件变动自动重启的方式等。</li>
<li>config.py<br>  <code>uvicorn</code>的配置文件， 它不仅读取用户的配置， 还自动加载上面所述的<code>lifespan</code>, <code>loops</code>, <code>protocols</code>等等</li>
<li>importer.py<br>  <code>uvicron</code>中很多地方使用了动态加载配置和动态加载库， 这里是把这个方法进行统一封装</li>
<li>logging.py<br>  提供了根据日志等级渲染不同颜色的日志以及访问日志(但是很少人用)</li>
<li>main.py<br>  <code>uvicorn</code>的入口文件， 包括代码运行和命令行运行两种方式</li>
<li>server.py<br>  <code>uvicorn</code>的核心服务， 用于处理进出流量以及处理自身的服务状态</li>
<li>subprocess.py<br>  给<code>supervisors/multiprocess.py</code>使用的， 可能是为了以后拓展需要， 才放在一级目录</li>
<li>workers.py<br>  其他工作模式的<code>Uvicorn</code>， 比如里面有个<code>UvicornWorker</code>, 就是用于<code>gunicorn</code>启动<code>uvicorn</code> </li>
</ul>
<p>结构了解完， 接下来开始正式步入源码之旅， 这里直接忽略掉命令行的启动方式， 从<code>uvicorn.run</code>开始, 实际上命令行启动方式也是通过获取参数， 然后传入<code>uvicorn</code>方法中, 这个<code>uvicorn.run</code>方法会接受符合ASGI的app和<code>kwargs</code>参数， 然后生成对应的配置实例<code>config</code>, 再生成<code>server</code>， 接着依靠配置判断是否启动模式， 具体代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span>(<span class="hljs-params">app, **kwargs</span>):</span><br>    <span class="hljs-comment"># 加载配置</span><br>    config = Config(app, **kwargs)<br>    <span class="hljs-comment"># 加载server</span><br>    server = Server(config=config)<br><br>    <span class="hljs-keyword">if</span> (config.reload <span class="hljs-keyword">or</span> config.workers &gt; <span class="hljs-number">1</span>) <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">isinstance</span>(app, <span class="hljs-built_in">str</span>):<br>        <span class="hljs-comment"># 只有命令行模式才可以使用reload</span><br>        logger = logging.getLogger(<span class="hljs-string">&quot;uvicorn.error&quot;</span>)<br>        logger.warning(<br>            <span class="hljs-string">&quot;You must pass the application as an import string to enable &#x27;reload&#x27; or &quot;</span><br>            <span class="hljs-string">&quot;&#x27;workers&#x27;.&quot;</span><br>        )<br>        sys.exit(<span class="hljs-number">1</span>)<br><br>    <span class="hljs-keyword">if</span> config.should_reload:<br>        <span class="hljs-comment"># 启动reload逻辑</span><br>        sock = config.bind_socket()<br>        supervisor = ChangeReload(config, target=server.run, sockets=[sock])<br>        supervisor.run()<br>    <span class="hljs-keyword">elif</span> config.workers &gt; <span class="hljs-number">1</span>:<br>        <span class="hljs-comment"># 多进程方式启动</span><br>        sock = config.bind_socket()<br>        supervisor = Multiprocess(config, target=server.run, sockets=[sock])<br>        supervisor.run()<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-comment"># 最普通的方法启动</span><br>        server.run()<br></code></pre></td></tr></table></figure>
<p><code>config</code>很简单， 它负责装填配置， 然后调用<code>configure_logging</code>配置全局的<code>logger</code>, 此外还有一个<code>load</code>的方法， 将会在<code>Server</code>中调用, 接下来， 先忽略其中涉及到的模板， 到<code>server.run</code>之中， 看看普通模式下， 服务是怎么启动的。</p>
<p>这个<code>run</code>方法很简单， 就是设置事件循环， 然后通过事件循环调用<code>serve</code>来启动服务:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span>(<span class="hljs-params">self, sockets=<span class="hljs-literal">None</span></span>):</span><br>    self.config.setup_event_loop()<br>    loop = asyncio.get_event_loop()<br>    loop.run_until_complete(self.serve(sockets=sockets))<br></code></pre></td></tr></table></figure>
<p><code>serve</code>是启动服务的最核心代码， 首先会执行<code>config.load</code>方法加载一些动态的配置， 如解析http的库， 解析websocket的库， 还有通过用户传过来的app来加载app, 并判断是使用<code>WSGI</code>，<code>ASGI2</code>或者是<code>ASGI3</code>， 并进行配置(<code>uvicorn</code>在这里是通过ASGI中间件的方式来支持), 最后根据配置启动对应的中间件。<br>接着会跳转到<code>server.startup</code>方法， 该方法首先会通过<code>lifaspan.startup</code>与用户传过来的<code>app</code>通信， 校验是否是合法的应用程序， 然后初始化变量, 先是初始化一个信号处理函数， 当收到信号时， 会把变量<code>should_exit</code>设置会<code>True</code>。<br>然后会初始化一个名为<code>create_protocol</code>的变量， 它是继承于<code>asyncio.Protocol</code>, <code>asyncio.Protocol</code>主要用于从socket获取数据和写入数据， 同时也有一些TCP相关的调用, <code>create_protocol</code>的主要作用就是作为socket和应用程序的中间层， 负责把HTTP数据与ASGI数据互转, 如下图:<br><img    class="lazyload" data-original="https://ftp.bmp.ovh/imgs/2021/11/423eec08a34e2797.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">协议转换</span><br>接着根据用户传过来的变量方式来启动服务, 这些都是<code>Python</code>的<code>Asyncio</code>封装好的， 具体为以下几种：</p>
<ul>
<li>当用户传socket过来的时候： 基于该scoket和<code>create_protocol</code>创建服务， 如果是多进程且是Windows系统， 则要显示的共享socket。</li>
<li>当用户传文件描述符的时候： 基于该文件描述符获取scoket， 并通过该socket和<code>create_protocol</code>创建服务。</li>
<li>当用户传unix domain socket的时候: 基于unix domain socket和<code>create_protocol</code>创建服务。</li>
<li>当用户传host和port参数的时候: 基于host和port和<code>create_protocol</code>创建服务。</li>
</ul>
<p>创建完服务后， socket的处理就转给了应用程序了， 但是采用了事件循环的思路， 需要<code>uvicorn</code>使用<code>while</code>使程序一直跑， 防止主程序退出:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main_loop</span>(<span class="hljs-params">self</span>):</span><br>    counter = <span class="hljs-number">0</span><br>    should_exit = <span class="hljs-keyword">await</span> self.on_tick(counter)<br>    <span class="hljs-keyword">while</span> <span class="hljs-keyword">not</span> should_exit:<br>        counter += <span class="hljs-number">1</span><br>        counter = counter % <span class="hljs-number">864000</span><br>        <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">0.1</span>)<br>        should_exit = <span class="hljs-keyword">await</span> self.on_tick(counter)<br></code></pre></td></tr></table></figure>
<p>每次循环执行的时候都会调用<code>on_tick</code>方法， 该方法主要是进行服务统计以及判断啥时候可以退出服务, 比如请求总数超过配置的限制数， 或者收到信号，把变量<code>should_exit</code>设置为<code>True</code>等等， 如果在循环中判断程序需要进行退出, 就会进入退出逻辑<code>shutdown</code>, 该逻辑比较简单， 注释和代码如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">shutdown</span>(<span class="hljs-params">self, sockets=<span class="hljs-literal">None</span></span>):</span><br>    logger.info(<span class="hljs-string">&quot;Shutting down&quot;</span>)<br><br>    <span class="hljs-comment"># 关闭socket， 不让有新的连接建立</span><br>    <span class="hljs-keyword">for</span> server <span class="hljs-keyword">in</span> self.servers:<br>        server.close()<br>    <span class="hljs-keyword">for</span> sock <span class="hljs-keyword">in</span> sockets <span class="hljs-keyword">or</span> []:<br>        sock.close()<br>    <span class="hljs-keyword">for</span> server <span class="hljs-keyword">in</span> self.servers:<br>        <span class="hljs-keyword">await</span> server.wait_closed()<br><br>    <span class="hljs-comment"># 关闭已经创建的连接， 并等待他们处理完毕 </span><br>    <span class="hljs-keyword">for</span> connection <span class="hljs-keyword">in</span> <span class="hljs-built_in">list</span>(self.server_state.connections):<br>        connection.shutdown()<br>    <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">0.1</span>)<br><br>    <span class="hljs-comment"># 等待连接关闭或者用户强制关闭</span><br>    <span class="hljs-keyword">if</span> self.server_state.connections <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> self.force_exit:<br>        msg = <span class="hljs-string">&quot;Waiting for connections to close. (CTRL+C to force quit)&quot;</span><br>        logger.info(msg)<br>        <span class="hljs-keyword">while</span> self.server_state.connections <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> self.force_exit:<br>            <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">0.1</span>)<br><br>    <span class="hljs-comment"># 等待后台任务完成或者用户强制关闭</span><br>    <span class="hljs-keyword">if</span> self.server_state.tasks <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> self.force_exit:<br>        msg = <span class="hljs-string">&quot;Waiting for background tasks to complete. (CTRL+C to force quit)&quot;</span><br>        logger.info(msg)<br>        <span class="hljs-keyword">while</span> self.server_state.tasks <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> self.force_exit:<br>            <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">0.1</span>)<br><br>    <span class="hljs-comment"># 通过lifespan告诉ASGI应用程序即将关闭</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self.force_exit:<br>        <span class="hljs-keyword">await</span> self.lifespan.shutdown()<br></code></pre></td></tr></table></figure>
<p>至此整个主流程分析完毕， 下图是我整理后的一个流程图：<br><img   class="lazyload" data-original="https://ftp.bmp.ovh/imgs/2021/11/5c8d300b7d67d800.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" ><br>从图中可以很清晰的看清<code>uvicorn</code>与ASGI应用程序的关系, 接下来是上面部分没有详细讲过的小组件源码分析。</p>
<h2 id="2-uvicorn-protocols源码分析"><a href="#2-uvicorn-protocols源码分析" class="headerlink" title="2.uvicorn.protocols源码分析"></a>2.uvicorn.protocols源码分析</h2><p>在了解了<code>uvicorn</code>的主流程后只大概的知道<code>uvicorn</code>是通过<code>uvicorn.protocols</code>与应用程序进行通信， 但是不明白他们具体是如何通信的， 接下来就开始了解<code>uvicorn</code>中最核心的<code>uvicorn.protocols</code>。</p>
<p>从上面的分析中我们可以知道， 作为一个Web服务器， <code>uvicorn</code>是通过一个socket来接收发发送请求的。 而对于socket来说， 它只关心怎么创建连接，关闭连接以及如何传输内容， 它不会关心传输的字节流的上层协议是如何实现的。<br>好在<code>Asyncio</code>提供了几种简单的网络传输模型, 它们都是对于这些传输数据的抽象， 这些抽象会在如<code>loop.create_server</code>和<code>loop.create_unix_server</code>方法中使用, 通过这个抽象我们能很方便的使用TCP和UDP连接。 </p>
<p><code>uvicorn</code>在基于<code>Asyncio</code>创建服务器时， 把<code>protocol</code>抽象通过protocols参数传入<code>loop.create_server</code>和<code>loop.create_unix_server</code>后, 维护他们返回的<code>server</code>对象， 剩下的与ASGI应用程序的数据交互全由<code>protocol</code>对象处理。<br><code>uvicorn</code>封装的对象继承于<code>asyncio.Protocols</code>, 它是针对TCP协议的封装, 它总共有6个方法，包括启动时的<code>connection_made</code>, 接收数据时的<code>data_received</code>, 断开时的<code>eof_received</code>以及丢失连接时的<code>connection_lost</code>, 然后还有当TCP连接出现堵塞时的暂停<code>pause_writing</code>和恢复<code>resume_writing</code>, 具体的方法传输的参数和使用方法如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Protocol</span>(<span class="hljs-params">BaseProtocol</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">connection_made</span>(<span class="hljs-params">self, transport</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        在建立连接时调用.</span><br><span class="hljs-string"></span><br><span class="hljs-string">        参数是表示管道连接的transport, </span><br><span class="hljs-string">        此时得到的transport需要设置为该类的transport， 方便后续connection_lost控制关闭管道.</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">data_received</span>(<span class="hljs-params">self, data</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        通过该方法可以获取到客户端传输过来的数据</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">eof_received</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        当另一端调用write_eof()或等效函数时调用.</span><br><span class="hljs-string"></span><br><span class="hljs-string">        如果返回一个假值(包括None)，则传输将关闭自身。</span><br><span class="hljs-string">        如果它返回true值，则关闭传输取决于协议.</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">connection_lost</span>(<span class="hljs-params">self, exc</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        当连接丢失或关闭时调用, 根据exc判断是否要关闭trnasport.</span><br><span class="hljs-string">        参数是一个异常对象或None(后者表示接收到常规EOF或中止或关闭连接).</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">pause_writing</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        当transport缓冲区超过高水位(high-water mark)时调用, </span><br><span class="hljs-string">        此时应该能控制外部不再写入数据（通常是一个asyncio.Future）,</span><br><span class="hljs-string">        同时应该通过transport.pause_reading来停止获取数据， 之后TCP就会通过拥塞机制使得客户端减缓发送数据的速度。</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">resume_writing</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        当transport缓冲区排放低于低水位线(low-water mark)时调用. </span><br><span class="hljs-string">        此时要释放标志， 使得外部可以继续写入数据， </span><br><span class="hljs-string">        同时通过transport.resume_reading来恢复获取数据， </span><br><span class="hljs-string">        之后TCP就会通过拥塞机制知道服务端的处理能力上来了， 使客户端加快发送速度。</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br></code></pre></td></tr></table></figure>
<p>了解完<code>asycnio.Protocol</code>后, 可以正式了解<code>uvicorn</code>对<code>asyncio.Protocol</code>做了哪些修改来达到跟应用程序进行通信, 由于各个<code>Protocol</code>的封装差不多， 这里以<code>httptools_impl.HttpToolsProtocol</code>为例子进行说明。</p>
<p>首先是类的初始化， <code>HttpToolsProtocol</code> 在初始化时会加载<code>config</code>并配置到日志，对应的websocket协议处理，对应的http解析器以及<code>serve</code>创建的统计容器等， 其中需要注意的是， 在初始化时， 传入的变量是<code>HttpToolsProtocol</code>的实例化本身。<br>接着是<code>Protocol</code>的几大主要协议接口函数, 这里以源码和注释进行分析：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HttpToolsProtocol</span>(<span class="hljs-params">asyncio.Protocol</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">connection_made</span>(<span class="hljs-params">self, transport</span>):</span><br>        <span class="hljs-comment"># 添加实例本身到集合， 代表当前还有连接在处理</span><br>        self.connections.add(self)<br><br>        self.transport = transport<br>        <span class="hljs-comment"># 初始化流控制</span><br>        self.flow = FlowControl(transport)<br>        <span class="hljs-comment"># 简单的初始化实例trsnaport的相关编列</span><br>        self.server = get_local_addr(transport)<br>        self.client = get_remote_addr(transport)<br>        self.scheme = <span class="hljs-string">&quot;https&quot;</span> <span class="hljs-keyword">if</span> is_ssl(transport) <span class="hljs-keyword">else</span> <span class="hljs-string">&quot;http&quot;</span><br><br>        <span class="hljs-keyword">if</span> self.logger.level &lt;= TRACE_LOG_LEVEL:<br>            prefix = <span class="hljs-string">&quot;%s:%d - &quot;</span> % <span class="hljs-built_in">tuple</span>(self.client) <span class="hljs-keyword">if</span> self.client <span class="hljs-keyword">else</span> <span class="hljs-string">&quot;&quot;</span><br>            self.logger.log(TRACE_LOG_LEVEL, <span class="hljs-string">&quot;%sConnection made&quot;</span>, prefix)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">connection_lost</span>(<span class="hljs-params">self, exc</span>):</span><br>        <span class="hljs-comment"># 从集合删除实例本身， 代表当前连接已经处理玩了， 不需要进入统计容器</span><br>        self.connections.discard(self)<br><br>        <span class="hljs-keyword">if</span> self.logger.level &lt;= TRACE_LOG_LEVEL:<br>            prefix = <span class="hljs-string">&quot;%s:%d - &quot;</span> % <span class="hljs-built_in">tuple</span>(self.client) <span class="hljs-keyword">if</span> self.client <span class="hljs-keyword">else</span> <span class="hljs-string">&quot;&quot;</span><br>            self.logger.log(TRACE_LOG_LEVEL, <span class="hljs-string">&quot;%sConnection lost&quot;</span>, prefix)<br><br>        <span class="hljs-comment"># 设置cycle， 告诉他连接已经断开</span><br>        <span class="hljs-keyword">if</span> self.cycle <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> self.cycle.response_complete:<br>            self.cycle.disconnected = <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">if</span> self.cycle <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            self.cycle.message_event.<span class="hljs-built_in">set</span>()<br>        <span class="hljs-keyword">if</span> self.flow <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            self.flow.resume_writing()<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_unset_keepalive_if_required</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;取消keep alive timeout的任务，</span><br><span class="hljs-string">        一般来说， 在发送数据后服务端会等待客户端发送数据， 如果超过多少秒没有发送数据则可以判断该客户端已经断开了， 服务端可以主动关闭连接</span><br><span class="hljs-string">        而uvicorn通过timeout_keep_alive_task来实现</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> self.timeout_keep_alive_task <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            self.timeout_keep_alive_task.cancel()<br>            self.timeout_keep_alive_task = <span class="hljs-literal">None</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">data_received</span>(<span class="hljs-params">self, data</span>):</span><br>        self._unset_keepalive_if_required()<br><br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-comment"># 接受字节数据， 并交由http解析器进行解析</span><br>            self.parser.feed_data(data)<br>        <span class="hljs-keyword">except</span> httptools.HttpParserError <span class="hljs-keyword">as</span> exc:<br>            <span class="hljs-comment"># 解析失败， 应该不是http协议的数据， 断开连接</span><br>            msg = <span class="hljs-string">&quot;Invalid HTTP request received.&quot;</span><br>            self.logger.warning(msg, exc_info=exc)<br>            self.transport.close()<br>        <span class="hljs-keyword">except</span> httptools.HttpParserUpgrade:<br>            <span class="hljs-comment"># 已经超过了解析器能解析的协议版本， 应该交由更新的协议解析器处理</span><br>            self.handle_upgrade()<br></code></pre></td></tr></table></figure>
<p>分析完了几个跟连接相关的主要方法后就会发现分析路线已经断了， 而该类中还有很多<code>on_xxx</code>的方法, 它们也没有被其他方法调用。<br>这是因为在初始化HTTP协议解析器的时候，<code>uvicorn.protocol</code>把自己的实例传入了HTTP解析器中， 解析器会边接收数据边按照url, header, body来顺序解析， 并在执行每种数据解析后， 会通过回调告诉传入的实例， <code>uvicorn</code>正是通过<code>on_xxx</code>方法来监听这些回调并处理解析完的HTTP数据:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HttpToolsProtocol</span>(<span class="hljs-params">asyncio.Protocol</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">on_url</span>(<span class="hljs-params">self, url</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;这是收到一个请求后的第一次解析, 可以认为是该请求体的初始化， 此时会根据url和连接数据进行初始化， 并存放在实例的scope中&quot;&quot;&quot;</span><br>        method = self.parser.get_method()<br>        parsed_url = httptools.parse_url(url)<br>        raw_path = parsed_url.path<br>        path = raw_path.decode(<span class="hljs-string">&quot;ascii&quot;</span>)<br>        <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;%&quot;</span> <span class="hljs-keyword">in</span> path:<br>            path = urllib.parse.unquote(path)<br>        self.url = url<br>        self.expect_100_continue = <span class="hljs-literal">False</span><br>        self.headers = []<br>        self.scope = &#123;<br>            <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;http&quot;</span>,<br>            <span class="hljs-string">&quot;asgi&quot;</span>: &#123;<span class="hljs-string">&quot;version&quot;</span>: self.config.asgi_version, <span class="hljs-string">&quot;spec_version&quot;</span>: <span class="hljs-string">&quot;2.1&quot;</span>&#125;,<br>            <span class="hljs-string">&quot;http_version&quot;</span>: <span class="hljs-string">&quot;1.1&quot;</span>,<br>            <span class="hljs-string">&quot;server&quot;</span>: self.server,<br>            <span class="hljs-string">&quot;client&quot;</span>: self.client,<br>            <span class="hljs-string">&quot;scheme&quot;</span>: self.scheme,<br>            <span class="hljs-string">&quot;method&quot;</span>: method.decode(<span class="hljs-string">&quot;ascii&quot;</span>),<br>            <span class="hljs-string">&quot;root_path&quot;</span>: self.root_path,<br>            <span class="hljs-string">&quot;path&quot;</span>: path,<br>            <span class="hljs-string">&quot;raw_path&quot;</span>: raw_path,<br>            <span class="hljs-string">&quot;query_string&quot;</span>: parsed_url.query <span class="hljs-keyword">if</span> parsed_url.query <span class="hljs-keyword">else</span> <span class="hljs-string">b&quot;&quot;</span>,<br>            <span class="hljs-string">&quot;headers&quot;</span>: self.headers,<br>        &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">on_header</span>(<span class="hljs-params">self, name: <span class="hljs-built_in">bytes</span>, value: <span class="hljs-built_in">bytes</span></span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;解析器在解析header时， 是按照header一行一行进行解析的， 所以每即系一行header都会调用一次on_header, 并把他们存在实例的headers中&quot;&quot;&quot;</span><br>        name = name.lower()<br>        <span class="hljs-keyword">if</span> name == <span class="hljs-string">b&quot;expect&quot;</span> <span class="hljs-keyword">and</span> value.lower() == <span class="hljs-string">b&quot;100-continue&quot;</span>:<br>            self.expect_100_continue = <span class="hljs-literal">True</span><br>        self.headers.append((name, value))<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">on_headers_complete</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;对于大部分前置web框架来说， 一般解析到header后就结束不再解析了， 会开始发送到正真处理的应用程序, uvicorn也是这样的&quot;&quot;&quot;</span><br>        http_version = self.parser.get_http_version()<br>        <span class="hljs-keyword">if</span> http_version != <span class="hljs-string">&quot;1.1&quot;</span>:<br>            self.scope[<span class="hljs-string">&quot;http_version&quot;</span>] = http_version<br>        <span class="hljs-keyword">if</span> self.parser.should_upgrade():<br>            <span class="hljs-comment"># 如果发现当前http版本更加高级（比如websocket）, 则不再处理, 在另外一个逻辑会转到websocket处理</span><br>            <span class="hljs-keyword">return</span><br><br>        <span class="hljs-comment"># Handle 503 responses when &#x27;limit_concurrency&#x27; is exceeded.</span><br>        <span class="hljs-keyword">if</span> self.limit_concurrency <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> (<br>            <span class="hljs-built_in">len</span>(self.connections) &gt;= self.limit_concurrency<br>            <span class="hljs-keyword">or</span> <span class="hljs-built_in">len</span>(self.tasks) &gt;= self.limit_concurrency<br>        ):<br>            <span class="hljs-comment"># 当前并发数过高， 不再转发给后面的应用程序， 直接返回错误, 这里是一个具有ASGI标准函数签名的函数, 里面实现的功能是发送错误信息到socket</span><br>            app = service_unavailable<br>            message = <span class="hljs-string">&quot;Exceeded concurrency limit.&quot;</span><br>            self.logger.warning(message)<br>        <span class="hljs-keyword">else</span>:<br>            app = self.app<br><br>        <span class="hljs-comment"># cycle相当于一个request的处理流程</span><br>        <span class="hljs-comment"># 普通的HTTP请求只对应一个cycle就可以了， 这里是兼容Pipelined HTTP请求</span><br>        existing_cycle = self.cycle<br>        self.cycle = RequestResponseCycle(<br>            scope=self.scope,<br>            transport=self.transport,<br>            flow=self.flow,<br>            logger=self.logger,<br>            access_logger=self.access_logger,<br>            access_log=self.access_log,<br>            default_headers=self.default_headers,<br>            message_event=asyncio.Event(),<br>            expect_100_continue=self.expect_100_continue,<br>            keep_alive=http_version != <span class="hljs-string">&quot;1.0&quot;</span>,<br>            on_response=self.on_response_complete,<br>        )<br>        <span class="hljs-keyword">if</span> existing_cycle <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">or</span> existing_cycle.response_complete:<br>            <span class="hljs-comment"># 如果上个请求已经处理完了， 则开始处理这个请求(通过run_asgi来运行)</span><br>            task = self.loop.create_task(self.cycle.run_asgi(app))<br>            task.add_done_callback(self.tasks.discard)<br>            self.tasks.add(task)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-comment"># 如果上个请求没有处理完， 就先暂停读取数据， 并把该cycle放到pipeline暂存</span><br>            self.flow.pause_reading()<br>            self.pipeline.insert(<span class="hljs-number">0</span>, (self.cycle, app))<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">on_body</span>(<span class="hljs-params">self, body: <span class="hljs-built_in">bytes</span></span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;读取到原生的body字节， 如果ASGI处理者还在运行， 且不是websocket, 则转给ASGI处理者</span><br><span class="hljs-string">        注： 一个请求可能会触发多次on_body&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> self.parser.should_upgrade() <span class="hljs-keyword">or</span> self.cycle.response_complete:<br>            <span class="hljs-keyword">return</span><br>        self.cycle.body += body<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(self.cycle.body) &gt; HIGH_WATER_LIMIT:<br>            <span class="hljs-comment"># 由于ASGI应用程序会根据调用者需要才来获取body(比如starlette的 await request.body())， 如果应用程序没有需要则会暂缓获取body数据</span><br>            self.flow.pause_reading()<br>        <span class="hljs-comment"># 告诉ASGI应用程序， body已经获取结束（通常在cycle的more_body为False的时候, 才会检查message_event）</span><br>        self.cycle.message_event.<span class="hljs-built_in">set</span>()<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">on_message_complete</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">if</span> self.parser.should_upgrade() <span class="hljs-keyword">or</span> self.cycle.response_complete:<br>            <span class="hljs-keyword">return</span><br>        <span class="hljs-comment"># 表示body已经读取结束了 </span><br>        self.cycle.more_body = <span class="hljs-literal">False</span><br>        self.cycle.message_event.<span class="hljs-built_in">set</span>()<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">on_response_complete</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;返回响应时的回调&quot;&quot;&quot;</span><br>        self.server_state.total_requests += <span class="hljs-number">1</span><br><br>        <span class="hljs-keyword">if</span> self.transport.is_closing():<br>            <span class="hljs-keyword">return</span><br><br>        <span class="hljs-comment"># 设置一个keep_alive的机制， 服务端返回响应后会设置一个倒计时future, 该future只有在上面data_received收到请求的时候才会取消</span><br>        <span class="hljs-comment"># 如果该future没有取消， 则会调用timeout_keep_alive_handler函数来关闭transport通道</span><br>        self._unset_keepalive_if_required()<br><br>        self.timeout_keep_alive_task = self.loop.call_later(<br>            self.timeout_keep_alive, self.timeout_keep_alive_handler<br>        )<br><br>        <span class="hljs-comment"># 恢复读取数据</span><br>        self.flow.resume_reading()<br><br>        <span class="hljs-keyword">if</span> self.pipeline:<br>            <span class="hljs-comment"># 如果是pipeline请求， 则开始处理刚才暂存的cycle</span><br>            cycle, app = self.pipeline.pop()<br>            task = self.loop.create_task(cycle.run_asgi(app))<br>            task.add_done_callback(self.tasks.discard)<br>            self.tasks.add(task)<br><br></code></pre></td></tr></table></figure>
<p>在了解解析HTTP数据的时候， 经常会遇到一个cycle对象， 这个对象是基于ASGI负责读写数据转换的对象， 这个对象有<code>send</code>和<code>receive</code>两个方法, 这两个方法的命名是站在ASGI应用程序的角度来命名的。<br>其中<code>send</code>通过传入的参数<code>message</code>获取到ASGI应用程序返回的数据， 并依据ASGI协议进行解析， 并拼接成HTTP协议的字节流， 当ASGI应用程序发送结束标记时， <code>send</code>会把拼接的字节流通过socket返回给客户端, 同时触发<code>on_response_complete</code>方法。<br>而<code>receive</code>比较简单， 它只负责接收获取到已经解析完成的HTTP数据（早前面on_xxx时会把数据传给cycle）， 然后发送到ASGI应用程序中。<br>这两个方法都是通过<code>on_headers_complete</code>中执行的<code>run_asgi</code>方法来调用的， 通过该方法， <code>uvicorn</code>会把数据的处理权转给ASGI应用程序, 如果ASGI应用程序处理异常， 则会返回HTTP状态码为500的响应给客户端并关闭transport。</p>
<p>分析完了cycle对象后， 再次回到protocol的<code>data_received</code>的方法中， 这里通过获取<code>httptools.HttpParserUpgrade</code>异常的方式得知当前可能是一个WebSocket请求， 于是进入<code>handle_upgrade</code>逻辑， 这个逻辑会检查是否加载了解析WebSocket解析器以及请求体是否满足WebSocket条件， 如果不满足就会返回一个响应体告诉客户端当前无法支持该HTTP请求的升级协议， 如果满足则会生成WebSocketProtocols来处理socket的数据， 并把它设置为当前的transport向关联， 不过这个WebsocketProtocols基本上是HTTP protocols和cycle两个对象的融合， 具体处理步骤也差不多， 这里就不多做描述了。</p>
<p>至此， 大体上的<code>uvicorn.protocols</code>源码就分析完了， 由于<code>uvicorn</code>是把<code>asyncio.Protocol</code>, 解析器， <code>cycle</code>三者结合在一起， 所以分析起来要经常跳转， 因此我把他们的流程转成如下的图：<br><img    class="lazyload" data-original="https://ftp.bmp.ovh/imgs/2021/11/a32784eec69cae1b.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">流处理图</span></p>
<h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3.总结"></a>3.总结</h2><p>至此， <code>uvicorn</code>的核心流程已经分析完了， 它先是通过<code>server</code>来启动一个服务， 并管理服务状态， 然后再通过<code>protocol</code>负责做双端的序列化, 使ASGI应用程序能够按照ASGI协议读写数据， 其中<code>protocol</code>还融合了HTTP解析器解析HTTP并通过它来解析数据。<br>当然， 除了上述主流程外， <code>uvicorn</code>还包括了中间件， 多进程启动以及监控文件变化重启服务等组件， 这些组件的代码量不大， 分析源码也说不出啥， 这里就简单略过。</p>
]]></content>
      <categories>
        <category>源码分析</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>保障Python项目质量的工具</title>
    <url>/2021/08/10/%E4%BF%9D%E9%9A%9CPython%E9%A1%B9%E7%9B%AE%E8%B4%A8%E9%87%8F%E7%9A%84%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<h2 id="前记"><a href="#前记" class="headerlink" title="前记"></a>前记</h2><p>在编写项目时，都会对代码质量有一定的追求， 比如代码艺术， 设计模式， 重构设计等等。 但是一个良好Python项目除了程序员本身的代码质量能力之外， 还有系统设计和代码质量工具等等。不过由于每个系统的设计都会有一些不同， 系统设计需要程序员一定的经验， 需要跟着项目去一起成长。 而代码质量工具是可以都抽离出来，应用到每个项目中， 本文则是我这些代码质量工具的简要使用总结。</p>
<h2 id="0-提交代码规范"><a href="#0-提交代码规范" class="headerlink" title="0.提交代码规范"></a>0.提交代码规范</h2><p>每个团队或个人， 都必须要有一套自己的分支管理和提交代码规范， 对于分支管理， 一般会选用<code>git flow</code>, 如果不太会使用， 前期可以使用<a href="https://danielkummer.github.io/git-flow-cheatsheet/index.zh_CN.html">git flow 备忘清单</a>, 并且对于<code>master</code>, <code>develop</code>等分支设置一些权权限。<br>另外提交的信息也要有对应的规范， 比如本次提交属于哪种类型， 本次提交的功能是什么等等, 但是这个提交规范往往都没有一个标准， 只要团队和个人用的顺心， 能通过这些规范来减少开发矛盾， 复盘代码等等即可。 我常使用的是：</p>
<figure class="highlight mojolicious"><table><tr><td class="code"><pre><code class="hljs mojolicious"><span class="xml">git commit -m&quot;<span class="hljs-tag">&lt;<span class="hljs-name">issue_id</span>&gt;</span>:<span class="hljs-tag">&lt;<span class="hljs-name">file</span> <span class="hljs-attr">change</span>&gt;</span>:<span class="hljs-tag">&lt;<span class="hljs-name">operating</span>&gt;</span>:<span class="hljs-tag">&lt;<span class="hljs-name">info</span>&gt;</span>&quot;</span><br></code></pre></td></tr></table></figure>
<p>其中每个字段代表的含义如下：</p>
<ul>
<li>issue_id: 代表一个issue的id, 在准备写功能或者修复一个bug时，都应该先提一个issue, 这个issue要详细的写明要修改什么，达到什么目的，然后再针对这个issue提交代码</li>
<li>file change: 代表文件的变化， 如增加， 删除， 修改;也有人使用<code>+,-，*</code>来分别代表增加， 删除， 修改</li>
<li>operating: 代表本次代码变化, 具体有如下几种<ul>
<li>feat：新功能</li>
<li>fix：修复bug</li>
<li>doc：文档改变</li>
<li>style：代码格式改变</li>
<li>refactor：某个已有功能重构</li>
<li>perf：性能优化</li>
<li>test：增加测试</li>
<li>build：改变了build工具 如 grunt换成了 npm</li>
<li>revert：撤销上一次的commit</li>
</ul>
</li>
<li>info: 简要的说明本次提交信息</li>
</ul>
<h2 id="1-项目环境管理-Poetry"><a href="#1-项目环境管理-Poetry" class="headerlink" title="1.项目环境管理-Poetry"></a>1.项目环境管理-Poetry</h2><p>一个项目最重要的就是跑起来， 而大家基本会同时在本地开发多个项目， 每个项目用到的环境都是不一样的， 所以就需要用到虚拟环境隔离。在Python中提供了一个叫<code>venv</code>的虚拟环境管理包，他非常稳定， 同时功能也不是很多， 一般只用在服务器上， 对于本地开发来说， 都会想要更多的功能， 更加方便的对虚拟环境， 依赖包进行管理， Python包管理领域相关工具很多， 包括争议很大的<code>Pipenv</code>, 我在经过多种尝试后， 觉得<code>Poetry</code>比较好用, 坑也比较少。</p>
<p><a href="https://python-poetry.org/">Poetry</a>官网的简介就是让Python包安装和依赖管理变得容易，  我觉得<code>Poetry</code>是最好用的, 他不止对包管理有很多的支持， 还有其他的拓展功能， 如方便的打包和发布， 脚本简写等等。</p>
<p>在第一次大多数的Python项目编写中， 基本上都是按以下流程进行：</p>
<ul>
<li>1.安装对应的Python版本</li>
<li>2.通过<code>python -m venv &lt;name&gt;</code>的方式在项目创建venv的虚拟环境</li>
<li>3.在使用的过程中通过<code>python -m pip install &lt;name&gt;</code>的方式安装依赖</li>
<li>4.在代码编写完毕后通过<code>python -m pip freeze &gt; requirements.txt</code>生成依赖文件</li>
</ul>
<p>而<code>Poetry</code>则十分简单， 以下是<code>poetry</code>的创建流程：</p>
<h3 id="1-1-创建项目"><a href="#1-1-创建项目" class="headerlink" title="1.1.创建项目"></a>1.1.创建项目</h3><p>通过命令<code>poetry new</code>就可以创建一个项目手脚架</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">➜ poetry new example<br>➜ tree<br>.<br>└── example<br>    ├── example<br>    │   └── __init__.py<br>    ├── pyproject.toml<br>    ├── README.rst<br>    └── tests<br>        ├── __init__.py<br>        └── test_example.py<br><br>3 directories, 5 files<br></code></pre></td></tr></table></figure>
<p>可以看到<code>Poetry</code>创建了一个<code>example</code>的项目， 生成了对应的文件夹以及包括项目信息的<code>pyproject.toml</code>。<br>如果在已有项目， 则通过命令<code>poetry init</code>来初始化：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">➜  example poetry init<br><br>This <span class="hljs-built_in">command</span> will guide you through creating your pyproject.toml config.<br><span class="hljs-comment"># 交互bash， 通过该交互bash填写项目信息。</span><br>Package name [example]:  example<br>Version [0.1.0]:  0.0.8<br>Description []:  example project<br>Author [so1n &lt;qaz6803609@163.com&gt;, n to skip]:  n<br>License []:  <br>Compatible Python versions [^3.7]:  <br><br>Would you like to define your main dependencies interactively? (yes/no) [yes] no<br>Would you like to define your development dependencies interactively? (yes/no) [yes] no<br>Generated file<br><span class="hljs-comment"># 填写完项目信息后会生成以下内容， 之后会在刚才的路径创建pyproject.toml文件， 并写入。 </span><br>[tool.poetry]<br>name = <span class="hljs-string">&quot;example&quot;</span><br>version = <span class="hljs-string">&quot;0.0.8&quot;</span><br>description = <span class="hljs-string">&quot;example project&quot;</span><br>authors = [<span class="hljs-string">&quot;Your Name &lt;you@example.com&gt;&quot;</span>]<br><br>[tool.poetry.dependencies]<br>python = <span class="hljs-string">&quot;^3.7&quot;</span><br><br>[tool.poetry.dev-dependencies]<br><br>[build-system]<br>requires = [<span class="hljs-string">&quot;poetry-core&gt;=1.0.0&quot;</span>]<br>build-backend = <span class="hljs-string">&quot;poetry.core.masonry.api&quot;</span><br><br><br>Do you confirm generation? (yes/no) [yes] yes<br></code></pre></td></tr></table></figure>
<h3 id="1-2-创建虚拟环境"><a href="#1-2-创建虚拟环境" class="headerlink" title="1.2.创建虚拟环境"></a>1.2.创建虚拟环境</h3><p><code>Poetry</code>默认使用系统默认的Python环境， 不过可以通过<code>poetry env use &lt;python version&gt;</code>来指定Python版本， 之后就创建了一个虚拟环境了。 默认的虚拟环境配置是存放在<code>/home/&#123;user&#125;/.cache/pypoetry</code>目录的, 可以直接查看配置了解：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">➜  poetry config --list<br><span class="hljs-comment"># poetry使用的缓存目录的路径</span><br>cache-dir = <span class="hljs-string">&quot;/home/so1n/.cache/pypoetry&quot;</span><br>experimental.new-installer = <span class="hljs-literal">true</span><br>installer.parallel = <span class="hljs-literal">true</span><br><span class="hljs-comment"># 默认值为true，如果执行 poetry install/poetry add时没有虚拟环境，就自动创建一个虚拟环境，设置为false的话，当虚拟环境不存在时，会将包安装到系统环境</span><br>virtualenvs.create = <span class="hljs-literal">true</span><br><span class="hljs-comment"># 默认值为false，设置为true的话，会在当前项目目录下创建虚拟环境</span><br>virtualenvs.in-project = <span class="hljs-literal">false</span><br><span class="hljs-comment"># 虚拟环境的路径，默认路径 &#123;cache-dir&#125;\virtualenvs</span><br>virtualenvs.path = <span class="hljs-string">&quot;&#123;cache-dir&#125;/virtualenvs&quot;</span>  <span class="hljs-comment"># /home/so1n/.cache/pypoetry/virtualenvs</span><br></code></pre></td></tr></table></figure>
<p>而默认的使用习惯（包括一些第三方包） 都是认为venv是创建在项目路径下的， 同时这也方便管理。 <code>poetry</code>可以通过如下命令进行更改后再创建虚拟环境，达到在项目路径下创建虚拟环境的效果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 更改配置</span><br>➜ poetry config virtualenvs.in-project <span class="hljs-literal">true</span> <br></code></pre></td></tr></table></figure>
<p>在虚拟环境创建好后可以通过</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">➜ poetry run &lt;commod&gt; <br></code></pre></td></tr></table></figure>
<p>来执行想要运行的命令或者调用Python包， 也可以通过<code>poetry shell</code>启动一个被虚拟环境包裹的交互shell.</p>
<h3 id="1-3-安装依赖"><a href="#1-3-安装依赖" class="headerlink" title="1.3.安装依赖"></a>1.3.安装依赖</h3><p>虚拟环境创建好后， 就可以安装依赖了， 可以直接使用<code>poetry</code>的<code>add</code>命令安装依赖， 其中带有<code>--dev</code>表示他是开发环境依赖包(开发环境依赖包和生成环境依赖包区分是很有益的)：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">➜ poetry add flask<br>➜ poetry add pytest --dev <br></code></pre></td></tr></table></figure>
<p>安装依赖后可以看到<code>pyproject.toml</code>文件发生变动：</p>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs toml">...<br><span class="hljs-section">[tool.poetry.dependencies]</span><br><span class="hljs-attr">python</span> = <span class="hljs-string">&quot;^3.7&quot;</span><br><span class="hljs-attr">Flask</span> = <span class="hljs-string">&quot;^1.1.2&quot;</span><br><br><span class="hljs-section">[tool.poetry.dev-dependencies]</span><br><span class="hljs-attr">pytest</span> = <span class="hljs-string">&quot;^6.2.4&quot;</span><br>...<br></code></pre></td></tr></table></figure>
<p>文件中多了刚刚安装的<code>flask</code>依赖和<code>pytest</code>依赖， 且<code>pytest</code>依赖是属于dev依赖。<br>在后面还可以通过<code>poetry</code>的命令生成对应的生产环境依赖文件<code>requirement.txt</code>和测试环境依赖文件<code>requirements-dev.txt</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 生产环境</span><br>poetry <span class="hljs-built_in">export</span> -o requirements.txt --without-hashes --with-credentials<br><span class="hljs-comment"># 测试环境</span><br>poetry <span class="hljs-built_in">export</span> -o requirements-dev.txt --without-hashes --with-credentials --dev<br></code></pre></td></tr></table></figure>
<p>这样区分测试环境和生产环境的依赖可以尽量的减少测试需要的依赖包对生成环境造成影响。</p>
<p>除了增加依赖外， <code>poetry</code>还支持很多种依赖操作方法， 具体如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看依赖</span><br>poetry show<br><span class="hljs-comment"># 以树形结构查看依赖</span><br>poetry show -t<br><span class="hljs-comment"># 更新所有锁定版本的依赖</span><br>poetry update<br><span class="hljs-comment"># 更新指定的依赖</span><br>poetry update flask<br><span class="hljs-comment"># 删除依赖</span><br>poetry remove flask<br></code></pre></td></tr></table></figure>
<h3 id="1-4-其他"><a href="#1-4-其他" class="headerlink" title="1.4.其他"></a>1.4.其他</h3><p>对于一般的自用Python项目来说， 上面的<code>poetry</code>操作已经够了， 如果需要发布自己的包到pypi, 或者安装github最新的并未发布的包则可以使用他的其他拓展命令， 具体可以见<a href="https://python-poetry.org/docs/">文档</a>。<br>个人觉得<code>poetry</code>已经非常优秀了， 但是由于缺少一个稳定的维护团队， 所以难免有bug, 这时候可以采用降级的方法解决， 比如安装依赖失败， 则可以使用<code>poetry run pip install</code>安装包， 再手动补上<code>pyproject.yml</code>文件。</p>
<h2 id="2-代码质量工具"><a href="#2-代码质量工具" class="headerlink" title="2.代码质量工具"></a>2.代码质量工具</h2><p>在大型的项目中， 一般都不追求花哨的代码， 而是追求稳定， 容易理解， 复杂度低的代码， 最完美的代码应该是入行的人一看就能理解， 又能完美的解决需求。<br>但是人无完人， 很多时候在写代码可能会出现一些小问题， 而这些小问题靠人来检查是费时费力的， 同时又很难排查出来，这时就需要代码检查工具了。<br>一般代码检查工具分为三类， 一类是检查代码风格， 并把不标准的代码风格格式化为标准的代码风格；另一类则是代码逻辑检查，他会检查代码逻辑， 代码复杂度， 引用的包是否有问题等等, 最后一类是代码安全检查， 比如是否在代码中引入密钥， 或者像在<code>Python</code>代码中写<code>eval</code>函数等。</p>
<h3 id="2-1-flake8"><a href="#2-1-flake8" class="headerlink" title="2.1.flake8"></a>2.1.flake8</h3><p><code>Flake8</code> 是由Python官方发布的一款辅助检测Python代码是否规范的工具，相对于目前热度比较高的<code>Pylint</code>来说，<code>Flake8</code>检查规则灵活，支持集成额外插件，扩展性强。<code>Flake8</code>是对下面三个工具的封装：</p>
<ul>
<li>1.PyFlakes：静态检查Python代码逻辑错误的工具。</li>
<li>2.Pep8： 静态检查PEP8编码风格的工具。</li>
<li>3.NedBatchelder’s McCabe ：静态分析Python代码复杂度的工具。</li>
</ul>
<p><code>Flake8</code>除了支持上面3种功能外， 还支持通过插件的方式引入其他功能， 比如使用<code>flake8-docstrings</code>强制要求编写函数<code>docstring</code>等。</p>
<p>在项目中可以通过<code>poetry add flake8 --dev</code>引入flake8到dev依赖， 然后通过在根目录增加<code>.flake8</code>文件：</p>
<figure class="highlight nix"><table><tr><td class="code"><pre><code class="hljs nix">[flake8]<br><span class="hljs-comment"># 适当提高最大行长度</span><br><span class="hljs-attr">max-line-length</span> = <span class="hljs-number">120</span><br><span class="hljs-comment"># 设置最大复杂度</span><br><span class="hljs-attr">max-complexity</span> = <span class="hljs-number">24</span><br><span class="hljs-comment"># 忽略这些错误类型</span><br><span class="hljs-attr">ignore</span> = F401, W503, E203<br><span class="hljs-comment"># 忽略以下文件</span><br><span class="hljs-attr">exclude</span> =<br>    .git,<br>    .venv,<br>    __pycache__,<br>    scripts,<br>    logs,<br>    upload,<br>    build,<br>    dist,<br>    docs,<br>    migrations,<br></code></pre></td></tr></table></figure>
<p>指定<code>Flke8</code>该如何执行, 最后调用命令<code>poetry run flake8. </code>即可。</p>
<h3 id="2-2-mypy"><a href="#2-2-mypy" class="headerlink" title="2.2.mypy"></a>2.2.mypy</h3><p>毫无疑问， Python的语法让人能简洁的写出代码， 但是他的动态语言特性会使大型项目变得不牢固， 而<code>mypy</code>的出现恰好能解决这一问题。<br><code>mypy</code>是一个静态类型检查工具，它可以帮助我们像静态语言一样在运行代码之前就捕获到某些错误， 但是我们在写Python代码时， 要像静态语言一样， 会参数写上他的类型， 这就是<a href="https://docs.python.org/3/library/typing.html">Type Hints</a>, 通过<code>mypy</code>和<code>Type Hints</code>的结合， 虽然会增加我们的代码量，  但它可以引入如下好处：</p>
<ul>
<li>1.可以使<code>IDE</code>通过类型推断提供更好的代码补全和提示功能, 方便项目重构以及提前检查出错误。</li>
<li>2.强制你去思考动态语言程序的类型可能会帮助你构建更清晰的代码架构。</li>
</ul>
<p>比如有如下一个函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span>(<span class="hljs-params">a, b</span>):</span><br>    <span class="hljs-keyword">return</span> a + b<br></code></pre></td></tr></table></figure>
<p>一般来说无法知道这个函数要传什么类型的参数进去， 也许一开始是传<code>int</code>变量， 后面变为<code>str</code>变量， 而通过<code>Type Hints</code>则可以指定这个变量的类型是什么， 以及返回的类型是什么， 经过改造后将会变为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span>(<span class="hljs-params">a: <span class="hljs-built_in">int</span>, b: <span class="hljs-built_in">int</span></span>) -&gt; int:</span><br>    <span class="hljs-keyword">return</span> a + b<br></code></pre></td></tr></table></figure>
<p>这个函数的a， b参数以及返回的值类型都被标注为<code>int</code>类型， 这时候假如在程序内有两个调用：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python">foo(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br>foo(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>)<br></code></pre></td></tr></table></figure>
<p>他们虽然都能运行， 但是可以通过<code>mypy</code>检查出第二种调用方式是错误的。 虽然这种示例简简单单， 看不出什么痛点， 但是在复杂的逻辑中， 他的优势就非常明显了。</p>
<p>在项目中可以通过<code>poetry add mypy --dev</code>安装依赖包， 然后通过在根目录增加<code>mypy.ini</code>文件：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><code class="hljs ini"><span class="hljs-comment"># mypy的核心配置</span><br><span class="hljs-section">[mypy]</span><br><span class="hljs-comment"># 指明函数的值类型也要检查</span><br><span class="hljs-attr">disallow_untyped_defs</span> = <span class="hljs-literal">True</span><br><span class="hljs-comment"># 忽略一些import的错误， 有些旧包架构可能不符合mypy的要求</span><br><span class="hljs-attr">ignore_missing_imports</span> = <span class="hljs-literal">True</span><br><br><span class="hljs-comment"># 指明针对根目录tests的配置</span><br><span class="hljs-section">[mypy-tests.*]</span><br><span class="hljs-comment"># 指明忽略对这个范围的检查</span><br><span class="hljs-attr">ignore_errors</span> = <span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure>
<p>指定<code>mypy</code>该如何执行， 最后调用<code>poetry run mypy .</code>即可</p>
<h2 id="2-3-自动格式化代码"><a href="#2-3-自动格式化代码" class="headerlink" title="2.3.自动格式化代码"></a>2.3.自动格式化代码</h2><p>Python是一个动态语言， 而且不会对代码风格做强要求， 这就会导致一千个人一千种Python代码风格， 这同样在大型项目中非常糟糕的…好在Python生态中有很多自动格式化的工具， 但这里并不会详细对比他们的差异， 只是简要介绍下我在试用了多种后保留了以下3个工具（适不适合自己团队， 还是得自己试试才知道）：</p>
<ul>
<li>1.autopep8, 这个工具主要用来移除没有使用到的import语句， 这个功能在需要开源的工具包中， autopep8是做得最好的， 但部分场景下可能没有<code>Pycharm</code>好用，可惜<code>Pycharm</code>只能手动按快捷键一个文件一个文件的格式化…<br>autopep8可以通过<code>poetry add autopep8 --dev</code>进行安装， 它的配置参数十分简单， 所以只提供命令， 没有配置文件， 他的主要命令对应用途如下：<ul>
<li><code>--in-place</code>: 直接对文件进行更改， 而不是把差异打印出来（用它就要相信他）</li>
<li><code>--exclude</code>: 排除哪些文件/文件夹不进行格式化</li>
<li><code>--recursive</code>: 递归的遍历文件</li>
<li><code>--remove-all-unused-imports</code>: 删除所有未导入的依赖包</li>
<li><code>--ignore-init-module-imports</code>: 删除所有未导入的包时排除<code>__init__.py</code>文件</li>
<li><code>--remove-unused-variables</code>:删除未使用的变量</li>
</ul>
</li>
<li>2.isort, 这个工具主要是用来给import语句进行格式化， 比如语句超出文件允许最大长度自动换行， 以及对import语句进行自动排序（这个功能对强迫症来说爽飞了）。<br>isort可以通过<code>poetry add isort --dev</code>进行安装， isort支持<code>pyproject.toml</code>文件配置， 以下是我的一个常用配置:<figure class="highlight toml"><table><tr><td class="code"><pre><code class="hljs toml"><span class="hljs-section">[tool.isort]</span><br><span class="hljs-comment"># 兼容black模式, 因为使用到了black进行自动格式化</span><br><span class="hljs-attr">profile</span> = <span class="hljs-string">&quot;black&quot;</span><br><span class="hljs-comment"># 当import包过多超过文件长度后需要换行时， 采用哪种模式</span><br><span class="hljs-attr">multi_line_output</span> = <span class="hljs-number">3</span><br><span class="hljs-attr">include_trailing_comma</span> = <span class="hljs-literal">true</span><br><span class="hljs-attr">force_grid_wrap</span> = <span class="hljs-number">0</span><br><span class="hljs-attr">use_parentheses</span> = <span class="hljs-literal">true</span><br><span class="hljs-attr">ensure_newline_before_comments</span> = <span class="hljs-literal">true</span><br><span class="hljs-comment"># 每行的最长长度</span><br><span class="hljs-attr">line_length</span> = <span class="hljs-number">120</span><br><span class="hljs-comment"># 忽略的文件夹</span><br><span class="hljs-attr">skip_glob</span> = <span class="hljs-string">&quot;tests&quot;</span><br></code></pre></td></tr></table></figure></li>
<li>3.black, 号称不妥协的自动格式化工具， 只要它认为不合适的， 就自动格式化， 没有选择的余地， 如果与团队标准不一样的请慎用， 我是挺接受他的自动格式化风格的…。<br>black可以通过<code>poetry add black --dev</code>进行安装， mypy同样支持<code>pyprojrct.toml</code>文件配置， 以下是我的一个常用配置(black的配置项不多):<figure class="highlight toml"><table><tr><td class="code"><pre><code class="hljs toml"><span class="hljs-section">[tool.black]</span><br><span class="hljs-comment"># 每行的最长长度</span><br><span class="hljs-attr">line-length</span> = <span class="hljs-number">120</span><br><span class="hljs-comment"># 当前是哪个Python版本</span><br><span class="hljs-attr">target-version</span> = [<span class="hljs-string">&#x27;py37&#x27;</span>]<br></code></pre></td></tr></table></figure>
<h2 id="3-pre-commit"><a href="#3-pre-commit" class="headerlink" title="3.pre-commit"></a>3.pre-commit</h2>自动格式化的工具引入到项目没多久后就会开始寻求自动化了， 因为每次提交之前都要手动跑一些自动格式化的脚本， 实在是太麻烦了， 好在有<code>pre-commit</code>这个专门为<code>git hooks</code>而生的工具。</li>
</ul>
<p><code>pre-commit</code> 是一个用于管理和维护多种语言的 <code>git pre-commit hooks</code> 框架，就像Python的包管理器 <code>pip</code> 一样，可以通过 <code>pre-commit</code> 将他人创建并分享的 <code>pre-commit hooks</code> 安装到自己的项目仓库中。 <code>pre-commit</code> 的出现大大减少了我们使用 <code>git hooks</code> 的难度，只需要在配置文件中指定想要的 <code>hooks</code>，它会替你安装任意语言编写的 <code>hooks</code> 并解决环境依赖问题，然后在每次提交前执行<code>hooks</code>。</p>
<h3 id="3-1-安装"><a href="#3-1-安装" class="headerlink" title="3.1.安装"></a>3.1.安装</h3><p>一般来说， 通过<code>pip install pre-commit</code>就可以安装了， 但是为了环境隔离， 需要使用 <code>poetry add pre-commit --dev</code>安装， 安装完后就可以在项目根目录创建文件<br><code>.pre-commit-config.yaml</code>, 以下是我的配置， 除了上面提到的几个工具外， 还有一些其他脚本的校验工具:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">repos:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">repo:</span> <span class="hljs-string">https://github.com/pre-commit/mirrors-mypy</span><br>    <span class="hljs-attr">rev:</span> <span class="hljs-string">v0.910</span><br>    <span class="hljs-attr">hooks:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">mypy</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">repo:</span> <span class="hljs-string">https://github.com/PyCQA/isort</span><br>    <span class="hljs-attr">rev:</span> <span class="hljs-number">5.9</span><span class="hljs-number">.3</span><br>    <span class="hljs-attr">hooks:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">isort</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">repo:</span> <span class="hljs-string">https://github.com/psf/black</span><br>    <span class="hljs-attr">rev:</span> <span class="hljs-number">21.</span><span class="hljs-string">7b0</span><br>    <span class="hljs-attr">hooks:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">black</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">repo:</span> <span class="hljs-string">https://github.com/PyCQA/flake8</span><br>    <span class="hljs-attr">rev:</span> <span class="hljs-number">3.9</span><span class="hljs-number">.2</span><br>    <span class="hljs-attr">hooks:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">flake8</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">repo:</span> <span class="hljs-string">https://github.com/myint/autoflake</span><br>    <span class="hljs-attr">rev:</span> <span class="hljs-string">v1.4</span><br>    <span class="hljs-attr">hooks:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">autoflake</span><br>        <span class="hljs-attr">args:</span> [<span class="hljs-string">&#x27;--recursive&#x27;</span>,  <span class="hljs-string">&#x27;--in-place&#x27;</span>, <span class="hljs-string">&#x27;--remove-all-unused-imports&#x27;</span>, <span class="hljs-string">&#x27;--remove-unused-variable&#x27;</span>]<br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">repo:</span> <span class="hljs-string">https://github.com/pre-commit/pre-commit-hooks</span><br>    <span class="hljs-attr">rev:</span> <span class="hljs-string">v3.2.0</span><br>    <span class="hljs-attr">hooks:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">check-ast</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">check-byte-order-marker</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">check-case-conflict</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">check-docstring-first</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">check-executables-have-shebangs</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">check-json</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">check-yaml</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">debug-statements</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">detect-private-key</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">end-of-file-fixer</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">trailing-whitespace</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">mixed-line-ending</span><br></code></pre></td></tr></table></figure>
<p>文件中的内容很简单， 它指明使用了哪些工具， 工具是哪个版本， 以及使用哪些<code>hook</code>(一个仓库可能有多个hook), 每个参数的解释如下：</p>
<ul>
<li>repo: 仓库url， pre-commit通过git来安装存在于github的工具</li>
<li>rev: 每个工具的版本， 这里是利用到git的tag属性</li>
<li>hooks/id: 每个仓库会有很多个hook, 通过hooks-id来选择要使用的hooks</li>
<li>hook/id/args: 每个hook都支持一些参数， args就是配置hook的参数</li>
</ul>
<p>这些工具都会读取根目录的配置文件， 而<code>autoflake</code>我找不到他的<code>pyproject.toml</code>配置说明， 所以直接通过的<code>args</code>参数配置参数。<br>之后就可以直接调用<code>hook</code>脚本， 如果是第一次引入已有项目则应该先手动调用<code>poetry run pre-commit run --all-files</code>, 他会调用所有<code>hook</code>对项目进行检查, 然后再根据检查结果对代码和配置进行调整。<br>调整完毕之后可以调用<code>poetry run pre-commit install</code>把<code>hook</code>脚本进行安装，它会自动安装在<code>.git/hooks/pre-commit</code>。安装后， 每执行次<code>git commit</code>时， 都会通过<code>git hooks</code>机制自动执行脚本， 自动对代码进行检查和格式化。 </p>
<p>上面的配置文件是我的常用配置， <code>pre-commit</code>的hook有很多, 不止这些, 如有兴趣可以到<a href="https://pre-commit.com/hooks.html">pre-commit hook合集</a>查阅所有hook</p>
<h2 id="4-远程仓库自动执行"><a href="#4-远程仓库自动执行" class="headerlink" title="4.远程仓库自动执行"></a>4.远程仓库自动执行</h2><p>本地的hook只针对本地提交者， 而在团队协作中， 其他人员可以暂时屏蔽或者删除hook文件， 导致本地hook没办法达到强制的作用， 所以团队一般会在Github&amp;Gitlab中的<code>pre-recevice</code>阶段配置一个自己的脚本， 用来跑上面的代码检测工具， 虽然两种的做法有点不同， 但核心步骤都是一样：</p>
<ul>
<li>1.先拉取最新的代码到容器里</li>
<li>2.安装阶段， 这时候会向容器安装Python版本以及类似<code>Redis</code>容器等等</li>
<li>3.代码检查， 这时候会运行代码质量检测工具， 如果有一个检测错误， 那么就拒绝提交， 并显示哪里错误了, 如果没有问题就走下一步。</li>
<li>4.测试阶段， 该阶段会运行测试用例，检测测试代码覆盖率是否合格， 同样的， 如果检测不合格就会拒绝提交， 成功就进入下一步。</li>
<li>4.风格统一， 使用风格统一插件， 如Python中的<code>isort</code>, <code>black</code>等， 把项目的代码进行格式化。</li>
</ul>
<p>一般每个公司都有自己的一套标准<code>CI/CD</code>， 而他们的使用方法可能都会有些差别, 但核心原理也差不多， 以下会以开源项目为例介绍如何使用Github的action(这个功能是免费的！！！).</p>
<blockquote>
<p>Gitlab的CI/CD相关文章比较多， 可以查阅网络或查阅书籍<a href="https://book.douban.com/subject/6862062/">《持续交付》</a>, 也可以查看文章：<a href="https://www.mindtheproduct.com/what-the-hell-are-ci-cd-and-devops-a-cheatsheet-for-the-rest-of-us/%EF%BC%8C">https://www.mindtheproduct.com/what-the-hell-are-ci-cd-and-devops-a-cheatsheet-for-the-rest-of-us/，</a> 如果对Gitlab hook有兴趣可以查阅<a href="treesir.pub/post/gitlab-pre-receive-webhook">Gitlab pre-receive webook 的添加与使用</a></p>
</blockquote>
<p>该例子来自于我的项目<a href="https://github.com/so1n/rap">rap</a>。 首先在项目目录创建<code>script</code>目录， 这里面的目录可以被本地调用， 但主要还是用于<code>Github action</code>, 首先创建一个install的脚本, 这个脚本用于安装依赖包：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/sh -e</span><br><br><span class="hljs-comment"># Use the Python executable provided from the `-p` option, or a default.</span><br>[ <span class="hljs-string">&quot;<span class="hljs-variable">$1</span>&quot;</span> = <span class="hljs-string">&quot;-p&quot;</span> ] &amp;&amp; PYTHON=<span class="hljs-variable">$2</span> || PYTHON=<span class="hljs-string">&quot;python3&quot;</span><br><br>REQUIREMENTS=<span class="hljs-string">&quot;requirements-dev.txt&quot;</span><br>VENV=<span class="hljs-string">&quot;venv&quot;</span><br><br><span class="hljs-built_in">set</span> -x<br><br><span class="hljs-keyword">if</span> [ -z <span class="hljs-string">&quot;<span class="hljs-variable">$GITHUB_ACTIONS</span>&quot;</span> ]; <span class="hljs-keyword">then</span><br>    <span class="hljs-string">&quot;<span class="hljs-variable">$PYTHON</span>&quot;</span> -m venv <span class="hljs-string">&quot;<span class="hljs-variable">$VENV</span>&quot;</span><br>    PIP=<span class="hljs-string">&quot;<span class="hljs-variable">$VENV</span>/bin/pip&quot;</span><br><span class="hljs-keyword">else</span><br>    PIP=<span class="hljs-string">&quot;pip&quot;</span><br><span class="hljs-keyword">fi</span><br><br><span class="hljs-string">&quot;<span class="hljs-variable">$PIP</span>&quot;</span> install -r <span class="hljs-string">&quot;<span class="hljs-variable">$REQUIREMENTS</span>&quot;</span><br></code></pre></td></tr></table></figure>
<p>注意这里是以<code>venv</code>为虚拟环境依赖的， 而不是我上面提到的<code>poetry</code>. 使用<code>venv</code>的原因是线上一般是一个机器跑一个项目， 同时生产的机器都追求稳定， 这时候venv简单而稳定的好处就体现出来了， 所以比较推荐在线上使用<code>venv</code>。 上面这个脚本就是创建一个虚拟环境， 然后根据<code>requirements-dev.txt</code>安装测试环境依赖。 </p>
<p>依赖部分搞定了， 接下来就是告诉<code>Github action</code>该如何进行代码质量检查了， 于是编写一个check的脚本：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/sh -e</span><br><br><span class="hljs-built_in">export</span> PREFIX=<span class="hljs-string">&quot;&quot;</span><br><span class="hljs-keyword">if</span> [ -d <span class="hljs-string">&#x27;venv&#x27;</span> ] ; <span class="hljs-keyword">then</span><br>    <span class="hljs-built_in">export</span> PREFIX=<span class="hljs-string">&quot;venv/bin/&quot;</span><br><span class="hljs-keyword">fi</span><br><br><span class="hljs-built_in">set</span> -x<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;use venv path:&#x27;</span> <span class="hljs-variable">$&#123;PREFIX&#125;</span><br><span class="hljs-variable">$&#123;PREFIX&#125;</span>mypy .<br><span class="hljs-variable">$&#123;PREFIX&#125;</span>flake8<br><span class="hljs-variable">$&#123;PREFIX&#125;</span>isort .<br><span class="hljs-variable">$&#123;PREFIX&#125;</span>black .<br><span class="hljs-variable">$&#123;PREFIX&#125;</span>autoflake --in-place --remove-unused-variables --recursive .<br></code></pre></td></tr></table></figure>
<p>这个脚本就是简单的调用各个命令， 命令的顺序就如同上面一样， 先进行代码检查， 再跑测试用例， 最后进行代码格式化。 这里的命令没有写各个的配置， 因为他们都会自动读取项目下的配置文件， 与我们的本地hook保持一致。</p>
<p>给Github action调用的脚本创建好后， 就开始创建真正的Github action文件了。 首先在项目创建<code>.github/workflows</code>目录， 并在<code>.github/workflows</code>目录创建<code>test-suite.yml</code>文件(文件的更多说明见<a href="https://docs.github.com/cn/actions/learn-github-actions/introduction-to-github-actions">官方文档</a>)：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-comment"># 指定workflows名称</span><br><span class="hljs-attr">name:</span> <span class="hljs-string">Test</span> <span class="hljs-string">Suite</span><br><br><span class="hljs-comment"># 指定操作push到master, 或者提pr到master时才执行</span><br><span class="hljs-attr">on:</span><br>  <span class="hljs-attr">push:</span><br>    <span class="hljs-attr">branches:</span> [<span class="hljs-string">&quot;master&quot;</span>]<br>  <span class="hljs-attr">pull_request:</span><br>    <span class="hljs-attr">branches:</span> [<span class="hljs-string">&quot;master&quot;</span>]<br><br><span class="hljs-attr">jobs:</span><br>  <span class="hljs-attr">tests:</span><br>    <span class="hljs-comment"># 设置任务名</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">&quot;Python $<span class="hljs-template-variable">&#123;&#123; matrix.python-version &#125;&#125;</span>&quot;</span><br>    <span class="hljs-comment"># 选择跑在哪种容器类型 </span><br>    <span class="hljs-attr">runs-on:</span> <span class="hljs-string">&quot;ubuntu-latest&quot;</span><br><br>    <span class="hljs-comment"># 设置变量, 这里设置多个Python版本表示会对每个Python版本都运行一次</span><br>    <span class="hljs-attr">strategy:</span><br>      <span class="hljs-attr">matrix:</span><br>        <span class="hljs-attr">python-version:</span> [<span class="hljs-string">&quot;3.6&quot;</span>, <span class="hljs-string">&quot;3.7&quot;</span>, <span class="hljs-string">&quot;3.8&quot;</span>, <span class="hljs-string">&quot;3.9&quot;</span>, <span class="hljs-string">&quot;3.10.0-beta.3&quot;</span>]<br><br>    <span class="hljs-attr">steps:</span><br>      <span class="hljs-comment"># 调用官方的检查和安装python版本 </span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">uses:</span> <span class="hljs-string">&quot;actions/checkout@v2&quot;</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">uses:</span> <span class="hljs-string">&quot;actions/setup-python@v2&quot;</span><br>        <span class="hljs-attr">with:</span><br>          <span class="hljs-attr">python-version:</span> <span class="hljs-string">&quot;$<span class="hljs-template-variable">&#123;&#123; matrix.python-version &#125;&#125;</span>&quot;</span><br>      <span class="hljs-comment"># 更改脚本权限</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">&quot;Change permissions&quot;</span><br>        <span class="hljs-attr">run:</span> <span class="hljs-string">|</span><br>          <span class="hljs-string">chmod</span> <span class="hljs-string">+x</span> <span class="hljs-string">scripts/install</span><br>          <span class="hljs-string">chmod</span> <span class="hljs-string">+x</span> <span class="hljs-string">scripts/check</span><br>      <span class="hljs-comment"># 安装依赖</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">&quot;Install dependencies&quot;</span><br>        <span class="hljs-attr">run:</span> <span class="hljs-string">&quot;scripts/install&quot;</span><br>      <span class="hljs-comment"># 进行检查  </span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">&quot;Run linting checks&quot;</span><br>        <span class="hljs-attr">run:</span> <span class="hljs-string">&quot;scripts/check&quot;</span><br></code></pre></td></tr></table></figure>
<p>文件编写完毕后就可以推送代码到远程了, 然后就可以到Github对应的项目地址查看action执行情况， 一般成功结果如下(这里只测一个Python3.7, 如果失败了， 你还会收到邮件提醒)：<br><img    class="lazyload" data-original="https://i.loli.net/2021/08/16/c245ljF7afmPZb8.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">截图录屏_选择区域_20210816152722.png</span><br>也可以点开查看某个步骤的详情， 比如检查代码的详情:<br><img    class="lazyload" data-original="https://i.loli.net/2021/08/16/13JDRYEtLGvSOkB.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">截图录屏_选择区域_20210816152735.png</span></p>
<h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5.总结"></a>5.总结</h2><p>这些工具都是我慢慢实践和整合后找到最符合自己的构建Python项目质量的工具集了， 但是这些工具只能检查表面情况， 而其他情况如代码逻辑是否有问题， 则需要编写测试用例后再运行才能知道。而有些团队甚至会采用压力测试， 线上仿真测试等等， 这些工具/系统的引入和使用初期会带来很大的学习和时间成本， 但它们却能让项目一直保持茁壮成长, 减少线上项目Bug出现的次数（当然这些工具还有测试用例等等也要一起跟着维护）。</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Redis做消息队列</title>
    <url>/2021/04/23/%E4%BD%BF%E7%94%A8Redis%E5%BD%93%E5%81%9A%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h2 id="前记"><a href="#前记" class="headerlink" title="前记"></a>前记</h2><p><code>Redis</code>拥有很多数据结构, 是一个非常灵活的内存数据库, 基本上很多后端业务都会用到<code>Redis</code>, 在网络社区中, 经常听到可以使用<code>Redis</code>来当做XXX的问题, 在第一次接触消息队列时, 会有一个疑问, 可以使用<code>Redis</code>当做消息队列吗? <code>Redis</code>容易部署与维护, 而且一般都业务已经有一套<code>Redis</code>在跑了, 开发人员也拥有了一些使用经验, 为什么一定要重新去用<code>Kafka</code>或者<code>RabbitMQ</code>呢? 如果选用<code>Redis</code>做消息队列, 哪用哪种数据结构会比较好呢? 在<code>Redis</code>中, 可以使用<code>Stream</code>当做消息队列, 但是由于<code>Redis</code>是一个内存型数据结构, 所以他并不是一个完备的消息队列, 还是有丢日志的可能, 如果要确保一个日志都不丢, 那还是得上硬盘型的消息队列.</p>
<span id="more"></span>
<h2 id="1-消息队列"><a href="#1-消息队列" class="headerlink" title="1.消息队列:"></a>1.消息队列:</h2><p>在内存中实现一个消息队列很简单, 消息队列的基础数据结构模型就是双端队列(双向链表), 然后只要确保这个双端队列的一端由生产者推数据进去, 消费者从另一端获取数据, 就是一个简单版的消息队列了.<br>但是这种实现是在程序内部, 需要考虑的事比较少, 如果转移到一个公共服务, 需要考虑的问题就很多了, 比如消息堆积, 还有网络的导致消息的收发问题等等, 而解决这些问题也可以认为是消息队列的特性:</p>
<ul>
<li>1.支持重复消费(可选), 这个往往不是最重要的, 但有这个特性会比较好.</li>
<li>2.每个消息应该确保被消费, 也就是消息不丢, 即使堆积了很多消息, 前面的消息也不能删除, 除非人为确定不需要了.</li>
<li>3.消息按照发送的顺序消费, 消费者的消费消息顺序和发送者发送的发送顺序一致.</li>
<li>4.支持阻塞等待拉消息, 防止消费者CPU空转.</li>
<li>5.消息不会因为自己消息队列本身服务挂了而丢数据.</li>
<li>6.有完善的消息队列监控.</li>
<li>7.可以对未完成消息的处理.</li>
</ul>
<h2 id="2-List"><a href="#2-List" class="headerlink" title="2.List"></a>2.List</h2><p>在<code>Stream</code>未出现之前, 很多新手都会使用(或者想使用)<code>List</code>来当做消息队列, <code>List</code>他的底层实现是一个双向链表, 他能从头部和尾部操作元素, 能满足先进先出, 而且操作的时间复杂度都是O(1), 这都很符合消息队列的基础模型.<br>如果把<code>List</code>当做消息队列, 那么可以通过以下语法使用:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># Redis支持双端操作, 以下遵循左进右出</span><br><br><span class="hljs-comment"># 使用LPUSH语法, 往test_queue队列, 并放入1, 队列不存在自动创建</span><br>127.0.0.1:6379&gt; LPUSH test_queue 1<br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; LPUSH test_queue 2<br>(<span class="hljs-built_in">integer</span>) 2<br>127.0.0.1:6379&gt; LPUSH test_queue 3<br>(<span class="hljs-built_in">integer</span>) 3<br><span class="hljs-comment"># 通过命令 查看队列可以发现 目前有三个值</span><br>127.0.0.1:6379&gt; LRANGE test_queue 0 5<br>1) <span class="hljs-string">&quot;3&quot;</span><br>2) <span class="hljs-string">&quot;2&quot;</span><br>3) <span class="hljs-string">&quot;1&quot;</span><br><span class="hljs-comment"># 弹出最先进去的值 1</span><br>127.0.0.1:6379&gt; RPOP test_queue<br><span class="hljs-string">&quot;1&quot;</span><br><span class="hljs-comment"># 只剩下后面进来的2和3</span><br>127.0.0.1:6379&gt; LRANGE test_queue 0 5<br>1) <span class="hljs-string">&quot;3&quot;</span><br>2) <span class="hljs-string">&quot;2&quot;</span><br>127.0.0.1:6379&gt; RPOP test_queue<br><span class="hljs-string">&quot;2&quot;</span><br>127.0.0.1:6379&gt; RPOP test_queue<br><span class="hljs-string">&quot;3&quot;</span><br><span class="hljs-comment"># 元素弹完了, 队列被删除</span><br>127.0.0.1:6379&gt; LRANGE test_queue 0 5<br>(empty list or <span class="hljs-built_in">set</span>)<br><br></code></pre></td></tr></table></figure>
<p>看完上面的操作, 会发现非常容易使用也非常容易理解, 但是消费者与<code>Redis</code>是通过网络交互的, 且不是在同一个进程, 这时候需要考虑的问题就来了, 当队列中没有消息时<br>消费者在执行<code>RPOP</code>时, 会发现队列是空的, 为了能继续工作, 程序里需要写一个死循环, 一直等数据到来(一般来说消费者也都是在一个循环里面), 这个时候不止会让CPU空转, 还会一直发消息给<code>Redis</code>, 增加<code>Redis</code>的压力.一般情况下会考虑增加一个休眠都逻辑, 不过休眠过长, 会影响消费的及时性, 还好<code>Redis</code>是一个服务, 他能提供了一个机制: 当队列为空且消费者来拉数据时, 让消费者先等待, 直到有数据过来, 再返回数据给消费者, 这样就可以减少很多网络请求了. 而要使用这个机制也很简单, 只要把<code>RPOP</code>改为<code>BRPOP</code>即可, <code>BRPOP</code>的<code>B</code>就是block的意思:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; LPUSH test_queue 1<br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; BRPOP test_queue<br><span class="hljs-string">&quot;1&quot;</span><br></code></pre></td></tr></table></figure>
<p>不过需要注意的是, 客户端一定要启用保活机制或者重连机制, 防止太久没有发送数据被<code>Redis</code>服务判断链接失活断开.此外, <code>Redis</code>无法知道消费者获取消息后有没有正确处理完消息, 可能在获得消息后就丢了消息, 或者处理时突然发生异常, 就直接丢消息了.</p>
<p>可以发现<code>List</code>没办法确保消息一定能被消费是很恐怖的一件事, 除非这个系统能容忍丢一些消息, 但是使用者是无法知道<code>List</code>丢了那些消息, 除非发送者和接收者都有日志记录, 最后再通过日志记录去匹配.</p>
<h2 id="2-Pub-Sub"><a href="#2-Pub-Sub" class="headerlink" title="2.Pub/Sub"></a>2.Pub/Sub</h2><p><code>List</code>只能有一个消费者可以获得到消息, 那如果有多个消费者, 只要确保消费者收到消息后处理消息能逻辑能幂等, 那就能降低丢日志的可能性了, 虽然整个系统的性能会偏差一些.</p>
<p><code>Pub/Sub</code>原本的意思是发布/订阅, 生成者发布一条消息, 多个订阅的消费者都能得到这条消息.</p>
<p>在使用<code>Pub/Sub</code>中, 需要启动订阅者, 之后订阅者会阻塞, 等待消息的到来,最后再启用发送:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 启动消费者1</span><br>127.0.0.1:6379&gt; SUBSCRIBE test_queue<br>subscribe from test_queue: 1<br><span class="hljs-comment"># 启动消费者2</span><br>127.0.0.1:6379&gt; SUBSCRIBE test_queue<br>subscribe from test_queue: 2<br><span class="hljs-comment"># 发送者发送消息</span><br>127.0.0.1:6379&gt; PUBLISH test_queue a<br>(<span class="hljs-built_in">integer</span>) 1<br><br><span class="hljs-comment"># 消费者1收到的消息</span><br>127.0.0.1:6379&gt; SUBSCRIBE test_queue<br>subscribe from test_queue: 1<br>message   from test_queue: a<br><span class="hljs-comment"># 消费者2收到的消息</span><br>127.0.0.1:6379&gt; SUBSCRIBE test_queue<br>subscribe from test_queue: 2<br>message   from test_queue: a<br></code></pre></td></tr></table></figure>
<p>可以看到<code>Pub/Sub</code>的使用方式也很简单, 但是通过使用<code>Pub/Sub</code>以及消费者幂等处理消息, 虽然能解决部分丢数据的问题, 但是<code>Pub/Sub</code>的实现会带来一个更明显的缺点, 由于<code>Pub/Sub</code>没有基于任何数据类型, 只是一个通道, 把数据从一端转发到一端, 不会有任何的数据存储, 如果这时候消费者下线了, 那么这个消息就没办法再到消费者手中, 如果所有消费者都下线了, 那当前的消息就会被丢弃了, 这个直接违背了消息队列的原则.<br>此外, 在消息积压上面也有个致命的问题, 发布者发布消息后, <code>Redis</code>会发给消费者, 如果消费者处理不及时, 会把消息积压在发送给消费者的缓冲区之中, 如果这个缓冲区的数量达到配置的上限, 那么<code>Redis</code>就会认为这个消费者可能失去了消费能力, 与他断开连接, 所以<code>Pub/Sub</code>方案是不可取的.</p>
<h2 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h2><p>综合上面两个类型后, 可以发现<code>Redis</code>并不是很胜任消息队列这个应用, 但很多人还会把<code>Redis</code>的<code>List</code>当做消息队列, <code>Redis</code>的作者还开发了一个叫<code>disque</code>的项目, 他就是一个基于内存的分布式消息队列, 在<code>Redis</code> 5.0之后, 合并到<code>Redis</code>之中, 也就是<code>Stream</code>, <code>Stream</code>是一个完备的分布式内存消息队列, 如果用过其他类似的内存消息队列, 会发现别的内存消息队列有的, <code>Stream</code>基本都有.</p>
<p>首先看看<code>Stream</code>的一个简单应用–发布与消费<br>在<code>Stream</code>之中, 通过<code>XADD</code>发布消息, 通过<code>XREAD</code>消费消息, 同时他的消息都带有自己的唯一ID, 也可以是我们自己设置的ID, 但要确保唯一, 使用如下:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># *代表redis自己生成的消息id, 格式是timestamp + 自增序号</span><br>127.0.0.1:6379&gt; XADD test_queue * field1 value1<br><span class="hljs-string">&quot;1620618087884-0&quot;</span><br>127.0.0.1:6379&gt; XADD test_queue * field1 value1 field2 value2<br><span class="hljs-string">&quot;1620618092658-0&quot;</span><br><br><span class="hljs-comment"># 代表从头获取3个消息, 由于目前只有2个, 只返回两个</span><br>127.0.0.1:6379&gt; XREAD COUNT 3 STREAMS test_queue 0-0<br>1) 1) <span class="hljs-string">&quot;test_queue&quot;</span><br>   2) 1) 1) <span class="hljs-string">&quot;1620618087884-0&quot;</span><br>         2) 1) <span class="hljs-string">&quot;field1&quot;</span><br>            2) <span class="hljs-string">&quot;value1&quot;</span><br>      2) 1) <span class="hljs-string">&quot;1620618092658-0&quot;</span><br>         2) 1) <span class="hljs-string">&quot;field1&quot;</span><br>            2) <span class="hljs-string">&quot;value1&quot;</span><br>            3) <span class="hljs-string">&quot;field2&quot;</span><br>            4) <span class="hljs-string">&quot;value2&quot;</span><br><span class="hljs-comment"># 获取上个消息ID之后的消息</span><br><br><span class="hljs-comment"># 如果没有消息, 会返回空(这里是iredis客户端解析的问题)</span><br>127.0.0.1:6379&gt; XREAD COUNT 1 STREAMS test_queue 1619024293085-0<br>(error) ERROR <span class="hljs-string">&#x27;NoneType&#x27;</span> object is not iterable<br><span class="hljs-comment"># 可以改用阻塞式拉取, 设置为0代表不超时, 设置其他参数代表超时时间, 单位为秒, 一般建议设置一个自己的超时时间数, 如果超时了继续发起一个等待, 防止没有开保活之类的机制导致客户端与服务端的链接断开.</span><br>127.0.0.1:6379&gt; XREAD COUNT 1 BLOCK 0 STREAMS test_queue 1619024293085-0<br></code></pre></td></tr></table></figure>
<p>看起来<code>Stream</code>的发送和消费逻辑都挺正常的, 消费者只要通过上个消息的ID 来请求, 就能一直获取到新的消息, 而且还能读历史数据(可以试着断开客户端重新连上, 还是一样能获得到消息的).不过上面的<code>XREAD</code>是独立消费的命令, 一般情况下还是用消费者组来消费会比较好. <code>Redis</code>的<code>Stream</code>使用了一种类似<code>Kafka</code>的消费组概念, 如下图, 生产者会把数据投到消息队列中, 每个消息都带有自己的消息id, 且这些id是趋势递增的, 而与消息队列接触的只有消费组,  随着组内成员的消费, 消费者组会往右移动, 消费者组中有个last_delivered_is, 用来记录当前移动到哪里了. 而消费者只能订阅到消费组, 消费组中所有的消费者共享着同一个last_deliverd_id标记, 多个消费者会共同消费到一个消费者组的消息, 他们不会读到下标一样的消息.<br>此外, 每个消费者还有一个叫pending_ids的变量, 用来表示已经被客户端读取到的但是还未ack的消息id, 客户端获取消息时, 就会把消息id存到这个变量, 如果收到客户端发过来该消息的id,则从变量中把该消息id移除. </p>
<p><img    class="lazyload" data-original="https://github.com/so1n/so1n_blog_photo/blob/master/blog_photo/redis-stream.png?raw=true" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">redis-stream</span></p>
<p><code>Stream</code>功能比较多, 以下是几个使用<code>Stream</code>的例子:</p>
<ul>
<li>发布/订阅模式:<br>  了解了<code>Pub/Sub</code>后, 可以知道在消息队列中使用发布/订阅模式可以做一些兜底的操作, 比如消息需要比较及时响应时, 有多个消费者在消费同一个消息, 即使有一个挂了, 其他的消费者也能正常处理消息.<br>  在<code>Stream</code>中, 可以通过消费者组实现发布/订阅模式:   <figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 创建消费者组1</span><br>127.0.0.1:6379&gt; XGROUP CREATE test_queue test_group1 0-0<br><span class="hljs-string">&quot;OK&quot;</span><br><span class="hljs-comment"># 创建消费者组2</span><br>127.0.0.1:6379&gt; XGROUP CREATE test_queue test_group2 0-0<br><span class="hljs-string">&quot;OK&quot;</span><br><span class="hljs-comment"># 删除消费者组2</span><br>127.0.0.1:6379&gt; XGROUP DESTROY test_queue test_group2<br>(<span class="hljs-built_in">integer</span>) 1<br><span class="hljs-comment"># 创建消费者组2, 并设置以第二条消息的id为起点</span><br>127.0.0.1:6379&gt; XGROUP CREATE test_queue test_group2 1619024299524-0 <br><span class="hljs-string">&quot;OK&quot;</span><br><span class="hljs-comment"># 第一组消费者开始消费, 只消费一条, &gt; 代表从最新数据开始拉取, 由于没有携带NOCAK, 命令是自动ACK掉消息的</span><br>127.0.0.1:6379&gt; XREADGROUP GROUP test_group1 consumer COUNT 1 STREAMS test_queue &gt;<br>1) 1) <span class="hljs-string">&quot;test_queue&quot;</span><br>   2) 1) 1) <span class="hljs-string">&quot;1619024293085-0&quot;</span><br>         2) 1) <span class="hljs-string">&quot;field1&quot;</span><br>            2) <span class="hljs-string">&quot;value1&quot;</span><br>127.0.0.1:6379&gt; XREADGROUP GROUP test_group1 consumer COUNT 1 STREAMS test_queue &gt;<br>1) 1) <span class="hljs-string">&quot;test_queue&quot;</span><br>   2) 1) 1) <span class="hljs-string">&quot;1619024299524-0&quot;</span><br>         2) 1) <span class="hljs-string">&quot;field1&quot;</span><br>            2) <span class="hljs-string">&quot;value1&quot;</span><br>            3) <span class="hljs-string">&quot;field2&quot;</span><br>            4) <span class="hljs-string">&quot;value2&quot;</span> <br><span class="hljs-comment"># 第二组由于设置了是从第二条消息之后为起点, 所以是拿不到数据的</span><br>127.0.0.1:6379&gt; XREADGROUP GROUP test_group2 consumer COUNT 1 STREAMS test_queue &gt;<br>(error) ERROR <span class="hljs-string">&#x27;NoneType&#x27;</span> object is not iterable<br><br></code></pre></td></tr></table></figure></li>
<li>消费监控<br>  在<code>Stream</code>中带有一个简单的消息监控, 可以看到每个消费组有多少个消费者, 当前消费到那条信息:  <figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; xinfo GROUPS test_queue<br>1) 1) <span class="hljs-string">&quot;name&quot;</span><br>   2) <span class="hljs-string">&quot;test_group1&quot;</span><br>   3) <span class="hljs-string">&quot;consumers&quot;</span><br>   4) <span class="hljs-string">&quot;1&quot;</span><br>   5) <span class="hljs-string">&quot;pending&quot;</span><br>   6) <span class="hljs-string">&quot;2&quot;</span><br>   7) <span class="hljs-string">&quot;last-delivered-id&quot;</span><br>   8) <span class="hljs-string">&quot;1620618092658-0&quot;</span><br>2) 1) <span class="hljs-string">&quot;name&quot;</span><br>   2) <span class="hljs-string">&quot;test_group2&quot;</span><br>   3) <span class="hljs-string">&quot;consumers&quot;</span><br>   4) <span class="hljs-string">&quot;0&quot;</span><br>   5) <span class="hljs-string">&quot;pending&quot;</span><br>   6) <span class="hljs-string">&quot;0&quot;</span><br>   7) <span class="hljs-string">&quot;last-delivered-id&quot;</span><br>   8) <span class="hljs-string">&quot;1620618087884-0&quot;</span><br></code></pre></td></tr></table></figure></li>
<li>ACK<br>  从消费者监控中可以看到, test_group1中还有两条pending的消息, 这些都是消费者还未ack的消息, 当消费者启动时, 需要通过命令<code>xpending</code>主动查看尚在pending的消息, 根据消息id, 再次消费并提交ACK.这样就可以确保所有消息都能被消费者正常消费, 不会因为消费者本身的问题造成漏消费.  <figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看还未消费的消息和信息</span><br>127.0.0.1:6379&gt; xpending test_queue test_group1<br>1) <span class="hljs-string">&quot;2&quot;</span><br>2) <span class="hljs-string">&quot;1620618087884-0&quot;</span><br>3) <span class="hljs-string">&quot;1620618092658-0&quot;</span><br>4) 1) 1) <span class="hljs-string">&quot;consumer&quot;</span><br>      2) <span class="hljs-string">&quot;2&quot;</span><br><span class="hljs-comment"># 直接使用xac膜模拟消费者已经消费消息</span><br>127.0.0.1:6379&gt; xack test_queue test_group1 1620618087884-0<br>(<span class="hljs-built_in">integer</span>) 1<br><span class="hljs-comment"># 可以发现已经正常消费</span><br>127.0.0.1:6379&gt; xpending test_queue test_group1<br>1) <span class="hljs-string">&quot;1&quot;</span><br>2) <span class="hljs-string">&quot;1620618092658-0&quot;</span><br>3) <span class="hljs-string">&quot;1620618092658-0&quot;</span><br>4) 1) 1) <span class="hljs-string">&quot;consumer&quot;</span><br>      2) <span class="hljs-string">&quot;1&quot;</span><br></code></pre></td></tr></table></figure></li>
<li>消息堆积<br>  当消息队列发生消息堆积时, 一般会通过生产者限流或者丢弃旧消息两种方式, 由于<code>Redis</code>是一个内存型的应用, 所以空间是有限的, 不能无限增长, 同时删除消息的<code>xdel</code>命令也不是真正的删除消息, 而是打上一个标记位, 所以<code>Stream</code>很容易遇到队列满的情况, 在这种情况下, 生产者能通过调用xlen命令来查看队列的情况, 决定是否限流, 也可以使用maxlen选项, 在创建<code>Stream</code>的队列时, 规定队列的最长长度, 当队列里面积压的消息超过限度时, 旧消息就会被扔掉了.但是<code>Stream</code>是数据结构比较特殊(基于基数树), 如果经常做调整, 把消息队列限制在固定的数字, 那么会对性能造成一定的影响, 因此maxlen支持带<code>~</code>的命令,带上<code>~</code>后,<code>Stream</code>会基于当前的结构进行合理的调整, 比如设置为1000时, <code>Stream</code>会保证消息队列的长度大于1000后会进行调整, 但可能是1030, 1050之类的.  <figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 限制长度为2</span><br>127.0.0.1:6379&gt; XADD test_queue maxlen 2 * field1 value1<br><span class="hljs-comment"># 带上~选项</span><br>127.0.0.1:6379&gt; XADD test_queue maxlen ~ 2 * field1 value1<br></code></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过分析, <code>Stream</code>拥有了很多消息队列的特性, 但由于是内存型的消息队列, 并不是非常完备的, 就像他实现了ack逻辑, 解决了消费者处理消息过程中挂了造成消息丢失的问题, 但是由于Redis的AOF/RDB机制, 如果Redis挂了, 那很有可能造成<code>Stream</code>本身丢失几条消息, 而且<code>Stream</code>的消息堆积是有限的. 在选择是否要用<code>Stream</code>做消息队列时, 要先清楚我们的业务可以容忍丢一两条数据吗(或者有其他兜底), 以及从0上线一个<code>Kafka</code>或者<code>RabbitMQ</code>的成本是否极高, 不如直接使用现成的<code>Redis</code>.</p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>消息队列</tag>
      </tags>
  </entry>
  <entry>
    <title>2021plan</title>
    <url>/2021/02/10/2021plan/</url>
    <content><![CDATA[<h2 id="前记"><a href="#前记" class="headerlink" title="前记"></a>前记</h2><p>rm 2020plan.md<br>vi 2021plan.md</p>
<p>害, 今年很快, 一下子就过去了, 有很多的意外, 也有很多不甘, 但还是得向前看</p>
<span id="more"></span>

<h2 id="amp"><a href="#amp" class="headerlink" title="%$*&amp;^"></a>%$*&amp;^</h2><p>20这一年, 是技术突飞猛进的一年, 也是第一次换了工作, 第一次拥有猫猫,第一次知道有现金流有多重要, 很想在大城市有个家, 也很想念家里人.</p>
<h2 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h2><p>1.这一年在老东家做了很多新的东西, 可惜的是有些东西没有做完就走了. 想走的原因很简单, 就是成长空间只能靠自己去想象摸索, 没有人可以带我, 还有就是钱太少了, 还拿着一份像毕业时一样的工资, 都比不过同学的工资了.</p>
<p>2.换了工作后, 有了个比较完善的团队体验, 但是项目就是屎山级别的代码, 通过半年的逐渐升级, 改造, 重构,终于开始像一个像样的项目了. 然而这个项目的天花板已经摆在那里了,  后面可成长的空间也不大, 还有一个只会<code>Java</code>和<code>Mysql</code>的<code>Leader</code>,  有些东西没办法交流, 他也很难理解我们为什么这样做, 认为就必须用<code>Java</code>去重构这个项目, <code>Java</code>才是最好的…而我虽然是喜欢<code>Python</code>但我是坚信每个语言都有自己的独特之处, 没有一门语言适用于所有场景.</p>
<p>3.还有换到新公司后发现了一个很神奇的现象, 公司里大多数<code>Java</code>的开发工程师(没有冒犯所有程序员), 连程序在服务器是怎么跑起来的都不知道, 也不知道需要用守护进程去调用程序, 也不知道需要在<code>Sql</code>防注入… 难道都是作为螺丝钉吗,总觉得写这样的代码很没有意思.</p>
<p>4.公司实行okr体系, 能一定程度的让员工增加奋斗的意愿(指良性), 但是okr体系的公司, 很难对一些的体验进行量化量化, 如优化内部工具, 提高内部团队的生产效率. 而性能优化非常容易量化, 即使性能优化的提升远远不及编程体验, 但它的okr也非常高, 经常从事性能提升的人晋升会非常的快.</p>
<p>5.当公司拥有很多面试者时, 不能对每个人的知识进行考察, 只能以学历或者算法之类的先快速筛选掉面试者, 而面试者需要多花时间对应试内容进行储备, 即使这类准备最终无法投入到公司的生产之中.</p>
<p>6.很少公司能实现<code>管理并不是晋升</code>, 如果对技术抱负很高, 不想做管理的, 目前只能考虑成为独立贡献者, 但是也不能忘了当前社会更需要的是π型人才</p>
<h2 id="经济"><a href="#经济" class="headerlink" title="经济"></a>经济</h2><p>今年勉强完成了任务, 3月份开始踏入基金并被隔了一下, 不过从6月份后开始好转, 今年总收益率在30-40%左右, 还是不错的. 在玩基金前也研究了很多资料, 但今年的行情+市场 真的是啥资料都白搭, 不如all in 白酒.  </p>
<p>明年继续投基金, 然后再研究量化基金, 程序员就是要相信自己的量化程序[doge].</p>
<h2 id="身体"><a href="#身体" class="headerlink" title="身体"></a>身体</h2><p>今年运动量大幅减少了…没想到我的运动计划居然是被猫猫和996打破的, 还好最后捡了回来. 今年做了体检, 有高尿酸和三高, 感觉以后会成为大毛病, 今年还有一直努力健身, 不能落下, 争取瘦10斤!</p>
<h2 id="编程"><a href="#编程" class="headerlink" title="编程"></a>编程</h2><p>今年接触了一堆的中间件, 什么<code>Elasticsearch</code>, <code>Kafka</code>,<code>RabbitMq</code>,<code>Prometheus</code>,<code>etc</code>,<code>cliskhouse</code>等等, 视野拓展了很多, 不过有些底层我还没有深入去了解, 今年一定要先看懂<code>etc</code>,<code>prometheus</code>的底层/源码!</p>
<p>今年<code>SIP</code>项目终于完结了, 在上半年的努力下, 加了很多网络防御, 自研sip网关等等,  还有可以通过es查看整个通话链路以及通话数据,通话质量等等, 非常不错, 即使后面我离职了, 系统还能一直健康的自我运转, 不需要他人干预.</p>
<p>今年在自己的项目也有很多建树, 有<code>statsd</code>的aio客户端, <code>Grahpite</code>,<code>Elasticsearch</code>的exporter, 自研协议的rpc框架<code>rap</code>和为Python的几乎所有web框架 接口函数提供参数校验和文档输出的<code>pait</code>, 特别是后面两个耗了我很多心血, 但是还不是特别完善, 并没有打算做推广, 希望接下来的一年能把他们完善, 使其更加好用.</p>
<p>明年希望能在生产级别写c和go的项目, 然后自己再学会java,同时也别落下sip相关的知识, 看起来生活是很美好呢, 加油.</p>
<h2 id="读书"><a href="#读书" class="headerlink" title="读书"></a>读书</h2><p>害, 读书就是经常计划赶不上变化的, 今年读的书比以往的还要多,如<code>Elasticsearch</code>, <code>Ansible</code>,<code>Prometheus</code>, <code>Docker</code>, <code>Nginx</code>,<code>Openresty</code>相关的书, 但下面有基本都还没读完, 继续列好读书清单, 并真的完结了!.</p>
<p>希望明年会读是书:</p>
<ul>
<li>UNIX网络编程卷1：套接字联网API（第3版）</li>
<li>CPrimer Plus</li>
<li>重录一遍Tcp/ip详解</li>
<li>高性能Mysql</li>
<li>恰如其分的软件架构</li>
<li>etcd相关</li>
<li>clickhouse相关</li>
<li>k8s相关</li>
<li>服务网格相关</li>
<li>微服务相关</li>
</ul>
<h2 id="随心"><a href="#随心" class="headerlink" title="随心"></a>随心</h2><p>今年由于疫情, 哪里也去不了…不过玩了下广州的白云山和动物园, 感觉也很不错(来了广州6年才去…)</p>
<p>明年希望有空去北京, 带女朋友去最想去的地方, 让她开心一下</p>
<h2 id="main"><a href="#main" class="headerlink" title="main"></a>main</h2><p>做好自己, 做自己想做的事, 不让自己后悔.</p>
]]></content>
      <categories>
        <category>计划</category>
      </categories>
      <tags>
        <tag>计划</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL分区,分表,分库</title>
    <url>/2020/12/12/Mysql%E5%88%86%E5%8C%BA%20%E5%88%86%E8%A1%A8%E5%88%86%E5%BA%93/</url>
    <content><![CDATA[<p>在使用<code>MySQL</code>且数据库数据越来越大后就需要进行优化, 常见的方案有分区, 分表, 分库, 这三种听起来很类似, 也都起到了性能优化, 加快查询的作用, 但是他们的区别很大, 应用情况也不一样</p>
<span id="more"></span>

<h2 id="1-分区"><a href="#1-分区" class="headerlink" title="1.分区"></a>1.分区</h2><p>分区是一种数据库表的设计模式，分区是将一大表，根据条件分割成若干个小表, 但是对于应用程序来说是无感的, 只是通过优化器识别sql语句来识别当前的语句应该去查询哪个小表，分区的表和没有分区的表是一样的, 但能提升很大的查询性能。换句话来讲，分区对于应用是透明的，只是数据库对于数据的重新整理。</p>
<h2 id="1-1分区注意事项"><a href="#1-1分区注意事项" class="headerlink" title="1.1分区注意事项"></a>1.1分区注意事项</h2><p>分区表虽然很棒, 但是有很多限制和需要注意的事项：</p>
<ul>
<li>分区字段必须是整数类型或解析为整数的表达式.</li>
<li>分区字段建议设置为NOT NULL，若某行数据分区字段为null，在RANGE分区中，该行数据会划分到最小的分区里.(任何表的字段都不应该为null)</li>
<li>MySQL分区中如果存在主键或唯一键，则分区列必须包含在其中.(任何表都应该有主键)</li>
<li>Innodb分区表不支持外键.(业务里尽量减少使用外建)</li>
<li>更改sql_mode模式可能影响分区表的表现.</li>
<li>分区表不影响自增列.</li>
</ul>
<h2 id="1-2分区适用情况"><a href="#1-2分区适用情况" class="headerlink" title="1.2分区适用情况"></a>1.2分区适用情况</h2><p>分区表适用于一些日志记录表.这类表的特点是数据量大、并且有冷热数据区分，可以按照时间维度来进行数据归档。这类表是比较适合使用分区表的，因为分区表可以对单独的分区进行维护，对于数据归档更方便。</p>
<p>除此之外, 分区表还适用于其他情况, 如现在的业务经常有马甲包, 这类产品共享主逻辑, 唯一的区别就是包名不一样, 这时候我们可以对包名做分区, 避免每个包的查询都会扫描到别的包的记录.</p>
<h2 id="1-3分区的目的及分区类型"><a href="#1-3分区的目的及分区类型" class="headerlink" title="1.3分区的目的及分区类型"></a>1.3分区的目的及分区类型</h2><p><code>MySQL</code>在创建表的时候可以通过使用<code>PARTITION BY</code>子句定义每个分区存放的数据. 在执行查询的时候, 优化器根据分区定义过滤掉那些我们不需要的数据的分区, 这样查询就可以无需扫描所有分区, 只需要查找包含需要数据的分区即可.分区除了带来性能的提升外, 分区将数据按照一个较粗的粒度分别存放在不同的表中, 我们想要一次批量删除整个分区的数据也会变得很方便. 常见的分区类型有以下四种:</p>
<ul>
<li>RANGE分区: 基于属于一个给定连续区间的列值, 把多行分配给分区.最常见的是基于时间字段.RANGE分区的特点是多个分区的范围要连续，但是不能重叠，默认情况下使用<code>VALUES LESS THAN</code>属性，即每个分区不包括指定的那个值, 如下的分区代码, 以年这个字段分区, 会分为小于1990, 小于1995大于1990, 小于2000大于1995三个分区:  <figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"># 创建分区表<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `example_table` (<br>  `id` <span class="hljs-type">INT</span>, <br>  `name` <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">50</span>), <br>  `create_date` <span class="hljs-type">DATE</span><br>) ENGINE<span class="hljs-operator">=</span>InnoDB <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8<br><span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">BY</span> <span class="hljs-keyword">RANGE</span>( <span class="hljs-keyword">YEAR</span>(purchased) ) (<br><span class="hljs-keyword">PARTITION</span> p0 <span class="hljs-keyword">VALUES</span> LESS THAN (<span class="hljs-number">1990</span>),<br><span class="hljs-keyword">PARTITION</span> p1 <span class="hljs-keyword">VALUES</span> LESS THAN (<span class="hljs-number">1995</span>),<br><span class="hljs-keyword">PARTITION</span> p2 <span class="hljs-keyword">VALUES</span> LESS THAN (<span class="hljs-number">2000</span>)<br>);<br></code></pre></td></tr></table></figure></li>
<li>LIST分区： LIST分区和RANGE分区类似，区别在于LIST是枚举值列表的集合，RANGE是连续的区间值的集合.</li>
<li>HASH分区： 基于用户定义的表达式的返回值来进行选择的分区, 该表达式使用将要插入到表中的这些行的列值进行计算. 这个函数可以包含MySQL中有效的、产生非负整数值的任何表达式.</li>
<li>KEY分区: 类似于按HASH分区, 区别在于KEY分区只支持计算一列或多列, 且MySQL服务器提供其自身的哈希函数.必须有一列或多列包含整数值.</li>
</ul>
<p>创建分区后, 我们可以通过<code>PARTITION</code>语句查询该分区的所有内容, 如果不带<code>PARTITION</code>就会查该表的所有分区:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"># 语句里的p1指明了只使用p1<br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> example_table <span class="hljs-keyword">PARTITION</span> (p1) <br></code></pre></td></tr></table></figure>
<p>在创建分区后, 如果没有更新分区, 插入的数据找不到分区会直接报错, 我们可以直接直接增加分区:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> example_table <span class="hljs-keyword">add</span> <span class="hljs-keyword">partition</span>(<span class="hljs-keyword">partition</span> p3 <span class="hljs-keyword">VALUES</span> LESS THAN (<span class="hljs-number">2005</span>));<br></code></pre></td></tr></table></figure>
<p>除了上面查找和创建分区外, 还有其他分区的操作:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"># 拆分分区<br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> example_table reorganize <span class="hljs-keyword">partition</span> p3 <span class="hljs-keyword">into</span> (<span class="hljs-keyword">partition</span> s0 <span class="hljs-keyword">values</span> less than(<span class="hljs-number">2002</span>),  <span class="hljs-keyword">partition</span> s1 <span class="hljs-keyword">values</span> less than(<span class="hljs-number">2004</span>));<br><br># 合并分区<br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> example_table reorganize <span class="hljs-keyword">partition</span> s0, s1 <span class="hljs-keyword">into</span> (<span class="hljs-keyword">partition</span> p3 <span class="hljs-keyword">VALUES</span> LESS THAN (<span class="hljs-number">2005</span>));<br><br># 清空分区<br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> example_table <span class="hljs-keyword">truncate</span> <span class="hljs-keyword">partition</span> p3;<br><br># 删除分区<br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> example_table <span class="hljs-keyword">drop</span> <span class="hljs-keyword">partition</span> p3;<br><br># 交换分区, 比如把过时的数据迁移到备份表<br># 先创建一样的表<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `example_table_bak` (<br>    `id` <span class="hljs-type">INT</span>, <br>    `name` <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">50</span>), <br>    `create_date` <span class="hljs-type">DATE</span><br>) ENGINE<span class="hljs-operator">=</span>InnoDB <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8;<br><br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> example_table exchange <span class="hljs-keyword">PARTITION</span> p3 <span class="hljs-keyword">with</span> <span class="hljs-keyword">table</span> example_table_bak;<br></code></pre></td></tr></table></figure>

<h2 id="2-分表与分库"><a href="#2-分表与分库" class="headerlink" title="2.分表与分库"></a>2.分表与分库</h2><p>经过分区后, 我们每个查询的速度会变快了(I/O的读写速度变快了), 单位时间内的查询量可以得到提升, 但是每个表的并发查询次数是没有得到提升的, 或者单机容量已经存不下那么多数据了,  所以对于一些业务量来说, 分区是不够的, 还需要分表, 甚至是分库.分表分库带来的性能提升是巨大的, 但是带来的限制以及维护和管理工作量也是很大的, 在做分表分库之前一定要做好评估.</p>
<p>分表一般有三种:</p>
<ul>
<li>利用merge引擎来实现分表, 这个方案是最简单的, 该方案的实现会跟分区一样, 对于业务代码来说是无感的, 但是很多业务都会依赖Innodb引擎, 切引擎的成本也很大.</li>
<li>MySQL集群, MySQL集群中, 会有几台机器保存一样的数据, 通过多个机器分流查询实际上也是分表的一个思路, 但是效率上没有真正的分表快(如果是一个表的数据按照分片分布在不同的机器, 那速度就跟真正的分表速度差不多).</li>
<li>通过MySQL-Proxy或者自己在业务代码上根据一定的条件选择把数据插入到哪个表或者哪个库, 该方法是最灵活的, 但也是修改和维护成本最高的.</li>
</ul>
<p>一般情况下都是选择第三种, 而且很多团队没办法自己去实现MySQL-Proxy, 都是通过代码的业务逻辑去控制分表分库的.一般分表和分库的切分方法按照垂直切分和水平切分:</p>
<ul>
<li><p>垂直切分<br>垂直切分是按照表的功能和关系密切程度切分出来, 如用户的表可以分为用户业务数据的表和第三方应用数据的表.一般情况下,各项业务逻辑划分清晰、低耦合的就选择垂直切分.<br>垂直分表是基于数据库中的”列”进行，某个表字段较多，可以新建一张扩展表，将不经常用或字段长度较大的字段拆分出去到扩展表中.在字段很多的情况下（例如一个大表有100多个字段），通过”大表拆小表”，更便于开发与维护，也能避免跨页问题，MySQL底层是通过数据页存储的，一条记录占用空间过大会导致跨页，造成额外的性能开销.<br>垂直切分可以解决业务系统层面的耦合，业务清晰,也能对不同业务的数据进行分级管理、维护、监控、扩展等, 但是垂直切分会使部分表无法join，只能通过接口聚合方式解决，提升了开发的复杂度让分布式事务处理复杂.另外数据库以行为单位将数据加载到内存中，这样表中字段长度较短且访问频率较高，内存能加载更多的数据，命中率更高，减少了磁盘IO，从而提升了数据库性能.</p>
</li>
<li><p>水平切分<br>当一个应用难以再细粒度的垂直切分，或切分后数据量行数巨大，存在单库读写、存储性能瓶颈，这时候就需要进行水平切分了.<br>水平切分将同一个表按不同的条件分散到多个数据库或多个表中，每个表中只包含一部分数据，从而使得单个表的数据量变小. 如按照uid, 日期等字段的数据进行散列, 然后分开存放在不同的相同数据结构的表.一般情况下, 单表的数据量很大、或数据热度很高，这种情况之下就应该选择水平切分，水平切分比垂直切分要复杂一些，它将原本逻辑上属于一体的数据进行了物理分割，除了在分割时要对分割的粒度做好评估，考虑数据平均和负载平均,后期也将对项目人员及应用程序产生额外的数据管理负担。</p>
</li>
</ul>
<p>垂直切分是根据业务逻辑来进行切分的, 除了切的时候麻烦点,  维护的时候还是挺方便的, 而水平切割闹除了切割外, 还要在代码层面考虑数据增长的问题, 所以会比较复杂. 常见的水平切割规则有:</p>
<ul>
<li>根据数值范围切分, 常见的用于以日期条件来水平切割的表, 像上面分区一样, 每隔一段时间进行切分, 我们可以根据实际增长情况对代码的切分粒度进行更改, 水平拓展非常方便, 完全可控, 同时对于报表型的数据表也能达到冷热分离的效果(所以也要注意热点数据的问题, 以及容易出现跨表查询的问题).</li>
<li>根据数值哈希, 常见于以uid为条件的水平切割表, 他能有效的避免热点数据并发查找的问题, 但是在扩容的时候比较麻烦, 除非使用一致哈希算法.</li>
</ul>
<p>良好的分表分库能为性能带来极大的提升, 突破网络IO,硬件资源,连接数的瓶颈, 但也有几个弊端:</p>
<ul>
<li>事务: 在执行分库分表之后，由于数据存储到了不同的库上，数据库事务管理出现了困难。如果依赖数据库本身的分布式事务管理功能去执行事务，将付出高昂的性能代价；如果由应用程序去协助控制,实现分布式事务的两阶段提交等等, 又会造成编程方面的负担.</li>
<li>跨库跨表join: 在执行了分库分表之后，难以避免会将原本逻辑关联性很强的数据划分到不同的表、不同的库上，这时，表的关联操作将受到限制，我们无法join位于不同分库的表，也无法join分表粒度不同的表，结果原本一次查询能够完成的业务，可能需要多次查询才能完成, 或者几个表都加上一个相同的字段, 但是这个字段要更新时, 两个表都得更新。</li>
<li>额外的数据管理负担和数据运算压力: 额外的数据管理负担，最显而易见的就是数据的定位问题和数据的增删改查的重复执行问题，这些都可以通过应用程序解决，但必然引起额外的逻辑运算, 如limit分页, order by 排序的问题. 例如, 对于一个记录用户成绩的用户数据表userTable，业务要求查出成绩最好的100位，在进行分表之前，只需一个order by语句就可以搞定，但是在进行分表之后，将需要n个order by语句，分别查出每一个分表的前100名用户数据，然后再对这些数据进行合并计算，才能得出结果.</li>
</ul>
<h3 id="2-1如何水平分表"><a href="#2-1如何水平分表" class="headerlink" title="2.1如何水平分表"></a>2.1如何水平分表</h3><p>了解完分表后, 可以发现没有一个十全十美的方法来分表, 只能根据当下业务选择一个最合适的方法来分表, 而且要尽量的让表均匀的分散到多个表, 这样子系统的并发能力才能提高.</p>
<p>以订单数据的分表为例子, 目前的分表思路一般有两种, 一种是按照订单号来分表, 一种是按照用户id来分表. 不管是那种分表, 都会把值的后几位当成一个值, 然后根据现有的库的数量取模, 这样数据会根据模的结果均匀的插入几个表里面 在插入和查询订单号时, 都是通过该订单号的模结果来判断从哪个表进行操作.之所以取模而不哈希的原因是在使用取模且每次按照倍数扩容时, 只需要迁移一半的数量, 这样子扩容相对简单.比如原先只有6个表, 需要扩容时, 就变为12个表, 10原先的取模结果是4, 新的取模结果是10, 需要迁移, 而12原先的取模结果是0, 新的取模结果也还是0, 不需要迁移(可以把该实现认为的简单的一致Hash).</p>
<p>了解了如何分表以及扩容后, 回到刚开始的问题, 使用订单号分表和用户id分表的区别.正常逻辑下, 用户会通过订单号查询数据, 或者用户查询自己的订单号列表. 如果是第一种且用户id分表, 则需要查询所有的表, 如果是第二种以订单号分表的话, 也需要查询所有表了, 这样的话两种分表都有查询效率都会非常差的时候. 不过有一个简单的方法可以解决, 订单号一般是一段非常长的字符串, 我们可以把订单号切割开来, 并定义好第几位到第几位代表什么意思, 就像雪花算法一样. 由于uid是固定的, 而我们都是以后面几位进行取模存放数据, 那么订单号也可以把后面几位变为uid的后面几位, 这样就是明面上以订单号分表, 但是实际上是以用户id分表, 无论是通过订单号查询数据, 还是用户查询自己的订单列表, 都只需要查询一个数据表, 效率变高了.</p>
<p>但是, 订单号关联的用户不止是一个, 而是关联了卖家和买家(虽然卖家只有一个).如果按买家id来分表,有卖家的商品，会有n个用户购买，他所有的订单，会分散到多个库多个表中去了，卖家查询自己的所有订单，会出现跨表扫描，性能低下. 如果按卖家id分库分表, 买家会在n个店铺下单,订单就会分散在多个库、多个表中, 买家查询自己所有订单，同样要去所有的库、所有的表搜索，性能低下.所以，无论是按照买家id切分订单表，还是按照卖家id切分订单表.两边都不讨好, 又回到了上面按照订单号分表还是用户id分表的问题了. 当然, 也可以在订单号里面再划出几位数来存放卖家的uid, 但是订单号的长度是有限的, 总不能有点需求就划几位数来存数据. 这时可以拆分为卖家库和买家库, 通过数据冗余来解决, 一个订单, 除了主表外, 还有另外的关联表, 并在代码逻辑里面维护主表和关联表的数据, 当然, 关联表数量多的话也需要分表- -….</p>
<h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3.总结"></a>3.总结</h2><p>分区, 分表, 分库能提升我们系统的并发能力, 如果发现项目里的Sql没办法再优化的情况下, 那赶紧考虑分区, 分表, 分库吧. 不过除了分区外, 分表, 分库都会使架构变得复杂, 分的不好的话, 小事一堆, 所以一定要确保当前真的需要分表, 分库再操作. </p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Celery同一时刻只执行一个相同任务</title>
    <url>/2020/12/10/Celery%E5%90%8C%E4%B8%80%E6%97%B6%E5%88%BB%E5%8F%AA%E6%89%A7%E8%A1%8C%E4%B8%80%E4%B8%AA%E7%9B%B8%E5%90%8C%E4%BB%BB%E5%8A%A1/</url>
    <content><![CDATA[<h2 id="前记"><a href="#前记" class="headerlink" title="前记"></a>前记</h2><p>最近由于业务原因在接触<code>Celery</code>,<code>Celery</code>的理念挺不错的,但是只从文档很难去知道改去怎么订制<code>Celery</code>,希望我过段时间会有一篇<code>Celery</code>的源码分析文章. </p>
<p>最近在用<code>Celery</code>调用任务时,发现无法实现同一时刻,只有一个相同的任务运行,但是光看文档不知道需要怎么去处理,只能通过源码去分析运行流程,并在对应的流程加上自己的逻辑.</p>
<span id="more"></span>
<p>Ps: 我那时候的业务场景除了确保任务在同一时刻唯一,还有另外一个需求,就是同样的任务执行时,新的任务需要上个任务执行完成后才能执行.</p>
<h2 id="1-如何确保任务在同一时刻唯一"><a href="#1-如何确保任务在同一时刻唯一" class="headerlink" title="1.如何确保任务在同一时刻唯一"></a>1.如何确保任务在同一时刻唯一</h2><p>一般情况下,都是通过一个锁实现在同一时刻内只有一个任务在跑,如下伪代码:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-comment"># 一个封装良好的锁对象可以被这样使用</span><br>lock = Lock()<br><br><span class="hljs-keyword">with</span> lock <span class="hljs-keyword">as</span> l:<br>    <span class="hljs-comment"># run code</span><br>    <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure>
<p>我们只要在伪代码中执行我们的代码就可以了,如果只是一两个任务需要锁,那直接在任务里更改代码就可以了,但是如果要做到<code>Celery</code>通用,那就要设计一下.</p>
<h2 id="2-需要做什么"><a href="#2-需要做什么" class="headerlink" title="2.需要做什么"></a>2.需要做什么</h2><p>由于要做到通用,那应该做到:</p>
<ul>
<li>1.结合<code>Celery</code>的任务事件功能, 做到任务脚本对锁无感知</li>
<li>2.调用方可以通过参数来确定任务需要执行什么锁逻辑</li>
<li>3.由于<code>Celery</code>的存储结果用到了<code>Redis</code>,那可以直接使用<code>Redis</code>锁</li>
</ul>
<h3 id="2-1-结合Celery的任务事件功能-做到任务脚本对锁无感知"><a href="#2-1-结合Celery的任务事件功能-做到任务脚本对锁无感知" class="headerlink" title="2.1.结合Celery的任务事件功能, 做到任务脚本对锁无感知"></a>2.1.结合<code>Celery</code>的任务事件功能, 做到任务脚本对锁无感知</h3><p>在<code>Celery</code>中,我们可以继承他的Task对象来让每个任务拥有<code>Celery</code>的任务事件功能:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyTask</span>(<span class="hljs-params">celery.Task</span>):</span><br>    <span class="hljs-comment"># 任务失败时执行</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">on_failure</span>(<span class="hljs-params">self, exc, task_id, args, kwargs, einfo</span>):</span><br>        <span class="hljs-keyword">pass</span><br><br>    <span class="hljs-comment"># 任务成功时执行</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">on_success</span>(<span class="hljs-params">self, retval, task_id, args, kwargs</span>):</span><br>        <span class="hljs-keyword">pass</span><br><br>    <span class="hljs-comment"># 任务重试时执行</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">on_retry</span>(<span class="hljs-params">self, exc, task_id, args, kwargs, einfo</span>):</span><br>        <span class="hljs-keyword">pass</span><br><br>    <span class="hljs-comment"># 当任务执行完毕</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">def</span> <span class="hljs-title">after_return</span>(<span class="hljs-params">self, status, retval, task_id, args, kwargs, einfo</span>):</span><br>        <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure>
<p>然后在任务设置base参数,使任务应用该对象的事件.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python">celery.task(name=<span class="hljs-string">&#x27;xxx&#x27;</span>, base=<span class="hljs-string">&#x27;MyTask&#x27;</span>)<br></code></pre></td></tr></table></figure>
<p>从Task对象中我们可以看到有个<code>after_return</code>的方法,我们可以在任务结束的时候通过该方法,释放锁,但是我们缺少一个入口, <code>Celery</code>的Task入口在哪呢?</p>
<p>我们知道,<code>Celery</code>可以直接通过调用<code>Task.apply()</code>来调用任务,那任务的入口就可以从这里入手,通过查看源码发现,<code>Celery</code>在调用任务时,是通过<code>Celery.app.trece.py</code>的build_tracer方法来执行任务的,在build_tracer刚开始就有一句代码,指明调用入口</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python">fun = task <span class="hljs-keyword">if</span> task_has_custom(task, <span class="hljs-string">&#x27;__call__&#x27;</span>) <span class="hljs-keyword">else</span> task.run<br></code></pre></td></tr></table></figure>
<p>以及在下面有一句代码, 执行fun,也就是执行任务,执行完再把他标记为成功</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">try</span>:<br>    R = retval = fun(*args, **kwargs)<br>    state = SUCCESS<br><span class="hljs-keyword">except</span> Reject <span class="hljs-keyword">as</span> exc:<br>    <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure>
<p>看来<code>Celery</code>的入口就是Task的<code>__call__</code>或者<code>run</code>方法了,而且可以发现,我们可以在<code>__call__</code>中写我们的锁逻辑,只要拿到锁的才可以去调用<code>super().__call__</code>去执行任务,否则就直接return,所以我们可以把Task对象改造为:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyTask</span>(<span class="hljs-params">celery.Task</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__call__</span>(<span class="hljs-params">self, *args, **kwargs</span>):</span><br>        <span class="hljs-comment"># 伪代码</span><br>        <span class="hljs-keyword">with</span> lock <span class="hljs-keyword">as</span> l:<br>            <span class="hljs-built_in">super</span>().__call__(*args, **kwargs)<br></code></pre></td></tr></table></figure>
<h3 id="2-调用方可以通过参数来确定任务需要执行什么锁逻辑"><a href="#2-调用方可以通过参数来确定任务需要执行什么锁逻辑" class="headerlink" title="2.调用方可以通过参数来确定任务需要执行什么锁逻辑"></a>2.调用方可以通过参数来确定任务需要执行什么锁逻辑</h3><p>在通过了解<code>Celery.app.trece.py</code>的build_tracer方法可以发现,调用方的参数是通过<code>*args</code>,<code>**kwargs</code>来传给任务的,我们只要对<code>**kwargs</code>进行改造即可,如果获取到<code>celery_once_key</code>,那key为对应的值,如果获取不到则为任务名,这里之所以这样设计而不直接使用任务名是可以把key的定义规则交给调用方,调用方可能会根据不同参数来让任务类型更细化的划分.</p>
<p>需要知道的是这里需要用pop而不是用get, 因为不pop的话,对应的值就会传到任务那边了.<br>后面如果有更多的参数,也可以通过这样拓展.:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyTask</span>(<span class="hljs-params">celery.Task</span>):</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_key</span>(<span class="hljs-params">self, args, kwargs</span>) -&gt; key:</span><br>        key: Optional[<span class="hljs-built_in">str</span>] = kwargs.pop(<span class="hljs-string">&#x27;celery_once_key&#x27;</span>, <span class="hljs-literal">None</span>)<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> once_key:<br>            key = self.name + <span class="hljs-string">&#x27;:&#x27;</span>.join(args)<br>        <span class="hljs-keyword">return</span> key<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__call__</span>(<span class="hljs-params">self, *args, **kwargs</span>):</span><br>        <span class="hljs-comment"># 伪代码</span><br>        <span class="hljs-keyword">with</span> lock <span class="hljs-keyword">as</span> l:<br>            <span class="hljs-built_in">super</span>().__call__(*args, **kwargs)<br></code></pre></td></tr></table></figure>
<h3 id="2-3-使用Redis锁"><a href="#2-3-使用Redis锁" class="headerlink" title="2.3.使用Redis锁"></a>2.3.使用<code>Redis</code>锁</h3><p>由于大部分都是使用<code>Redis</code>来做<code>Celery</code>的结果存储,所以我们可以直接调用<code>Celery</code>的redis的lock对象来实现锁,并且通过参数拓展更多的功能.</p>
<p>首先先说明下<code>Redis</code>中Lock参数的意义</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python">lock(key, timeout=<span class="hljs-literal">None</span>, blocking_timeout=<span class="hljs-literal">None</span>, sleep=<span class="hljs-number">0.1</span>)<br></code></pre></td></tr></table></figure>
<ul>
<li>key就是锁的名</li>
<li>timeout为锁的过期时间,None则代表一直持有锁</li>
<li>blocking_timeout为尝试等待获取锁的时间,如果在该时间内没获取锁就报错,None为一直在等待</li>
<li>sleep为在等待获取锁的循环间隙时间</li>
</ul>
<p>接下来就开始更改下我们的<code>MyTask</code>(说明见代码注释):</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyTask</span>(<span class="hljs-params">celery.Task</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_lock</span>(<span class="hljs-params">self, args, kwargs</span>) -&gt; Lock:</span><br>        <span class="hljs-string">&quot;&quot;&quot;通过kwargs来获取redis.lock所需要的参数&quot;&quot;&quot;</span><br>        once_key: Optional[<span class="hljs-built_in">str</span>] = kwargs.pop(<span class="hljs-string">&#x27;celery_once_key&#x27;</span>, <span class="hljs-literal">None</span>)<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> once_key:<br>            once_key = self.name + <span class="hljs-string">&#x27;:&#x27;</span>.join(args)<br>        timeout: <span class="hljs-built_in">int</span> = kwargs.pop(<span class="hljs-string">&#x27;celery_once_timeout&#x27;</span>, <span class="hljs-literal">None</span>)<br>        blocking_timeout: <span class="hljs-built_in">int</span> = kwargs.pop(<span class="hljs-string">&#x27;celery_once_blocking_timeout&#x27;</span>, <span class="hljs-literal">None</span>)<br>        sleep: <span class="hljs-built_in">float</span> = kwargs.pop(<span class="hljs-string">&#x27;celery_once_sleep&#x27;</span>, <span class="hljs-number">0.1</span>)<br>        redis: Redis = self.backend.client<br>        <span class="hljs-keyword">return</span> redis.lock(once_key, timeout=timeout, blocking_timeout=blocking_timeout, sleep=sleep)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__call__</span>(<span class="hljs-params">self, *args, **kwargs</span>):</span><br>        lock = self.get_lock(args, kwargs)<br>        <span class="hljs-comment"># 根据build_tracer逻辑,这里如果执行超时,会抛错并执行Task的失败event</span><br>        <span class="hljs-keyword">with</span> lock <span class="hljs-keyword">as</span> _lock:<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>().__call__(*args, **kwargs)<br></code></pre></td></tr></table></figure>
<p>这样就完成啦, 不过,如果设置timeout=None, blocking_timeout=None时,收到另外一个相同的任务后会一直卡在执行中,直到上一个任务完成后,他才会继续执行,这样有点不符合我们的逻辑.收到的另外一个任务应该是要被放弃掉,好像在我们上面看的build_tracer代码中,他有会Reject的异常进行处理,如果是Reject异常,那任务会直接完成,且不会把结果记录下来.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">try</span>:<br>    R = retval = fun(*args, **kwargs)<br>    state = SUCCESS<br><span class="hljs-keyword">except</span> Reject <span class="hljs-keyword">as</span> exc:<br>    <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure>
<p>所以经过最后的修改,完整的代码就像下面这样啦 </p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyTask</span>(<span class="hljs-params">Task</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_lock</span>(<span class="hljs-params">self, args, kwargs</span>) -&gt; Lock:</span><br>        once_key: Optional[<span class="hljs-built_in">str</span>] = kwargs.pop(<span class="hljs-string">&#x27;celery_once_key&#x27;</span>, <span class="hljs-literal">None</span>)<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> once_key:<br>            once_key = self.name + <span class="hljs-string">&#x27;:&#x27;</span>.join(args)<br>        timeout: <span class="hljs-built_in">int</span> = kwargs.pop(<span class="hljs-string">&#x27;celery_once_timeout&#x27;</span>, <span class="hljs-literal">None</span>)<br>        blocking_timeout: <span class="hljs-built_in">int</span> = kwargs.pop(<span class="hljs-string">&#x27;celery_once_blocking_timeout&#x27;</span>, <span class="hljs-literal">None</span>)<br>        sleep: <span class="hljs-built_in">float</span> = kwargs.pop(<span class="hljs-string">&#x27;celery_once_sleep&#x27;</span>, <span class="hljs-number">0.1</span>)<br>        redis: Redis = self.backend.client<br>        <span class="hljs-keyword">return</span> redis.lock(once_key, timeout=timeout, blocking_timeout=blocking_timeout, sleep=sleep)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__call__</span>(<span class="hljs-params">self, *args, **kwargs</span>):</span><br>        lock = self.get_lock(args, kwargs)<br>        enable_wait: <span class="hljs-built_in">bool</span> = kwargs.pop(<span class="hljs-string">&#x27;celery_once_enable_wait&#x27;</span>, <span class="hljs-literal">False</span>)<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> enable_wait <span class="hljs-keyword">and</span> lock.locker():<br>            <span class="hljs-comment"># 如果任务不需要等待且获取不到锁,则需要被标记为Reject并放弃执行</span><br>            logger.info(<br>                <span class="hljs-string">f&#x27;lock:<span class="hljs-subst">&#123;lock.name&#125;</span> not release and not eanble retry, task ignore, args <span class="hljs-subst">&#123;args&#125;</span>, kwargs <span class="hljs-subst">&#123;kwargs&#125;</span>&#x27;</span><br>            )<br>            <span class="hljs-keyword">raise</span> Reject<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">with</span> lock <span class="hljs-keyword">as</span> _lock:<br>                <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>().__call__(*args, **kwargs)<br></code></pre></td></tr></table></figure>
<h2 id="3-附录"><a href="#3-附录" class="headerlink" title="3.附录"></a>3.附录</h2><h3 id="3-1完整代码"><a href="#3-1完整代码" class="headerlink" title="3.1完整代码:"></a>3.1完整代码:</h3><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> Optional<br><br><span class="hljs-keyword">import</span> Celery<br><span class="hljs-keyword">from</span> celery <span class="hljs-keyword">import</span> Task<br><span class="hljs-keyword">from</span> celery.exceptions <span class="hljs-keyword">import</span> Reject<br><span class="hljs-keyword">from</span> celery.utils.log <span class="hljs-keyword">import</span> get_task_logger<br><span class="hljs-keyword">from</span> redis.client <span class="hljs-keyword">import</span> Redis<br><span class="hljs-keyword">from</span> redis.lock <span class="hljs-keyword">import</span> Lock<br><br>logger = get_task_logger(__name__)<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OnceTask</span>(<span class="hljs-params">Task</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    OnceTask需要在调用任务时从kwargs传入如下参数(非必选)</span><br><span class="hljs-string">    celery_once_key: 锁的key,为空时以task_name + args为key</span><br><span class="hljs-string">    celery_once_timeout: 锁的持有时间,默认为None, 也就是等到任务主动调用release之前,锁一直存在</span><br><span class="hljs-string">    celery_once_enable_retry: 如果检查到锁存在, 是否需要尝试获取锁</span><br><span class="hljs-string">    celery_once_blocking_timeout: 尝试获取锁的时间, 默认为None, 也就是一直在尝试</span><br><span class="hljs-string">    celery_once_sleep: 每次尝试获取锁的睡眠时间, 默认为0.1, 也就是锁的隔多久尝试一次</span><br><span class="hljs-string">    timeout=None, sleep=0.1, blocking_timeout=None,</span><br><span class="hljs-string"></span><br><span class="hljs-string">    举例子:</span><br><span class="hljs-string">        如果要确保只能只有一个任务运行,其他任务运行会被忽略则:</span><br><span class="hljs-string">         celery_once_timeout: None, celery_once_enable_retry: False</span><br><span class="hljs-string">        如果要确保一个任务运行时,其他任务排队,并在上一个任务运行完再运行则:</span><br><span class="hljs-string">        celery_once_timeout: None, celery_once_enable_retry: True</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_lock</span>(<span class="hljs-params">self, args, kwargs</span>) -&gt; Lock:</span><br>        once_key: Optional[<span class="hljs-built_in">str</span>] = kwargs.pop(<span class="hljs-string">&#x27;celery_once_key&#x27;</span>, <span class="hljs-literal">None</span>)<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> once_key:<br>            once_key = self.name + <span class="hljs-string">&#x27;:&#x27;</span>.join(args)<br>        timeout: <span class="hljs-built_in">int</span> = kwargs.pop(<span class="hljs-string">&#x27;celery_once_timeout&#x27;</span>, <span class="hljs-literal">None</span>)<br>        blocking_timeout: <span class="hljs-built_in">int</span> = kwargs.pop(<span class="hljs-string">&#x27;celery_once_blocking_timeout&#x27;</span>, <span class="hljs-literal">None</span>)<br>        sleep: <span class="hljs-built_in">float</span> = kwargs.pop(<span class="hljs-string">&#x27;celery_once_sleep&#x27;</span>, <span class="hljs-number">0.1</span>)<br>        redis: Redis = self.backend.client<br>        <span class="hljs-keyword">return</span> redis.lock(once_key, timeout=timeout, blocking_timeout=blocking_timeout, sleep=sleep)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__call__</span>(<span class="hljs-params">self, *args, **kwargs</span>):</span><br>        lock = self.get_lock(args, kwargs)<br>        enable_wait: <span class="hljs-built_in">bool</span> = kwargs.pop(<span class="hljs-string">&#x27;celery_once_enable_wait&#x27;</span>, <span class="hljs-literal">False</span>)<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> enable_wait <span class="hljs-keyword">and</span> lock.locker():<br>            <span class="hljs-comment"># 如果任务不需要等待且获取不到锁,则需要被标记为Reject并放弃执行</span><br>            logger.info(<br>                <span class="hljs-string">f&#x27;lock:<span class="hljs-subst">&#123;self.lock.name&#125;</span> not release and not eanble retry, task ignore, args <span class="hljs-subst">&#123;args&#125;</span>, kwargs <span class="hljs-subst">&#123;kwargs&#125;</span>&#x27;</span><br>            )<br>            <span class="hljs-keyword">raise</span> Reject<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">with</span> lock <span class="hljs-keyword">as</span> _lock:<br>                <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>().__call__(*args, **kwargs)<br>             <br>             <br>app: <span class="hljs-string">&#x27;Celery&#x27;</span> = Celery()<br><br><span class="hljs-meta">@celery.task(<span class="hljs-params">name=<span class="hljs-string">&quot;tasks1&quot;</span>, base=OnceTask</span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test</span>(<span class="hljs-params">*args, **kwargs</span>):</span><br>    time.sleep(<span class="hljs-number">60</span>)<br>   <br>test.apply()<br>test.apply() <span class="hljs-comment"># 这个任务会被Reject</span><br>test.apply(kwargs=&#123;<span class="hljs-string">&#x27;celery_once_enable_retry&#x27;</span>: <span class="hljs-literal">True</span>, <span class="hljs-string">&#x27;celery_once_sleep&#x27;</span>: <span class="hljs-number">1</span>&#125;) <span class="hljs-comment"># 这个任务会等第一个任务执行完了再执行</span><br></code></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Celery</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Redis</tag>
        <tag>Celery</tag>
      </tags>
  </entry>
  <entry>
    <title>Celery调用不同项目的任务</title>
    <url>/2020/12/10/Celery%E8%B0%83%E7%94%A8%E4%B8%8D%E5%90%8C%E9%A1%B9%E7%9B%AE%E7%9A%84%E4%BB%BB%E5%8A%A1/</url>
    <content><![CDATA[<h2 id="前记"><a href="#前记" class="headerlink" title="前记"></a>前记</h2><p>PS: 水文笔记…</p>
<p><code>Celery</code>的示例或者常用使用方式中, <code>Celery</code>的Woker以及任务调用经常都是在同一个项目里面.<br>但是随着项目的拓展,很多时候<code>Celery</code>任务调用端与Woker的代码并不是在同一个项目里(但是共享同一个Mq, Redis等配置和中间件),而且<code>Celery</code>是基于<code>RabbitMQ</code>进行任务信息传输的,非常适合不同的项目调用解耦.<br>而<code>Celery</code>有一个非常好的概念–Signature,我们只要在远程端封装一个伪任务的Signature,就可以通过调用该Signature去让另一个项目的Celery执行对应的任务.</p>
<span id="more"></span>

<h2 id="1-send-task"><a href="#1-send-task" class="headerlink" title="1.send_task"></a>1.send_task</h2><p>在<code>Celery</code>的文档中,有提到如果是调用不同项目的Woker可以使用send_task方法,先看看Woker端的代码:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">from</span> celery <span class="hljs-keyword">import</span> Celery<br><br>celery: Celery = Celery()    <span class="hljs-comment"># 省略配置</span><br><br><span class="hljs-comment"># 一个模拟任务,会跑60秒</span><br><span class="hljs-meta">@celery.task(<span class="hljs-params">name=<span class="hljs-string">&quot;test.block&quot;</span></span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test</span>(<span class="hljs-params">sleep_seconds=<span class="hljs-number">60</span></span>):</span><br>    time.sleep(sleep_seconds)<br></code></pre></td></tr></table></figure>

<p>作为调用端,如果需要调用的话需要如下代码去调用:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">from</span> celery <span class="hljs-keyword">import</span> Celery<br><br>celery: Celery = Celery()    <span class="hljs-comment"># 省略配置</span><br>celery.send_task(<span class="hljs-string">&quot;test.block&quot;</span>)<br></code></pre></td></tr></table></figure>

<p>可以发现只要通过send_task传送对应的任务名即可,事实上<code>Celery</code>最底层的远程调用逻辑也是通过send_task.不过如果要通过send_task远程调用并使用<code>Celery</code>的其他特性却比较困难,要自己去了解源码,并经过一定的封装,好再<code>Celery</code>中有一个叫签名–Signature的概念.</p>
<h2 id="2-Signature"><a href="#2-Signature" class="headerlink" title="2.Signature"></a>2.Signature</h2><p>Signature非常好用,通过他我们可以很容易的使用<code>Celery</code>的高级方法,而且在不同项目中,我们的调用方法也是跟相同项目的调用方法是一致的.先看看通过Signature改进后的调用端代码:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">from</span> celery <span class="hljs-keyword">import</span> Celery, signature<br><br>celery: Celery = Celery()    <span class="hljs-comment"># 省略配置</span><br>block_signature = signature(<br>    <span class="hljs-string">&#x27;test.block&#x27;</span>,      <span class="hljs-comment"># 任务名</span><br>    immutable=<span class="hljs-literal">True</span>,    <span class="hljs-comment"># chain时变量不可变</span><br>    app=celery<br>)<br>block_signature.delay()<br></code></pre></td></tr></table></figure>
<p>看起来参数比较多一点,但是可以看到我们可以像平常同个项目下调用task一样使用delay()方法.可以看做上面的block_signature等于woker项目的test().si,所以Signature也支持其他高级调用,如Chain:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">from</span> celery <span class="hljs-keyword">import</span> Celery, chain, signature<br><br>celery: Celery = Celery()    <span class="hljs-comment"># 省略配置</span><br>block_signature_1 = signature(<br>    <span class="hljs-comment"># 任务名</span><br>    <span class="hljs-string">&#x27;test.block&#x27;</span>,<br>    <span class="hljs-comment"># chain时变量不可变</span><br>    immutable=<span class="hljs-literal">True</span>,<br>    kwargs=&#123;<span class="hljs-string">&#x27;sleep_seconds&#x27;</span>: <span class="hljs-number">10</span>&#125;<br>    app=celery<br>)<br>block_signature_2 = signature(<br>    <span class="hljs-comment"># 任务名</span><br>    <span class="hljs-string">&#x27;test.block&#x27;</span>,<br>    <span class="hljs-comment"># chain时变量不可变</span><br>    immutable=<span class="hljs-literal">True</span>,<br>    kwargs=&#123;<span class="hljs-string">&#x27;sleep_seconds&#x27;</span>: <span class="hljs-number">20</span>&#125;<br>    app=celery<br>)<br>chain(block_signature_1, block_signature_2).delay()<br></code></pre></td></tr></table></figure>

<h2 id="3-附录"><a href="#3-附录" class="headerlink" title="3.附录"></a>3.附录</h2><h3 id="3-1检查任务是否运行结束"><a href="#3-1检查任务是否运行结束" class="headerlink" title="3.1检查任务是否运行结束"></a>3.1检查任务是否运行结束</h3><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">from</span> celery <span class="hljs-keyword">import</span> Celery, chain, signature<br><br>celery: Celery = Celery()    <span class="hljs-comment"># 省略配置</span><br><span class="hljs-comment"># 其他任务类型,如group的task前缀并不是celery-task-meta-,需要查询文档</span><br>task_key_prefix: <span class="hljs-built_in">str</span> = <span class="hljs-string">&#x27;celery-task-meta-&#x27;</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">celery_task_id_is_run</span>(<span class="hljs-params">task_id: <span class="hljs-built_in">str</span></span>) -&gt; bool:</span><br>    redis: Redis = celery.backend.client<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> task_id.startswith(task_key_prefix):<br>        task_id += task_id<br>    <span class="hljs-keyword">return</span> redis.exists(task_id)<br><br>task_id: <span class="hljs-built_in">str</span> = celery.send_task(<span class="hljs-string">&quot;test.block&quot;</span>).task_id<br>celery_task_id_is_run(task_id)<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Celery</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Celery</tag>
      </tags>
  </entry>
  <entry>
    <title>基于Python探针完成调用库的数据提取</title>
    <url>/2020/11/18/%E5%9F%BA%E4%BA%8EPython%E6%8E%A2%E9%92%88%E5%AE%8C%E6%88%90%E8%B0%83%E7%94%A8%E5%BA%93%E7%9A%84%E6%95%B0%E6%8D%AE%E6%8F%90%E5%8F%96/</url>
    <content><![CDATA[<h2 id="前记"><a href="#前记" class="headerlink" title="前记"></a>前记</h2><p>最近在完善公司的监控系统, 发现在项目运行时经常会出现一些运行时的问题， 这些问题往往不是一个子服务引发的问题， 而可能是某个环节出现了问题， 这时候就需要引入APM系统。在收集APM数据时发现在<code>Python</code>生态中针对web框架都有完善的APM中间件用于接口统计与监控, 但是第三方调用库相关的APM实现都比较少(几乎没有)， 同时这些库大多数也都没提供一些钩子实现。这就需要自己去封装一些库， 为这些库实现一套调用过程的数据提供逻辑。</p>
<p>本文是以<code>Python</code>的<code>aiomysql</code>库为例，阐述如何基于<code>Python</code>的探针完成调用库的调用过程统计与监控的封装。 </p>
<span id="more"></span>

<blockquote>
<p>注: 监控的形式的agent有很多种，如<code>Prometheus</code>，<code>Zabbix</code>, <code>Graphite</code>和<code>Opentracing</code>他们的数据源有很大的不同，但是他们都是基于元数据封装成自己的源数据，然后发送到对应的服务，所以本文只介绍如何提取元数据，剩下的如何发送需要自己按照特定的监控系统去实现。</p>
</blockquote>
<blockquote>
<p>注：这里以aiomysql库来做示例，提取数据的方法应该用统一的dbapi2， 本文只阐述如何简单的实现。</p>
</blockquote>
<h2 id="1-简单粗暴的方法–对mysql库进行封装"><a href="#1-简单粗暴的方法–对mysql库进行封装" class="headerlink" title="1.简单粗暴的方法–对mysql库进行封装"></a>1.简单粗暴的方法–对mysql库进行封装</h2><p>要统计一个执行过程， 有一个必要的条件就是需要知道这个执行过程的开始位置和结束位置， 所以最简单粗暴的方法就是要基于调用的方法进行封装，在框架调用<code>MySQL</code>库和<code>MySQL</code>库中间实现一个中间层, 并基于中间层完成耗时统计,如:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-comment"># 伪代码</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">my_execute</span>(<span class="hljs-params">conn, sql, param</span>):</span><br>    <span class="hljs-comment"># 针对MySql库的统计封装组件</span><br>    <span class="hljs-keyword">with</span> MyTracer(conn, sql, param):<br>        <span class="hljs-comment"># 以下为正常使用MySql库的代码</span><br>        <span class="hljs-keyword">with</span> conn.cursor <span class="hljs-keyword">as</span> cursor:<br>            cursor.execute(sql, param)<br>            ...<br></code></pre></td></tr></table></figure>
<p>这样的实现看起来非常不错, 而且更改非常方便, 但由于是在最顶层的API上进行修改, 其实是非常不灵活的, 同时<code>cursor.execute</code>里面会执行一些预操作, 如把sql和param进行拼接, 以及调用<code>nextset</code>清除当前游标的数据等等。 所以最后拿到的数据如时间耗时也是不准确的, 同时也没办法得到一些详细的元数据， 如错误码等等.</p>
<p>如果要拿到最直接有用的数据，就只能去改源代码, 然后再调用了, 但是如果每个库都需要改源代码才能统计, 那也太麻烦了, 好在<code>Python</code>也提供了一些类似探针的接口, 可以通过探针把库的源码进行替换完成我们的代码.</p>
<h2 id="2-Python的探针"><a href="#2-Python的探针" class="headerlink" title="2.Python的探针"></a>2.Python的探针</h2><p>在<code>Python</code>中可以通过<code>sys.meta_path</code>来实现<code>import hook</code>的功能, 当执行 import 相关操作时, 会根据<code>sys.meta_path</code>定义的对象对import相关库进行更改.<br><code>sys.meta_path</code>中的对象需要实现一个<code>find_module</code>方法， 这个<code>find_module</code>方法返回<code>None</code>或一个实现了<code>load_module</code>方法的对象, 我们可以通过这个对象, 针对一些库在import时, 把相关的方法进行替换, 简单用法如下,通过hook<code>time.sleep</code>让他在sleep的时候能打印消耗的时间.<br><a href="https://github.com/so1n/example/blob/master/example_python/example_python/python_hook/hook_demo">github源码存储</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> importlib<br><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> wraps<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">func_wrapper</span>(<span class="hljs-params">func</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;这里通过一个装饰器来达到狸猫换太子和获取数据的效果&quot;&quot;&quot;</span><br><span class="hljs-meta">    @wraps(<span class="hljs-params">func</span>)</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">wrapper</span>(<span class="hljs-params">*args, **kwargs</span>):</span><br>        <span class="hljs-comment"># 记录开始时间</span><br>        start = time.time()<br>        result = func(*args, **kwargs)<br>        <span class="hljs-comment"># 统计消耗时间</span><br>        end = time.time()<br>        print(<span class="hljs-string">f&quot;speed time:<span class="hljs-subst">&#123;end - start&#125;</span>&quot;</span>)<br>        <span class="hljs-keyword">return</span> result<br>    <span class="hljs-keyword">return</span> wrapper<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MetaPathFinder</span>:</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">find_module</span>(<span class="hljs-params">self, fullname, path=<span class="hljs-literal">None</span></span>):</span><br>        <span class="hljs-comment"># 执行时可以看出来在import哪些模块</span><br>        print(<span class="hljs-string">f&#x27;find module:<span class="hljs-subst">&#123;path&#125;</span>:<span class="hljs-subst">&#123;fullname&#125;</span>&#x27;</span>)<br>        <span class="hljs-keyword">return</span> MetaPathLoader()<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MetaPathLoader</span>:</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">load_module</span>(<span class="hljs-params">self, fullname</span>):</span><br>        <span class="hljs-comment"># import的模块都会存放在sys.modules里面， 通过判断可以减少重复import</span><br>        <span class="hljs-keyword">if</span> fullname <span class="hljs-keyword">in</span> sys.modules:<br>            <span class="hljs-keyword">return</span> sys.modules[fullname]<br>        <span class="hljs-comment"># 防止递归调用</span><br>        finder = sys.meta_path.pop(<span class="hljs-number">0</span>)<br>        <span class="hljs-comment"># 导入 module</span><br>        module = importlib.import_module(fullname)<br>        <span class="hljs-keyword">if</span> fullname == <span class="hljs-string">&#x27;time&#x27;</span>:<br>            <span class="hljs-comment"># 替换函数</span><br>            module.sleep = func_wrapper(module.sleep)<br>        sys.meta_path.insert(<span class="hljs-number">0</span>, finder)<br>        <span class="hljs-keyword">return</span> module<br><br><br>sys.meta_path.insert(<span class="hljs-number">0</span>, MetaPathFinder())<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-keyword">import</span> time<br>    time.sleep(<span class="hljs-number">1</span>)<br><br><br><span class="hljs-comment"># 输出示例:</span><br><span class="hljs-comment"># find module:datetime</span><br><span class="hljs-comment"># find module:time</span><br><span class="hljs-comment"># load module:time</span><br><span class="hljs-comment"># find module:math</span><br><span class="hljs-comment"># find module:_datetime</span><br><span class="hljs-comment"># speed time:1.00073385238647468</span><br></code></pre></td></tr></table></figure>
<h2 id="3-制作探针模块"><a href="#3-制作探针模块" class="headerlink" title="3.制作探针模块"></a>3.制作探针模块</h2><p>了解完了主要流程后， 可以开始制作自己的探针模块了, 由于示例只涉及到aiomysql模块, 那么在<code>MetaPathFinder.find_module</code>中需要只对aiomysql模块进行处理, 其他的先忽略.<br>然后我们需要确定要把aiomysql的哪个功能给替换, 从业务上来说, 一般情况下我们只要<code>cursor.execute</code>, <code>cursor.fetchone</code>, <code>cursor.fetchall</code>, <code>cursor.executemany</code>这几个主要的操作,所以需要深入<a href="https://github.com/aio-libs/aiomysql/blob/master/aiomysql/cursors.py">cursor的源码</a>, 看看如何去更改代码, 后者重载哪个函数.</p>
<p>先从<code>cursor.execute</code>的源码(<code>cursor.executemanay</code>也类似)入手, 发现会先调用<code>self.nextset</code>的方法, 把上个请求的数据先拿完, 再合并sql语句, 最后通过<code>self._query</code>进行查询:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">execute</span>(<span class="hljs-params">self, query, args=<span class="hljs-literal">None</span></span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;Executes the given operation</span><br><span class="hljs-string">    Executes the given operation substituting any markers with</span><br><span class="hljs-string">    the given parameters.</span><br><span class="hljs-string">    For example, getting all rows where id is 5:</span><br><span class="hljs-string">        cursor.execute(&quot;SELECT * FROM t1 WHERE id = %s&quot;, (5,))</span><br><span class="hljs-string">    :param query: ``str`` sql statement</span><br><span class="hljs-string">    :param args: ``tuple`` or ``list`` of arguments for sql query</span><br><span class="hljs-string">    :returns: ``int``, number of rows that has been produced of affected</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    conn = self._get_db()<br><br>    <span class="hljs-keyword">while</span> (<span class="hljs-keyword">await</span> self.nextset()):<br>        <span class="hljs-keyword">pass</span><br><br>    <span class="hljs-keyword">if</span> args <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>        query = query % self._escape_args(args, conn)<br><br>    <span class="hljs-keyword">await</span> self._query(query)<br>    self._executed = query<br>    <span class="hljs-keyword">if</span> self._echo:<br>        logger.info(query)<br>        logger.info(<span class="hljs-string">&quot;%r&quot;</span>, args)<br>    <span class="hljs-keyword">return</span> self._rowcount<br></code></pre></td></tr></table></figure>
<p>再看<code>cursor.fetchone</code>的源码(<code>cursor.fetchall</code>也类似), 发现其实是从缓存中获取数据, 这些数据在执行<code>cursor.execute</code>中就已经获取了:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fetchone</span>(<span class="hljs-params">self</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;Fetch the next row &quot;&quot;&quot;</span><br>    self._check_executed()<br>    fut = self._loop.create_future()<br><br>    <span class="hljs-keyword">if</span> self._rows <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">or</span> self._rownumber &gt;= <span class="hljs-built_in">len</span>(self._rows):<br>        fut.set_result(<span class="hljs-literal">None</span>)<br>        <span class="hljs-keyword">return</span> fut<br>    result = self._rows[self._rownumber]<br>    self._rownumber += <span class="hljs-number">1</span><br><br>    fut = self._loop.create_future()<br>    fut.set_result(result)<br>    <span class="hljs-keyword">return</span> fut<br></code></pre></td></tr></table></figure>
<p>综合上面的分析, 可以发现只要对核心的方法<code>self._query</code>进行重载即可拿到我们想要的数据, 从源码中我们可以知道, 我们能获取到传入<code>self._query</code>的<code>self</code>和<code>sql</code>参数, 根据<code>self</code>又能获取到查询的结果, 同时我们通过装饰器能获取到运行的时间, 要的数据基本都到齐了, 按照思路修改后的代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> importlib<br><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> wraps<br><br><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> cast, Any, Callable, Optional, Tuple, TYPE_CHECKING<br><span class="hljs-keyword">from</span> types <span class="hljs-keyword">import</span> ModuleType<br><span class="hljs-keyword">if</span> TYPE_CHECKING:<br>    <span class="hljs-keyword">import</span> aiomysql<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">func_wrapper</span>(<span class="hljs-params">func: Callable</span>):</span><br><span class="hljs-meta">    @wraps(<span class="hljs-params">func</span>)</span><br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">wrapper</span>(<span class="hljs-params">*args, **kwargs</span>) -&gt; Any:</span><br>        start: <span class="hljs-built_in">float</span> = time.time()<br>        func_result: Any = <span class="hljs-keyword">await</span> func(*args, **kwargs)<br>        end: <span class="hljs-built_in">float</span> = time.time()<br><br>        <span class="hljs-comment"># 根据_query可以知道, 第一个参数是self, 第二个参数是sql</span><br>        self: aiomysql.Cursor = args[<span class="hljs-number">0</span>]<br>        sql: <span class="hljs-built_in">str</span> = args[<span class="hljs-number">1</span>]<br>        <span class="hljs-comment"># 通过self,我们可以拿到其他的数据</span><br>        db: <span class="hljs-built_in">str</span> = self._connection.db<br>        user: <span class="hljs-built_in">str</span> = self._connection.user<br>        host: <span class="hljs-built_in">str</span> = self._connection.host<br>        port: <span class="hljs-built_in">str</span> = self._connection.port<br>        execute_result: Tuple[Tuple] = self._rows<br>        <span class="hljs-comment"># 可以根据自己定义的agent把数据发送到指定的平台, 然后我们就可以在平台上看到对应的数据或进行监控了, </span><br>        <span class="hljs-comment"># 这里只是打印一部分数据出来</span><br>        print(&#123;<br>            <span class="hljs-string">&quot;sql&quot;</span>: sql,<br>            <span class="hljs-string">&quot;db&quot;</span>: db,<br>            <span class="hljs-string">&quot;user&quot;</span>: user,<br>            <span class="hljs-string">&quot;host&quot;</span>: host,<br>            <span class="hljs-string">&quot;port&quot;</span>: port,<br>            <span class="hljs-string">&quot;result&quot;</span>: execute_result,<br>            <span class="hljs-string">&quot;speed time&quot;</span>: end - start<br>        &#125;)<br>        <span class="hljs-keyword">return</span> func_result<br>    <span class="hljs-keyword">return</span> cast(Callable, wrapper)<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MetaPathFinder</span>:</span><br><br><span class="hljs-meta">    @staticmethod</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">find_module</span>(<span class="hljs-params">fullname: <span class="hljs-built_in">str</span>, path: Optional[<span class="hljs-built_in">str</span>] = <span class="hljs-literal">None</span></span>) -&gt; Optional[&quot;MetaPathLoader&quot;]:</span><br>        <span class="hljs-keyword">if</span> fullname == <span class="hljs-string">&#x27;aiomysql&#x27;</span>:<br>            <span class="hljs-comment"># 只有aiomysql才进行hook</span><br>            <span class="hljs-keyword">return</span> MetaPathLoader()<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MetaPathLoader</span>:</span><br><br><span class="hljs-meta">    @staticmethod</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">load_module</span>(<span class="hljs-params">fullname: <span class="hljs-built_in">str</span></span>):</span><br>        <span class="hljs-keyword">if</span> fullname <span class="hljs-keyword">in</span> sys.modules:<br>            <span class="hljs-keyword">return</span> sys.modules[fullname]<br>        <span class="hljs-comment"># 防止递归调用</span><br>        finder: <span class="hljs-string">&quot;MetaPathFinder&quot;</span> = sys.meta_path.pop(<span class="hljs-number">0</span>)<br>        <span class="hljs-comment"># 导入 module</span><br>        module: ModuleType = importlib.import_module(fullname)<br>        <span class="hljs-comment"># 针对_query进行hook</span><br>        module.Cursor._query = func_wrapper(module.Cursor._query)<br>        sys.meta_path.insert(<span class="hljs-number">0</span>, finder)<br>        <span class="hljs-keyword">return</span> module<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_mysql</span>() -&gt; <span class="hljs-keyword">None</span>:</span><br>    <span class="hljs-keyword">import</span> aiomysql<br>    pool: aiomysql.Pool = <span class="hljs-keyword">await</span> aiomysql.create_pool(<br>        host=<span class="hljs-string">&#x27;127.0.0.1&#x27;</span>, port=<span class="hljs-number">3306</span>, user=<span class="hljs-string">&#x27;root&#x27;</span>, password=<span class="hljs-string">&#x27;123123&#x27;</span>, db=<span class="hljs-string">&#x27;mysql&#x27;</span><br>    )<br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> pool.acquire() <span class="hljs-keyword">as</span> conn:<br>        <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> conn.cursor() <span class="hljs-keyword">as</span> cur:<br>            <span class="hljs-keyword">await</span> cur.execute(<span class="hljs-string">&quot;SELECT 42;&quot;</span>)<br>            (r,) = <span class="hljs-keyword">await</span> cur.fetchone()<br>            <span class="hljs-keyword">assert</span> r == <span class="hljs-number">42</span><br>    pool.close()<br>    <span class="hljs-keyword">await</span> pool.wait_closed()<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    sys.meta_path.insert(<span class="hljs-number">0</span>, MetaPathFinder())<br>    <span class="hljs-keyword">import</span> asyncio<br><br>    asyncio.run(test_mysql())<br><br><span class="hljs-comment"># 输出示例:</span><br><span class="hljs-comment"># 可以看出sql语句与我们输入的一样, db, user, host, port等参数也是, 还能知道执行的结果和运行时间</span><br><span class="hljs-comment"># &#123;&#x27;sql&#x27;: &#x27;SELECT 42;&#x27;, &#x27;db&#x27;: &#x27;mysql&#x27;, &#x27;user&#x27;: &#x27;root&#x27;, &#x27;host&#x27;: &#x27;127.0.0.1&#x27;, &#x27;port&#x27;: 3306, &#x27;result&#x27;: ((42,),), &#x27;speed time&#x27;: 0.00045609474182128906&#125;</span><br></code></pre></td></tr></table></figure>

<p>这个例子看来很不错, 但是需要在调用的入口处显式调用该逻辑, 通常一个项目可能有几个入口, 每个入口都显示调用该逻辑会非常麻烦， 而且必须先调用我们的hook逻辑后才能import， 这样就得订好引入规范， 不然就可能出现部分地方hook不成功, 如果能把引入hook这个逻辑安排在解析器启动后马上执行， 就可以完美地解决这个问题了.<br>查阅了一翻资料后发现,<code>python</code>解释器初始化的时候会自动<code>import PYTHONPATH</code>下存在的<code>sitecustomize</code>和<code>usercustomize</code>模块, 我们只需要创建该模块, 并在模块里面写入我们的<br>替换函数即可。</p>
<p>具体结构如下，也可以参考<a href="https://github.com/so1n/example/blob/master/example_python/example_python/python_hook/hook_by_sys/">github存储</a></p>
<figure class="highlight vim"><table><tr><td class="code"><pre><code class="hljs vim">.<br>├── __init__.<span class="hljs-keyword">py</span><br>├── hook_aiomysql.<span class="hljs-keyword">py</span><br>├── sitecustomize.<span class="hljs-keyword">py</span><br>└── test_auto_hook.<span class="hljs-keyword">py</span><br></code></pre></td></tr></table></figure>
<p><code>hook_aiomysql.py</code>是我们制作探针的代码为例子， 而<code>sitecustomize.py</code>存放的代码如下, 非常简单， 就是引入我们的探针代码, 并插入到<code>sys.meta_path</code>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">from</span> hook_aiomysql <span class="hljs-keyword">import</span> MetaPathFinder<br><br>sys.meta_path.insert(<span class="hljs-number">0</span>, MetaPathFinder())<br></code></pre></td></tr></table></figure>
<p><code>test_auto_hook.py</code>则是测试代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> asyncio<br><span class="hljs-keyword">from</span> hook_aiomysql <span class="hljs-keyword">import</span> test_mysql<br><br><br>asyncio.run(test_mysql())<br></code></pre></td></tr></table></figure>
<p>接下来只要设置<code>PYTHONPATH</code>并运行我们的代码即可（如果是项目的话一般交由superisor启动，则可以在配置文件中设置好<code>PYTHONPATH</code>）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">(.venv) ➜  python_hook git:(master) ✗ <span class="hljs-built_in">export</span> PYTHONPATH=.      <br>(.venv) ➜  python_hook git:(master) ✗ python test_auto_hook.py <br>&#123;<span class="hljs-string">&#x27;sql&#x27;</span>: <span class="hljs-string">&#x27;SELECT 42;&#x27;</span>, <span class="hljs-string">&#x27;db&#x27;</span>: <span class="hljs-string">&#x27;mysql&#x27;</span>, <span class="hljs-string">&#x27;user&#x27;</span>: <span class="hljs-string">&#x27;root&#x27;</span>, <span class="hljs-string">&#x27;host&#x27;</span>: <span class="hljs-string">&#x27;127.0.0.1&#x27;</span>, <span class="hljs-string">&#x27;port&#x27;</span>: 3306, <span class="hljs-string">&#x27;result&#x27;</span>: ((42,),), <span class="hljs-string">&#x27;speed time&#x27;</span>: 0.000213623046875&#125;<br></code></pre></td></tr></table></figure>

<h2 id="4-直接替换方法"><a href="#4-直接替换方法" class="headerlink" title="4.直接替换方法"></a>4.直接替换方法</h2><p>可以看到上面的方法很好的运行了， 而且可以很方便的嵌入到我们的项目中， 但是该方法依赖了<code>sitecustomize.py</code>文件， 我们很难让它抽离成一个第三方的库， 如果要抽离成第三方的库就得考虑看看有没有其他的方法。<br>在上面介绍<code>MetaPathLoader</code>时说到了<code>sys.module</code>, 在里面通过<code>sys.modules</code>来减少重复引入：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MetaPathLoader</span>:</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">load_module</span>(<span class="hljs-params">self, fullname</span>):</span><br>        <span class="hljs-comment"># import的模块都会存放在sys.modules里面， 通过判断可以减少重复import</span><br>        <span class="hljs-keyword">if</span> fullname <span class="hljs-keyword">in</span> sys.modules:<br>            <span class="hljs-keyword">return</span> sys.modules[fullname]<br>        <span class="hljs-comment"># 防止递归调用</span><br>        finder = sys.meta_path.pop(<span class="hljs-number">0</span>)<br>        <span class="hljs-comment"># 导入 module</span><br>        module = importlib.import_module(fullname)<br>        <span class="hljs-keyword">if</span> fullname == <span class="hljs-string">&#x27;time&#x27;</span>:<br>            <span class="hljs-comment"># 替换函数</span><br>            module.sleep = func_wrapper(module.sleep)<br>        sys.meta_path.insert(<span class="hljs-number">0</span>, finder)<br>        <span class="hljs-keyword">return</span> module<br></code></pre></td></tr></table></figure>
<p>这个减少重复引入的原理是， 每次引入一个模块后， 他就会存放在sys.modules， 如果是重复引入， 就会直接刷新成最新引入的模块。上面之所以会考虑到减少重复import是因为我们不会在程序运行时升级第三方库的依赖。</p>
<p>利用到我们可以不考虑重复引入同名不同实现的模块， 以及sys.modules会缓存引入模块的特点， 我们可以把上面的逻辑简化成<code>引入模块-&gt;替换当前模块方法为我们修改的hook方法</code>。<br>第一次接触这个方法是从<a href="https://github.com/uber-common/opentracing-python-instrumentation">opentracing-python-instrumentation</a>学的， 不过他夹带着其他的封装， 所以我这里进行了简化处理<a href="https://github.com/so1n/example/tree/master/example_python/example_python/python_hook/hook_by_global">github代码仓</a>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> wraps<br><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> Any, Callable, Tuple, cast<br><br><span class="hljs-keyword">import</span> aiomysql<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">func_wrapper</span>(<span class="hljs-params">func: Callable</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;和上面一样的封装函数, 这里简单略过&quot;&quot;&quot;</span><br>    <br><span class="hljs-comment"># 判断是否hook过</span><br>_IS_HOOK: <span class="hljs-built_in">bool</span> = <span class="hljs-literal">False</span><br><span class="hljs-comment"># 存放原来的_query</span><br>_query: Callable = aiomysql.Cursor._query<br><br><br><span class="hljs-comment"># hook函数</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">install_hook</span>() -&gt; <span class="hljs-keyword">None</span>:</span><br>    <span class="hljs-keyword">global</span> _IS_HOOK<br>    _IS_HOOK = <span class="hljs-literal">False</span><br>    <span class="hljs-keyword">if</span> _IS_HOOK:<br>        <span class="hljs-keyword">return</span><br>    aiomysql.Cursor._query = func_wrapper(aiomysql.Cursor._query)<br>    _IS_HOOK = <span class="hljs-literal">True</span><br><br><br><span class="hljs-comment"># 还原到原来的函数方法</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reset_hook</span>() -&gt; <span class="hljs-keyword">None</span>:</span><br>    aiomysql.Cursor._query = _query<br>    _IS_HOOK = <span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure>
<p>代码简单明了，接下来跑一跑刚才的测试：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> asyncio<br><span class="hljs-keyword">import</span> aiomysql<br><br><span class="hljs-keyword">from</span> demo <span class="hljs-keyword">import</span> install_hook, reset_hook<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_mysql</span>() -&gt; <span class="hljs-keyword">None</span>:</span><br>    pool: aiomysql.Pool = <span class="hljs-keyword">await</span> aiomysql.create_pool(<br>        host=<span class="hljs-string">&#x27;127.0.0.1&#x27;</span>, port=<span class="hljs-number">3306</span>, user=<span class="hljs-string">&#x27;root&#x27;</span>, password=<span class="hljs-string">&#x27;&#x27;</span>, db=<span class="hljs-string">&#x27;mysql&#x27;</span><br>    )<br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> pool.acquire() <span class="hljs-keyword">as</span> conn:<br>        <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> conn.cursor() <span class="hljs-keyword">as</span> cur:<br>            <span class="hljs-keyword">await</span> cur.execute(<span class="hljs-string">&quot;SELECT 42;&quot;</span>)<br>            (r,) = <span class="hljs-keyword">await</span> cur.fetchone()<br>            <span class="hljs-keyword">assert</span> r == <span class="hljs-number">42</span><br>    pool.close()<br>    <span class="hljs-keyword">await</span> pool.wait_closed()<br><br>print(<span class="hljs-string">&quot;install hook&quot;</span>)<br>install_hook()<br>asyncio.run(test_mysql())<br>print(<span class="hljs-string">&quot;reset hook&quot;</span>)<br>reset_hook()<br>asyncio.run(test_mysql())<br>print(<span class="hljs-string">&quot;end&quot;</span>)<br></code></pre></td></tr></table></figure>

<p>通过测试输出可以发现我们的逻辑的正确的, install hook后能出现我们提取的元信息， 而reset后则不会打印原信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">install hook<br>&#123;<span class="hljs-string">&#x27;sql&#x27;</span>: <span class="hljs-string">&#x27;SELECT 42;&#x27;</span>, <span class="hljs-string">&#x27;db&#x27;</span>: <span class="hljs-string">&#x27;mysql&#x27;</span>, <span class="hljs-string">&#x27;user&#x27;</span>: <span class="hljs-string">&#x27;root&#x27;</span>, <span class="hljs-string">&#x27;host&#x27;</span>: <span class="hljs-string">&#x27;127.0.0.1&#x27;</span>, <span class="hljs-string">&#x27;port&#x27;</span>: 3306, <span class="hljs-string">&#x27;result&#x27;</span>: ((42,),), <span class="hljs-string">&#x27;speed time&#x27;</span>: 0.000347137451171875&#125;<br>reset hook<br>end<br></code></pre></td></tr></table></figure>

<h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5.总结"></a>5.总结</h2><p>得益于Python动态语言的特性， 我们可以很容易为第三方库实现钩子方法，上面说的两种方法中， 第二种方法非常简单， 但在自己项目中最好还是采用第一种方法， 因为<code>Python</code>是通过一行一行代码进行扫描执行的， 第二种方法只能放在入口代码中， 并且要在被hook的对象实例化之前执行， 不然就会实现hook失败的现象, 而第一种方法除了麻烦外， 基本上能躲避所有坑。</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>APM</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式ID的几种方案</title>
    <url>/2020/09/07/%E5%88%86%E5%B8%83%E5%BC%8Fid/</url>
    <content><![CDATA[<h2 id="前记"><a href="#前记" class="headerlink" title="前记"></a>前记</h2><p>在业务中, 我们经常需要有一个唯一id, 来区分每个数据, 如每个订单都有一个自己的id, 如果是一个单体应用, 实现起来会非常容易, 但很多时候是有多个应用同时索要id, 这时候就要确保任一次生成的id都不重复,  这就催生了分布式id的概念, 分布式id一般有几个特性:</p>
<ul>
<li>全局唯一, 不会再生成与这一样的id</li>
<li>高可用， 所有的业务系统都需要依赖这个方法生成id，所以不能出现问题.</li>
<li>趋势有序, 这个id在业务中通常会充当索引字段, 所以要趋势上有序.</li>
<li>数量不可猜测(非必要), 一般的业务场景中, 会要求生成的id不会被他人猜测到今天生成的量有多少.</li>
<li>高性能, 生成id的速度一定要快.<span id="more"></span>

</li>
</ul>
<h2 id="1-UUID方案"><a href="#1-UUID方案" class="headerlink" title="1.UUID方案"></a>1.UUID方案</h2><p>UUID方案是最方便引用的方案, 由于没有网络依赖, 全靠本地生成, 所以他的性能是最高的. 但同时他的劣势也非常的明显:</p>
<ul>
<li>UUID太长了, 不适合做数据库的索引存储</li>
<li>非有序, 由于业务上基本都是用MySQL的InnoDB引擎, 所以UUID的无序会严重影响InnoDB的写入性能.</li>
<li>如果选用随机的UUID生成方式, 当使用伪随机的时候, 在量大的时候会出现冲突的可能, 如果使用真随机, 会出现硬件的熵因子不够的情况, 性能会急剧下降.</li>
<li>如果选用mac生成UUID的方式, 则会造成mac泄露</li>
</ul>
<h2 id="2-MySQL自增id方案"><a href="#2-MySQL自增id方案" class="headerlink" title="2.MySQL自增id方案"></a>2.MySQL自增id方案</h2><p>在业务中, 经常会使用MySQL中的自增id来作为id, 但是为了保证性能和高可用, 一个MySQL肯定是不行的, 必须得用集群, 这时候就得使用步进式的方案,假设有3台MySQL服务器, 那么1,2,3台服务器的初始id分别为1, 2, 3, 且他们的自增系数都为3.如下所配置:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">set</span> @@auto_increment_offset = 1;     -- 设置起始值<br><span class="hljs-built_in">set</span> @@auto_increment_increment = 2;  -- 设置自增步长<br></code></pre></td></tr></table></figure>
<p>这样能很完美的解决问题,可是这样也存在一个问题，那就是无法扩容, 用多主数据库来进行ID自增的话，只要设定好了，就再也无法变更了, 如果需要增加MySQL服务器, 上面的配置就得改了, 还要重新设置起始值(一般取当前集群最大的id), 而且每次调用都要插入一条数据, 性能会受到影响, 同时是对MySQL有强依赖, 以及自增id数量可猜测.</p>
<p>PS也可以用mongodb的自增id</p>
<h2 id="3-Redis自增id方案"><a href="#3-Redis自增id方案" class="headerlink" title="3.Redis自增id方案"></a>3.Redis自增id方案</h2><p>既然用MySQL不行, 那就用Redis吧, 通过Redis集群保证了高可用, 再使用incr指令达到跟MySQL一样的效果, 也解决的扩容的问题, 而且他的性能非常高. 但是也存在了对Redis的强依赖和订单量可猜测问题, 同时Redis只保证了3个9的可用性, 如果涉及到金额相关的场景, 3个9的可用性是不安全的. Redis之所以是3个9的一个原因是Redis的数据是存在内存的, 为了保证高可用, 需要依赖RDB和AOF来持久化, 为了保证一条命令都不能缺失, 一定要启用AOF, 每执行一条命令就写入一次, 这样的性能的不够的, 如果使用时间间隔的AOF, Redis挂了之后容易导致生成的Id重复了.</p>
<h2 id="4-号段"><a href="#4-号段" class="headerlink" title="4.号段"></a>4.号段</h2><p>号段一般是依赖与数据库的, 但是他是通过预拿一批id放到代理池里面, 本来代替每次需要的时候才拿, 减少了性能的消耗, 这种方案不会强依赖数据库, 即使数据库挂了也能撑一段时间, 但是内存所在的程序挂了的话, 这批id就丢了, 所以使用号段来实现分布式id最重要的是确定一段有多少个id, 使其性能最好, 但不会很浪费.除此之外他还有以下几个优点:</p>
<ul>
<li>可以很方便的线性扩展，性能完全能够支撑大多数业务场景</li>
<li>ID号码是趋势递增的</li>
<li>由于可以自定义启动id, 可以方便的从别的业务迁移过来</li>
</ul>
<p>但是号段方式也会造成发号数量的泄露, 不太安全, 同时每当一个号段用完了就会再去取一次数据, 这时候耗时会明显变大. 这个问题我们可以通过预加载来解决, 通过判断号段内存池剩余的数量变少到一定的数量时, 就使用后台任务重新拉一批新的号段放入号段池, 这样就可以解决用完号段再去拉号段的问题了.</p>
<h2 id="5-雪花算法"><a href="#5-雪花算法" class="headerlink" title="5.雪花算法"></a>5.雪花算法</h2><p>雪花算法是一个非常通用的方案, 由于只需要在启动时分配机器id, 之后全靠算法来生成分布式id, 所以实现成本低, 速度也快, 没有什么特殊情况, 一般都推荐使用雪花算法来实现分布式id.</p>
<p>雪花id按照一定的规则进行填充：时间（毫秒级）+集群ID+机器ID+序列号 来生成分布式id, 除了初始化阶段外, 只依赖时间, 没有其他的依赖方式, 同时生成速度也非常快, 生成的id也是趋势有序的.雪花算法十分优秀, 只不过因为需要依赖时间, 会出现两个问题:</p>
<ul>
<li>1.时间回拨的问题: 机器有可能发生时间回拨, 在遇到时间回拨时, 可以直接不处理直接报错, 或者等到时间追上来为止, 或者借用未来时间, 但是在借用未来时间后, 程序在重启时要等现实时间追上未来时间后才启动.</li>
<li>2.当前时间序列号用完了: 一般情况下, 序列号的够用的, 但也有极端情况下出现不够用的情况, 这时候需要等待到下一个时间单位.</li>
</ul>
<p>雪花算法的具体实现规则是: 雪花id是一个64bit的整数, 这64bit根据上面说的规则分别代表不同的参数值(从左到右开始数):</p>
<ul>
<li>第一bit: 一般是符号位，不做处理</li>
<li>第2-42bit: 用来记录时间戳，这里可以记录69年, 需要自己设置个开始时间戳, 用于后面的计算,twitter使用的元年时间戳是1288834974657</li>
<li>第43-52bit: 用来记录机器ID，总共可以记录1024台机器, 一般会把前几位当做集群id或者区域id, 后面几位再代表机器id</li>
<li>最后12bit: 用来对同一个毫秒之内产生不同的ID，12位可以最多记录4095个，也就是在同一个机器同一毫秒最多记录4095个，多余的需要进行等待下毫秒. 一般情况下没有业务的并发量会这样大, 所以是可以接受的.</li>
</ul>
<p><a href="https://github.com/so1n/example/blob/master/example_python/example_python/snowflake/__init__.py">简单的python实现</a>  </p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>分布式id由于带有分布式的名头, 自然也就没有一个完美的解决方案, 如果选择无中间件依赖就要解决时间回拨问题, 如果选择中间件依赖, 就要做好中间件出问题的解决办法.一般情况下雪花分布式id都适合, 但还是需要结合自己的业务去选择或定制分布式id方案. </p>
]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>基于InnoDB的API分页设计</title>
    <url>/2020/09/05/%E5%9F%BA%E4%BA%8EMySql%E7%9A%84API%E5%88%86%E9%A1%B5%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<h2 id="前记"><a href="#前记" class="headerlink" title="前记"></a>前记</h2><p>分页设计是一个常见的需求, 对于后端来说, 分页设计通常是跟数据库强绑定的需求. 一个后端API经常会返回成千上百条记录, 如果一下子返回所有结果对服务器, 客户端来说都是一个不小的挑战, 而用户也不会一次请求完所有数据, 对于多余的数据就是单纯的浪费内存和性能. 于是就有了分页的功能, 通过分页功能可以减少对服务器的负担, 加快响应速度. 分页设计很常见, 但是数据都存在数据库里面, 而很少有数据库会提供一个完备的分页功能, 数据库只能尽量的提供分页功能, 所以直接依赖数据库的分页功能容易带来性能问题. 在实现分页功能的时候, 需要尽量避免性能低效, 使用别的方法尽量的实现分页功能. 目前分页方案很多, 但没有一个万金油选项, 只能根据业务以及技术服务定义自己的分页功能.</p>
<span id="more"></span>
<hr>
<h2 id="1-一个简单的API例子"><a href="#1-一个简单的API例子" class="headerlink" title="1.一个简单的API例子"></a>1.一个简单的API例子</h2><p>首先先看看一个简单的API例子, 大多数第一版的分页功能都是这样实现的. 这个例子的Url让客户端知道能请求第几页,每页有多少条数据, 总的数量有多少:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">GET /api/book?page=10&amp;size=10<br></code></pre></td></tr></table></figure>
<p>服务端在收到请求时,会转化为offset为100(10* 10), 并在数据库调用<code>select * from xxx limit 100, 10</code>的语法来查出数据, 同时通过<code>select count(*) from xxx</code>在返回数据时,告诉客户端总共有多少条数据:</p>
<figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json">&#123;<br>    <span class="hljs-attr">&quot;page_info&quot;</span>: &#123;<br>        <span class="hljs-attr">&quot;page&quot;</span>: <span class="hljs-number">10</span>,<br>        <span class="hljs-attr">&quot;page_size&quot;</span>: <span class="hljs-number">10</span>,<br>        <span class="hljs-attr">&quot;total&quot;</span>: <span class="hljs-number">10000</span><br>    &#125;,<br>    <span class="hljs-attr">&quot;data&quot;</span>: [<br>        ...<br>    ]<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这样的设计看起来非常不错, 前后端都看得懂, 后端写起来也不费劲,但是对于服务端与<code>MySQL</code>的交互还是需要优化的</p>
<h2 id="2-优化点一-offset语法"><a href="#2-优化点一-offset语法" class="headerlink" title="2.优化点一: offset语法"></a>2.优化点一: offset语法</h2><p><code>offset</code>语法使用非常简单,但非常低效, 在前面几页时, <code>MySQL</code>的性能消耗都不高, 但翻到一定的页数时, 性能瓶颈就开始出现了.<br>前面说过, 数据库只是尽量地去提供分页功能, 在实现翻页时, 确实是返回第n页后的数据, 但是数据库仍然会去扫描前n页的数据, 当翻的页数变高时, 由于扫描的数据过多, 就开始有性能瓶颈了.</p>
<p>还是以<code>select * from xxx limit 100, 10</code>为例子,offset为100时,数据库还是会查看前解析提取110条数据,只不过是跳过前100条而已, 只返回最后10条而已(大多数提供分页功能的数据库都是这样), 所以当offset非常大时, 数据库需要查的数据量就会更大.</p>
<p>看来这个方法是不行的, 哪该怎么优化呢? 如果数据表有良好的设计, 表里应该有个<code>primary key</code>索引的id字段, 他的数值还是趋势自增的(论良好设计的重要性). 那么我们就可以利用这个字段来做实现分页功能了. 这个分页功能的原理是查询条件一定时且数据量不变的情况下(暂不分析带有 order by的情况), 数据库返回的数据顺序永远是相同的且按主键排序, 这样就可以人为的通过id来对数据进行切分, 达到分页的目的.<br>基于这个思路, 我们可以这样设计, 在每次响应时, 都把当前结果的最后一条数据的id返回给前端, 前端带上这个id请求即可请求下一页, 如果翻到最后一页, 这个id则为空, 前端就知道不可以继续翻页了, 现在可以把API的例子改为:</p>
<figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json"># page_start改为next_id<br>GET /api/book?next_id=xxxxxxx&amp;size=10<br><br>&#123;<br>    <span class="hljs-attr">&quot;page_info&quot;</span>: &#123;<br>        <span class="hljs-attr">&quot;next_id&quot;</span>: <span class="hljs-string">&quot;xxxxxxx&quot;</span>,<br>        <span class="hljs-attr">&quot;page_size&quot;</span>: <span class="hljs-number">10</span>,<br>        <span class="hljs-attr">&quot;total&quot;</span>: <span class="hljs-number">10000</span><br>    &#125;,<br>    <span class="hljs-attr">&quot;data&quot;</span>: [<br>        ...<br>    ]<br>&#125;<br></code></pre></td></tr></table></figure>
<p>如果觉得id会暴露自己的数据(比如当前的业务量), 可以改用雪花id, 也可以用其他字段代替, 只要该字段满足有索引,且保持有序自增的条件即可. 如业务需求会按时间的相关性来查询, 这时就可以用时间这个字段来代替id了.</p>
<p>改用了这种方法除了可以减少<code>MySQL</code>查询时扫描的行数,提升性能外, 还可以规避另外一个问题, 如已经查询到了100-110条数据时, 0-100中突然插入新的10条数据, 这时下一页的数据还是下一页的数据, 而offset语法则做不到这一点. </p>
<p>然而上面说了那么多好的,特别是对性能的提升非常明显,但他也有局限性, 最大的局限性就是在当前的相关性查询中必须有带索引且保持自增的字段, 此外还有一个局限性, 就是没办法大范围跳页, 或者说使用大范围跳页带来的性能消耗会跟原本的offset…limit…的方法一样. 如果用了很多种数据库, 就会发现上面说的方法很像<code>MySQL</code>, <code>ElasticSearch</code>和<code>Redis</code>的游标, 实际上上面用到的方法正就是<code>MySQL</code>的游标, 如果在代码里有保存对应的游标对象的话, 是能一直调用<code>cursor.fetchone</code>获取之后的数据的, 每次查一行数据, 但是不能直接无视中间的数据跳到第n行后面, 我们这个方法就是通过一个索引数据来代替这个游标对象.</p>
<h2 id="3-优化点二-总的数量"><a href="#3-优化点二-总的数量" class="headerlink" title="3.优化点二: 总的数量"></a>3.优化点二: 总的数量</h2><p>在返回响应中, 我们需要返回一个总的数量, 那么就需要执行两条语句:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> xxx limit <span class="hljs-number">100</span>, <span class="hljs-number">10</span><br><span class="hljs-keyword">select</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">from</span> xxx<br></code></pre></td></tr></table></figure>
<p>这样不止在写代码的时候十分麻烦, 同时要查两次也很浪费性能, 如果通过查阅资料就可以发现, 这时可以通过使用<code>FOUND_ROWS</code>函数来帮忙, 把语句改为如下:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> SQL_CALC_FOUND_ROWS <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> xxx limit <span class="hljs-number">100</span>, <span class="hljs-number">10</span><br><span class="hljs-keyword">select</span> found_rows() count;<br></code></pre></td></tr></table></figure>
<p>这样查询的查询量只有一次, 第二条语句会返回第一条语句不带limit查询的总值, 大大的增加了性能.<br>需要注意的是, 第一条语句一定要带有<code>sql_cale_found_rows</code>和<code>limit</code>, 不然第二条语句返回的结果会不对, 同时第二条语句会过滤一些为空的数据.<br>可以看出来, 这种方法让人容易误解, 也容易出错, 而且它是<code>MySQL</code>提供的功能, 而不是<code>MySQL</code>中引擎提供的功能, 对部分引擎来说, 性能提升并不是很大, 特别是对于我们常用的InnoDB引擎来说….<br>对于InnoDB引擎来说, 还是选择用<code>count(*)</code>性能会更好, 因为它对<code>count</code>有一些特别的优化, 以下是<code>count</code>几种情形的执行原理:</p>
<ul>
<li>对于<code>count(pk)</code>, InnoDB会遍历整张表, 把每一行的id值都取出来, 返回给<code>MySQL</code>的server层, server层拿到id后, 通过判断是不是为空来累加.</li>
<li>对于<code>count(1)</code>, InnoDB会遍历整张表, 但不取值, <code>MySQL</code>的server层对于返回的每一行, 都放一个数字1进去, 判断是不是为空再按行累加, 由于不用解析数据, 所以速度比<code>count(pk)</code>快一些.</li>
<li>对于<code>count(字段)</code>, 会先判断这个字段是<code>not null</code>还是<code>null</code>, 如果是<code>not null</code>, 则一行行地从记录里读取这个字段, 判断不能为null再按行累加. 如果是<code>null</code>, 那么判断有可能为null, 则把值取出来判断, 最后判断不是null才累加.</li>
<li>对于<code>count(*)</code>, 是一个特殊的优化, 他不取值, 也不判断是不是null, 直接按行累加.</li>
</ul>
<p>可以看出, 按照效率排行是 <code>count(*)</code> 约等于 <code>count(1)</code> &gt; <code>count(pk)</code> &gt; <code>count(字段)</code>.</p>
<blockquote>
<p>注: found_row方法并不是在所有的场景下都能增加性能, 不同的存储引擎, 以及查询语句是否根据索引过滤都会影响到该方法的性能, 如果不确定那种方法的性能好, 建议使用 select count(*) from xxx</p>
<p>found_rows 性能说明链接:</p>
<p><a href="https://stackoverflow.com/questions/1022482/is-there-an-effect-on-the-speed-of-a-query-when-using-sql-calc-found-rows-in-mys#">https://stackoverflow.com/questions/1022482/is-there-an-effect-on-the-speed-of-a-query-when-using-sql-calc-found-rows-in-mys#</a></p>
<p><a href="https://www.percona.com/blog/2007/08/28/to-sql_calc_found_rows-or-not-to-sql_calc_found_rows/">https://www.percona.com/blog/2007/08/28/to-sql_calc_found_rows-or-not-to-sql_calc_found_rows/</a></p>
</blockquote>
<p>那我们该如何改进呢? 首先是确定真的需要总数吗, 目前很多基于瀑布流的展示都是不需要总数, 如果真的需要总数, 那就只能使用缓存的方法, 根据查询条件为Key, 总数为Value存在缓存中, 每过一段时间再重新更新缓存. 由于内容很多造成页数很大, 即使数据有变动, 短时间内总页数不变动影响也不大, 这样既能满足需求, 又能解决性能上的问题.</p>
<h2 id="4-优化点三-数据重复问题"><a href="#4-优化点三-数据重复问题" class="headerlink" title="4.优化点三: 数据重复问题"></a>4.优化点三: 数据重复问题</h2><p>在执行<code>select * from xxx limit 100, 10</code>时, 顺序都是一致的, 假设里面有个价格的字段, 而这个字段我们一般不会加索引的, 但是我们要按照他的大小来排序, 这时sql会写为<code>select * from xxx order by price desc limit 100, 10</code>. 经过这个改动后, 就会触发一个问题–不同的页面可能会出现相同的数据, 但是使用了<code>select * from xxx order by price desc, id desc limit 100, 10</code>就可以解决问题了(id为唯一索引), 为啥在排序条件中增加id这个字段后就可以解决问题呢?</p>
<p>首先先看看<code>MySQL</code>针对一个查询语句的执行顺序:</p>
<ul>
<li><ol>
<li>SELECT</li>
</ol>
</li>
<li><ol start="2">
<li>DISTINCT <select_list></li>
</ol>
</li>
<li><ol start="3">
<li>FROM <left_table></li>
</ol>
</li>
<li><ol start="4">
<li><join_type> JOIN <right_table></li>
</ol>
</li>
<li><ol start="5">
<li>ON <join_condition></li>
</ol>
</li>
<li><ol start="6">
<li>WHERE <where_condition></li>
</ol>
</li>
<li><ol start="7">
<li>GROUP BY <group_by_list></li>
</ol>
</li>
<li><ol start="8">
<li>HAVING <having_condition></li>
</ol>
</li>
<li><ol start="9">
<li>ORDER BY <order_by_condition></li>
</ol>
</li>
<li><ol start="10">
<li>LIMIT <limit_number></li>
</ol>
</li>
</ul>
<p>从执行顺序可以看出, <code>MySQL</code>在执行完排序后再执行limit语句的, 而出现上面不同页面可能有相同数据这种情况是跟<code>MySQL</code>5.6之后的更新有关的. 在<code>MySQL</code>5.6之, 后优化器在遇到order by limit语句时, 会使用priority queue的一个优化, 使用 priority queue 的目的是在不能使用索引有序性的时候，如果用到了排序且使用了limit n，那么只需要在排序的过程中，保留n条记录即可, 也就是这个最小堆的排序, 而这种方法不是稳定排序的, 值相同时, 顺序并不是一定的. 假设我们要排序的值都是一样的, 且有20个, 假设有两次查询, 一次查询的量是10个, 那会发现两次查询的值是有重复的.</p>
<p>了解了问题的原因后就可以知道<code>select * from xxx order by price desc limit 100, 10</code>出现重复数据的原因是price有相同的值, 导致了数据的重复, 而在加了一个id后, 就没有一个值会重复了, 所以问题也就解决了.<br>但是需要注意的是, 还有一些极端的情况下会出现数据重复的情况, 因为我们的分页是在数据库提供的排序功能的基础上，衍生出来的应用需求，数据库并不保证分页的重复问题。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>大多数的数据库都是没有分页这个接口的, 我们定义的分页都是建立在排序的基础上进行了数量范围的分割. 排序是数据库提供的功能, 分页是衍生的需求, 所以我们只要了解好了数据库的排序功能已经如何去切割, 那就能在基于数据库实现分页时少踩坑.</p>
]]></content>
      <categories>
        <category>设计</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>Web</tag>
        <tag>设计</tag>
      </tags>
  </entry>
  <entry>
    <title>git</title>
    <url>/2020/09/01/git/</url>
    <content><![CDATA[<h2 id="1-开发流程"><a href="#1-开发流程" class="headerlink" title="1.开发流程"></a>1.开发流程</h2><p>每个公司都有自己的一套git流程， 如果没有则推荐使用<a href="https://danielkummer.github.io/git-flow-cheatsheet/index.zh_CN.html">git-flow备完清单</a></p>
<h2 id="2-log"><a href="#2-log" class="headerlink" title="2.log"></a>2.log</h2><p>优雅的输出git日志</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">log</span> --decorate --oneline --graph<br></code></pre></td></tr></table></figure>
<h2 id="3-tag"><a href="#3-tag" class="headerlink" title="3.tag"></a>3.tag</h2><p>项目每次发一个版本可以打一个tag, 利于代码版本管理, tag 的作用是对某个提交点打上标签，发布版本后打 tag，便于以后回滚特定版本，而不需要 revert。</p>
<ul>
<li><code>$ git tag -a &#39;&lt;tag_name&gt;&#39; -m &#39;&lt;description&gt;&#39;</code> 提交一个tag</li>
<li><code>$ git tag -n1</code> 显示一个 tag</li>
<li><code>$ git push origin --tags</code> 上传tag</li>
<li><code>$ git pull origin --tags</code> 下载合并tag</li>
<li><code>$ git push origin :refs/tags/&lt;tag_name&gt;</code> 删除远程 tags</li>
</ul>
<h2 id="4-第一次提交使用git-push-–set-upsteam"><a href="#4-第一次提交使用git-push-–set-upsteam" class="headerlink" title="4.第一次提交使用git push –set-upsteam"></a>4.第一次提交使用git push –set-upsteam</h2><p>在第一次提交时， 建议使用–set-upsteam, 后续在push时就可以直接使用git push, 比如有个项目名叫<code>demo</code>:</p>
<ul>
<li>使用push的情况:<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 第一次push</span><br>git push demo<br><span class="hljs-comment"># 后续push</span><br>git push demo<br></code></pre></td></tr></table></figure></li>
<li>使用<code>--set-upsteam</code>的情况:<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 第一次push</span><br>git push demo --set-upsteam<br><span class="hljs-comment"># 后续push</span><br>git push<br></code></pre></td></tr></table></figure></li>
<li>简写：<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 第一次push</span><br>git push -u demo<br><span class="hljs-comment"># 后续push</span><br>git push<br></code></pre></td></tr></table></figure>
<h2 id="5-rebase-master"><a href="#5-rebase-master" class="headerlink" title="5.rebase/master"></a>5.rebase/master</h2><h3 id="5-1rebase与master的区别"><a href="#5-1rebase与master的区别" class="headerlink" title="5.1rebase与master的区别"></a>5.1rebase与master的区别</h3><code>git merge</code> 和 <code>git rebase</code> 都可以整合两个分支的内容，最终结果没有任何区别，但是变基使得提交历史更加整洁。</li>
</ul>
<p>假设先在<code>dev</code>分支提交一次， 然后在<code>master</code>提交一次， 然后在<code>dev</code>分支执行<code>rabese</code>/<code>merge</code>操作，之后有两点不同：</p>
<ul>
<li>提交点顺序：<ul>
<li><code>git merge</code>后，提交点的顺序都和提交的时间顺序相同，即<code>master</code>的提交在<code>dev</code>之后。</li>
<li><code>git rebase</code>后，顺序变成被<code>rebase</code>的分支（<code>master</code>）所有提交都在前面，进行<code>rebase</code>的分支（<code>dev</code>）提交都在被<code>rebase</code>的分支之后，在同一分支上的提交点仍按时间顺序排列。</li>
</ul>
</li>
<li>分支变化<br><code>dev</code>在<code>rebase master</code>后，由原来的两个分岔的分支，变成重叠的分支，看起来<code>dev</code>是从最新的<code>master</code>上拉出的分支。<h3 id="5-2何时使用rebase"><a href="#5-2何时使用rebase" class="headerlink" title="5.2何时使用rebase"></a>5.2何时使用rebase</h3>假设现在有<code>dev</code>分支， 由于有功能开发， 基于<code>dev</code>分支创建了<code>feature</code>分支。<br>如果<code>dev</code>分支要合并<code>feature</code>， 则都在<code>dev</code>分支调用<code>git merge feature</code>, 反过来<code>feature</code>要更新<code>dev</code>的内容时，使用<code>git rebase dev</code><br>假设场景：从 dev 拉出分支 feature-a。那么当 dev 要合并 feature-a 的内容时，使用 git merge feature-a；反过来当 feature-a 要更新 dev 的内容时，使用 git rebase dev。<h3 id="5-3git-merge-–no-ff"><a href="#5-3git-merge-–no-ff" class="headerlink" title="5.3git merge –no-ff"></a>5.3git merge –no-ff</h3>在使用merge时， 如果分支没有冲突， 则会把被merge分支的指针指到merge的分支。而使用<code>git merge --no-ff</code>则是在新的分支上进行合并， 合并时会保留当前分支的信息。<h3 id="5-4git-pull-–rebase"><a href="#5-4git-pull-–rebase" class="headerlink" title="5.4git pull –rebase"></a>5.4git pull –rebase</h3>理论上， 任何时候执行<code>git pull</code>时， 都应该变为<code>git pull --rebase</code>.<br>当某个分支可能与其远程分支发生分离， 在使用<code>git pull</code>后就会变成本地分支和远程分支合并, 就会变成类似<code>git merge</code>的情况，  而我们拉取分支只是要同步线上的功能， 通过<code>5.2</code>可以知道， 应该使用类似<code>git merge</code>来更新功能。</li>
</ul>
<h2 id="6-commit规范"><a href="#6-commit规范" class="headerlink" title="6.commit规范"></a>6.commit规范</h2><p>每个项目的都应该有个一统一的commit规范， 不同公司的提交规范会不一致， 我个人常用的规范是：</p>
<figure class="highlight mojolicious"><table><tr><td class="code"><pre><code class="hljs mojolicious"><span class="xml">git commit -m&quot;<span class="hljs-tag">&lt;<span class="hljs-name">issue_id</span>&gt;</span>:<span class="hljs-tag">&lt;<span class="hljs-name">file</span> <span class="hljs-attr">change</span>&gt;</span>:<span class="hljs-tag">&lt;<span class="hljs-name">operating</span>&gt;</span>:<span class="hljs-tag">&lt;<span class="hljs-name">info</span>&gt;</span>&quot;</span><br></code></pre></td></tr></table></figure>
<ul>
<li>issue_id: 代表一个issue的id, 在准备写功能或者修复一个bug时，都应该先提一个issue，然后在针对这个issue提交代码</li>
<li>file change: 代表文件的变化， 如增加， 删除， 修改;也有人使用<code>+,-，*</code>来分别代表增加， 删除， 修改</li>
<li>operating: 代表本次代码变化, 具体有如下几种<ul>
<li>feat：新功能</li>
<li>fix：修复bug</li>
<li>doc：文档改变</li>
<li>style：代码格式改变</li>
<li>refactor：某个已有功能重构</li>
<li>perf：性能优化</li>
<li>test：增加测试</li>
<li>build：改变了build工具 如 grunt换成了 npm</li>
<li>revert：撤销上一次的commit</li>
</ul>
</li>
<li>info: 简要的说明本次提交信息</li>
</ul>
<p>更加规范的参考示例见： <a href="https://www.conventionalcommits.org/en/v1.0.0/">https://www.conventionalcommits.org/en/v1.0.0/</a></p>
<h2 id="7-cherry-pick"><a href="#7-cherry-pick" class="headerlink" title="7.cherry-pick"></a>7.cherry-pick</h2><p><code>git cherry-pick</code>即应用某些已有提交所引入的更改, 通常是将某个分支的提交应用到另外一个分支, 常用于紧急修复bug或者从放弃的分支中挑出有用的commit。他的优点非常明显，只合并分支中的一个提交，而不是所有提交,如下, 可以单独挑出<code>master</code>分支的c提交合并到new_feature中：</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><code class="hljs xl">[<span class="hljs-function"><span class="hljs-title">master</span>] a -&gt;</span> <span class="hljs-function"><span class="hljs-title">b</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">c</span> -&gt;</span> d<br>[<span class="hljs-function"><span class="hljs-title">new_feature</span>] e -&gt;</span> <span class="hljs-function"><span class="hljs-title">f</span> -&gt;</span> g<br></code></pre></td></tr></table></figure>
<p><code>gir cherry-pick</code>常见使用命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 应用某个commit</span><br>git cherry-pick &lt;commit-id&gt;<br><span class="hljs-comment"># 保留提交人信息， 不带x则使用cherrt-pick的执行者信息</span><br><span class="hljs-comment"># 如果是-e则是可以重新写上新的提交信息</span><br><span class="hljs-comment"># 如果是-n 则只更新工作区和暂存区， 不提交（相当于git add）</span><br>git cherry-pick -x &lt;commit-id&gt;<br><span class="hljs-comment"># 应用一段连续的commit,注意是左开右闭</span><br>git cherry-pick &lt;start-commit-id&gt;…&lt;end-commit-id&gt;<br><span class="hljs-comment"># 应用一段连续的commit, 注意是左闭右闭</span><br>git cherry-pick &lt;start-commit-id&gt;^…&lt;end-commit-id&gt;<br><span class="hljs-comment">#</span><br></code></pre></td></tr></table></figure>

<h2 id="8-git-pull-强制覆盖本地"><a href="#8-git-pull-强制覆盖本地" class="headerlink" title="8.git pull 强制覆盖本地"></a>8.git pull 强制覆盖本地</h2><p>一般我们需要同步线上分支时,需要重新强制拉取线上分支覆盖到本地</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 从远程拉取所有内容</span><br>git fetch --all<br><br><span class="hljs-comment"># reset 本地代码</span><br>git reset --hard origin/master<br><br><span class="hljs-comment"># 重启拉取对齐</span><br>git pull<br></code></pre></td></tr></table></figure>
<h2 id="9-回退到某个分支"><a href="#9-回退到某个分支" class="headerlink" title="9.回退到某个分支"></a>9.回退到某个分支</h2><p>很多时候我们经常需要回退到某个分支,这时就需要git reset,为了保险起见,需要确保在执行git reset前,能知道当前分支的commit或者查看reflog的commit,确保有后悔药可以吃。</p>
<blockquote>
<p><code>git log</code>是查看分支的变根情况， 会根远程分支同步， 而<code>git reflog</code>的功能是查看本地操作记录，可以看到本地的<code>commit</code>, <code>merge</code>, <code>rebase</code>等操作记录<br>git reset简单粗暴,就是把索引指向某个commit,并做对应的操作,使用方法</p>
</blockquote>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql">git <span class="hljs-keyword">reset</span> &lt;<span class="hljs-keyword">commit</span>&gt;<br></code></pre></td></tr></table></figure>
<p>此外还可以指定可选参数， 具体参数定义如下:</p>
<figure class="highlight brainfuck"><table><tr><td class="code"><pre><code class="hljs brainfuck">--<span class="hljs-comment">soft</span> <span class="hljs-comment">回退后分支修改的代码被保留并标记为add的状态（git</span> <span class="hljs-comment">status</span> <span class="hljs-comment">是绿色的状态）</span><br><span class="hljs-comment"></span>--<span class="hljs-comment">mixed</span> <span class="hljs-comment">重置索引，但不重置工作树，更改后的文件标记为未提交（add）的状态。默认操作。</span><br><span class="hljs-comment"></span>--<span class="hljs-comment">hard</span> <span class="hljs-comment">重置索引和工作树，并且a分支修改的所有文件和中间的提交，没提交的代码都被丢弃了。</span><br><span class="hljs-comment"></span>--<span class="hljs-comment">merge</span> <span class="hljs-comment">和</span>--<span class="hljs-comment">hard类似，只不过如果在执行reset命令之前你有改动一些文件并且未提交，merge会保留你的这些修改，hard则不会。【注：如果你的这些修改add过或commit过，merge和hard都将删除你的提交】</span><br><span class="hljs-comment"></span>--<span class="hljs-comment">keep</span> <span class="hljs-comment">和</span>--<span class="hljs-comment">hard类似，执行reset之前改动文件如果是a分支修改了的，会提示你修改了相同的文件，不能合并。如果不是a分支修改的文件，会移除缓存区。git</span> <span class="hljs-comment">status还是可以看到保持了这些修改。</span><br></code></pre></td></tr></table></figure>
<p>如果要reset到上个提交,可以直接写</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql">git <span class="hljs-keyword">reset</span> <span class="hljs-comment">--hard HEAD^</span><br></code></pre></td></tr></table></figure>

<h2 id="10-移除git的某些commit"><a href="#10-移除git的某些commit" class="headerlink" title="10.移除git的某些commit"></a>10.移除git的某些commit</h2><p>执行该命令,会撤销对应的提交,然后再重新提交一个新的提交(该操作可以撤销,如果使用reset则会直接回退到某个commit,除非有reflog记录或记得某个commit id,不然无法撤销).<br>再执行git revert前,必须执行</p>
<figure class="highlight handlebars"><table><tr><td class="code"><pre><code class="hljs handlebars"><span class="xml">git diff <span class="hljs-tag">&lt;<span class="hljs-name">commit1</span>&gt;</span> HEAD</span><br><span class="xml">git diff <span class="hljs-tag">&lt;<span class="hljs-name">commit1</span>&gt;</span>..<span class="hljs-tag">&lt;<span class="hljs-name">commit2</span>&gt;</span></span><br></code></pre></td></tr></table></figure>
<p>查看要撤销的代码是否正确,再使用 git revert <commit> 可以撤销指定的提交，要撤销一串提交可以用 <commit1>..<commit2> 语法。 注意这是一个前开后闭区间，即不包括 commit1，但包括 commit2。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">git revent &lt;commit&gt;<br><span class="hljs-comment"># 可以指定一个前开后闭的区间被移除</span><br>git revent &lt;commit&gt;...&lt;commit&gt;<br></code></pre></td></tr></table></figure>

<h3 id="11-另外一种移除git的某些commit方法"><a href="#11-另外一种移除git的某些commit方法" class="headerlink" title="11.另外一种移除git的某些commit方法"></a>11.另外一种移除git的某些commit方法</h3><p>假设有commig v1,v2,v3,v4,v5共5个commit, 下面的操作会移除v3这个commit</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 从 v2 切分支出来</span><br>git checkout -b fixing v2<br><span class="hljs-comment"># 合并 v4，保持代码不变</span><br>git merge -s ours v4<br><span class="hljs-comment"># 合并 v5(也就是当前罪行的分支)</span><br>git merge master<br></code></pre></td></tr></table></figure>
<h2 id="12-git将一个分支完全覆盖另外一个分支"><a href="#12-git将一个分支完全覆盖另外一个分支" class="headerlink" title="12.git将一个分支完全覆盖另外一个分支"></a>12.git将一个分支完全覆盖另外一个分支</h2><p>如下代码,把线上的master分支覆盖本地的develop分支</p>
<figure class="highlight vala"><table><tr><td class="code"><pre><code class="hljs vala"><span class="hljs-meta"># 切换到develop</span><br>git checkout develop<br><span class="hljs-meta"># 指向origin/master</span><br>git reset --hard origin/master<br><span class="hljs-meta"># 强拉</span><br>git push -f<br></code></pre></td></tr></table></figure>

<h2 id="13-git-hooks文件指定"><a href="#13-git-hooks文件指定" class="headerlink" title="13.git hooks文件指定"></a>13.git hooks文件指定</h2><p>git hook文件一般为bash.sh文件, 只要把文件放置于项目的<code>.git/hooks</code>下即可让该项目的git命令享用hook套餐</p>
<p>如果觉得每个项目都需要配置一次很麻烦, 则可以创建一个文件夹存放hooks文件,并调用全局命令<code>git config --global core.hookspath xxx</code>指定.</p>
<p>如果自己的电脑上有自己的项目和公司的项目, 想用两套hook文件, 也还是有办法的:</p>
<ul>
<li>1.首先自己的项目和公司的项目是在不同的文件夹里面, 比如我自己的项目在<code>/home/so1n/github</code>, 公司的项目在<code>/home/so1n/xxx_gitlab</code>下面.</li>
<li>2.修改<code>~/.gitconfig</code>  <figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">[includeIf <span class="hljs-string">&quot;gitdir:~/xxx_gitlab/&quot;</span>]<br>path = .gitconfig-xxx<br></code></pre></td></tr></table></figure></li>
<li>3.创建一个与上面path一样的文件<code>~/.gitconfig-xxx</code>,并写入如下配置, 指定该项目需要的hook文件  <figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">[core]<br>hookspath = ~/.git-hooks<br></code></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="13-1git禁止在master分支push和commit"><a href="#13-1git禁止在master分支push和commit" class="headerlink" title="13.1git禁止在master分支push和commit"></a>13.1git禁止在master分支push和commit</h3><p><a href="https://suncle.me/2020/09/25/git-forbids-push-and-commit-on-master-branch/">本小节来源</a></p>
<p>作为管理者，在远端将master分支设为保护分支，可以从根源上杜绝直接推送到master的问题, 每个平台的选项有所不同.<br>作为开发者，在本地的git hook中加配置可以做到在commit和push操作时做对应的检查.</p>
<h3 id="13-2禁止在master分支上Commit"><a href="#13-2禁止在master分支上Commit" class="headerlink" title="13.2禁止在master分支上Commit"></a>13.2禁止在master分支上Commit</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/sh</span><br><br><span class="hljs-comment"># 指定受保护的分支</span><br>protected_branch=<span class="hljs-string">&#x27;master&#x27;</span><br><br><span class="hljs-comment"># 获取当前的分支</span><br>current_branch=$(git rev-parse --symbolic --abbrev-ref HEAD)<br><br><span class="hljs-comment"># 判断当前分支是否为受保护的分支, 如果是则打印警告, 并且退出</span><br><span class="hljs-keyword">if</span> [ <span class="hljs-string">&quot;<span class="hljs-variable">$protected_branch</span>&quot;</span> == <span class="hljs-string">&quot;<span class="hljs-variable">$current_branch</span>&quot;</span> ]; <span class="hljs-keyword">then</span><br>  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;.git/hooks: Do not commit to <span class="hljs-variable">$current_branch</span> branch&quot;</span><br>  <span class="hljs-built_in">exit</span> 1<br><span class="hljs-keyword">fi</span><br></code></pre></td></tr></table></figure>

<h3 id="13-3在master分支上Commit时提示"><a href="#13-3在master分支上Commit时提示" class="headerlink" title="13.3在master分支上Commit时提示"></a>13.3在master分支上Commit时提示</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/sh</span><br><br>protected_branch=<span class="hljs-string">&#x27;master&#x27;</span><br>current_branch=$(git rev-parse --symbolic --abbrev-ref HEAD)<br><br><span class="hljs-keyword">if</span> [ <span class="hljs-string">&quot;<span class="hljs-variable">$protected_branch</span>&quot;</span> == <span class="hljs-string">&quot;<span class="hljs-variable">$current_branch</span>&quot;</span> ]; <span class="hljs-keyword">then</span><br>  <span class="hljs-comment"># 打印提示 并等待操作...</span><br>  <span class="hljs-built_in">read</span> -p <span class="hljs-string">&quot;You&#x27;re about to commit to master, is that what you intended? [y|n] &quot;</span> -n 1 -r &lt;/dev/tty<br>  <span class="hljs-built_in">echo</span><br>  <span class="hljs-comment"># 如果是y则通过, 否则退出</span><br>  <span class="hljs-keyword">if</span> <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$REPLY</span>&quot;</span> | grep -E <span class="hljs-string">&#x27;^[Yy]$&#x27;</span> &gt;/dev/null; <span class="hljs-keyword">then</span><br>    <span class="hljs-built_in">exit</span> 0 <br>  <span class="hljs-keyword">fi</span><br>  <span class="hljs-built_in">exit</span> 1 <br><span class="hljs-keyword">fi</span><br></code></pre></td></tr></table></figure>

<h3 id="13-4禁止推送到master分支"><a href="#13-4禁止推送到master分支" class="headerlink" title="13.4禁止推送到master分支"></a>13.4禁止推送到master分支</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/sh</span><br><br>protected_branch=<span class="hljs-string">&#x27;master&#x27;</span><br>remote_branch_prefix=<span class="hljs-string">&quot;refs/heads/&quot;</span><br>protected_remote_branch=$remote_branch_prefix<span class="hljs-variable">$protected_branch</span><br><br><span class="hljs-keyword">while</span> <span class="hljs-built_in">read</span> local_ref local_sha remote_ref remote_sha<br><span class="hljs-keyword">do</span><br>    <span class="hljs-keyword">if</span> [ <span class="hljs-string">&quot;<span class="hljs-variable">$protected_remote_branch</span>&quot;</span> == <span class="hljs-string">&quot;<span class="hljs-variable">$remote_ref</span>&quot;</span> ]; <span class="hljs-keyword">then</span><br>        <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;.git/hooks: Do not commit to <span class="hljs-variable">$protected_branch</span> branch&quot;</span><br>      <span class="hljs-built_in">exit</span> 1<br>    <span class="hljs-keyword">fi</span><br><span class="hljs-keyword">done</span><br><br><span class="hljs-built_in">exit</span> 0<br></code></pre></td></tr></table></figure>
<h3 id="13-5推送时如果commit消息包含WIP则禁止推送"><a href="#13-5推送时如果commit消息包含WIP则禁止推送" class="headerlink" title="13.5推送时如果commit消息包含WIP则禁止推送"></a>13.5推送时如果commit消息包含WIP则禁止推送</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/sh</span><br><br>protected_branch=<span class="hljs-string">&#x27;master&#x27;</span><br>remote_branch_prefix=<span class="hljs-string">&quot;refs/heads/&quot;</span><br>protected_remote_branch=$remote_branch_prefix<span class="hljs-variable">$protected_branch</span><br><br><span class="hljs-keyword">while</span> <span class="hljs-built_in">read</span> local_ref local_sha remote_ref remote_sha<br><span class="hljs-keyword">do</span><br>    <span class="hljs-keyword">if</span> [ <span class="hljs-string">&quot;<span class="hljs-variable">$protected_remote_branch</span>&quot;</span> == <span class="hljs-string">&quot;<span class="hljs-variable">$remote_ref</span>&quot;</span> ]; <span class="hljs-keyword">then</span><br>        <span class="hljs-built_in">read</span> -p <span class="hljs-string">&quot;You&#x27;re about to push master, is that what you intended? [y|n] &quot;</span> -n 1 -r &lt; /dev/tty<br>    <span class="hljs-built_in">echo</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">echo</span> <span class="hljs-variable">$REPLY</span> | grep -E <span class="hljs-string">&#x27;^[Yy]$&#x27;</span> &gt; /dev/null<br>    <span class="hljs-keyword">then</span><br>        <span class="hljs-built_in">exit</span> 0 <span class="hljs-comment"># push will execute</span><br>    <span class="hljs-keyword">fi</span><br>    <span class="hljs-built_in">exit</span> 1 <span class="hljs-comment"># push will not execute</span><br>    <span class="hljs-keyword">fi</span><br><span class="hljs-keyword">done</span><br><br><span class="hljs-built_in">exit</span> 0<br></code></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式事务</title>
    <url>/2020/08/17/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/</url>
    <content><![CDATA[<h2 id="前记"><a href="#前记" class="headerlink" title="前记"></a>前记</h2><p>随着业务的快速发展, 业务会越来越复杂, 架构也会跟着变复杂.传统的单体应用逐渐变得力不从心, 而微服务架构却能很好的解决问题. 但是微服务也会带来一些问题, 如本文说到的分布式事务, 分布式事务有几种解决的方法, 但都不是银弹, 分布式事务不可能100%的得到解决, 只能尽量提高成功率, 剩下的会失败的部分应该要做好监控或者任务补偿, 还需要人工介入.</p>
<span id="more"></span>
<h2 id="1-单机事务到分布式事务的区别"><a href="#1-单机事务到分布式事务的区别" class="headerlink" title="1.单机事务到分布式事务的区别"></a>1.单机事务到分布式事务的区别</h2><p>单机的事务通过ACDI保证数据的强一致性,例如常见的<code>MySQL</code>, 从事务开始后可以执行commit提交事务, 或者执行rollback回滚事务, 提交事务很简单, 而回滚事务是通过<code>undo log</code>记录的反向日志进行回滚.单机事务可以准确的执行要么成功, 要么失败的操作, 没有其他的影响因素. 但是把单机事务拓展为分布式事务的时候, 就已经来到了分布式系统了, 这时候的事务管理会更加复杂, 会由于数据不一致,网络波动,程序bug,数据库挂掉等原因会导致一些奇怪的问题, 而这些因素都是不可控的.<br>一旦跟分布式有关, 就可以套用cap定理了, 根据cap定理可以知道, 任何系统只能满足其中两个条件, 无法三者兼得, 对于分布式系统而言，分区容错性是一个最基本的要求. 如果选择了一致性和分区容错性，放弃可用性，那么网络问题会导致系统不可用. 如果选择可用性和分区容错性，放弃一致性，不同的节点之间的数据不能及时同步数据而导致数据的不一致. 在分布式事务中, 虽然从单机变成多台机器, 但是总的事务逻辑都是不变的, 但是在可用性这方面是有区别的.<br>所以我们没有别的方案, 我们需要让分布式事务允许损失部分可用性，并且不同节点进行数据同步的过程存在延时，但是在经过一段时间的修复后，最终能够达到数据的最终一致性, 所以大多数是分布式事务都会考虑放弃一定的一致性, 通过一定的补偿方法让数据最终一致.</p>
<h2 id="2-二阶段提交协议"><a href="#2-二阶段提交协议" class="headerlink" title="2.二阶段提交协议"></a>2.二阶段提交协议</h2><p>假设现在有两个微服务B和C, B负责扣款, C负责减库存, 有个购买的服务A调用B和C, 在正常的微服务通信中, 很难做到同时判断B和C是否成功和失败, 而二阶段提交协议为了解决多个节点的协调问题, 引入了一个事务管理者来管理B和C, 而B和C被称为参与者.</p>
<p>二阶段提交协议就像名字一样, 共有两个阶段, 第一个阶段, 事务管理者D向参与者B和C发送准备命令, 并等待结果, 如果参与者可以执行, 就会执行操作, 但不提交, 然后把自己的操作结果返回给事务管理者D. 第二阶段, 如果全部参与者都返回提交成功, 则事务管理者会发送提交命令给参与者, 让参与者正式提交, 如果其中有一个提交失败, 则事务管理者会向所有的参与者发送回滚命令, 让参与者回滚数据.</p>
<p>可以看出二阶段提交协议非常的简单, 描述也就是一句话而已, 但是还是有缺陷的, 一个是所有操作全靠事务管理者来调度, 而事务管理者需要等待所有的参与者返回数据后才能进行下一步, 这样相当于有一个全局的大锁, 很容易造成同步阻塞的问题. 另一个是如果出现单点故障,整个流程都会阻塞, 如参与者出现故障无法响应, 事务管理者会一直等待响应, 事务管理者出现问题则失去控制者, 可能出现数据不一致.</p>
<h2 id="3-三阶段提交协议"><a href="#3-三阶段提交协议" class="headerlink" title="3.三阶段提交协议"></a>3.三阶段提交协议</h2><p>三阶段协议和二阶段协议很像, 不过增加了超时机制解决同步阻塞的问题, 同时引入了一个预备阶段, 该阶段会在准备执行事务时, 由事务管理者发送请求给所有的参与者, 如果有参与者回复超时或出错则停止事务, 如果都回复成功, 则像二阶段提交协议一样继续执行.<br>三阶段协议虽然解决了一个预阶段来防止大部分可能出现的全局阻塞问题, 但是还是不可避免的出现了全局锁和单点事务管理者的问题.</p>
<h2 id="4-TCC模式"><a href="#4-TCC模式" class="headerlink" title="4.TCC模式"></a>4.TCC模式</h2><p>上面中引入了事务管理者, 容易出现单点瓶颈, 在业务的不断变大的情况下,系统的伸缩性可能存在问题, 同时,由于是同步操作, 引入的事务会被一个全局锁锁住,直至事务结束才释放, 所以性能压力会非常大, 而TCC模式都能解决上面的问题.<br>TCC模式将一个分布式任务拆分为Try, Confirm, Cancel. 由调用服务A发起流程, 而业务服务B和C提供TCC模式的三个阶段操作: 预留资源, 提交 or 回滚, 主要流程是:</p>
<ul>
<li>第一阶段:调用服务A发起请求, 业务服务分别执行, B进行资金冻结, C进行库存冻结,</li>
<li>第二阶段:调用服务A检查两个服务的返回状态, 如果都返回成功, 则发起Confirm请求, 业务服务收到请求后, B进行资金扣减, C进行库存扣减</li>
<li>第三阶段:如果有一个服务失败, 则发起Cancel请求, 业务服务收到请求后, B移除资金冻结, Ｃ移除库存冻结</li>
</ul>
<p>上面的每一步都是一个完整的子事务, 每次做完操作都会进行提交, 也就没有一个大锁锁住整个事务, 影响性能. 但是写起来也会比较麻烦, 在编写每个服务时都需要多写上创建预留资源和清除预留资源的代码，　同时在数据库应该创建预留资源的字段. 如库存数据库当前的库存为９, 用户下单一个产品后需要在预留资源的字段，也就是冻结字段的计数+1, 如果有其他是请求进来时, 会通过库存-冻结的库存发现只有9个库存能被使用. 确认事务提交成功后, 就可以进行Confirm, 把库存-1,然后把冻结的数字-1. 如果有事务失败, 则进入Cancel, 只需要把冻结的字段进行-1还原即可.</p>
<p>TCC模式在使用中应当注意几个问题:</p>
<ul>
<li>幂等<br>由于TCC模式中, 每个阶段都是一个事务, 所以每个阶段都要确保幂等. 如上面的例子, 订单在每个阶段都只有一个状态, 如第一阶段是冻结, 第二个阶段是成功, 第三个阶段是失败, 在进行数据更新时, 一定要在where条件把状态限定, 这样就能达到幂等的效果了.</li>
<li>空回滚<br>理论上,在执行Confirm和Cancel时,我们都要检查是否已经执行了Try, 如果没有执行Try就执行了Cancel, 则称为空回滚.TCC服务在实现时, 应当允许一些空回滚的执行, 不要抛异常. 但由于网络问题造成先执行Cancel再执行Try的情况则是不行的, 要抛异常.</li>
</ul>
<h2 id="5-事务补偿"><a href="#5-事务补偿" class="headerlink" title="5.事务补偿"></a>5.事务补偿</h2><p>可以从上面的演进中发现, 每个模式都有一种进步, 性能越来越越高, 但是错误还是无法避免的,即使他发生的概率很小很小, 但一影响到业务就可能炸了, 特别是跟金额有关的, 这时就需要一定的补偿机制, 可以是自动, 定时或者人工.</p>
<ul>
<li><p>自动补偿–重试: 一般情况下, 对失败的数据都要进行幂等的最大努力重试, 来保证数据的最终一致性. 要确保每次重试的数据要不就只有成功的结果, 要不就只有失败的结果, 且多次同个最终状态的结果一定是一样的.同时需要确保有个良好的重试策略, 比如固定的重试次数内或时间失败了, 就不在进行重试, 而是发送报警交由人工干预, 同时每次重试的间隔最好是不一样的, 并且是逐步边长.</p>
</li>
<li><p>定时补偿: 比如金融系统中, 可能收到一笔还款成功的数据, 和还款失败的数据, 但是你没办法知道哪一笔才是有效的, 但当天内也数据提供方也无法给你提供准确的数据, 这时就需要定时任务在第二天通过提供方的数据和自己的数据进行对账, 并自动修复账单数据.</p>
</li>
<li><p>人工: 人工是事务补偿的兜底, 如果上面两种补偿失败或是没办法覆盖的情况, 都需要人工去手动处理. 所以在分布式事务中, 要做好良好的监控和日志打印, 同时也需要为每个分布式任务创建唯一Id, 并对整个分布式链路进行监控.</p>
<h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6.总结"></a>6.总结</h2><p>分布式事务是基于分布式而诞生的东西, 自然而然的, 他拥有很多分布式自带的缺陷, 所以分布式事务不可能100%的得到解决, 我们只能尽量的去增加他的成功率, 减少对性能的消耗, 并维护一定的操作手册, 分布式事务日志和监控, 在紧急时刻可以快速的以人工的方式进行分布式事务的事务补偿.<br>所以分布式很高大上, 但没啥事就上分布式, 什么体量的系统就用什么样的方案, 如果上了分布式, 则要确保链路监控和日志能十分的完善.</p>
</li>
</ul>
]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>分布式</tag>
        <tag>事务</tag>
      </tags>
  </entry>
  <entry>
    <title>Es的字段过多的坑</title>
    <url>/2020/08/03/Es%E7%9A%84%E5%AD%97%E6%AE%B5%E8%BF%87%E5%A4%9A%E7%9A%84%E5%9D%91/</url>
    <content><![CDATA[<h2 id="前记"><a href="#前记" class="headerlink" title="前记"></a>前记</h2><p>前几天,突然发现线上Es有大量的错误日志,核心日志是Limit of total fields [1000] in index.经过查明发现是同事存api server日志时他是数据带有有很多field,导致报错,解决这个问题很简单,又却很复杂,最好的解决方案是分开存储,让Es只做好Es的职责,但是对于架构又复杂了.</p>
<span id="more"></span>

<h2 id="1-发生问题"><a href="#1-发生问题" class="headerlink" title="1.发生问题"></a>1.发生问题</h2><p>前几天在准备增加Logstash的机器部署时发现旧Logstash机器上面有一些错误日志,核心的信息是<code>Limit of total fields [1000] in index</code>.很容易理解,就是本次发送的数据字段数量大于1000了.</p>
<blockquote>
<p>题外话,之所以会有这样大的数据量是因为同事那边发送的日志数据里有一个动态的json对象,而对于es来说{‘a’: {‘b’: 1, ‘c’: 2}}会认为有a.b,和a.c两个字段.在发现问题后,把含有该动态json对象的字段解析为文本就好了(不过没事还是不要存那么多数据).</p>
</blockquote>
<h2 id="2-解决问题"><a href="#2-解决问题" class="headerlink" title="2.解决问题"></a>2.解决问题</h2><p>解决这个问题也非常的简单只要针对有问题的索引处理即可,如下是把限制放宽到2000:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">curl -X PUT  -H <span class="hljs-string">&quot;Content-Type: application/json&quot;</span> -d <span class="hljs-string">&#x27;&#123;&quot;index.mapping.total_fields.limit&quot;:2000&#125;&#x27;</span> http://127.0.0.1:9200/so1n_index/_settings<br></code></pre></td></tr></table></figure>
<p>如果需要永久解决,则需要给索引增加temple,并执行以下命令:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">curl -X PUT  -H <span class="hljs-string">&quot;Content-Type: application/json&quot;</span> -d <span class="hljs-string">&#x27;&#123;&quot;template&quot;: &quot;so1n-*&quot;,&quot;settings&quot;:&#123;&quot;index.mapping.total_fields.limit&quot;:2000&#125;&#125;&#x27;</span> http://127.0.0.1:9200/_template/logstash<br></code></pre></td></tr></table></figure>
<p>好了问题就到此解决了,不过如果是简单的解决问题,那我就是在水文章了,接下来当然是迎接一个新的坑</p>
<h2 id="3-坑"><a href="#3-坑" class="headerlink" title="3.坑"></a>3.坑</h2><p>在处理完问题后的第二天发现被应用了<code>index.mapping.total_fields.limit</code>在<code>grafana</code>和自建报表平台都查不出数据了,而在<code>Kibana</code>上面使用KQL查询时,则是可以查询数据的.</p>
<p>对问题进行排查与梳理后发现,只要使用query语句查询时,就会无法查询数据,同时会有类似的报错:<code>field expansion matches too many fields, limit: 1024, got: 1889</code>.<br>一开始看到这个报错的想法是:写入的限制通过改索引的配置就可以解决了,那读取的限制也可以通过改索引来解决.然而事实上并没有想象中的容易,找了一圈都找不到可以通过改索引的配置来解决查询数据字段过多的限制.</p>
<p>最后发现有一个改法,需要更改elasticsearch.yml的一个配置<code>indices.query.bool.max_clause_count</code>,然后滚动重启集群.好处是可以马上解决,坏处是解决成本太高了,所以放弃该方法,换成另一个方法:删除字段过长的数据.</p>
<p>想着那些过长的数据都没啥用,只是为了出问题时能排查问题,那现在直接删掉就可以了.然而在删除数据后,问题并没有解决…</p>
<h2 id="4-避坑"><a href="#4-避坑" class="headerlink" title="4.避坑"></a>4.避坑</h2><p>回想一下,目前查询中只有用到es的query字符串查询方法才有问题,而使用KQL查询时,是能正常查询到数据的,那么一定是query字符串的查询机制与字段过多而引发限制.</p>
<p>先看一看出问题的query字符串查询的语法:</p>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs json">&#123;<br>    <span class="hljs-attr">&quot;size&quot;</span>: <span class="hljs-number">0</span>,<br>    <span class="hljs-attr">&quot;query&quot;</span>: &#123;<br>        <span class="hljs-attr">&quot;bool&quot;</span>: &#123;<br>            <span class="hljs-attr">&quot;filter&quot;</span>: [<br>                &#123;<br>                    <span class="hljs-attr">&quot;range&quot;</span>: &#123;<br>                        <span class="hljs-attr">&quot;@timestamp&quot;</span>: &#123;<br>                            <span class="hljs-attr">&quot;gte&quot;</span>: start_time,<br>                            <span class="hljs-attr">&quot;lte&quot;</span>: end_time,<br>                            <span class="hljs-attr">&quot;format&quot;</span>: <span class="hljs-string">&quot;epoch_millis&quot;</span><br>                        &#125;<br>                    &#125;<br>                &#125;,<br>                &#123;<br>                    <span class="hljs-attr">&quot;query_string&quot;</span>: &#123;<br>                        <span class="hljs-attr">&quot;analyze_wildcard&quot;</span>: True,<br>                        &quot;query&quot;: &#123;query str&#125;,<br>                    &#125;<br>                &#125;<br>            ]<br>        &#125;<br>    &#125;,<br>    &quot;aggs&quot;: ...<br>&#125;<br></code></pre></td></tr></table></figure>

<p>看了之后会发现还是找不到问题,那就看看<code>query_string</code>的相关<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-query-string-query.html">文档</a>吧.在文档中发现有对参数<code>default_field</code>的描述</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql">(Optional, string) <span class="hljs-keyword">Default</span> field you wish <span class="hljs-keyword">to</span> <span class="hljs-keyword">search</span> <span class="hljs-keyword">if</span> <span class="hljs-keyword">no</span> field <span class="hljs-keyword">is</span> provided <span class="hljs-keyword">in</span> the query string.<br><br>Defaults <span class="hljs-keyword">to</span> the <span class="hljs-keyword">index</span>.query.default_field <span class="hljs-keyword">index</span> setting, which has a <span class="hljs-keyword">default</span> <span class="hljs-keyword">value</span> <span class="hljs-keyword">of</span> *. The * <span class="hljs-keyword">value</span> extracts <span class="hljs-keyword">all</span> fields that are eligible <span class="hljs-keyword">for</span> term queries <span class="hljs-keyword">and</span> filters the metadata fields. <span class="hljs-keyword">All</span> extracted fields are <span class="hljs-keyword">then</span> combined <span class="hljs-keyword">to</span> build a query <span class="hljs-keyword">if</span> <span class="hljs-keyword">no</span> prefix <span class="hljs-keyword">is</span> specified.<br><br>Searching across <span class="hljs-keyword">all</span> eligible fields does <span class="hljs-keyword">not</span> <span class="hljs-keyword">include</span> nested documents. Use a nested query <span class="hljs-keyword">to</span> <span class="hljs-keyword">search</span> those documents.<br><br><span class="hljs-keyword">For</span> mappings <span class="hljs-keyword">with</span> a <span class="hljs-keyword">large</span> number <span class="hljs-keyword">of</span> fields, searching across <span class="hljs-keyword">all</span> eligible fields could be expensive.<br><br>There <span class="hljs-keyword">is</span> a <span class="hljs-keyword">limit</span> <span class="hljs-keyword">on</span> the number <span class="hljs-keyword">of</span> fields that can be queried at once. It <span class="hljs-keyword">is</span> defined <span class="hljs-keyword">by</span> the indices.query.bool.max_clause_count <span class="hljs-keyword">search</span> setting, which defaults <span class="hljs-keyword">to</span> <span class="hljs-number">1024.</span><br></code></pre></td></tr></table></figure>

<p>大概就是说如果没填<code>default_field</code>时,会默认按照*多所有字段进行匹配,如果字段数量超过<code>indices.query.bool.max_clause_count</code>的限制则会抛错.</p>
<p>由于自己的项目中有一个公有字段<code>log_level</code>,所以只要把参数body按下面更改即可:</p>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs json">&#123;<br>    <span class="hljs-attr">&quot;size&quot;</span>: <span class="hljs-number">0</span>,<br>    <span class="hljs-attr">&quot;query&quot;</span>: &#123;<br>        <span class="hljs-attr">&quot;bool&quot;</span>: &#123;<br>            <span class="hljs-attr">&quot;filter&quot;</span>: [<br>                &#123;<br>                    <span class="hljs-attr">&quot;range&quot;</span>: &#123;<br>                        <span class="hljs-attr">&quot;@timestamp&quot;</span>: &#123;<br>                            <span class="hljs-attr">&quot;gte&quot;</span>: start_time,<br>                            <span class="hljs-attr">&quot;lte&quot;</span>: end_time,<br>                            <span class="hljs-attr">&quot;format&quot;</span>: <span class="hljs-string">&quot;epoch_millis&quot;</span><br>                        &#125;<br>                    &#125;<br>                &#125;,<br>                &#123;<br>                    <span class="hljs-attr">&quot;query_string&quot;</span>: &#123;<br>                        <span class="hljs-attr">&quot;analyze_wildcard&quot;</span>: True,<br>                        &quot;query&quot;: &#123;query str&#125;,<br>                        &quot;default_field&quot;: &quot;log_level&quot; &lt;-- changed<br>                    &#125;<br>                &#125;<br>            ]<br>        &#125;<br>    &#125;,<br>    &quot;aggs&quot;: ...<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如果由于设计的问题,导致每个查询的字段相差比较大,没有公有字段,那么还是更改限制并重启吧.</p>
<h2 id="5-解决方案"><a href="#5-解决方案" class="headerlink" title="5.解决方案"></a>5.解决方案</h2><p>上面只是从写入和读取层解决问题的,但需要注意的是,我们不应该把大量非正常使用的数据全塞入Es.首先从ES的查询原理来看看为什么不应该这样处理?.</p>
<p>Es在查询数据时,会把命中查询的数据全部都拉到内存里面,并根据语句进行计算与统计.当数据的字段变多时,对应的数据量就更多了,Es就需要更多的内存来存放数据,如果此时机器不够(一般不能配置机器内存大于32g),旧的数据就会被清掉,下次查询时又得重新从硬盘里拉取符合条件的数据.<br>简单来说Es读取热数据(内存数据)的速度远远大于读取冷数据(硬盘数据)的速度,如果单个数据量越大或者内存不够大,那么会影响到Es的查询速度和效率,除此之外,Es数据的每个字段都是索引,而这些会占用了大量的空间.</p>
<p>了解完上面那些,我们就可以知道我们不应该把所有数据都存在于Es,特别是数据量比较多的时候.我们应该对数据进行拆分,把每个数据存到他应该呆的地方.我们可以按照上面的说法来拆分两大类数据,一类是<code>索引型数据</code>,也就是存在Es中的可以被快速查询到的数据;一类型是<code>详情型数据</code>,这类数据类似于商品信息数据,数据量很大,记录了商品的说明等等,可以不用存入Es中被索引,可以存在Mysql或者Hbase之中.除此之外,还有一种介于<code>索引性数据</code>和<code>详情型数据</code>的<code>辅助型数据</code>,他可以被Es做聚合运算或者充当辅助查询,这类型数据必须存在与Es之中,也可以存在于数据库之中,如果没办法确定就先放Es里吧.</p>
<p>做好数据类型拆分后,我们就需要给架构添加复杂性了…<br>如图,我们需要在后端服务与Es之间添加一个中间件,这里中间件负责的是在写数据时把数据进行拆分,把<code>索引性数据</code>和<code>辅助型数据</code>发送到Es,并拿到写入成功的id与<code>详情型数据</code>一起写入数据库.而在查的时候需要把查询语句转发到Es进行查询,并拿到查询成功的id从数据库拉取数据并返回给用户.<br>![Untitled Diagram](/home/so1n/Downloads/Untitled Diagram.png)</p>
<p>虽然描述起来简单,但是实现还是比较复杂的,比如发给Es的数据需要内部保存,每隔一段时间bluk一次,同时要防止数据保存期间丢失.还有中间件接受到数据时该如何拆分数据,怎么制订方案等都是比较复杂同时又得结合自己本身项目来制订.</p>
]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>ElasticSearch</tag>
      </tags>
  </entry>
  <entry>
    <title>Python的TypeHints</title>
    <url>/2020/06/03/Python%E7%9A%84TypeHints/</url>
    <content><![CDATA[<h2 id="前记"><a href="#前记" class="headerlink" title="前记"></a>前记</h2><p>现在,已经不是那个坚信动态语言+好用的工具就能写工程项目的时代,新出的语言都是走静态语言的路线,动态语言也都开始引入类型增强,解决自己的不足,而Python的也有自己的类型增强方案–TypeHints.</p>
<p>一开始用着Python写起代码非常爽,但是在大项目且多人合作时,会发现重构代码非常艰难或者不敢去修改历史代码.在引入TypeHints后,通过IDE的增强或者mypy等检查,能使我们重构代码方便,且让代码健壮.(也许有朝一日还能做到静态编译,提升性能- -…)</p>
<span id="more"></span>

<h2 id="1-PEP的历史进程"><a href="#1-PEP的历史进程" class="headerlink" title="1.PEP的历史进程"></a>1.PEP的历史进程</h2><p>Python作为一个非常灵活的动态语言,也不是一下子就拥有TypeHints的,而是通过PEP 3107, PEP 483, PEP  484,PEP 526,PEP 544,PEP 586,PEP 589, PEP 591,慢慢的使TypeHint变得完整</p>
<h3 id="1-1-PEP-3107-TypeHints的主要依赖"><a href="#1-1-PEP-3107-TypeHints的主要依赖" class="headerlink" title="1.1.PEP 3107 TypeHints的主要依赖"></a>1.1.PEP 3107 TypeHints的主要依赖</h3><p><a href="https://www.python.org/dev/peps/pep-3107/">PEP 3107</a>,在06年就已经提出来了,是目前TypeHints的主要依赖,然,而此方案一开始跟TypeHints并没有什么关系,官方对于这个提案处于放养阶段,只是让函数拥有了注解功能:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python">In [<span class="hljs-number">1</span>]: <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test</span>(<span class="hljs-params">bar: <span class="hljs-built_in">str</span>, foo: <span class="hljs-built_in">int</span></span>) -&gt; int:</span> <br>   ...:     <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>   <br>In [<span class="hljs-number">2</span>]: test.__annotations__                                             <br>Out[<span class="hljs-number">2</span>]: &#123;<span class="hljs-string">&#x27;bar&#x27;</span>: <span class="hljs-built_in">str</span>, <span class="hljs-string">&#x27;foo&#x27;</span>: <span class="hljs-built_in">int</span>, <span class="hljs-string">&#x27;return&#x27;</span>: <span class="hljs-built_in">int</span>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="1-2-PEP-483"><a href="#1-2-PEP-483" class="headerlink" title="1.2.PEP 483"></a>1.2.PEP 483</h3><p>PEP 483并没有去讲怎么实现TypeHints,而是简明扼要的写清楚 Python 的类型系统建设方向、边界.理清Type是语法分析的概念,<code>class</code>是运行时概念,<code>class</code>都是一个type,但type不一定是class.<br>同时PEP 483还介绍了一些常用的基础类型Any, Callabel,Optional, Tuple等,同时还支持泛型,也支持使用注释标记类型,防止被循环引用</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python">In [<span class="hljs-number">4</span>]: <span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> TypeVar                                       <br>In [<span class="hljs-number">5</span>]: S = TypeVar(<span class="hljs-string">&#x27;S&#x27;</span>, <span class="hljs-built_in">str</span>, <span class="hljs-built_in">bytes</span>)                                     <br>In [<span class="hljs-number">6</span>]: <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test</span>(<span class="hljs-params">a: S, b: S</span>) -&gt; S:</span> <br>   ...:     <span class="hljs-keyword">return</span> a <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(a) &gt; <span class="hljs-built_in">len</span>(b) <span class="hljs-keyword">else</span> b<br><br><span class="hljs-comment"># 支持注释标记类型和嵌套类型(以下示例要PEP526后才可以使用)</span><br>In [<span class="hljs-number">7</span>]: <span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> List                                           <br>In [<span class="hljs-number">8</span>]: a = [<span class="hljs-string">&#x27;1&#x27;</span>]  <span class="hljs-comment"># type: List[str]   </span><br></code></pre></td></tr></table></figure>
<h3 id="1-3-PEP484"><a href="#1-3-PEP484" class="headerlink" title="1.3.PEP484"></a>1.3.PEP484</h3><p>PEP 484是TypeHints的核心,首先它确定了Python仍将是一种动态类型语言,并不强制Python成为静态语言,同时讲解了TypeHints的几个新特性:</p>
<ul>
<li> 为已经存在的库添加类型描述文件(.pyi),通过在同名的.pyi文件编写类或函数的type hint后,即使原文件没有编写Type Hint相关代码, 也可以被mypy或者其他工具识别.这是一个不改变原有代码就可以获得Type Hint功能的手段.</li>
<li> 允许使用 @overload 进行类型重载,但是只是用于代码检查时,实际上只有未被overload装饰的函数才能真正的被使用到</li>
<li>使用typing.TYPE_CHECKING,让一些库只有在运行检查时才引入  <figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> typing<br><br><span class="hljs-keyword">if</span> typing.TYPE_CHECKING:<br>    <span class="hljs-keyword">import</span> expensive_mod<br></code></pre></td></tr></table></figure>
<h3 id="1-4-PEP-526"><a href="#1-4-PEP-526" class="headerlink" title="1.4.PEP 526"></a>1.4.PEP 526</h3>上面一直在说的都是函数,而在PEP526后,变量和类属性都可以支持TypeHints了, 在PEP526后可以如下使用:<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> List<br>test_int_list: List[<span class="hljs-built_in">int</span>]<br><br>print(__annotations__)<br>&#123;<span class="hljs-string">&#x27;test_int_list&#x27;</span>: typing.List[<span class="hljs-built_in">int</span>]&#125;<br></code></pre></td></tr></table></figure>
需要注意的是,上面的代码实际上并未创建变量,而是把变量和类型存在全局的<code>__annotations__</code>中, 如果是类属性,<br>那么变量则会存在类的<code>__annotations__</code>中.</li>
</ul>
<h3 id="1-5-PEP544"><a href="#1-5-PEP544" class="headerlink" title="1.5.PEP544"></a>1.5.PEP544</h3><p>544中主要说的是通过静态鸭子类型,Python自动得知类的Type Hint类型.我们都知道Python的动态类型是动态鸭子类型,当觉得一个类看起来像鸭子,那就认为他是鸭子,PEP544也是这样,只不过把确定的结果当成TypeHint反馈给代码检查工具.如官网给的例子:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> Iterator, Iterable<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bucket</span>:</span><br>    ...<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__len__</span>(<span class="hljs-params">self</span>) -&gt; int:</span> ...<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__iter__</span>(<span class="hljs-params">self</span>) -&gt; Iterator[int]:</span> ...<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">collect</span>(<span class="hljs-params">items: Iterable[<span class="hljs-built_in">int</span>]</span>) -&gt; int:</span> ...<br>result: <span class="hljs-built_in">int</span> = collect(Bucket())  <span class="hljs-comment"># Passes type check</span><br></code></pre></td></tr></table></figure>
<p>代码中定义了 Bucket 这种类型，并且提供了两个类成员。这两个类成员刚好是 Interator 的定义。 那么在实际使用中，就可以使用 Bucket 替换 Iterable。</p>
<h3 id="1-6-PEP563"><a href="#1-6-PEP563" class="headerlink" title="1.6.PEP563"></a>1.6.PEP563</h3><p>在编写树节点的时候,如果我们使用TypeHints,那我们就会碰到循环依赖的问题,而PEP563就是为了解决这个问题的,在使用PEP563后我们可以如下通过使用<code>&#39;变量&#39;</code>来解决:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> Optional<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>:</span><br>    left: Optional[<span class="hljs-string">&quot;Node&quot;</span>]<br>    right: Optional[<span class="hljs-string">&quot;Node&quot;</span>]<br></code></pre></td></tr></table></figure>
<h3 id="1-7-Python3-8-PEP-对TypeHints的增强"><a href="#1-7-Python3-8-PEP-对TypeHints的增强" class="headerlink" title="1.7.Python3.8 PEP 对TypeHints的增强"></a>1.7.Python3.8 PEP 对TypeHints的增强</h3><p>在Python3.8中,多了几个PEP,不过比较简单,只是对TypeHint的一个完善</p>
<ul>
<li><p>PEP586非常简单,只是支持以字面量来作为类型使用, 但一般不推荐这样用:</p>
  <figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python">Literal[<span class="hljs-number">26</span>]<br>Literal[<span class="hljs-number">0x1A</span>]  <span class="hljs-comment"># Exactly equivalent to Literal[26]</span><br>Literal[-<span class="hljs-number">4</span>]<br>Literal[<span class="hljs-string">&quot;hello world&quot;</span>]<br>Literal[<span class="hljs-string">b&quot;hello world&quot;</span>]<br>Literal[<span class="hljs-string">u&quot;hello world&quot;</span>]<br>Literal[<span class="hljs-literal">True</span>]<br>Literal[Color.RED]  <span class="hljs-comment"># Assuming Color is some enum</span><br>Literal[<span class="hljs-literal">None</span>]<br></code></pre></td></tr></table></figure></li>
<li><p>PEP589则支持对每个dict的key进行类型标注</p>
  <figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> TypedDict<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Movie</span>(<span class="hljs-params">TypedDict</span>):</span><br>    name: <span class="hljs-built_in">str</span><br>    year: <span class="hljs-built_in">int</span><br>    <br>movie: Movie = &#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;Blade Runner&#x27;</span>, <span class="hljs-string">&#x27;year&#x27;</span>: <span class="hljs-number">1982</span>&#125;<br><span class="hljs-comment"># 没有PEP589之前只能如下编写, 同时不能对每个key进行检查...</span><br><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> Dict, Union<br>move_dict: Dict[<span class="hljs-built_in">str</span>, Union[<span class="hljs-built_in">str</span>, <span class="hljs-built_in">int</span>]]<br></code></pre></td></tr></table></figure>
</li>
<li><p>PEP591增加 final / Final, final是一个装饰器,用于声明一个类不能被更改或者继承,而Final则是声明变量不可被修改</p>
</li>
</ul>
<h2 id="2-一些使用小技巧"><a href="#2-一些使用小技巧" class="headerlink" title="2.一些使用小技巧"></a>2.一些使用小技巧</h2><p>常规的TypeHints使用就不多说了,这里只说一些平常少用又好用的…</p>
<h3 id="2-1别名"><a href="#2-1别名" class="headerlink" title="2.1别名"></a>2.1别名</h3><p>在项目中,经常会有一些变量类型非常复杂,且在多处地方都会使用到,纳闷利用别名,且把别名放在项目下的types.py是个不错的注意.如下是声明一个<code>DEMO_TYPE</code>的别名, 别名不需要写TypeHInts.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> Dict, List<br><br>DEMO_TYPE = Dict[<span class="hljs-built_in">str</span>, List[<span class="hljs-built_in">int</span>]]<br><br>demo_container: DEMO_TYPE = &#123;<span class="hljs-string">&quot;bar&quot;</span>: [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]&#125;<br></code></pre></td></tr></table></figure>
<h3 id="2-2TypeVar的使用"><a href="#2-2TypeVar的使用" class="headerlink" title="2.2TypeVar的使用"></a>2.2TypeVar的使用</h3><p><code>TypeVar</code>跟<code>Union</code>的使用很像,区别是<code>Union</code>返回值的类型与输入的值是可以不一样的,而<code>TypeVar</code>返回值类型与输入的值类型必须一样的.当前<code>Generic</code>也是跟<code>TypeVar</code>一样要求返回值的类型与输入的值类型必须是一样的.<br><code>Union</code>例子:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> Union<br><br>DEMO_TYPE = Union[<span class="hljs-built_in">int</span>, <span class="hljs-built_in">str</span>]<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">demo</span>(<span class="hljs-params">a: DEMO_TYPE, b: DEMO_TYPE</span>) -&gt; DEMO_TYPE:</span><br>    <span class="hljs-keyword">pass</span><br><br><br>demo(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;1&#x27;</span>)    <span class="hljs-comment"># ok</span><br>demo(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)      <span class="hljs-comment"># ok</span><br>demo(<span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>)  <span class="hljs-comment"># ok</span><br></code></pre></td></tr></table></figure>
<p><code>TypeVar</code>例子:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> TypeVar<br><br>DEMO_TYPE = TypeVar(<span class="hljs-string">&#x27;DEMO_TYPE&#x27;</span>, <span class="hljs-built_in">int</span>, <span class="hljs-built_in">str</span>)<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">demo</span>(<span class="hljs-params">a: DEMO_TYPE, b: DEMO_TYPE</span>) -&gt; DEMO_TYPE:</span><br>    <span class="hljs-keyword">pass</span><br><br><br>demo(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;1&#x27;</span>)    <span class="hljs-comment"># error</span><br>demo(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)      <span class="hljs-comment"># ok</span><br>demo(<span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>)  <span class="hljs-comment"># ok</span><br></code></pre></td></tr></table></figure>
<p>在类中除了使用<code>TypeVar</code>外,也可以使用overload, 如:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-meta">@overload</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">demo</span>(<span class="hljs-params">value: <span class="hljs-built_in">int</span></span>) -&gt; int:</span> <span class="hljs-keyword">pass</span><br><br><span class="hljs-meta">@overload</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">demo</span>(<span class="hljs-params">value: <span class="hljs-built_in">str</span></span>) -&gt; int:</span> <span class="hljs-keyword">pass</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">demo</span>(<span class="hljs-params">value</span>):</span><br>    ...<br></code></pre></td></tr></table></figure>
<h3 id="2-3防止循环引用"><a href="#2-3防止循环引用" class="headerlink" title="2.3防止循环引用"></a>2.3防止循环引用</h3><p>上面提到了在写树节点时会遇到循环引用的情况,实际上Python还有其他解决方案:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> Optional<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>:</span><br>    left=<span class="hljs-literal">None</span>  <span class="hljs-comment"># tpye: Optional[&quot;Node&quot;]</span><br>    right=<span class="hljs-literal">None</span>  <span class="hljs-comment"># type: Optional[&quot;Node&quot;]</span><br></code></pre></td></tr></table></figure>
<h3 id="2-4协变与裂变"><a href="#2-4协变与裂变" class="headerlink" title="2.4协变与裂变"></a>2.4协变与裂变</h3><p>协变: 让一个比较泛的接口可以接受一个更加具体的接口作为参数或者返回值.如把猫的类赋值给英短蓝白猫的类.<br>裂变: 让一个比较具体的接口的可以接受一个更加泛的接口作为参数或者返回值.如把英短蓝白猫的类赋值给猫的类</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> TypeVar, Generic<br><br><br>DEMO_TYPE = TypeVar(<span class="hljs-string">&quot;DEMO_TYPE&quot;</span>,  covariant=<span class="hljs-literal">True</span>)<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyList</span>(<span class="hljs-params">Generic[DEMO_TYPE]</span>):</span> <span class="hljs-keyword">pass</span><br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span>(<span class="hljs-params">MyList</span>):</span> <span class="hljs-keyword">pass</span><br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BritishShorthair</span>(<span class="hljs-params">Cat</span>):</span> <span class="hljs-keyword">pass</span><br><br><br>cat: Cat<br>british_shorthair: BritishShorthair = BritishShorthair()<br>cat = british_shorthair<br></code></pre></td></tr></table></figure>
<h3 id="2-5运行时类型检查"><a href="#2-5运行时类型检查" class="headerlink" title="2.5运行时类型检查"></a>2.5运行时类型检查</h3><p>通过<code>@runtime_checkable</code>装饰器和<code>Protoclol</code>可以运行时检查</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> runtime_checkable, Protocol<br><br><br><span class="hljs-meta">@runtime_checkable</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span>(<span class="hljs-params">Protocol</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">close</span>(<span class="hljs-params">self</span>):</span><br>        ...<br>    <br><span class="hljs-keyword">assert</span> <span class="hljs-built_in">isinstance</span>(<span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;...&#x27;</span>), Demo)<br></code></pre></td></tr></table></figure>

<h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3.总结"></a>3.总结</h2><p>在Python中,TypeHints能帮我们写的代码更加健全,同时借助IDE,我们也可以非常快速的编写或者更改代码,减少我们一些开发时间.<br>Typehints在编写代码时,只能被IDE检查进行提示,或者被检查工具用于代码检查,在实际代码中并不会生效,但是由于Python把TypeHints的一些变量存放在相关的<code>__annotations__</code>中,所以我们还是可以在运行中调用<code>__annotations__</code>提取TypeHints并对参数进行类型判断或者转换,这在web中非常有用,目前有个叫<code>Pydantic</code>的库就是专门处理这类应用的,非常不错.</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>语法</tag>
      </tags>
  </entry>
  <entry>
    <title>由内存溢出的思考:如何监控内存?</title>
    <url>/2020/05/28/%E5%86%85%E5%AD%98%E7%BB%9F%E8%AE%A1/</url>
    <content><![CDATA[<h2 id="前记"><a href="#前记" class="headerlink" title="前记"></a>前记</h2><p>最近在做监控系统,发现Linux的内存监控比较困难,主要是指标太多,不知道那些指标才是真正需要的,比如一开始我们就监控free命令输出的free,然而由于页缓存的原因,有些数据是不对的.恰好今天刚刚遇到系统的一个内存看似不准的问题,在调查问题时同时了解了Linux的内存设计</p>
<span id="more"></span>

<h2 id="1-一次”内存报警异常”"><a href="#1-一次”内存报警异常”" class="headerlink" title="1.一次”内存报警异常”"></a>1.一次”内存报警异常”</h2><h3 id="1-1-问题"><a href="#1-1-问题" class="headerlink" title="1.1.问题"></a>1.1.问题</h3><p>最近监控一直在报某些机器内存异常,内存超过了90%的使用,登上去机器用<code>free -h</code>命令查看发现user部分确实很多,但通过<code>ps -aux | sort -l 4</code>发现所有进程加起来的内存占用都没有user的10分之一,究竟是谁在吃内存不得而知.</p>
<h3 id="1-2-排查问题机器"><a href="#1-2-排查问题机器" class="headerlink" title="1.2.排查问题机器"></a>1.2.排查问题机器</h3><h4 id="1-2-1-top"><a href="#1-2-1-top" class="headerlink" title="1.2.1.top"></a>1.2.1.top</h4><p>从top命令可以看出,目前最占用内存的进程只有supervisord,只占用了0.9%的内存,即使所有进程占用内存加起来,也占用到10-20%左右</p>
<figure class="highlight tap"><table><tr><td class="code"><pre><code class="hljs tap">  PID USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND                                                                                                          <br><span class="hljs-number"> 1230 </span>root     <span class="hljs-number"> 20 </span> <span class="hljs-number"> 0 </span> <span class="hljs-number"> 30040 </span><span class="hljs-number"> 18192 </span> <span class="hljs-number"> 1764 </span>S   0.0   0.9  73:32.80 supervisord                                                                                                      <br>27835 nobody   <span class="hljs-number"> 20 </span> <span class="hljs-number"> 0 </span> <span class="hljs-number"> 21248 </span><span class="hljs-number"> 11552 </span> <span class="hljs-number"> 1900 </span>S   3.3   0.6  18:15.34 so1n-server                                                                                                        <br>16045 nobody   <span class="hljs-number"> 20 </span> <span class="hljs-number"> 0 </span> <span class="hljs-number"> 18456 </span> <span class="hljs-number"> 8240 </span> <span class="hljs-number"> 1380 </span>S   1.0   0.4   3:45.40 so1n-server                                                                                                        <br>22880 root     <span class="hljs-number"> 20 </span> <span class="hljs-number"> 0 </span> <span class="hljs-number"> 16720 </span> <span class="hljs-number"> 8108 </span> <span class="hljs-number"> 6836 </span>S   0.0   0.4   0:01.83 sshd                                                                                                             <br> <span class="hljs-number"> 209 </span>root     <span class="hljs-number"> 20 </span> <span class="hljs-number"> 0 </span> <span class="hljs-number"> 44292 </span> <span class="hljs-number"> 8056 </span> <span class="hljs-number"> 4212 </span>S   0.0   0.4   5:36.02 systemd-journal  <br>.....<br></code></pre></td></tr></table></figure>
<h4 id="1-2-2-free"><a href="#1-2-2-free" class="headerlink" title="1.2.2. free"></a>1.2.2. free</h4><p>通过<code>free -h</code>命令可以看到 共2g内存的小机器,used已经使用了1.6g了 ,占用了80%了</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache">              <span class="hljs-attribute">total</span>        used        free      shared  buff/cache   available<br><span class="hljs-attribute">Mem</span>:          <span class="hljs-number">2</span>.<span class="hljs-number">0</span>Gi       <span class="hljs-number">1</span>.<span class="hljs-number">6</span>Gi       <span class="hljs-number">297</span>Mi        <span class="hljs-number">20</span>Mi        <span class="hljs-number">87</span>Mi       <span class="hljs-number">257</span>Mi<br><span class="hljs-attribute">Swap</span>:            <span class="hljs-number">0</span>B          <span class="hljs-number">0</span>B          <span class="hljs-number">0</span>B<br></code></pre></td></tr></table></figure>
<p>为了了解used的主要组成,先通过<code>man free</code>查看free各个字段的说明</p>
<figure class="highlight tcl"><table><tr><td class="code"><pre><code class="hljs tcl">DESCRIPTION<br>        ......<br>       total  Total installed <span class="hljs-keyword">memory</span> (MemTotal and SwapTotal in /<span class="hljs-keyword">proc</span>/meminfo)<br><span class="hljs-title">       used</span> <span class="hljs-title">  Used</span> memory (calculated<span class="hljs-title"> as</span> total -<span class="hljs-title"> free</span> -<span class="hljs-title"> buffers</span> -<span class="hljs-title"> cache)</span><br><span class="hljs-title"></span> <span class="hljs-title">      free</span> <span class="hljs-title">  Unused</span> memory (MemFree<span class="hljs-title"> and</span> SwapFree<span class="hljs-title"> in</span> /<span class="hljs-keyword">proc</span>/meminfo)<br><span class="hljs-title">       shared</span> Memory<span class="hljs-title"> used</span> (mostly)<span class="hljs-title"> by</span> tmpfs (Shmem<span class="hljs-title"> in</span> /<span class="hljs-keyword">proc</span>/meminfo)<br><span class="hljs-title">       buffers</span><br><span class="hljs-title"></span> <span class="hljs-title">             Memory</span> used<span class="hljs-title"> by</span> kernel<span class="hljs-title"> buffers</span> (Buffers<span class="hljs-title"> in</span> /<span class="hljs-keyword">proc</span>/meminfo)<br><span class="hljs-title">       cache</span> <span class="hljs-title"> Memory</span> used<span class="hljs-title"> by</span> the<span class="hljs-title"> page</span> cache<span class="hljs-title"> and</span> slabs (Cached<span class="hljs-title"> and</span> SReclaimable<span class="hljs-title"> in</span> /<span class="hljs-keyword">proc</span>/meminfo)<br><span class="hljs-title">       buff/cache</span><br><span class="hljs-title"></span> <span class="hljs-title">             Sum</span> of<span class="hljs-title"> buffers</span> and<span class="hljs-title"> cache</span><br><span class="hljs-title"></span> <span class="hljs-title">      available</span><br><span class="hljs-title"></span> <span class="hljs-title">             Estimation</span> of<span class="hljs-title"> how</span> much<span class="hljs-title"> memory</span> is<span class="hljs-title"> available</span> for<span class="hljs-title"> starting</span> new<span class="hljs-title"> applications,</span> without<span class="hljs-title"> swapping.</span> Unlike<span class="hljs-title"> the</span> data<span class="hljs-title"> provided</span> by<span class="hljs-title"> the</span> cache<span class="hljs-title"> or</span> free<span class="hljs-title"> fields,</span> this<span class="hljs-title"> field</span> <span class="hljs-title"> takes</span><br><span class="hljs-title"></span> <span class="hljs-title">             into</span> <span class="hljs-title"> account</span> <span class="hljs-title"> page</span> <span class="hljs-title"> cache</span> <span class="hljs-title"> and</span> also<span class="hljs-title"> that</span> not<span class="hljs-title"> all</span> reclaimable<span class="hljs-title"> memory</span> slabs<span class="hljs-title"> will</span> be<span class="hljs-title"> reclaimed</span> due<span class="hljs-title"> to</span> items<span class="hljs-title"> being</span> in<span class="hljs-title"> use</span> (MemAvailable<span class="hljs-title"> in</span> /<span class="hljs-keyword">proc</span>/meminfo,<span class="hljs-title"> available</span> on<br><span class="hljs-title">              kernels</span> 3.14,<span class="hljs-title"> emulated</span> on<span class="hljs-title"> kernels</span> 2.6.27+,<span class="hljs-title"> otherwise</span> the<span class="hljs-title"> same</span> as<span class="hljs-title"> free)</span><br><span class="hljs-title"></span><br></code></pre></td></tr></table></figure>
<p>可以看出used是由total -free - buffes - cache计算得出,而cache又包括了Cached和SReclaimable,,所以used=total -free -buffers - Cached - SReclaimable.</p>
<h4 id="1-2-3-cat-proc-meminfo"><a href="#1-2-3-cat-proc-meminfo" class="headerlink" title="1.2.3. cat /proc/meminfo"></a>1.2.3. cat /proc/meminfo</h4><p>了解了free中used的计算后我们就可以自己根据/proc/meminfo查看有什么异常值,除去了计算used的free,buffers,Cached,SReclaimable后发现有一个叫SUnreclaim的值非常可疑,这个值表明的是存在于内核中的不可回收数据结构的大小, 存在与内核的数据结构有很多,比如创建一个TCP时,内核里面就会创建一个存TCP相关数据的数据结构,一般来说这个值的比较低的,而且是要低于SReclaimable(也是存在于内核中的数据结构的大小,不过是可回收的)的,所以需要进入Sunreclaim内部,查看是什么数据结构占用了比较多的内存</p>
<figure class="highlight tcl"><table><tr><td class="code"><pre><code class="hljs tcl">cat /<span class="hljs-keyword">proc</span>/meminfo <br>MemTotal:        2045852<span class="hljs-title"> kB</span><br><span class="hljs-title">MemFree:</span>          296104<span class="hljs-title"> kB</span><br><span class="hljs-title">MemAvailable:</span>     255252<span class="hljs-title"> kB</span><br><span class="hljs-title">Buffers:</span>            9348<span class="hljs-title"> kB</span><br><span class="hljs-title">Cached:</span>            58672<span class="hljs-title"> kB</span><br><span class="hljs-title">SwapCached:</span>            0<span class="hljs-title"> kB</span><br><span class="hljs-title">Active:</span>           118576<span class="hljs-title"> kB</span><br><span class="hljs-title">Inactive:</span>          29460<span class="hljs-title"> kB</span><br><span class="hljs-title">Active(anon):</span>      80200<span class="hljs-title"> kB</span><br><span class="hljs-title">Inactive(anon):</span>    20792<span class="hljs-title"> kB</span><br><span class="hljs-title">Active(file):</span>      38376<span class="hljs-title"> kB</span><br><span class="hljs-title">Inactive(file):</span>     8668<span class="hljs-title"> kB</span><br><span class="hljs-title">Unevictable:</span>           0<span class="hljs-title"> kB</span><br><span class="hljs-title">Mlocked:</span>               0<span class="hljs-title"> kB</span><br><span class="hljs-title">SwapTotal:</span>             0<span class="hljs-title"> kB</span><br><span class="hljs-title">SwapFree:</span>              0<span class="hljs-title"> kB</span><br><span class="hljs-title">Dirty:</span>                36<span class="hljs-title"> kB</span><br><span class="hljs-title">Writeback:</span>             0<span class="hljs-title"> kB</span><br><span class="hljs-title">AnonPages:</span>         80080<span class="hljs-title"> kB</span><br><span class="hljs-title">Mapped:</span>            18632<span class="hljs-title"> kB</span><br><span class="hljs-title">Shmem:</span>             20956<span class="hljs-title"> kB</span><br><span class="hljs-title">Slab:</span>             717036<span class="hljs-title"> kB</span><br><span class="hljs-title">SReclaimable:</span>      22040<span class="hljs-title"> kB</span><br><span class="hljs-title">SUnreclaim:</span>       694996<span class="hljs-title"> kB</span><br><span class="hljs-title">KernelStack:</span>        1308<span class="hljs-title"> kB</span><br><span class="hljs-title">PageTables:</span>         1880<span class="hljs-title"> kB</span><br><span class="hljs-title">NFS_Unstable:</span>          0<span class="hljs-title"> kB</span><br><span class="hljs-title">Bounce:</span>                0<span class="hljs-title"> kB</span><br><span class="hljs-title">WritebackTmp:</span>          0<span class="hljs-title"> kB</span><br><span class="hljs-title">CommitLimit:</span>     1022924<span class="hljs-title"> kB</span><br><span class="hljs-title">Committed_AS:</span>     210184<span class="hljs-title"> kB</span><br><span class="hljs-title">VmallocTotal:</span>   34359738367<span class="hljs-title"> kB</span><br><span class="hljs-title">VmallocUsed:</span>           0<span class="hljs-title"> kB</span><br><span class="hljs-title">VmallocChunk:</span>          0<span class="hljs-title"> kB</span><br><span class="hljs-title">Percpu:</span>              452<span class="hljs-title"> kB</span><br><span class="hljs-title">AnonHugePages:</span>     18432<span class="hljs-title"> kB</span><br><span class="hljs-title">ShmemHugePages:</span>        0<span class="hljs-title"> kB</span><br><span class="hljs-title">ShmemPmdMapped:</span>        0<span class="hljs-title"> kB</span><br><span class="hljs-title">HugePages_Total:</span>       0<br>HugePages_Free:        0<br>HugePages_Rsvd:        0<br>HugePages_Surp:        0<br>Hugepagesize:       2048<span class="hljs-title"> kB</span><br><span class="hljs-title">Hugetlb:</span>               0<span class="hljs-title"> kB</span><br><span class="hljs-title">DirectMap4k:</span>     1380324<span class="hljs-title"> kB</span><br><span class="hljs-title">DirectMap2M:</span>      716800<span class="hljs-title"> kB</span><br><span class="hljs-title">DirectMap1G:</span>           0<span class="hljs-title"> kB</span><br></code></pre></td></tr></table></figure>
<h4 id="1-2-4-slabtop"><a href="#1-2-4-slabtop" class="headerlink" title="1.2.4. slabtop"></a>1.2.4. slabtop</h4><p>slabtop可以查看slab(存放于内核的数据结构)的使用情况,可以发现有一个叫TCP的数据结构占用了600多M的内存,根据往常的使用经验,一个正常使用的TCP链接大概占4kb左右,这样算下来是这台机器打开了161392个TCP链接,显然是不对的(即使64kb, 换算下来也要1w个请求, 当前的请求量根本没那么多).所以需要对该问题进行修复,不过由于该问题是更改TCP参数造成的,跟主题不一样,所以关于内存异常的问题的调查就到这.</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">OBJS</span> ACTIVE  USE OBJ SIZE  SLABS OBJ/SLAB CACHE SIZE NAME                   <br><span class="hljs-attribute">307968</span> <span class="hljs-number">307298</span>  <span class="hljs-number">99</span>%    <span class="hljs-number">0</span>.<span class="hljs-number">02</span>K   <span class="hljs-number">1203</span>      <span class="hljs-number">256</span>      <span class="hljs-number">4812</span>K kmalloc-<span class="hljs-number">16</span><br><span class="hljs-attribute">302610</span> <span class="hljs-number">301633</span>  <span class="hljs-number">99</span>%    <span class="hljs-number">2</span>.<span class="hljs-number">12</span>K  <span class="hljs-number">20174</span>       <span class="hljs-number">15</span>    <span class="hljs-number">645568</span>K TCP<br> <span class="hljs-attribute">99519</span>  <span class="hljs-number">99519</span> <span class="hljs-number">100</span>%    <span class="hljs-number">0</span>.<span class="hljs-number">19</span>K   <span class="hljs-number">4739</span>       <span class="hljs-number">21</span>     <span class="hljs-number">18956</span>K kmalloc-<span class="hljs-number">192</span><br> <span class="hljs-attribute">28056</span>  <span class="hljs-number">21510</span>  <span class="hljs-number">76</span>%    <span class="hljs-number">0</span>.<span class="hljs-number">19</span>K   <span class="hljs-number">1336</span>       <span class="hljs-number">21</span>      <span class="hljs-number">5344</span>K dentry<br> <span class="hljs-attribute">18944</span>  <span class="hljs-number">16993</span>  <span class="hljs-number">89</span>%    <span class="hljs-number">0</span>.<span class="hljs-number">03</span>K    <span class="hljs-number">148</span>      <span class="hljs-number">128</span>       <span class="hljs-number">592</span>K kmalloc-<span class="hljs-number">32</span><br> <span class="hljs-attribute">15390</span>  <span class="hljs-number">15390</span> <span class="hljs-number">100</span>%    <span class="hljs-number">0</span>.<span class="hljs-number">13</span>K    <span class="hljs-number">513</span>       <span class="hljs-number">30</span>      <span class="hljs-number">2052</span>K kernfs_node_cache<br> <span class="hljs-attribute">13824</span>  <span class="hljs-number">13038</span>  <span class="hljs-number">94</span>%    <span class="hljs-number">0</span>.<span class="hljs-number">06</span>K    <span class="hljs-number">216</span>       <span class="hljs-number">64</span>       <span class="hljs-number">864</span>K anon_vma_chain<br> <span class="hljs-attribute">10816</span>   <span class="hljs-number">8193</span>  <span class="hljs-number">75</span>%    <span class="hljs-number">0</span>.<span class="hljs-number">06</span>K    <span class="hljs-number">169</span>       <span class="hljs-number">64</span>       <span class="hljs-number">676</span>K kmalloc-<span class="hljs-number">64</span><br>  <span class="hljs-attribute">9477</span>   <span class="hljs-number">9180</span>  <span class="hljs-number">96</span>%    <span class="hljs-number">0</span>.<span class="hljs-number">59</span>K    <span class="hljs-number">729</span>       <span class="hljs-number">13</span>      <span class="hljs-number">5832</span>K inode_cache<br>  <span class="hljs-attribute">7923</span>   <span class="hljs-number">7915</span>  <span class="hljs-number">99</span>%    <span class="hljs-number">0</span>.<span class="hljs-number">20</span>K    <span class="hljs-number">417</span>       <span class="hljs-number">19</span>      <span class="hljs-number">1668</span>K vm_area_struct<br>  <span class="hljs-attribute">7605</span>   <span class="hljs-number">6366</span>  <span class="hljs-number">83</span>%    <span class="hljs-number">0</span>.<span class="hljs-number">10</span>K    <span class="hljs-number">195</span>       <span class="hljs-number">39</span>       <span class="hljs-number">780</span>K buffer_head<br>  <span class="hljs-attribute">7452</span>   <span class="hljs-number">7310</span>  <span class="hljs-number">98</span>%    <span class="hljs-number">0</span>.<span class="hljs-number">09</span>K    <span class="hljs-number">162</span>       <span class="hljs-number">46</span>       <span class="hljs-number">648</span>K anon_vma<br>  <span class="hljs-attribute">4528</span>   <span class="hljs-number">3242</span>  <span class="hljs-number">71</span>%    <span class="hljs-number">0</span>.<span class="hljs-number">25</span>K    <span class="hljs-number">283</span>       <span class="hljs-number">16</span>      <span class="hljs-number">1132</span>K filp<br>  <span class="hljs-attribute">4116</span>   <span class="hljs-number">4116</span> <span class="hljs-number">100</span>%    <span class="hljs-number">0</span>.<span class="hljs-number">19</span>K    <span class="hljs-number">196</span>       <span class="hljs-number">21</span>       <span class="hljs-number">784</span>K uid_cache<br></code></pre></td></tr></table></figure>
<h2 id="2-要监控哪些内存"><a href="#2-要监控哪些内存" class="headerlink" title="2.要监控哪些内存"></a>2.要监控哪些内存</h2><p>通过上面的排查后,可以比较明确的是,内存监控不是单一指标,应该用一主多辅的指标进行监控(不然Linux内存那么多指标就是摆设了….)</p>
<p>主要指标当然是我们常说的内存使用占比了,根据free命令中的说明,我们一般都是用free的user/total来计算,也就是((MemTotal - (MemFree + Buffers + Cached + SReclaimable)) / MemTotal),但是这个计算会漏一些数据,比如上面所说的<code>SUnreclaim</code>以及/proc/meminfo里面的其他情况,同时Linux的页缓存也可能存在无法回收的情况.所以可以说这个指标也是不太准的.</p>
<p>那要怎么样才能把上面的情况考虑进去,尽量做一个所有服务都共有的内存监控呢,还记得free里有一个available字段,他的文档说明也说了,该字段是对一些可用内存进行统计,同时它会考虑 Page Cache 和无法回收的<code>SUnreclaim</code>的内存( 假设pagecache / 2 和 <code>SUnreclaim</code> / 2 是不可回收的)，最后估算出一个当前可用内存,来达到尽可能的与实际数据贴合.<br>所以实际的内存统计应该为( MemTotal - MemAvailable) / MemTotal,这样子会比原来的统计更加准确.</p>
<p>这样一来主要指标已经定下了,但考虑到他只能尽量去适配所有业务,有些业务有对某项值消耗的非常厉害,但主要指标不一定能统计到的,所以我们还要添加一些辅助指标,以完善我们的内存监控系统</p>
<ul>
<li><code>SUnreclaim</code> ,就像我们上面提到的,这个指标一般机器是不会出现的,只有涉及到tcp等问题才会导致该常数的值异常,这个异常用我们的主要指标是很难分析到的.</li>
<li><code>buffer</code>, <code>cached</code>,正常情况下的业务该值是不会有异常的,但是在涉及到一些io读写比较多的情景时,机器上面很多内存会被buffer,cached占用.<h2 id="3-附录"><a href="#3-附录" class="headerlink" title="3. 附录"></a>3. 附录</h2><h3 id="3-1-正常机器数据"><a href="#3-1-正常机器数据" class="headerlink" title="3.1. 正常机器数据"></a>3.1. 正常机器数据</h3>该章节主要用于展示数据,对比与原来的数据差别<h3 id="3-2-free"><a href="#3-2-free" class="headerlink" title="3.2. free"></a>3.2. free</h3><figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache">              <span class="hljs-attribute">total</span>        used        free      shared  buff/cache   available<br><span class="hljs-attribute">Mem</span>:          <span class="hljs-number">2</span>.<span class="hljs-number">0</span>Gi       <span class="hljs-number">193</span>Mi       <span class="hljs-number">921</span>Mi        <span class="hljs-number">20</span>Mi       <span class="hljs-number">882</span>Mi       <span class="hljs-number">1</span>.<span class="hljs-number">6</span>Gi<br><span class="hljs-attribute">Swap</span>:            <span class="hljs-number">0</span>B          <span class="hljs-number">0</span>B          <span class="hljs-number">0</span>B<br></code></pre></td></tr></table></figure>
<h3 id="3-3-cat-proc-meminfo"><a href="#3-3-cat-proc-meminfo" class="headerlink" title="3.3. cat /proc/meminfo"></a>3.3. cat /proc/meminfo</h3><figure class="highlight makefile"><table><tr><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">MemTotal:        2045852 kB</span><br><span class="hljs-section">MemFree:          937856 kB</span><br><span class="hljs-section">MemAvailable:    1658140 kB</span><br><span class="hljs-section">Buffers:           56928 kB</span><br><span class="hljs-section">Cached:           779772 kB</span><br><span class="hljs-section">SwapCached:            0 kB</span><br><span class="hljs-section">Active:           356800 kB</span><br><span class="hljs-section">Inactive:         604076 kB</span><br><span class="hljs-section">Active(anon):     121720 kB</span><br><span class="hljs-section">Inactive(anon):    20808 kB</span><br><span class="hljs-section">Active(file):     235080 kB</span><br><span class="hljs-section">Inactive(file):   583268 kB</span><br><span class="hljs-section">Unevictable:           0 kB</span><br><span class="hljs-section">Mlocked:               0 kB</span><br><span class="hljs-section">SwapTotal:             0 kB</span><br><span class="hljs-section">SwapFree:              0 kB</span><br><span class="hljs-section">Dirty:                28 kB</span><br><span class="hljs-section">Writeback:             0 kB</span><br><span class="hljs-section">AnonPages:        121908 kB</span><br><span class="hljs-section">Mapped:            36768 kB</span><br><span class="hljs-section">Shmem:             20972 kB</span><br><span class="hljs-section">Slab:             104908 kB</span><br><span class="hljs-section">SReclaimable:      67096 kB</span><br><span class="hljs-section">SUnreclaim:        37812 kB</span><br><span class="hljs-section">KernelStack:        1612 kB</span><br><span class="hljs-section">PageTables:         2088 kB</span><br><span class="hljs-section">NFS_Unstable:          0 kB</span><br><span class="hljs-section">Bounce:                0 kB</span><br><span class="hljs-section">WritebackTmp:          0 kB</span><br><span class="hljs-section">CommitLimit:     1022924 kB</span><br><span class="hljs-section">Committed_AS:     398732 kB</span><br><span class="hljs-section">VmallocTotal:   34359738367 kB</span><br><span class="hljs-section">VmallocUsed:           0 kB</span><br><span class="hljs-section">VmallocChunk:          0 kB</span><br><span class="hljs-section">Percpu:              356 kB</span><br><span class="hljs-section">AnonHugePages:     51200 kB</span><br><span class="hljs-section">ShmemHugePages:        0 kB</span><br><span class="hljs-section">ShmemPmdMapped:        0 kB</span><br><span class="hljs-section">HugePages_Total:       0</span><br><span class="hljs-section">HugePages_Free:        0</span><br><span class="hljs-section">HugePages_Rsvd:        0</span><br><span class="hljs-section">HugePages_Surp:        0</span><br><span class="hljs-section">Hugepagesize:       2048 kB</span><br><span class="hljs-section">Hugetlb:               0 kB</span><br><span class="hljs-section">DirectMap4k:      163812 kB</span><br><span class="hljs-section">DirectMap2M:     1933312 kB</span><br><span class="hljs-section">DirectMap1G:           0 kB</span><br></code></pre></td></tr></table></figure>
<h3 id="3-4-slabtop"><a href="#3-4-slabtop" class="headerlink" title="3.4. slabtop"></a>3.4. slabtop</h3><figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">OBJS</span> ACTIVE  USE OBJ SIZE  SLABS OBJ/SLAB CACHE SIZE NAME                   <br><span class="hljs-attribute">183456</span> <span class="hljs-number">179948</span>  <span class="hljs-number">98</span>%    <span class="hljs-number">0</span>.<span class="hljs-number">10</span>K   <span class="hljs-number">4704</span>       <span class="hljs-number">39</span>     <span class="hljs-number">18816</span>K buffer_head<br> <span class="hljs-attribute">57036</span>  <span class="hljs-number">55070</span>  <span class="hljs-number">96</span>%    <span class="hljs-number">0</span>.<span class="hljs-number">19</span>K   <span class="hljs-number">2716</span>       <span class="hljs-number">21</span>     <span class="hljs-number">10864</span>K dentry<br> <span class="hljs-attribute">51639</span>  <span class="hljs-number">51639</span> <span class="hljs-number">100</span>%    <span class="hljs-number">0</span>.<span class="hljs-number">19</span>K   <span class="hljs-number">2459</span>       <span class="hljs-number">21</span>      <span class="hljs-number">9836</span>K kmalloc-<span class="hljs-number">192</span><br> <span class="hljs-attribute">24684</span>  <span class="hljs-number">24684</span> <span class="hljs-number">100</span>%    <span class="hljs-number">0</span>.<span class="hljs-number">04</span>K    <span class="hljs-number">242</span>      <span class="hljs-number">102</span>       <span class="hljs-number">968</span>K ext<span class="hljs-number">4</span>_extent_status<br> <span class="hljs-attribute">17280</span>  <span class="hljs-number">16530</span>  <span class="hljs-number">95</span>%    <span class="hljs-number">0</span>.<span class="hljs-number">03</span>K    <span class="hljs-number">135</span>      <span class="hljs-number">128</span>       <span class="hljs-number">540</span>K kmalloc-<span class="hljs-number">32</span><br> <span class="hljs-attribute">17055</span>  <span class="hljs-number">16817</span>  <span class="hljs-number">98</span>%    <span class="hljs-number">1</span>.<span class="hljs-number">05</span>K   <span class="hljs-number">1137</span>       <span class="hljs-number">15</span>     <span class="hljs-number">18192</span>K ext<span class="hljs-number">4</span>_inode_cache<br> <span class="hljs-attribute">15420</span>  <span class="hljs-number">15420</span> <span class="hljs-number">100</span>%    <span class="hljs-number">0</span>.<span class="hljs-number">13</span>K    <span class="hljs-number">514</span>       <span class="hljs-number">30</span>      <span class="hljs-number">2056</span>K kernfs_node_cache<br> <span class="hljs-attribute">11520</span>  <span class="hljs-number">10774</span>  <span class="hljs-number">93</span>%    <span class="hljs-number">0</span>.<span class="hljs-number">06</span>K    <span class="hljs-number">180</span>       <span class="hljs-number">64</span>       <span class="hljs-number">720</span>K anon_vma_chain<br> <span class="hljs-attribute">11479</span>  <span class="hljs-number">11416</span>  <span class="hljs-number">99</span>%    <span class="hljs-number">0</span>.<span class="hljs-number">59</span>K    <span class="hljs-number">883</span>       <span class="hljs-number">13</span>      <span class="hljs-number">7064</span>K inode_cache<br> <span class="hljs-attribute">11136</span>  <span class="hljs-number">11136</span> <span class="hljs-number">100</span>%    <span class="hljs-number">0</span>.<span class="hljs-number">06</span>K    <span class="hljs-number">174</span>       <span class="hljs-number">64</span>       <span class="hljs-number">696</span>K tcp_bind_bucket<br>  <span class="hljs-attribute">9024</span>   <span class="hljs-number">7905</span>  <span class="hljs-number">87</span>%    <span class="hljs-number">0</span>.<span class="hljs-number">06</span>K    <span class="hljs-number">141</span>       <span class="hljs-number">64</span>       <span class="hljs-number">564</span>K kmalloc-<span class="hljs-number">64</span><br>  <span class="hljs-attribute">8960</span>   <span class="hljs-number">8960</span> <span class="hljs-number">100</span>%    <span class="hljs-number">0</span>.<span class="hljs-number">02</span>K     <span class="hljs-number">35</span>      <span class="hljs-number">256</span>       <span class="hljs-number">140</span>K kmalloc-<span class="hljs-number">16</span><br></code></pre></td></tr></table></figure>



</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>记一次ElasticSearch冷热分离索引无法正确分配的问题</title>
    <url>/2020/04/10/%E8%AE%B0%E4%B8%80%E6%AC%A1ElasticSearch%E5%86%B7%E7%83%AD%E5%88%86%E7%A6%BB%E7%B4%A2%E5%BC%95%E6%97%A0%E6%B3%95%E6%AD%A3%E7%A1%AE%E5%88%86%E9%85%8D%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="前记"><a href="#前记" class="headerlink" title="前记"></a>前记</h2><p>一开始ElasticSearch是同事自己搭的一个单节点, 我在接手后开始使用mapping,集群等功能, 但很多旧<code>index</code>在单节点时被应用了很多奇怪的配置, 导致添加新的功能非常麻烦, 比如在启用冷热分离功能的时候, 旧的<code>index</code>无法正确分配.</p>
<span id="more"></span>
<h2 id="1-问题"><a href="#1-问题" class="headerlink" title="1.问题"></a>1.问题</h2><p>当给ElasticSearch配置了ILM后,ElasticSearch会根据配置自动执行,按照配置把索引进行在集群之中迁移,但是运行一段时间后发现,之前用logstash传过来的且没有使用mapping的旧索引都无法正常执行ILM,而其他数据却能正常处理.<br>由于发现这个问题时,对于Es不是十分了解,只能copy错误去搜索,搜索后发现几乎没有一个答案是满意的,最多说的是升级ElasticSearch版本解决,所以就又水了一文.</p>
<h2 id="2-查看索引ilm运行情况"><a href="#2-查看索引ilm运行情况" class="headerlink" title="2.查看索引ilm运行情况"></a>2.查看索引ilm运行情况</h2><p>由于是由ilm自己自动运行的, 我们可以通过查看ilm的运行情况查看问题发生在哪</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">GET so1n_index/_ilm/explain<br></code></pre></td></tr></table></figure>
<p>得出响应如下, 这里使用so1n_index代替索引名(下同).</p>
<figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;indices&quot;</span> : &#123;<br>    <span class="hljs-attr">&quot;so1n_index&quot;</span> : &#123;<br>      <span class="hljs-attr">&quot;index&quot;</span> : <span class="hljs-string">&quot;so1n_index&quot;</span>,<br>      <span class="hljs-attr">&quot;managed&quot;</span> : <span class="hljs-literal">true</span>,<br>      <span class="hljs-attr">&quot;policy&quot;</span> : <span class="hljs-string">&quot;so1n_index_policy&quot;</span>,<br>      <span class="hljs-attr">&quot;lifecycle_date_millis&quot;</span> : <span class="hljs-number">1585008002962</span>,<br>      <span class="hljs-attr">&quot;age&quot;</span> : <span class="hljs-string">&quot;35.41d&quot;</span>,<br>      <span class="hljs-attr">&quot;phase&quot;</span> : <span class="hljs-string">&quot;cold&quot;</span>,<br>      <span class="hljs-attr">&quot;phase_time_millis&quot;</span> : <span class="hljs-number">1587686411329</span>,<br>      <span class="hljs-attr">&quot;action&quot;</span> : <span class="hljs-string">&quot;allocate&quot;</span>,<br>      <span class="hljs-attr">&quot;action_time_millis&quot;</span> : <span class="hljs-number">1587686419823</span>,<br>      <span class="hljs-attr">&quot;step&quot;</span> : <span class="hljs-string">&quot;check-allocation&quot;</span>,<br>      <span class="hljs-attr">&quot;step_time_millis&quot;</span> : <span class="hljs-number">1587686428607</span>,<br>      <span class="hljs-attr">&quot;step_info&quot;</span> : &#123;<br>        <span class="hljs-attr">&quot;message&quot;</span> : <span class="hljs-string">&quot;Waiting for [2] shards to be allocated to nodes matching the given filters&quot;</span>,<br>        <span class="hljs-attr">&quot;shards_left_to_allocate&quot;</span> : <span class="hljs-number">2</span>,<br>        <span class="hljs-attr">&quot;all_shards_active&quot;</span> : <span class="hljs-literal">true</span>,<br>        <span class="hljs-attr">&quot;actual_replicas&quot;</span> : <span class="hljs-number">1</span><br>      &#125;,<br>      <span class="hljs-attr">&quot;phase_execution&quot;</span> : &#123;<br>        <span class="hljs-attr">&quot;policy&quot;</span> : <span class="hljs-string">&quot;so1n_index_policy&quot;</span>,<br>        <span class="hljs-attr">&quot;phase_definition&quot;</span> : &#123;<br>          <span class="hljs-attr">&quot;min_age&quot;</span> : <span class="hljs-string">&quot;31d&quot;</span>,<br>          <span class="hljs-attr">&quot;actions&quot;</span> : &#123;<br>            <span class="hljs-attr">&quot;freeze&quot;</span> : &#123; &#125;,<br>            <span class="hljs-attr">&quot;allocate&quot;</span> : &#123;<br>              <span class="hljs-attr">&quot;include&quot;</span> : &#123; &#125;,<br>              <span class="hljs-attr">&quot;exclude&quot;</span> : &#123; &#125;,<br>              <span class="hljs-attr">&quot;require&quot;</span> : &#123;<br>                <span class="hljs-attr">&quot;box_type&quot;</span> : <span class="hljs-string">&quot;cold&quot;</span><br>              &#125;<br>            &#125;,<br>            <span class="hljs-attr">&quot;set_priority&quot;</span> : &#123;<br>              <span class="hljs-attr">&quot;priority&quot;</span> : <span class="hljs-number">10</span><br>            &#125;<br>          &#125;<br>        &#125;,<br>        <span class="hljs-attr">&quot;version&quot;</span> : <span class="hljs-number">3</span>,<br>        <span class="hljs-attr">&quot;modified_date_in_millis&quot;</span> : <span class="hljs-number">1587663954354</span><br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p>看输出可以发现,我在ilm配置索引min_age超过31天就执行so1n_index_policy中的一个cold phase,而在执行其中allocate的check-allocation步骤时报错<code>Waiting for [2] shards to be allocated to nodes matching the given filters</code>,也就是ilm执行到so1n_index节点分配时就已经出问题了,而且还是在check-allocation阶段.所以我们只要查明为什么check-allocation不通过就好了.</p>
<h2 id="3-查看索引allocation情况"><a href="#3-查看索引allocation情况" class="headerlink" title="3.查看索引allocation情况"></a>3.查看索引allocation情况</h2><p>直接使用explain查看allocation的错误原因</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">GET /_cluster/allocation/explain<br>&#123;<br>  <span class="hljs-string">&quot;index&quot;</span>: <span class="hljs-string">&quot;so1n_index&quot;</span>,<br>  <span class="hljs-string">&quot;shard&quot;</span>: 0,<br>  <span class="hljs-string">&quot;primary&quot;</span>: <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>返回响应如下:</p>
<figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;index&quot;</span> : <span class="hljs-string">&quot;so1n_index&quot;</span>,<br>  <span class="hljs-attr">&quot;shard&quot;</span> : <span class="hljs-number">0</span>,<br>  <span class="hljs-attr">&quot;primary&quot;</span> : <span class="hljs-literal">true</span>,<br>  <span class="hljs-attr">&quot;current_state&quot;</span> : <span class="hljs-string">&quot;started&quot;</span>,<br>  <span class="hljs-attr">&quot;current_node&quot;</span> : &#123;<br>    <span class="hljs-attr">&quot;id&quot;</span> : <span class="hljs-string">&quot;so1n_id_1&quot;</span>,<br>    <span class="hljs-attr">&quot;name&quot;</span> : <span class="hljs-string">&quot;so1n-elastic-node-1&quot;</span>,<br>    <span class="hljs-attr">&quot;transport_address&quot;</span> : <span class="hljs-string">&quot;10.142.0.1:9300&quot;</span>,<br>    <span class="hljs-attr">&quot;attributes&quot;</span> : &#123;<br>      <span class="hljs-attr">&quot;ml.machine_memory&quot;</span> : <span class="hljs-string">&quot;7839637504&quot;</span>,<br>      <span class="hljs-attr">&quot;xpack.installed&quot;</span> : <span class="hljs-string">&quot;true&quot;</span>,<br>      <span class="hljs-attr">&quot;box_type&quot;</span> : <span class="hljs-string">&quot;hot&quot;</span>,<br>      <span class="hljs-attr">&quot;ml.max_open_jobs&quot;</span> : <span class="hljs-string">&quot;20&quot;</span><br>    &#125;<br>  &#125;,<br>  <span class="hljs-attr">&quot;can_remain_on_current_node&quot;</span> : <span class="hljs-string">&quot;no&quot;</span>,<br>  <span class="hljs-attr">&quot;can_remain_decisions&quot;</span> : [<br>    &#123;<br>      <span class="hljs-attr">&quot;decider&quot;</span> : <span class="hljs-string">&quot;filter&quot;</span>,<br>      <span class="hljs-attr">&quot;decision&quot;</span> : <span class="hljs-string">&quot;NO&quot;</span>,<br>      <span class="hljs-attr">&quot;explanation&quot;</span> : <span class="hljs-string">&quot;&quot;</span><span class="hljs-string">&quot;node does not match index setting [index.routing.allocation.require] filters [box_type:&quot;</span>cold<span class="hljs-string">&quot;,_id:&quot;</span>so1n_id_3<span class="hljs-string">&quot;]&quot;</span><span class="hljs-string">&quot;&quot;</span><br>    &#125;<br>  ],<br>  <span class="hljs-attr">&quot;can_move_to_other_node&quot;</span> : <span class="hljs-string">&quot;no&quot;</span>,<br>  <span class="hljs-attr">&quot;move_explanation&quot;</span> : <span class="hljs-string">&quot;cannot move shard to another node, even though it is not allowed to remain on its current node&quot;</span>,<br>  <span class="hljs-attr">&quot;node_allocation_decisions&quot;</span> : [<br>    &#123;<br>      <span class="hljs-attr">&quot;node_id&quot;</span> : <span class="hljs-string">&quot;so1n_id_2&quot;</span>,<br>      <span class="hljs-attr">&quot;node_name&quot;</span> : <span class="hljs-string">&quot;so1n-elastic-node-2&quot;</span>,<br>      <span class="hljs-attr">&quot;transport_address&quot;</span> : <span class="hljs-string">&quot;10.142.0.2:9300&quot;</span>,<br>      <span class="hljs-attr">&quot;node_attributes&quot;</span> : &#123;<br>        <span class="hljs-attr">&quot;ml.machine_memory&quot;</span> : <span class="hljs-string">&quot;7839653888&quot;</span>,<br>        <span class="hljs-attr">&quot;ml.max_open_jobs&quot;</span> : <span class="hljs-string">&quot;20&quot;</span>,<br>        <span class="hljs-attr">&quot;box_type&quot;</span> : <span class="hljs-string">&quot;cold&quot;</span>,<br>        <span class="hljs-attr">&quot;xpack.installed&quot;</span> : <span class="hljs-string">&quot;true&quot;</span><br>      &#125;,<br>      <span class="hljs-attr">&quot;node_decision&quot;</span> : <span class="hljs-string">&quot;no&quot;</span>,<br>      <span class="hljs-attr">&quot;weight_ranking&quot;</span> : <span class="hljs-number">1</span>,<br>      <span class="hljs-attr">&quot;deciders&quot;</span> : [<br>        &#123;<br>          <span class="hljs-attr">&quot;decider&quot;</span> : <span class="hljs-string">&quot;filter&quot;</span>,<br>          <span class="hljs-attr">&quot;decision&quot;</span> : <span class="hljs-string">&quot;NO&quot;</span>,<br>          <span class="hljs-attr">&quot;explanation&quot;</span> : <span class="hljs-string">&quot;&quot;</span><span class="hljs-string">&quot;node does not match index setting [index.routing.allocation.require] filters [box_type:&quot;</span>cold<span class="hljs-string">&quot;,_id:&quot;</span>so1n_id_3<span class="hljs-string">&quot;]&quot;</span><span class="hljs-string">&quot;&quot;</span><br>        &#125;<br>      ]<br>    &#125;<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这里可以发现,原来是索引多了一段配置,导致在分配索引时,必须要确保节点的id是:so1n_id_3且box_type为cold,可是被分配的节点这一台的box_type是虽然是cold, 但是节点id是:so1n_id_2.<br>接下来就可以具体查看索引的设置(kibana的设置里面可以查看):</p>
<figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;index.blocks.read_only_allow_delete&quot;</span>: <span class="hljs-string">&quot;false&quot;</span>,<br>  <span class="hljs-attr">&quot;index.query.default_field&quot;</span>: [<br>    <span class="hljs-string">&quot;*&quot;</span><br>  ],<br>  <span class="hljs-attr">&quot;index.refresh_interval&quot;</span>: <span class="hljs-string">&quot;1s&quot;</span>,<br>  <span class="hljs-attr">&quot;index.write.wait_for_active_shards&quot;</span>: <span class="hljs-string">&quot;1&quot;</span>,<br>  <span class="hljs-attr">&quot;index.lifecycle.name&quot;</span>: <span class="hljs-string">&quot;so1n_index_policy&quot;</span>,<br>  <span class="hljs-attr">&quot;index.routing.allocation.require._id&quot;</span>: <span class="hljs-string">&quot;so1n_id_3&quot;</span>,<br>  <span class="hljs-attr">&quot;index.routing.allocation.require.box_type&quot;</span>: <span class="hljs-string">&quot;cold&quot;</span>,<br>  <span class="hljs-attr">&quot;index.blocks.write&quot;</span>: <span class="hljs-string">&quot;true&quot;</span>,<br>  <span class="hljs-attr">&quot;index.priority&quot;</span>: <span class="hljs-string">&quot;10&quot;</span>,<br>  <span class="hljs-attr">&quot;index.number_of_replicas&quot;</span>: <span class="hljs-string">&quot;1&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>可以发现,这里多了一段</p>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs json">&quot;index.routing.allocation.require._id&quot;: &quot;so1n_id_3&quot;<br></code></pre></td></tr></table></figure>
<p>这一段从来没配置过,估计是没使用mapping时,当数据发送到so1n_id_3节点时,Es会自动给索引加上<code>index.routing.allocation.require._id</code>.</p>
<h2 id="4-解决"><a href="#4-解决" class="headerlink" title="4.解决"></a>4.解决</h2><p>从上面可以发现, 由于旧索引带有:</p>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs json">&quot;index.routing.allocation.require._id&quot;: &quot;so1n_id_3&quot;<br></code></pre></td></tr></table></figure>
<p>导致了旧索引无法分配, 目前业务上不需要该限制条件, 可以确定Es上面的所有索引都可以不需要<code>index.routing.allocation.require._id</code>,那可以通过以下进行修改:(如果有部分索引需要<code>index.routing.allocation.require._id</code>,则需要通配符修改)</p>
<figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json">PUT */_settings<br>&#123;<br>   <span class="hljs-attr">&quot;index.routing.allocation.require._id&quot;</span>: <span class="hljs-literal">null</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>修改完成后再调用explain查看:</p>
<figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json">GET /_cluster/allocation/explain<br>&#123;<br>  <span class="hljs-attr">&quot;index&quot;</span>: <span class="hljs-string">&quot;so1n_index&quot;</span>,<br>  <span class="hljs-attr">&quot;shard&quot;</span>: <span class="hljs-number">0</span>,<br>  <span class="hljs-attr">&quot;primary&quot;</span>: <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>通过响应可以发现Es已经在后台执行索引迁移了:</p>
<figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;index&quot;</span> : <span class="hljs-string">&quot;so1n_index&quot;</span>,<br>  <span class="hljs-attr">&quot;shard&quot;</span> : <span class="hljs-number">0</span>,<br>  <span class="hljs-attr">&quot;primary&quot;</span> : <span class="hljs-literal">true</span>,<br>  <span class="hljs-attr">&quot;current_state&quot;</span> : <span class="hljs-string">&quot;relocating&quot;</span>,<br>  <span class="hljs-attr">&quot;current_node&quot;</span> : &#123;<br>    <span class="hljs-attr">&quot;id&quot;</span> : <span class="hljs-string">&quot;so1n_id_1&quot;</span>,<br>    <span class="hljs-attr">&quot;name&quot;</span> : <span class="hljs-string">&quot;so1n-elastic-node-1&quot;</span>,<br>    <span class="hljs-attr">&quot;transport_address&quot;</span> : <span class="hljs-string">&quot;10.142.0.1:9300&quot;</span>,<br>    <span class="hljs-attr">&quot;attributes&quot;</span> : &#123;<br>      <span class="hljs-attr">&quot;ml.machine_memory&quot;</span> : <span class="hljs-string">&quot;7839637504&quot;</span>,<br>      <span class="hljs-attr">&quot;xpack.installed&quot;</span> : <span class="hljs-string">&quot;true&quot;</span>,<br>      <span class="hljs-attr">&quot;box_type&quot;</span> : <span class="hljs-string">&quot;hot&quot;</span>,<br>      <span class="hljs-attr">&quot;ml.max_open_jobs&quot;</span> : <span class="hljs-string">&quot;20&quot;</span><br>    &#125;<br>  &#125;,<br>  <span class="hljs-attr">&quot;explanation&quot;</span> : <span class="hljs-string">&quot;the shard is in the process of relocating from node [so1n-elastic-node-1] to node [so1n-elastic-node-4], wait until relocation has completed&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>迁移完成后再去查看可以发现字段<code>rebalance_explanation</code>会显示:<code>cannot rebalance as no target node exists that can both allocate this shard and improve the cluster balance</code><br>则此,索引冷热分离规则全部适配运行完成.</p>
]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>ElasticSearch</tag>
      </tags>
  </entry>
  <entry>
    <title>APScheduler原理分析</title>
    <url>/2020/03/26/APScheduler%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h2 id="前记"><a href="#前记" class="headerlink" title="前记"></a>前记</h2><p>最近由于账单提交和脚本过多不好控制的原因,一直在寻找解决方案,发现APScheduler比较轻量级以及适合我的账单提交,和脚本运行控制(如果脚本运行需要依赖的话就可以上AirFlow).为了弄清楚原理,以及更好的使用APScheduler,所以阅读了APScheduler代码.其实是APScheduler代码量比较少的分析起来才容易(逃)</p>
<p>不过apscheduler有一个致命的缺点, 除,由于apscheduler的实现比较简单, 在初始化时, 能达到分布式work的效果外,  在运行时增加任务时, 并不会同步到每个work.</p>
<span id="more"></span>

<p><strong>注:</strong> 为了节省篇幅,下面分析代码时大多数是只贴github的源码链接,并加以说明,源码是<a href="https://github.com/agronholm/apscheduler/tree/3.x/apscheduler">APscheduler第三版</a></p>
<h2 id="1-主体逻辑"><a href="#1-主体逻辑" class="headerlink" title="1.主体逻辑"></a>1.主体逻辑</h2><h3 id="1-1代码结构"><a href="#1-1代码结构" class="headerlink" title="1.1代码结构"></a>1.1代码结构</h3><p>首先看看APScheduler的代码结构,除了job,event,util这几个简单的封装外,APScheduler中的组件都各自一个文件夹</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">├── executors      执行器,用于执行任务<br>├── jobstores      储存器,用于存放任务<br>├── schedulers     调度器,用于调度任务实例,由执行器,存储器,触发器三个组件构成<br>├── triggers       触发器,用于设定触发任务的条件<br>├── __init__.py<br>├── events.py      事件,调度器触发时的事件封装<br>├── job.py         job,对添加的任务进行封装,方便调度器调用<br>└── util.py        工具包,apscheduler一些常用函数封装<br></code></pre></td></tr></table></figure>
<h3 id="1-2简单的例子"><a href="#1-2简单的例子" class="headerlink" title="1.2简单的例子"></a>1.2简单的例子</h3><p>看完了代码结构,会觉得APScheduler代码并不复杂,但是APScheduler大量的用到了Python动态语言的特性,一个一个看可能比较懵,所以需要找一个切入点开始进入APScheduler的代码世界,而这个切入点就是从一个简单的例子开始.先看APScheduler的<code>Hello World</code>级别的入门代码:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">from</span> datetime <span class="hljs-keyword">import</span> datetime,timedelta<br><span class="hljs-keyword">from</span> apscheduler.schedulers.blocking <span class="hljs-keyword">import</span> BlockingScheduler<br><br>scheduler = BlockingScheduler()  <span class="hljs-comment"># 1</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">so1n_job</span>(<span class="hljs-params">text</span>):</span>   <span class="hljs-comment"># 2</span><br>    print(text)<br><br>scheduler.add_job(so1n_job, <span class="hljs-string">&#x27;date&#x27;</span>, run_date=datetime.now() + timeelta(hours=<span class="hljs-number">1</span>), args=[<span class="hljs-string">&#x27;test&#x27;</span>])   <span class="hljs-comment"># 3</span><br>scheduler.start()   <span class="hljs-comment"># 4</span><br></code></pre></td></tr></table></figure>
<p>这个简单的代码如要做如下步骤:</p>
<ul>
<li>1.实例化一个scheduler,这里使用的是BlockingScheduler,它在运行时会阻塞代码</li>
<li>2.为了演示而创建的简单job函数,只执行print功能</li>
<li>3.通过scheduler的add_job方式添加job, 同时定义了date触发器和触发时间以及运行job时的参数, 这里定义的是一小时后执行任务.</li>
<li>4.开始运行scheduler,检查和执行调度.</li>
</ul>
<h3 id="1-3-初始化scheduler"><a href="#1-3-初始化scheduler" class="headerlink" title="1.3 初始化scheduler"></a>1.3 初始化scheduler</h3><p>在实例化scheduler时,会先把其他三个组件加载到自己的父属性[源码]:(<a href="https://github.com/agronholm/apscheduler/blob/3.x/apscheduler/schedulers/base.py#L66">https://github.com/agronholm/apscheduler/blob/3.x/apscheduler/schedulers/base.py#L66</a>)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python">_trigger_plugins = <span class="hljs-built_in">dict</span>((ep.name, ep) <span class="hljs-keyword">for</span> ep <span class="hljs-keyword">in</span> iter_entry_points(<span class="hljs-string">&#x27;apscheduler.triggers&#x27;</span>))<br>_trigger_classes = &#123;&#125;<br>_executor_plugins = <span class="hljs-built_in">dict</span>((ep.name, ep) <span class="hljs-keyword">for</span> ep <span class="hljs-keyword">in</span> iter_entry_points(<span class="hljs-string">&#x27;apscheduler.executors&#x27;</span>))<br>_executor_classes = &#123;&#125;<br>_jobstore_plugins = <span class="hljs-built_in">dict</span>((ep.name, ep) <span class="hljs-keyword">for</span> ep <span class="hljs-keyword">in</span> iter_entry_points(<span class="hljs-string">&#x27;apscheduler.jobstores&#x27;</span>))<br>_jobstore_classes = &#123;&#125;<br></code></pre></td></tr></table></figure>
<p>在实例化后,<code>__init__</code>会创建一些锁相关的属性以及调用<a href="https://github.com/agronholm/apscheduler/blob/3.x/apscheduler/schedulers/base.py#L89">configure</a>方法初始化一些数据(在scheduler还没start前,我们也可以直接调用<a href="https://github.com/agronholm/apscheduler/blob/3.x/apscheduler/schedulers/base.py#L89">configure</a>方法修改数据)</p>
<ul>
<li><p>加载配置,把所有数据加载到一个叫config的dict里面</p>
</li>
<li><p>通过调用<a href="https://github.com/agronholm/apscheduler/blob/3.x/apscheduler/schedulers/base.py#L694">_configure</a>初始化常用配置, 对于一些特定的scheduler, 还会初始化一些属性, 如<code>background</code>会初始化deamon, <code>asyncio</code>会初始化loop等:</p>
<ul>
<li>logger,APScheduler运行时打日志的logger,默认为apscheduler.scheduler</li>
<li>timezone, 设置时区, 默认为本地时区. 对于调度系统来说时区是一个非常关键的参数, 特别是对于有冬夏令时的国家, 如果有做多国家业务的, 必须要用时区.</li>
<li>jobstore_retry_interval, 重试时间, 如果get_due_jobs()调用引发异常，则至少在设置n秒内进行一次新的唤醒</li>
</ul>
</li>
<li><p>同时也会创建创建job的默认配置:</p>
<ul>
<li>misfire_grace_time,在指定的运行时之后几秒钟，仍允许运行该作业. 如果有个业务是指定一分钟后运行, 但apscheduler需要在两分钟后才有空闲运行该业务, 那么可以把<code>misfire_grace_time</code>的值设置为120+.</li>
<li>coalesce,为True时,即使调度程序确定该job可以运行多次，也只运行一次</li>
<li>max_instances, apscheduler同时最大运行实例数.</li>
</ul>
</li>
<li><p>配置执行器executors以及它的插件,并启动执行器</p>
</li>
<li><p>配置任务存储器jobstores以及它的插件,并启动任务存储器</p>
<h3 id="1-4添加job"><a href="#1-4添加job" class="headerlink" title="1.4添加job"></a>1.4添加job</h3><p>scheduler初始化完就可以开始添加job了,对于APScheduler来说,每个job的本体都是一个Python函数,在添加job本体的同时,顺便添加执行器,以及其他信息,如触发器,执行器,函数的参数,job的名称和id等,构成一个可以给scheduler调用的job.</p>
</li>
</ul>
<p>不过在添加job的时候还有一个参数叫<a href="https://github.com/agronholm/apscheduler/blob/3.x/apscheduler/schedulers/base.py#L448">replace_existing</a>,他不属于job的属性,当它为True时,scheduler会用相同的id替换已经存在的job,同时保留job的运行次数.还有存储器也不属于job的属性,只是让scheduler知道可以从该存储器可以获取到刚才添加的job.</p>
<p>例子中的job添加时,scheduler还未运行,所以会把job, jobstore, replace_existing拼成一个元祖,并存放到一个叫<code>_pending_jobs</code>的等待队列中.</p>
<p>如果job添加时scheduler还在运行,那就会进行如下一些处理(<a href="https://github.com/agronholm/apscheduler/blob/3.x/apscheduler/schedulers/base.py#L843">_real_add_job</a>函数),把job真正的添加到调度系统中:</p>
<ul>
<li>1.如果此时的job没有下次运行时间,则为其创建下次运行时间</li>
<li>2.调用job的_modify方法,当配置有效时更新job的配置</li>
<li>3.把job添加到对应的store,或更新已经存在store里的job, 这里会调用store的<a href="https://github.com/agronholm/apscheduler/blob/3.x/apscheduler/jobstores/memory.py#L82">_get_job_index</a>通过二分法查找job需要插入对应的index中.</li>
<li>4.如果scheduler正在运行, 则唤醒scheduler,看看新添加的job是否可以被调度(注意,此次唤醒会替换原本已经安排的唤醒计划)</li>
</ul>
<p>注意, 上面第4步只会唤醒本身的apscheduler, 如果是多个worker,那么其他的apscheduler并不会被唤醒.</p>
<h3 id="1-5开始运行scheduler"><a href="#1-5开始运行scheduler" class="headerlink" title="1.5开始运行scheduler"></a>1.5开始运行scheduler</h3><p>添加完job后,scheduler就可以开始运行了,通过调用scheduler的<a href="https://github.com/agronholm/apscheduler/blob/3.x/apscheduler/schedulers/base.py#L128">start</a>开始处理任务.<br>在开始运行前,scheduler会先去<a href="https://github.com/agronholm/apscheduler/blob/3.x/apscheduler/schedulers/base.py#L835">检查是否在使用禁用线程的uWSGI环境下运行</a>,只有检查通过后才能继续运行.</p>
<p>检查完毕后,scheduler会去进行一些初始化,首先scheduler会激活所有添加到scheduler的执行器,以便待会可以使用,同样激活所有添加到scheduler的储存器,以便待会可以使用.这里会把scheduler初始化时的<code>_pending_jobs</code>通过<strong>1.4添加job</strong>里面说到的<code>_real_add_job</code>函数,把job真正的添加到调度系统中.</p>
<p>初始化完成了,scheduler可以真正的开始去检查和调度job了,这一切都发生在scheduler的<a href="https://github.com/agronholm/apscheduler/blob/3.x/apscheduler/schedulers/base.py#L927">_process_jobs</a>函数里,他会遍历每个作业存储器中的job，然后执行可以被调度的job，最后检查下次运行时间,apscheduler会休眠到下次运行时间在启动,防止一直运行导致浪费计算机资源,具体操作如下:</p>
<ul>
<li>1.遍历存储器,并从存储器的<a href="https://github.com/agronholm/apscheduler/blob/3.x/apscheduler/jobstores/memory.py#L23">get_due_jobs</a>方法找出比目前时间早的job列表,如果处理失败则会根据scheduler的<code>jobstore_retry_interval</code>生成下一次唤醒scheduler的时间.</li>
<li>2.遍历并处理从步骤1拿到的job列表<ul>
<li>2.1.遍历步骤1的job列表,提取job的执行器,如果提取失败则从存储器中删除掉job.</li>
<li>2.2.从job的<a href="https://github.com/agronholm/apscheduler/blob/3.x/apscheduler/job.py#L123">_get_run_times</a>方法获取介于现在时间到job的下一次运行时间中触发器可以触发的时间,并放在run_times列表中.</li>
<li>2.3.调用执行器的<a href="https://github.com/agronholm/apscheduler/blob/3.x/apscheduler/executors/base.py#L55">submit_job</a>方法,首先检查目前该job的执行实例数会不会大于或等于定义的max_instances,只有没超过定义的max_instances时,才会继续执行执行器的<code>_do_submit_job</code>方法,执行job.</li>
<li>2.4.运行完毕job后,[计算job是否还有next_run_time,如果有更新job以及对应的存储器,如果没有则把job从存储器中移除</li>
</ul>
</li>
<li>3.执行完job后,算出存储器中最早的下次运行时间,并与next_wakeup_time比对,如果早于next_wakeup_time则把next_wakeup_time设置为存储器中最早的下次运行时间(<a href="https://github.com/agronholm/apscheduler/blob/3.x/apscheduler/schedulers/base.py#L992">992-997</a>)</li>
<li>4.处理队列中的event,并算出距离下次运行时间与现在时间的时间差wait_seconds,并让scheduler睡眠wait_seconds,防止cpu空转(<a href="https://github.com/agronholm/apscheduler/blob/3.x/apscheduler/schedulers/base.py#L999">999-1004</a>).</li>
<li>5.等待了wait_seconds后scheduler从步骤1继续开始执行操作.</li>
</ul>
<p>则此,根据例子的主体逻辑代码分析已经分析完毕了,但是还有一些scheduler的方法,event,APScheduler的util以及APScheduler支持的gevent,async等库代码还没有分析.</p>
<h2 id="2-源码分析"><a href="#2-源码分析" class="headerlink" title="2.源码分析"></a>2.源码分析</h2><p>上一部分主要说的是APScheduler中的主要逻辑,简单的了解到APScheduler是如何运行的,以及运行时要做哪些操作,在说到主要函数时只说了是哪个模块下的哪个函数以及这个函数做了什么,对于一些细节并没有披露出来.而这一节不再跟着APScheduler的运行顺序进行分析,而是根据APScheduler的代码结构逐一分析里面的代码,从代码中了解APScheduler的原理,以及从APScheduler中吸收一些比较棒的idea.</p>
<h3 id="2-1-executors"><a href="#2-1-executors" class="headerlink" title="2.1 executors"></a>2.1 executors</h3><p>executors是apscheduler中的执行器,apscheduler为python中各种类型封装了executors,但核心的方法就只有几个,比较简单.</p>
<ul>
<li><p><a href="https://github.com/agronholm/apscheduler/blob/3.x/apscheduler/executors/base.py#L33">start</a></p>
<p>从scheduler获取资源和部分数据初始化,其余由其他封装实现</p>
</li>
<li><p><a href="https://github.com/agronholm/apscheduler/blob/3.x/apscheduler/executors/base.py#L47">shutdown</a></p>
<p>由其他封装实现,停用执行器并删除部分资源,如果任务并未完成,则会取消或清空任务</p>
</li>
<li><p><a href="https://github.com/agronholm/apscheduler/blob/3.x/apscheduler/executors/base.py#L55">submit_job</a></p>
<p>用于运行前的初始化和检查,主要用于检查当前job有多少实例正在运行,如果超出限制则抛出异常,未超出限制则执行_do_submit_job</p>
</li>
<li><p><a href="https://github.com/agronholm/apscheduler/blob/3.x/apscheduler/executors/base.py#L75">_do_submit_job</a></p>
<p>由其他封装实现,负责运行job,并检查运行结果,成功则调用_run_job_success, 失败则调用_run_job_error</p>
</li>
<li><p>_run_job_success<br>运行成功的后续操作</p>
</li>
<li><p>_run_job_error<br>运行失败的后续操作</p>
</li>
</ul>
<p>除此之外executors文件中还有一个叫<a href="https://github.com/agronholm/apscheduler/blob/3.x/apscheduler/executors/base.py#L103">run_job</a>的函数,它才是正真用于执行job的函数,它除了调用job的func和处理异常外,还对任务是否错过运行窗口进行检查,比如任务应该在9.00-9.10间运行,然而直到9.15程序没有运行,那么apscheduler会抛出对应的错误event和job.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run_job</span>(<span class="hljs-params">job, jobstore_alias, run_times, logger_name</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    Called by executors to run the job. Returns a list of scheduler events to be dispatched by the</span><br><span class="hljs-string">    scheduler.</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    events = []<br>    logger = logging.getLogger(logger_name)<br>    <span class="hljs-keyword">for</span> run_time <span class="hljs-keyword">in</span> run_times:<br>        <span class="hljs-comment"># 如果设置了,misfire_grace_time,且时间差在misfire_grace_time外,则超出了任务执行时间的时间窗口,放弃运行</span><br>        <span class="hljs-keyword">if</span> job.misfire_grace_time <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            difference = datetime.now(utc) - run_time<br>            grace_time = timedelta(seconds=job.misfire_grace_time)<br>            <span class="hljs-keyword">if</span> difference &gt; grace_time:<br>                events.append(JobExecutionEvent(EVENT_JOB_MISSED, job.<span class="hljs-built_in">id</span>, jobstore_alias,<br>                                                run_time))<br>                logger.warning(<span class="hljs-string">&#x27;Run time of job &quot;%s&quot; was missed by %s&#x27;</span>, job, difference)<br>                <span class="hljs-keyword">continue</span><br><br>        logger.info(<span class="hljs-string">&#x27;Running job &quot;%s&quot; (scheduled at %s)&#x27;</span>, job, run_time)<br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-comment"># 执行job</span><br>            retval = job.func(*job.args, **job.kwargs)<br>        <span class="hljs-keyword">except</span> BaseException:<br>            exc, tb = sys.exc_info()[<span class="hljs-number">1</span>:]<br>            formatted_tb = <span class="hljs-string">&#x27;&#x27;</span>.join(format_tb(tb))<br>            events.append(JobExecutionEvent(EVENT_JOB_ERROR, job.<span class="hljs-built_in">id</span>, jobstore_alias, run_time,<br>                                            exception=exc, traceback=formatted_tb))<br>            logger.exception(<span class="hljs-string">&#x27;Job &quot;%s&quot; raised an exception&#x27;</span>, job)<br><br>            <span class="hljs-comment"># 回收对象</span><br>            <span class="hljs-keyword">if</span> six.PY2:<br>                sys.exc_clear()<br>                <span class="hljs-keyword">del</span> tb<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">import</span> traceback<br>                traceback.clear_frames(tb)<br>                <span class="hljs-keyword">del</span> tb<br>        <span class="hljs-keyword">else</span>:<br>            events.append(JobExecutionEvent(EVENT_JOB_EXECUTED, job.<span class="hljs-built_in">id</span>, jobstore_alias, run_time,<br>                                            retval=retval))<br>            logger.info(<span class="hljs-string">&#x27;Job &quot;%s&quot; executed successfully&#x27;</span>, job)<br><br>    <span class="hljs-keyword">return</span> events<br></code></pre></td></tr></table></figure>



<h3 id="2-2-JobStore"><a href="#2-2-JobStore" class="headerlink" title="2.2 JobStore"></a>2.2 JobStore</h3><p>JobStore是apscheduler中的存储器,apscheduler为各种存储器做了封装,核心的JobStore比较简单,各个封装的功能都一样,只是具体逻辑跟对应的客户端相关.这里先以<code>MemoryJobStore</code>和<code>BaseJobStore</code>对JobStore的所有功能函数进行分析.</p>
<h4 id="2-2-1-MemoryJobStore和BaseJobStore"><a href="#2-2-1-MemoryJobStore和BaseJobStore" class="headerlink" title="2.2.1 MemoryJobStore和BaseJobStore"></a>2.2.1 MemoryJobStore和BaseJobStore</h4><ul>
<li>start<br>当apscheduler开始执行start或者job被添加到jobstores时,开始执行start,初始化scheduler以及jobstores的别名.</li>
<li>shutdown<br>关闭对应stores的客户端链接或者清理内存回收空间.</li>
<li>_fix_paused_jobs_sorting 返回没有<code>next_run_time</code>属性的任务(或者说暂停的任务)</li>
<li>lookup_job 获取指定任务id的任务</li>
<li>get_due_jobs  返回早于<code>next_run_time</code>或等于<code>now</code>的任务列表,返回的任务必须按<code>next_run_time</code>（升序）进行排序</li>
<li><a href="https://github.com/agronholm/apscheduler/blob/3.x/apscheduler/jobstores/memory.py#L33">get_next_run_time</a> 从存储器的所有job中获取最早运行的一个,由于在<code>MemoryJobStore</code>中对保存job的_jobs队列进行了排序维护,不管添加和删除都确保他是有序的,所以<code>MemoryJobStore</code>的<code>get_next_run_time</code>只要从_jobs[0]获取的job就是即将最早运行的job</li>
<li>get_all_jobs 从存储器中获取所有任务</li>
<li>add_job 向存储器添加任务</li>
<li>update_job 更新已经存储在存储器中的任务</li>
<li>remove_job 从存储器中删除指定的任务(根据job id)</li>
<li>remove_all_jobs 从存储器中删除所有任务</li>
<li><a href="https://github.com/agronholm/apscheduler/blob/3.x/apscheduler/jobstores/memory.py#L82">_get_job_index(<code>MemoryJobStore</code>特有方法)</a>  通过二分法查找快速查找job的索引，或者如果找不到索引，则根据给定的时间戳记将job插入的索引。</li>
</ul>
<h4 id="2-2-2-其他JobStore"><a href="#2-2-2-其他JobStore" class="headerlink" title="2.2.2 其他JobStore"></a>2.2.2 其他JobStore</h4><p>其他JobStore提供的功能也是与MemoryJobStore一样,但是由于各个存储容器/数据库不同,实现的逻辑都是不同,但原理还是一样的.Apschedulers除了MemoryJobStore外,通过把Job序列化存到JobStore中,使得job可以与add_job的进程分离,达到分布式调用的效果,但是由于每个Apschedulers并不会互相通信,所以可能存在多个Apschedulers获得到相同的Job,所以我们需要添加一个锁来解决该问题.</p>
<h3 id="2-3-schedulers"><a href="#2-3-schedulers" class="headerlink" title="2.3 schedulers"></a>2.3 schedulers</h3><p>schedulers是Apschedulers的调度器,负责Apschedulers的核心功能,所以在上面的<code>主体逻辑</code>中基本都说了,这里只说一些上面没提到的功能函数.</p>
<ul>
<li><p>状态</p>
<p>Apschedulers中提供以下三种状态，通过状态机切换状态使Apschedulers可以正确的启动停止，以及在<code>_process_jobs</code>中通过判断当前状态是否为<code>STATE_PAUSED</code>来实现暂停的功能</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">STATE_STOPPED</span> = <span class="hljs-number">0</span>  <span class="hljs-comment"># 停止</span><br><span class="hljs-attr">STATE_RUNNING</span> = <span class="hljs-number">1</span>  <span class="hljs-comment"># 运行</span><br><span class="hljs-attr">STATE_PAUSED</span> = <span class="hljs-number">2</span>   <span class="hljs-comment">#暂停</span><br></code></pre></td></tr></table></figure>
</li>
<li><p><code>_process_jobs</code><br>process_jobs函数为了处理job,函数比较长, 这里看实际代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_process_jobs</span>(<span class="hljs-params">self</span>):</span><br>    <span class="hljs-comment"># 如果是暂停状态,则暂停运行</span><br>    <span class="hljs-keyword">if</span> self.state == STATE_PAUSED:<br>        self._logger.debug(<span class="hljs-string">&#x27;Scheduler is paused -- not processing jobs&#x27;</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>  		<br>    self._logger.debug(<span class="hljs-string">&#x27;Looking for jobs to run&#x27;</span>)<br>    now = datetime.now(self.timezone)<br>    next_wakeup_time = <span class="hljs-literal">None</span><br>    events = []<br>  <br>    <span class="hljs-keyword">with</span> self._jobstores_lock:<br>        <span class="hljs-comment"># 获取存储job的jobstore</span><br>        <span class="hljs-keyword">for</span> jobstore_alias, jobstore <span class="hljs-keyword">in</span> six.iteritems(self._jobstores):<br>            <span class="hljs-keyword">try</span>:<br>                <span class="hljs-comment"># 从jobstore中获取满足条件的job list</span><br>                due_jobs = jobstore.get_due_jobs(now)<br>            <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>                <span class="hljs-comment"># 计算该jobstore至少需要n秒内唤醒一次</span><br>                self._logger.warning(<span class="hljs-string">&#x27;Error getting due jobs from job store %r: %s&#x27;</span>,<br>                                     jobstore_alias, e)<br>                retry_wakeup_time = now + timedelta(seconds=self.jobstore_retry_interval)<br>                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> next_wakeup_time <span class="hljs-keyword">or</span> next_wakeup_time &gt; retry_wakeup_time:<br>                    next_wakeup_time = retry_wakeup_time<br>  <br>                <span class="hljs-keyword">continue</span><br>  <br>            <span class="hljs-keyword">for</span> job <span class="hljs-keyword">in</span> due_jobs:<br>                <span class="hljs-keyword">try</span>:<br>                    <span class="hljs-comment"># 获取job的存储器</span><br>                    executor = self._lookup_executor(job.executor)<br>                <span class="hljs-keyword">except</span> BaseException:<br>                    self._logger.error(<br>                        <span class="hljs-string">&#x27;Executor lookup (&quot;%s&quot;) failed for job &quot;%s&quot; -- removing it from the &#x27;</span><br>                        <span class="hljs-string">&#x27;job store&#x27;</span>, job.executor, job)<br>                    <span class="hljs-comment"># 从存储器中移除掉job</span><br>                    self.remove_job(job.<span class="hljs-built_in">id</span>, jobstore_alias)<br>                    <span class="hljs-keyword">continue</span><br>    <span class="hljs-comment"># 获取job的运行时间</span><br>                run_times = job._get_run_times(now)<br>                run_times = run_times[-<span class="hljs-number">1</span>:] <span class="hljs-keyword">if</span> run_times <span class="hljs-keyword">and</span> job.coalesce <span class="hljs-keyword">else</span> run_times<br>                <span class="hljs-keyword">if</span> run_times:<br>                    <span class="hljs-keyword">try</span>:<br>                        <span class="hljs-comment"># 运行job</span><br>                        executor.submit_job(job, run_times)<br>                    <span class="hljs-keyword">except</span> MaxInstancesReachedError:<br>                        self._logger.warning(<br>                            <span class="hljs-string">&#x27;Execution of job &quot;%s&quot; skipped: maximum number of running &#x27;</span><br>                            <span class="hljs-string">&#x27;instances reached (%d)&#x27;</span>, job, job.max_instances)<br>                        <span class="hljs-comment"># 提交job运行实例过大的event</span><br>                        event = JobSubmissionEvent(EVENT_JOB_MAX_INSTANCES, job.<span class="hljs-built_in">id</span>,<br>                                                   jobstore_alias, run_times)<br>                        events.append(event)<br>                    <span class="hljs-keyword">except</span> BaseException:<br>                        self._logger.exception(<span class="hljs-string">&#x27;Error submitting job &quot;%s&quot; to executor &quot;%s&quot;&#x27;</span>,<br>                                               job, job.executor)<br>                    <span class="hljs-keyword">else</span>:<br>                        <span class="hljs-comment"># 提交job运行成功的event</span><br>                        event = JobSubmissionEvent(EVENT_JOB_SUBMITTED, job.<span class="hljs-built_in">id</span>, jobstore_alias,<br>                                                   run_times)<br>                        events.append(event)<br>  <br>                    <span class="hljs-comment"># 如果有下一个执行时间，则更新job，否则将job从jobstore中删除。</span><br>                    job_next_run = job.trigger.get_next_fire_time(run_times[-<span class="hljs-number">1</span>], now)<br>                    <span class="hljs-keyword">if</span> job_next_run:<br>                        job._modify(next_run_time=job_next_run)<br>                        jobstore.update_job(job)<br>                    <span class="hljs-keyword">else</span>:<br>                        self.remove_job(job.<span class="hljs-built_in">id</span>, jobstore_alias)<br>  <br>            <span class="hljs-comment"># 计算jobstore下次唤醒时间</span><br>            jobstore_next_run_time = jobstore.get_next_run_time()<br>            <span class="hljs-keyword">if</span> jobstore_next_run_time <span class="hljs-keyword">and</span> (next_wakeup_time <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">or</span><br>                                           jobstore_next_run_time &lt; next_wakeup_time):<br>                next_wakeup_time = jobstore_next_run_time.astimezone(self.timezone)<br>  <br>    <span class="hljs-comment"># 触发所有event</span><br>    <span class="hljs-keyword">for</span> event <span class="hljs-keyword">in</span> events:<br>        self._dispatch_event(event)<br>  <br>    <span class="hljs-comment"># 计算下次运行时间</span><br>    <span class="hljs-keyword">if</span> self.state == STATE_PAUSED:<br>        wait_seconds = <span class="hljs-literal">None</span><br>        self._logger.debug(<span class="hljs-string">&#x27;Scheduler is paused; waiting until resume() is called&#x27;</span>)<br>    <span class="hljs-keyword">elif</span> next_wakeup_time <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>        wait_seconds = <span class="hljs-literal">None</span><br>        self._logger.debug(<span class="hljs-string">&#x27;No jobs; waiting until a job is added&#x27;</span>)<br>    <span class="hljs-keyword">else</span>:<br>        wait_seconds = <span class="hljs-built_in">min</span>(<span class="hljs-built_in">max</span>(timedelta_seconds(next_wakeup_time - now), <span class="hljs-number">0</span>), TIMEOUT_MAX)<br>        self._logger.debug(<span class="hljs-string">&#x27;Next wakeup is due at %s (in %f seconds)&#x27;</span>, next_wakeup_time,<br>                           wait_seconds)<br>  <br>    <span class="hljs-keyword">return</span> wait_seconds<br></code></pre></td></tr></table></figure>
<h3 id="2-4-triggers"><a href="#2-4-triggers" class="headerlink" title="2.4 triggers"></a>2.4 triggers</h3><p>首先<code>BaseTrigger</code>提供一个触发器的基本方法,用于给<code>get_next_fire_time</code>添加抖动时间,防止大量任务在同一时间运行.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python">  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_apply_jitter</span>(<span class="hljs-params">self, next_fire_time, jitter, now</span>):</span><br>      <span class="hljs-keyword">if</span> next_fire_time <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> jitter:<br>          <span class="hljs-keyword">return</span> next_fire_time<br><br><span class="hljs-comment"># 主要的代码,通过随机选择+-jitter值与next_fire_time进行和运算</span><br>      next_fire_time_with_jitter = next_fire_time + timedelta(<br>              seconds=random.uniform(-jitter, jitter))<br><br>      <span class="hljs-keyword">if</span> next_fire_time_with_jitter &lt; now:<br>      	<span class="hljs-comment"># 如果新的时间值小于当前时间,则返回旧时间</span><br>          <span class="hljs-keyword">return</span> next_fire_time<br>      <span class="hljs-keyword">return</span> next_fire_time_with_jitter<br></code></pre></td></tr></table></figure>
<p>而其他细节比较简单,各种触发器都是按照设置的时间进行运行,如果能算出下次运行时间,则在运行后按照下次运行时间继续运行,算不出下次运行时间该job将停止运行</p>
<h3 id="2-5-job-py"><a href="#2-5-job-py" class="headerlink" title="2.5 job.py"></a>2.5 job.py</h3><p>job比较简单,主要是提供一些给scheduler调用的方法.<br>job的方法分为两大类,一类是类似于代理,通过调用scheduler的方法来修改自己本身,如<code>modify</code>,<code>reschedule</code>,<code>pause</code>,<code>resume</code>,<code>remove</code>.<br>这类方法比较简单,而且主要逻辑在于scheduler,不在于job,另外的就是主要逻辑在job的方法.如<code>__getstate__</code>以及<code>__setstate__</code>的序列化相关方法,同时还有一个<code>_modify</code>用来接受更新job的方法,虽然该方法很长,但主要逻辑也是各种判断再更新指</p>
</li>
</ul>
<h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3.总结"></a>3.总结</h2><p>表面上看APScheduler的代码会比较复杂,但经过拆解后,Apscheduler的代码除了scheduler的代码是非常简单的,主要是针对各种不同的运行环境而封装的代码比较多,导致在分析代码时,觉得这些代码经不起分析,但是APScheduler的核心设计还是很不错的.</p>
]]></content>
      <categories>
        <category>源码分析</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title>ELasticSearch优化设置</title>
    <url>/2020/02/28/Elasticsearch%E4%BC%98%E5%8C%96%E8%AE%BE%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="前记"><a href="#前记" class="headerlink" title="前记"></a>前记</h2><p>最近一直在接触ElasticSearch,非常好用,不过需要记的东西太多了,就把优化项记录下来</p>
<span id="more"></span>

<h2 id="1-ElasticSearch相关配置"><a href="#1-ElasticSearch相关配置" class="headerlink" title="1.ElasticSearch相关配置"></a>1.ElasticSearch相关配置</h2><ul>
<li><p>path.data: /var/lib/elasticsearch<br>别用来存放索引数据<br>path.data支持配置多个目录，每个目录都会用来存放数据，但是单个分片会存放在同一个目录内</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">path:<br>  data:<br>    - /dir/elasticsearch_1<br>    - /dir/elasticsearch_2<br>    - /dir/elasticsearch_3<br></code></pre></td></tr></table></figure></li>
<li><p>path.logs: /var/log/elasticsearch<br>用来存放运行日志</p>
</li>
<li><p>cluster.name: elasticsearch<br>集群名称,可以用来区分不同集群。每个节点需要配置相同的集群名才能加入同一个集群中，且每个节点只能加入一个集群。</p>
</li>
<li><p>node.name: so1n-node<br>节点名称,默认情况下节点名称是操作系统的主机名.</p>
</li>
<li><p>network.host: 127.0.0.1<br>默认配置下，Elasticsearch绑定的是一个环回地址<code>127.0.0.1</code> ，这只适合在单机开发时使用。在正式环境中，为了保证该节点能够被其它节点找到，形成一个集群，需要设置一个非环回地址.在内网中一般填写自己的内网ip</p>
</li>
<li><p>discovery.seed_hosts: [127.0.0.1, 10.0.0.1]<br>服务发现种子主机,用于本机可以去连接其他已经存在的机器,融入已有集群,<br>如果是在同一个机器上面部署多个实例,可以不用填写,Elasticsearch默认会从本机的9300-9305端口尝试去连接其它节点.<br>对于每个机器每个实例,一起创建集群时,每个机器都配置其他机器的ip,如果是向某集群添加新的机器,新的机器添加好集群已有机器ip即可.<br>discovery.seed_hosts可以是ip、ip:端口和域名。如果配置是ip，Elasticsearch默认会使用transport.profiles.default.port配置项的端口，该端口默认为9300；如果配置是域名，且该域名下绑定了多个ip，ES会尝试去连接多个ip。</p>
</li>
<li><p>cluster.initial_master_nodes: [“so1n-node”]<br>初始主节点列表,当开启一个全新的集群时，会有一个集群的引导步骤，这步骤用来确定哪些节点参与第一次的主节点选举,这些步骤会从初始主节点列表里面的节点协商出一个主节点.</p>
<h2 id="2-ElasticSearch相关优化配置"><a href="#2-ElasticSearch相关优化配置" class="headerlink" title="2.ElasticSearch相关优化配置"></a>2.ElasticSearch相关优化配置</h2></li>
<li><p>内存锁bootstrap.memory_lock: true<br>内存锁可以在ES启动时，锁住一段堆内存，保证堆内存的数据不会被挤到磁盘中(对应Linux中的mlockall 系统调用).</p>
</li>
<li><p>更改Refresh间隔index.refresh_interval: 1s<br>ELasticsearch是一个近实时的库,该参数会指引ELasticsearch间隔多少时间把数据写入,每次写入都需要使用大量io,如果对数据的及时性要求不高,可以通过增加时间间隔,提升机器性能,但是也意味着占用了更多heap,所以要确保机器的heap足够大.</p>
</li>
<li><p>提前加载数据到缓存 index.store.preload: [“nvd”,”dvd”]<br>机器重启时,缓存会被清空,设置index.store.preload后,可以告知系统可以把指定文件扩展名文件提早加载到缓存.<br>或者可以在创建索引的时候执行</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">PUT index<br>&#123;<br>    <span class="hljs-string">&quot;settings&quot;</span>:&#123;<br>        <span class="hljs-string">&quot;index.store.preload&quot;</span>:[<span class="hljs-string">&quot;nvd&quot;</span>,<span class="hljs-string">&quot;dvd&quot;</span>]<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>配置段合并indices.store.throttle.max_bytes_per_sec: 20mb<br>Lucene以段的形式存数据,当有新的数据写入到索引时,Lucene就会自动创建一个新的段,随着数据的增加,段的数量会越来越多,消耗的文件句柄数以及cpu也变大,导致查询效率下降.<br>而由于lucene段的合并会消耗i/o以及计算,所以默认的ES策略比较保守:</p>
<ul>
<li>当索引的写入效率下降时,也就是段的合并速度低于索引的写入速度,ES会把索引的写入线程数量减少到1.这样可以避免出现段数量的堆积,同时会打印<code>now throttling indexing</code>.</li>
<li>ES对段的合并默认速度为20m/s,这一值是针对机械硬盘设置的.<br>我们可以通过更该默认的段合并速度来提升段的合并速率,如:<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">PUT /_cluster/settings <br>&#123; <br>    <span class="hljs-string">&quot;persistent&quot;</span> : &#123; <br>        <span class="hljs-string">&quot;indices.store.throttle.max_bytes_per_sec&quot;</span> : <span class="hljs-string">&quot;100mb&quot;</span> <br>    &#125; <br>&#125; <br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>index_buffer_size 的设置<br>可以通过设置成百分数或者具体的大小(最多512mb),当大于这个值时会触发refresh</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">indices.memory.index_buffer_size：10%（默认）<br>indices.memory.min_index_buffer_size： 48mb（默认）<br>indices.memory.max_index_buffer_size: 512mb(默认)<br></code></pre></td></tr></table></figure></li>
<li><p>修改 translog 相关的设置<br>Flush 的主要目的是把缓存中的段持久化到硬盘，当 Translog 的数据量达到 512MB 或者 FLush间隔超过30 分钟时，会触发一次 Flush,可以通过更改</p>
<ul>
<li>index.translog.flush_threshold_size: 512mb</li>
<li>index.translog.sync_interval：5s</li>
<li>index.translog.durability:async  # 写入方式,async是异步写入<br>的值来决定Translog的数据量达到多少时才进行Flush的操作.不过值越大,也就意味着会占用更过的内存</li>
</ul>
</li>
<li><p>Cache<br>ES 提供了几种缓存,可以根据业务需求决定是否开启缓存和缓存大小</p>
<ul>
<li>QueryCache:使用fliter查询时的缓存,如果fliter查询比较多,则可以设置QueryCache缓存  <figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">indices.queries.cache.size： 10%（默认），//可设置成百分比，也可设置成具体值，如256mb。<br>index.queries.cache.enabled：<span class="hljs-literal">true</span>(默认开启QueryCache)<br></code></pre></td></tr></table></figure></li>
<li>FieldDataCache: 缓存聚合类运算或着排序的结果  <figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">indices.fielddata.cache.size：30%<br></code></pre></td></tr></table></figure></li>
<li>ShardRequestCache:缓存每个协调节点的聚合结果(只缓存 hits.total, aggregations, suggestions 类型的数据，并不会缓存hits的内容)  <figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">index.requests.cache.enable: <span class="hljs-literal">true</span><br>indices.requests.cache.size: 1%（默认）<br></code></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>推迟分片的分配<br>当节点瞬时中断是,默认情况下,集群会等待一分钟来查看节点是否会重新加入,如果在期间节点重新加入,这时节点会保持现有的分片数据,不会触发新的分片分配,可以减少es自动再平衡可用分片时带来的开销,可以通过如下设置,<code>_all</code>代表所有索引</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">PUT /_all/_settings <br>&#123;<br>  <span class="hljs-string">&quot;settings&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;index.unassigned.node_left.delayed_timeout&quot;</span>: <span class="hljs-string">&quot;5m&quot;</span> <br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>控制mapping</p>
<ul>
<li>尽量避免使用nested或 parent/child,或者控制nested fields字段的数量, 每一个nested field, 都会生成一个独立的document, 这将使Doc数量剧增，影响查询效率,es默认50</li>
<li>控制索引的字段数量</li>
<li>控制mapping深度<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">index.mapping.nested_fields.limit ：50 <span class="hljs-comment"># nested field数量限制</span><br>index.mapping.total_fields.limit:1000  <span class="hljs-comment"># 控制索引字段数量</span><br>index.mapping.depth.limit: 20  <span class="hljs-comment">#控制mapping深度</span><br></code></pre></td></tr></table></figure>
<h2 id="3-ElasticSearch-Client优化"><a href="#3-ElasticSearch-Client优化" class="headerlink" title="3.ElasticSearch Client优化"></a>3.ElasticSearch Client优化</h2>常用写入ElasticSearch有logstash以及自己利用ELasticSearch Restful API 编写的API,其中logstash基本是开箱即用,基本修改pipeline即可,详见<a href="http://so1n.me/2020/02/10/logstash%20Pipeline/#5-pipeline%E5%90%9E%E5%90%90%E9%87%8F%E4%BC%98%E5%8C%96">Logstash Pipeline</a>,ELasticSearch Restful API 相关优化见下面:</li>
</ul>
</li>
<li><p>字段类型可以使用keyword就使用keyword</p>
</li>
<li><p>对于不需要聚合和排序的索引字段禁用doc values<br>Doc Values 默认对所有字段启用，除了 analyzed strings,但我们有写字段可以不需要排序和聚合,而关闭了doc values后可以节省磁盘空间,同时会提升索引的速度.<br>设置mapping时,在想要禁用doc values的字段设置<code>doc_values: false</code>即可</p>
</li>
<li><p>使用Bulk Api提交数据<br>每次提交的数据量为多少时，能达到最优的性能，主要受到文件大小、网络情况、数据类型、集群状态等因素影响。<br>通用的策略如下：Bulk 默认设置批量提交的数据量不能超过 100M。数据条数一般是根据文档的大小和 服务器 性能而定的，但是单次批处理的数据大小应从 5MB～15MB 逐渐增加，当性能没有提升时，把这个数据量作为最大值。</p>
</li>
<li><p>使用scroll查询<br>在查询数据时,我们可以使用from+size来模拟分页,但是form查询时,每次都需要查询,聚合数据,再进行排序,最后返回[from, from + size]的size条数据.不能利用好上次查询的缓存.<br>为此ES提供了类似Redis的Scan的Scroll和Scroll-Scan两种查询模式:</p>
<ul>
<li>Scroll:第一次查询时,会先在分片上根据查询条件查询数据(Es默认限制search api搜索的数据最高为10000条, scroll也不例外,需要更改配置),然后协同节点聚合数据,合并,排序,并把数据缓存到内存,然后再返回部分数据和scorll_id,下次请求可以带上scorll_id参数获取下一段数据</li>
<li>Scroll-Scan: 与Scroll相似,但不会去计算文本相似度和排序,也不支持聚合操作,所以性能会更加高效.</li>
</ul>
</li>
</ul>
<p>**注: 由于Scroll和Scroll-Scan是根据第一次查询结果的数据缓存到内存,后面的数据增删改查都不能影响到查询的结果,所以后续的Scroll和Scroll-Scan请求操作都不是实时. **</p>
<ul>
<li>按时间间隔创建index<br>按照自己数据量的多少,设置一个月或者一天等一个索引<br>由于索引在创建后就无法更改分片和副本数量,除非进行重建索引操作,但重建索引操作会随着数据量的提升而变得耗时,同时处理好每个索引的时间间隔会更容易做优化,如对索引的merge.所以我们需要按照自己的数据量大小去设置索引,如果每天的数据量很大，则可以按天创建索引，如果是一个月积累起来导致数据量很大，则可以一个月创建一个索引。</li>
<li>如果没有需求,不要自定义id<br>如果客户端有自定义id,Elasticsearch会在数据传入时,检查该id文档是否已经存在于相同的分片中.这一操作会随着索引的量变多而更加消耗机器的性能</li>
<li>如果不需要查询数据本身,search请求中,query要设置size=0<br>例如我们只需要使用query的aggs查询时,我们就可以设置size=0,这样子ElasticSearch就不会把所有文档数据查出来,而只是按照aggs特性查询count</li>
<li>查询数据时,尽量使用具体时间<br>如果自己加了一层缓存层,那就可以不看此说明.<br>在查询时间范围时,我们一般会给日期字段设置now这类的参数,但这类查询一般是不会被缓存的.只有填写明确的时间参数,ELasticSearch才会对数据进行缓存.</li>
<li>调用search api时可以通过preference参数设置ELasticSearch的偏好查询<br>默认情况下,假设我们一个索引有a个shard和b个副本,当一个查询请求过来的时,a个shard的数据都会被查询，然后每个shard随机查询主shard或者replia.<ul>
<li>preference=_local<br>优先在本地节点上的分片查询数据,如果查询失败则去其他节点上的分片查询，本地节点没有IO问题但有可能造成负载不均问题;数据量是完整的。</li>
<li>preference=_only_local<br>仅在分配给本地节点的分片沙勋</li>
<li>preference=_primary<br>只在主分片查询,不查询副本数据,一般数据完整</li>
<li>preference=_primary_first<br>优先在主分片查询,如果主分片挂了则去副本查询,一般数据完整.</li>
<li>preference=_prefer_node<br>优先在指定的节点查询,一般数据完整.</li>
<li>preference=_shards<br>在指定分片中查询,数据可能不完整.该选项可以与其他的选项一起使用,如:_shards:2,3|_local</li>
<li>preference=_only_node<br>在指定id的节点中的分片查询,数据可能不完整</li>
<li>preference=_only_nodes<br>在自定的多个节点查询,可以使用通配符</li>
</ul>
</li>
<li>调整search api 的batched_reduce_size<br>默认情况下，聚合操作是在协调节点需要等待所有的分片都取回结果后才执行，使用batched_reduce_size参数可以不等待全部分片返回结果，而是在指定数量的分片返回结果只会就可以先处理一部分(reduce)。这样可以避免协调节点在等待全部结果的过程中占用大量内存，避免极端情况下可能导致的OOM。该字段默认值512.</li>
<li>查询时设置查询条件的Routing(需要配置好mapping)</li>
</ul>
<p><strong>注:需要配置好mapping,同时要注意由于配置routing导致分片不均的情况,需要把数据量小的routing合并成一个大的routing,或者多个维度组合成一个tag</strong><br>ES中有种类似于tag的东西,叫做路由,在创建文档的时候,可以给文档添加一个路由属性的tag,有了tag后,ES会有两个优化:<br>    - 拥有相同路由属性的文档,无论主分片还是副本,都会被分配到相同的一个分片上<br>    - 查询时,设置routing参数后,ES会直接定位到目标分片,避免查询到所有分片和经过协调节点的二次排序.<em>当没有设置routing参数,先依照协调节点的分配,查询所有分片,然后协调节点根据每个分片的搜索结果进行排序,再返回数据</em></p>
<h2 id="4-ELasticSearch所在机器相关优化配置"><a href="#4-ELasticSearch所在机器相关优化配置" class="headerlink" title="4.ELasticSearch所在机器相关优化配置"></a>4.ELasticSearch所在机器相关优化配置</h2><ul>
<li><p>设置堆内存(配置文件/etc/elasticsearhc/jvm.options)<br>  修改下面的两个参数再重启elasticsearch即可</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">-Xms2g <br>-Xmx2g <br></code></pre></td></tr></table></figure>
<p>默认情况下，Elasticsearch中JVM堆内存的最小值和最大值为1GB，在生产模式下，堆内存容量是非常重要的，需要确保Elasticsearch有足够的堆内存可用。我们可以在jvm.options 配置文件中，通过配置Xmx 和Xms项来决定JVM堆内存容量<br>配置的容量本身也取决于服务器的物理内存，Xmx 和Xms的值不超过物理内存的50%,因为除了给elasticsearch使用内存外,底层的Lucene也需要使用内存,最好是两个各占机器的一半内存(也要考虑机器上的其他服务),同时,最大可设置接近32GB，26GB是安全值</p>
</li>
<li><p>设置文件描述符大小<br>Linux默认配置下单个进程最大打开文件描述符数为1024,而elasticsearch在创建索引过程中会打开很多文件，导致一下子就超过linux默认的限制量<br>在/etc/security/limits.conf新增下面配置即可</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">elasticsearch - nofile 65535<br></code></pre></td></tr></table></figure>
<p>表示由用户elasticsearch打开的进程,最大的文件描述符为65535(由于linux是使用c 的非负数类型来表示可用文件描述符数,所以最大为65535)</p>
</li>
<li><p>禁止交换空间<br>有些Linux系统默认启动交换空间,对于一些程序(例如我的电脑在关闭时,可以把当前数据写入交换空间,下次启动后从交换空间读取数据到内存,这样子就可以避免每次打开都要启动一堆软件了),交换空间是非常有用的,但是对于elasticsearch来说,使用了交换空间后,读写速度会变得很慢,所以我们要对elasticsearch所在的服务器禁用交换空间</p>
<ul>
<li>临时禁用交换空间<br>在Linux上，可以执行命令:sudo swapoff -a 临时关闭操作系统交换空间</li>
<li>永久禁用交换空间(/etc/fstab)<br>TODO</li>
<li>配置swappiness<br>修改 /etc/sysctl.conf文件，设置vm.swappiness = 1，可以使Linux在一般情况下不使用交换空间,设置0可能引发OOM</li>
<li>使用内存锁<br>见1.ElasticSearch相关优化配置的内存锁部分</li>
</ul>
</li>
<li><p>设置线程<br>Elasticsearch中不同的操作有不同的线程池，为了确保Elasticsearch线程正常创建线程，需要设置操作系统的线程数限制。最小值为4096，可通过修改/etc/security/limits.conf来完成设置。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>ElasticSearch</tag>
        <tag>优化</tag>
      </tags>
  </entry>
  <entry>
    <title>2020plan</title>
    <url>/2020/02/26/2020plan/</url>
    <content><![CDATA[<h2 id="前记"><a href="#前记" class="headerlink" title="前记"></a>前记</h2><p>rm 2019plan.md<br>vi 2020plan.md</p>
<p>之所以不是像之前采用mv的形式,是因为今年的总结写的比较多,而且作为一个社畜,所关注的再也不局限于技术上面</p>
<span id="more"></span>

<h2 id="amp"><a href="#amp" class="headerlink" title="%$*&amp;^"></a>%$*&amp;^</h2><p>过去这一年(19), 是在社会完整滚爬的一年,校园有多简单,社会就有多复杂,本着一心想好好搞技术,却发现,技术人不能只囚禁在技术之内.</p>
<p>虽然这一年有点点错技能树,但总体上来说还是可以,技术上得到了更上一层的提升,最主要的不再是一个curd boy,会去涉猎一些基础服务,也会去参与架构的调研,而这些参与远比平时写写api的学的多.</p>
<p>杂记:每次都会想到第一次来公司面试时,我大佬问我以后想做什么,我思考了一会,我想做架构师.现在想想我那时候就像小时候老师问我,你以后的理想是什么,我答想做科学家一样,可惜的是,之后公司拆分,再也不是大佬带着了.</p>
<h2 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h2><p>这一年的代码质量有了质一般的飞跃,毕竟把 代码简洁之道,编写可读代码的艺术重构，改善既有代码的设计这几本书看了1,2遍,而且代码量也写的多,开始有了些手感,分层思想等有些已经被刻进脑海里.但最重要的反倒是觉得学会了代码之外的东西(代码能力也是需要提升的,主要是其他文章也有写了,这篇文章主要是年度总结,所以重点就放在代码外面,工作之上的).</p>
<ul>
<li>1.要汇报自己的工作,体现自己工作的价值,即使你去帮同事完成某件事,也要写入周报里</li>
</ul>
<p>老板最想看到的就是你的产出,你在单位时间内产出越多,你在他眼中也就是越有价值,而老板也不可能时时刻刻的去关注你做了什么.所以在写周报时,要详细的写出自己做了什么,对业务有什么帮助,有什么价值,同时在去帮助同事完成某些事时,也要写入工作报告里面.</p>
<ul>
<li>2.说明工作的价值</li>
</ul>
<p>做基础业务有一个很亏的点就是:做出来的东西,很难去衡量出他的价值,或者说他的价值没有办法像API那边改个接口或者参数一样,马上就能带来他的价值.</p>
<p>就像一开始公司的监控系统是使用zabbix,并和MySQL以及其他业务放在同一台服务器,除了单点缺乏容灾外,还很容易由于别的程序异常导致监控崩溃.但是部署起来却很容易,半天就能搞定一些普通的监控,并且服务器能发送异常的情况很低,可能只有1%.当在重新整理监控服务时,需要把业务和zabbix拆开,zabbix还要部署多台服务器,防止一台挂的情况,除此之外还需要迁移MySQL,这时候花费的时间可能需要2-3天,但在老板那边,他只是觉得监控还在正常的运行,之前部署只用了半天,这次的优化却需要几倍的时间,从表面上看起来收益还并不明显.那这时候就需要用幼儿园化的思想去阐明优化的意义,如果无法简单明了的说,那可以直接说收益就是N(N为监控出问题导致的损失,虽然可能有点严重,但作为程序员要相信如果程序上可能会出现一个bug,那么这个bug就一定会出现)</p>
<ul>
<li><p>3.在报告可能存在一个问题时,由于工作进度导致跳过,那这个问题一定要通过写在周报等可以查询的记录报告出来(项目开发中有issue报版类的除外).<br>国内公司都是用战术上的勤奋弥补战略上的不足,所以开发进度会比较快,会造成一些目前影响不严重的bug遗留在线上,而上级由于没有接触这片业务,或者预估这个bug不严重,想跳过一些bug,那这时候需要把这个bug的可能造成影响,影响程度发出来.当以后出现问题时,可以找到该记录,以便甩锅(逃)</p>
</li>
<li><p>4.及时跟老板表达自己的想法,如让你做你不想做的东西,或者表达可以帮忙自己擅长的.<br>在接需求时,如果有的选择的话,避免选到自己不想做的或者觉得自己并不合适去做的.要尽量去选择自己所擅长的,告知老板自己做这一块产出比较大(注:这并不代表不学尝试新的东西,例如后端领域从纯api开发到去尝试一些推送系统,网关系统这类型是可以去尝试的)</p>
</li>
<li><p>5.不要闷声不吭<br>在工作时需要多跟团队交流,特别是反馈自己做到哪里,有哪些需求可以去改进的.或者在写完一个api后,要去体验app中跟该api相关的对应功能,跟团队讨论是否可以改进优化等.</p>
<p>同时,多交流能增加自己的话语权,不然即使自己的建议很有用,但可能无法传到上级,或者无法被上级采纳,可能还会让自己去做一些没必要的加班</p>
</li>
<li><p>6.开会要记录好每一个需求,被分配到一个需求时,要确认好需求,包括与组员确认好需求</p>
<p>每一次开会都要好好记录,不要认为自己的脑子能记录到很多东西,最好是能边录音边记录.</p>
<p>同时,在领取需求时要确认自己需求的工期和组员的工期情况,特别是自己的任务需要先等别人完成才能启动的情况.</p>
<p>就像之前在写客户端时,老板给了一个需求,问我能不能一天内完成,我评估了工作量后发现可以在一天内完成,就回复可以在一天内完成.但是这个需求需要设计师先完成好设计,我在根据设计图写界面,结果由于设计有其他需求没完成,到了晚上才能把设计图发给我,而且设计图还因为太晚没法经过上级审阅.导致我白白通宵了一晚上去赶工这个需求.</p>
</li>
</ul>
<h2 id="经济"><a href="#经济" class="headerlink" title="经济"></a>经济</h2><p>之前一直认为纯走技术路,在技术路上面开花结果,就一定能过得很好.现在觉得实则不然,技术也是为一些东西服务的,同时由于最近爆发肺炎,我们永远不能单拼一个行业,需要有个类似于副业的东西,而且最好的不同的行业.目前觉得最适的就是经济类(入场做韭菜),一来觉得技术可以为经济服务,二来了解经济可以为自己做好财务规划,同时也能了解世界经济动向</p>
<h2 id="身体"><a href="#身体" class="headerlink" title="身体"></a>身体</h2><p>相比起去年一个月一次感冒发热,今年的身体好了很多了,果然好好休息和运用是有用的.<br>今年还收获到了switch和健身环,每天下班后都可以好好锻炼了.</p>
<p>接下来的一年还是保持每天都能运动,争取不再去熬夜Orz.</p>
<h2 id="编程"><a href="#编程" class="headerlink" title="编程"></a>编程</h2><p>由于今年下半年多了Flutter相关的项目,加班时间比较多,且需要从0开始学,c语言学到一半就停,今年继续把c学完.同时考虑到今年想去接触k8s等云原生领域(还可以趁机熟悉go,不止停留于基本知识),应该不会接触新的编程语言了</p>
<p>今年限制比较少,同时由于项目的需要,接触了更多时下流行的技术(如kafka,elk)和架构理念(如学习了别人的架构理念后去拓展了整个sip的架构)</p>
<h2 id="读书"><a href="#读书" class="headerlink" title="读书"></a>读书</h2><p>今年读的书越来越多了,数据库系统概念,算法导论,高性能mysql还是没看完,希望不要再鸽了.今年还是再看了一遍流畅的python,每多读一次就有多一次收获,这本书真好.</p>
<p>今年没想到的是读了许多计划之外的书,比如elasticsearch,ansible,prometheus等,这是去年计划里没有的(然而在公司里docker之类的还是没有用武之地…)</p>
<p>希望明年会读是书:</p>
<ul>
<li>UNIX网络编程卷1：套接字联网API（第3版）</li>
<li>编码:隐匿在计算机软硬件的背后</li>
<li>CPrimer Plus</li>
<li>数据密集型应用</li>
<li>重录一遍Tcp/ip详解</li>
<li>Linux System Programming中文版</li>
<li>恰如其分的软件架构</li>
<li>计算机网络-自顶向下(去年看一半T_T)</li>
</ul>
<h2 id="随心"><a href="#随心" class="headerlink" title="随心"></a>随心</h2><p>一直都在广东这边生活着,今年去了3个地方,每个地方的文化都很不一样,感触很多,还是多赚钱多出去走走,生活不止眼前的枸杞啊!!!</p>
<ul>
<li><p>重庆和长沙<br>今年终于去了重庆了,而且还是跟女朋友一起去的,虽然只有短短4天,但真的非常开心(火锅真香,我还想吃)<br>在去重庆的路上,还去了下长沙,长沙真是一个不夜城,作为臭豆腐死忠粉,终于可以在长沙打卡了.</p>
</li>
<li><p>上海<br>今年还由于去了Pycon上海主场,顺便逛了下上海,在Pycon上海主场见到了流畅的Python的作者和Flask框架的作者.还登上了上海中心,去了上海滩,目前去了最北的城市就是上海了….</p>
</li>
</ul>
<h2 id="main"><a href="#main" class="headerlink" title="main"></a>main</h2><p>今年以工作为主,多参加社区活动,多发表一些奇思妙想的代码,不再局限于工作内容.</p>
<p>好好珍惜时间,陪伴家人,好好珍惜时间,把握零碎时间去持续学习</p>
<p>只要干不死,就往死里干, all in!</p>
]]></content>
      <categories>
        <category>计划</category>
      </categories>
      <tags>
        <tag>计划</tag>
      </tags>
  </entry>
  <entry>
    <title>lgostash Pipeline</title>
    <url>/2020/02/10/logstash%20Pipeline/</url>
    <content><![CDATA[<h2 id="1-Logstash-Pipeline"><a href="#1-Logstash-Pipeline" class="headerlink" title="1.Logstash Pipeline"></a>1.Logstash Pipeline</h2><p>pipeline在logstash6.0后加入,有了pipeline这个机制后,我们可以只通过配置pipeline来控制logstash的input, filter, output</p>
<span id="more"></span>
<h3 id="1-1-logstash所在位置"><a href="#1-1-logstash所在位置" class="headerlink" title="1.1.logstash所在位置"></a>1.1.logstash所在位置</h3><p>目前很多都是使用beats收集各个项目的数据,并经过类似kafka等缓冲层,再由logstash接受处理数据再发到elastic(如下)<br>beats -&gt; [缓冲] -&gt;logstash -&gt; elasticsearch</p>
<h3 id="1-2为何需要Pipeling"><a href="#1-2为何需要Pipeling" class="headerlink" title="1.2为何需要Pipeling"></a>1.2为何需要Pipeling</h3><ul>
<li>条件地狱<br>在没有出现pipeline的时候,只能在input,filter,output配置多个if,else非常麻烦.<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">input &#123;<br>  beats &#123; port =&gt; 2333  tag =&gt; apache   &#125;<br>  beats &#123; port =&gt; 2233  tag =&gt; so1n   &#125;<br>&#125;<br>filter &#123;<br>   <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;apache&quot;</span> <span class="hljs-keyword">in</span> [tags] &#123;  <br>    dissect &#123; ... &#125;<br>   &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;so1n&quot;</span> <span class="hljs-keyword">in</span> [tags] &#123;  <br>    grok &#123; ... &#125;<br>   &#125;  <br>&#125;<br><span class="hljs-comment"># elasticsearch需要分别定义index等导致需要拆分</span><br>output &#123;<br>   <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;apache&quot;</span> <span class="hljs-keyword">in</span> [tags] &#123;  <br>    elasticsearch &#123; ... &#125;<br>   &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;so1n&quot;</span> <span class="hljs-keyword">in</span> [tags] &#123;  <br>    elasticsearch &#123; ... &#125;<br>   &#125;  <br>&#125;<br></code></pre></td></tr></table></figure></li>
<li>缺乏拥塞隔离<br>在logstash在同一段事件只能处理一件事情,效率比较低,当apache拥塞时,tag为so1n的数据无法被处理,会导致tag为 so1n的输入端压力也增加</li>
</ul>
<p>在pipeline没出现前可以通过在同一台机器上运行多个 Logstash 实例来解决，然后可以独立地管理这些实例。但是即使这样的解决方案也会产生其他问题,如:需要管理多个实例,每个 Logstash 的实例就会多出一个JVM,需要监视每个 Logstash 实例,而pipeline的出现就可以解决了这些问题</p>
<h2 id="2-Pipeline使用场景"><a href="#2-Pipeline使用场景" class="headerlink" title="2.Pipeline使用场景"></a>2.Pipeline使用场景</h2><h3 id="2-1-Distributor-Pattern-分发者模式"><a href="#2-1-Distributor-Pattern-分发者模式" class="headerlink" title="2.1.Distributor Pattern 分发者模式"></a>2.1.Distributor Pattern 分发者模式</h3><p>在一个 pipeline 处理输入，然后根据不同的数据类型再分发到对应的 Pipeline 去处理。这种模式的好处在于统一输入端口，隔离不同类型的处理配置文件，减少由于配置文件混合在一起带来的维护成本。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># /etc/logstash/pipelines.yml</span><br>- pipeline.id: main<br>  config.string: |<br>    input &#123; beats &#123; port =&gt; 2333 &#125; &#125;<br>    output &#123;<br>        <span class="hljs-keyword">if</span> [<span class="hljs-built_in">type</span>] == apache &#123;<br>          pipeline &#123; send_to =&gt; apache &#125;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> [<span class="hljs-built_in">type</span>] == system &#123;<br>          pipeline &#123; send_to =&gt; syslog &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          pipeline &#123; send_to =&gt; so1n &#125;<br>        &#125;<br>    &#125;<br>- pipeline.id: apache-processing<br>  config.string: |<br>    input &#123; pipeline &#123; address =&gt; apache &#125; &#125;<br>    filter &#123;<br>       <span class="hljs-comment"># ...</span><br>    &#125;<br>    output &#123;<br>      elasticsearch &#123; hosts =&gt; [es] &#125;<br>    &#125;<br>- pipeline.id: syslog-processing<br>  config.string: |<br>    input &#123; pipeline &#123; address =&gt; syslog &#125; &#125;<br>    filter &#123;<br>       <span class="hljs-comment"># ...</span><br>    &#125;<br>    output &#123;<br>      pipeline &#123; send_to =&gt; es &#125;<br>    &#125;<br>- pipeline.id: so1n-processing<br>    config.string: |<br>    input &#123; pipeline &#123; address =&gt; so1n &#125; &#125;<br>    output &#123; <br>      pipeline &#123; send_to =&gt; es &#125;<br>    &#125;<br>- pipeline.id: es<br>    config.string: |<br>    input &#123; pipeline &#123;address =&gt; es &#125; &#125;<br>    output &#123;<br>      elasticsearch &#123; ... &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>
<h3 id="2-2-Output-Isolator-Pattern-输出隔离模式"><a href="#2-2-Output-Isolator-Pattern-输出隔离模式" class="headerlink" title="2.2.Output Isolator Pattern 输出隔离模式"></a>2.2.Output Isolator Pattern 输出隔离模式</h3><p> Logstash 的一个 pipeline 可以配置多个 output，但是一旦某一个 output 出问题，会导致另一个 output 也无法处理新数据。而通过输出隔离模式可以完美解决这个问题。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># /etc/logstash/pipelines.yml</span><br>- pipeline.id: main<br>  config.string: |<br>    input &#123; beats &#123; port =&gt; 2333 &#125; &#125;<br>    output &#123; pipeline &#123; send_to =&gt; [es1, es2] &#125; &#125;<br>- pipeline.id: es1<br>  config.string: |<br>    input &#123; pipeline &#123; address =&gt; es1 &#125; &#125;<br>    output &#123; elasticsearch &#123; &#125; &#125;<br>- pipeline.id: es2<br>  config.string: |<br>    input &#123; pipeline &#123; address =&gt; es2 &#125; &#125;<br>    output &#123; elasticsearch &#123; &#125; &#125;<br></code></pre></td></tr></table></figure>
<p>通过输出到两个独立的 pipeline，解除es1和es2的相互的影响，比如 es1 出问题的时候，es2 依然可以正常处理数据，而且两个 pipeline 可以配置独立的队列来保障数据的完备性.</p>
<p>此外,如果把上面的输出改为filter,那么就可以把同一分输入数据克隆成两份,并分发给不通的filter进行处理输出.</p>
<h3 id="2-3Collector-Pattern-收集者模式"><a href="#2-3Collector-Pattern-收集者模式" class="headerlink" title="2.3Collector Pattern 收集者模式"></a>2.3Collector Pattern 收集者模式</h3><p>这个模式很简单,就是把不同地方的数据收集过来,并一起解析输出</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># /etc/logstash/pipelines.yml</span><br>- pipeline.id: beats<br>  config.string: |<br>    input &#123; beats &#123; port =&gt; 2333 &#125; &#125;<br>    output &#123; pipeline &#123; send_to =&gt; [so1n] &#125; &#125;<br>- pipeline.id: kafka<br>  config.string: |<br>    input &#123; kafka &#123; ... &#125; &#125;<br>    output &#123; pipeline &#123; send_to =&gt; [so1n] &#125; &#125;<br>- pipeline.id: so1n<br>  config.string: |<br>    input &#123; pipeline &#123; address =&gt; so1n &#125; &#125;<br>    filter &#123;<br>      <span class="hljs-comment"># ...</span><br>    &#125;<br>    output &#123; elasticsearch &#123; &#125; &#125;<br></code></pre></td></tr></table></figure>
<h2 id="3-如何更好的搭配使用"><a href="#3-如何更好的搭配使用" class="headerlink" title="3.如何更好的搭配使用"></a>3.如何更好的搭配使用</h2><p>上面多种模式其实都很简单,官方定义了这些模式也就是跟大家说 可以灵活的编写配置文件,通过pipeline可以更好的解耦和复用,如何使用还是看实际的使用场景<br>目前很多人用了beats -&gt; [缓冲] -&gt;logstash -&gt; elasticsearch这种结构,那我们可以利用beats中的metadate特性来创建es的index,让所有的输出都可以输出到同一个es,其他的只要编辑filter就可以了,如果 公司里大部分业务数据命名是差不多的,可能只有一点点不太一样,那也可以合并到一个filter,不必去写更多的filter</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">- pipeline.id: beats-server<br>  config.string: |<br>    input &#123; beats &#123; port =&gt; 5044 &#125; &#125;<br>    output &#123;<br>      <span class="hljs-keyword">if</span> [fields][custom_field] == <span class="hljs-string">&quot;so1n1&quot;</span> &#123;<br>        pipeline &#123; send_to =&gt; so1n &#125;<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> [fields][custom_field] == <span class="hljs-string">&quot;so1n2&quot;</span> &#123;<br>        pipeline &#123; send_to =&gt; so1n &#125;<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> [fields][custom_field] == <span class="hljs-string">&quot;other&quot;</span> &#123;<br>        pipeline &#123; send_to =&gt; other &#125;<br>      &#125;<br>    &#125;<br><br>- pipeline.id : so1n<br>  config.string: |<br>    input &#123; pipeline &#123; address =&gt; so1n &#125; &#125; <br>    filter &#123;<br>      json &#123;<br>        <span class="hljs-built_in">source</span> =&gt; <span class="hljs-string">&quot;json_dumps&quot;</span><br>      &#125;<br>      geoip &#123;<br>        <span class="hljs-built_in">source</span> =&gt; <span class="hljs-string">&quot;clientip&quot;</span><br>      &#125; <br>    &#125;<br>    output &#123; pipeline &#123; send_to =&gt; es &#125;&#125;<br><br>- pipeline.id : other<br>  config.string: |<br>    input &#123; pipeline &#123; address =&gt; other &#125; &#125; <br>    filter &#123;<br>      <span class="hljs-comment"># ....</span><br>    &#125;<br>    output &#123; pipeline &#123; send_to =&gt; es &#125;&#125;<br><br>- pipeline.id: es<br>  config.string: |<br>    input &#123; pipeline &#123; address =&gt; es &#125;&#125;<br>    output &#123;<br>      elasticsearch &#123;<br>        hosts =&gt; [....]<br>        index =&gt; <span class="hljs-string">&quot;%&#123;[@metadata][beat]&#125;-%&#123;+YYYY.MM.dd&#125;&quot;</span><br>      &#125;<br>    &#125;<br><br></code></pre></td></tr></table></figure>
<h2 id="4-queue-让logstash优雅关闭"><a href="#4-queue-让logstash优雅关闭" class="headerlink" title="4.queue 让logstash优雅关闭"></a>4.queue 让logstash优雅关闭</h2><p>默认情况下logstash会将在处在pipeline各个stage的event buffer在内存中, 这种buffer方式,在logstash意外down掉的情况下会丢失数据,因此引入了Persisted queue这个用来持久化数据,防止logstash  down掉时数据丢失.</p>
<h3 id="4-1queue位置"><a href="#4-1queue位置" class="headerlink" title="4.1queue位置"></a>4.1queue位置</h3><p>queue的位置示意: input → queue → filter + output</p>
<p>当event从input写到queue成功后, 会发送ack给给数据源,会把数据写入本地文件, 当对应的filter和output都处理完event后,该event才会被标记为acknowleged/ACKed,并把对应数据从本地文件删除, 比如, 当grok完后,并发送个ES收到成功响应后, event才会被标记为成功处理.如果logstash意外down机, 那些未被标记为ACKed的事件会被重新处理.</p>
<h3 id="4-2-queue参数"><a href="#4-2-queue参数" class="headerlink" title="4.2 queue参数"></a>4.2 queue参数</h3><ul>
<li><strong>queue.type: persisted</strong>  persisted为持久化数据,默认是写入到内存</li>
<li><strong>path.queue: /usr/share/logstash/data</strong>  队列存储路径；如果队列类型为persisted时生效</li>
<li><strong>queue.page_capacity: 250mb</strong> 队列为持久化，单个队列大小</li>
<li><strong>queue.max_events: 0</strong>  当启用持久化队列时，队列中未读事件的最大数量，0为不限制</li>
<li>**queue.max_bytes: 1024mb **队列最大容量</li>
<li>**queue.checkpoint.writes: 1024 **在启用持久队列时强制执行检查点之前的最大数量的写入事件，0为不限制</li>
<li>**queue.checkpoint.interval: 1000 **当启用持久队列时，在头页面上强制一个检查点的时间间隔</li>
<li><strong>queue.drain:</strong>  指示logstash在关闭之前是否需要将queue中的数据处理. 一般queue不大且堆积的event数量不大的情况下可以开启, 不然耗时时间会太长</li>
</ul>
<h2 id="5-pipeline吞吐量优化"><a href="#5-pipeline吞吐量优化" class="headerlink" title="5.pipeline吞吐量优化"></a>5.pipeline吞吐量优化</h2><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">pipeline.workers: 8        <span class="hljs-comment"># pipeline线程数，官方建议是等于CPU内核数,命令行参数为-w</span><br>pipeline.output.workers: 8 <span class="hljs-comment"># 实际output时的线程数</span><br>pipeline.batch.size: 3000  <span class="hljs-comment"># 默认为125,当存入的事件数大于该值时则发送数据</span><br>pipeline.batch.delay: 5    <span class="hljs-comment"># 每隔一段时间,发送数据</span><br></code></pre></td></tr></table></figure>
<p>pipeline的配置没有queue那么多,同时上面两个线程数的基本可以不用配置,只关注后两个pipeline.batch*相关的参数即可.这两个参数只要其中一个满足就调用es的api接口发送数据到es.<br>根据自己的实时性去调节两个数字的大小,如果发现es写入有瓶颈,可以调大两个参数.<br>其中发现是否写入瓶颈可以如下操作:</p>
<ul>
<li>查看logstash是否有retrying failed action with response code: 429字样的日志</li>
<li>查看es, 可以在kibanan的控制台输入<code>GET _nodes/stats/thread_pool?pretty</code>,看node -&gt; thread_pool -&gt; bulk 查看threads和active,active越接近threads则证明越接近写入瓶颈</li>
</ul>
]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>中间件</tag>
        <tag>Logstash</tag>
      </tags>
  </entry>
  <entry>
    <title>Python的Dict实现</title>
    <url>/2019/12/16/Python%E7%9A%84Dict%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h2 id="前记"><a href="#前记" class="headerlink" title="前记"></a>前记</h2><p>在<code>Python</code>中, Dict是一系列由键和值配对组成的元素的集合, 它是一个可变容器模型，可以存储任意类型对象. Dict的存取速度非常的快, 而这全靠他的哈希算法的功劳, 在<code>Python</code>3.6之前Dict是无序的, 在<code>Python</code>3.6中绝大部分是有序的, 在<code>Python</code>3.7以及之后则是绝对有序的, 而且占用内存空间更少, 对于万物基于Dict的<code>Python</code>,这算一个大优化, 也让我好奇<code>Python</code>是如何实现哈希有序的.</p>
<span id="more"></span>

<h2 id="1-Dict的实现"><a href="#1-Dict的实现" class="headerlink" title="1.Dict的实现"></a>1.Dict的实现</h2><p>Dict在查找key时非常的快， 这得益于它的使用空间换时间思路和哈希实现。的在读取和写入Key时， 都会对Key进行哈希计算(所以要求Key都是不可变类型，如果是可变类型，就无法计算出他的哈希值了), 然后根据计算的值, 与当前的数组空间长度进行取模计算, 得到的值就是当前Key在数组的下标, 最后通过下标就可以以O(1)的时间复杂度读取值. 这种实现非常棒, 也是分布式的常见做法, 但也有问题, 如果数组满了怎么办或者是不同的Key, 但是哈希结果是一样的怎么办?</p>
<p>针对第一个问题的解决办法是在合适的时候进行扩容, 在<code>Python</code>中, 当Dict中放置的数量占容量的2/3时, Dict就会开始扩容, 扩容后的总容量是扩容之前的一倍, 这是为了减少频繁扩容， 导致key的迁移次数变多;</p>
<p>而针对第二个问题则有两个解法:</p>
<ul>
<li><p>链接法: 原本数组里面存的是Key对应的值, 而链接法的数组存的是一个数组, 这个数组存了一个包含key和对应值的数组, 如下所示, 假设key1和key2的哈希结果都是0, 那就会插入到数组的0下标中, key1在0下标的数组的第一位, 而key2在插入时,发现已经存在key1了, 再用key2与key1进行对比, 发现它们的key其实是不一样的, 那就在0下标进行追加.</p>
  <figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python">array = [<br>    [<br>       <span class="hljs-comment"># 分别为key, hash值， 数值</span><br>        (<span class="hljs-string">&#x27;key1&#x27;</span>, <span class="hljs-number">123</span>, <span class="hljs-number">123</span>),<br>        (<span class="hljs-string">&#x27;key2&#x27;</span>, <span class="hljs-number">123</span>, <span class="hljs-number">123</span>)<br>    ],<br>    [<br>        (<span class="hljs-string">&#x27;key3&#x27;</span>, <span class="hljs-number">123</span>, <span class="hljs-number">123</span>)<br>    ]<br>]<br></code></pre></td></tr></table></figure>
</li>
<li><p>开发寻址法: 开发寻址法走的是另外一个思路, 采取借用的思想, 在插入数据时， 如果遇到了冲突那就去使用当前下标的下一位, 如果下一位还是冲突, 就继续用下一位.在查找数据时则会对哈希值对应的key进行比较， 如果有值且对不上就找下一位， 直到或者空位找到为止。</p>
</li>
</ul>
<p>上面两个的方案的实现都很简单, 对比下也很容易知道他们的优缺点:</p>
<ul>
<li>链表法的优点:<ul>
<li>删除记录方便, 直接处理数组对应下标的子数组即可.</li>
<li>平均查找速度快, 如果冲突了, 只需要对子数组进行查询即可</li>
</ul>
</li>
<li>链表法的缺点:<ul>
<li>用到了指针, 导致了查询速度会偏慢一点, 内存占用可能会较高, 不适合序列化.<br>而开放寻址法的优缺点是跟链表法反过来的, 由于Python万物基于Dict, 且都需要序列化, 所以选择了开放寻址法. </li>
</ul>
</li>
</ul>
<p>通过对比链表法和开放寻执法都可以发现, 他们都是针对哈希冲突的一个解决方案, 如果存数据的数组够大, 那么哈希冲突的可能性就会很小, 不用频繁扩容迁移数据, 但是占用的空间就会很大.所以一个好的哈希表实现初始值都不能太大, 在<code>Python</code>的Dict的初始值是8.<br>另外哈希表还需要让存数据的数组的未使用空位保持在一个范围值内波动, 这样空间的使用和哈希冲突的概率都会保持在一个最优的情况, 但由于每次扩容都会消耗很大的性能, 也不能每次更改都进行一次扩容, 所以需要确定一个值, 当未使用/使用的占比达到这个值时, 就自动扩容, 在<code>Python</code>的Dict中这个值是2/3. 也就是当Dict里面使用了2/3的空间后, 他就会自动扩容, 使他达到一个新的最优平衡. 同时, 为了减少每次扩容时key的迁移次数, 扩容后的总容量一定是扩容之前的总容量的一倍, 这样的话, key只需要迁移一半的数量即可.</p>
<blockquote>
<p>哈希表扩容一倍只会迁移一半的key的原因是获取key在数组的下标是通过对哈希值取模实现的， 比如一个哈希表容量为8，一个哈希值为20的key取模值为4，哈希表扩容后长度变为16， 此时取模结果还是4。而一个哈希值为11的key取模值为3， 扩容后取模值为11。可以很明显的看出，扩容后原来哈希值大于容量的key都不用做迁移， 而哈希值小于容量的都需要迁移。</p>
</blockquote>
<p>但是如果按照上面是说法, 开放寻址法还是有一个问题的, 比如下面的数组:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python">arrray = [<span class="hljs-literal">None</span>, <span class="hljs-literal">None</span>, <span class="hljs-literal">None</span>, <span class="hljs-literal">None</span>, <span class="hljs-literal">True</span>, <span class="hljs-literal">True</span>, <span class="hljs-literal">True</span>, <span class="hljs-literal">True</span>]<br></code></pre></td></tr></table></figure>
<p>以True代表当前数组的位置已经被占用, None代表未被占用, 可以看出当前并未满足使用了数组的2/3空间, 数组还未到扩容阶段。 此时假设要插入一个Key, 刚好落在数组下标4, 那么插入的时候就要一直查询下去, 最后发现只有数组下标0的位置的空的, 才可以真正的插入数据. 对于一个长度只有8的数组, 需要执行5次才能插入数据, 那也太浪费性能了, 所以<code>Python</code>要实现一个算法, 尽量让冲突的数据插在别的地方.<br>在源码中, <code>Python</code>用到了公式<code>x = ((5*y) + 1) % 2**i</code>来实现跳跃插入冲突数据. 式子中x为数组的下一个坐标, y为当前发生冲突的坐标,i为容量系数, 比如初始化时, i为3, 那么容量就是8了,<br>第一次插入数据到坐标0冲突时, y = 0, 带入公式后, 求得x 等于1, 第二次插入数据到坐标0时, y = 1, 求得x 等于 6, 通过这样算下去, 可以发现数字生成轨迹是0&gt;1&gt;6&gt;7&gt;4&gt;5&gt;2&gt;3&gt;0一直循环着, 这样跳着插数据就能完美解决上面场景的问题.</p>
<h2 id="2-有序字典的原理"><a href="#2-有序字典的原理" class="headerlink" title="2.有序字典的原理"></a>2.有序字典的原理</h2><p><code>Python</code>3.6之前说的差不多, 它的数组大概是长这样的, 数组中存了子数组, 第一项为hash值, 第二项为key, 第三项为值.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python">array = [<br>    [],<br>    [<span class="hljs-number">123456</span>, <span class="hljs-string">&quot;key1&quot;</span>, <span class="hljs-number">1</span>],<br>    [],<br>    [],<br>    [],<br>    [<span class="hljs-number">234567</span>, <span class="hljs-string">&quot;key2&quot;</span>, <span class="hljs-number">2</span>],<br>    [],<br>    []<br>]<br></code></pre></td></tr></table></figure>
<p>这种实现的空间大小在初始化时就固定了, 直到下次扩容再发送变化, 在遍历字典时, 实际上就是遍历数组, 只是把没有占用的空间进行跳过.可以看出这种遍历的生成的顺序只跟哈希结果相关, 无法跟插入顺序相关, 所以这种方法的实现是无序的(同时由于每次启动程序时， 他们的哈希计算是不一样的， 所以每次遍历的顺序也就各不相同了).</p>
<p>而在<code>Python</code>3.7之后, <code>Python</code>的Dict使用了新的数据结构, 使<code>Python</code>新Dict的内存占用也比老的Dict少了, 同时新的Dict在遍历时是跟插入顺序是一致的, 具体的实现是, 初始化时会生成两个数组, 插入值时, 在数组二追加当前的数据, 并获得当前追加数据所在的下标A, 然后对key进行哈希取模算出下标B, 最后对数组下标B的值更新为A, 简单的演示如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-comment"># 初始的结构</span><br><span class="hljs-comment"># -1代表还未插入数据</span><br>array_1 = [-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>]<br>array_2 = []<br><br><br><span class="hljs-comment"># 插入值后, 他就会变为:</span><br>array_1 = [-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>]<br>array_2 = [<br>    [<span class="hljs-number">123456</span>, <span class="hljs-string">&quot;key1&quot;</span>, <span class="hljs-number">1</span>],<br>    [<span class="hljs-number">234567</span>, <span class="hljs-string">&quot;key2&quot;</span>, <span class="hljs-number">2</span>],<br>]<br></code></pre></td></tr></table></figure>
<p>可以看出, 数组2的容量跟当前放入的值相等的, 数组1虽然还会保持1/3的空闲标记位, 但他只保存数组二的下标, 占用空间也不多, 相比之前的方案会节省一些空间, 同时在遍历的时候可以直接遍历数组2, 这样<code>Python</code>的Dict就变为有序的了.<br>注: 为了保持操作高效, 在删除的时候, 只是把数组1的值设置为-2, 并把数组2对应的值设置为None, 而不去删除它, 在查找时会忽略掉数组1中值为-2的元素， 在遍历时会忽略掉值为None的元素.</p>
<h2 id="3-有序字典的实现"><a href="#3-有序字典的实现" class="headerlink" title="3.有序字典的实现"></a>3.有序字典的实现</h2><p>通过上面的了解后, 可以使用<code>Python</code>来写一个新版Dict的实现, 具体说明见注释:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> Any, Iterable, List, Optional, Tuple<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomerDict</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        self._init_seed: <span class="hljs-built_in">int</span> = <span class="hljs-number">3</span>  <span class="hljs-comment"># 容量因子</span><br>        self._init_length: <span class="hljs-built_in">int</span> = <span class="hljs-number">2</span> ** self._init_seed  <span class="hljs-comment"># 初始化数组大小</span><br>        self._load_factor: <span class="hljs-built_in">float</span> = <span class="hljs-number">2</span> / <span class="hljs-number">3</span>  <span class="hljs-comment"># 扩容因子</span><br>        self._index_array: List[<span class="hljs-built_in">int</span>] = [-<span class="hljs-number">1</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(self._init_length)]  <span class="hljs-comment"># 存放下标的数组</span><br>        self._data_array: List[Optional[Tuple[<span class="hljs-built_in">int</span>, Any, Any]]] = []  <span class="hljs-comment"># 存放数据的数组</span><br>        self._used_count: <span class="hljs-built_in">int</span> = <span class="hljs-number">0</span>  <span class="hljs-comment"># 目前用的量</span><br>        self._delete_count: <span class="hljs-built_in">int</span> = <span class="hljs-number">0</span>  <span class="hljs-comment"># 被标记删除的量</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_create_new</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;扩容函数&quot;&quot;&quot;</span><br>        self._init_seed += <span class="hljs-number">1</span>  <span class="hljs-comment"># 增加容量因子</span><br>        self._init_length = <span class="hljs-number">2</span> ** self._init_seed<br>        old_data_array: List[Tuple[<span class="hljs-built_in">int</span>, Any, Any]] = self._data_array<br>        self._index_array: List[<span class="hljs-built_in">int</span>] = [-<span class="hljs-number">1</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(self._init_length)]<br>        self._data_array: List[Tuple[<span class="hljs-built_in">int</span>, Any, Any]] = []<br>        self._used_count = <span class="hljs-number">0</span><br>        self._delete_count = <span class="hljs-number">0</span><br><br>        <span class="hljs-comment"># 这里只是简单实现, 实际上只需要搬运一半的数据</span><br>        <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> old_data_array:<br>            <span class="hljs-keyword">if</span> item <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>                self.__setitem__(item[<span class="hljs-number">1</span>], item[<span class="hljs-number">2</span>])<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_get_next</span>(<span class="hljs-params">self, index: <span class="hljs-built_in">int</span></span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;计算冲突的下一跳，如果下标对应的值冲突了, 需要计算下一跳的下标&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">return</span> ((<span class="hljs-number">5</span>*index) + <span class="hljs-number">1</span>) % self._init_length<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_core</span>(<span class="hljs-params">self, key: Any, default_value: Optional[Any] = <span class="hljs-literal">None</span></span>) -&gt; Tuple[int, Any, int]:</span><br>        <span class="hljs-string">&quot;&quot;&quot;获取数据或者得到可以放新数据的方法, 返回值是index_array的索引, 数据, data_array的索引&quot;&quot;&quot;</span><br>        index: <span class="hljs-built_in">int</span> = <span class="hljs-built_in">hash</span>(key) % (self._init_length - <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>            data_index: <span class="hljs-built_in">int</span> = self._index_array[index]<br>            <span class="hljs-comment"># 如果是-1则代表没有数据</span><br>            <span class="hljs-keyword">if</span> data_index == -<span class="hljs-number">1</span>:<br>                <span class="hljs-keyword">break</span><br>            <span class="hljs-comment"># 如果是-2则代表之前有数据则不过被删除了</span><br>            <span class="hljs-keyword">elif</span> data_index == -<span class="hljs-number">2</span>:<br>                index = self._get_next(index)<br>                <span class="hljs-keyword">continue</span><br><br>            _, new_key, default_value = self._data_array[data_index]<br>            <span class="hljs-comment"># 判断是不是对应的key</span><br>            <span class="hljs-keyword">if</span> key != new_key:<br>                index = self._get_next(index)<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">break</span><br>        <span class="hljs-keyword">return</span> index, default_value, data_index<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__getitem__</span>(<span class="hljs-params">self, key: Any</span>) -&gt; Any:</span><br>        _, value, data_index = self._core(key)<br>        <span class="hljs-keyword">if</span> data_index == -<span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">raise</span> KeyError(key)<br>        <span class="hljs-keyword">return</span> value<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__setitem__</span>(<span class="hljs-params">self, key: Any, value: Any</span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        <span class="hljs-keyword">if</span> (self._used_count / self._init_length) &gt; self._load_factor:<br>            self._create_new()<br>        index, _, _ = self._core(key)<br><br>        self._index_array[index] = self._used_count<br>        self._data_array.append((<span class="hljs-built_in">hash</span>(key), key, value))<br>        self._used_count += <span class="hljs-number">1</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__delitem__</span>(<span class="hljs-params">self, key: Any</span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        index, _, data_index = self._core(key)<br>        <span class="hljs-keyword">if</span> data_index == -<span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">raise</span> KeyError(key)<br>        self._index_array[index] = -<span class="hljs-number">2</span><br>        self._data_array[data_index] = <span class="hljs-literal">None</span><br>        self._delete_count += <span class="hljs-number">1</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__len__</span>(<span class="hljs-params">self</span>) -&gt; int:</span><br>        <span class="hljs-keyword">return</span> self._used_count - self._delete_count<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__iter__</span>(<span class="hljs-params">self</span>) -&gt; Iterable:</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">iter</span>(self._data_array)<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__str__</span>(<span class="hljs-params">self</span>) -&gt; str:</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">str</span>(&#123;item[<span class="hljs-number">1</span>]: item[<span class="hljs-number">2</span>] <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> self._data_array <span class="hljs-keyword">if</span> item <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>&#125;)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">keys</span>(<span class="hljs-params">self</span>) -&gt; List[Any]:</span><br>        <span class="hljs-string">&quot;&quot;&quot;模拟实现keys方法&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">return</span> [item[<span class="hljs-number">1</span>] <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> self._data_array <span class="hljs-keyword">if</span> item <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>]<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">values</span>(<span class="hljs-params">self</span>) -&gt; List[Any]:</span><br>        <span class="hljs-string">&quot;&quot;&quot;模拟实现values方法&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">return</span> [item[<span class="hljs-number">2</span>] <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> self._data_array <span class="hljs-keyword">if</span> item <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>]<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">items</span>(<span class="hljs-params">self</span>) -&gt; List[Tuple[Any, Any]]:</span><br>        <span class="hljs-string">&quot;&quot;&quot;模拟实现items方法&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">return</span> [(item[<span class="hljs-number">1</span>], item[<span class="hljs-number">2</span>]) <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> self._data_array <span class="hljs-keyword">if</span> item <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>]<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    customer_dict: CustomerDict = CustomerDict()<br>    customer_dict[<span class="hljs-string">&quot;demo_1&quot;</span>] = <span class="hljs-string">&quot;a&quot;</span><br>    customer_dict[<span class="hljs-string">&quot;demo_2&quot;</span>] = <span class="hljs-string">&quot;b&quot;</span><br>    <span class="hljs-keyword">assert</span> <span class="hljs-built_in">len</span>(customer_dict) == <span class="hljs-number">2</span><br><br>    <span class="hljs-keyword">del</span> customer_dict[<span class="hljs-string">&quot;demo_1&quot;</span>]<br>    <span class="hljs-keyword">del</span> customer_dict[<span class="hljs-string">&quot;demo_2&quot;</span>]<br>    <span class="hljs-keyword">assert</span> <span class="hljs-built_in">len</span>(customer_dict) == <span class="hljs-number">0</span><br><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">30</span>):<br>        customer_dict[i] = i<br>    <span class="hljs-keyword">assert</span> <span class="hljs-built_in">len</span>(customer_dict) == <span class="hljs-number">30</span><br><br>    customer_dict_value_list: List[Any] = customer_dict.values()<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">30</span>):<br>        <span class="hljs-keyword">assert</span> i == customer_dict[i]<br><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">30</span>):<br>        <span class="hljs-keyword">assert</span> customer_dict[i] == i<br>        <span class="hljs-keyword">del</span> customer_dict[i]<br>    <span class="hljs-keyword">assert</span> <span class="hljs-built_in">len</span>(customer_dict) == <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>linux日志规则</title>
    <url>/2019/12/05/linux%E6%97%A5%E5%BF%97%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h2 id="前记"><a href="#前记" class="headerlink" title="前记"></a>前记</h2><p>最近系统上出现部分日志丢失的情况,为了解决这个问题,开始了解Linux的日志结构和机制。以下是我的学习总结, 主要涉及到了如何发送日志， 怎么处理日志以及怎么管理日志。<br>注:由于这些应用都是需要用配置去改良或者指导他们如何去做,所以除了简述Linux的结构和功能外,更多的是如何去配置他们。但其中最重要的是了解整个日志记录的机制,以及通过配置去了解这套机制会如何去限制日志的记录以及优化传输,这样我们才能去灵活使用他们。</p>
<span id="more"></span>
<h2 id="1-Linux中日志的发送流程"><a href="#1-Linux中日志的发送流程" class="headerlink" title="1.Linux中日志的发送流程"></a>1.Linux中日志的发送流程</h2><p>一般来说， 我们所写的Web应用的日志都是直接打开一个文件， 然后把日志信息写到这个文件中。 这样非常方便, 但是缺少了一个统一的定义和管理, 所以Linux中就使用了一套稳定的日志管理系统–<code>rsyslog</code>。 它可以接收应用程序通过socket发送过来的日志数据， 然后按照规则非常方便的过滤和分发日志, 同时它也支持稳定的把所有日志从某台机器发送到另外一台机器， 不漏一条消息。</p>
<p>那么这整套机制是怎么运行的呢， 先看看一个本机应用程序发送日志， 本机rsyslog接收日志的流程图：</p>
<blockquote>
<p>注:操作系统为debain7, 该流程图以本地发送, 本地接受为例。</p>
</blockquote>
<p><img    class="lazyload" data-original="https://github.com/so1n/so1n_blog_photo/blob/master/blog_photo/Linux%E6%97%A5%E5%BF%97%E6%9C%BA%E5%88%B6%E7%BB%93%E6%9E%84.png?raw=true" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">img</span></p>
<p>在这个流程图中， 第一步是应用程序把日志根据<a href="https://tools.ietf.org/html/rfc5424">syslog协议</a>进行封装， 比如用户指定的日志等级， 系统log渠道等等, 然后把封装好的数据发送到指定socket – <code>/dev/log</code>。<br><code>/dev/log</code>是一个UNIX域套接字，它负责接受在本地机器上运行的进程所产生的消息。</p>
<blockquote>
<p>除此之外还有一个与它十分相似的<code>/dev/klog</code>, <code>/dev/klog</code>是一个从UNIX内核接受消息的设备的socket, 如果看到syslog记录了kern的日志,却没记录普通日志,那就是<code>/dev/log</code>这个socket缓冲区满了, 而<code>/dev/klog</code>缓存区还有空间， 还可以正常运行， 这时候可以尝试通过kern.ipc.maxsockbuf改变缓冲区大小,但并不能完全解决问题。</p>
</blockquote>
<p>第二步是由系统的<code>journald</code>开始服务， 在我的系统中，由于使用了<code>Systemd</code>, 它的附属套件<code>systemd/journald</code>提供了一个<code>socket</code> – <code>/run/systemd/journal/syslog</code>，它通过软连接,让发送到<code>/dev/log/</code>的数据转而发送到<code>/run/systemd/journal/syslog</code>， 然后通过读取标准socket来读取日志。不过<code>systemd-journald</code>所记录的数据其实是在内存中，只是系统利用文件的型态将它记录到<code>/run/log/</code>下面, 在重新开机后,这些数据就会被清除掉。<br>当然， 也可以通过在<code>/etc/systemd/journald.conf</code>中更改设置， 设置它的存储位置和存储限制， 但一般都不会去更改它的这些存储相关的配置， 而是设置<code>ForwardToSyslog=yes</code>, 让journald把日志发送到rsyslog， 进入下一步。（journald自己也提供了很多<a href="https://wiki.archlinux.org/index.php/Systemd/Journal_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)">功能</a>,比如有:过滤输出,大小限制等等）</p>
<blockquote>
<p>PS: 在还没有<code>systemd</code>的时代, 必须要开机完成并且执行了<code>rsyslogd</code>这个<code>daemon</code>之后，登录文件才会开始记录日志。所以，需要自己产生一个<code>klogd</code>的服务， 才能将系统在开机过程、启动服务的过程中的信息记录下来，然后等<code>rsyslogd</code>启动后才传送给它来处理。现在有了systemd主动调用 <code>systemd-journald</code>来协助记载登录文件, 在开机过程中的所有信息， 包括启动服务与服务若启动失败的情况等等，都可以直接被记录到<code>systemd-journald</code>.</p>
</blockquote>
<p>第三步是<code>rsyslog</code>服务了， 在rsyslog服务启动后(以监控本地日志为例子,也就是加载module(load=”imuxsock”)) 从<code>/run/systemd/journal/syslog</code>这个socket消费syslog类型日志, 这些日志在经过预处理后会进入到主队列， 然后根据对应规则被分发, 由于<code>rsyslog</code>采用C/S结构，它可以将日志的信息追加到对应的日志文件中，一般在<code>/var/log</code>目录下(可以通过配置进行更改)。还可以把日志数据通过网络协议发送到另一台Linux服务器上，或者将日志存储在MySQL或Oracle等数据库中。<br>除此之外, <code>rsyslog</code>能够快速的过滤,转发,发送日志(官方说的每秒支持百万级日志),所以rsyslog的内容非常丰富。 <code>rsyslog</code>为了能让我们方便的使用这些功能， 提供了多个版本的配置语言， 我们只要通过对配置文件进行简单的修改,就能实现传输,过滤等功能。</p>
<blockquote>
<p>如上面的结构图,rsyslog中只有一个主消息队列，任何消息都要先进入这个队列，然后直到进入到动作队列之后消息才会从这个队列中删除。通常，我们都不会去动主队列的配置，因为默认的设置已经工作得很好；消息经过主消息队列之后，就被rule processor解析和处理，然后根据预先配置的规则压入各自的动作队列，动作队列的消息最终被消费掉, 而我们经常要配置的就是这一部分。</p>
</blockquote>
<p>可以发现， 上面这三步就是一个简单的消息队列， 应用程序通过syslog把日志输出到一个指定的log， 这是一个生产的步骤， <code>systemd-journald</code>则是以<code>FIFO</code>的形式暂存日志数据， 最后被<code>rsyslog</code>以消费者的形式进行消费。而<code>rsyslog</code>的内部则更像一个高级版本的消费队列， 一个简易版本的<code>RabbitMQ</code>。</p>
<h2 id="2-journald的配置"><a href="#2-journald的配置" class="headerlink" title="2.journald的配置"></a>2.journald的配置</h2><p>上面说到, 整个日志发送流程中， 对于<code>journald</code>只使用到它的暂存日志并转发到<code>rsyslog</code>的功能,所以这里分析的与暂存内存相关的配置, 如果要了解更多可以直接从man手册查看, 如果觉得内容太干， 也可以跳过， 都是从官网那边整理过来的。</p>
<ul>
<li><p>Storage: 指定收到数据时， 如何存数据,默认值为<code>none</code>, 此外它还有几个值：</p>
<ul>
<li>volatile： 表示仅保存在内存中， 也就是仅保存在<code>/run/log/journal</code>目录中(将会被自动按需创建)。 </li>
<li>persistent: 表示优先保存在磁盘上， 也就优先保存在<code>/var/log/journal</code>目录中(将会被自动按需创建)， 但若失败(例如在系统启动早期”/var”尚未挂载)， 则降级转而保存在<code>/run/log/journal</code>目录中(将会被自动按需创建)。 </li>
<li>auto： 与<code>persistent</code>类似， 但不自动创建<code>/var/log/journal</code>目录， 因此可以根据该目录的存在与否决定日志的保存位置。 </li>
<li>none: 表示不保存任何日志(直接丢弃所有收集到的日志)， 但日志转发不受影响。</li>
</ul>
</li>
<li><p>Compress: 默认值”yes”, 它表示压缩存储大于特定阈值(默认为512字节)的对象。 也可以直接设置一个字节值(可以带有 K, M, G 后缀)来表示要压缩存储大于指定阈值的对象。</p>
</li>
<li><p>Seal: 默认值”yes”, 它表示如果存在一个”sealing key”(由 journalctl(1) 的 –setup-keys 命令创建)， 那么就为所有持久保存的日志文件启用FSS(Seekable Sequential Key Generators)保护， 以避免日志文件 被恶意或无意的修改。</p>
</li>
<li><p>SplitMode: 设置是否按照每个用户分割日志文件，以实现对日志的访问控制(日志守护进程会确保每个用户都能读取自己的日志文件)。 默认值为uid, “uid” 表示每个用户都有自己专属的日志文件(无论该用户是否拥有登录会话)，但系统用户的日志依然记录到系统日志中。此外还有一个值”none”， 它表示不对日志文件按不同用户进行分割，而是将所有日志都记录到系统日志中。这意味着非特权用户根本无法读取属于自己的日志信息。 需要注意的是， 仅分割持久保存的日志(/var/log/journal)， 永不分割内存中的日志(/run/log/journal)。</p>
</li>
<li><p>RateLimitIntervalSec: 用于设置一个时间段长度,可以使用下面的时间单位： “ms”, “s”, “min”, “h”, “d”来限制日志的生成速率.表示在 RateLimitIntervalSec 时间段内， 每个服务最多允许产生 RateLimitBurst 数量(条数)的日志。 在同一个时间段内，超出数量限制的日志将被丢弃，直到下一个时间段才能再次开始记录。 对于所有被丢弃的日志消息，仅用一条类似”xxx条消息被丢弃”的消息来代替。 这个限制是针对每个服务的限制，一个服务超限并不会影响到另一个服务的日志记录。<br>如果一个服务已经通过<code>systemd</code>的<code>LogRateLimitIntervalSec=</code> 或 <code>LogRateLimitBurst=</code>选项限制了自身的日志生成速率，那么将会覆盖此处的设置。</p>
</li>
<li><p>RateLimitBurst 用于设置一个正整数，表示消息条数，默认值是10000条, 说明见RateLimitIntervalSec。 </p>
</li>
<li><p>SystemMaxUse: 限制磁盘使用量， 也就是<code>/var/log/journal</code>的使用量。限制全部日志文件加在一起最多可以占用多少空间。默认值是空间的10%与4G空间两者中的较小者；</p>
</li>
<li><p>SystemKeepFree: 限制磁盘使用量， 也就是<code>/var/log/journal</code>的使用量, 但与<code>SystemMaxUse</code>有所不同， 它的值的意思是除日志文件之外，至少保留多少空间给其他用途。<code>systemd-journald</code>会同时使用<code>SystemKeepFree</code>与<code>SystemMaxUse</code>两个值, 并且尽量限制日志文件的总大小，以同时满足这两个限制。默认值是空间的15%与4G空间两者中的较大者；</p>
</li>
<li><p>SystemMaxFileSize: 限制磁盘使用量， 也就是<code>/var/log/journal</code>的使用量。它限制的是单个日志文件的最大体积， 到达此限制后日志文件将会自动滚动。 默认值是对应的 SystemMaxUse值的1/8 ， 这也意味着日志滚动 默认保留7个历史文件。日志大小 可以使用以1024为基数的 K, M, G, T, P, E 后缀， 分别对应于 1024, 1024², … 字节。</p>
</li>
<li><p>SystemMaxFiles,<br>限制磁盘使用量， 也就是<code>/var/log/journal</code>的使用量。 限制最多允许同时存在多少个日志文件， 超出此限制后， 最老的日志文件将被删除， 而当前的活动日志文件 则不受影响。 默认值为100个。</p>
</li>
<li><p>RuntimeMaxUse<br>限制内存使用量， 也就是<code>/run/log/journal</code>的使用量。限制全部日志文件加在一起最多可以占用多少空间。默认值是空间的10%与4G空间两者中的较小者；</p>
</li>
<li><p>RuntimeKeepFree<br>限制内存使用量， 也就是<code>/run/log/journal</code>的使用量。除日志文件之外，至少保留多少空间给其他用途。systemd-journald 会同时RuntimeKeepFree与RuntimeMaxUse ， 并且尽量限制日志文件的总大小，以同时满足这两个限制。默认值是空间的15%与4G空间两者中的较大者；</p>
</li>
<li><p>RuntimeMaxFileSize<br>限制内存使用量， 也就是<code>/run/log/journal</code>的使用量。限制单个日志文件的最大体积， 到达此限制后日志文件将会自动滚动。 默认值是对应的 RuntimeMaxUse值的1/8 ， 这也意味着日志滚动 默认保留7个历史文件。日志大小 可以使用以1024为基数的 K, M, G, T, P, E 后缀， 分别对应于 1024, 1024², … 字节。</p>
</li>
<li><p>RuntimeMaxFiles<br>限制内存使用量， 也就是<code>/run/log/journal</code>的使用量。 限制最多允许同时存在多少个日志文件， 超出此限制后， 最老的日志文件将被删除， 而当前的活动日志文件 则不受影响。 默认值为100个。</p>
</li>
<li><p>MaxFileSec 日志滚动的时间间隔。 默认值是一个月， 设为零表示禁用基于时间的日志滚动策略。 可以使用 “year”, “month”, “week”, “day”, “h”, “m” 时间后缀， 若不使用后缀则表示以秒为单位。<br>通常 并不需要使用基于时间的日志滚动策略， 因为由 SystemMaxFileSize 与 RuntimeMaxFileSize 控制的基于文件大小的日志滚动策略 已经可以确保日志文件的大小不会超标。</p>
</li>
<li><p>MaxRetentionSec 日志文件的最大保留期限。 默认值零表示不使用基于时间的日志删除策略。可以使用 “year”, “month”, “week”, “day”, “h”, “m” 时间后缀， 若不使用后缀则表示以秒为单位。<br>当日志文件的最后修改时间(mtime)与当前时间之差， 大于此处设置的值时，日志文件将会被删除。  通常并不需要使用基于时间的日志删除策略，因为由 SystemMaxUse= 与 RuntimeMaxUse= 控制的基于文件大小的日志滚动策略 已经可以确保日志文件的大小不会超标。 </p>
</li>
<li><p>SyncIntervalSec 向磁盘刷写日志文件的时间间隔， 默认值是五分钟。<br>刷写之后，日志文件将会处于离线(OFFLINE)状态。 注意，当接收到 CRIT, ALERT, EMERG 级别的日志消息后， 将会无条件的立即刷写日志文件。 因此该设置仅对 ERR, WARNING, NOTICE, INFO, DEBUG 级别的日志消息有意义。</p>
</li>
<li><p>ForwardToSyslog 表示是否将接收到的日志消息转发给传统的 syslog 守护进程，默认值为”no”。 如果设为”yes”，但是没有任何进程监听对应的套接字，那么这种转发是无意义的。 此选项可以被内核引导选项 “systemd.journald.forward_to_syslog” 覆盖。</p>
</li>
<li><p>ForwardToKMsg 表示是否将接收到的日志消息转发给内核日志缓冲区(kmsg)，默认值为”no”。 此选项可以被内核引导选项 “systemd.journald.forward_to_kmsg” 覆盖。</p>
</li>
<li><p>ForwardToConsole 表示是否将接收到的日志消息转发给系统控制台，默认值为”no”。 如果设为”yes”，那么可以通过下面的 TTYPath= 指定转发目标。 此选项可以被内核引导选项 “systemd.journald.forward_to_console” 覆盖。 </p>
</li>
<li><p>ForwardToWall 表示是否将接收到的日志消息作为警告信息发送给所有已登录用户，默认值为”yes”。 此选项可以被内核引导选项 “systemd.journald.forward_to_wall” 覆盖。</p>
</li>
<li><p>MaxLevelStore 设置记录到日志文件中的最高日志等级，默认值为”debug”；可以被内核引导选项”systemd.journald.max_level_store”覆盖<br>可以设为日志等级的名称， 也可以设为日志等级对应的数字： “emerg”(0), “alert”(1), “crit”(2), “err”(3), “warning”(4), “notice”(5), “info”(6), “debug”(7) 。 所有高于设定等级的日志消息都将被直接丢弃， 仅保存/转发小于等于设定等级的日志消息。</p>
</li>
<li><p>MaxLevelSyslog 设置转发给传统的 syslog 守护进程的最高日志等级， 默认值为”debug”；可以被内核引导选项”systemd.journald.max_level_syslog”覆盖<br>选项说明同MaxLevelStore</p>
</li>
<li><p>MaxLevelKMsg 设置转发给内核日志缓冲区(kmsg)的最高日志等级，默认值为”notice”； 可以被内核引导选项”systemd.journald.max_level_kmsg”覆盖<br>选项说明同MaxLevelStore</p>
</li>
<li><p>MaxLevelConsole 设置转发给系统控制台的最高日志等级，默认值为”info”；可以被内核引导选项”systemd.journald.max_level_console”覆盖<br>选项说明同MaxLevelStore</p>
</li>
<li><p>MaxLevelWall 设置作为警告信息发送给所有已登录用户的最高日志等级，默认值为”emerg”；可以被内核引导选项”systemd.journald.max_level_wall”覆盖<br>选项说明同MaxLevelStore</p>
</li>
<li><p>ReadKMsg 是否收集内核日志。 默认值 yes 表示从 /dev/kmsg 中读取内核产生的日志消息。</p>
</li>
<li><p>TTYPath 指定 ForwardToConsole=yes 时所使用的控制台TTY， 默认值是 /dev/console</p>
</li>
<li><p>LineMax<br>在将日志流转化为日志记录时，每条日志记录最大允许的长度(字节)。 如果将单元的标准输出(STDOUT)/标准错误(STDERR)通过流套接字连接到日志中， 那么将会以换行符(“\n”, ASCII 10)与NUL字符(“\0”, ASCII 0)作为分割符， 把日志流切分成一条条独立的日志记录。 如果超过此处设置的长度之后仍然没有遇到分割符， 那么将会自动插入一个分割符，以强制将单行超长日志截断为多行。 此选项的值越大，每个日志流客户端日志守护进程占用的内存也越大(最大值等于此选项的值)。 另外，此选项的值太大也会造成与传统日志传输协议的不兼容(太长的日志无法封装在单个 AF_UNIX 或 AF_INET 报文内)。 此选项的值以字节为单位，同时也可以在数字的末尾加上 K, M, G, T 后缀(以1024为基准)。 默认值 48K 是一个足够大并且也能保持与传统日志传输协议兼容的值。 注意， 不能设为小于 79 的值(将被自动提升到79)。</p>
<h2 id="3-rsyslog配置"><a href="#3-rsyslog配置" class="headerlink" title="3.rsyslog配置"></a>3.rsyslog配置</h2><p>上面说到， <code>rsyslog</code>的配置主要是针对主队列之后的所有模块， 同时它目前支持两种语法配置, 个人觉得两种都有它的方便性,所以以下的配置一般都是混用。<code>rsyslog</code>的配置文件一般位于:<code>/etc/rsyslog.conf</code>， 他可以引用模块， 设置变量， 还有设置消息规则， 而规则就是指明一条消息要怎么输出， 也就是上面所说的过滤器+动作队列+输出模块的组合。</p>
<h3 id="3-1过滤器"><a href="#3-1过滤器" class="headerlink" title="3.1过滤器"></a>3.1过滤器</h3><p>消息经过主队列后进来的第一步就是过滤器, 过滤器有时候被称为选择器（selector）, 它用于过滤消息， 并把消息指向对应的操作队列，<code>rsyslog</code>可以配置三种形式的过滤器， 分别为<code>Facility/Priority-based</code>过滤器, <code>Property-based</code>过滤器以及<code>Expression-based</code>过滤器。</p>
</li>
</ul>
<h4 id="3-1-1-Facility-Priority-based-过滤器"><a href="#3-1-1-Facility-Priority-based-过滤器" class="headerlink" title="3.1.1.Facility/Priority-based 过滤器"></a>3.1.1.Facility/Priority-based 过滤器</h4><p>在syslog中指定消息发送时必须带有<code>facility</code>和<code>priority</code>字段， 对于<code>facility</code>我更想把它定义是<code>channel</code>, 也就是渠道， Linux系统默认设置了24个<code>facility</code>, 前16个都有专门的用途， 后8个交给用户自定义， 一般来说一个线上的机器只运行几个服务， 8个是够的， 以下是Linux支持渠道的列表：<br>| 代码 | 名称 | 描述 |<br>| —- | ——– | ———- |<br>| 0 | kern | 内核 |<br>| 1 | user | 用户级 |<br>| 2 | mail | 邮件 |<br>| 3 | daemon | 系统 |<br>| 4 | auth | 安全与授权 |<br>| 5 | syslog | 守护进程 |<br>| 6 | lpr | 打印相关 |<br>| 7 | news | 网络消息 |<br>| 8 | uucp | uucp子系统 |<br>| 9 | | 时钟 |<br>| 10 | authpriv | 安全与授权 |<br>| 11 | ftp | FTP |<br>| 12 | - | NTP |<br>| 13 | - | 日志审计 |<br>| 14 | - | 日志报警 |<br>| 15 | cron | 定时器 |<br>| 16 | local0 | 用户自定义 |<br>| 17 | local1 | 用户自定义 |<br>| 18 | local2 | 用户自定义 |<br>| 19 | local3 | 用户自定义 |<br>| 20 | local4 | 用户自定义 |<br>| 21 | local5 | 用户自定义 |<br>| 22 | local6 | 用户自定义 |<br>| 23 | local7 | 用户自定义 |</p>
<p>而至于<code>priority</code>, 大家都会十分熟悉， 只不过这里换了个说法， 设计上他代表的就是日志等级， 支持的日志等级列表有：<br>|代码|名称|简写|描述|<br>| —- | ————- | —— | —- |<br>| 0 | Emergency | emerg | 紧急 |<br>| 1 | Alert | alert | 报警 |<br>| 2 | Critical | crit | 关键 |<br>| 3 | Error | err | 错误 |<br>| 4 | Warning | warn | 警告 |<br>| 5 | Notice | notice | 通知 |<br>| 6 | Informational | info | 消息 |<br>| 7 | Debug | debug | 调试 |</p>
<p>了解完了<code>Facility</code>和<code>Priority</code>后就可以编写过滤器了, 过滤器编写十分简单， 他就是一个通配符, 通过<code>.</code>来区分<code>Facility</code>和<code>Priority</code>， <code>.</code>前面是<code>Facility</code>, <code>.</code>后面是<code>Priority</code>。<br>例如通配符<code>\*</code>的意思是任何类型, 而<code>\*.\*</code>的意思就是匹配所有的<code>Facility</code>和<code>Priority</code>。</p>
<p>举个例子, 一般默认的配置里都有一段规则：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">cron.alert /var/<span class="hljs-built_in">log</span>/cron<br></code></pre></td></tr></table></figure>
<p>其中<code>corn.alert</code>就是规则中的<code>Facility</code>和<code>Priority</code>过滤器，其中<code>Facility</code>为cron的， <code>Priority</code>为alert， 一般来说就是crontab定期任务所产生的日志且任何等级等于或高于alert的日志（也就是代码值大于alert的日志等级）都会被指定的动作处理。<br>如果希望只处理定义等级的日志，而不处理高于这个等级的日志，可以使用等号（=），例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">cron.=alert /var/<span class="hljs-built_in">log</span>/cron<br></code></pre></td></tr></table></figure>
<p>此外， 有一些子系统产生的日志可能没有Priority，那么可以使用关键字none，例如</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">news.none /var/<span class="hljs-built_in">log</span>/messages<br></code></pre></td></tr></table></figure>
<p>除了星号和等号，过滤器中还可以使用逗号（,）， 感叹号（!）和分号（；），逗号用于分隔多个Priority，而感叹号的作用是取反，例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">cron.!info,!debug /var/<span class="hljs-built_in">log</span>/cron<br></code></pre></td></tr></table></figure>
<p>意思是除了info和debug等级的日志外，都写入到/var/log/cron中。<br>对于分号(;), 它表示或的意思, 如系统中的默认配置：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">*.=debug;\<br>    auth,authpriv.none;\<br>    news.none;mail.none -/var/<span class="hljs-built_in">log</span>/debug<br></code></pre></td></tr></table></figure>
<p>它表示的是<code>*.=debug</code>, <code>auth,authpriv.none</code>, <code>news.none</code>和<code>mail.none</code>四组过滤器都不要马上写入到<code>/var/log/debug</code>中。</p>
<h4 id="3-1-2-Property-based-过滤器"><a href="#3-1-2-Property-based-过滤器" class="headerlink" title="3.1.2.Property-based 过滤器"></a>3.1.2.Property-based 过滤器</h4><p><code>Property-based</code>过滤器是基于属性的过滤器，使我们可以根据不同的属性值进行日志处理。配置文件中常用的属性有：msg、hostname、fromhost、programname、timegenerated等。它的基本语法是:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs basg">PROPERTY,[!]COMPARE_OPERATION,&quot;VALUE&quot;<br></code></pre></td></tr></table></figure>
<p>其中<code>PROPERTRY</code>为属性， <code>COMPARE_OPERATION</code>为操作符， <code>VALUE</code>为值</p>
<p>属性过滤器可用的操作符如下：</p>
<ul>
<li>contains 检查属性值是否包含指定的字符串（大小写敏感）</li>
<li>contains_i 和上面一样，但忽略大小写</li>
<li>isequal 属性值是否等于目标字符串</li>
<li>startswith 属性值是否以某字符串开头（大小写敏感）</li>
<li>startswith_i 如上，但忽略大小写</li>
<li>regex 正则表达式匹配</li>
<li>ereregex 使用扩展正则表达式匹配</li>
<li>isempty 属性值是否为空</li>
</ul>
<p>一个具体的例子是：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#日志信息中是否包含“error”字符串</span><br>:msg, contains, <span class="hljs-string">&quot;error&quot;</span> <br><span class="hljs-comment">#主机名称是否相等</span><br>:hostname, isequal, <span class="hljs-string">&quot;host1&quot;</span><br></code></pre></td></tr></table></figure>

<h4 id="3-1-3-Expression-based-过滤器"><a href="#3-1-3-Expression-based-过滤器" class="headerlink" title="3.1.3.Expression-based 过滤器"></a>3.1.3.Expression-based 过滤器</h4><p><code>Expression-based</code>过滤器是一个基于表达式的过滤器，这个表达式是一个条件表达式，即当满足特定条件的时候，执行指定的操作。<br>一般来说，表达式过滤器需要上面两种过滤器来结合使用。<br>基本语法如下(这里使用了新式语法)：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">if</span> expression_true <span class="hljs-keyword">then</span> action <span class="hljs-keyword">else</span> action<br></code></pre></td></tr></table></figure>
<p>else后续部分并不是必须的，它可以指定不满足条件的时候所执行的操作。<br>表达式中可用的操作符有：</p>
<ul>
<li>and、or、not</li>
<li>==、!=、&lt;&gt;、&lt;、&gt;、&lt;=、&gt;= （!=和&lt;&gt;的作用基本相等）</li>
<li>contains</li>
<li>startswith、startswith_i（case-insensitive）</li>
</ul>
<p>一些例子如下：：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#日志中包含error，保存到/var/log/errlog中</span><br><span class="hljs-keyword">if</span> <span class="hljs-variable">$msg</span> contains <span class="hljs-string">&#x27;error&#x27;</span> <span class="hljs-keyword">then</span> /var/<span class="hljs-built_in">log</span>/errlog<br><span class="hljs-comment">#如果要同时满足多个条件，使用and连接这些条件，整个表达式需要写在一行中</span><br><span class="hljs-keyword">if</span> <span class="hljs-variable">$syslogfacility</span>-text == <span class="hljs-string">&#x27;local0&#x27;</span> and <span class="hljs-variable">$msg</span> startswith <span class="hljs-string">&#x27;DEVNAME&#x27;</span> and (<span class="hljs-variable">$msg</span> contains <span class="hljs-string">&#x27;error1&#x27;</span> or <span class="hljs-variable">$msg</span> contains <span class="hljs-string">&#x27;error0&#x27;</span>) <span class="hljs-keyword">then</span> /var/<span class="hljs-built_in">log</span>/somelog<br><span class="hljs-keyword">if</span> <span class="hljs-variable">$syslogfacility</span>-text == <span class="hljs-string">&#x27;local0&#x27;</span> and <span class="hljs-variable">$msg</span> startswith <span class="hljs-string">&#x27;DEVNAME&#x27;</span> and not (<span class="hljs-variable">$msg</span> contains <span class="hljs-string">&#x27;error1&#x27;</span> or <span class="hljs-variable">$msg</span> contains <span class="hljs-string">&#x27;error0&#x27;</span>) <span class="hljs-keyword">then</span> /var/<span class="hljs-built_in">log</span>/somelog<br></code></pre></td></tr></table></figure>
<h3 id="3-1-4-动作"><a href="#3-1-4-动作" class="headerlink" title="3.1.4.动作"></a>3.1.4.动作</h3><p>在上面介绍过滤器时， 其中有一段关于分号(;)配置示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">*.=debug;\<br>    auth,authpriv.none;\<br>    news.none;mail.none -/var/<span class="hljs-built_in">log</span>/debug<br></code></pre></td></tr></table></figure>
<p>其中<code>/var/log/debug</code>前面的<code>-</code>就是一个动作, 表示日志不会马上写入到文件中，而是缓存到内存中。<br>常见的动作有:</p>
<ul>
<li>写入文件</li>
<li>转发到另一台服务器</li>
<li>写入数据库</li>
<li>丢弃</li>
<li>发送给用户</li>
</ul>
<p>如从<code>rsyslog</code>的默认配置:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">auth,authpriv.*	/var/<span class="hljs-built_in">log</span>/auth.log<br>*.*;auth,authpriv.none	-/var/<span class="hljs-built_in">log</span>/syslog<br>cron.*	/var/<span class="hljs-built_in">log</span>/cron.log<br>daemon.*	-/var/<span class="hljs-built_in">log</span>/daemon.log<br>kern.*	-/var/<span class="hljs-built_in">log</span>/kern.log<br>lpr.*	-/var/<span class="hljs-built_in">log</span>/lpr.log<br>mail.*	-/var/<span class="hljs-built_in">log</span>/mail.log<br>user.*	-/var/<span class="hljs-built_in">log</span>/user.log<br><br>*.emerg	:omusrmsg:*<br></code></pre></td></tr></table></figure>
<p>可以看出<code>rsyslog</code>会根据规则写入到各个指定的文件夹,动作前面有一个（-）横杠，表示日志不会马上写入到文件中，而是缓存到内存中，这样可以提高日志系统的性能，但有可能会造成日志的丢失;使用波浪符号（~）表示处理需要丢弃的日志。<br>而omusrmsg则表示会把消息转发给指定的用户,用户登录时就可以收到该消息.默认为全部用户,如果需要指定用户则如下编写:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs bahs">*.emerg	:omusrmsg:root,so1n<br></code></pre></td></tr></table></figure>
<p>它代表会把消息发送给用户root以及我(so1n)</p>
<h3 id="3-1-5-输出"><a href="#3-1-5-输出" class="headerlink" title="3.1.5.输出"></a>3.1.5.输出</h3><p><code>rsyslog</code>的输出有多种， 比如上面介绍过滤器时， 它的动作是把日志写入到哪个文件以及通过配置写入到数据库， 此外它还支持把日志通过远程传输的方式传到别的服务器。 <code>rsyslog</code>提供三个远程日志传输方式：</p>
<ul>
<li><p>UDP: 基于传统UDP协议进行远程日志传输，也是传统syslog使用的传输协议；<br>可靠性比较低，但性能损耗最少， 在网络情况比较差， 或者接收服务器压力比较高情况下，可能存在丢日志情况。 仅在对日志完整性要求不是很高，以及在可靠的局域网环境下可以使用。</p>
</li>
<li><p>TCP: 基于传统TCP协议明文传输，需要回传进行确认，可靠性比较高；<br>但在接收服务器宕机或者两者之间网络出问题的情况下，会出现丢日志情况。<br>这种协议相比于UDP在可靠性方面已经好很多，并且rsyslog原生支持，配置简单，<br>同时针对可能丢日志情况，可以进行额外配置提高可靠性，因此使用比较广。</p>
</li>
<li><p>RELP: RELP（Reliable Event Logging Protocol）是基于TCP封装的可靠日志消息传输协议；<br>是为了解决<code>TCP</code>与<code>UDP</code>协议的缺点而在应用层实现的传输协议，也是三者之中最可靠的。 不过需要多安装一个包<code>rsyslog-relp</code>以支持该协议。</p>
</li>
</ul>
<p>远程传输需要更改客户端和服务端的配置， 首先是客户端配置, 客户端配置需要先配置对应的传输模块:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 使用udp传输模块</span><br>module(load=<span class="hljs-string">&quot;imudp&quot;</span>)<br><span class="hljs-comment"># 使用udp传输模块， 指定端口为514</span><br>input(<span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;imudp&quot;</span> port=<span class="hljs-string">&quot;514&quot;</span>)<br><br><span class="hljs-comment"># 使用tcp传输模块</span><br>module(load=<span class="hljs-string">&quot;imtcp&quot;</span>)<br><span class="hljs-comment"># 使用tcp传输模块， 指定端口为514</span><br>input(<span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;imtcp&quot;</span> port=<span class="hljs-string">&quot;514&quot;</span>)<br></code></pre></td></tr></table></figure>

<p>然后在动作那里配上如下格式</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">@[(zNUMBER)]HOST:[PORT]<br></code></pre></td></tr></table></figure>
<p>其中@代表udp(UDP 在主机名前加”@”;TCP 在主机名前加”@@”;RELP 在主机名前加”:omrelp:”),可选值zNUMBER设置了是否允许使用zlib对日志压缩（压缩级别1-9）。比如下面是一个使用relp发送的示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># local0.=warn,local1.* :omrelp:35.227.112.245:30514</span><br></code></pre></td></tr></table></figure>

<p>而服务端的配置也不复杂， 首先是UDP, 先在服务端创建配置文件：/etc/rsyslog.d/udp.conf</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># server configure</span><br><span class="hljs-variable">$ModLoad</span> imudp <span class="hljs-comment"># 加载模块</span><br><span class="hljs-variable">$UDPServerRun</span> 10514 <span class="hljs-comment"># 指定监听端口</span><br><span class="hljs-variable">$AllowedSender</span> UDP, 10.0.0.0/16 <span class="hljs-comment"># 设置白名单, 也就是客户端的IP</span><br><br><span class="hljs-comment"># 创建模板location和uformat</span><br><span class="hljs-comment"># location模板是根据客户端IP存放到不同目录下，以日期命名文件</span><br><span class="hljs-variable">$template</span> location,/data/%fromhost-ip%/%<span class="hljs-variable">$YEAR</span>%-%<span class="hljs-variable">$MONTH</span>%-%<span class="hljs-variable">$DAY</span>%.<span class="hljs-built_in">log</span><br><span class="hljs-comment"># uformat模板是自定义日志格式</span><br><span class="hljs-variable">$template</span> uformat,<span class="hljs-string">&quot;%fromhost-ip% %msg%\n&quot;</span><br><br><span class="hljs-comment"># 使用属性过滤器匹配非本地传输的日志， 然后执行动作， 这个动作使用了上面的模板， 也就是按照指定的文件路径及格式保存</span><br>:fromhost-ip, !isequal, <span class="hljs-string">&quot;127.0.0.1&quot;</span> -?location;uformat<br><span class="hljs-comment"># 最后一句指明了该日志已经被匹配过了， 不需要其他的动作队列处理， 其中&amp; 表示已经匹配处理的内容，~ 表示不再进行其他处理, 是stop元素的一个符号代替</span><br>&amp; ~<br></code></pre></td></tr></table></figure>
<p>接着就是TCP, 在服务端创建配置文件：/etc/rsyslog.d/tcp.conf</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># server configure</span><br><span class="hljs-variable">$ModLoad</span> imtcp <span class="hljs-comment"># 加载模块</span><br><span class="hljs-variable">$InputTCPServerRun</span> 20514 <span class="hljs-comment"># 指定监听端口</span><br><span class="hljs-variable">$AllowedSender</span> TCP, 10.0.0.0/16 <span class="hljs-comment"># 设置白名单</span><br><span class="hljs-comment"># 根据客户端IP存放到不同目录下，以日期命名文件</span><br><span class="hljs-variable">$template</span> location,<span class="hljs-string">&quot;/data/log/syslog/%fromhost-ip%.log&quot;</span><br><span class="hljs-comment"># 自定义日志格式</span><br><span class="hljs-variable">$template</span> uformat,<span class="hljs-string">&quot;%timestamp% %fromhost-ip% %rawmsg%\n&quot;</span><br><span class="hljs-comment"># 把非本地传输的日志按照指定的文件路径及格式保存</span><br>:fromhost-ip, !isequal, <span class="hljs-string">&quot;127.0.0.1&quot;</span> -?location;uformat<br><span class="hljs-comment"># &amp; 表示已经匹配处理的内容，stop 表示不再进行其他处理</span><br>&amp; stop<br></code></pre></td></tr></table></figure>
<p>最后是RELP, 首先需要在客户端和服务端安装RELP</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">apt-get update<br>apt-get -y install rsyslog-relp<br></code></pre></td></tr></table></figure>
<p>客户端需要额外加载模块</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">module(load=<span class="hljs-string">&quot;omrelp&quot;</span>)<br></code></pre></td></tr></table></figure>
<p>然后在服务端编辑配置（/etc/rsyslog.d/relp.conf）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># server configure</span><br><span class="hljs-variable">$ModLoad</span> imrelp    <span class="hljs-comment"># 加载模块</span><br><span class="hljs-variable">$InputRELPServerRun</span> 30514    <span class="hljs-comment"># 指定监听端口</span><br><span class="hljs-comment"># 根据客户端IP存放到不同目录下，以日期命名文件</span><br><span class="hljs-variable">$template</span> location,<span class="hljs-string">&quot;/data/log/syslog/%fromhost-ip%.log&quot;</span><br><span class="hljs-comment"># 自定义日志格式</span><br><span class="hljs-variable">$template</span> uformat,<span class="hljs-string">&quot;%timestamp% %fromhost-ip% %rawmsg%\n&quot;</span><br><span class="hljs-comment"># 把非本地传输的日志按照指定的文件路径及格式保存</span><br>:fromhost-ip, !isequal, <span class="hljs-string">&quot;127.0.0.1&quot;</span> -?location;uformat<br><span class="hljs-comment"># &amp; 表示已经匹配处理的内容，stop 表示不再进行其他处理</span><br>&amp; stop<br></code></pre></td></tr></table></figure>

<h4 id="3-1-6模板"><a href="#3-1-6模板" class="headerlink" title="3.1.6模板"></a>3.1.6模板</h4><p>模板<code>$template</code>常用于接收端, 可用来定义消息格式、文件名。 语法如下:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-variable">$template</span> &lt;模板名&gt;,&lt;内容&gt;,&lt;可选项&gt;<br><span class="hljs-variable">$template</span> MyTemplateName,<span class="hljs-string">&quot;\7Text %property% some more text\n&quot;</span>,&lt;options&gt;<br></code></pre></td></tr></table></figure>
<p>其中内容可以使用模板变量， 比如一条消息格式如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">&lt;接收内容的时间&gt; &lt;发送者的hostname&gt; &lt;<span class="hljs-variable">$InputFileTag</span>&gt; &lt;原始消息%msg%&gt;<br>Dec 18 20:39:27 jumper-172-31-56-18 karltestdemoTag blala... dummy msg<br></code></pre></td></tr></table></figure>
<p>如果只需要显示原始消息，可设置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-variable">$template</span> CleanMsgFormat,<span class="hljs-string">&quot;%msg%\n&quot;</span><br></code></pre></td></tr></table></figure>
<p>除了msg变量， 模板还支持很多变量,常见变量如下(<a href="https://www.rsyslog.com/doc/v5-stable/configuration/properties.html">更多变量见官网文档</a>):</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">%msg%<br>%syslogfacility%<br>%HOSTNAME%<br>%syslogpriority%<br>%timereported:::date-mysql%<br>%timegenerated:::date-mysql%<br>%iut%<br><span class="hljs-string">&#x27;%syslogtag%&#x27;</span><br></code></pre></td></tr></table></figure>
<p>如果要生成动态文件名,并把日志写入该文件,那可以这样配置:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-variable">$template</span> DynamicFile,<span class="hljs-string">&quot;/var/log/test_logs/%timegenerated%-test.log&quot;</span>    <span class="hljs-comment"># timegenerated属性从日志信息中提取出消息的时间戳，这样可以为每个日志生成唯一文件名称。</span><br>*.* ?DynamicFile<br></code></pre></td></tr></table></figure>
<h4 id="3-1-7常用模块"><a href="#3-1-7常用模块" class="headerlink" title="3.1.7常用模块"></a>3.1.7常用模块</h4><p>上面我们看到服务端会通过引入模块来拓展输出模块的功能， 比如输出到本地文件或者输出到<code>Redis</code>,<code>Kafka</code>等等…</p>
<p><strong>imfile模块</strong></p>
<p>imfile模块主要解决的问题是将非syslog日志转为syslog日志<br>假设有个没有按照syslog协议生成的日志文件<code>/var/log/helloworld.log</code>, 下面将用<code>imfile</code>模块把它加载到<code>rsyslog</code>中并处理：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 加载imfile这个模块, 使用inotify模式来实时加载数据</span><br>module(load=<span class="hljs-string">&quot;imfile&quot;</span> mode=<span class="hljs-string">&quot;inotify&quot;</span> PollingInterval=<span class="hljs-string">&quot;1&quot;</span>)<br><span class="hljs-comment"># 指定输入端使用了imfile, 配置是日志文件路径以及tag, severity, facility这些参数</span><br>input(<span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;imfile&quot;</span> File=<span class="hljs-string">&quot;/var/log/helloworld.log&quot;</span> Tag=<span class="hljs-string">&quot;helloworld&quot;</span> Severity=<span class="hljs-string">&quot;error&quot;</span> Facility=<span class="hljs-string">&quot;local0&quot;</span>)<br><span class="hljs-comment"># 由于local有限,一般可以专门预留一个local用来接受带有Tag的日志,解决local不足的问题</span><br><span class="hljs-comment"># 将helloworld的应用日志发送到远程服务器</span><br>:programname, contains, <span class="hljs-string">&quot;helloworld&quot;</span> @192.168.1.2<br></code></pre></td></tr></table></figure>
<p>其他imfile配置如下,如果使用input做输入端,input的参数基本是以下配置的名称去掉input前缀,<br>更多配置见<a href="https://www.rsyslog.com/doc/v8-stable/configuration/modules/imfile.html">官网</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-variable">$InputFileName</span> /path/to/file <span class="hljs-comment"># 待监控的文件路径</span><br><span class="hljs-variable">$InputFileTag</span> tag <span class="hljs-comment"># 文件唯一标识tag，最好保持唯一，用于接收端区分原始log文件，可以包含特殊字符，如&quot;:&quot;、&quot;,&quot;等 </span><br><span class="hljs-variable">$InputFileStateFile</span> /path/to/state/file<br><span class="hljs-comment"># 需要保证发送端唯一，记录读取到哪儿，状态文件保存在$WorkDirectory，默认为 /var/lib/rsyslog</span><br><span class="hljs-comment"># 如果某个要监控的文件名变化了，一定要重新设置该值</span><br><span class="hljs-variable">$InputFileFacility</span> facility <span class="hljs-comment"># log类型，默认local0， local开头的表示自定义类型</span><br><span class="hljs-variable">$InputFileSeverity</span> severity <span class="hljs-comment"># log级别：info，warning，默认notice</span><br><span class="hljs-variable">$InputRunFileMonitor</span> <span class="hljs-comment"># 启动监控当前的文件，如果忘记这行，则啥事也不会发生</span><br><span class="hljs-variable">$InputFilePollInterval</span> seconds <span class="hljs-comment"># 全局设置，默认轮询是10s</span><br><span class="hljs-variable">$InputFilePersistStateInterval</span> lines <span class="hljs-comment"># 每多少行更新state文件状态 </span><br><span class="hljs-variable">$InputFileMaxLinesAtOnce</span> number <span class="hljs-comment"># 默认10240，如果在发送端，需要同时监控多个文件，会处理完当前文件特定行后，切换到下一个文件，避免一个文件一直占用处理，导致收集别的文件不及时。</span><br><span class="hljs-variable">$InputFileBindRuleset</span> ruleset <span class="hljs-comment"># 绑定ruleset，可以把这个listener绑定到特点的规则(http://www.rsyslog.com/doc/v5-stable/concepts/multi_ruleset.html)</span><br></code></pre></td></tr></table></figure>
<p>在input的语法中stateFile参数已经不建议使用。原因在于，为了防止出现重复的state files，rsyslog会基于下面的规则自动生成这些文件：</p>
<ul>
<li>在具体的被监控文件前添加”imfile-state:”字符串</li>
<li>文件名前的反斜杠会被替换为短横杠。<br>尽量在文件刚生成时初始化日志,或者使用freshStartTail参数,然rsyslog并不建议使用该参数…</li>
</ul>
<p><strong>omprog模块</strong></p>
<p>omprog模块可以让日志通过管道的形式发送给程序(以每行日志分开发送),然后再由程序处理日志（类似于Map-Reduce）。</p>
<p>以下是官网的一个例子, 例子中该模块会根据配置执行Python程序,并通过stdin的形式发送到Python程序,Python程序会一直运行,等待数据的到来,如果收到数据则处理数据(这个例子是写入数据库), 如果程序终止,则重新启动,如果rsyslo终止,则程序的stdin会捕获到EOF,此时程序会终止.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 配置</span><br>module(load=<span class="hljs-string">&quot;omprog&quot;</span>)<br><br><span class="hljs-comment"># 省略了过滤器， 只说一下语法</span><br>action(<span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;omprog&quot;</span><br>       name=<span class="hljs-string">&quot;db_forward&quot;</span><br>       binary=<span class="hljs-string">&quot;/usr/share/logging/db_forward.py&quot;</span><br>       confirmMessages=<span class="hljs-string">&quot;on&quot;</span>  <span class="hljs-comment"># 它告诉rsyslog等待程序确认其初始化以及收到的每条消息。该设置的目的是防止由于数据库连接失败而导致日志丢失。如果程序无法将日志写入数据库，它将通过stdout向rsyslog返回否定确认</span><br>       confirmTimeout=<span class="hljs-string">&quot;30000&quot;</span>  <span class="hljs-comment"># 指定超时时间内未收到程序的响应，则rsyslog将终止并重新启动它</span><br>       queue.type=<span class="hljs-string">&quot;LinkedList&quot;</span><br>       queue.saveOnShutdown=<span class="hljs-string">&quot;on&quot;</span><br>       queue.workerThreads=<span class="hljs-string">&quot;5&quot;</span> <span class="hljs-comment"># 使用具有（最多）5个工作线程的专用磁盘辅助队列，以避免在高负载时影响其他日志目标</span><br>       action.resumeInterval=<span class="hljs-string">&quot;5&quot;</span> <span class="hljs-comment"># Rsyslog将失败的日志保留在队列中，并在5秒后再次将其发送给程序。</span><br>       killUnresponsive=<span class="hljs-string">&quot;on&quot;</span><br>       output=<span class="hljs-string">&quot;/var/log/db_forward.log&quot;</span>  <span class="hljs-comment"># 程序将错误详细信息写入stderr,rsyslog捕获并写入/var/log/db_forward.log</span><br>)<br></code></pre></td></tr></table></figure>
<p>除了使用模块接收日志,还可以用程序读取日志(建议用上inotify),或者开个端口接收日志</p>
<h3 id="3-2-各个日志文件简介"><a href="#3-2-各个日志文件简介" class="headerlink" title="3.2.各个日志文件简介"></a>3.2.各个日志文件简介</h3><ul>
<li><p>/var/log/secure：记录用户登陆系统的信息，比如SSH，telnet，ftp等记录</p>
</li>
<li><p>/var/log/btmp：记录登陆失败的信息，被编码过，所以必须使用last解析</p>
</li>
<li><p>/var/log/messages：在开机运行中几乎所有的系统发生的错误都在此记录。</p>
</li>
<li><p>/var/log/boot.log：记录一些开机或者关机启动的一些服务信息</p>
</li>
<li><p>/var/log/cron：用来记录crontab这个服务执行任务计划产生的日志</p>
</li>
<li><p>/var/log/utmp：记录现在登陆的用户</p>
</li>
<li><p>/var/log/dmesg：内核日志</p>
</li>
<li><p>/var/log/kern：内核产生的信息</p>
</li>
<li><p>/var/log/daemon.log：系统监控程序产生的日志。</p>
</li>
</ul>
<h3 id="3-3-队列"><a href="#3-3-队列" class="headerlink" title="3.3.队列"></a>3.3.队列</h3><p>队列是在rsyslog中我们在使用中最无感, 就像上面我们使用的语法中， 其实都用到了队列， 但是很难发现它的存在， 即便如此队列也是最重要的, 因为队列可以加速日志的传输,还会让传输更加可靠。<br><code>Rsyslog</code>中分为两种队列， 主队列和动作队列。</p>
<blockquote>
<p>以下内容大多数来源于<a href="https://www.rsyslog.com/doc/master/concepts/queues.html">官方文档</a></p>
</blockquote>
<h4 id="3-3-1主队列"><a href="#3-3-1主队列" class="headerlink" title="3.3.1主队列"></a>3.3.1主队列</h4><p>一般日志进来到rsyslog时,都会先进入主队列,然后根据配置消费日志分发到各个队列以及执行动作,一般主队列的鲁棒性很强,我们都不用去修改他, 改改参数即可, 如使用下面命令可以告诉主消息队列在关闭时保存其内容:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-variable">$MainMsgQueueSaveOnShutdown</span> on<br></code></pre></td></tr></table></figure>
<h4 id="3-3-2动作队列"><a href="#3-3-2动作队列" class="headerlink" title="3.3.2动作队列"></a>3.3.2动作队列</h4><p>动作队列用于接受主队列的消息,并根据规则执行动作,一般与动作绑定在一起， <code>rsyslog</code>的动作队列有以下4种:</p>
<ul>
<li><p>Direct queue<br>该队列是默认队列,如果对action没进行配置,则默认采用该队列,该队列既不排队也不缓冲任何队列消息,而是直接将消息传给消费者。同时,该队列是唯一一个会把执行结果从消费者（action processor）返回给生产者的队列。通过这个返回值提醒action queue，让action queue取回这些处理失败的消息，如此循环，直到消息处理成功。</p>
</li>
<li><p>Disk queue<br>该队列使用硬盘进行缓冲,而不在内存中缓冲任何内容。因此该队列是超级可靠的，但到也是效率最慢的队列。正常情况下，不建议使用此队列模式。如果日志数据非常重要，为了确保在极端情况下也不能丢失，则可以使用该队列。<br>写入该队列时，它是分块完成的。每个块接收其各自的文件。文件以前缀命名（通过<code>$&lt;object&gt;QueueFilename</code>设置），后跟7位数字（从1开始，每个文件递增）。默认情况下，块为10mb，可通过<code>$&lt;object&gt;QueueMaxFileSize</code>设置不同的大小。不过，大小限制不是一个很严格的限制,因为rsyslog总是写一个完整的队列条目，即使它会比大小限制还大。因此，块实际上比配置的大小大一点（通常小于1k）,所以，每个块的大小都会不一样。<br>此外，每一个队列可以使用不同的位置保存数据，可以通过队列的$WorkDirectory指令设置，这个指令需要在队列创建之前配置。</p>
</li>
<li><p>memory queue （LinkedList/FixedArray）<br>这种类型的队列会把所有的消息都保存在内存中，因此它的处理速度非常快，缺点是当电脑关闭或死机的时候，所有未被处理的消息都会丢失。如果希望电脑关机的时候保存这些消息，可以设置变量<code>$&lt;Object&gt;QueueSaveOnShutdown</code>。</p>
<p>  memory queue队列拥有两种模式:</p>
<ul>
<li><p><code>FixedArray queue</code>: 预先分配一定的内存来保存这些消息，它的缺点是，无论你的日志有多少，它都需要完全占用这些内存；好处是当数据量不大的时候，它的性能是最好的。</p>
</li>
<li><p><code>LinkedList queue</code>: 内存是运行时分配的，会根据数据量的不同而作出调整，好处是内存利用率高，LinkedList队列适合使用在一些突发数据量大的场景。</p>
<p>如果不知道用哪个模式,建议使用LinkedList模式, 因为它与FixedArray相比，处理开销较低，并且可以通过减少内存使用量来弥补。在大多数不使用的指针数组页面中分页可能比动态分配它们慢得多。创建不同类型的队列方法为分别使用<code>$&lt;object&gt;QueueType LinkedList</code> or <code> /$&lt;object&gt;QueueType FixedArray</code>创建 LinkedLIst和FixesArray队列。</p>
</li>
</ul>
</li>
<li><p>Disk-Assisted In-memory queue<br>这种队列实际上是以内存队列为主，Disk Queue为辅的队列。在正常情况下，不会使用辅助的Disk queue，但当内存队列被填满，或者主机关闭的时候，Disk Queue就会被激活，数据被写入硬盘。结合两者使用，可以同时满足速度和数据的可靠性。</p>
</li>
</ul>
<p>设置队列的旧式语法如下:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-variable">$ActionQueueType</span> LinkedList<br><span class="hljs-variable">$ActionQueueFileName</span> fileName<br><br><span class="hljs-comment">#还有另外两个参数设置</span><br>$&lt;Object&gt;QueueHighWatermark  <span class="hljs-comment">#当队列中的数据超过这个设置的值的时候，要么把数据保存，要么把数据丢弃，如果是Disk-Assisted In-memory Queue，队列中的数据超过这个值，Disk Queue就会被激活。</span><br>$&lt;Object&gt;QueueLowWatermark  <span class="hljs-comment">#和上面的相反，这是一个低水位设置，当数据小于这个值的时候，就停止相关的操作，如果是Disk-Assisted In-memory Queue，数据低于这个值，Disk Queue就会被取消激活状态。</span><br></code></pre></td></tr></table></figure>
<p>但是旧语法使用起来很奇怪， 我更喜欢使用新语法， 新式语法使用如下, action表示要执行的操作， 比如这个action指明要以什么方式发送， 发送到哪里， 这个action绑定的是哪个队列: </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">if</span> <span class="hljs-variable">$syslogfacility</span>-text == <span class="hljs-string">&#x27;local6&#x27;</span> <span class="hljs-keyword">then</span> action(<br>       <span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;omrelp&quot;</span>\ <br>       Target=<span class="hljs-string">&quot;127.0.0.1&quot;</span>\<br>       Port=<span class="hljs-string">&quot;30514&quot;</span>\<br>       queue.type=<span class="hljs-string">&quot;LinkedList&quot;</span>\<br>       queue.spoolDirectory=<span class="hljs-string">&quot;/var/spool/rsyslog&quot;</span>\<br>       queue.filename=<span class="hljs-string">&quot;demo&quot;</span>\<br>       queue.size=<span class="hljs-string">&quot;100000&quot;</span>\<br>       queue.maxdiskspace=<span class="hljs-string">&quot;1g&quot;</span>\<br>       queue.highwatermark=<span class="hljs-string">&quot;60000&quot;</span>\<br>       queue.lowwatermark=<span class="hljs-string">&quot;2000&quot;</span>\<br>       queue.discardmark=<span class="hljs-string">&quot;80000&quot;</span>\<br>       queue.timeoutenqueue=<span class="hljs-string">&quot;3000&quot;</span>\<br>       queue.maxfilesize=<span class="hljs-string">&quot;200m&quot;</span>\<br>       queue.dequeuebatchsize=<span class="hljs-string">&quot;1000&quot;</span>\<br>       queue.saveonshutdown=<span class="hljs-string">&quot;on&quot;</span>\<br>       action.resumeRetryCount=<span class="hljs-string">&quot;-1&quot;</span>\<br>)<br></code></pre></td></tr></table></figure>
<h4 id="3-3-3队列管理"><a href="#3-3-3队列管理" class="headerlink" title="3.3.3队列管理"></a>3.3.3队列管理</h4><p>队列的管理过程实际上是对队列的参数进行调优的过程。主队列的参数和动作队列的参数基本一样。这些参数必须在队列创建之后才能使用，每个不同的队列可以设置不同的数值，这些值在下一个队列创建之前被重置，前一个队列设置的值不会影响到下一个队列(如果使用新式队列， 则会与action绑定)。</p>
<ul>
<li><p>限制队列容量</p>
<ul>
<li><code>$&lt;Object&gt;QueueSize &lt;number&gt;</code></li>
<li><code>$&lt;Object&gt;QueueHighWaterMark &lt;number&gt;</code><br>两者之间有细微的差别 <code>$&lt;Object&gt;QueueSize</code>用于设置队列的总容量，即队列可容纳的消息数量。<br>而<code>$&lt;Object&gt;QueueHighWaterMark</code>只用于disk-assisted类型的队列，当队列中的消息数量达到这个值之后，消息就会被写入到硬盘。但是这种行为是有依赖性的，仅当日志的输出目标无法到达的时候（数据库无法访问，远程服务器离线等），它才会发生。</li>
</ul>
</li>
<li><p>丢弃消息</p>
<ul>
<li><code>$&lt;Object&gt;QueueDiscardMark</code>     设置队列的最高值,当队列中的消息达到这个指定的值时，消息就会被丢弃</li>
<li><code>$&lt;Object&gt;QueueDiscardSeverity</code>  设定要丢弃哪些日志消息(见rsyslog的 Priority)</li>
</ul>
</li>
<li><p>队列的终止<br>只有在系统被关闭的那一刻，队列才会被结束。当队列被终止的时候，队列中可能有数据尝试进入,rsyslog会试图处理这些数据,可以使用配置控制rsyslog的做法.</p>
<ul>
<li><code>$&lt;Object&gt;QueueTimeoutShutdown &lt;milliseconds&gt;</code>  队列会仍然去处理这些数据,当队列关闭时间超过这个值，队列中的所有数据被丢弃</li>
<li><code>$&lt;Object&gt;QueueTimeoutActionCompletion</code> 只处理当前被处理的消息,其他的消息全部被抛弃</li>
<li><code>$&lt;Object&gt;QueueSaveOnShutdown</code> 不丢弃任何消息且队列是Disk-Queue或者Disk-assisted-Queue  </li>
</ul>
</li>
</ul>
<h3 id="3-4Ruleset"><a href="#3-4Ruleset" class="headerlink" title="3.4Ruleset"></a>3.4Ruleset</h3><p>Ruleset就是多个规则的集合，当消息进来后<code>rsyslogd</code>会从ruleset的第一条规则开始处理，直到这个ruleset的最后一条规则或者是设置了终止标记。rsyslogd有一个默认的Ruleset，名为<code>RSYSLOG_DefaultRuleset</code>, 它的使用方法如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-variable">$template</span> Centos7Server,<span class="hljs-string">&quot;/var/log/%hostname%/messages-%<span class="hljs-variable">$now</span>%.log&quot;</span><br><span class="hljs-variable">$RuleSet</span> remote<br>*.* ?Centos7Server<br> <br><span class="hljs-variable">$RuleSet</span> RSYSLOG_DefaultRuleset<br></code></pre></td></tr></table></figure>
<p>这个方法先创建了一个名叫remote的Ruleset，规则中使用了一个预先定义的模板。最后切换回默认的Ruleset，不切换回去的话,后面的配置就还是remote Ruleset。</p>
<p>多个Ruleset的使用场景在于区分本地写日志和网络传日志.<br>本地通过$DefaultRuleset命令指定Ruleset,而利用TCP传输模块可以通过如下方法设置规则如下:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-variable">$ModLoad</span> imtcp<br><span class="hljs-variable">$InputTCPServerBindRuleset</span> remote <span class="hljs-comment">#绑定自定以的Ruleset</span><br><span class="hljs-variable">$InputTCPServerRun</span> 514<br></code></pre></td></tr></table></figure>
<p>这时走TCP的日志就会使用remote Rules,如果是正常启用TCP传输日志,那么会走DefaultRuleset指定的ruleset,因为没有使用InputTCPServerBindRuleset去覆盖Ruleset.<br>如果有多个端口传输日志,每个端口的ruleset不同,那可以利用InputTCPServerBindRuleset 的覆盖性进行如下配置:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-variable">$InputTCPServerBindRuleset</span> remote10001<br><span class="hljs-variable">$InputTCPServerRun</span> 10001<br> <br><span class="hljs-variable">$InputTCPServerBindRuleset</span> remote10002<br><span class="hljs-variable">$InputTCPServerRun</span> 10002<br> <br><span class="hljs-variable">$InputTCPServerBindRuleset</span> remote10003<br><span class="hljs-variable">$InputTCPServerRun</span> 10003<br></code></pre></td></tr></table></figure>
<p>但是我会更喜欢用新式语法写rule。</p>
<h3 id="3-5-RainerScript"><a href="#3-5-RainerScript" class="headerlink" title="3.5.RainerScript"></a>3.5.RainerScript</h3><p>上面的介绍中我经常说新式语法和旧式语法， 其中新式语法的名字就叫<code>RainerScript</code>它是一个比较新的配置语言, 具有更紧凑的语法，使配置过程更加清晰，更不容易出错, 同时能支持复用， 让人觉得更像在写一个变成语言， 在上面有些情况我已经用了新式的语法了, 下面看看新式语法的区别：</p>
<ul>
<li><p>加载模块</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 旧语法</span><br><span class="hljs-variable">$ModLoad</span> imtcp<br><span class="hljs-comment"># 新语法</span><br>module(load=<span class="hljs-string">&quot;imtcp&quot;</span>)<br></code></pre></td></tr></table></figure></li>
<li><p>input</p>
<p>  上面已经有使用imfile的例子了,这里就不多阐述</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 旧语法</span><br><span class="hljs-variable">$ModLoad</span> imfile <span class="hljs-comment">#导入模块</span><br><span class="hljs-variable">$InputFileName</span> /var/<span class="hljs-built_in">log</span>/nginx/access.log <span class="hljs-comment">#需要导入的文件</span><br><span class="hljs-variable">$InputFileTag</span> ng-acc <span class="hljs-comment">#添加标签名称</span><br><span class="hljs-variable">$InputFilePersistStateInterval</span> 10 <span class="hljs-comment">#多久处理一次追踪文件</span><br><span class="hljs-variable">$InputFileStateFile</span> state-ng-acc<br><span class="hljs-variable">$InputRunFileMonitor</span> <span class="hljs-comment">#开始监控文件</span><br><span class="hljs-comment"># 新语法</span><br>module(load=<span class="hljs-string">&quot;builtin:imfile&quot;</span>)<br>input(Type=<span class="hljs-string">&quot;imfile&quot;</span> File=<span class="hljs-string">&quot;/var/log/nginx/access.log&quot;</span> Tag=<span class="hljs-string">&quot;ng-acc&quot;</span>PersistStateInterval=10)<br></code></pre></td></tr></table></figure></li>
<li><p>action</p>
<p>  action是输出模块,包括了结构图里的action和队列</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 旧语法</span><br>*.* /var/<span class="hljs-built_in">log</span>/messages<br><span class="hljs-comment"># 新语法</span><br>*.* action(Type=<span class="hljs-string">&quot;omfile&quot;</span> File=<span class="hljs-string">&quot;/var/log/messages&quot;</span>)<br><span class="hljs-comment"># 包含队列的新语法</span><br>action(<span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;ommysql&quot;</span> server=<span class="hljs-string">&quot;localhost&quot;</span> db=<span class="hljs-string">&quot;Syslog&quot;</span> uid=<span class="hljs-string">&quot;root&quot;</span> <span class="hljs-built_in">pwd</span>=<span class="hljs-string">&quot;password&quot;</span>\<br>queue.type=<span class="hljs-string">&quot;LinkedList&quot;</span> queue.filename=<span class="hljs-string">&quot;name&quot;</span> queue.saveonshutdown=<span class="hljs-string">&quot;on&quot;</span>\<br>action.resumeRetryCount=<span class="hljs-string">&quot;-1&quot;</span><br></code></pre></td></tr></table></figure></li>
<li><p>template</p>
<p>  新的template对象提供了两种常用的模板定义方式，一种是string，另一种是list。string方式比较接近旧template的定义方式，而list方式可以更清晰的区分字符串和属性值。</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 旧语法</span><br><span class="hljs-variable">$template</span> remote, <span class="hljs-string">&quot;message from %hostname%, received at %timegenerated%.&quot;</span><br><span class="hljs-comment"># 新语法string</span><br>template(namme=<span class="hljs-string">&quot;remote&quot;</span> <span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;string&quot;</span> string=<span class="hljs-string">&quot;message from %hostname%, received at %timegenerated%.&quot;</span>)<br><span class="hljs-comment"># 新语法list</span><br><span class="hljs-comment"># constant用于定义字面字符串值，而property用于定义实际的属性</span><br>template(name=<span class="hljs-string">&quot;dbFormat&quot;</span> <span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;list&quot;</span> option.sql=<span class="hljs-string">&quot;on&quot;</span>) &#123;<br>    constant(value=<span class="hljs-string">&quot;insert into SystemEvents (Message, FromHost,ReceivedAt)&quot;</span>)<br>    constant(value=<span class="hljs-string">&quot; values (&#x27;&quot;</span>)<br>    property(name=<span class="hljs-string">&quot;msg&quot;</span>)<br>    constant(value=<span class="hljs-string">&quot;, &#x27;&quot;</span>)<br>    property(name=<span class="hljs-string">&quot;hostname&quot;</span>)<br>    constant(value=<span class="hljs-string">&quot;&#x27;, &#x27;&quot;</span>)<br>    property(name=<span class="hljs-string">&quot;timegenerated&quot;</span> dateFormat=<span class="hljs-string">&quot;mysql&quot;</span>)<br>    constant(value=<span class="hljs-string">&quot;&#x27;)&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>ruleset</p>
<p>  ruleset推荐用新的语法,比原来的清晰了很多。</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 旧语法</span><br><span class="hljs-variable">$Ruleset</span> remote<br>mail.none /var/<span class="hljs-built_in">log</span>/mail.log<br>cron.none /var/<span class="hljs-built_in">log</span>/cron.log<br><br><span class="hljs-variable">$ModLoad</span> imtcp<br><span class="hljs-variable">$InputTCPBindRuleset</span> remote<br><span class="hljs-variable">$InputTCPServerRun</span> 514<br><span class="hljs-comment"># 新语法</span><br>ruleset(name=<span class="hljs-string">&quot;remote-514&quot;</span>) &#123;<br>cron.none action(<span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;omfile&quot;</span> file=<span class="hljs-string">&quot;/var/log/remote-514-cron&quot;</span>)<br>mail.none action(<span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;omfile&quot;</span> file=<span class="hljs-string">&quot;/var/log/remote-514-mail&quot;</span>)<br>&#125;<br><br>input(<span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;imtcp&quot;</span> port=<span class="hljs-string">&quot;514&quot;</span> ruleset=<span class="hljs-string">&quot;remote-514&quot;</span>);<br></code></pre></td></tr></table></figure>
<h2 id="4-日志轮转–Logrotate"><a href="#4-日志轮转–Logrotate" class="headerlink" title="4.日志轮转–Logrotate"></a>4.日志轮转–Logrotate</h2><p>在查看日志时我们很容易就发现出现有命名类似于syslog syslog.1 syslog.2.gz等类型的日志,这些日志都是靠<code>Logrotate</code>进行日志轮转的,方便我们对日志进行查找和管理。<br><code>Logrotate</code>的主脚本位于<code>/etc/cron.daily/logrotate</code>， 它不会自动运行， 而是通过contab定时运行脚本执行日志轮转。 <code>Logrotate</code>不止可以针对系统日志, 还可以使一些应用本身不带日志轮转功能,或者本身日志轮换功能残缺的应用(对就是说Supervisor)拥有完善,高自定义的日志轮转功能。</p>
<blockquote>
<p>如果多个程序（多个进程）写入到同一个日志文件，那请不要使用程序自己的轮转来轮转日志， 不然会出现丢数据的情况。建议所有的日志轮转都使用<code>Logrotate</code></p>
</blockquote>
</li>
</ul>
<p><code>Logrotate</code>实际运行时，会调用配置文件<code>/etc/logrotate.conf</code>。我们除了修改<code>/etc/logrotate.conf</code>文件外， 还可以在<code>/etc/logrotate.d</code>目录里放置自定义好的配置文件，用来覆盖Logrotate的缺省值。<br>同时， 这些脚本我们也可以手动执行, 不过要记得添加-f参数,表示强制轮转, 否则<code>Logrotate</code>会判断还没达到条件而不执行轮转。此外， 手动运行时最好要添加-d参数来测试配置文件是否有错误,常用参数如下:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">logrotate [OPTION...] &lt;configfile&gt;<br>-d, --debug ：debug模式，测试配置文件是否有错误。<br>-f, --force ：强制转储文件。<br>-m, --mail=<span class="hljs-built_in">command</span> ：压缩日志后，发送日志到指定邮箱。<br>-s, --state=statefile ：使用指定的状态文件。<br>-v, --verbose ：显示转储过程。<br></code></pre></td></tr></table></figure>
<p><code>Logrotate</code>的原理是检查日志是否需要轮转, 以及在轮转后使进程重新打开文件描述符(有两种方法， 最优的方法是发送信号量, 不过需要程序支持), 确保进程能重新打开文件，写入到新的文件。</p>
<blockquote>
<p>如果程序不支持信号量重载日志文件描述符的方法， 那就只能在脚本启用copytruncate，该方法会直接把文本的内容复制到新的文件后再清空当前的日志文件， 如果文件的数据量过高则有可能漏掉一些日志。</p>
</blockquote>
<p>一般来说,我们只要在/etc/logrotate.d/目录下配置针对某个日志的日志文件轮转配置就可以了, 这个配置文件主要是声明要轮换的日志文件路径以及花括号内配置轮转属性, 以<code>Nginx</code>为例子:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 匹配Nginx的所有日志</span><br>/usr/<span class="hljs-built_in">local</span>/nginx/logs/*<span class="hljs-built_in">log</span> &#123;<br>    daily<br>    <span class="hljs-comment"># 每天转储</span><br>    rotate 30<br>    <span class="hljs-comment"># 只保存30个备份</span><br>    missingok<br>    <span class="hljs-comment"># 在日志转储期间,任何错误将被忽略</span><br>    notifempty<br>    <span class="hljs-comment"># 文件为空时不转储</span><br>    compress<br>    <span class="hljs-comment"># 通过 gzip 压缩</span><br>    dateext<br>    <span class="hljs-comment"># 日志文件以当前日期为格式结尾</span><br>    sharedscripts<br>    <span class="hljs-comment"># 所有日志文件转储完毕后执行一次脚本</span><br>    postrotate<br>    <span class="hljs-comment"># 转储之后执行命令, 和endscript成对使用</span><br>    <span class="hljs-comment"># 该命令使nginx重新打开日志文件描述符，</span><br>        /bin/<span class="hljs-built_in">kill</span> -USR1 \$(cat /usr/<span class="hljs-built_in">local</span>/nginx/logs/nginx.pid 2&gt;/dev/null) 2&gt;/dev/null || :<br>    endscript<br>    <span class="hljs-comment"># 转储之后执行命令，和postrotate成对使用</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>此外， 如果像<code>rsyslog</code>一样控制的日志比较多,可以像以下这样配置,多个日志文件多行显示,并同样的用花括号把配置包起来</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">/var/<span class="hljs-built_in">log</span>/mail<br>/var/<span class="hljs-built_in">log</span>/messages<br>/var/<span class="hljs-built_in">log</span>/syslog<br>&#123;<br>    sharedscripts<br>    dateext<br>    rotate 25<br>    size 40M<br>    compress<br>    dateformat -%Y%m%d%s<br>    postrotate<br>            /bin/<span class="hljs-built_in">kill</span> -HUP `cat /var/run/syslogd.pid 2&gt; /dev/null` 2&gt; /dev/null || <span class="hljs-literal">true</span><br>    endscript<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="4-1logrotate参数"><a href="#4-1logrotate参数" class="headerlink" title="4.1logrotate参数"></a>4.1logrotate参数</h3><p><code>Logrotate</code>的主要使用也是以配置为主,需要注意一些配置, 不然logrotate会以文件太小或者时间间隔比较低(如配置1天轮转一次,logrotate首次轮转可能要间隔两天)而不进行轮转<br>| 参数 | 描述 |<br>| ———————– | ———————————————————— |<br>|dateext |  切换后的日志文件会附加上一个短横线和YYYYMMDD格式的日期，没有这个配置项会附加一个小数点加一个数字序号.|<br>|dateformat | 配合dateext使用可以为切割后的日志加上YYYYMMDD格式的日期，如dateformat -%Y%m%d|<br>| compress | 通过gzip 压缩转储以后的日志 |<br>| nocompress | 不需要压缩时，用这个参数 |<br>| copytruncate | 用于还在打开中的日志文件，把当前日志备份并截断 |<br>| nocopytruncate | 备份日志文件但是不截断 |<br>| create mode owner group | 转储文件，使用指定的文件模式创建新的日志文件 |<br>| nocreate | 不建立新的日志文件 |<br>| delaycompress | 一起使用时，转储的日志文件到下一次转储时才压缩 |<br>| nodelaycompress | 覆盖 delaycompress 选项，转储同时压缩。 |<br>| errors address | 专储时的错误信息发送到指定的Email 地址 |<br>| ifempty | 即使是空文件也转储，这个是 logrotate 的缺省选项。 |<br>| notifempty | 如果是空文件的话，不转储 |<br>| mail address | 把转储的日志文件发送到指定的E-mail 地址 |<br>| nomail | 转储时不发送日志文件 |<br>| olddir directory | 转储后的日志文件放入指定的目录，必须和当前日志文件在同一个文件系统 |<br>| noolddir | 转储后的日志文件和当前日志文件放在同一个目录下 |<br>|sharedscripts  | 运行postrotate脚本，作用是在所有日志都轮转后统一执行一次脚本。如果没有配置这个，那么每个日志轮转后都会执行一次脚本 |<br>| prerotate/endscript | 在转储以前需要执行的命令可以放入这个对，这两个关键字必须单独成行 |<br>| postrotate/endscript | 在转储以后需要执行的命令可以放入这个对，这两个关键字必须单独成行 |<br>| daily | 指定转储周期为每天 |<br>| weekly | 指定转储周期为每周 |<br>| monthly | 指定转储周期为每月 |<br>| rotate count | 指定日志文件删除之前转储的次数，0 指没有备份，5 指保留5 个备份 |<br>| tabootext [+] list | 让logrotate 不转储指定扩展名的文件，缺省的扩展名是：.rpm-orig, .rpmsave, v, 和 ~ |<br>| size size | 当日志文件到达指定的大小时才转储，后缀MB. |</p>
<h2 id="5-一些常见坑"><a href="#5-一些常见坑" class="headerlink" title="5.一些常见坑"></a>5.一些常见坑</h2><p>可以看到整套日志流程涉及多个流程和多种参数， 所以容易因为参数导致出现一些问题， 以下是我遇到的几个问题和解决办法：</p>
<ul>
<li>log太长了,被截断;<br>这是由于被$MaxMessageSize限制的,它的默认大小是2k，大概可以保存1000个中文字符,在加载<code>imtcp/imudp</code>之前设置， 此配置包括发送和接收，所以rsyslog客户端、服务端都要设置</li>
<li>如果一行日志消息大小大于4K,只能用TCP。这是因为UDP栈大小限制的。</li>
<li>某个系统日志文件过大;<br>像用debian的话,可以看到/var/log/syslog会随着你的配置,里面的东西越来越多,主要要对该行默认配置进行修改,不然所有日志都会发送到这里了(以定义了local5,6为例子)  <figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">*.info;mail.none;authpriv.none;cron.none /var/<span class="hljs-built_in">log</span>/syslog<br>*.info;mail.none;authpriv.none;cron.none;local5.none;local6.none /var/<span class="hljs-built_in">log</span>/messages<br></code></pre></td></tr></table></figure></li>
<li>接收端保存的文件路径不对; 主要是用到了tag, 且他们两个tag有共同的前缀导致匹配出错，解决办法是调整顺序， 把长的放在前面, 比如如下配置：  <figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># For erp_wms</span><br><span class="hljs-variable">$template</span> erp_wms_FileFormat,<span class="hljs-string">&quot;/Data/logs/erp/wms/%fromhost-ip%/%syslogtag:F,44:2%-%<span class="hljs-variable">$YEAR</span>%%<span class="hljs-variable">$MONTH</span>%%<span class="hljs-variable">$DAY</span>%.log&quot;</span><br><span class="hljs-keyword">if</span> <span class="hljs-variable">$syslogtag</span> startswith <span class="hljs-string">&#x27;erp_wms&#x27;</span> <span class="hljs-keyword">then</span> ?erp_wms_FileFormat;CleanMsgFormat<br>&amp; ~<br><br><span class="hljs-comment"># For erp_wms3</span><br><span class="hljs-variable">$template</span> erp_wms3_FileFormat,<span class="hljs-string">&quot;/Data/logs/erp/wms3/%fromhost-ip%/%syslogtag:F,44:2%-%<span class="hljs-variable">$YEAR</span>%%<span class="hljs-variable">$MONTH</span>%%<span class="hljs-variable">$DAY</span>%.log&quot;</span><br><span class="hljs-keyword">if</span> <span class="hljs-variable">$syslogtag</span> startswith <span class="hljs-string">&#x27;erp_wms3&#x27;</span> <span class="hljs-keyword">then</span> ?erp_wms3_FileFormat;CleanMsgFormat<br>&amp; ~<br></code></pre></td></tr></table></figure>
  修改后  <figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 这里注意下面的tag的顺序， 一定要让长的tag（erp_wms3）保持在上面，因为他们有共同的前缀(erp_wms)</span><br><span class="hljs-comment"># For erp_wms3</span><br><span class="hljs-variable">$template</span> erp_wms3_FileFormat,<span class="hljs-string">&quot;/Data/logs/erp/wms3/%fromhost-ip%/%syslogtag:F,44:2%-%<span class="hljs-variable">$YEAR</span>%%<span class="hljs-variable">$MONTH</span>%%<span class="hljs-variable">$DAY</span>%.log&quot;</span><br><span class="hljs-keyword">if</span> <span class="hljs-variable">$syslogtag</span> startswith <span class="hljs-string">&#x27;erp_wms3&#x27;</span> <span class="hljs-keyword">then</span> ?erp_wms3_FileFormat;CleanMsgFormat<br>&amp; ~<br><br><span class="hljs-comment"># For erp_wms</span><br><span class="hljs-variable">$template</span> erp_wms_FileFormat,<span class="hljs-string">&quot;/Data/logs/erp/wms/%fromhost-ip%/%syslogtag:F,44:2%-%<span class="hljs-variable">$YEAR</span>%%<span class="hljs-variable">$MONTH</span>%%<span class="hljs-variable">$DAY</span>%.log&quot;</span><br><span class="hljs-keyword">if</span> <span class="hljs-variable">$syslogtag</span> startswith <span class="hljs-string">&#x27;erp_wms&#x27;</span> <span class="hljs-keyword">then</span> ?erp_wms_FileFormat;CleanMsgFormat<br>&amp; ~<br></code></pre></td></tr></table></figure></li>
<li>接收端<code>rsyslog</code>文件名太长后被截断, 这个一般是发送端的配置造成的， 如以下发送端默认配置：  <figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">template (name=<span class="hljs-string">&quot;ForwardFormat&quot;</span> <span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;string&quot;</span> string=<span class="hljs-string">&quot;&lt;%PRI%&gt;%TIMESTAMP:::date-rfc3339% %HOSTNAME%</span><br><span class="hljs-string">%syslogtag:1:32%%msg:::sp-if-no-1st-sp%%msg%&quot;</span>)<br></code></pre></td></tr></table></figure>
  中的<code>%syslogtag:1:32%</code>限制了文件名长度,所以需要发送端重新绑定到一个新的模板<h2 id="6-常见rsyslog不记日志问题"><a href="#6-常见rsyslog不记日志问题" class="headerlink" title="6.常见rsyslog不记日志问题"></a>6.常见rsyslog不记日志问题</h2>前记里说过， 我是因为遇到日志写入缺少时才开始查看整个Linux的日志机制， 在查阅资料后我总结了以下几个不记日志的原因：</li>
<li>1.<code>OOM kernel</code>不能及时释放cache来满足应用程序的突发内存需求的情况。</li>
<li>2.系统内存严重不够或者Rsyslog限制了它将在内存中保留的消息数量。如果该消息大于系统中的内存，则需要调整它。要么给机器更多内存，要么将rsyslog配置为更小的队列大小。</li>
<li>3.jounald配置问题， 数据只暂存于内存中， 且由于系统内存不够导致部分日志被删除了。</li>
<li>4.回车控制符(来源于网络,没遇到过)<br>有可能是由于某用户的debug或者info log中，包含了回车控制符\n，而我们rsyslog client段的配置文件中EscapeControlCharactersOnReceive是off的，即不对控制符做转义，所以含有\n控制符的log被发送给了rsyslog center。而rsyslog center是根据回车控制符\n来判断是不是一条log的。如果用户的log中包含类似字段：GET /123/id=123&amp;\n90887294–sdf，那么rsyslog会把”GET /123/id=123&amp;“当作一条log，而把90887294作为下一条message的长度，并且会有刚才的Framing Error的报错。rsyslog会等待接收90887294byte的数据，然后判断大于了MaxMessageSize 4KB，然后rsyslog就只保存了从90887294开始之后的4KB日志，剩下的90887294 - 4*1024= 90883198byte的数据全被截断丢弃。这就有了received oversize message的报错。<br>解决办法：  <figure class="highlight vim"><table><tr><td class="code"><pre><code class="hljs vim">issues：http<span class="hljs-variable">s:</span>//github.<span class="hljs-keyword">com</span>/rsyslog/rsyslog/issues/<span class="hljs-number">111</span><br><span class="hljs-number">1</span>,开启rsyslog client的EscapeControlCharactersOnReceive为<span class="hljs-keyword">on</span>状态。对回车控制符进行转义，即可避免此问题<br>影响：把用户<span class="hljs-built_in">log</span>中的\n转换成了以#开头的三位八进制数#<span class="hljs-number">012</span>。（根基<span class="hljs-keyword">ascii</span>表转换）<br><span class="hljs-number">2</span>,关闭rsyslog <span class="hljs-keyword">center</span>的SupportOctetCountedFraming为off状态。即不支持Octet数据流。<br>影响：当用户<span class="hljs-built_in">log</span>中有\n的时候，<span class="hljs-built_in">log</span>会被截断。<br></code></pre></td></tr></table></figure></li>
<li>5.rsyslog 性能跟不上导致丢日志，需要进行调优如对rsyslog的main queue和action queue进行调优<h2 id="7-附录A-用python发送日志到syslog"><a href="#7-附录A-用python发送日志到syslog" class="headerlink" title="7.附录A:用python发送日志到syslog"></a>7.附录A:用python发送日志到syslog</h2><code>Python</code>的logging模块除了自己输出日志外， 也兼容Linux的日志机制。 修改方法也十分简单， 只需要对logger进行一些小修改， 就可以把日志发向<code>/dev/log/</code>从而被<code>rsyslog</code>捕获到日志, 以下是一个普通的logging代码:<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-comment"># 初始化logger</span><br>logger = logging.getLogger(<span class="hljs-string">&#x27;exp&#x27;</span>)<br>logger.setLevel(logging.INFO)<br><span class="hljs-comment"># 初始化handler</span><br>filehandler = logging.FileHandler(os.environ[<span class="hljs-string">&#x27;HOME&#x27;</span>] + <span class="hljs-string">&#x27;/exp.log&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf8&#x27;</span>)<br>filehandler.setFormatter(logging.Formatter(<span class="hljs-string">&quot;%(asctime)s - %(levelname)s - %(message)s&quot;</span>))<br>logger.addHandler(filehandler)<br></code></pre></td></tr></table></figure>
进行以下修改后， 他就可以发送到<code>rsyslog</code>了:<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-comment"># 初始化logger</span><br>logger = logging.getLogger(<span class="hljs-string">&#x27;exp&#x27;</span>)<br>logger.setLevel(logging.INFO)<br><span class="hljs-comment"># 初始化handler, 这个handler是sysloghandle， 且定义了输出是本机的/dev/log, 还定义了一些syslog参数</span><br>sys_handler = logging.handlers.SysLogHandler(<span class="hljs-string">&#x27;/dev/log&#x27;</span>, facility=logging.handlers.SysLogHandler.LOG_LOCAL0)<br>sys_handler.setFormatter(logging.Formatter(<span class="hljs-string">&#x27;exp_log&#x27;</span> + <span class="hljs-string">&quot;:%(asctime)s - %(name)s - %(levelname)s - %(message)s&quot;</span>))<br>logger.addHandler(sys_handler)<br></code></pre></td></tr></table></figure>
另外,如果你想用python读日志的话也可以直接监听/dev/log/再打印日志<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> socket<br><span class="hljs-keyword">import</span> time<br>sock = socket.socket(socket.AF_UNIX, socket.SOCK_DGRAM)<br>sock.bind(<span class="hljs-string">&#x27;/dev/log&#x27;</span>) <span class="hljs-comment">#需要先手动kill掉已经在运行的[r]syslogd进程，否则这里无法执行成功</span><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    time.sleep(<span class="hljs-number">5</span>)<br>    data, addr = sock.recvfrom(<span class="hljs-number">1024</span>)<br>    print(data)<br></code></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Rsyslog</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux日志--logrotate</title>
    <url>/2019/11/03/logrotate/</url>
    <content><![CDATA[<h2 id="前记"><a href="#前记" class="headerlink" title="前记"></a>前记</h2><p>生产的机器会产生很多的日志, 如果不对日志进行管理, 日志会不断消耗硬盘空间, 直到把硬盘挤爆, 同时所有日志挤在同一个文件, 也很难去翻前几天的日志数据, 这时候就需要一个日志管理工具–<code>logrotate</code>.<br>Linux机器中自带<code>logrotate</code>用于日志轮转, 他的实现是最简单的, 也是最好用的, 基本适用所有情况, 一般情况下, 机器上面有logrotate时, 就不要使用其他的日志轮转, 如Python日志模块的转换, Java日志模块的转换, supervisor的日志轮转模块, 他们在多线程/多进程的时候基本有坑.</p>
<span id="more"></span>

<h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h2><p><code>logrotate</code>是一个linux系统日志的管理工具。可以对单个日志文件或者某个目录下的文件按时间或者文件大小进行切割，压缩等操作, 并能按照指定设置的保留n个日志；还可以在切割之后运行自定义命令。</p>
<p>logrotate 并不是一个守护进程, 正常情况下不会启动, 而是按照一定的周期启动的, 这个周期是基于<code>crontab</code>运行的，所以这个时间点是由 crontab 控制的，具体可以查询 crontab 的配置文件<code>/etc/crontab</code>. 系统会按照计划的频率运行 logrotate，通常是每天, 也就是通过<code>/etc/cron.daily/logrotate</code>配置文件来配置logrotate的运行.</p>
<p><code>logrotate</code>默认的配置文件<code>/etc/logrotate.conf</code>里有一句<code>include /etc/logrotate.d</code>, 所以<code>logrotate</code>在启动后会读取<code>/etc/logrotate.d</code>里的所有配置, 如果我们有新的需求, 就在该目录下面创建需求对应的文件夹, 并在里面写<code>logrotate</code>脚本, 或者在<code>/etc/logrotate.d</code>里面直接写配置文件.</p>
<p>当时间到时,<code>crontab</code>会通过命令调用启动<code>logrotate</code>,<code>logrotate</code>使用<code>/etc/logrotate.conf</code>配置文件, 按照文件执行轮换/清理日志文件.</p>
<h2 id="2-轮换机制"><a href="#2-轮换机制" class="headerlink" title="2.轮换机制"></a>2.轮换机制</h2><p><code>logrotate</code> 是一个普通的文件, 为了能不侵入代码且在执行日志轮转后 程序能写到新的日志文件, <code>logrotate</code>提供两套日志轮换方法.</p>
<ul>
<li><p>create<br>这是最好的方案也是默认的方案,这个方案是重命名旧文件, 再创建一个新的文件, 在告诉程序把日志流写到新的文件, 前两步比较简单, 最后一步比较复杂, 需要程序的支持, 具体如下:</p>
<ul>
<li>1.重命名正在输出日志文件，因为重命名只修改目录以及文件的名称，而进程操作文件使用的是<code>inode</code>, 所以并不影响原程序继续输出日志. 可以看到程序在往重命名的文件输出日志.</li>
<li>2.创建新的日志文件，文件名和原日志文件一样，此时只是文件名称一样，而<code>inode</code>编号不同，原程序输出的日志还是往原日志文件输出, 并不会对该新创建的日志文件输日志.</li>
<li>3.最后通过信号通知程序，程序收到信号后会重新打开日志文件;由于重新打开日志文件会用到文件路径而非<code>inode</code>编号，所以打开的是新的日志文件, 此时程序的日志流就会输到新的日志文件.<br>总的来说, 就是mv文件,再create文件, 然后再通知程序重新打开日志文件, 这几个操作的成本很低, 一般redis, nginx, mysql都使用这种方式.<br>上面说的信号其实是Linux的USR1信号, 它常被用来告知应用程序重载配置文件,通过<code>kill -USR1 xx.pid</code>把信号发送给对应的pid(除非这个程序的文档有说是靠另外一个信号来控制的)<br><a href="www.baidu.com">TODO inode说明参见</a></li>
</ul>
</li>
<li><p>copytruncate<br>create方式虽好, 但不是所有的程序都支持监听信号并做出响应的操作, 这时候只能使用土办法了: 直接把日志的数据从文件1copy到文件2, 并清空文件1的数据, 具体如下:</p>
<ul>
<li>1.将当前正在输出的日志文件复制为目标文件，此时程序仍然将日志输出到原来文件中，此时，原文件名也没有变.</li>
<li>2.清空日志文件，原程序仍然还是输出到预案日志文件中，因为清空文件只把文件的内容删除了，而<code>inode</code>并没改变，后续日志的输出仍然写入该文件中,但是查看文件后可以发现文件像新创建的一样.<br>这种方式十分简单, 只需要两步操作, 但是具体的操作成本比较高, 当日志文件比较大时, 复制就会比较耗时导致可能丢失部分日志, 这是<code>copytruncate</code>的缺点之一, 但很多人都不会遇到很大的日志文件.</li>
</ul>
</li>
</ul>
<h2 id="3-logrotate的配置"><a href="#3-logrotate的配置" class="headerlink" title="3.logrotate的配置"></a>3.logrotate的配置</h2><p><code>logrotate</code>也有一套自己的配置, 用户只要写好了这配置, 放到<code>/etc/logrotate.d/</code>就可以被<code>logrotate</code>调用到, <code>logrotate</code>配置主要是告诉<code>logrotate</code>对哪些文件进行哪些操作, 具体可以看如下的nginx的<code>logrotate</code>配置:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 这里配置了日志的所在位置, *号代表匹配xxxlog的日志</span><br>/usr/<span class="hljs-built_in">local</span>/nginx/logs/*<span class="hljs-built_in">log</span> &#123;<br>    daily          <span class="hljs-comment"># 每天转储</span><br>    rotate 30      <span class="hljs-comment"># 保存30个备份, 一般按时间排序, 超过30天前的日志会被删除</span><br>    missingok      <span class="hljs-comment"># 在日志转储期间,任何错误将被忽略, 如权限不够, 找不到文件等</span><br>    notifempty     <span class="hljs-comment"># 文件为空时不转储</span><br>    compress       <span class="hljs-comment"># 轮转后的日志 通过 gzip 压缩</span><br>    dateext        <span class="hljs-comment"># 日志文件以当前日期为格式结尾</span><br>    sharedscripts  <span class="hljs-comment"># 所有日志文件转储完毕后再执行下面的脚本</span><br>    postrotate     <span class="hljs-comment"># 转储之后执行命令，和endscript成对使用</span><br>        <span class="hljs-comment"># 发送信号给nginx, 把返回的输出写到/dev/null中丢掉</span><br>        /bin/<span class="hljs-built_in">kill</span> -USR1 \$(cat /usr/<span class="hljs-built_in">local</span>/nginx/logs/nginx.pid 2&gt;/dev/null) 2&gt;/dev/null || :<br>    endscript      <span class="hljs-comment"># 转储之后执行命令，和postrotate成对使用</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>上面只是对一种类型的日志进行轮换, 如果像<code>rsyslog</code>一样, 可以通过如下以回车切分多行配置多种类型日志来适用同一套规则:</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><code class="hljs gradle"><span class="hljs-regexp">/var/</span>log/mail<br><span class="hljs-regexp">/var/</span>log/messages<br><span class="hljs-regexp">/var/</span>log/syslog<br>&#123;<br>        sharedscripts<br>        dateext<br>        rotate <span class="hljs-number">25</span><br>        <span class="hljs-keyword">size</span> <span class="hljs-number">40</span>M<br>        compress<br>        dateformat -%Y%m%d%s<br>        postrotate<br>                <span class="hljs-regexp">/bin/</span>kill -HUP `cat <span class="hljs-regexp">/var/</span>run<span class="hljs-regexp">/syslogd.pid 2&gt; /</span>dev<span class="hljs-regexp">/null` 2&gt; /</span>dev/<span class="hljs-keyword">null</span> || <span class="hljs-keyword">true</span><br>        endscript<br>&#125;<br></code></pre></td></tr></table></figure>
<p>可以看到配置文件十分简单, 实际上<code>logrotate</code>的配置也不多, 具体如下:<br>| 参数 | 描述 |<br>| —| — |<br>| dateext | 切换后的日志文件会附加上一个短横线和YYYYMMDD格式的日期，没有这个配置项会附加一个小数点加一个数字序号.|<br>| dateformat | 配合dateext使用可以为切割后的日志加上YYYYMMDD格式的日期，如dateformat -%Y%m%d|<br>| compress | 通过gzip 压缩转储以后的日志 |<br>| nocompress | 不需要压缩时，用这个参数 |<br>| delaycompress | 一起使用时，转储的日志文件到下一次转储时才压缩 |<br>| nodelaycompress | 覆盖 delaycompress 选项，转储同时压缩。 |<br>| copytruncate | 用于还在打开中的日志文件，把当前日志备份并清空 |<br>| nocopytruncate | 备份日志文件但是不截断 |<br>| create mode owner group | 转储文件，使用指定的文件模式创建新的日志文件 |<br>| nocreate | 不建立新的日志文件 |<br>| errors address | 专储时的错误信息发送到指定的Email 地址 |<br>| ifempty | 即使是空文件也转储，这个是 logrotate 的缺省选项。 |<br>| notifempty | 如果是空文件的话，不转储 |<br>| mail address | 把转储的日志文件发送到指定的E-mail 地址 |<br>| nomail | 转储时不发送日志文件 |<br>| olddir directory | 转储后的日志文件放入指定的目录，必须和当前日志文件在同一个文件系统 |<br>| noolddir | 转储后的日志文件和当前日志文件放在同一个目录下 |<br>| sharedscripts | 运行postrotate脚本，作用是在所有日志都轮转后统一执行一次脚本。如果没有配置这个，那么每个日志轮转后都会执行一次脚本 |<br>| prerotate/endscript | 在转储以前需要执行的命令可以放入这个对，这两个关键字必须单独成行 |<br>| postrotate/endscript | 在转储以后需要执行的命令可以放入这个对，这两个关键字必须单独成行 |<br>| daily | 指定转储周期为每天 |<br>| weekly | 指定转储周期为每周 |<br>| monthly | 指定转储周期为每月 |<br>| rotate count | 指定日志文件删除之前转储的次数，0 指没有备份，5 指保留5 个备份 |<br>| tabootext [+] list | 让logrotate 不转储指定扩展名的文件，缺省的扩展名是：.rpm-orig, .rpmsave, v, 和 ~ |<br>| size size | 当日志文件到达指定的大小时才转储，后缀MB. |</p>
<h2 id="4-手动调用logrotate命令"><a href="#4-手动调用logrotate命令" class="headerlink" title="4.手动调用logrotate命令"></a>4.手动调用logrotate命令</h2><p>一般情况写完配置文件, 我们都需要测试文件是否合法或者需要手动轮转日志, 这时候就需要用到logrotate命令了, 具体的logrotate命令如下:</p>
<figure class="highlight jboss-cli"><table><tr><td class="code"><pre><code class="hljs jboss-cli">logrotate [OPTION.<span class="hljs-string">..</span>] &lt;configfile&gt;<br>-d, <span class="hljs-params">--debug</span> ：debug模式，测试配置文件是否有错误。<br>-f, <span class="hljs-params">--force</span> ：强制转储文件。<br>-m, <span class="hljs-params">--mail=command</span> ：压缩日志后，发送日志到指定邮箱。<br>-s, <span class="hljs-params">--state=statefile</span> ：使用指定的状态文件。<br>-v, <span class="hljs-params">--verbose</span> ：显示转储过程。<br></code></pre></td></tr></table></figure>

<p>默认<code>crontab</code>通过调用<code>logrotate /etc/logrotate.conf</code>来启动<code>logrotate</code>以及读取对应的配置文件, 我们也可以通过这样来启动, 不过一般情况不建议直接使用<code>logrotate /etc/logrotate.conf</code>, 而是要直接调用我们自己的文件. 此外, 每次写完一个配置文件, 都要<code>logrotate -d xxx</code>来检查文件是否配置正常</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>日志</tag>
      </tags>
  </entry>
  <entry>
    <title>如何把自己的Python应用容器化</title>
    <url>/2019/10/07/docker%E9%83%A8%E7%BD%B2python%E5%90%8E%E5%8F%B0%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<p>现在云原生越来越流行, 容器化势在必行, 作为一个开发人员， 多多少少也要接触一些容器相关的操作， 其中最基础的操作是如何把自己的应用构建为一个<code>Docker</code>容器， 并管理。 本文以<code>starlette</code>框架和后台的开发常见3件套<code>Nginx</code>， <code>MySQL</code>和<code>Redis</code>为底创建一个简单的Web后台演示项目, 并一步一步介绍如何编写成一个容器以及容器的运行。</p>
<span id="more"></span>

<p>注: 2021-02-07增加了示例代码<br>注: 2021-12-12部分内容进行重写</p>
<h2 id="1-创建项目"><a href="#1-创建项目" class="headerlink" title="1.创建项目"></a>1.创建项目</h2><p>第一步会先创建一个<code>Python</code>后台项目， 这个项目包含3个接口， 一个接口用来测试服务是否正常， 另外一个是测试<code>MySQL</code>调用， 最后一个是测试<code>Redis</code>调用。</p>
<p>首先是创建一个后台项目以及依赖:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">➜  example_python git:(master) mkdir python_on_docker          <br>➜  example_python git:(master) <span class="hljs-built_in">cd</span> python_on_docker <br><span class="hljs-comment">#　一个项目配套一个虚拟环境, 如果熟悉, 建议用porety来处理项目的python和venv配套环境问题, 这里为了演示方便, 使用了venv</span><br>➜  python_on_docker git:(master) python3.7 -m venv venv<br>➜  python_on_docker git:(master) <span class="hljs-built_in">source</span> venv/bin/activate <br>➜  python_on_docker git:(master) touch __init__.py  <span class="hljs-comment"># 每个Python项目要确保有一个__init__.py文件 </span><br><br><span class="hljs-comment"># 可以看到多了个venv的环境, 目前已经切到venv, 开始安装依赖</span><br>(venv) ➜  python_on_docker git:(master) pip install starlette aiomysql aioredis uvicorn<br>(venv) ➜  python_on_docker git:(master) pip install cryptography  <span class="hljs-comment"># aiomysql需要该模块提供加密算法</span><br><span class="hljs-comment"># 生成pip安装的依赖文件</span><br>(venv) ➜  python_on_docker git:(master) python -m pip freeze &gt; requirements.txt<br></code></pre></td></tr></table></figure>
<p>之后创建项目主文件<code>example.py</code>, 该文件主要提供API服务，里面包含上面所说的3个接口, 示例代码如下(<a href="https://github.com/so1n/example/blob/master/example_python/example_python/python_on_docker/version_1/example.py">源码</a>):</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> Optional, Tuple<br><br><span class="hljs-keyword">import</span> aiomysql<br><span class="hljs-keyword">import</span> aioredis<br><span class="hljs-keyword">from</span> starlette.applications <span class="hljs-keyword">import</span> Starlette<br><span class="hljs-keyword">from</span> starlette.config <span class="hljs-keyword">import</span> Config<br><span class="hljs-keyword">from</span> starlette.requests <span class="hljs-keyword">import</span> Request<br><span class="hljs-keyword">from</span> starlette.responses <span class="hljs-keyword">import</span> JSONResponse, PlainTextResponse<br><span class="hljs-keyword">from</span> starlette.routing <span class="hljs-keyword">import</span> Route<br><br><br>config: Config = Config(<span class="hljs-string">&quot;.env&quot;</span>)<br>mysql_pool: Optional[aiomysql.Pool] = <span class="hljs-literal">None</span><br>redis: Optional[aioredis.Redis] = <span class="hljs-literal">None</span><br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">on_start_up</span>():</span><br>    <span class="hljs-string">&quot;&quot;&quot;连接MySQL和Redis&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">global</span> mysql_pool<br>    <span class="hljs-keyword">global</span> redis<br><br>    mysql_pool = <span class="hljs-keyword">await</span> aiomysql.create_pool(<br>        host=config(<span class="hljs-string">&quot;MYSQL_HOST&quot;</span>),<br>        port=config(<span class="hljs-string">&quot;MYSQL_PORT&quot;</span>, cast=<span class="hljs-built_in">int</span>),<br>        user=config(<span class="hljs-string">&quot;MYSQL_USER&quot;</span>),<br>        password=config(<span class="hljs-string">&quot;MYSQL_PW&quot;</span>),<br>        db=config(<span class="hljs-string">&quot;MYSQL_DB&quot;</span>),<br>    )<br>    redis = aioredis.Redis(<br>        <span class="hljs-keyword">await</span> aioredis.create_redis_pool(<br>            config(<span class="hljs-string">&quot;REDIS_URL&quot;</span>),<br>            minsize=config(<span class="hljs-string">&quot;REDIS_POOL_MINSIZE&quot;</span>, cast=<span class="hljs-built_in">int</span>),<br>            maxsize=config(<span class="hljs-string">&quot;REDIS_POOL_MAXSIZE&quot;</span>, cast=<span class="hljs-built_in">int</span>),<br>            encoding=config(<span class="hljs-string">&quot;REDIS_ENCODING&quot;</span>)<br>        )<br>    )<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">on_shutdown</span>():</span><br>    <span class="hljs-string">&quot;&quot;&quot;关闭MySQL和Redis连接&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">await</span> mysql_pool.wait_closed()<br>    <span class="hljs-keyword">await</span> redis.wait_closed()<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hello_word</span>(<span class="hljs-params">request: Request</span>) -&gt; PlainTextResponse:</span><br>    <span class="hljs-string">&quot;&quot;&quot;测试接口调用接口&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">return</span> PlainTextResponse(<span class="hljs-string">&quot;Hello Word!&quot;</span>)<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">mysql_demo</span>(<span class="hljs-params">request: Request</span>) -&gt; JSONResponse:</span><br>    <span class="hljs-string">&quot;&quot;&quot;测试MySQL调用接口&quot;&quot;&quot;</span><br>    count: <span class="hljs-built_in">int</span> = <span class="hljs-built_in">int</span>(request.query_params.get(<span class="hljs-string">&quot;count&quot;</span>, <span class="hljs-string">&quot;0&quot;</span>))<br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> mysql_pool.acquire() <span class="hljs-keyword">as</span> conn:<br>        <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> conn.cursor() <span class="hljs-keyword">as</span> cur:<br>            <span class="hljs-keyword">await</span> cur.execute(<span class="hljs-string">&quot;SELECT %s;&quot;</span>, (count, ))<br>            mysql_result_tuple: Tuple[<span class="hljs-built_in">int</span>] = <span class="hljs-keyword">await</span> cur.fetchone()<br>    <span class="hljs-keyword">return</span> JSONResponse(&#123;<span class="hljs-string">&quot;result&quot;</span>: mysql_result_tuple&#125;)<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">redis_demo</span>(<span class="hljs-params">request: Request</span>) -&gt; JSONResponse:</span><br>    <span class="hljs-string">&quot;&quot;&quot;测试Redis调用接口&quot;&quot;&quot;</span><br>    count: <span class="hljs-built_in">int</span> = <span class="hljs-built_in">int</span>(request.query_params.get(<span class="hljs-string">&quot;count&quot;</span>, <span class="hljs-string">&quot;0&quot;</span>))<br>    key: <span class="hljs-built_in">str</span> = request.query_params.get(<span class="hljs-string">&quot;key&quot;</span>)<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> key:<br>        <span class="hljs-keyword">return</span> JSONResponse(<span class="hljs-string">&quot;key is empty&quot;</span>)<br>    result: <span class="hljs-built_in">int</span> = <span class="hljs-keyword">await</span> redis.incrby(key, count)<br>    <span class="hljs-keyword">await</span> redis.expire(key, <span class="hljs-number">60</span>)<br>    <span class="hljs-keyword">return</span> JSONResponse(&#123;<span class="hljs-string">&quot;count&quot;</span>: result&#125;)<br><br><br>app: Starlette = Starlette(<br>    routes=[<br>        Route(<span class="hljs-string">&#x27;/&#x27;</span>, hello_word),<br>        Route(<span class="hljs-string">&#x27;/mysql&#x27;</span>, mysql_demo),<br>        Route(<span class="hljs-string">&#x27;/redis&#x27;</span>, redis_demo)<br>    ],<br>    on_startup=[on_start_up],<br>    on_shutdown=[on_shutdown]<br>)<br></code></pre></td></tr></table></figure>
<p>项目文件创建完毕, 接着再创建一个配套的配置文件<code>.env</code>(<code>starlette</code>的config会自动加载<code>.env</code>的配置):</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 按自己的配置信息更改配置</span><br>MYSQL_DB=<span class="hljs-string">&quot;mysql&quot;</span><br>MYSQL_HOST=<span class="hljs-string">&quot;127.0.0.1&quot;</span><br>MYSQL_PORT=<span class="hljs-string">&quot;3306&quot;</span><br>MYSQL_USER=<span class="hljs-string">&quot;root&quot;</span><br>MYSQL_PW=<span class="hljs-string">&quot;&quot;</span><br><br>REDIS_URL=<span class="hljs-string">&quot;redis://localhost&quot;</span><br>REDIS_POOL_MINSIZE=1<br>REDIS_POOL_MAXSIZE=10<br>REDIS_ENCODING=<span class="hljs-string">&quot;utf-8&quot;</span><br><br></code></pre></td></tr></table></figure>
<p>到现在为止, 目录里只有<code>example.py</code>主文件, <code>.env</code>配置文件以及<code>requirements.txt</code>的依赖文件, 现在开始启动应用查看应用是否能正常启动(注意修改mysql和redis的配置文件, 目前假设已经在本地安装好mysql和redis):</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 使用python -m uvicorn可以防止调用到外部的uvicorn</span><br>python -m uvicorn example:app<br><span class="hljs-comment"># 以下为终端输出</span><br>INFO:     Started server process [4616]<br>INFO:     Waiting <span class="hljs-keyword">for</span> application startup.<br>INFO:     Application startup complete.<br>INFO:     Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)<br></code></pre></td></tr></table></figure>
<p>通过终端的输出可以看到我们的服务已经启动并监听本机的8000端口,接下来测试接口可否正常使用:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">➜  curl http://127.0.0.1:8000<br>Hello Word!<br>➜  curl http://127.0.0.1:8000/mysql<br>&#123;<span class="hljs-string">&quot;result&quot;</span>:[0]&#125;<br>➜  curl http://127.0.0.1:8000/mysql\?count\=10<br>&#123;<span class="hljs-string">&quot;result&quot;</span>:[10]&#125;<br>➜  curl http://127.0.0.1:8000/mysql\?count\=50<br>&#123;<span class="hljs-string">&quot;result&quot;</span>:[50]&#125;<br>➜  curl http://127.0.0.1:8000/redis\?key\=<span class="hljs-built_in">test</span><br>&#123;<span class="hljs-string">&quot;count&quot;</span>:0&#125;<br>➜  curl http://127.0.0.1:8000/redis\?key\=<span class="hljs-built_in">test</span>\&amp;count\=2<br>&#123;<span class="hljs-string">&quot;count&quot;</span>:2&#125;<br>➜  curl http://127.0.0.1:8000/redis\?key\=<span class="hljs-built_in">test</span>\&amp;count\=2<br>&#123;<span class="hljs-string">&quot;count&quot;</span>:4&#125;<br>➜  curl http://127.0.0.1:8000/redis\?key\=<span class="hljs-built_in">test</span>\&amp;count\=2<br>&#123;<span class="hljs-string">&quot;count&quot;</span>:6&#125;<br>➜  curl http://127.0.0.1:8000/redis\?key\=<span class="hljs-built_in">test</span>\&amp;count\=2<br>&#123;<span class="hljs-string">&quot;count&quot;</span>:8&#125;    <br></code></pre></td></tr></table></figure>
<p>通过输出可以发现, 我们的测试结果正常, 接口可以正常使用,前菜到此结束, 接下来是开始利用<code>Docker</code>部署Python Web应用之旅.</p>
<h2 id="2-为项目创建镜像并运行"><a href="#2-为项目创建镜像并运行" class="headerlink" title="2.为项目创建镜像并运行"></a>2.为项目创建镜像并运行</h2><p>目前我们还没碰过<code>Docker</code>, 从这里开始, 就开始使用<code>Docker</code>了, 但在使用之前要确保自己安装了<code>Docker</code>, 每个平台都有不同的安装方法且资料很多， 官方资料也很详细, 这里就不多做描述了。</p>
<p>在<code>Docker</code>中创建镜像很简单， 只需要通过一个<code>Dockerfile</code>文件来告诉<code>Docker</code>如何制作镜像即可, <code>Dockerfile</code>主要包括两个用途, 一个是对当前镜像的描述； 一个是指导<code>Docker</code>完成应用的容器化（创建一个包含当前应用的镜像),<code>Dockerfile</code>能实现开发和部署两个过程的无缝切换, 同时<code>Dockerfile</code>还能帮助新手快速熟悉这个项目(<code>Dockerfile</code>对当前的应用及其依赖有一个清晰准确的描述，并且非常容易阅读和理解，因此，要像重视你的代码一样重视这个文件，并且将它纳入到源控制系统当中.</p>
<p>简单的了解后开始编写对应的<code>Dockerfile</code>文件， 文件如下(<a href="https://github.com/so1n/example/blob/master/example_python/example_python/python_on_docker/version_1/Dockerfile">源码</a>):</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><code class="hljs Dockerfile"><span class="hljs-comment"># 拉取python的基础镜像, 具体使用python -V查看刚才自己是哪个版本的</span><br><span class="hljs-keyword">FROM</span> python:<span class="hljs-number">3.7</span>.<span class="hljs-number">4</span>-alpine<br><span class="hljs-comment"># 设置当前镜像的维护者</span><br><span class="hljs-keyword">LABEL</span><span class="bash"> maintainer=<span class="hljs-string">&quot;so1nxxxx@gmail.com&quot;</span></span><br><span class="hljs-comment"># 设置工作目录</span><br><span class="hljs-keyword">WORKDIR</span><span class="bash"> /data/app</span><br><span class="hljs-comment"># 复制本地依赖, 每个COPY会新建一个镜像层</span><br><span class="hljs-keyword">COPY</span><span class="bash"> . .</span><br><br><span class="hljs-comment"># 设置环境变量</span><br><span class="hljs-comment"># 不要生成pyc文件</span><br><span class="hljs-keyword">ENV</span> PYTHONDONTWRITEBYTECODE <span class="hljs-number">1</span><br><span class="hljs-keyword">ENV</span> PYTHONUNBUFFERED <span class="hljs-number">1</span><br><br><span class="hljs-comment"># 安装依赖, 由于aioredis依赖的hiredis以及cryptography需要编译, 所以这里需要add这些包, 这样依赖，容器就会变得很大...</span><br><span class="hljs-keyword">RUN</span><span class="bash"> apk add --update gcc musl-dev python3-dev libffi-dev openssl-dev build-base &amp;&amp; pip install --upgrade pip &amp;&amp; pip install -r requirements.txt</span><br><br><span class="hljs-comment"># 指明监听的端口</span><br><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">8080</span><br><br><span class="hljs-comment"># 运行的命令</span><br><span class="hljs-keyword">CMD</span><span class="bash"> [<span class="hljs-string">&quot;uvicorn&quot;</span>, <span class="hljs-string">&quot;--host&quot;</span>, <span class="hljs-string">&quot;0.0.0.0&quot;</span>, <span class="hljs-string">&quot;example:app&quot;</span>]</span><br></code></pre></td></tr></table></figure>
<p><code>Dockerfile</code>文件中的命令虽然有点多, 但是不复杂, 理解后就会发现这些命令可读性很高, 以下是各个命令的解读:</p>
<ul>
<li><p>FROM: 每个<code>Dockerfile</code>文件第一行都是FROM指令, FROM指令指定的镜像，都会作为当前镜像的一个基础镜像层，后续命令产生的镜像都会作为新增镜像层添加到基础镜像层之上。这里我们使用<code>python:xxx-alpine</code>的镜像都是官方的镜像, 这个镜像的Python是建立在一个alpine Linux的镜像上面, alpine Linux体积非常小, 不过麻雀虽小, 但五脏俱全。 使用FROM指令引用官方基础镜像是一个很好的习惯，这是因为官方的镜像通常会遵循一些最佳实践，并且能帮助使用者规避一些已知的问题。除此之外，使用FROM的时候选择一个相对较小的镜像文件通常也能避免一些潜在的问题.</p>
</li>
<li><p>LABEL: <code>Dockerfile</code>中通过标签（LABLE）方式指定了当前镜像的维护者。每个标签其实是一个键值对（Key-Value），在一个镜像当中可以通过增加标签的方式来为镜像添加自定义元数据.</p>
</li>
<li><p>WORKDIR: 指明在镜像中的工作目录</p>
</li>
<li><p>COPY: 复制本地目录, 将应用相关文件从构建上下文复制到了当前镜像中，并且新建一个镜像层来存储.</p>
</li>
<li><p>ENV: 设置该镜像运行时的环境变量</p>
</li>
<li><p>RUN: 执行命令, RUN指令会在FROM指定的alpine基础镜像之上，新建一个镜像层来存储这些安装内容.</p>
</li>
<li><p>EXPOSE: 指明监听的端口, 实际上并没有任何作用</p>
</li>
<li><p>CMD: 启动时运行的命令</p>
<p>这些命令都很简单, 不过我在<code>COPY</code>和<code>RUN</code>命令注释中, 都说到了新建了一个镜像层, 在<code>Docker</code>镜像中， 每多一个镜像层就意味这这个镜像会占用更多存储空间, 同时也会更难用, 更慢。 所以大家一般都会追求构建的镜像都尽量的小， 不喜欢因为几个命令导致镜像占用过多的空间。 那我们该怎么区分命令， 判断哪些命令会新增一个镜像层呢?</p>
</li>
</ul>
<p>关于如何区分命令是否会新建镜像层的一个基本原则是，如果指令的作用是向镜像中增添新的文件或者程序，那么这条指令就会新建镜像层， 如果只是告诉<code>Docker</code>如何完成构建或者如何运行应用程序，那么就只会增加镜像的元数据。</p>
<p>此外， 不同的<code>Dockerfile</code>写法都会导致镜像层数量的不同, 比如在<code>Dockerfile</code>中每一个<code>RUN</code>指令基本都会新增一个镜像层, 我们可以通过使用&amp;&amp;连接多个命令或者使用反斜杠（\）换行的方法，将多个命令包含在一个RUN指令中, 这样就可以减少镜像层的产生。 </p>
<p>不过有些时候要把<code>RUN</code>拆分的, 因为<code>Docker</code>自带了一个缓存机制, 如果这个<code>RUN</code>执行时构建的镜像层在缓存中时, <code>Docker</code>会直接引用， 这样构建速度就会比较快, 而在把所有<code>RUN</code>合并到同一条时, 基本上就很难命中缓存了(需要注意的是, docker在执行到第一句不命中缓存的命令后, 后面的所有命令是都不会通过缓存构建的)。</p>
<p>现在<code>Dockerfile</code>编写完了， 在构建镜像之前, 我们先检查我们的目录:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">(venv) ➜  python_on_docker git:(master) ls -a<br>Dockerfile  example.py  requirements.txt __pycache__  venv .env<br></code></pre></td></tr></table></figure>
<p>发现目录下面有<code>__pycache__</code>和<code>venv</code>文件, 这两个文件我是不想编进镜像里的， 但是开发的时候需要用到, 这时就可以使用<code>Docker</code>中一个类似于<code>gitignore</code>的机制, 我们通过<code>.dockerignore</code>文件编写我们要忽略的文件即可让<code>Docker</code>在构建镜像时忽略这些文件:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs .dockerignore">__pycache__&#x2F;<br>.venv<br></code></pre></td></tr></table></figure>
<p>现在，<code>Dockerfile</code>和<code>.dockerignore</code>文件创建完了, 可以通过以下的命令开始构建自己的镜像了:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># -t后面是标签, 可以自己填写, .代表当前目录</span><br>➜  docker image build -t app:latest .<br></code></pre></td></tr></table></figure>
<p>构建完镜像后就可以查看当前镜像了</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看当前的镜像</span><br>➜  version_1 git:(master) docker image ls<br>REPOSITORY          TAG                 IMAGE ID            CREATED              SIZE<br>app                 latest              3351ee7a79ac        About a minute ago   435MB<br></code></pre></td></tr></table></figure>
<p>可以看到我们的镜像已经创建成功了， 不过显示这个简单的镜像占用了435MB的空间， 这是不合理的， 我们可以通过<code>docker image inspect xxx</code>查看镜像有多少层, 有哪些卷和配置信息, 进一步解决镜像过大的问题(由于返回的数据会比较多, 这里就不展示了)。此外， 我们还可以通过<code>history</code>命令查看我们的镜像构建情况, 了解是哪一个步骤导致镜像变大的:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">➜  version_1 git:(master) docker <span class="hljs-built_in">history</span> app<br>IMAGE               CREATED              CREATED BY                                      SIZE                COMMENT<br>3351ee7a79ac        About a minute ago   /bin/sh -c <span class="hljs-comment">#(nop)  CMD [&quot;uvicorn&quot; &quot;--host&quot; &quot;…   0B                  </span><br>f7fedcb216b0        About a minute ago   /bin/sh -c <span class="hljs-comment">#(nop)  EXPOSE 8080                  0B                  </span><br>190fd056b947        About a minute ago   /bin/sh -c apk add --update gcc musl-dev pyt…   313MB               <br>66901ff8b9d4        5 minutes ago        /bin/sh -c <span class="hljs-comment">#(nop)  ENV PYTHONUNBUFFERED=1       0B                  </span><br>7e85b2fa504e        5 minutes ago        /bin/sh -c <span class="hljs-comment">#(nop)  ENV PYTHONDONTWRITEBYTECO…   0B                  </span><br>a2714bff8c12        5 minutes ago        /bin/sh -c <span class="hljs-comment">#(nop) COPY dir:26dace857b0be9773…   23.7MB              </span><br>dc4d69bd98e5        5 minutes ago        /bin/sh -c <span class="hljs-comment">#(nop) WORKDIR /data/app             0B                  </span><br>db1533598434        5 minutes ago        /bin/sh -c <span class="hljs-comment">#(nop)  LABEL maintainer=so1nxxxx…   0B                  </span><br>f309434dea3a        16 months ago        /bin/sh -c <span class="hljs-comment">#(nop)  CMD [&quot;python3&quot;]              0B                  </span><br>&lt;missing&gt;           16 months ago        /bin/sh -c <span class="hljs-built_in">set</span> -ex;   wget -O get-pip.py <span class="hljs-string">&quot;<span class="hljs-variable">$P</span>…   6.24MB              </span><br><span class="hljs-string">&lt;missing&gt;           16 months ago        /bin/sh -c #(nop)  ENV PYTHON_GET_PIP_SHA256…   0B                  </span><br><span class="hljs-string">&lt;missing&gt;           16 months ago        /bin/sh -c #(nop)  ENV PYTHON_GET_PIP_URL=ht…   0B                  </span><br><span class="hljs-string">&lt;missing&gt;           16 months ago        /bin/sh -c #(nop)  ENV PYTHON_PIP_VERSION=19…   0B                  </span><br><span class="hljs-string">&lt;missing&gt;           17 months ago        /bin/sh -c cd /usr/local/bin  &amp;&amp; ln -s idle3…   32B                 </span><br><span class="hljs-string">&lt;missing&gt;           17 months ago        /bin/sh -c set -ex  &amp;&amp; apk add --no-cache --…   86.4MB              </span><br><span class="hljs-string">&lt;missing&gt;           17 months ago        /bin/sh -c #(nop)  ENV PYTHON_VERSION=3.7.4     0B                  </span><br><span class="hljs-string">&lt;missing&gt;           17 months ago        /bin/sh -c #(nop)  ENV GPG_KEY=0D96DF4D4110E…   0B                  </span><br><span class="hljs-string">&lt;missing&gt;           17 months ago        /bin/sh -c apk add --no-cache ca-certificates   551kB               </span><br><span class="hljs-string">&lt;missing&gt;           17 months ago        /bin/sh -c #(nop)  ENV LANG=C.UTF-8             0B                  </span><br><span class="hljs-string">&lt;missing&gt;           17 months ago        /bin/sh -c #(nop)  ENV PATH=/usr/local/bin:/…   0B                  </span><br><span class="hljs-string">&lt;missing&gt;           17 months ago        /bin/sh -c #(nop)  CMD [&quot;</span>/bin/sh<span class="hljs-string">&quot;]              0B                  </span><br><span class="hljs-string">&lt;missing&gt;           17 months ago        /bin/sh -c #(nop) ADD file:fe64057fbb83dccb9…   5.58MB</span><br></code></pre></td></tr></table></figure>
<p>可以看到, 第3条命令的<code>apk ...</code>那里占用的空间最大, 这是因为在<code>RUN</code>的时候需要安装一些编译依赖后才能安装我们的想要的<code>Python</code>库, 但这些依赖都非常大。 幸好<code>Docker</code>针对这种情况提供了多阶段构建的功能(还有建造者模式, 但不如多阶段构建), 多阶段构建方式是一个<code>Dockerfile</code>文件包含了多个FROM指令， 在这个文件中每一个FROM指令都是一个新的构建阶段（Build Stage），并且每个新的构建接单都可以方便地复制之前阶段完成的构件, 也就是可以先通过依赖构建一个比较重的Docker镜像， 然后基于该镜像构建一个用户真正想要的镜像， 最终只保留最后构建的镜像。 </p>
<p>于是我们可以把我们的<code>Dockerfile</code>文件进行改写， 使用第一个构建阶段解决好依赖安装， 然后在第二个构建阶段时基于第一阶段的依赖构建一个新的镜像， 最后输出第二个构建阶段的镜像， 该示例文件如下：(<a href="https://github.com/so1n/example/blob/master/example_python/example_python/python_on_docker/version_2/Dockerfile">源码</a>):</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><code class="hljs Dockerfile"><span class="hljs-comment">#####################</span><br><span class="hljs-comment"># 编译依赖的配置文件#</span><br><span class="hljs-comment">#####################</span><br><br><span class="hljs-comment"># 第一阶段</span><br><span class="hljs-comment"># 设置该阶段的别名为builder</span><br><span class="hljs-keyword">FROM</span> python:<span class="hljs-number">3.7</span>.<span class="hljs-number">4</span>-alpine as builder<br><span class="hljs-comment"># 设置工作目录</span><br><span class="hljs-keyword">WORKDIR</span><span class="bash"> /data/app</span><br><span class="hljs-comment"># 复制本地依赖</span><br><span class="hljs-keyword">COPY</span><span class="bash"> . .</span><br><br><span class="hljs-comment"># 设置环境变量</span><br><span class="hljs-comment"># 不要生成pyc文件</span><br><span class="hljs-keyword">ENV</span> PYTHONDONTWRITEBYTECODE <span class="hljs-number">1</span><br><span class="hljs-keyword">ENV</span> PYTHONUNBUFFERED <span class="hljs-number">1</span><br><br><span class="hljs-comment"># 安装依赖并编译文件到/data/python_wheels</span><br><span class="hljs-keyword">RUN</span><span class="bash"> apk add --update gcc musl-dev python3-dev libffi-dev openssl-dev build-base &amp;&amp; pip install --upgrade pip &amp;&amp; pip wheel --no-cache-dir --no-deps --wheel-dir /data/python_wheels -r requirements.txt</span><br><br><span class="hljs-comment">#####################</span><br><span class="hljs-comment"># 线上使用的配置文件#</span><br><span class="hljs-comment">#####################</span><br><br><span class="hljs-comment"># 第二阶段</span><br><span class="hljs-comment"># 拉取python的基础镜像, 具体使用python -V查看刚才自己是哪个版本的</span><br><span class="hljs-keyword">FROM</span> python:<span class="hljs-number">3.7</span>.<span class="hljs-number">4</span>-alpine<br><span class="hljs-comment"># 设置当前镜像的维护者</span><br><span class="hljs-keyword">LABEL</span><span class="bash"> maintainer=<span class="hljs-string">&quot;so1nxxxx@gmail.com&quot;</span></span><br><span class="hljs-comment"># 设置工作目录</span><br><span class="hljs-keyword">WORKDIR</span><span class="bash"> /data/app</span><br><span class="hljs-comment"># 复制本地依赖</span><br><span class="hljs-keyword">COPY</span><span class="bash"> . .</span><br><br><span class="hljs-comment"># 将第一构建阶段生成的编译文件复制到容器对应的路径下面</span><br><span class="hljs-keyword">COPY</span><span class="bash"> --from=builder /data/python_wheels /data/python_wheels</span><br><span class="hljs-comment"># 通过wheels安装python依赖</span><br><span class="hljs-keyword">RUN</span><span class="bash"> pip install --no-cache /data/python_wheels/*</span><br><br><span class="hljs-comment"># 指明监听的端口</span><br><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">8080</span><br><br><span class="hljs-comment"># 运行的命令</span><br><span class="hljs-keyword">CMD</span><span class="bash"> [<span class="hljs-string">&quot;uvicorn&quot;</span>, <span class="hljs-string">&quot;--host&quot;</span>, <span class="hljs-string">&quot;0.0.0.0&quot;</span>, <span class="hljs-string">&quot;example:app&quot;</span>]</span><br>```  <br>所示的`Dockerfile`文件中有两个`<span class="hljs-keyword">FROM</span>`, 一个`<span class="hljs-keyword">FROM</span>`代表一个单独的构建阶段， 第一个阶段是根据当前的`Python`环境, 安装并编译需要的依赖, 然后根据`requirements`生成`Python`的 wheel文件, 生成的位置是`/data/python_wheels`。第二个`<span class="hljs-keyword">FROM</span>`还是跟刚才的一样, 直到`<span class="hljs-keyword">COPY</span><span class="bash">`语句,这里是一个`COPY --from`指令，它从之前的阶段构建的镜像中仅复制生产环境相关的依赖，而不会复制生产环境不需要的依赖, 这个语句的意思是从builder构建阶段的`/data/python_wheels`复制到当前构建阶段的`/data/python_wheels`。 接下来`RUN`语句也发生改变, 由于在第一阶段已经编译好了依赖, 这里直接使用依赖进行安装即可. 后面的就跟前面一样, 没有什么变化, `Dkckerfile`文件编写好了, 开始构建自己的镜像:</span><br>```bash<br><span class="hljs-comment"># -t后面是标签, 可以自己填写, .代表当前目录</span><br>➜  docker image build -t app_1:latest .<br></code></pre></td></tr></table></figure>
<p>构建完成后查看构建完的镜像:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">➜  version_2 git:(master) docker image ls<br>REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE<br>app_1               latest              a71a4a7db157        7 seconds ago       116MB<br>app                 latest              3351ee7a79ac        9 minutes ago       435MB<br><br>➜  version_2 git:(master) docker <span class="hljs-built_in">history</span> app_1<br>IMAGE               CREATED             CREATED BY                                      SIZE                COMMENT<br>a71a4a7db157        43 seconds ago      /bin/sh -c <span class="hljs-comment">#(nop)  CMD [&quot;uvicorn&quot; &quot;--host&quot; &quot;…   0B                  </span><br>d4d38b71a1ba        43 seconds ago      /bin/sh -c <span class="hljs-comment">#(nop)  EXPOSE 8080                  0B                  </span><br>5fb10c8afea8        43 seconds ago      /bin/sh -c pip install --no-cache /data/pyth…   15.3MB              <br>e454bbe54adb        46 seconds ago      /bin/sh -c <span class="hljs-comment">#(nop) COPY dir:ff6195d46738a79a1…   2.13MB              </span><br>d70a8a552490        46 seconds ago      /bin/sh -c <span class="hljs-comment">#(nop) COPY dir:fbe9ac8ac1636d3d7…   3.63kB              </span><br>dc4d69bd98e5        14 minutes ago      /bin/sh -c <span class="hljs-comment">#(nop) WORKDIR /data/app             0B                  </span><br>db1533598434        14 minutes ago      /bin/sh -c <span class="hljs-comment">#(nop)  LABEL maintainer=so1nxxxx…   0B                  </span><br>f309434dea3a        16 months ago       /bin/sh -c <span class="hljs-comment">#(nop)  CMD [&quot;python3&quot;]              0B                  </span><br>&lt;missing&gt;           16 months ago       /bin/sh -c <span class="hljs-built_in">set</span> -ex;   wget -O get-pip.py <span class="hljs-string">&quot;<span class="hljs-variable">$P</span>…   6.24MB              </span><br><span class="hljs-string">&lt;missing&gt;           16 months ago       /bin/sh -c #(nop)  ENV PYTHON_GET_PIP_SHA256…   0B                  </span><br><span class="hljs-string">&lt;missing&gt;           16 months ago       /bin/sh -c #(nop)  ENV PYTHON_GET_PIP_URL=ht…   0B                  </span><br><span class="hljs-string">&lt;missing&gt;           16 months ago       /bin/sh -c #(nop)  ENV PYTHON_PIP_VERSION=19…   0B                  </span><br><span class="hljs-string">&lt;missing&gt;           17 months ago       /bin/sh -c cd /usr/local/bin  &amp;&amp; ln -s idle3…   32B                 </span><br><span class="hljs-string">&lt;missing&gt;           17 months ago       /bin/sh -c set -ex  &amp;&amp; apk add --no-cache --…   86.4MB              </span><br><span class="hljs-string">&lt;missing&gt;           17 months ago       /bin/sh -c #(nop)  ENV PYTHON_VERSION=3.7.4     0B                  </span><br><span class="hljs-string">&lt;missing&gt;           17 months ago       /bin/sh -c #(nop)  ENV GPG_KEY=0D96DF4D4110E…   0B                  </span><br><span class="hljs-string">&lt;missing&gt;           17 months ago       /bin/sh -c apk add --no-cache ca-certificates   551kB               </span><br><span class="hljs-string">&lt;missing&gt;           17 months ago       /bin/sh -c #(nop)  ENV LANG=C.UTF-8             0B                  </span><br><span class="hljs-string">&lt;missing&gt;           17 months ago       /bin/sh -c #(nop)  ENV PATH=/usr/local/bin:/…   0B                  </span><br><span class="hljs-string">&lt;missing&gt;           17 months ago       /bin/sh -c #(nop)  CMD [&quot;</span>/bin/sh<span class="hljs-string">&quot;]              0B                  </span><br><span class="hljs-string">&lt;missing&gt;           17 months ago       /bin/sh -c #(nop) ADD file:fe64057fbb83dccb9…   5.58MB </span><br></code></pre></td></tr></table></figure>
<p>可以看到现在的镜像大小已经减少很多了, 差不多只剩4分之一，非常完美! 如果还想让镜像更小一点, 那可以在使用<code>bliud</code>命令时, 添加<code>--squash</code>选项, 这样<code>Docker</code>在<code>build</code>的时候就会把所有镜像层合并为一个, 但这也是有缺点的, 因为合并的镜像层无法共享镜像层, 而且镜像在<code>push</code>和<code>pull</code>的时候开销会变得很大。</p>
<p>镜像终于创建完了, 终于可以启动容器查看我们构建的镜像的运行效果了:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 执行容器运行命令, --name参数可以自己定, -p 参数指定容器的端口(第二个)绑定到本机的端口(第一格), 最后一个参数为image id每次生成的镜像都不同</span><br>➜  docker container run -d --name docker_app_1 -p 8000:8000 app_1<br></code></pre></td></tr></table></figure>
<p>调用了启动命令后， 通过<code>ps</code>命令你给查看容器运行情况:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 启动后查看容器启动失败, 很正常, 配置用的是`127.0.0.1`而容器没有安装mysql和redis,肯定是连不上的 </span><br><span class="hljs-comment"># 查看容器状态</span><br>➜  version_2 git:(master) docker ps -a<br>CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                     PORTS               NAMES<br>3070cf77c951        app_1               <span class="hljs-string">&quot;uvicorn --host 0.0.…&quot;</span>   7 seconds ago       Exited (0) 6 seconds ago                       docker_app_1<br></code></pre></td></tr></table></figure>
<p>通过输出可以发现镜像运行失败, 但是不知道为啥失败, 只能通过运行日志查看为什么失败:</p>
<figure class="highlight subunit"><table><tr><td class="code"><pre><code class="hljs subunit"># 查看运行日志<br>➜  version_2 git:(master) docker logs -f -t --tail 10 docker_app_1 <br>2021<span class="hljs-string">-02</span><span class="hljs-string">-07</span>T09:01:16.062239955Z     await pool._fill_free_pool(False)<br>2021<span class="hljs-string">-02</span><span class="hljs-string">-07</span>T09:01:16.062241993Z   File &quot;/usr/local/lib/python3.7/site-packages/aiomysql/pool.py&quot;, line 168, in _fill_free_pool<br>2021<span class="hljs-string">-02</span><span class="hljs-string">-07</span>T09:01:16.062250734Z     **self._conn_kwargs)<br>2021<span class="hljs-string">-02</span><span class="hljs-string">-07</span>T09:01:16.062253106Z   File &quot;/usr/local/lib/python3.7/site-packages/aiomysql/connection.py&quot;, line 75, in _connect<br>2021<span class="hljs-string">-02</span><span class="hljs-string">-07</span>T09:01:16.062255305Z     await conn._connect()<br>2021<span class="hljs-string">-02</span><span class="hljs-string">-07</span>T09:01:16.062257318Z   File &quot;/usr/local/lib/python3.7/site-packages/aiomysql/connection.py&quot;, line 523, in _connect<br>2021<span class="hljs-string">-02</span><span class="hljs-string">-07</span>T09:01:16.062259455Z     self._host) from e<br>2021<span class="hljs-string">-02</span><span class="hljs-string">-07</span>T09:01:16.062275244Z pymysql.err.OperationalError: (2003, &quot;Can&#x27;t connect to MySQL server on &#x27;127.0.0.1&#x27;&quot;)<br>2021<span class="hljs-string">-02</span><span class="hljs-string">-07</span>T09:01:16.062277250Z <br>2021<span class="hljs-string">-02</span><span class="hljs-string">-07</span>T09:01:16.062279127Z ERROR:    Application startup failed. Exiting.<br></code></pre></td></tr></table></figure>
<p>从报错日志可以看到, 镜像启动失败是由于连不上<code>127.0.0.1</code>地址导致报错了, 可是本机上面已经安装了<code>MySQL</code>啊, 为什么还会连不上呢? 这是因为<code>Docker</code>容器运行的时候会选择一个网络模式， 共有<code>host</code>、<code>bridge</code>和<code>none</code>三种网络可供配置：</p>
<ul>
<li><p>bridge  该模式是<code>Docker</code>的默认选项. bridge即桥接网络，以桥接模式连接到宿主机, 这时候容器内的应用访问<code>127.0.0.1</code>是指容器本身的网络(在本机通过<code>ifconfig</code>命令可以看到有个类似于<code>docker0</code>的展示), 该模式下如果要连接到宿主机的网络, 只能把<code>127.0.0.1</code>改为本机的局域网ip；</p>
</li>
<li><p>host  host是宿主网络，即<code>Docker</code>与宿主机共用网络, 在该模式下， <code>Docker</code>容器内的应用使用网络时跟平时一样正常使用即可, 同时该模式的网络性能也是最好的, 如果在使用bridge模式时发现有网络瓶颈, 或者应用对网络延迟和并发有极高的要求时, 记得切为host网络模式。</p>
</li>
<li><p>none则表示无网络，容器内应用将无法联网.</p>
<p>了解了<code>Docker</code>的网络模式后， 我们可以通过把网络模式改为<code>host</code>来解决连不上的问题了， 具体操作是通过去掉<code>-p 8000:8000</code>选项, 增加<code>--net=host</code>选项来启动容器 (如果旧容器存在, 记得删除掉, 不然会占用空间):</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 启动容器</span><br>➜  version_2 git:(master) docker container run -d --name docker_app_1 --net=host app_1  <br>cd1ea057cdb6ec6ee3917d13f9c3c55db2a2949e409716d1dbb86f34bb1356e5<br><br><span class="hljs-comment">#　查看启动日志，　正常！</span><br>➜  version_2 git:(master) docker logs -f -t --tail 10 docker_app_1<br>2021-02-07T09:06:35.403888447Z INFO:     Started server process [1]<br>2021-02-07T09:06:35.403903761Z INFO:     Waiting <span class="hljs-keyword">for</span> application startup.<br>2021-02-07T09:06:35.437776480Z INFO:     Application startup complete.<br>2021-02-07T09:06:35.438466743Z INFO:     Uvicorn running on http://0.0.0.0:8000 (Press CTRL+C to quit)<br><br><span class="hljs-comment"># 调用接口发现启动成功</span><br>➜  curl 127.0.0.1:8000<br>127.0.0.1, Hello Word!<br></code></pre></td></tr></table></figure>
<p>则此, 我们终于把python的web应用构建成镜像, 并正常启动镜像了。 </p>
</li>
</ul>
<h2 id="3-单引擎模式部署和管理多容器应用"><a href="#3-单引擎模式部署和管理多容器应用" class="headerlink" title="3.单引擎模式部署和管理多容器应用"></a>3.单引擎模式部署和管理多容器应用</h2><p>在懂了如何制作容器之后, 就可以开始准备成为Yaml工程师了, 上面我们只构建一个<code>Python</code>应用的镜像, 然后连接了本地的<code>MySQL</code>和<code>Redis</code>服务, 现在我们也可以把<code>MySQL</code>和<code>Redis</code>这两个服务一起容器化, 不过这时候每个服务都通过一个特定<code>Dockerfile</code>来配置并使用的话就太麻烦了。</p>
<p>如果有一个像<code>Dockerfile</code>的文件, 文件里写了如何安装这3个镜像, 然后我们执行一个命令就可以把这三个服务都安装到服务器上, 那就很方便了, 在<code>Docker</code>中是由<code>Docker Compose</code>提供了这个功能。</p>
<blockquote>
<p>如果用过<code>Ansible</code>, 就知道会有一个<code>palybook</code>的yaml配置文件, 只要在控制主机上存放一个<code>palybook</code>文件， 就可以控制其它机器执行任何操作, 比如为其它主机安装应用等到, 而<code>Docker Compose</code>有点类似, 基于该功能可以做到在一台机器上同时管理多个<code>Docker</code>容器。</p>
</blockquote>
<p><code>Docker Compose</code>通过一个声明式的配置文件描述整个应用，从而使用一条命令完成部署。应用部署成功后，还可以通过一系列简单的命令实现对其完整生命周期的管理。此外，配置文件还可以置于版本控制系统中进行存储和管理, 这个工具会跟<code>docker</code>一起安装。</p>
<p>接下来就是实战了， 本次实例相比于之前的服务多了个<code>Nginx</code>服务， 而且<code>Nginx</code>是需要一个配置文件都，所以需要先为<code>Nginx</code>单独配置一个<code>Dockerfile</code>文件。</p>
<p>首先, 在目录创建一个<code>nginx</code>文件夹, 然后在文件夹里面编写配置文件<code>nginx.conf</code>(<a href="https://github.com/so1n/example/blob/master/example_python/example_python/python_on_docker/version_3/nginx/nginx.conf">源码</a>):</p>
<figure class="highlight nginx"><figcaption><span>Conf</span></figcaption><table><tr><td class="code"><pre><code class="hljs Nginx"><span class="hljs-attribute">upstream</span> app_server &#123;<br>    <span class="hljs-attribute">server</span> app:<span class="hljs-number">8000</span>;<br>&#125;<br><br><span class="hljs-section">server</span> &#123;<br><br>    <span class="hljs-attribute">listen</span> <span class="hljs-number">80</span>;<br><br>    <span class="hljs-attribute">location</span> / &#123;<br>        <span class="hljs-attribute">proxy_pass</span> http://app_server;<br>        <span class="hljs-attribute">proxy_set_header</span> X-Forwarded-For $proxy_add_x_forwarded_for;<br>        <span class="hljs-attribute">proxy_set_header</span> Host $host;<br>        <span class="hljs-attribute">proxy_redirect</span> <span class="hljs-literal">off</span>;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>
<p>这时可能发现配置文件里的<code>upstream</code>里面有个奇怪的配置<code>app:8000</code>,我们先不管, 继续创建<code>Nginx</code>的<code>Dockerfile</code>(<a href="https://github.com/so1n/example/blob/master/example_python/example_python/python_on_docker/version_3/nginx/Dockerfile">源码</a>)文件:</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><code class="hljs Dockerfile"><span class="hljs-keyword">FROM</span> nginx:<span class="hljs-number">1.19</span>.<span class="hljs-number">0</span>-alpine<br><br><span class="hljs-comment"># 移除Nginx的默认配置文件</span><br><span class="hljs-keyword">RUN</span><span class="bash"> rm /etc/nginx/conf.d/default.conf</span><br><span class="hljs-comment"># 使用我们编写的配置文件</span><br><span class="hljs-keyword">COPY</span><span class="bash"> nginx.conf /etc/nginx/conf.d</span><br></code></pre></td></tr></table></figure>
<p>现在， <code>Nginx</code>的容器文件已经准备完毕， 开始编写我们的<code>docker-compose.yml</code>文件, 假设我们现在的单服务器需要有<code>Python</code>的Web服务, <code>Nginx</code>, <code>Redis</code>和<code>MySQL</code>服务(<a href="https://github.com/so1n/example/blob/master/example_python/example_python/python_on_docker/version_3/docker-compose.yml">源码</a>):</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><code class="hljs yml"><span class="hljs-comment"># version是必须指定的，而且总是位于文件的第一行。它定义了Compose文件格式（主要是API）的版本。建议使用最新版本。</span><br><span class="hljs-attr">version:</span> <span class="hljs-string">&quot;3.5&quot;</span><br><span class="hljs-comment"># 用于定义不同的应用服务</span><br><span class="hljs-attr">services:</span><br>    <span class="hljs-attr">redis:</span><br>        <span class="hljs-comment"># 基于redis:alpine镜像启动一个独立的名为redis的容器。</span><br>        <span class="hljs-attr">image:</span> <span class="hljs-string">&quot;redis:alpine&quot;</span><br>        <span class="hljs-comment"># 使得Docker可以将服务连接到指定的网络上。这个网络应该是已经存在的，或者是在networks一级key中定义的网络。</span><br>        <span class="hljs-attr">networks:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">local-net</span><br>        <span class="hljs-comment"># 指定Docker将容器内（-target）的6379端口映射到主机（published）的63790端口。</span><br>        <span class="hljs-attr">ports:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-attr">target:</span> <span class="hljs-number">6379</span><br>              <span class="hljs-attr">published:</span> <span class="hljs-number">63790</span><br>    <span class="hljs-attr">mysql:</span><br>        <span class="hljs-attr">image:</span> <span class="hljs-string">mysql</span><br>        <span class="hljs-attr">command:</span> <span class="hljs-string">mysqld</span> <span class="hljs-string">--character-set-server=utf8mb4</span> <span class="hljs-string">--collation-server=utf8mb4_unicode_ci</span> <span class="hljs-comment">#设置utf8字符集</span><br>        <span class="hljs-attr">restart:</span> <span class="hljs-string">always</span><br>        <span class="hljs-attr">networks:</span><br>            <span class="hljs-attr">local-net:</span><br>        <span class="hljs-attr">environment:</span><br>            <span class="hljs-comment"># 通过环境变量设置　mysql需要的用户名和密码等</span><br>            <span class="hljs-attr">MYSQL_DATABASE:</span> <span class="hljs-string">&#x27;test&#x27;</span><br>            <span class="hljs-attr">MYSQL_USER:</span> <span class="hljs-string">&#x27;root&#x27;</span><br>            <span class="hljs-attr">MYSQL_PASSWORD:</span> <span class="hljs-string">&#x27;&#x27;</span><br>            <span class="hljs-attr">MYSQL_ROOT_PASSWORD:</span> <span class="hljs-string">&#x27;&#x27;</span><br>            <span class="hljs-attr">MYSQL_ALLOW_EMPTY_PASSWORD:</span> <span class="hljs-string">&#x27;true&#x27;</span><br><br>        <span class="hljs-comment"># 指定Docker将容器内（-target）的3306端口映射到主机（published）的33060端口。</span><br>        <span class="hljs-attr">ports:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-attr">target:</span> <span class="hljs-number">3306</span><br>              <span class="hljs-attr">published:</span> <span class="hljs-number">33060</span><br>        <span class="hljs-comment"># 设置MySQL容易存储内容在哪个目录</span><br>        <span class="hljs-attr">volumes:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-attr">type:</span> <span class="hljs-string">volume</span><br>              <span class="hljs-attr">source:</span> <span class="hljs-string">local-vol</span><br>              <span class="hljs-attr">target:</span> <span class="hljs-string">/example_volumes</span><br>    <span class="hljs-attr">app:</span><br>        <span class="hljs-comment"># 指定Docker基于当前目录（.）下Dockerfile中定义的指令来构建一个新镜像。该镜像会被用于启动该服务的容器。</span><br>        <span class="hljs-attr">build:</span> <span class="hljs-string">.</span><br>        <span class="hljs-comment"># 指定Docker在容器中执行的命令, 由于我们的Dockerfile中已经有了， 这里就注释掉</span><br>        <span class="hljs-comment"># command:</span><br>        <span class="hljs-comment"># 指定Docker将容器内（-target）的8000端口映射到主机（published）的8000端口。</span><br>        <span class="hljs-attr">ports:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-attr">target:</span> <span class="hljs-number">8000</span><br>              <span class="hljs-attr">published:</span> <span class="hljs-number">8000</span><br>        <span class="hljs-attr">networks:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">local-net</span><br>        <span class="hljs-comment"># 挂载到本地的卷</span><br>        <span class="hljs-attr">volumes:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-attr">type:</span> <span class="hljs-string">volume</span><br>              <span class="hljs-attr">source:</span> <span class="hljs-string">local-vol</span><br>              <span class="hljs-attr">target:</span> <span class="hljs-string">/example_volumes</span><br>        <span class="hljs-comment"># 声明需要依赖上面的服务, 只有上面的服务起来， 这个才能起</span><br>        <span class="hljs-attr">depends_on:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">mysql</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">redis</span><br>    <span class="hljs-attr">nginx:</span><br>        <span class="hljs-attr">build:</span> <span class="hljs-string">./nginx</span><br><br>        <span class="hljs-comment"># 指定Docker将容器内（-target）的80端口映射到主机（published）的8001端口。</span><br>        <span class="hljs-attr">networks:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">local-net</span><br>        <span class="hljs-attr">ports:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-attr">target:</span> <span class="hljs-number">80</span><br>              <span class="hljs-attr">published:</span> <span class="hljs-number">8001</span><br>        <span class="hljs-attr">depends_on:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">app</span><br><br><span class="hljs-comment"># networks用于指引Docker创建新的网络。默认情况下，Docker Compose会创建bridge网络。这是一种单主机网络，只能够实现同一主机上容器的连接。当然，也可以使用driver属性来指定不同的网络类型。</span><br><span class="hljs-attr">networks:</span><br>    <span class="hljs-attr">local-net:</span><br>        <span class="hljs-attr">driver:</span> <span class="hljs-string">bridge</span><br><br><span class="hljs-attr">volumes:</span><br>    <span class="hljs-attr">local-vol:</span><br></code></pre></td></tr></table></figure>

<p>文件创建完了, 如果直接启动， 会发现虽然容器都会将端口映射到主机上面, 但是由于全部服务都配置了一个<code>local-net</code>网络, 它是<code>bridge</code>模式的网络, 所以容器里面访问<code>127.0.0.1</code>是访问不到其他容器了, 不过这几个容器应用都可以通过<code>local-net</code>网络建立连接, 只要通过访问容器服务名就可以直接访问到对应的容器(国内的教程很多都没说, 巨坑), 所以上面的<code>nginx.conf</code>配置才有<code>app:8000</code>这个选项, 指的是让<code>Nginx</code>与我们的Python应用(服务名为app)的8000端口连接。除此之外, 我们还需要改下我们的.env配置文件, 把他们的host进行修改:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># MySQL访问的是mysql， 相当于访问自己的网络, 与127.0.0.1是类似的</span><br>MYSQL_DB=<span class="hljs-string">&quot;mysql&quot;</span><br>MYSQL_HOST=<span class="hljs-string">&quot;mysql&quot;</span><br>MYSQL_PORT=<span class="hljs-string">&quot;3306&quot;</span><br>MYSQL_USER=<span class="hljs-string">&quot;root&quot;</span><br>MYSQL_PW=<span class="hljs-string">&quot;&quot;</span><br><br>REDIS_URL=<span class="hljs-string">&quot;redis://redis&quot;</span><br>REDIS_POOL_MINSIZE=1<br>REDIS_POOL_MAXSIZE=10<br>REDIS_ENCODING=<span class="hljs-string">&quot;utf-8&quot;</span><br></code></pre></td></tr></table></figure>
<p>然后还需要改下app的<code>Dockerfile</code>启动命令, 让他5秒后启动, 防止有些服务还没起来自己就先运行了:</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><code class="hljs Dockerfile"><span class="hljs-keyword">CMD</span><span class="bash"> CMD sh -c <span class="hljs-string">&#x27;sleep 5 &amp;&amp; uvicorn --host 0.0.0.0 example:app&#x27;</span></span><br></code></pre></td></tr></table></figure>

<p>万事俱备, 终于可以通过执行<code>docker-compose up -d</code>命令来启动我们的容器群了, 在这个命令中d是后台运行的意思, 然后自通过几个命令查看运行情况:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 使用docker-compose up命令来查看应用的状态。输出中会显示容器名称、其中运行的Command、当前状态以及其监听的网络端口。</span><br>➜  version_3 git:(master) docker-compose ps           <br>      Name                     Command               State                 Ports               <br>-----------------------------------------------------------------------------------------------<br>version_3_app_1     uvicorn --host 0.0.0.0 exa ...   Up      0.0.0.0:8000-&gt;8000/tcp, 8080/tcp  <br>version_3_mysql_1   docker-entrypoint.sh mysql ...   Up      0.0.0.0:33060-&gt;3306/tcp, 33060/tcp<br>version_3_nginx_1   /docker-entrypoint.sh ngin ...   Up      0.0.0.0:8001-&gt;80/tcp              <br>version_3_redis_1   docker-entrypoint.sh redis ...   Up      0.0.0.0:63790-&gt;6379/tcp <br><br><br><span class="hljs-comment"># 使用docker-compose top命令列出各个服务（容器）内运行的进程。</span><br><span class="hljs-comment"># 其中PID编号是在Docker主机上（而不是容器内）的进程ID。</span><br>➜  version_3 git:(master) docker-compose top<br>version_3_app_1<br>UID    PID    PPID   C   STIME   TTY     TIME                                       CMD                                  <br>-------------------------------------------------------------------------------------------------------------------------<br>root   1802   1786   0   16:05   ?     00:00:00   /usr/<span class="hljs-built_in">local</span>/bin/python /usr/<span class="hljs-built_in">local</span>/bin/uvicorn --host 0.0.0.0 example:app<br><br>version_3_mysql_1<br>  UID      PID    PPID   C   STIME   TTY     TIME                                         CMD                                    <br>---------------------------------------------------------------------------------------------------------------------------------<br>deepin-+   1047   1018   0   16:05   ?     00:00:00   mysqld --character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_ci<br><br>version_3_nginx_1<br>  UID      PID    PPID   C   STIME   TTY     TIME                        CMD                    <br>------------------------------------------------------------------------------------------------<br>root       1355   1339   0   16:05   ?     00:00:00   nginx: master process nginx -g daemon off;<br>systemd+   1467   1355   0   16:05   ?     00:00:00   nginx: worker process                     <br>systemd+   1468   1355   0   16:05   ?     00:00:00   nginx: worker process                     <br>systemd+   1469   1355   0   16:05   ?     00:00:00   nginx: worker process                     <br>systemd+   1470   1355   0   16:05   ?     00:00:00   nginx: worker process                     <br>systemd+   1471   1355   0   16:05   ?     00:00:00   nginx: worker process                     <br>systemd+   1472   1355   0   16:05   ?     00:00:00   nginx: worker process                     <br>systemd+   1473   1355   0   16:05   ?     00:00:00   nginx: worker process                     <br>systemd+   1474   1355   0   16:05   ?     00:00:00   nginx: worker process                     <br>systemd+   1475   1355   0   16:05   ?     00:00:00   nginx: worker process                     <br>systemd+   1476   1355   0   16:05   ?     00:00:00   nginx: worker process                     <br>systemd+   1477   1355   0   16:05   ?     00:00:00   nginx: worker process                     <br>systemd+   1478   1355   0   16:05   ?     00:00:00   nginx: worker process                     <br><br>version_3_redis_1<br>  UID      PID    PPID   C   STIME   TTY     TIME         CMD     <br>------------------------------------------------------------------<br>deepin-+   1048   1014   0   16:05   ?     00:00:00   redis-server<br><br><span class="hljs-comment"># 查看目前的网络</span><br><span class="hljs-comment"># 查看network的详细信息 docker network inspect version_3_local-net  </span><br>➜  version_3 git:(master) docker network ls<br>NETWORK ID          NAME                  DRIVER              SCOPE<br>b39273f15fb3        bridge                bridge              <span class="hljs-built_in">local</span><br>23ef7eb0fba0        host                  host                <span class="hljs-built_in">local</span><br>ab8439cd985c        none                  null                <span class="hljs-built_in">local</span><br>5bcd17ecd747        version_3_local-net   bridge              <span class="hljs-built_in">local</span><br><br><span class="hljs-comment"># 查看卷</span><br><span class="hljs-comment"># 查看详情 docker volume inspect version_3_local-vol </span><br>➜  version_3 git:(master) docker volume ls<br>DRIVER              VOLUME NAME<br><span class="hljs-built_in">local</span>               version_3_local-vol<br></code></pre></td></tr></table></figure>
<p>通过上述的几个命令可以发现服务是正常运行的， 如果这时候要停止, 可以使用<code>docker-compose stop</code>命令, 它会停止应用，但并不会删除资源, 不过对于已停止的应用，可以使用<code>docker-compose rm</code>命令来进行删除, 这会删除应用相关的容器和网络，但是不会删除卷和镜像。 而直接使用<code>docker-compose down</code>这一个命令就可以停止和关闭应用, 然后应用被删除，仅留下了镜像、卷和源码。</p>
<h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h2><p>至此， Python应用的容器化就已经介绍完毕， 但是这只是一个简单的开始， 后面需要慢慢的了解多机的容器应用的怎么控制和执行的。</p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>如何使用contextvars模块和源码分析</title>
    <url>/2019/06/13/contextvars%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<h2 id="前记"><a href="#前记" class="headerlink" title="前记"></a>前记</h2><p>在Python3.7后官方库出现了<code>contextvars</code>模块, 它的主要功能就是可以为多线程以及asyncio生态添加上下文功能,即使程序在多个协程并发运行的情况下,也能调用到程序的上下文变量, 从而使我们的逻辑解耦.</p>
<p>上下文,可以理解为我们说话的语境, 在聊天的过程中, 有些话脱离了特定的语境,他的意思就变了,程序的运行也是如此.在线程中也是有他的上下文,只不过称为堆栈,如在python中就是保存在thread.local变量中,而协程也有他自己的上下文,但是没有暴露出来,不过有了<code>contextvars</code>模块后我们可以通过<code>contextvars</code>模块去保存与读取.</p>
<p>使用<code>contextvars</code>的好处不仅可以防止’一个变量传遍天’的事情发生外,还能很好的结合TypeHint,可以让自己的代码可以被mypy以及IDE检查,让自己的代码更加适应工程化.<br>不过用了<code>contextvars</code>后会多了一些隐性的调用, 需要解决好这些隐性的成本. </p>
<span id="more"></span>
<h2 id="更新说明"><a href="#更新说明" class="headerlink" title="更新说明"></a>更新说明</h2><ul>
<li>切换web框架<code>sanic</code>为<code>starlette</code></li>
<li>增加一个自己编写且可用于<code>starlette</code>,<code>fastapi</code>的context说明</li>
<li>更新fast_tools.context的最新示例以及简单的修改行文。</li>
</ul>
<hr>
<h2 id="1-有无上下文传变量的区别"><a href="#1-有无上下文传变量的区别" class="headerlink" title="1.有无上下文传变量的区别"></a>1.有无上下文传变量的区别</h2><p>如果有用过<code>Flask</code>框架, 就知道了<code>Flask</code>拥有自己的上下文功能, 而contextvars跟它很像, 而且还增加了对asyncio的上下文提供支持。<br><code>Flask</code>的上下文是基于<code>threading.local</code>实现的, <code>threading.local</code>的隔离效果很好，但是他是只针对线程的，只隔离线程之间的数据状态, 而<code>werkzeug</code>为了支持在<code>gevent</code>中运行,自己实现了一个<code>Local</code>变量, 常用的<code>Flask</code>上下文变量<code>request</code>的例子如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Flask, request<br><br><br>app = Flask(__name__)<br><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/&#x27;</span></span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">root</span>():</span><br>    so1n_name = request.get(<span class="hljs-string">&#x27;so1n_name&#x27;</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">f&#x27;Name is <span class="hljs-subst">&#123;so1n_name&#125;</span>&#x27;</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>拓展阅读：<a href="https://blog.tonyseek.com/post/the-context-mechanism-of-flask/"><code>Flask</code>的上下文是怎么实现</a></p>
</blockquote>
<p>与之相比的是<code>Python</code>的另一个经典Web框架<code>Djano</code>， 它没有上下文的支持, 所以只能显示的传<code>request</code>对象， 例子如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">from</span> django.http <span class="hljs-keyword">import</span> HttpResponse<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">root</span>(<span class="hljs-params">request</span>):</span><br>    so1n_name = request.get(<span class="hljs-string">&#x27;so1n_name&#x27;</span>)<br>    <span class="hljs-keyword">return</span> HttpResponse(<span class="hljs-string">f&#x27;Name is <span class="hljs-subst">&#123;so1n_name&#125;</span>&#x27;</span>)<br></code></pre></td></tr></table></figure>

<p>通过上面两者的对比可以发现， 在<code>Django</code>中,我们需要显示的传一个叫request的变量,而<code>Flask</code>则是import一个叫request的全局变量,并在视图中直接使用,达到解耦的目的.</p>
<p>可能会有人说, 也就是传个变量的区别,为了省传这个变量,而花许多功夫去维护一个上下文变量,有点不值得,那可以看看下面的例子,如果层次多就会出现’一个参数传一天’的情况(不过分层做的好或者需求不坑爹一般不会出现像下面的情况,一个好的程序员能做好代码的分层, 但可能也有出现一堆烂需求的时候)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-comment"># 伪代码,举个例子一个request传了3个函数</span><br><span class="hljs-keyword">from</span> django.http <span class="hljs-keyword">import</span> HttpResponse<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">is_allow</span>(<span class="hljs-params">request, uid</span>):</span><br>    <span class="hljs-keyword">if</span> request.ip == <span class="hljs-string">&#x27;127.0.0.1&#x27;</span> <span class="hljs-keyword">and</span> check_permissions(uid):<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">check_permissions</span>(<span class="hljs-params">request, uid</span>):</span><br>    <span class="hljs-keyword">pass</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">root</span>(<span class="hljs-params">request</span>):</span><br>    user_id = request.GET.get(<span class="hljs-string">&#x27;uid&#x27;</span>)<br>    <span class="hljs-keyword">if</span> is_allow(request, <span class="hljs-built_in">id</span>):<br>    	<span class="hljs-keyword">return</span> HttpResponse(<span class="hljs-string">&#x27;ok&#x27;</span>)<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> HttpResponse(<span class="hljs-string">&#x27;error&#x27;</span>)<br></code></pre></td></tr></table></figure>

<p>此外， 除了防止<code>一个参数传一天</code>这个问题外, 通过上下文, 可以进行一些解耦, 比如有一个最经典的技术业务需求就是在日志打印request_id, 从而方便链路排查, 这时候如果有上下文模块, 就可以把读写request_id给解耦出来, 比如下面这个基于<code>Flask</code>框架读写request_id的例子:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> logging<br><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> Any<br><br><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> g  <span class="hljs-comment"># type: ignore</span><br><span class="hljs-keyword">from</span> flask.logging <span class="hljs-keyword">import</span> default_handler<br><br><br><span class="hljs-comment"># 这是一个Python logging.Filter的对象, 日志在生成之前会经过Filter步骤, 这时候我们可以为他绑定request_id变量</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RequestIDLogFilter</span>(<span class="hljs-params">logging.Filter</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    Log filter to inject the current request id of the request under `log_record.request_id`</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">filter</span>(<span class="hljs-params">self, record: Any</span>) -&gt; Any:</span><br>        record.request_id = g.request_id <span class="hljs-keyword">or</span> <span class="hljs-literal">None</span><br>        <span class="hljs-keyword">return</span> record<br><br><span class="hljs-comment"># 配置日志的format格式, 这里多配了一个request_id变量</span><br>format_string: <span class="hljs-built_in">str</span> = (<br>    <span class="hljs-string">&quot;[%(asctime)s][%(levelname)s][%(filename)s:%(lineno)d:%(funcName)s:%(request_id)s]&quot;</span> <span class="hljs-string">&quot; %(message)s&quot;</span><br>)<br><span class="hljs-comment"># 为flask的默认logger设置format和增加一个logging.Filter对象</span><br>default_handler.setFormatter(logging.Formatter(format_string))<br>default_handler.addFilter(RequestIDLogFilter())<br><br><span class="hljs-comment"># 该方法用于设置request_id</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">set_request_id</span>() -&gt; <span class="hljs-keyword">None</span>:</span><br>    g.request_id = request.headers.get(<span class="hljs-string">&quot;X-Request-Id&quot;</span>, <span class="hljs-built_in">str</span>(uuid4()))<br><br><span class="hljs-comment"># 初始化FLask对象, 并设置before_request</span><br>app: Flask = Flask(<span class="hljs-string">&quot;demo&quot;</span>)<br>app.before_request(set_request_id)<br></code></pre></td></tr></table></figure>

<h2 id="2-如何使用contextvars模块"><a href="#2-如何使用contextvars模块" class="headerlink" title="2.如何使用contextvars模块"></a>2.如何使用contextvars模块</h2><blockquote>
<p>这里举了一个例子, 但这个例子也有别的解决方案. 只不过通过这个例子顺便说如何使用contextvar模块</p>
</blockquote>
<p>首先看看未使用<code>contextvars</code>时,asyncio的web框架是如何传变量的,根据<code>starlette</code>的文档,在未使用<code>contextvars</code>时,传递<code>Redis</code>客户端实例的办法是通过request.stat这个变量保存<code>Redis</code>客户端的实例,改写代码如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-comment"># demo/web_tools.py</span><br><span class="hljs-comment"># 通过中间件把变量给存进去</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RequestContextMiddleware</span>(<span class="hljs-params">BaseHTTPMiddleware</span>):</span><br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dispatch</span>(<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">            self, request: Request, call_next: RequestResponseEndpoint</span></span><br><span class="hljs-function"><span class="hljs-params">    </span>) -&gt; Response:</span><br>        request.stat.redis = REDIS_POOL<br>        response = <span class="hljs-keyword">await</span> call_next(request)<br>        <span class="hljs-keyword">return</span> response<br><span class="hljs-comment"># demo/server.py</span><br><span class="hljs-comment"># 调用变量</span><br><span class="hljs-meta">@APP.route(<span class="hljs-params"><span class="hljs-string">&#x27;/&#x27;</span></span>)</span><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">homepage</span>(<span class="hljs-params">request</span>):</span><br>    <span class="hljs-comment"># 伪代码,这里是执行redis命令</span><br>    <span class="hljs-keyword">await</span> request.stat.redis.execute()<br>    <span class="hljs-keyword">return</span> JSONResponse(&#123;<span class="hljs-string">&#x27;hello&#x27;</span>: <span class="hljs-string">&#x27;world&#x27;</span>&#125;)<br></code></pre></td></tr></table></figure>
<p>代码非常简便, 也可以正常的运行, 但你下次在重构时, 比如简单的把redis这个变量名改为new_redis, 那IDE不会识别出来, 需要一个一个改。 同时, 在写代码的时候, IDE永远不知道这个方法调用到的变量的类型是什么, IDE也无法智能的帮你检查(如输入request.stat.redis.时,IDE不会出现execute,或者出错时,IDE并不会提示). 这非常不利于项目的工程化, 而通过<code>contextvars</code>和<code>TypeHints</code>, 恰好能解决这个问题.</p>
<p>说了那么多, 下面以一个<code>Redis</code> client为例子,展示如何在asyncio生态中使用<code>contextvars</code>, 并引入<code>TypeHints</code>(详细解释见代码).</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-comment"># demo/context.py</span><br><span class="hljs-comment"># 该文件存放contextvars相关</span><br><span class="hljs-keyword">import</span> contextvars<br><br><span class="hljs-keyword">if</span> TYPE_CHECKING:<br>    <span class="hljs-keyword">from</span> demo.redis_dal <span class="hljs-keyword">import</span> RDS  <span class="hljs-comment"># 这里是一个redis的封装实例</span><br><br><span class="hljs-comment"># 初始化一个redis相关的全局context</span><br>redis_pool_context = contextvars.ContextVar(<span class="hljs-string">&#x27;redis_pool&#x27;</span>)<br><br><span class="hljs-comment"># 通过函数调用可以获取到当前协程运行时的context上下文</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_redis</span>() -&gt; &#x27;RDS&#x27;:</span><br>    <span class="hljs-keyword">return</span> redis_pool_context.get()<br><br><span class="hljs-comment"># demo/web_tool.py</span><br><span class="hljs-comment"># 该文件存放starlette相关模块</span><br><span class="hljs-keyword">from</span> starlette.middleware.base <span class="hljs-keyword">import</span> BaseHTTPMiddleware<br><span class="hljs-keyword">from</span> starlette.requests <span class="hljs-keyword">import</span> Request<br><span class="hljs-keyword">from</span> starlette.middleware.base <span class="hljs-keyword">import</span> RequestResponseEndpoint<br><span class="hljs-keyword">from</span> starlette.responses <span class="hljs-keyword">import</span> Response<br><span class="hljs-keyword">from</span> demo.redis_dal <span class="hljs-keyword">import</span> RDS<br><br><br><span class="hljs-comment"># 初始化一个redis客户端变量,当前为空</span><br>REDIS_POOL = <span class="hljs-literal">None</span>  <span class="hljs-comment"># type: Optional[RDS]</span><br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RequestContextMiddleware</span>(<span class="hljs-params">BaseHTTPMiddleware</span>):</span><br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dispatch</span>(<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">            self, request: Request, call_next: RequestResponseEndpoint</span></span><br><span class="hljs-function"><span class="hljs-params">    </span>) -&gt; Response:</span><br>        <span class="hljs-comment"># 通过中间件,在进入路由之前,把redis客户端放入当前协程的上下文之中</span><br>        token = redis_pool_context.<span class="hljs-built_in">set</span>(REDIS_POOL)<br>        <span class="hljs-keyword">try</span>:<br>        	response = <span class="hljs-keyword">await</span> call_next(request)<br>            <span class="hljs-keyword">return</span> response<br>        <span class="hljs-keyword">finally</span>:<br>        	<span class="hljs-comment"># 调用完成,回收当前请求设置的redis客户端的上下文</span><br>            redis_pool_context.reset(token)<br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">startup_event</span>() -&gt; <span class="hljs-keyword">None</span>:</span><br>    <span class="hljs-keyword">global</span> REDIS_POOL<br><br>    REDIS_POOL = RDS() <span class="hljs-comment"># 初始化客户端,里面通过asyncio.ensure_future逻辑延后连接</span><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">shutdown_event</span>() -&gt; <span class="hljs-keyword">None</span>:</span><br>    <span class="hljs-keyword">if</span> REDIS_POOL:<br>        <span class="hljs-keyword">await</span> REDIS_POOL.close() <span class="hljs-comment"># 关闭redis客户端</span><br><br><span class="hljs-comment"># demo/server.py</span><br><span class="hljs-comment"># 该文件存放starlette main逻辑</span><br><span class="hljs-keyword">from</span> starlette.applications <span class="hljs-keyword">import</span> Starlette<br><span class="hljs-keyword">from</span> starlette.responses <span class="hljs-keyword">import</span> JSONResponse<br><br><span class="hljs-keyword">from</span> demo.web_tool <span class="hljs-keyword">import</span> RequestContextMiddleware<br><span class="hljs-keyword">from</span> demo.context <span class="hljs-keyword">import</span> get_redis<br><br><br>APP = Starlette()<br>APP.add_middleware(RequestContextMiddleware)<br><br><br><span class="hljs-meta">@APP.route(<span class="hljs-params"><span class="hljs-string">&#x27;/&#x27;</span></span>)</span><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">homepage</span>(<span class="hljs-params">request</span>):</span><br>    <span class="hljs-comment"># 伪代码,这里是执行redis命令</span><br>    <span class="hljs-comment"># 只要验证 id(get_redis())等于demo.web_tool里REDID_POOL的id一致,那证明contextvars可以为asyncio维护一套上下文状态</span><br>    <span class="hljs-keyword">await</span> get_redis().execute()<br>    <span class="hljs-keyword">return</span> JSONResponse(&#123;<span class="hljs-string">&#x27;hello&#x27;</span>: <span class="hljs-string">&#x27;world&#x27;</span>&#125;)<br></code></pre></td></tr></table></figure>

<h2 id="3-如何优雅的使用contextvars"><a href="#3-如何优雅的使用contextvars" class="headerlink" title="3.如何优雅的使用contextvars"></a>3.如何优雅的使用contextvars</h2><p>从上面的示例代码来看, 使用<code>contextvar</code>和<code>TypeHint</code>确实能让让IDE可以识别到这个变量是什么了, 但增加的代码太多了,更恐怖的是, 每多一个变量,就需要自己去写一个context,一个变量的初始化,一个变量的get函数,同时在引用时使用函数会比较别扭.</p>
<p>自己在使用了<code>contextvars</code>一段时间后,觉得这样太麻烦了,每次都要做一堆重复的操作,且平时使用最多的就是把一个实例或者提炼出Headers的参数放入contextvars中,所以写了一个封装<a href="https://github.com/so1n/fast-tools/blob/master/fast_tools/context.py">fast_tools.context</a>(同时兼容<code>fastapi</code>和<code>starlette</code>)， 它能屏蔽所有与contextvars的相关逻辑,其中由ContextModel负责contextvars的set和get操作,ContextMiddleware管理contextvars的周期,HeaderHeader负责托管Headers相关的参数， 调用者只需要在ContextModel中写入自己需要的变量,引用时调用ContextModel的属性即可. </p>
<p>以下是调用者的代码示例, 这里的实例化变量由一个http client代替, 且都会每次请求分配一个客户端实例, 但在实际使用中并不会为每一个请求都分配一个客户端实例, 很影响性能:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> asyncio<br><span class="hljs-keyword">import</span> uuid<br><span class="hljs-keyword">from</span> contextvars <span class="hljs-keyword">import</span> Context, copy_context<br><span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> partial<br><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> Optional, Set<br><br><span class="hljs-keyword">import</span> httpx<br><span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> FastAPI, Request, Response<br><br><span class="hljs-keyword">from</span> fast_tools.context <span class="hljs-keyword">import</span> ContextBaseModel, ContextMiddleware, HeaderHelper<br><br>app: FastAPI = FastAPI()<br>check_set: Set[<span class="hljs-built_in">int</span>] = <span class="hljs-built_in">set</span>()<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ContextModel</span>(<span class="hljs-params">ContextBaseModel</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">	通过该实例可以屏蔽大部分与contextvars相关的操作,如果要添加一个变量,则在该实例添加一个属性即可.</span><br><span class="hljs-string">	属性必须要使用Type Hints的写法,不然不会识别(强制使用Type Hints)</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br><br>    <span class="hljs-comment"># 用于把自己的实例(如上文所说的redis客户端)存放于contextvars中</span><br>    http_client: httpx.AsyncClient<br>    <span class="hljs-comment"># HeaderHepler用于把header的变量存放于contextvars中</span><br>    request_id: <span class="hljs-built_in">str</span> = HeaderHelper.i(<span class="hljs-string">&quot;X-Request-Id&quot;</span>, default_func=<span class="hljs-keyword">lambda</span> request: <span class="hljs-built_in">str</span>(uuid.uuid4()))<br>    ip: <span class="hljs-built_in">str</span> = HeaderHelper.i(<span class="hljs-string">&quot;X-Real-IP&quot;</span>, default_func=<span class="hljs-keyword">lambda</span> request: request.client.host)<br>    user_agent: <span class="hljs-built_in">str</span> = HeaderHelper.i(<span class="hljs-string">&quot;User-Agent&quot;</span>)<br><br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">before_request</span>(<span class="hljs-params">self, request: Request</span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        <span class="hljs-comment"># 请求之前的钩子, 通过该钩子可以设置自己的变量</span><br>        self.http_client = httpx.AsyncClient()<br>        check_set.add(<span class="hljs-built_in">id</span>(self.http_client))<br><br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">before_reset_context</span>(<span class="hljs-params">self, request: Request, response: Optional[Response]</span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        <span class="hljs-comment"># 准备退出中间件的钩子, 这步奏后会清掉上下文</span><br>        <span class="hljs-keyword">await</span> self.http_client.aclose()<br><br><br>context_model: ContextModel = ContextModel()<br>app.add_middleware(ContextMiddleware, context_model=context_model)<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_ensure_future</span>() -&gt; <span class="hljs-keyword">None</span>:</span><br>    <span class="hljs-keyword">assert</span> <span class="hljs-built_in">id</span>(context_model.http_client) <span class="hljs-keyword">in</span> check_set<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_run_in_executor</span>() -&gt; <span class="hljs-keyword">None</span>:</span><br>    <span class="hljs-keyword">assert</span> <span class="hljs-built_in">id</span>(context_model.http_client) <span class="hljs-keyword">in</span> check_set<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_call_soon</span>() -&gt; <span class="hljs-keyword">None</span>:</span><br>    <span class="hljs-keyword">assert</span> <span class="hljs-built_in">id</span>(context_model.http_client) <span class="hljs-keyword">in</span> check_set<br><br><br><span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&quot;/&quot;</span></span>)</span><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">root</span>() -&gt; dict:</span><br>    <span class="hljs-comment"># 在使用asyncio.ensure_future开启另外一个子协程跑任务时, 也可以复用上下文</span><br>    asyncio.ensure_future(test_ensure_future())<br>    loop: <span class="hljs-string">&quot;asyncio.AbstractEventLoop&quot;</span> = asyncio.get_event_loop()<br><br>    <span class="hljs-comment"># 使用call_soon也能复用上下文</span><br>    loop.call_soon(test_call_soon)<br><br>    <span class="hljs-comment"># 使用run_in_executor也能复用上下文, 但必须使用上下文的run方法, copy_context表示复制当前的上下文</span><br>    ctx: Context = copy_context()<br>    <span class="hljs-keyword">await</span> loop.run_in_executor(<span class="hljs-literal">None</span>, partial(ctx.run, test_run_in_executor))  <span class="hljs-comment"># type: ignore</span><br>    <span class="hljs-keyword">return</span> &#123;<br>        <span class="hljs-string">&quot;message&quot;</span>: context_model.to_dict(is_safe_return=<span class="hljs-literal">True</span>),  <span class="hljs-comment"># not return CustomQuery</span><br>        <span class="hljs-string">&quot;client_id&quot;</span>: <span class="hljs-built_in">id</span>(context_model.http_client),<br>    &#125;<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    <span class="hljs-keyword">import</span> uvicorn  <span class="hljs-comment"># type: ignore</span><br><br>    uvicorn.run(app)<br></code></pre></td></tr></table></figure>
<p>可以从例子中看到, 通过封装的上下文调用会变得非常愉快, 只要通过一两步方法就能设置好自己的上下文属性, 同时不用考虑如何编写上下文的生命周期. 另外也能通过这个例子看出, 在asyncio生态中, contextvars能运用到包括子协程, 多线程等所有的场景中.</p>
<h2 id="4-contextvars的原理"><a href="#4-contextvars的原理" class="headerlink" title="4.contextvars的原理"></a>4.contextvars的原理</h2><p>在第一次使用时,我就很好奇contextvars是如何去维护程序的上下文的,好在contextvars的作者出了一个向下兼容的<a href="https://github.com/MagicStack/contextvars">contextvars</a>库,虽然他不支持asyncio,但我们还是可以通过代码了解到他的基本原理.</p>
<h3 id="4-1-ContextMeta-ContextVarMeta和TokenMeta"><a href="#4-1-ContextMeta-ContextVarMeta和TokenMeta" class="headerlink" title="4.1 ContextMeta,ContextVarMeta和TokenMeta"></a>4.1 ContextMeta,ContextVarMeta和TokenMeta</h3><p>代码仓中有<code>ContextMeta</code>,<code>ContextVarMeta</code>和<code>TokenMeta</code>这几个对象, 它们的功能都是防止用户来继承<code>Context</code>,<code>ContextVar</code>和<code>Token</code>,原理都是通过元类来判断类名是否是自己编写类的名称,如果不是则抛错.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ContextMeta</span>(<span class="hljs-params"><span class="hljs-built_in">type</span>(<span class="hljs-params">collections.abc.Mapping</span>)</span>):</span><br><br>    <span class="hljs-comment"># contextvars.Context is not subclassable.</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__new__</span>(<span class="hljs-params">mcls, names, bases, dct</span>):</span><br>        cls = <span class="hljs-built_in">super</span>().__new__(mcls, names, bases, dct)<br>        <span class="hljs-keyword">if</span> cls.__module__ != <span class="hljs-string">&#x27;contextvars&#x27;</span> <span class="hljs-keyword">or</span> cls.__name__ != <span class="hljs-string">&#x27;Context&#x27;</span>:<br>            <span class="hljs-keyword">raise</span> TypeError(<span class="hljs-string">&quot;type &#x27;Context&#x27; is not an acceptable base type&quot;</span>)<br>        <span class="hljs-keyword">return</span> cls<br></code></pre></td></tr></table></figure>

<h3 id="4-2-Token"><a href="#4-2-Token" class="headerlink" title="4.2 Token"></a>4.2 Token</h3><p>上下文的本质是一个堆栈, 每次set一次对象就向堆栈增加一层数据, 每次reset就是pop掉最上层的数据, 而在<code>Contextvars</code>中, 通过<code>Token</code>对象来维护堆栈之间的交互.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Token</span>(<span class="hljs-params">metaclass=TokenMeta</span>):</span><br><br>    MISSING = <span class="hljs-built_in">object</span>()<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, context, var, old_value</span>):</span><br>        <span class="hljs-comment"># 分别存放上下文变量, 当前set的数据以及上次set的数据</span><br>        self._context = context<br>        self._var = var<br>        self._old_value = old_value<br>        self._used = <span class="hljs-literal">False</span><br><br><span class="hljs-meta">    @property</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">var</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> self._var<br><br><span class="hljs-meta">    @property</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">old_value</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> self._old_value<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__repr__</span>(<span class="hljs-params">self</span>):</span><br>        r = <span class="hljs-string">&#x27;&lt;Token &#x27;</span><br>        <span class="hljs-keyword">if</span> self._used:<br>            r += <span class="hljs-string">&#x27; used&#x27;</span><br>        r += <span class="hljs-string">&#x27; var=&#123;!r&#125; at &#123;:0x&#125;&gt;&#x27;</span>.<span class="hljs-built_in">format</span>(self._var, <span class="hljs-built_in">id</span>(self))<br>        <span class="hljs-keyword">return</span> r<br></code></pre></td></tr></table></figure>
<p>可以看到<code>Token</code>的代码很少, 它只保存当前的<code>context</code>变量, 本次调用set的数据和上一次被set的旧数据. 用户只有在调用<code>contextvar.context</code>后才能得到<code>Token</code>, 返回的<code>Token</code>可以被用户在调用context后, 通过调用context.reset(token)来清空保存的上下文,方便本次context的变量能及时的被回收, 回到上上次的数据.</p>
<h3 id="4-3-全局唯一context"><a href="#4-3-全局唯一context" class="headerlink" title="4.3 全局唯一context"></a>4.3 全局唯一context</h3><p>前面说过, Python中由<code>threading.local()</code>负责每个线程的context, 协程属于线程的’子集’,所以contextvar直接基于<code>threading.local()</code>生成自己的全局context. 从他的源代码可以看到, <code>_state</code>就是<code>threading.local()</code>的引用, 并通过设置和读取<code>_state</code>的<code>context</code>属性来写入和读取当前的上下文, <code>copy_context</code>调用也很简单, 同样也是调用到<code>threading.local()</code>API.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">copy_context</span>():</span><br>    <span class="hljs-keyword">return</span> _get_context().copy()<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_get_context</span>():</span><br>    ctx = <span class="hljs-built_in">getattr</span>(_state, <span class="hljs-string">&#x27;context&#x27;</span>, <span class="hljs-literal">None</span>)<br>    <span class="hljs-keyword">if</span> ctx <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>        ctx = Context()<br>        _state.context = ctx<br>    <span class="hljs-keyword">return</span> ctx<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_set_context</span>(<span class="hljs-params">ctx</span>):</span><br>    _state.context = ctx<br><br><br>_state = threading.local()<br></code></pre></td></tr></table></figure>

<p>关于<code>threading.local()</code>,虽然不是本文重点,但由于<code>contextvars</code>是基于<code>threading.local()</code>进行封装的,所以还是要明白<code>threading.local()</code>的原理,这里并不直接通过源码分析, 而是做一个简单的示例解释.</p>
<p>在一个线程里面使用线程的局部变量会比直接使用全局变量的性能好，因为局部变量只有线程自己能看见，不会影响其他线程，而全局变量的修改必须加锁, 性能会变得很差, 比如下面全局变量的例子:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python">pet_dict = &#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_pet</span>(<span class="hljs-params">pet_name</span>):</span><br>    <span class="hljs-keyword">return</span> pet_dict[pet_name]<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">set_pet</span>(<span class="hljs-params">pet_name</span>):</span><br>    <span class="hljs-keyword">return</span> pet_dict[pet_name]<br></code></pre></td></tr></table></figure>
<p>这份代码就是模仿一个简单的全局变量调用, 如果是多线程调用的话, 那就需要加锁啦, 每次在读写之前都要等到持有锁的线程放弃了锁后再去竞争, 而且还可能污染到了别的线程存放的数据. </p>
<p>而线程的局部变量则是让每个线程有一个自己的<code>pet_dict</code>, 假设每个线程调用<code>get_pet</code>,<code>set_pet</code>时,都会把自己的pid传入进来, 那么就可以避免多个线程去同时竞争资源, 同时也不会污染到别的线程的数据, 那么代码可以改为这样子:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python">pet_dict = &#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_pet</span>(<span class="hljs-params">pet_name, pid</span>):</span><br>    <span class="hljs-keyword">return</span> pet_dict[pid][pet_name]<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">set_pet</span>(<span class="hljs-params">pet_name, pid</span>):</span><br>    <span class="hljs-keyword">return</span> pet_dict[pid][pet_name]<br></code></pre></td></tr></table></figure>
<p>不过这样子使用起来非常方便, 同时示例例子没有对异常检查和初始化等处理, 如果值比较复杂, 我们还要维护异常状况， 这样太麻烦了.</p>
<p>这时候<code>threading.local()</code>就应运而生了,他负责帮我们处理这些维护的工作,我们只要对他进行一些调用即可,调用起来跟单线程调用一样简单方便, 应用<code>threading.local()</code>后的代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> threading<br><br><br>thread_local=threading.local()<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_pet</span>(<span class="hljs-params">pet_name</span>):</span><br>    <span class="hljs-keyword">return</span> thread_local[pet_name]<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">set_pet</span>(<span class="hljs-params">pet_name</span>):</span><br>    <span class="hljs-keyword">return</span> thread_local[pet_name]<br></code></pre></td></tr></table></figure>
<p>可以看到代码就像调用全局变量一样， 但是又不会产生竞争状态。</p>
<h3 id="4-4contextvar自己封装的Context"><a href="#4-4contextvar自己封装的Context" class="headerlink" title="4.4contextvar自己封装的Context"></a>4.4contextvar自己封装的Context</h3><p><code>contextvars</code>自己封装的Context比较简单, 这里只展示他的两个核心方法(其他的魔术方法就像<code>dict</code>的魔术方法一样):</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Context</span>(<span class="hljs-params">collections.abc.Mapping, metaclass=ContextMeta</span>):</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        self._data = immutables.Map()<br>        self._prev_context = <span class="hljs-literal">None</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span>(<span class="hljs-params">self, <span class="hljs-built_in">callable</span>, *args, **kwargs</span>):</span><br>        <span class="hljs-keyword">if</span> self._prev_context <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">raise</span> RuntimeError(<br>                <span class="hljs-string">&#x27;cannot enter context: &#123;&#125; is already entered&#x27;</span>.<span class="hljs-built_in">format</span>(self))<br><br>        self._prev_context = _get_context()<br>        <span class="hljs-keyword">try</span>:<br>            _set_context(self)<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">callable</span>(*args, **kwargs)<br>        <span class="hljs-keyword">finally</span>:<br>            _set_context(self._prev_context)<br>            self._prev_context = <span class="hljs-literal">None</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">copy</span>(<span class="hljs-params">self</span>):</span><br>        new = Context()<br>        new._data = self._data<br>        <span class="hljs-keyword">return</span> new<br></code></pre></td></tr></table></figure>
<p>首先, 在<code>__init__</code>方法可以看到self._data,这里使用到了一个叫immutables.Map()的不可变对象,并对immutables.Map()进行一些封装,所以context可以看成一个不可变的dict。这样可以防止调用copy方法后得到的上下文的变动会影响到了原本的上下文变量。</p>
<p>查看immutables.Map()的示例代码可以看到,每次对原对象的修改时,原对象并不会发生改变,并会返回一个已经发生改变的新对象.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python">map2 = <span class="hljs-built_in">map</span>.<span class="hljs-built_in">set</span>(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-number">10</span>)<br>print(<span class="hljs-built_in">map</span>, map2)<br><span class="hljs-comment"># will print:</span><br><span class="hljs-comment">#   &lt;immutables.Map(&#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: 2&#125;)&gt;</span><br><span class="hljs-comment">#   &lt;immutables.Map(&#123;&#x27;a&#x27;: 10, &#x27;b&#x27;: 2&#125;)&gt;</span><br><br>map3 = map2.delete(<span class="hljs-string">&#x27;b&#x27;</span>)<br>print(<span class="hljs-built_in">map</span>, map2, map3)<br><span class="hljs-comment"># will print:</span><br><span class="hljs-comment">#   &lt;immutables.Map(&#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: 2&#125;)&gt;</span><br><span class="hljs-comment">#   &lt;immutables.Map(&#123;&#x27;a&#x27;: 10, &#x27;b&#x27;: 2&#125;)&gt;</span><br><span class="hljs-comment">#   &lt;immutables.Map(&#123;&#x27;a&#x27;: 10&#125;)&gt;</span><br></code></pre></td></tr></table></figure>

<p>此外,context还有一个叫<code>run</code>的方法, 上面在执行<code>loop.run_in_executor</code>时就用过<code>run</code>方法, 目的就是可以产生一个新的上下文变量给另外一个线程使用, 同时这个新的上下文变量跟原来的上下文变量是一致的.<br>执行run的时候,可以看出会copy一个新的上下文来调用传入的函数, 由于<code>immutables.Map</code>的存在, 函数中对上下文的修改并不会影响旧的上下文变量, 达到进程复制数据时的写时复制的目的. 在<code>run</code>方法的最后, 函数执行完了会再次set旧的上下文, 从而完成一次上下文切换.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span>(<span class="hljs-params">self, <span class="hljs-built_in">callable</span>, *args, **kwargs</span>):</span><br>    <span class="hljs-comment"># 已经存在旧的context,抛出异常,防止多线程循环调用</span><br>    <span class="hljs-keyword">if</span> self._prev_context <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>        <span class="hljs-keyword">raise</span> RuntimeError(<br>            <span class="hljs-string">&#x27;cannot enter context: &#123;&#125; is already entered&#x27;</span>.<span class="hljs-built_in">format</span>(self))<br><br>    self._prev_context = _get_context()  <span class="hljs-comment"># 保存当前的context</span><br>    <span class="hljs-keyword">try</span>:<br>        _set_context(self) <span class="hljs-comment"># 设置新的context</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">callable</span>(*args, **kwargs)  <span class="hljs-comment"># 执行函数</span><br>    <span class="hljs-keyword">finally</span>:<br>        _set_context(self._prev_context)  <span class="hljs-comment"># 设置为旧的context</span><br>        self._prev_context = <span class="hljs-literal">None</span><br></code></pre></td></tr></table></figure>

<h3 id="4-5-ContextVar"><a href="#4-5-ContextVar" class="headerlink" title="4.5 ContextVar"></a>4.5 ContextVar</h3><p>我们一般在使用contextvars模块时,经常使用的就是<code>ContextVar</code>这个类了,这个类很简单,主要提供了set–设置值,get–获取值,reset–重置值三个方法, 从<code>Context</code>类中写入和获取值, 而set和reset的就是通过上面的token类进行交互的.</p>
<ul>
<li>set – 为当前上下文设置变量  <figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">set</span>(<span class="hljs-params">self, value</span>):</span><br>    ctx = _get_context()  <span class="hljs-comment"># 获取当前上下文对象`Context`</span><br>    data = ctx._data<br>    <span class="hljs-keyword">try</span>:<br>        old_value = data[self]  <span class="hljs-comment"># 获取Context旧对象</span><br>    <span class="hljs-keyword">except</span> KeyError:<br>        old_value = Token.MISSING  <span class="hljs-comment"># 获取不到则填充一个object(全局唯一)</span><br><br>    updated_data = data.<span class="hljs-built_in">set</span>(self, value) <span class="hljs-comment"># 设置新的值</span><br>    ctx._data = updated_data<br>    <span class="hljs-keyword">return</span> Token(ctx, self, old_value) <span class="hljs-comment"># 返回带有旧值的token</span><br></code></pre></td></tr></table></figure></li>
<li>get – 从当前上下文获取变量  <figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get</span>(<span class="hljs-params">self, default=_NO_DEFAULT</span>):</span><br>    ctx = _get_context()  <span class="hljs-comment"># 获取当前上下文对象`Context`</span><br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-keyword">return</span> ctx[self]  <span class="hljs-comment"># 返回获取的值</span><br>    <span class="hljs-keyword">except</span> KeyError:<br>        <span class="hljs-keyword">pass</span><br><br>    <span class="hljs-keyword">if</span> default <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> _NO_DEFAULT:<br>        <span class="hljs-keyword">return</span> default    <span class="hljs-comment"># 返回调用get时设置的值</span><br><br>    <span class="hljs-keyword">if</span> self._default <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> _NO_DEFAULT:<br>        <span class="hljs-keyword">return</span> self._default  <span class="hljs-comment"># 返回初始化context时设置的默认值</span><br><br>    <span class="hljs-keyword">raise</span> LookupError  <span class="hljs-comment"># 都没有则会抛错</span><br></code></pre></td></tr></table></figure></li>
<li>reset – 清理本次用到的上下文数据  <figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reset</span>(<span class="hljs-params">self, token</span>):</span><br>       <span class="hljs-keyword">if</span> token._used:<br>       	<span class="hljs-comment"># 判断token是否已经被使用</span><br>           <span class="hljs-keyword">raise</span> RuntimeError(<span class="hljs-string">&quot;Token has already been used once&quot;</span>)<br><br>       <span class="hljs-keyword">if</span> token._var <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> self:<br>       	<span class="hljs-comment"># 判断token是否是当前contextvar返回的</span><br>           <span class="hljs-keyword">raise</span> ValueError(<br>               <span class="hljs-string">&quot;Token was created by a different ContextVar&quot;</span>)<br><br>       <span class="hljs-keyword">if</span> token._context <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> _get_context():<br>       	<span class="hljs-comment"># 判断token的上下文是否跟contextvar上下文一致</span><br>           <span class="hljs-keyword">raise</span> ValueError(<br>               <span class="hljs-string">&quot;Token was created in a different Context&quot;</span>)<br><br>       ctx = token._context<br>       <span class="hljs-keyword">if</span> token._old_value <span class="hljs-keyword">is</span> Token.MISSING:<br>       	<span class="hljs-comment"># 如果没有旧值则删除该值</span><br>           ctx._data = ctx._data.delete(token._var)<br>       <span class="hljs-keyword">else</span>:<br>       	<span class="hljs-comment"># 有旧值则当前contextvar变为旧值</span><br>           ctx._data = ctx._data.<span class="hljs-built_in">set</span>(token._var, token._old_value)<br><br>       token._used = <span class="hljs-literal">True</span>  <span class="hljs-comment"># 设置flag,标记token已经被使用了</span><br></code></pre></td></tr></table></figure>
则此,contextvar的原理了解完了,接下来再看看他是如何在asyncio运行的.</li>
</ul>
<h2 id="5-contextvars-asyncio"><a href="#5-contextvars-asyncio" class="headerlink" title="5.contextvars asyncio"></a>5.contextvars asyncio</h2><p>由于向下兼容的<code>contextvars</code>并不支持asyncio, 所以这里通过<a href="https://github.com/Skyscanner/aiotask-context">aiotask-context</a>的源码简要的了解如何在asyncio中如何获取和设置context。</p>
<h3 id="5-1在asyncio中获取context"><a href="#5-1在asyncio中获取context" class="headerlink" title="5.1在asyncio中获取context"></a>5.1在asyncio中获取context</h3><p>相比起contextvars复杂的概念,在asyncio中,我们可以很简单的获取到当前协程的task, 然后通过task就可以很方便的获取到task的context了,由于Pyhon3.7对asyncio的高级API 重新设计,所以可以看到需要对获取当前task进行封装</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python">PY37 = sys.version_info &gt;= (<span class="hljs-number">3</span>, <span class="hljs-number">7</span>)<br><br><span class="hljs-keyword">if</span> PY37:<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">asyncio_current_task</span>(<span class="hljs-params">loop=<span class="hljs-literal">None</span></span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;Return the current task or None.&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-keyword">return</span> asyncio.current_task(loop)<br>        <span class="hljs-keyword">except</span> RuntimeError:<br>            <span class="hljs-comment"># simulate old behaviour</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br><span class="hljs-keyword">else</span>:<br>    asyncio_current_task = asyncio.Task.current_task<br></code></pre></td></tr></table></figure>
<p>不同的版本有不同的获取task方法， 之后我们就可以通过调用<code>asyncio_current_task().context</code>即可获取到当前的上下文了…</p>
<h3 id="5-2-对上下文的操作"><a href="#5-2-对上下文的操作" class="headerlink" title="5.2 对上下文的操作"></a>5.2 对上下文的操作</h3><p>同样的,在得到上下文后, 我们这里也需要set, get, reset的操作,不过十分简单, 类似dict一样的操作即可, 它没有token的逻辑：</p>
<ul>
<li>set  <figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">set</span>(<span class="hljs-params">key, value</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    Sets the given value inside Task.context[key]. If the key does not exist it creates it.</span><br><span class="hljs-string">    :param key: identifier for accessing the context dict.</span><br><span class="hljs-string">    :param value: value to store inside context[key].</span><br><span class="hljs-string">    :raises</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    current_task = asyncio_current_task()<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> current_task:<br>        <span class="hljs-keyword">raise</span> ValueError(NO_LOOP_EXCEPTION_MSG.<span class="hljs-built_in">format</span>(key))<br><br>    current_task.context[key] = value<br></code></pre></td></tr></table></figure></li>
<li>get  <figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get</span>(<span class="hljs-params">key, default=<span class="hljs-literal">None</span></span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    Retrieves the value stored in key from the Task.context dict. If key does not exist,</span><br><span class="hljs-string">    or there is no event loop running, default will be returned</span><br><span class="hljs-string">    :param key: identifier for accessing the context dict.</span><br><span class="hljs-string">    :param default: None by default, returned in case key is not found.</span><br><span class="hljs-string">    :return: Value stored inside the dict[key].</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    current_task = asyncio_current_task()<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> current_task:<br>        <span class="hljs-keyword">raise</span> ValueError(NO_LOOP_EXCEPTION_MSG.<span class="hljs-built_in">format</span>(key))<br><br>    <span class="hljs-keyword">return</span> current_task.context.get(key, default)<br></code></pre></td></tr></table></figure></li>
<li>clear – 也就是<code>contextvar.ContextVars</code>中的reset  <figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">clear</span>():</span><br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    Clear the Task.context.</span><br><span class="hljs-string">    :raises ValueError: if no current task.</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    current_task = asyncio_current_task()<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> current_task:<br>        <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&quot;No event loop found&quot;</span>)<br><br>    current_task.context.clear()<br></code></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="5-2-copying-task-factory和chainmap-task-factory"><a href="#5-2-copying-task-factory和chainmap-task-factory" class="headerlink" title="5.2 copying_task_factory和chainmap_task_factory"></a>5.2 copying_task_factory和chainmap_task_factory</h3><p>在Python的更高级版本中,已经支持设置context了,所以这两个方法可以不再使用了.他们最后都用到了<code>task_factory</code>的方法.<br><code>task_factory</code>简单说就是创建一个新的task,再通过工厂方法合成context,最后把context设置到task</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">task_factory</span>(<span class="hljs-params">loop, coro, copy_context=<span class="hljs-literal">False</span>, context_factory=<span class="hljs-literal">None</span></span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    By default returns a task factory that uses a simple dict as the task context,</span><br><span class="hljs-string">    but allows context creation and inheritance to be customized via ``context_factory``.</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-comment"># 生成context工厂函数</span><br>    context_factory = context_factory <span class="hljs-keyword">or</span> partial(<br>        dict_context_factory, copy_context=copy_context)<br><br>    <span class="hljs-comment"># 创建task, 跟asyncio.ensure_future一样</span><br>    task = asyncio.tasks.Task(coro, loop=loop)<br>    <span class="hljs-keyword">if</span> task._source_traceback:<br>        <span class="hljs-keyword">del</span> [-<span class="hljs-number">1</span>]<br><br>    <span class="hljs-comment"># 获取task的context</span><br>    <span class="hljs-keyword">try</span>:<br>        context = asyncio_current_task(loop=loop).context<br>    <span class="hljs-keyword">except</span> AttributeError:<br>        context = <span class="hljs-literal">None</span><br>    <br>    <span class="hljs-comment"># 从context工厂中处理context并赋值在task</span><br>    task.context = context_factory(context)<br><br>    <span class="hljs-keyword">return</span> task<br></code></pre></td></tr></table></figure>

<p><code>aiotask-context</code>提供了两个对context处理的函数<code>dict_context_factory</code>和<code>chainmap_context_factory</code>.在<code>aiotask-context</code>中,context是一个dict对象,<code>dict_context_factory</code>可以选择赋值或者设置新的context</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dict_context_factory</span>(<span class="hljs-params">parent_context=<span class="hljs-literal">None</span>, copy_context=<span class="hljs-literal">False</span></span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;A traditional ``dict`` context to keep things simple&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">if</span> parent_context <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>        <span class="hljs-comment"># initial context</span><br>        <span class="hljs-keyword">return</span> &#123;&#125;<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-comment"># inherit context</span><br>        new_context = parent_context<br>        <span class="hljs-keyword">if</span> copy_context:<br>            new_context = deepcopy(new_context)<br>        <span class="hljs-keyword">return</span> new_context<br></code></pre></td></tr></table></figure>

<p><code>chainmap_context_factory</code>与<code>dict_context_factory</code>的区别就是在合并context而不是直接继承.同时借用<code>ChainMap</code>保证合并context后,还能同步context的改变</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">chainmap_context_factory</span>(<span class="hljs-params">parent_context=<span class="hljs-literal">None</span></span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    A ``ChainMap`` context, to avoid copying any data</span><br><span class="hljs-string">    and yet preserve strict one-way inheritance</span><br><span class="hljs-string">    (just like with dict copying)</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-keyword">if</span> parent_context <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>        <span class="hljs-comment"># initial context</span><br>        <span class="hljs-keyword">return</span> ChainMap()<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-comment"># inherit context</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">isinstance</span>(parent_context, ChainMap):<br>            <span class="hljs-comment"># if a dict context was previously used, then convert</span><br>            <span class="hljs-comment"># (without modifying the original dict)</span><br>            parent_context = ChainMap(parent_context)<br>        <span class="hljs-keyword">return</span> parent_context.new_child()<br></code></pre></td></tr></table></figure>
<p>至此, asyncio中context的调用就简单的分析完了, 如果想要深入的了解asyncio是怎么传上下文的, 可以查看asyncio都源码.</p>
<h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6.总结"></a>6.总结</h2><p>contextvars本身原理很简单,但他可以让我们调用起来更加方便便捷,减少我们的传参次数,同时还可以结合TypeHint使项目更加工成化, 但是还是仁者见仁. 不过在使用时最好能加上一层封装, 最好的实践应该是一个协程共享同一个context而不是每个变量一个context.</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>asyncio</tag>
      </tags>
  </entry>
  <entry>
    <title>python常见的坑</title>
    <url>/2019/06/08/python%E5%B8%B8%E8%A7%81%E7%9A%84%E5%9D%91/</url>
    <content><![CDATA[<h2 id="前记"><a href="#前记" class="headerlink" title="前记"></a>前记</h2><p>本文主体思想和内容来自于<a href="https://www.toptal.com/python/top-10-mistakes-that-python-programmers-make">Buggy Python Code: The 10 Most Common Mistakes That Python Developers Make</a>。由于结合内容写出自己平时遇到一些坑，所以与原文有些不同之处，出入较大。</p>
<span id="more"></span>

<h2 id="1-滥用可变对象作为函数参数的默认值"><a href="#1-滥用可变对象作为函数参数的默认值" class="headerlink" title="1. 滥用可变对象作为函数参数的默认值"></a>1. 滥用可变对象作为函数参数的默认值</h2><p>Python允许您给函数的参数提供默认值，但是在使用可变对象作为默认参数时，它可能会导致一些混淆。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python">In [<span class="hljs-number">1</span>]: <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span>(<span class="hljs-params">bar=[]</span>):</span> <br>   ...:     bar.append(<span class="hljs-string">&quot;baz&quot;</span>) <br>   ...:     <span class="hljs-keyword">return</span> bar <br>   ...:                                                                                                            <br><br>In [<span class="hljs-number">2</span>]: foo()                                                                                                      <br>Out[<span class="hljs-number">2</span>]: [<span class="hljs-string">&#x27;baz&#x27;</span>]<br><br>In [<span class="hljs-number">3</span>]: foo()                                                                                                      <br>Out[<span class="hljs-number">3</span>]: [<span class="hljs-string">&#x27;baz&#x27;</span>, <span class="hljs-string">&#x27;baz&#x27;</span>]<br><br>In [<span class="hljs-number">4</span>]: foo()                                                                                                      <br>Out[<span class="hljs-number">4</span>]: [<span class="hljs-string">&#x27;baz&#x27;</span>, <span class="hljs-string">&#x27;baz&#x27;</span>, <span class="hljs-string">&#x27;baz&#x27;</span>]<br></code></pre></td></tr></table></figure>
<p>写下这个代码时，是想让代码在参数时已经初始化为一个list，之后可以对该参数进行操作，最后返回该参数，但是Python每次调用时都会给现有的foo()的bar默认值添加”bar”.<br>造成这样的原因是，Python在执行的时候，会把关键字参数存在于函数的<code>__defaults__</code>里面,在foo函数中,虽然调用的foo行为不一样,但函数里的bar对象的一样的,也就是把bar=[]这个对象存放于<code>__defaults__</code>里,由于bar是一个可变对象,每次调用都会用到与上一次相同的bar对象,进行处理后返回同一个bar,可以通过调用以下方法查看foo函数的关键字参数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python">In [<span class="hljs-number">5</span>]: foo.__defaults__       <br><br>Out[<span class="hljs-number">5</span>]: ([<span class="hljs-string">&#x27;baz&#x27;</span>, <span class="hljs-string">&#x27;baz&#x27;</span>, <span class="hljs-string">&#x27;baz&#x27;</span>, <span class="hljs-string">&#x27;baz&#x27;</span>, <span class="hljs-string">&#x27;baz&#x27;</span>],)<br></code></pre></td></tr></table></figure>
<p>同时要注意的是，在使用Python的类方法时也会发生这样的情况</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python">In [<span class="hljs-number">1</span>]: <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span> <br>   ...:     bar = [] <br>   ...:                                                                                <br>In [<span class="hljs-number">2</span>]: foo = Foo()                                                        <br>In [<span class="hljs-number">3</span>]: foo.bar.append(<span class="hljs-number">1</span>)                                                 <br><br>In [<span class="hljs-number">4</span>]: foo1 = Foo()                                                                                 <br>In [<span class="hljs-number">5</span>]: foo1.bar                                                                                       <br>Out[<span class="hljs-number">5</span>]: [<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure>

<h2 id="2-错误的使用类变量"><a href="#2-错误的使用类变量" class="headerlink" title="2.错误的使用类变量"></a>2.错误的使用类变量</h2><p>先看看如下示例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python">In [<span class="hljs-number">1</span>]: <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span> <br>   ...:     x=<span class="hljs-number">1</span> <br>   ...:                                                                                                            <br><br>In [<span class="hljs-number">2</span>]: <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span>(<span class="hljs-params">A</span>):</span> <br>   ...:     <span class="hljs-keyword">pass</span> <br>   ...:                                                                                                            <br><br>In [<span class="hljs-number">3</span>]: <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span>(<span class="hljs-params">A</span>):</span> <br>   ...:     <span class="hljs-keyword">pass</span> <br>   ...:                                                                                                            <br><br>In [<span class="hljs-number">4</span>]: print(A.x, B.x, C.x)                                                                                       <br><span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>
<p>会发现一切都和预想的一样</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python">In [<span class="hljs-number">5</span>]: B.x = <span class="hljs-number">2</span>                                                                                                    <br><br>In [<span class="hljs-number">6</span>]: print(A.x, B.x, C.x)                                                                                       <br><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>
<p>这个也完成OK没/有任何问题，接下来试一试改A.x</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python">In [<span class="hljs-number">7</span>]: A.x = <span class="hljs-number">2</span>                                                                                                                                                             <br>In [<span class="hljs-number">8</span>]: print(A.x, B.x, C.x)                                                                                                                                                 <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span><br><br>In [<span class="hljs-number">9</span>]: A.x = <span class="hljs-number">3</span>                                                                                                                                                             <br>In [<span class="hljs-number">10</span>]: print(A.x, B.x, C.x)                                                                                                                                               <br><span class="hljs-number">3</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure>
<p>可以看到,C.x会根据A.x进行改变,而B不会进行改变,这是因为在Python中，类变量在内部作为字典处理，并遵循解析顺序（MRO）的方法。因此在上面的代码中，由于在C类中找不到该属性x，因此将在其基类中查找（仅A在上面的示例中，尽管Python支持多个继承）。因此，C.x实际上是指A.x。而B.x在In[5]中做了赋值的操作,所以B类中存在属性x.</p>
<p>所以在使用继承时,要让子类共享父类的属性,那子类的属性一定不能进行赋值操作</p>
<h2 id="3-Python作用域与定义的问题"><a href="#3-Python作用域与定义的问题" class="headerlink" title="3.Python作用域与定义的问题"></a>3.Python作用域与定义的问题</h2><p>先看看代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python">In [<span class="hljs-number">1</span>]: a = <span class="hljs-number">10</span>                                                                                                     <br><br>In [<span class="hljs-number">2</span>]: <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span>():</span> <br>   ...:     print(a) <br>   ...:     a += <span class="hljs-number">1</span> <br>   ...:                                                                                                            <br><br>In [<span class="hljs-number">3</span>]: foo()                                                                                                      <br>---------------------------------------------------------------------------<br>UnboundLocalError                         Traceback (most recent call last)<br>&lt;ipython-<span class="hljs-built_in">input</span>-<span class="hljs-number">3</span>-c19b6d9633cf&gt; <span class="hljs-keyword">in</span> &lt;module&gt;<br>----&gt; 1 foo()<br><br>&lt;ipython-<span class="hljs-built_in">input</span>-<span class="hljs-number">2</span>-174dbfc7b886&gt; <span class="hljs-keyword">in</span> foo()<br>      <span class="hljs-number">1</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span>():</span><br>----&gt; 2     print(a)<br>      <span class="hljs-number">3</span>     a += <span class="hljs-number">1</span><br>      <span class="hljs-number">4</span> <br><br>UnboundLocalError: local variable <span class="hljs-string">&#x27;a&#x27;</span> referenced before assignment<br></code></pre></td></tr></table></figure>
<p>造成这样的原因是在对def作用域的变量进行赋值(定义)时，Python会自动将变量a视为def作用域，但此时def作用域并没有a这个变量，因此才会抛出该错误。可以通过global和nonlocal分别声明def里的变量是在def作用域还是全局作用域来解决这个问题。<br>之所以在赋值后面括号加上定义是因为，Python的=不仅是赋值，还带有定义，而真正引起错误的是<br>a += 1, a += 1其实是a = a + 1 此时的 = 带有的定义功能，才会造成这样的错误，试试下面的例子，由于append并不是赋值的操作，会发现Python并不会报错</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python">In [<span class="hljs-number">4</span>]: aaa = []                                                                                                   <br><br>In [<span class="hljs-number">5</span>]: <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span>():</span> <br>   ...:     print(aaa) <br>   ...:     aaa.append(<span class="hljs-string">&#x27;1&#x27;</span>) <br>   ...:     <span class="hljs-keyword">return</span> aaa                                                                                                    <br>In [<span class="hljs-number">7</span>]: print(foo())                                                                                           <br>[<span class="hljs-string">&#x27;1&#x27;</span>]<br>[<span class="hljs-string">&#x27;1&#x27;</span>]<br><br></code></pre></td></tr></table></figure>
<p>此外，在该示例代码中的In[2]中相对于原文调整了x += 1和print的位置。这样的抛错会让人感觉更加奇怪，按道理应该会先执行print(a)再抛错的，但是却看不到有执行print(a)的痕迹，这时在写下一个与原文一样的代码，函数名命名为foo1，查看他们的字节码有什么变化</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python">In [<span class="hljs-number">4</span>]: <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo1</span>():</span> <br>   ...:     a += <span class="hljs-number">1</span> <br>   ...:     print(a) <br>   ...:                                                                                                            <br>In [<span class="hljs-number">5</span>]: <span class="hljs-keyword">import</span> dis                                                                                                <br>In [<span class="hljs-number">6</span>]: dis.dis(foo)                                                     <br>  <span class="hljs-number">2</span>           <span class="hljs-number">0</span> LOAD_GLOBAL              <span class="hljs-number">0</span> (<span class="hljs-built_in">print</span>)<br>              <span class="hljs-number">2</span> LOAD_FAST                <span class="hljs-number">0</span> (a)<br>              <span class="hljs-number">4</span> CALL_FUNCTION            <span class="hljs-number">1</span><br>              <span class="hljs-number">6</span> POP_TOP<br><br>  <span class="hljs-number">3</span>           <span class="hljs-number">8</span> LOAD_FAST                <span class="hljs-number">0</span> (a)<br>             <span class="hljs-number">10</span> LOAD_CONST               <span class="hljs-number">1</span> (<span class="hljs-number">1</span>)<br>             <span class="hljs-number">12</span> INPLACE_ADD<br>             <span class="hljs-number">14</span> STORE_FAST               <span class="hljs-number">0</span> (a)<br>             <span class="hljs-number">16</span> LOAD_CONST               <span class="hljs-number">0</span> (<span class="hljs-literal">None</span>)<br>             <span class="hljs-number">18</span> RETURN_VALUE<br><br>In [<span class="hljs-number">7</span>]: dis.dis(foo1)                                              <br>  <span class="hljs-number">2</span>           <span class="hljs-number">0</span> LOAD_FAST                <span class="hljs-number">0</span> (a)<br>              <span class="hljs-number">2</span> LOAD_CONST               <span class="hljs-number">1</span> (<span class="hljs-number">1</span>)<br>              <span class="hljs-number">4</span> INPLACE_ADD<br>              <span class="hljs-number">6</span> STORE_FAST               <span class="hljs-number">0</span> (a)<br><br>  <span class="hljs-number">3</span>           <span class="hljs-number">8</span> LOAD_GLOBAL              <span class="hljs-number">0</span> (<span class="hljs-built_in">print</span>)<br>             <span class="hljs-number">10</span> LOAD_FAST                <span class="hljs-number">0</span> (a)<br>             <span class="hljs-number">12</span> CALL_FUNCTION            <span class="hljs-number">1</span><br>             <span class="hljs-number">14</span> POP_TOP<br>             <span class="hljs-number">16</span> LOAD_CONST               <span class="hljs-number">0</span> (<span class="hljs-literal">None</span>)<br>             <span class="hljs-number">18</span> RETURN_VALUE<br></code></pre></td></tr></table></figure>
<p>可以看出按照原文(foo1)会直接执行查找变量a，而在执行foo()的print(a)时，python也会去查找a,由于下面带有a+=1,Python的字节码从LOAD_GLOBAL变为LOAD_FAST也就是从def查找局部变量，所以就会导致print(a)执行的时候就报错了。</p>
<h2 id="4-在迭代时修改list"><a href="#4-在迭代时修改list" class="headerlink" title="4.在迭代时修改list"></a>4.在迭代时修改list</h2><p>先看一下代码以及报错</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python">In [<span class="hljs-number">1</span>]: odd = <span class="hljs-keyword">lambda</span> x: <span class="hljs-built_in">bool</span>(x % <span class="hljs-number">2</span>)                                                                                <br>In [<span class="hljs-number">2</span>]: number_list = [n <span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>)]                                                                     <br>In [<span class="hljs-number">3</span>]: <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(number_list)): <br>   ...:     <span class="hljs-keyword">if</span> odd(number_list[i]): <br>   ...:         <span class="hljs-keyword">del</span> number_list[i] <br>   ...:                                                                                                            <br>---------------------------------------------------------------------------<br>IndexError                                Traceback (most recent call last)<br>&lt;ipython-<span class="hljs-built_in">input</span>-<span class="hljs-number">3</span>-6c6e0f879da3&gt; <span class="hljs-keyword">in</span> &lt;module&gt;<br>      <span class="hljs-number">1</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(number_list)):<br>----&gt; 2     if odd(number_list[i]):<br>      <span class="hljs-number">3</span>         <span class="hljs-keyword">del</span> number_list[i]<br>      <span class="hljs-number">4</span> <br><br>IndexError: <span class="hljs-built_in">list</span> index out of <span class="hljs-built_in">range</span><br></code></pre></td></tr></table></figure>
<p>这是一个常见的问题，但是经常会陷入一个误区，直到报错了发现不能在迭代的过程中del list的某一项数值。解决该错误的思路就是根据原有对象重新deepcopy一个对象再进行处理，下面是一个优雅的编程示例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python">In [<span class="hljs-number">4</span>]: number_list = [n <span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> number_list <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> odd(n)]                                                       <br>In [<span class="hljs-number">5</span>]: number_list                                                                                                <br>Out[<span class="hljs-number">5</span>]: [<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>]<br></code></pre></td></tr></table></figure>
<h2 id="5-闭包中的变量一直不变"><a href="#5-闭包中的变量一直不变" class="headerlink" title="5.闭包中的变量一直不变"></a>5.闭包中的变量一直不变</h2><p>考虑以下示例代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python">In [<span class="hljs-number">1</span>]: <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">create_multipliers</span>():</span> <br>   ...:     <span class="hljs-keyword">return</span> [<span class="hljs-keyword">lambda</span> x:i*x <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>)] <br>   ...:                                                                                                             <br><br>In [<span class="hljs-number">2</span>]: <span class="hljs-keyword">for</span> multiplier <span class="hljs-keyword">in</span> create_multipliers(): <br>   ...:     print(multiplier(<span class="hljs-number">2</span>)) <br>   ...:                                                                                                             <br><span class="hljs-number">8</span><br><span class="hljs-number">8</span><br><span class="hljs-number">8</span><br><span class="hljs-number">8</span><br><span class="hljs-number">8</span><br></code></pre></td></tr></table></figure>
<p>没想到他的输出竟然不是</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-number">0</span><br><span class="hljs-number">2</span><br><span class="hljs-number">4</span><br><span class="hljs-number">6</span><br><span class="hljs-number">8</span><br></code></pre></td></tr></table></figure>
<p>这是因为PYthon的后期绑定行为，每当调用时，Python会在作用域查找对应的值(此时循环已经完成了，因此i的值是它的最终值：4)。<br>要想解决这个问题需要用到一些稍微奇妙的方法，就像问题1说到给参数配置一个动态变量时那样神奇。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python">In [<span class="hljs-number">3</span>]: <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">create_multipliers</span>():</span> <br>   ...:     <span class="hljs-keyword">return</span> [<span class="hljs-keyword">lambda</span> x, i=i:i*x <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>)] <br>   ...:      <br>   ...:  <br>   ...:                                                                                                             <br>In [<span class="hljs-number">4</span>]: <span class="hljs-keyword">for</span> multiplier <span class="hljs-keyword">in</span> create_multipliers(): <br>   ...:     print(multiplier(<span class="hljs-number">2</span>)) <br>   ...:                                                                                                             <br><span class="hljs-number">0</span><br><span class="hljs-number">2</span><br><span class="hljs-number">4</span><br><span class="hljs-number">6</span><br><span class="hljs-number">8</span><br></code></pre></td></tr></table></figure>

<h2 id="6-异常处理中finally的return"><a href="#6-异常处理中finally的return" class="headerlink" title="6.异常处理中finally的return"></a>6.异常处理中finally的return</h2><p>在异常处理中，不管是否抛错，都会执行finally而且比return优先执行，这就会造成一个bug，如下示例:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python">In [<span class="hljs-number">1</span>]: <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dig_dig2</span>(<span class="hljs-params">index</span>):</span> <br>   ...:     <span class="hljs-keyword">try</span>: <br>   ...:         print(<span class="hljs-string">&quot;I&#x27;m in try&quot;</span>) <br>   ...:         <span class="hljs-keyword">if</span> index &lt; <span class="hljs-number">0</span>: <br>   ...:             <span class="hljs-keyword">raise</span> IndexError <br>   ...:         <span class="hljs-keyword">else</span>: <br>   ...:             <span class="hljs-keyword">return</span> index <br>   ...:     <span class="hljs-keyword">except</span> IndexError: <br>   ...:         print(<span class="hljs-string">&quot;I&#x27;m in except&quot;</span>) <br>   ...:         <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;except&quot;</span> <br>   ...:     <span class="hljs-keyword">finally</span>: <br>   ...:         print(<span class="hljs-string">&quot;I&#x27;m in finally&quot;</span>) <br>   ...:         <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;finally&quot;</span> <br>   ...:  <br>   ...:  <br>   ...: print(dig_dig2(<span class="hljs-number">12</span>))                                                                                        <br>I<span class="hljs-string">&#x27;m in try</span><br><span class="hljs-string">I&#x27;</span>m <span class="hljs-keyword">in</span> <span class="hljs-keyword">finally</span><br><span class="hljs-keyword">finally</span><br></code></pre></td></tr></table></figure>
<p>由于代码中在finally块语句中存在return语句，整个函数已结束，所以try块语句中return语句将永远得不到执行。</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>给Python Web框架接口加上类型检查</title>
    <url>/2019/04/15/%E7%BB%99python%E6%8E%A5%E5%8F%A3%E5%8A%A0%E4%B8%8A%E4%B8%80%E5%B1%82%E7%B1%BB%E5%9E%8B%E6%A3%80/</url>
    <content><![CDATA[<h2 id="前记"><a href="#前记" class="headerlink" title="前记"></a>前记</h2><p>给接口加上类型检查的想法源于我实习时写接口的灵感, 那时候就是一个crud boy,一直在写接口,但每次都要在接口写一些参数校验或参数类型转换, 觉得很繁琐,总觉得这个是可以自己封装一个,减少大量代码. 在实现的过程中发现自己慢慢的接受了代码即文档的实现, 并且慢慢迭代, 使之越来越完善, 最终蜕变成一个开源项目<a href="https://github.com/so1n/pait">pait</a></p>
<span id="more"></span>
<hr>
<p><strong>注</strong>:<br>第一版是18年实习的时候,基 于一个叫sanic的web框架以及Python3.5写的.</p>
<p>19/03 更新: 为了代码统一,这里的示例是把sanic的接口代码迁移到starlette, Python3.7了.</p>
<p>19/04 更新: 增加Pydantic的使用</p>
<p>20/07 更新: 根据几个版本迭代出了项目<a href="https://github.com/so1n/pait">pait</a>,功能更多,并且支持接口文档导出, 以及支持swagger和redoc页面展示.</p>
<p>21/01 更新: 更新每个版本的完整代码<a href="https://github.com/so1n/example/tree/master/example_python/example_python/api_param_check">跳转链接</a></p>
<h2 id="1-为何要加上给接口加上一层类型校验"><a href="#1-为何要加上给接口加上一层类型校验" class="headerlink" title="1.为何要加上给接口加上一层类型校验"></a>1.为何要加上给接口加上一层类型校验</h2><h3 id="1-1-示例接口"><a href="#1-1-示例接口" class="headerlink" title="1.1.示例接口"></a>1.1.示例接口</h3><p>先看看一个普通的示例接口:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> uvicorn<br><span class="hljs-keyword">from</span> starlette.applications <span class="hljs-keyword">import</span> Starlette<br><span class="hljs-keyword">from</span> starlette.responses <span class="hljs-keyword">import</span> JSONResponse<br><span class="hljs-keyword">from</span> starlette.routing <span class="hljs-keyword">import</span> Route, Router<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">demo_post</span>(<span class="hljs-params">request</span>):</span><br>    json_data = <span class="hljs-keyword">await</span> request.json()<br>    uid = request_data.get(<span class="hljs-string">&#x27;uid&#x27;</span>, <span class="hljs-number">0</span>)<br>    timestamp = request_data.get(<span class="hljs-string">&#x27;timestamp&#x27;</span>, <span class="hljs-number">0</span>)<br>    user_info = request_data.get(<span class="hljs-string">&#x27;user_info&#x27;</span>, &#123;&#125;)<br>    user_name = request_data.get(<span class="hljs-string">&#x27;user_name&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>)<br>    <span class="hljs-keyword">return</span> JSONResponse(&#123;<span class="hljs-string">&#x27;hello&#x27;</span>: <span class="hljs-string">&#x27;world&#x27;</span>&#125;)<br><br><br>app = Starlette(<br>    routes=[<br>        Route(<span class="hljs-string">&#x27;/api&#x27;</span>, demo_post, methods=[<span class="hljs-string">&#x27;POST&#x27;</span>]),<br>    ]<br>)<br>uvicorn.run(app)<br></code></pre></td></tr></table></figure>

<p>可以看到, 这个接口接收POST请求, 路由函数获取了4个参数<code>uid</code>,<code>timestamp</code>,<code>user_info</code>,<code>user_name</code>.在正常的接口中需要对参数进行处理和转换,比如uid这里只接受int类型,那么就需要多写一个判断或者转换, 如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-comment"># 示例代码, 实际上通过封装会更优美</span><br><span class="hljs-keyword">try</span><br>    uid = <span class="hljs-built_in">int</span>(uid)<br><span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>    <span class="hljs-keyword">raise</span> e<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">type</span>(uid) != <span class="hljs-built_in">int</span>:<br>    <span class="hljs-keyword">raise</span> Exception<br></code></pre></td></tr></table></figure>
<p>可以看到平时写这种参数校验或类型转换会比较繁琐,同时接口的所有参数都需要参数校验,非常麻烦.一般像这些又繁琐又简单的东西都可以给程序自动化处理的,减轻自己的负担.</p>
<h2 id="2-接口类型校验加在哪里"><a href="#2-接口类型校验加在哪里" class="headerlink" title="2.接口类型校验加在哪里?"></a>2.接口类型校验加在哪里?</h2><p>从上面的例子来看,加上一层接口类型自动校验和转换是非常有用且利于我们写接口的,也能减少很多工作量,那么这一层得怎么加,加在哪呢?</p>
<p>这一层主要工作是拿到请求信息, 并进行转换和处理, 再把结果传递给路由函数, 那么, 我们这一层必须处于在框架拿到请求信息之后, 在进入路由函数之前.<br>而在框架中,只有中间件和给路由函数套上装饰器才可以比较优雅的增加接口类型校验. 但考虑到每个接口的参数都不一致,所以只能把接口类型校验这一层封装在一个装饰器里面,并在对应的路由函数套上该装饰器.</p>
<p>既然决定了只能把接口类型校验放在装饰器,那只能通过传递参数和编写装饰器来共同完成接口类型校验功能,其中装饰器的逻辑是绝对不会变的, 应传递的参数决定了该路由函数接受了什么样的参数,那最好就是传递的参数是一个model(也就是python的类型),如果有新加功能,就是给类添加一个方法,再由装饰器的逻辑去调用.</p>
<p>好了思路已经想好了,开始实现吧.</p>
<h3 id="2-1-第一版-使用python基本类型校验"><a href="#2-1-第一版-使用python基本类型校验" class="headerlink" title="2.1 第一版,使用python基本类型校验"></a>2.1 第一版,使用python基本类型校验</h3><p><a href="https://github.com/so1n/example/blob/master/example_python/example_python/api_param_check/version1.py">第一版代码</a></p>
<p>第一版是整个代码的核心部分,之后也是围绕第一版代码进行修改,这里先贴所有代码<br>相对于示例接口, 主要改动是:</p>
<ul>
<li>1.增加一个Model类,用户通过继承可以简单快速的创建自己想要的Mode</li>
<li>2.增加一个装饰器,用户可以把要检验的函数套上装饰器,并传入自己定义的Model.</li>
<li>3.增加一个``request.state.param_dict`的方法, 路由函数可以直接从该方法获得已经被转换好的数据</li>
</ul>
<p>其他说明见代码里面的注释:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> ast<br><span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> wraps<br><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> Callable, Type<br><br><br><span class="hljs-keyword">import</span> uvicorn<br><span class="hljs-keyword">from</span> starlette.applications <span class="hljs-keyword">import</span> Starlette<br><span class="hljs-keyword">from</span> starlette.requests <span class="hljs-keyword">import</span> Request<br><span class="hljs-keyword">from</span> starlette.responses <span class="hljs-keyword">import</span> JSONResponse<br><span class="hljs-keyword">from</span> starlette.routing <span class="hljs-keyword">import</span> Route<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Model</span>:</span><br>    <span class="hljs-string">&quot;&quot;&quot;创建一个Model类, 类属性是&#123;参数&#125;=&#123;参数类型&#125;&quot;&quot;&quot;</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;这里把类属性的值设置到__dict__&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">for</span> key <span class="hljs-keyword">in</span> self.__dir__():<br>            <span class="hljs-comment"># 屏蔽自带方法,或其他私有方法</span><br>            <span class="hljs-keyword">if</span> key.startswith(<span class="hljs-string">&#x27;_&#x27;</span>):<br>                <span class="hljs-keyword">continue</span><br>            value = <span class="hljs-built_in">getattr</span>(self, key, <span class="hljs-literal">None</span>)<br>            <span class="hljs-comment"># 值不是python type的也是错的</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">isinstance</span>(value, <span class="hljs-built_in">type</span>):<br>                <span class="hljs-keyword">continue</span><br>            self.__dict__[key] = value<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">to_dict</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;把&#123;参数&#125;=&#123;类型&#125;转为dict&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">return</span> self.__dict__<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomModel</span>(<span class="hljs-params">Model</span>):</span><br>    <span class="hljs-comment"># 这个是实际使用的Model, 看得出需要的uid参数类型是int</span><br>    uid = <span class="hljs-built_in">int</span><br>    timestamp = <span class="hljs-built_in">int</span><br>    user_info = <span class="hljs-built_in">dict</span><br>    user_name = <span class="hljs-built_in">str</span><br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">params_verify</span>(<span class="hljs-params">model: Type[Model]</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;装饰器&quot;&quot;&quot;</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">wrapper</span>(<span class="hljs-params">func: Callable</span>):</span><br><span class="hljs-meta">        @wraps(<span class="hljs-params">func</span>)</span><br>        <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">request_param</span>(<span class="hljs-params">request: Request, *args, **kwargs</span>):</span><br>            <span class="hljs-comment"># 获取参数, 这里只做简单演示, 只获取url和json请求的数据</span><br>            param_dict: <span class="hljs-built_in">dict</span> = <span class="hljs-built_in">dict</span>(request.query_params)<br>            <span class="hljs-keyword">if</span> request.method == <span class="hljs-string">&quot;POST&quot;</span>:<br>                param_dict.update(<span class="hljs-keyword">await</span> request.json())<br>            instance_model: Model = model()<br>            <span class="hljs-keyword">try</span>:<br>                <span class="hljs-comment"># 通过model了解到了需要获取什么参数, 参数的类型是什么</span><br>                <span class="hljs-keyword">for</span> key, key_type <span class="hljs-keyword">in</span> instance_model.to_dict().items():<br>                    <span class="hljs-keyword">if</span> key <span class="hljs-keyword">in</span> param_dict:<br>                        <span class="hljs-comment"># 通过ast进行安全的类型转换</span><br>                        value = ast.literal_eval(param_dict[key])<br>                        param_dict[key] = key_type(value)<br>                <span class="hljs-comment"># 把转化好的参数放到&#x27;param_dict&#x27;</span><br>                request.state.param_dict = param_dict<br>                <span class="hljs-comment"># 处理响应</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> func(request, *args, **kwargs)<br>            <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>                <span class="hljs-comment"># 这里为了示范,把错误抛出来</span><br>                <span class="hljs-keyword">return</span> JSONResponse(&#123;<span class="hljs-string">&#x27;error&#x27;</span>: <span class="hljs-built_in">str</span>(e)&#125;)<br>        <span class="hljs-keyword">return</span> request_param<br>    <span class="hljs-keyword">return</span> wrapper<br><br><br><span class="hljs-meta">@params_verify(<span class="hljs-params">CustomModel</span>)</span><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">demo_post</span>(<span class="hljs-params">request</span>):</span><br>    <span class="hljs-keyword">return</span> JSONResponse(&#123;<span class="hljs-string">&#x27;result&#x27;</span>: request.state.param_dict&#125;)<br><br><br><span class="hljs-meta">@params_verify(<span class="hljs-params">CustomModel</span>)</span><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">demo_get</span>(<span class="hljs-params">request</span>):</span><br>    <span class="hljs-keyword">return</span> JSONResponse(&#123;<span class="hljs-string">&#x27;result&#x27;</span>: request.state.param_dict&#125;)<br><br><br>app = Starlette(<br>    routes=[<br>        Route(<span class="hljs-string">&#x27;/api&#x27;</span>, demo_post, methods=[<span class="hljs-string">&#x27;POST&#x27;</span>]),<br>        Route(<span class="hljs-string">&#x27;/api&#x27;</span>, demo_get, methods=[<span class="hljs-string">&#x27;GET&#x27;</span>]),<br>    ]<br>)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    uvicorn.run(app)<br></code></pre></td></tr></table></figure>
<p>代码编写好后开始运行代码,测试<code>GET:/api</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">&gt;&gt;&gt; curl <span class="hljs-string">&quot;127.0.0.1:8000/api?uid=123&quot;</span><br>&#123;<span class="hljs-string">&quot;result&quot;</span>:&#123;<span class="hljs-string">&quot;uid&quot;</span>:123&#125;&#125;<br>&gt;&gt;&gt; curl <span class="hljs-string">&quot;127.0.0.1:8000/api?uid=abc&quot;</span><br>&#123;<span class="hljs-string">&quot;error&quot;</span>:<span class="hljs-string">&quot;malformed node or string: &lt;_ast.Name object at 0x7f3b2c5c3c10&gt;&quot;</span>&#125;<br></code></pre></td></tr></table></figure>
<p>可以看到当uid=123时,程序会自动把123转换为int类型, 而uid=abc则无法进行转换,并由ast模块抛错.<br>看得出第一版还是挺不错的,但是使用上有些麻烦,接下来进入第二版,添加更多常用的功能.</p>
<h3 id="2-2-第二版-添加其他常用的功能"><a href="#2-2-第二版-添加其他常用的功能" class="headerlink" title="2.2 第二版,添加其他常用的功能"></a>2.2 第二版,添加其他常用的功能</h3><p><a href="https://github.com/so1n/example/blob/master/example_python/example_python/api_param_check/version2.py">第二版代码</a></p>
<p>在做接口检验时, 除了做类型识别外, 我们还会有一些常见的需求:</p>
<ul>
<li>字符串长度的最大/小长值</li>
<li>数字最大/最小值</li>
<li>该参数是否是必填</li>
</ul>
<p>但是由于我们设计Model时,采用’{参数}={类型}’的方法,已经填不了更多的值了,如果传一个dict或者list 限制又比较多,同时会让人很迷惑,同时,装饰器函数只是个函数,功能尽量的单一,要方便拓展.所以在第二版,我结合Python的描述器协议,对Model进行改版.</p>
<p>首先创建一个<code>MISS_OBJECT</code>空对象, 用来判断用户有没有设置默认值, 和<code>CustomValueError</code>异常</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomValueError</span>(<span class="hljs-params">ValueError</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;异常&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">pass</span><br><br><br>MISS_OBJECT: <span class="hljs-string">&#x27;object()&#x27;</span> = <span class="hljs-built_in">object</span>()  <span class="hljs-comment"># 用于判空且非None</span><br></code></pre></td></tr></table></figure>

<p>接下来就是一个创建Field,我们可以通过Field来实现拓展功能,Field是一个Python描述器,用于托管Model类属性的<code>__get__</code>,<code>__set__</code>,<code>__delete__</code>方法,本次修改的主要功能都在<code>Field</code>的<code>__set__</code>方法里面(目前简单就都写在同一个函数里)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Field</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">        self,</span></span><br><span class="hljs-function"><span class="hljs-params">        _type: Type,</span></span><br><span class="hljs-function"><span class="hljs-params">        default: Any = MISS_OBJECT,</span></span><br><span class="hljs-function"><span class="hljs-params">        max_length: Optional[<span class="hljs-built_in">int</span>] = <span class="hljs-literal">None</span>,</span></span><br><span class="hljs-function"><span class="hljs-params">        max_value: Optional[<span class="hljs-built_in">int</span>] = <span class="hljs-literal">None</span>,</span></span><br><span class="hljs-function"><span class="hljs-params">        min_value: Optional[<span class="hljs-built_in">int</span>] = <span class="hljs-literal">None</span>,</span></span><br><span class="hljs-function"><span class="hljs-params">    </span>):</span><br>        self._type: Type = _type<br>        self._default: Any = default<br>        self._max_length: Optional[<span class="hljs-built_in">int</span>] = max_length<br>        self._max: Optional[<span class="hljs-built_in">int</span>] = max_value<br>        self._min: Optional[<span class="hljs-built_in">int</span>] = min_value<br>        self._dict: Dict[<span class="hljs-built_in">str</span>, Any] = &#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__get__</span>(<span class="hljs-params">self, instance: <span class="hljs-string">&#x27;object()&#x27;</span>, owner: Type</span>) -&gt; Any:</span><br>        <span class="hljs-comment"># 获取已经处理好的数据</span><br>        <span class="hljs-keyword">try</span>:<br>            value = self._dict[instance]<br>        <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>            <span class="hljs-keyword">raise</span> CustomValueError(<span class="hljs-string">&#x27;value must not empty&#x27;</span>) <span class="hljs-keyword">from</span> e<br>        <span class="hljs-keyword">return</span> value<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__set__</span>(<span class="hljs-params">self, instance: <span class="hljs-string">&#x27;object()&#x27;</span>, value: Union[<span class="hljs-built_in">str</span>, Any]</span>):</span><br>        <span class="hljs-comment"># 获取到请求的数据, 开始写入数据</span><br>        <span class="hljs-keyword">if</span> value <span class="hljs-keyword">is</span> MISS_OBJECT:<br>            <span class="hljs-comment"># 如果是空数据,且没设置默认值,则抛错</span><br>            <span class="hljs-keyword">if</span> self._default <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> MISS_OBJECT:<br>                value = self._default<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&#x27;value must not empty&#x27;</span>)<br><br>        <span class="hljs-keyword">if</span> value <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-comment"># 类型转换</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">type</span>(value) != self._type:<br>                value = ast.literal_eval(value)<br>                value = self._type(value)<br><br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(value, <span class="hljs-built_in">str</span>) <span class="hljs-keyword">or</span> <span class="hljs-built_in">isinstance</span>(value, <span class="hljs-built_in">list</span>) <span class="hljs-keyword">or</span> <span class="hljs-built_in">isinstance</span>(value, <span class="hljs-built_in">tuple</span>):<br>                <span class="hljs-comment"># 限制字符,list串长度</span><br>                <span class="hljs-keyword">if</span> self._max_length <span class="hljs-keyword">and</span> <span class="hljs-built_in">len</span>(value) &gt; self._max_length:<br>                    <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">f&#x27;value length:<span class="hljs-subst">&#123;<span class="hljs-built_in">len</span>(value)&#125;</span> &gt; <span class="hljs-subst">&#123;self._max_length&#125;</span>&#x27;</span>)<br>            <span class="hljs-keyword">elif</span> <span class="hljs-built_in">isinstance</span>(value, <span class="hljs-built_in">int</span>) <span class="hljs-keyword">or</span> <span class="hljs-built_in">isinstance</span>(value, <span class="hljs-built_in">float</span>):<br>                <span class="hljs-comment"># 限制数字范围</span><br>                <span class="hljs-keyword">if</span> self._max <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> value &gt; self._max:<br>                    value = self._max<br>                <span class="hljs-keyword">elif</span> self._min <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> value &lt; self._min:<br>                    value = self._min<br>        self._dict[instance] = value<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__delete__</span>(<span class="hljs-params">self, instance</span>):</span><br>        <span class="hljs-keyword">del</span> self._dict[instance]<br></code></pre></td></tr></table></figure>

<p>编写完了描述器,那么我们可以根据描述器来更改Model了, <code>__init__</code>的初始化方法进行更改,把用到Field的属性加入到<code>field_list</code>中,方便参数校验装饰器调用.在<code>CustomModel</code>中我们赋值Field,并使用FIeld中的功能约束属性.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Model</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;这里把类属性的值设置到field_dict&quot;&quot;&quot;</span><br>        self.field_list: List[<span class="hljs-built_in">str</span>] = []<br>        <span class="hljs-keyword">for</span> key <span class="hljs-keyword">in</span> self.__dir__():<br>            <span class="hljs-comment"># 屏蔽自带方法,或其他私有方法</span><br>            <span class="hljs-keyword">if</span> key.startswith(<span class="hljs-string">&#x27;_&#x27;</span>):<br>                <span class="hljs-keyword">continue</span><br>            <span class="hljs-keyword">if</span> key <span class="hljs-keyword">in</span> self.__dict__:<br>                <span class="hljs-keyword">continue</span><br>            <span class="hljs-keyword">try</span>:<br>                <span class="hljs-built_in">getattr</span>(self, key)<br>            <span class="hljs-keyword">except</span> CustomValueError:<br>                <span class="hljs-comment"># Field 还没初始化数据,所以会抛出CustpmValueError错误</span><br>                self.field_list.append(key)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">to_dict</span>(<span class="hljs-params">self</span>) -&gt; Dict[str, Any]:</span><br>        <span class="hljs-string">&quot;&quot;&quot;把&#123;参数&#125;=&#123;类型&#125;转为dict&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">return</span> &#123;<br>            key: <span class="hljs-built_in">getattr</span>(self, key)<br>            <span class="hljs-keyword">for</span> key <span class="hljs-keyword">in</span> self.field_list<br>        &#125;<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomModel</span>(<span class="hljs-params">Model</span>):</span><br>    <span class="hljs-comment"># 现在可以结合Field编写我们自己的Model, 可以看到声明了类型, 条件</span><br>    uid = Field(<span class="hljs-built_in">int</span>, min_value=<span class="hljs-number">10</span>, max_value=<span class="hljs-number">100</span>)<br>    timestamp = Field(<span class="hljs-built_in">int</span>, default=<span class="hljs-literal">None</span>)<br>    user_info = Field(<span class="hljs-built_in">dict</span>, default=<span class="hljs-literal">None</span>)<br>    user_name = Field(<span class="hljs-built_in">str</span>, max_length=<span class="hljs-number">4</span>)<br><br></code></pre></td></tr></table></figure>

<p>Model改造好了,可以把原来的装饰器进行修改:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">params_verify</span>(<span class="hljs-params">model: Type[Model]</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;装饰器&quot;&quot;&quot;</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">wrapper</span>(<span class="hljs-params">func: Callable</span>):</span><br><span class="hljs-meta">        @wraps(<span class="hljs-params">func</span>)</span><br>        <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">request_param</span>(<span class="hljs-params">request: Request, *args, **kwargs</span>):</span><br>            <span class="hljs-comment"># 获取参数, 这里只做简单演示, 只获取url和json请求的数据</span><br>            param_dict: <span class="hljs-built_in">dict</span> = <span class="hljs-built_in">dict</span>(request.query_params)<br>            <span class="hljs-keyword">if</span> request.method == <span class="hljs-string">&quot;POST&quot;</span>:<br>                param_dict.update(<span class="hljs-keyword">await</span> request.json())<br>            instance_model: Model = model()<br>            <span class="hljs-keyword">try</span>:<br>                <span class="hljs-keyword">for</span> key <span class="hljs-keyword">in</span> instance_model.field_list:<br>                    value = param_dict.get(key, MISS_OBJECT)<br>                    <span class="hljs-built_in">setattr</span>(instance_model, key, value)<br>                <span class="hljs-comment"># 把model设置到request.stat里面,方便调用</span><br>                request.state.model = instance_model<br>                <span class="hljs-comment"># 处理响应</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> func(request, *args, **kwargs)<br>            <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>                <span class="hljs-comment"># 这里为了示范,把错误抛出来</span><br>                <span class="hljs-keyword">return</span> JSONResponse(&#123;<span class="hljs-string">&#x27;error&#x27;</span>: <span class="hljs-built_in">str</span>(e)&#125;)<br>        <span class="hljs-keyword">return</span> request_param<br>    <span class="hljs-keyword">return</span> wrapper<br><br><br><span class="hljs-meta">@params_verify(<span class="hljs-params">CustomModel</span>)</span><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">demo_post</span>(<span class="hljs-params">request</span>):</span><br>    <span class="hljs-comment"># 适配修改</span><br>    <span class="hljs-keyword">return</span> JSONResponse(&#123;<span class="hljs-string">&#x27;result&#x27;</span>: request.state.model.to_dict()&#125;)<br><br><br><span class="hljs-meta">@params_verify(<span class="hljs-params">CustomModel</span>)</span><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">demo_get</span>(<span class="hljs-params">request</span>):</span><br>    <span class="hljs-comment"># 适配修改</span><br>    <span class="hljs-keyword">return</span> JSONResponse(&#123;<span class="hljs-string">&#x27;result&#x27;</span>: request.state.model.to_dict()&#125;)<br><br></code></pre></td></tr></table></figure>

<p>改写完了,继续跑下测试,看看结果怎么样(由于还没完善异常处理,所以只抛出简单的异常信息)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 由于我们没给use_name设置了default值, 所以抛错,需要填值</span><br>&gt;&gt;&gt; curl <span class="hljs-string">&quot;127.0.0.1:8000/api?uid=123&quot;</span><br>&#123;<span class="hljs-string">&quot;error&quot;</span>:<span class="hljs-string">&quot;value must not empty&quot;</span>&#125;<br><span class="hljs-comment"># 由于user_name的最大长度限制为4, 而apple的长度为5,所以抛错</span><br>&gt;&gt;&gt; curl <span class="hljs-string">&quot;127.0.0.1:8000/api?uid=123&amp;user_name=apple&quot;</span><br>&#123;<span class="hljs-string">&quot;error&quot;</span>:<span class="hljs-string">&quot;value length:5 &gt; 4&quot;</span>&#125;<br><span class="hljs-comment"># 响应正常,但是uid大于100,所以自动设置为100(正常来说这里uid的值不能被更改再使用,这里只是做测试)</span><br>&gt;&gt;&gt; curl <span class="hljs-string">&quot;127.0.0.1:8000/api?uid=123&amp;user_name=appl&quot;</span> <br>&#123;<span class="hljs-string">&quot;result&quot;</span>:&#123;<span class="hljs-string">&quot;uid&quot;</span>:100,<span class="hljs-string">&quot;timestamp&quot;</span>:null,<span class="hljs-string">&quot;user_info&quot;</span>:null,<span class="hljs-string">&quot;user_name&quot;</span>:<span class="hljs-string">&quot;appl&quot;</span>&#125;&#125;<br></code></pre></td></tr></table></figure>

<p>可以看到这一版本还有一些细节还没敲定好, 但是基本功能都是完备的, 也可以很方便的进行校验功能拓展.</p>
<h3 id="2-3-第三版-使用Type-Hints"><a href="#2-3-第三版-使用Type-Hints" class="headerlink" title="2.3 第三版,使用Type Hints"></a>2.3 第三版,使用Type Hints</h3><p><a href="https://github.com/so1n/example/blob/master/example_python/example_python/api_param_check/version3.py">第三版代码</a></p>
<p>在Python 3.5之后开始出现了一个叫TypeHints的东西, TypeHints可以通过类似于</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test</span>(<span class="hljs-params">a: <span class="hljs-built_in">int</span>, b: <span class="hljs-built_in">str</span></span>) -&gt; list</span><br><span class="hljs-function">	return [a, b]</span><br></code></pre></td></tr></table></figure>

<p>来告诉 IDE或者代码检查工具,查看用户写代码的类型是否准确(但是会让你感觉在写静态语言- -), 但不会影响运行时的性能. 在3.5时, TypeHints非常简单, 如今到了3.7TypeHint已经越来越完善了, 我们可以把Field的type转移到annotation中, 这样在写路由函数时, IDE可以帮我们更好的分析, 防止我们写错代码.<br>这一版本中, 由于使用了Python的TypeHint, 所以Field不用传入type了, 把类型写在annotation中.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Field</span>:</span><br>    ...<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">type_handle</span>(<span class="hljs-params">self, value: Any, key_type: Union[Type, _GenericAlias]</span>) -&gt; Any:</span><br>        <span class="hljs-string">&quot;&quot;&quot;兼容TyepHint和python基础类型转换的handle</span><br><span class="hljs-string">        目前只支持typing的Union,Option和所有Python的基础类型</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">hasattr</span>(key_type, <span class="hljs-string">&#x27;__origin__&#x27;</span>) <span class="hljs-keyword">and</span> key_type.__origin__ <span class="hljs-keyword">is</span> Union:<br>            <span class="hljs-comment"># get typing.type from Union</span><br>            key_type = key_type.__args__<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">isinstance</span>(value, key_type):<br>            <span class="hljs-keyword">try</span>:<br>                <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(key_type, <span class="hljs-built_in">tuple</span>):<br>                    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> key_type:<br>                        <span class="hljs-keyword">try</span>:<br>                            value = self._python_type_conversion(i, value)<br>                            <span class="hljs-keyword">break</span><br>                        <span class="hljs-keyword">except</span> TypeError:<br>                            value = <span class="hljs-literal">None</span><br>                    <span class="hljs-keyword">else</span>:<br>                        <span class="hljs-keyword">raise</span> TypeError<br>                <span class="hljs-keyword">else</span>:<br>                    value = self._python_type_conversion(key_type, value)<br>            <span class="hljs-keyword">except</span> Exception:<br>                <span class="hljs-keyword">raise</span> TypeError(<span class="hljs-string">f&quot;The type should be <span class="hljs-subst">&#123;key_type&#125;</span>&quot;</span>)<br>        <span class="hljs-keyword">return</span> value<br><br><span class="hljs-meta">    @staticmethod</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_python_type_conversion</span>(<span class="hljs-params">key_type: Type, value: <span class="hljs-built_in">str</span></span>) -&gt; Any:</span><br>        <span class="hljs-string">&quot;&quot;&quot;Python基础类型转换&quot;&quot;&quot;</span><br>        value = ast.literal_eval(value)<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">type</span>(value) == key_type:<br>            <span class="hljs-keyword">return</span> value<br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-keyword">return</span> key_type(value)<br>        <span class="hljs-keyword">except</span> Exception:<br>            <span class="hljs-keyword">raise</span> TypeError(<span class="hljs-string">f&quot;Value type:<span class="hljs-subst">&#123;<span class="hljs-built_in">type</span>(value)&#125;</span> is not <span class="hljs-subst">&#123;key_type&#125;</span>&quot;</span>)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__set__</span>(<span class="hljs-params">self, instance: <span class="hljs-string">&#x27;object()&#x27;</span>, value_tuple: Tuple[Any, Union[Type, _GenericAlias]]</span>):</span><br>        <span class="hljs-comment"># 写入数据</span><br>        value, key_type = value_tuple<br>        <span class="hljs-keyword">if</span> value <span class="hljs-keyword">is</span> MISS_OBJECT:<br>            <span class="hljs-comment"># 如果是空数据,且没设置默认值,则抛错</span><br>            <span class="hljs-keyword">if</span> self._default <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> MISS_OBJECT:<br>                value = self._default<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&#x27;value must not empty&#x27;</span>)<br>        <span class="hljs-keyword">if</span> value <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-comment"># 类型转换</span><br>            value = self.type_handle(value, key_type)<br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(value, <span class="hljs-built_in">str</span>) <span class="hljs-keyword">or</span> <span class="hljs-built_in">isinstance</span>(value, <span class="hljs-built_in">list</span>) <span class="hljs-keyword">or</span> <span class="hljs-built_in">isinstance</span>(value, <span class="hljs-built_in">tuple</span>):<br>                <span class="hljs-comment"># 限制字符,list串长度</span><br>                <span class="hljs-keyword">if</span> self._max_length <span class="hljs-keyword">and</span> <span class="hljs-built_in">len</span>(value) &gt; self._max_length:<br>                    <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">f&#x27;value length:<span class="hljs-subst">&#123;<span class="hljs-built_in">len</span>(value)&#125;</span> &gt; <span class="hljs-subst">&#123;self._max_length&#125;</span>&#x27;</span>)<br>            <span class="hljs-keyword">elif</span> <span class="hljs-built_in">isinstance</span>(value, <span class="hljs-built_in">int</span>) <span class="hljs-keyword">or</span> <span class="hljs-built_in">isinstance</span>(value, <span class="hljs-built_in">float</span>):<br>                <span class="hljs-comment"># 限制数字范围</span><br>                <span class="hljs-keyword">if</span> self._max <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> value &gt; self._max:<br>                    value = self._max<br>                <span class="hljs-keyword">elif</span> self._min <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> value &lt; self._min:<br>                    value = self._min<br>        self._dict[instance] = value<br></code></pre></td></tr></table></figure>

<p>使用TypeHint后,类型信息存放点从Field改为Model,所以Model也要做适配性改造</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Model</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;这里把类属性的值设置到field_dict&quot;&quot;&quot;</span><br>        self.field_dict = &#123;&#125;<br>        <span class="hljs-comment"># 这里调用的是self.__annotations__,里面存着类属性的key, type</span><br>        <span class="hljs-keyword">for</span> key <span class="hljs-keyword">in</span> self.__annotations__:<br>            <span class="hljs-comment"># 屏蔽自带方法,或其他私有方法</span><br>            <span class="hljs-keyword">if</span> key.startswith(<span class="hljs-string">&#x27;_&#x27;</span>):<br>                <span class="hljs-keyword">continue</span><br>            <span class="hljs-keyword">if</span> key <span class="hljs-keyword">in</span> self.__dict__:<br>                <span class="hljs-keyword">continue</span><br>            <span class="hljs-keyword">try</span>:<br>                <span class="hljs-built_in">getattr</span>(self, key)<br>            <span class="hljs-keyword">except</span> CustomValueError:<br>                <span class="hljs-comment"># 还没初始化数据,所以会抛出CustpmValueError错误</span><br>                self.field_dict[key] = self.__annotations__[key]<br>                <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">to_dict</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;把&#123;参数&#125;=&#123;类型&#125;转为dict&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">return</span> &#123;<br>            key: <span class="hljs-built_in">getattr</span>(self, key)<br>            <span class="hljs-keyword">for</span> key <span class="hljs-keyword">in</span> self.field_dict<br>        &#125;<br></code></pre></td></tr></table></figure>

<p>装饰器函数同样针对Model和Field的改动进行适配</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">params_verify</span>(<span class="hljs-params">model: Type[Model]</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;装饰器&quot;&quot;&quot;</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">wrapper</span>(<span class="hljs-params">func: Callable</span>):</span><br><span class="hljs-meta">        @wraps(<span class="hljs-params">func</span>)</span><br>        <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">request_param</span>(<span class="hljs-params">request: Request, *args, **kwargs</span>):</span><br>            <span class="hljs-comment"># 获取参数, 这里只做简单演示, 只获取url和json请求的数据</span><br>            param_dict: <span class="hljs-built_in">dict</span> = <span class="hljs-built_in">dict</span>(request.query_params)<br>            <span class="hljs-keyword">if</span> request.method == <span class="hljs-string">&quot;POST&quot;</span>:<br>                param_dict.update(<span class="hljs-keyword">await</span> request.json())<br><br>            instance_model: Model = model()<br>            <span class="hljs-keyword">try</span>:<br>                <span class="hljs-keyword">for</span> key, key_type <span class="hljs-keyword">in</span> instance_model.field_dict.items():<br>                    value = param_dict.get(key, MISS_OBJECT)<br>                    <span class="hljs-comment"># 现在传入的是value和value的type</span><br>                    <span class="hljs-built_in">setattr</span>(instance_model, key, (value, key_type))<br>                <span class="hljs-comment"># 把model设置到request.stat里面,方便调用</span><br>                request.state.model = instance_model<br>                <span class="hljs-comment"># 处理响应</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> func(request, *args, **kwargs)<br>            <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>                <span class="hljs-comment"># 这里为了示范,把错误抛出来</span><br>                <span class="hljs-keyword">return</span> JSONResponse(&#123;<span class="hljs-string">&#x27;error&#x27;</span>: <span class="hljs-built_in">str</span>(e)&#125;)<br>        <span class="hljs-keyword">return</span> request_param<br>    <span class="hljs-keyword">return</span> wrapper<br><br></code></pre></td></tr></table></figure>

<p>进行修改后,CustomModel就可以支持TyepHint功能了, 可以重点关注uid的类型,现在可以同时支持str和int了.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomModel</span>(<span class="hljs-params">Model</span>):</span><br>    uid: Union[<span class="hljs-built_in">str</span>, <span class="hljs-built_in">int</span>] = Field(min_value=<span class="hljs-number">10</span>, max_value=<span class="hljs-number">100</span>)<br>    timestamp: <span class="hljs-built_in">int</span> = Field(default=<span class="hljs-literal">None</span>)<br>    user_info: <span class="hljs-built_in">dict</span> = Field(default=<span class="hljs-literal">None</span>)<br>    user_name: <span class="hljs-built_in">str</span> = Field(max_length=<span class="hljs-number">4</span>)<br></code></pre></td></tr></table></figure>

<p>接下来看以下测试,,由于Field的逻辑,第一个类型检查转换完毕后,就不会继续检查和转换.所以uid会优先被转换为str,并不受min和max的影响.可以看到下面返回的uid的值是<code>“123”</code>,并不会受到max的限制</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">&gt;&gt;&gt; curl <span class="hljs-string">&quot;127.0.0.1:8000/api?uid=123&amp;user_name=appl&quot;</span><br>&#123;<span class="hljs-string">&quot;result&quot;</span>:&#123;<span class="hljs-string">&quot;uid&quot;</span>:<span class="hljs-string">&quot;123&quot;</span>,<span class="hljs-string">&quot;timestamp&quot;</span>:null,<span class="hljs-string">&quot;user_info&quot;</span>:null,<span class="hljs-string">&quot;user_name&quot;</span>:<span class="hljs-string">&quot;appl&quot;</span>&#125;&#125;<br></code></pre></td></tr></table></figure>



<h3 id="2-4-第四版-使用inspect"><a href="#2-4-第四版-使用inspect" class="headerlink" title="2.4 第四版,使用inspect"></a>2.4 第四版,使用inspect</h3><p><a href="https://github.com/so1n/example/blob/master/example_python/example_python/api_param_check/version4.py">第四版代码</a></p>
<p>在TypeHint出现后,inspect可以解析函数的参数以及参数对应的值,同时也能解析我们标注函数返回的类型,这样我们就可以做2个改造了:</p>
<ul>
<li>1.把model从装饰器传入改为从函数传入,从函数传入有多个优点:<ul>
<li>调用者简单明了,知道这就是他自己想要的参数</li>
<li>支持多个model,用户可以重复利用多个model.</li>
<li>支持param: type = value的形式(这里没实现,可以见项目<a href="https://github.com/so1n/pait">pait</a>)</li>
</ul>
</li>
<li>2.对返回类型进行标注,同时进行检查和抛错</li>
</ul>
<p>一般来说第一点比较重要,可能有人觉得第二点导致他无法返回其他状态码响应,解决办法是从装饰器转入状态码即可.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomModel</span>(<span class="hljs-params">Model</span>):</span><br>    <span class="hljs-comment"># 旧的Model</span><br>    uid: Union[<span class="hljs-built_in">str</span>, <span class="hljs-built_in">int</span>] = Field(<span class="hljs-built_in">min</span>=<span class="hljs-number">10</span>, <span class="hljs-built_in">max</span>=<span class="hljs-number">100</span>)<br>    timestamp: <span class="hljs-built_in">int</span> = Field(default=<span class="hljs-literal">None</span>)<br>    user_info: <span class="hljs-built_in">dict</span> = Field(default=<span class="hljs-literal">None</span>)<br>    user_name: <span class="hljs-built_in">str</span> = Field(max_length=<span class="hljs-number">4</span>)<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomOtherModel</span>(<span class="hljs-params">Model</span>):</span><br>    <span class="hljs-comment"># 新的Model</span><br>    age: <span class="hljs-built_in">int</span> = Field(<span class="hljs-built_in">min</span>=<span class="hljs-number">1</span>, <span class="hljs-built_in">max</span>=<span class="hljs-number">100</span>)<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">params_verify</span>():</span><br>    <span class="hljs-string">&quot;&quot;&quot;装饰器&quot;&quot;&quot;</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">wrapper</span>(<span class="hljs-params">func: Callable</span>):</span><br><span class="hljs-meta">        @wraps(<span class="hljs-params">func</span>)</span><br>        <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">request_param</span>(<span class="hljs-params">request: Request, *args, **kwargs</span>):</span><br>            <span class="hljs-comment"># 获取参数, 这里只做简单演示, 只获取url和json请求的数据</span><br>            param_dict: <span class="hljs-built_in">dict</span> = <span class="hljs-built_in">dict</span>(request.query_params)<br>            <span class="hljs-keyword">if</span> request.method == <span class="hljs-string">&quot;POST&quot;</span>:<br>                param_dict.update(<span class="hljs-keyword">await</span> request.json())<br>            <span class="hljs-comment"># 通过inspect解析参数</span><br>            sig: <span class="hljs-string">&#x27;inspect.Signature&#x27;</span> = inspect.signature(func)<br>            fun_param_dict: Dict[<span class="hljs-built_in">str</span>, inspect.Parameter] = &#123;<br>                key: sig.parameters[key]<br>                <span class="hljs-keyword">for</span> key <span class="hljs-keyword">in</span> sig.parameters<br>                <span class="hljs-keyword">if</span> sig.parameters[key].annotation != inspect._empty<br>            &#125;<br>            return_param: Type = sig.return_annotation<br>            <span class="hljs-keyword">try</span>:<br>                <span class="hljs-comment"># 对参数进行转换,并返回给函数</span><br>                func_args = []<br>                <span class="hljs-keyword">for</span> param <span class="hljs-keyword">in</span> fun_param_dict.values():<br>                    model: Model = param.annotation()<br>                    <span class="hljs-keyword">for</span> key, key_type <span class="hljs-keyword">in</span> model.field_dict.items():<br>                        value: Any = param_dict.get(key, MISS_OBJECT)<br>                        <span class="hljs-built_in">setattr</span>(model, key, (value, key_type))<br>                    func_args.append(model)<br>                <span class="hljs-comment"># 处理响应</span><br>                response = <span class="hljs-keyword">await</span> func(request, *func_args, **kwargs)<br>                <span class="hljs-comment"># 响应检查</span><br>                <span class="hljs-keyword">if</span> <span class="hljs-built_in">type</span>(response) != return_param:<br>                    <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">f&#x27;response type != <span class="hljs-subst">&#123;return_param&#125;</span>&#x27;</span>)<br>                <span class="hljs-keyword">if</span> <span class="hljs-built_in">dict</span> <span class="hljs-keyword">is</span> return_param:<br>                    <span class="hljs-keyword">return</span> JSONResponse(response)<br>                <span class="hljs-keyword">raise</span> TypeError(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;<span class="hljs-built_in">type</span>(response)&#125;</span> not support&#x27;</span>)<br>            <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>                <span class="hljs-comment"># 这里为了示范,把错误抛出来</span><br>                <span class="hljs-keyword">return</span> JSONResponse(&#123;<span class="hljs-string">&#x27;error&#x27;</span>: <span class="hljs-built_in">str</span>(e)&#125;)<br>        <span class="hljs-keyword">return</span> request_param<br>    <span class="hljs-keyword">return</span> wrapper<br><br><br><span class="hljs-comment"># 装饰器移除了参数, 改为从函数参数传入</span><br><span class="hljs-meta">@params_verify()</span><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">demo_get</span>(<span class="hljs-params">request, model: CustomModel, other_model: CustomOtherModel</span>) -&gt; dict:</span><br>    return_dict = model.to_dict()<br>    return_dict.update(other_model.to_dict())<br>    <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&#x27;result&#x27;</span>: return_dict&#125;<br></code></pre></td></tr></table></figure>

<p>修改完成后,进行测试,可以发现age被转为min=1的值.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">&gt;&gt;&gt;curl <span class="hljs-string">&quot;127.0.0.1:8000/api?uid=123&amp;user_name=appl&amp;age=-1&quot;</span><br>&#123;<span class="hljs-string">&quot;result&quot;</span>:&#123;<span class="hljs-string">&quot;uid&quot;</span>:<span class="hljs-string">&quot;123&quot;</span>,<span class="hljs-string">&quot;timestamp&quot;</span>:null,<span class="hljs-string">&quot;user_info&quot;</span>:null,<span class="hljs-string">&quot;user_name&quot;</span>:<span class="hljs-string">&quot;appl&quot;</span>,<span class="hljs-string">&quot;age&quot;</span>:1&#125;&#125;<br></code></pre></td></tr></table></figure>

<h3 id="2-5-第五版-使用Pydantic"><a href="#2-5-第五版-使用Pydantic" class="headerlink" title="2.5 第五版,使用Pydantic"></a>2.5 第五版,使用Pydantic</h3><p><a href="https://github.com/so1n/example/blob/master/example_python/example_python/api_param_check/version5.py">第五版代码</a></p>
<p>其实到了第四版,就开始投入使用,并运行很长的时间了,因为对类型嵌套没有比较大需求,所以也没打算有什么改进.</p>
<p>直到有一天看到fastapi同时又发现自己其实是有类型嵌套的需求, 所以就开始了解Pydantic并使用他(毕竟功能类似,功能还能更多,何乐而不为呢).</p>
<p>Pydantic功能非常多,远远大于上面的Model和Field, 支持多种校验, 支持Orm, 支持openapi schema生成等等,需要什么功能,从<a href="https://pydantic-docs.helpmanual.io/">文档</a>里查找就可以了.</p>
<p>由于之前实现Model的逻辑跟Pydantic的BaseModel逻辑很像, 所以基于第四版代码修改并使用Pydantic十分简单,只要把自己的Model,Field删除掉,并且引入Pydantic即可(如下),并在装饰器那里使用dict的方式传入并把调用model的to_dict改为dict即可</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> inspect<br><br><span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> wraps<br><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> Any, Dict, List, Type<br><br><span class="hljs-keyword">import</span> uvicorn<br><span class="hljs-keyword">from</span> starlette.applications <span class="hljs-keyword">import</span> Starlette<br><span class="hljs-keyword">from</span> starlette.requests <span class="hljs-keyword">import</span> Request<br><span class="hljs-keyword">from</span> starlette.responses <span class="hljs-keyword">import</span> JSONResponse<br><span class="hljs-keyword">from</span> starlette.routing <span class="hljs-keyword">import</span> Route<br><span class="hljs-keyword">from</span> pydantic <span class="hljs-keyword">import</span> (<br>    BaseModel,<br>    conint,<br>    constr,<br>)<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PydanticModel</span>(<span class="hljs-params">BaseModel</span>):</span><br>    <span class="hljs-comment"># 改为Pydantic的Model</span><br>    uid: conint(gt=<span class="hljs-number">10</span>, lt=<span class="hljs-number">1000</span>)<br>    user_name: constr(min_length=<span class="hljs-number">2</span>, max_length=<span class="hljs-number">4</span>)<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PydanticOtherModel</span>(<span class="hljs-params">BaseModel</span>):</span><br>    age: conint(gt=<span class="hljs-number">1</span>, lt=<span class="hljs-number">100</span>)<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">params_verify</span>():</span><br>    <span class="hljs-string">&quot;&quot;&quot;装饰器&quot;&quot;&quot;</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">wrapper</span>(<span class="hljs-params">func</span>):</span><br><span class="hljs-meta">        @wraps(<span class="hljs-params">func</span>)</span><br>        <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">request_param</span>(<span class="hljs-params">request: Request, *args, **kwargs</span>):</span><br>            <span class="hljs-comment"># 获取参数, 这里只做简单演示, 只获取url和json请求的数据</span><br>            param_dict: <span class="hljs-built_in">dict</span> = <span class="hljs-built_in">dict</span>(request.query_params)<br>            <span class="hljs-keyword">if</span> request.method == <span class="hljs-string">&quot;POST&quot;</span>:<br>                param_dict.update(<span class="hljs-keyword">await</span> request.json())<br><br>            sig: <span class="hljs-string">&#x27;inspect.Signature&#x27;</span> = inspect.signature(func)<br>            fun_param_dict: Dict[<span class="hljs-built_in">str</span>, inspect.Parameter] = &#123;<br>                key: sig.parameters[key]<br>                <span class="hljs-keyword">for</span> key <span class="hljs-keyword">in</span> sig.parameters<br>                <span class="hljs-keyword">if</span> sig.parameters[key].annotation != inspect._empty<br>            &#125;<br>            return_param: Any = sig.return_annotation<br>            <span class="hljs-keyword">try</span>:<br>                func_args: List[BaseModel] = []<br>                <span class="hljs-keyword">for</span> param <span class="hljs-keyword">in</span> fun_param_dict.values():<br>                    <span class="hljs-keyword">if</span> param.annotation <span class="hljs-keyword">is</span> Request:<br>                        <span class="hljs-keyword">continue</span><br>                    model: BaseModel = param.annotation(**param_dict)<br>                    func_args.append(model)<br>                <span class="hljs-comment"># 处理响应</span><br>                response: Any = <span class="hljs-keyword">await</span> func(request, *func_args, **kwargs)<br>                <span class="hljs-keyword">if</span> <span class="hljs-built_in">type</span>(response) != return_param:<br>                    <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">f&#x27;response type != <span class="hljs-subst">&#123;return_param&#125;</span>&#x27;</span>)<br>                <span class="hljs-keyword">if</span> <span class="hljs-built_in">dict</span> <span class="hljs-keyword">is</span> return_param:<br>                    <span class="hljs-keyword">return</span> JSONResponse(response)<br>                <span class="hljs-keyword">raise</span> TypeError(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;<span class="hljs-built_in">type</span>(response)&#125;</span> not support&#x27;</span>)<br>            <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>                <span class="hljs-comment"># 这里为了示范,把错误抛出来,这里改为e.json,错误信息会更详细的</span><br>                <span class="hljs-keyword">return</span> JSONResponse(&#123;<span class="hljs-string">&#x27;error&#x27;</span>: <span class="hljs-built_in">str</span>(e)&#125;)<br>        <span class="hljs-keyword">return</span> request_param<br>    <span class="hljs-keyword">return</span> wrapper<br><br><br><span class="hljs-meta">@params_verify()</span><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">demo_get</span>(<span class="hljs-params">request: Request, model: PydanticModel, other_model: PydanticOtherModel</span>) -&gt; dict:</span><br>    return_dict = model.<span class="hljs-built_in">dict</span>()<br>    return_dict.update(other_model.<span class="hljs-built_in">dict</span>())<br>    <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&#x27;result&#x27;</span>: return_dict&#125;<br><br><br>app = Starlette(<br>    routes=[<br>        Route(<span class="hljs-string">&#x27;/api&#x27;</span>, demo_get, methods=[<span class="hljs-string">&#x27;GET&#x27;</span>]),<br>    ]<br>)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    uvicorn.run(app)<br></code></pre></td></tr></table></figure>

<p>继续跑刚才的测试,由于逻辑有点不同,Pydantic不会进行自动转换,但是抛错信息挺详细的(改为e.json报错会更详细)…</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">&gt;&gt;&gt; curl <span class="hljs-string">&quot;127.0.0.1:8000/api?uid=123&amp;user_name=apple&amp;age=-1&quot;</span><br>&#123;<span class="hljs-string">&quot;error&quot;</span>:<span class="hljs-string">&quot;1 validation error for PydanticModel\nuser_name\n  ensure this value has at most 4 characters (type=value_error.any_str.max_length; limit_value=4)&quot;</span>&#125;<br>&gt;&gt;&gt; curl <span class="hljs-string">&quot;127.0.0.1:8000/api?uid=123&amp;user_name=appl&amp;age=2&quot;</span><br>&#123;<span class="hljs-string">&quot;result&quot;</span>:&#123;<span class="hljs-string">&quot;uid&quot;</span>:123,<span class="hljs-string">&quot;user_name&quot;</span>:<span class="hljs-string">&quot;appl&quot;</span>,<span class="hljs-string">&quot;age&quot;</span>:2&#125;&#125;<br></code></pre></td></tr></table></figure>

<p>到这里,对于接口层的类型校验基本功能的升级基本完成了,可以看到理解了原理后是非常简单的代码(在引入Pydantic后),但减少了很多重复的代码量,再稍微拓展,就可以支持更多的框架啦.</p>
<h3 id="2-6-更多功能"><a href="#2-6-更多功能" class="headerlink" title="2.6 更多功能"></a>2.6 更多功能</h3><p>这份代码很简单, 主要做了对接口的参数检查,转换等封装, 但是只获取了url的参数和json body参数, 在日常使用中我还更希望我能快速的获取到cookie和header的参数. 同时由于代码既文档的思想, 我还想让他能自动生成文档, 所以我再进行了升级改造, 使他能实现这些功能,详情查看我的开源项目<a href="https://github.com/so1n/pait">pait</a>, 他还支持cbv模式, 支持更好的错误报错, 更重要的是支持更多的框架.</p>
<h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3.总结"></a>3.总结</h2><p>在第一次编写接口的类型校验时, 带我的大佬说不提倡这样写, 特别是不要经常引入装饰器(此时处于python2与python3的转换期),觉得装饰器会让人误解,导致别人很难一下子看得懂逻辑, 在路由函数的doc写就可以了, 但是后面慢慢多了TypeHint, 也有Pydantic这样优秀的框架, 我觉得实现这个类型校验带来的收益(比如减少代码量等)远远大于他让人难以理解时,那我们就可以选择使用他.所以我就从实现后一直使用这个功能,并且逐渐的完善他,让他更好用,同时也让我对Python的TypeHint更加的深入理解和运用,现在写非小脚本的Python代码时也都在用TypeHint了,推荐大家都使用他.随着TypeHint的发展,在大项目中写Python会越来越顺手的, 也能让Python项目更工程化.</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title>iptables</title>
    <url>/2019/04/15/iptables/</url>
    <content><![CDATA[<p>iptables 是一个配置 Linux 内核 防火墙 的命令行工具，是 netfilter 项目的一部分。</p>
<span id="more"></span>

<h2 id="iptables知识点"><a href="#iptables知识点" class="headerlink" title="iptables知识点"></a>iptables知识点</h2><h3 id="查看iptables-规则"><a href="#查看iptables-规则" class="headerlink" title="查看iptables 规则"></a>查看iptables 规则</h3><h4 id="1、iptables-L"><a href="#1、iptables-L" class="headerlink" title="1、iptables -L"></a>1、iptables -L</h4><p>查看filter表的iptables规则，包括所有的链。filter表包含INPUT、OUTPUT、FORWARD三个规则链。</p>
<p>说明：-L是–list的简写，作用是列出规则。</p>
<h4 id="2、iptables-L-t-表名"><a href="#2、iptables-L-t-表名" class="headerlink" title="2、iptables -L [-t 表名]"></a>2、iptables -L [-t 表名]</h4><p>只查看某个表的中的规则。</p>
<p>说明：表名一个有三个：filter,nat,mangle，如果没有指定表名，则默认查看filter表的规则列表（就相当于第一条命令）。</p>
<p>举例：iptables -L -t filter</p>
<h4 id="3、iptables-L-t-表名-链名"><a href="#3、iptables-L-t-表名-链名" class="headerlink" title="3、iptables -L (-t 表名)(链名)"></a>3、iptables -L (-t 表名)(链名)</h4><p>这里多了个链名，就是规则链的名称。</p>
<p>说明：iptables一共有INPUT、OUTPUT、FORWARD、PREROUTING、POSTROUTING五个规则链。</p>
<p>举例：iptables -L INPUT</p>
<p>注意：链名必须大写。在Linux系统上，命令的大小写很敏感。</p>
<h4 id="4、iptables-n-L"><a href="#4、iptables-n-L" class="headerlink" title="4、iptables -n -L"></a>4、iptables -n -L</h4><p>说明：以数字形式显示规则。如果没有-n，规则中可能会出现anywhere，有了-n，它会变成0.0.0.0/0</p>
<h4 id="5、iptables-nv-L"><a href="#5、iptables-nv-L" class="headerlink" title="5、iptables -nv -L"></a>5、iptables -nv -L</h4><p>说明：这个列表看起来更详细.</p>
<h4 id="6、删除规则-D"><a href="#6、删除规则-D" class="headerlink" title="6、删除规则(-D)"></a>6、删除规则(-D)</h4><p>如果想删除iptables规则我们可以如下操作</p>
<p>如删除之前添加的规则（iptables -A INPUT -s 192.168.1.5 -j DROP）：</p>
<p>[root@test ~]# iptables -D INPUT -s 192.168.1.5 -j DROP</p>
<p>有时候要删除的规则太长，删除时要写一大串，既浪费时间又容易写错，这时我们可以先使用–line-number找出该条规则的行号，再通过行号删除规则。</p>
<p>[root@test ~]# iptables -nv –line-number</p>
<p>iptables v1.4.7: no command specified</p>
<p>Try `iptables -h’ or ‘iptables –help’ for more information.</p>
<p>[root@test ~]# iptables -nL –line-number</p>
<p>Chain INPUT (policy ACCEPT)</p>
<p>num target prot opt source destination</p>
<p>1 DROP all – 192.168.1.1 0.0.0.0/0</p>
<p>2 DROP all – 192.168.1.2 0.0.0.0/0</p>
<p>3 DROP all – 192.168.1.3 0.0.0.0/0</p>
<p>删除第二行规则</p>
<p>[root@test ~]# iptables -D INPUT 2</p>
<h3 id="添加iptables规则"><a href="#添加iptables规则" class="headerlink" title="添加iptables规则"></a>添加iptables规则</h3><p>首先,从网络上出现最多的例子开始说起.</p>
<p> # iptables -A INPUT -p tcp –dport 80 -m connlimit –connlimit-above 50 -j DROP</p>
<ul>
<li><p>-A</p>
<p>填写的参数是链,目前iptables中有preouting, input, output, forward,postrouting链.<a href="http://www.zsythink.net/archives/1199">详细参考</a></p>
</li>
<li><p>-p</p>
<p>填写的是Tcp/ip协议簇</p>
</li>
<li><p>-dport</p>
<p>填写连接到本机的端口</p>
</li>
<li><p>-m</p>
<p>使用iptables的模块,示例中使用了connlimit模块,并且使用了里面的connlimit-above 和connlimit- mask,其中connlimit-above是连接数统计,如果大于50就满足条件,而connlimit-mask是定义组机,此处的数值是网络为,即子网掩码,示例中的子网掩码为0则表示所有ip</p>
</li>
<li><p>-j</p>
<p>表示满足条件后执行的动作,以下为所有动作列表.</p>
<blockquote>
<p>ACCEPT #允许数据包通过</p>
</blockquote>
<p>DROP #丢弃数据包，不对该数据包进一步处理</p>
<p>REFECT #丢弃数据包，同时发送响应报文</p>
<p>–reject-with tcp-reset 返回tcp重置</p>
<p>–reject-with icmp-net-unreachable 返回网络不可达</p>
<p>–reject-with icmp-host-unreachable 返回主机不可达</p>
<p>RETURN #转到其它链处理</p>
<p>LOG #将数据包信息记录到syslog</p>
</li>
</ul>
<p>此外,还有:</p>
<ul>
<li><p>-s</p>
<p>指定源地址</p>
</li>
<li><p>-d</p>
<p>指定目标地址</p>
</li>
<li><p>-i</p>
<p>指定数据报文流入接口</p>
</li>
<li><p>-o</p>
<p>指定数据报文流出接口</p>
</li>
</ul>
<h3 id="iptables的日志"><a href="#iptables的日志" class="headerlink" title="iptables的日志"></a>iptables的日志</h3><p>将上面的例子改为</p>
<p># iptables -A INPUT -p tcp –dport 80 -m connlimit –connlimit-above 50 -j LOG –log-prefix ‘IptableslOG:’ –log-ip-options</p>
<p>iptables会对满足条件的连接打印出log而不是drop掉,其中 –log-profix是可以让用户自定义的log前缀, 合理的log-profix能让自己更快速的找到日志(使用grep),</p>
<p>–log-ip-options则是记录包中的ip header</p>
<p>除此之外,log还支持其他参数.</p>
<ul>
<li><p>–log-tcp-sequence</p>
<p>记录保中的TCP序列号</p>
</li>
<li><p>–log-tcp-options</p>
<p>记录保重的TCP header</p>
</li>
<li><p>–log-uid</p>
<p>记录生成数据包的进程的用户标识。</p>
</li>
<li><p>–log-level</p>
<p>生成的日志等级, 等级对应说明如下:</p>
</li>
<li><p>0 (KERN_EMERG) 系统无法使用</p>
<ul>
<li><p>1 (KERN_ALERT) 必须立即处理</p>
</li>
<li><p>2 (KERN_CRIT) 关建事件</p>
</li>
<li><p>3 (KERN_ERR) 非关键事件错误</p>
</li>
<li><p>4 (KERN_WARNING) 应该注意的警告事件</p>
</li>
<li><p>5 (KERN_NOTICE) 正常但比较重要的事件</p>
</li>
<li><p>6 (KERN_INFO) info事件</p>
</li>
<li><p>7 (KERN_DEBUG) 内核调试消息</p>
</li>
</ul>
</li>
</ul>
<p>之后满足条件iptables就可能产生一段如下一段日志(来源于网上)</p>
<p>Jun 19 17：20:04 webkernel： NEW DRAP IN=eth0 OUT=MAC=00:10:4b:cd:7b:b4:00:e0:le:b9:04：al:08:00SRC=192.168.150.1 DST=192.168.150.152 LEN=20 TOS=0X00 PREC=0x00 TTL=249ID=10492 DF PROTO=UDP SPT=53 DPT=32926 LEN=231</p>
<p>| <strong>序号</strong> | <strong>字段名称</strong> | <strong>含义</strong> |</p>
<p>| ——– | ———————————————————— | ———————————————————— |</p>
<p>| 1 | Jun 19 17:20:24 | 日期时间，由syslog生成 |</p>
<p>| 2 | Web | 主机名称 |</p>
<p>| 3 | Kernel | 进程名由syslogd生成kernel为内核产生的日志说明netfilter在内核中运行 |</p>
<p>| 4 | NEW_DRAP | 记录前缀，由用户指定—log-prefix”NEW_DRAP” |</p>
<p>| 5 | IN=eth0 | 数据包进入的接口，若为空表示本机产生，接口还有eth0、br0等 |</p>
<p>| 6 | OUT= | 数据包离开的接口，若为空表示本机接收 |</p>
<p>| 7 | MAC=00:10:4b:cd:7b:b4:00:e0:le:b9:04:al | 00:10:4b:cd:7b:b4 为目标MAC地址00:e0:le:b9:04:al 为源MAC地址 |</p>
<p>| 8 | 08:00 | 08:00 为上层协议代码，即表示IP协议 |</p>
<p>| 9 | SRC=192.168.150.1 | 192.168.150.1为源IP地址 |</p>
<p>| 10 | DST=192.168.150.152 | 192.168.150.152w为目标IP地址 |</p>
<p>| 11 | LEN=20 | IP封包+承载数据的总长度(MTU) |</p>
<p>| 12 | TOS=0x00 | IP包头内的服务类型字段，能反应服务质量包括延迟、可靠性和拥塞等 |</p>
<p>| 13 | PREC=0x00 | 服务类型的优先级字段 |</p>
<p>| 14 | TTL=249 | IP数据包的生存时间 |</p>
<p>| 15 | ID=10492 | IP数据包标示 |</p>
<p>| 16 | DF | DF表示不分段,此字段还可能为MF/FRAG |</p>
<p>| 17 | PROTO=UDP | 传输层协议类型，它代表上层协议是什么可分为TCP、UDP、ICMP等 |</p>
<p>| 18 | SPT=53 | 表示源端口号 |</p>
<p>| 19 | DPT=32926 | 表示目的端口号 |</p>
<p>| 20 | LEN=231 | 传输层协议头长度 |</p>
<p>| 21 | SEQ= 内容略 | TCP序列号 |</p>
<p>| 22 | ACK=内容略 | TCP应答号 |</p>
<p>| 23 | WINDOWS=内容略 | IP包头内的窗口大小 |</p>
<p>| 24 | RES | TCP-Flags中ECN bits的值 |</p>
<p>| 25 | CWR/ECE/URG/ACK/PSH/RST/SYN/FIN | TCP标志位 |</p>
<p>| 26 | URGP= | 紧急指针起点 |</p>
<p>| 27 | OPT( 内容略 ) | IP或TCP选项，括号内为十六进制 |</p>
<p>| 28 | INCOMPLETE[65535 bytes] | 不完整的数据包 |</p>
<p>| 29 | TYPE=CODE=ID=SEQ=PARAMETER= | 当协议为ICMP时出现 |</p>
<p>| 30 | SPI=0xF1234567 | 当前协议为AHESP时出现 |</p>
<p>| 31 | SYN | TCP-Flags中的SYN标志,此外还有FIN/ACK/RST/URG/PSH几种 |</p>
<p>| 32 | [ ] | 中括号出现在两个地方，在ICMP协议中作为协议头的递归使用；在数据包长度出现非法时用于指出数据实际长度 |</p>
<h4 id="让日志变得清晰"><a href="#让日志变得清晰" class="headerlink" title="让日志变得清晰"></a>让日志变得清晰</h4><p>目前iptables产生的日志会到了系统的日志里面,利用rsyslog则可以把日志分发到其他地方.(需要系统是使用rsyslog)</p>
<ol>
<li><p>在rsyslog.conf 添加配置</p>
<p>/etc/rsyslog.conf中添加不同的日志级别（默认warn(=4））</p>
</li>
</ol>
<p>kern.warning /var/log/iptables.log</p>
<p>kern.debug /var/log/iptables.log</p>
<p>kern.info /var/log/iptables.log</p>
<p>如果全部都加入系统日志的话使用(推荐)： kern.* /var/log/iptables.log</p>
<p>重启日志配置： /etc/init.d/rsyslogd restart</p>
<ol start="2">
<li><p>让日志rotate(滚动)</p>
<p>vim /etc/logrotate.d/syslog</p>
<p>加入/var/log/iptables</p>
</li>
</ol>
<p>这样配置完就有iptables对应的log文件啦</p>
<h3 id="一些使用例子与说明"><a href="#一些使用例子与说明" class="headerlink" title="一些使用例子与说明"></a>一些使用例子与说明</h3><ul>
<li>清空当前的所有规则和计数</li>
</ul>
<figure class="highlight nginx"><table><tr><td class="code"><pre><code class="hljs nginx"><br><span class="hljs-attribute">iptables</span> -F <span class="hljs-comment"># 清空所有防火墙规则</span><br><br>iptables -X <span class="hljs-comment"># 删除用户自定义的空链</span><br><br>iptables -Z <span class="hljs-comment"># 清空计数</span><br><br></code></pre></td></tr></table></figure>

<ul>
<li>允许ssh端口连接</li>
</ul>
<p>如下例子,22端口是ssh的端口, 192.168.1.0/24表示该网段的所有ip(使用了CIDR,也就是192.168.0.1~192.168.0.254)</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><br><span class="hljs-attribute">iptables</span> -A INPUT -s <span class="hljs-number">192.168.1.0</span>/<span class="hljs-number">24</span> -p tcp --dport -j ACCEPT<br><br></code></pre></td></tr></table></figure>

<ul>
<li>允许本地回环地址可以正常使用</li>
</ul>
<figure class="highlight dns"><table><tr><td class="code"><pre><code class="hljs dns"><br>iptables -<span class="hljs-keyword">A</span> INPUT -i lo -j ACCEPT #本地圆环地址就是那个<span class="hljs-number">127.0.0.1</span>，是本机上使用的,它进与出都设置为允许<br><br>iptables -<span class="hljs-keyword">A</span> OUTPUT -o lo -j ACCEPT<br><br></code></pre></td></tr></table></figure>

<ul>
<li>每秒中最多允许5个新连接</li>
</ul>
<figure class="highlight brainfuck"><table><tr><td class="code"><pre><code class="hljs brainfuck"><br><span class="hljs-comment">iptables</span> <span class="hljs-literal">-</span><span class="hljs-comment">A</span> <span class="hljs-comment">FORWARD</span> <span class="hljs-literal">-</span><span class="hljs-comment">p</span> <span class="hljs-comment">tcp</span> --<span class="hljs-comment">syn</span> <span class="hljs-literal">-</span><span class="hljs-comment">m</span> <span class="hljs-comment">limit</span> --<span class="hljs-comment">limit</span> <span class="hljs-comment">1/s</span> --<span class="hljs-comment">limit</span><span class="hljs-literal">-</span><span class="hljs-comment">burst</span> <span class="hljs-comment">5</span> <span class="hljs-literal">-</span><span class="hljs-comment">j</span> <span class="hljs-comment">ACCEPT</span> <br><br></code></pre></td></tr></table></figure>

<ul>
<li>防止各种端口扫描</li>
</ul>
<figure class="highlight jboss-cli"><table><tr><td class="code"><pre><code class="hljs jboss-cli"><br>iptables -A FORWARD -p tcp <span class="hljs-params">--tcp-flags</span> SYN,ACK,FIN,RST RST -m limit <span class="hljs-params">--limit</span> 1/s -j ACCEPT <br><br></code></pre></td></tr></table></figure>

<ul>
<li>防止ping洪水攻击</li>
</ul>
<figure class="highlight llvm"><table><tr><td class="code"><pre><code class="hljs llvm"><br>iptables -A FORWARD -p <span class="hljs-keyword">icmp</span> --<span class="hljs-keyword">icmp</span>-<span class="hljs-keyword">type</span> echo-request -m limit --limit <span class="hljs-number">1</span>/s -j ACCEPT <br><br></code></pre></td></tr></table></figure>

<ul>
<li>关闭别人对服务器的ping</li>
</ul>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"><br>iptables -A <span class="hljs-keyword">INPUT</span> -p icmp -j <span class="hljs-keyword">DROP</span> <br><br></code></pre></td></tr></table></figure>

<ul>
<li>防止同步包洪水（Sync Flood） </li>
</ul>
<figure class="highlight jboss-cli"><table><tr><td class="code"><pre><code class="hljs jboss-cli"><br>iptables -A FORWARD -p tcp <span class="hljs-params">--syn</span> -m limit <span class="hljs-params">--limit</span> 1/s -j ACCEPT <br><br></code></pre></td></tr></table></figure>

<ul>
<li>利用recent模块 限制60秒内只有10个新链接</li>
</ul>
<p>例子中的–SYN TCP是由于syn的tcp中建立连接时的第一个包,通过–syn可以限定TCP 连接</p>
<p>而使用了 state new则无需再使用 –SYN,因为state new包括TCP UDP IMCP<a href="https://serverfault.com/questions/338553/iptables-new-connections-vs-syn">参考链接</a></p>
<figure class="highlight jboss-cli"><table><tr><td class="code"><pre><code class="hljs jboss-cli"><br>iptables -A INPUT -p tcp <span class="hljs-params">--dport</span> 80 <span class="hljs-params">--syn</span> -m recent <span class="hljs-params">--name</span> webpool <span class="hljs-params">--rcheck</span> <span class="hljs-params">--seconds</span> 60 <span class="hljs-params">--hitcount</span> 10 -j DROP<br><br></code></pre></td></tr></table></figure>



<p>iptables可以通过模块来执行许多灵活的功能,如:</p>
<ul>
<li><p>-m state –state</p>
<p>NEW,ESTABLISHED,RELATED 表示用state模块来匹配当前连接状态为这三种状态的连接</p>
</li>
<li><p>-m iprange</p>
</li>
<li><p>-src-range 用iprange模块匹配来源的ip地址范围</p>
</li>
<li><p>-dst-range 用iprange模块匹配目的的ip地址范围</p>
</li>
<li><p>-m multiport</p>
</li>
<li><p>-source-ports 用multiport模块来匹配来源的端口范围</p>
</li>
<li><p>-destination-ports 用multiport模块来匹配目的的端口范围</p>
</li>
</ul>
<h3 id="在配置文件中配置"><a href="#在配置文件中配置" class="headerlink" title="在配置文件中配置"></a>在配置文件中配置</h3><p>使用命令配置时,配置的信息是存在于内存中的,重启iptables或重启计算机后就没有了,配置在配置文件能让iptables启动后能重新把配置加载到内存.</p>
<p>使用vim /etc/sysconfig/iptables打开配置文件</p>
<p>加上对应的命令即可(前面不需要iptables)了</p>
<p>最后执行命令:# /etc/init.d/iptables restar重启iptables</p>
<p>以下是来源于网络上的配置文件(越容易被执行的条件越应该房前面)</p>
<blockquote>
<p># Generated by iptables-save v1.4.7 on Wed Sep 28 18:06:07 2016</p>
</blockquote>
<p> *filter</p>
<p> :INPUT DROP [8:632]  </p>
<p> :FORWARD DROP [0:0]</p>
<p> :OUTPUT ACCEPT [4:416]</p>
<p> -A INPUT -s 192.168.1.0/24 -p tcp -m tcp –dport 22 -j ACCEPT </p>
<p> -A INPUT -i lo -j ACCEPT </p>
<p> -A INPUT -s 192.168.1.0/24 -j ACCEPT </p>
<p> -A INPUT -s 192.168.140.0/24 -j ACCEPT </p>
<p> -A INPUT -s 183.121.3.7/32 -p tcp -m tcp –dport 3380 -j ACCEPT </p>
<p> -A INPUT -p tcp -m tcp –dport 80 -j ACCEPT </p>
<p> -A INPUT -p icmp -m icmp –icmp-type 8 -j ACCEPT </p>
<p> -A INPUT -m state –state RELATED,ESTABLISHED -j ACCEPT </p>
<p> -A OUTPUT -o lo -j ACCEPT </p>
<p> COMMIT</p>
<p> # Completed on Wed Sep 28 18:06:07 2016</p>
<p>前4行说明</p>
<blockquote>
<p>*filter #代表接下来的配置都是在filter表上的。我们默认的配置都在filter表上的，当然还有其它表，如raw,mangle,nat</p>
</blockquote>
<p>:INPUT DROP [8:632] #代表filter表上默认的input chain为drop ，对应上面的命令iptables -P INPUT DROP，中括号里面的两个数字代表的是这条链上已经接受到的包的数量及字节数量[包的数量:包的总字节数]</p>
<p>:FORWARD DROP [0:0] #代表filter表上默认的forward chain为drop ，对应上面的命令iptables -P FORWARD DROP，中括号里面的两个数字代表的是这条链上已经接受到的包的数量及字节数量[包的数量:包的总字节数]</p>
<p>:OUTPUT ACCEPT [4:416] #代表filter表上默认的forward chain为drop ，对应上面的命令iptables -P OUTPUT ACCEPT，中括号里面的两个数字代表的是这条链上已经接受到的包的数量及字节数量[包的数量:包的总字节数]</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Iptables</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>记一次TCP长连接过多的问题--实际上是被攻击了</title>
    <url>/2019/04/06/%E8%AE%B0%E4%B8%80%E6%AC%A1TCP%E9%95%BF%E8%BF%9E%E6%8E%A5%E8%BF%87%E9%95%BF%E7%9A%84%E9%97%AE%E9%A2%98---%E5%AE%9E%E9%99%85%E4%B8%8A%E6%98%AF%E8%A2%AB%E6%94%BB%E5%87%BB%E4%BA%86/</url>
    <content><![CDATA[<h2 id="前记"><a href="#前记" class="headerlink" title="前记"></a>前记</h2><p>在接手了公司的SIP项目后的不久，发现服务器时不时就遇到了kamailio进程(用于处理sip协议)占用了过多的文件描述符,直接超过限制的情况，造成kamailio进程无法接收新的请求,影响线上用户使用。</p>
<p>这个问题有个两个难点,一个是只有发生问题才能进行排查,而发生问题时需要快速重启进程,不然影响用户使用;另一个问题由于发生时间充满随机性，而且时隔半个月到一个月才发生一次，所以整个解决流程用了快3个月，其中共发生了4次。</p>
<p>不过从发现问题到解决问题倒是收获了很多,只是到了后来才发现造成该问题的根本原因是客户端由于觉得接口加密逻辑有bug就跟API接口的商量一起下线加密逻辑,而我又不知道,加密逻辑下线后导致sip服务器的ip被暴露出来,引发SIP服务器被攻击…</p>
<span id="more"></span>
<h2 id="1-SIP连接的特性"><a href="#1-SIP连接的特性" class="headerlink" title="1.SIP连接的特性"></a>1.SIP连接的特性</h2><p>SIP服务器不像http服务器一样一个请求一个链接,而是用户在使用时就是一条长链接,并且一直存活着.一开始客户端的设计时只有客户端打开期间才有长链接，之后客户端改为后台常驻长链接也能存活，变成了用户只要不强制杀死客户端，服务器就会为之保留一个长链接。服务器的长链接数量发生了6倍的提升.</p>
<h2 id="2-更改文件描述符限制"><a href="#2-更改文件描述符限制" class="headerlink" title="2.更改文件描述符限制"></a>2.更改文件描述符限制</h2><p>由于链接量的提升,导致了服务器更容易触发文件描述符过多的问题,由于刚接触对kamailio以及Linux不熟悉，在整理了一些资料后,就去咨询大佬，询问是不是由于服务器被攻击导致的，大佬说可能性不大，主要是用户链接数量增长了，而Linux限制的文件描述符造成了该问题的发生，在查阅资料后发现Linux的文件描述符限制在1024，修改即可。</p>
<h3 id="2-1更改默认文件描述符限制值"><a href="#2-1更改默认文件描述符限制值" class="headerlink" title="2.1更改默认文件描述符限制值"></a>2.1更改默认文件描述符限制值</h3><p>更改文件描述符这个比较简单，通常可以通过ulimit -n查看默认限制值，以下是修改命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">vi /etc/security/limits.conf<br><span class="hljs-comment"># 追加内容</span><br>* soft nofile 10240<br>* hard nofile 10240<br><br>vi /etc/sysctl.conf<br><span class="hljs-comment"># 追加内容</span><br>fs.file-max=1024<br><span class="hljs-comment"># 应用配置</span><br>sysctl -p<br></code></pre></td></tr></table></figure>
<p>一般来说完成上述命令就可以了，然而kamailio运行在自己的用户组下, 同时是被Systemd托管的(守护)，还需要改Systemd的默认配 /etc/systemd/system.conf 的 DefaultLimitNOFILE 和 DefaultLimitNPROC的值才能更改成功。</p>
<h2 id="3-iptables限制和TCP调优双管齐下"><a href="#3-iptables限制和TCP调优双管齐下" class="headerlink" title="3.iptables限制和TCP调优双管齐下"></a>3.iptables限制和TCP调优双管齐下</h2><p>改进了文件描述符后问题并没有解决（只是解决了客户端启用常驻功能后用户连接数量的限制），通过使用Tcpdump捉包分析后发现,根本原因还是由于一些恶意请求，造成了服务器启用了大量的半开链接（TCP握手后就不再发送请求），而这些恶意请求根本还没到kamailio层，光查看kamailio数据和日志是看不出问题的原因。之后通过iptables限制请求和TCP调优(主要是尽早关闭半开链接)可以从跟本上解决该问题.</p>
<p>注:这个问题解决时间比较长的原因是 发生异常的情况间隔比较久,需要等到异常才能捉取数据,同时跟大佬还猜测可能由于客户端异常造成的原因.</p>
<h3 id="3-1误打误撞的找到问题"><a href="#3-1误打误撞的找到问题" class="headerlink" title="3.1误打误撞的找到问题"></a>3.1误打误撞的找到问题</h3><p>由于之前要写个定时程序来检测SIP服务器接口的可用性，本着能不造轮子就不造轮子的原则查了很多开源库，但查遍了python的开源库,要不就实现太完美了，接听电话都实现了也引用了很多其他的东西，要不就是要引用Twisted和zope,觉得这两个库太重了,要是出现问题再排查的话就很麻烦了。所以最后自己手撸了一个简单的SIP协议和利用sockets发送报文来模拟ping，检测SIP服务器接口的可用性。</p>
<p>然后很碰巧，在上线这个程序后不久，SIP服务器就会发生这个问题，凭着一直认为自己很渣，写的程序有问题的态度后，开始排查这个程序是不是有忘记关闭socket等问题，然后在进行第一步输入ss -a查看所有socket时（见下图有个185.104..。。），发现有个ip在这个输出列表里出现了很多次，通过命令:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 如果是线上运行,该用ss命令性能更高</span><br>netstat -nat|grep ESTABLISHED|awk <span class="hljs-string">&#x27;&#123;split($5,ip_port,&quot;:&quot;);print ip_port[1]&#125;&#x27;</span> | sort | uniq -c | sort -rn<br></code></pre></td></tr></table></figure>
<p><img    class="lazyload" data-original="https://raw.githubusercontent.com/so1n/so1n_blog_photo/blob/master/blog_photo/ip%E5%8D%A0%E7%94%A8%E7%AB%AF%E5%8F%A3.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">ip占用端口</span><br>发现该ip已经占用了684个链接了，而且之后利用tcpdump捉包发现该ip发的都是空包，并且在发送一段时间后自动转为半开链接,到此该问题的症状已经找到了—该ip发送大量的非法请求,导致占用了kamailio进程的可用文件描述符数量,导致kamailio进程无法再去处理正常链接而无法响应服务为止. </p>
<p>到了找出问题时，监控服务器也上线了，对每台服务器的文件描述符都进行了监控，通过监控数据可以看到，都是数据量突然上升，两小时后才下降(这个两小时也是一个重点，后来TCP调优后再看此图时才发现，linux默认在创建链接的两小时后tcp发送keep_alive发现对方没回包，服务器主动关闭了该sockets)</p>
<p><img    class="lazyload" data-original="https://raw.githubusercontent.com/so1n/so1n_blog_photo/master/blog_photo/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">img</span></p>
<h3 id="2-2使用iptables限制请求"><a href="#2-2使用iptables限制请求" class="headerlink" title="2.2使用iptables限制请求"></a>2.2使用iptables限制请求</h3><p>找出问题后解决起来就容易多了，由于是短时间内有大量相同ip的请求，那只要不再响应或接受这部分请求就可以了，而iptables的recent模块就是实现这一功能的。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># iptables配置</span><br><span class="hljs-comment"># 触发条件就记录日志(确保没问题时可以去掉记录日志)</span><br>-A INPUT -p tcp -m tcp --dport 5061 --tcp-flags FIN,SYN,RST,ACK SYN -m recent --rcheck --seconds 600 --hitcount 128 --name 5061webpool --mask 255.255.255.255 --rsource -j LOG --log-prefix <span class="hljs-string">&quot;Iptable-p5061-recent:&quot;</span> --log-ip-options<br><span class="hljs-comment"># 触发条件就把该连接drop掉</span><br>-A INPUT -p tcp -m tcp --dport 5061 --tcp-flags FIN,SYN,RST,ACK SYN -m recent --rcheck --seconds 600 --hitcount 128 --name 5061webpool --mask 255.255.255.255 --rsource -j DROP<br><span class="hljs-comment"># 把ip加入对应的set，以及记录连接次数，以便上面可以判断是否触发条件</span><br>-A INPUT -p tcp -m tcp --dport 5061 --tcp-flags FIN,SYN,RST,ACK SYN -m recent --name 5061webpool --<span class="hljs-built_in">set</span> -j ACCEPT<br></code></pre></td></tr></table></figure>

<p>通过iptables的recent模块的配置，目前可以防止请求，但是recent模块默认只记录100条记录，需要通过修改配置文件才可以去修改限制，而此时部分服务器长链接是数量基本都在2000,3000以上,后面预计长链接数可能会达到10000以上,靠这种方式效率还是太低了,而且占用了太多机器内存。</p>
<p><strong>注:</strong><br><strong>如何修改记录条数限制见：<a href="https://linux.die.net/man/8/iptables">https://linux.die.net/man/8/iptables</a>的recent模块部分。</strong><br><strong>每个系统的iptables配置都不太一样，这里就不贴出来了<a href="https://wiki.debian.org/iptables">debian见这里</a></strong></p>
<h3 id="2-3动态限制请求"><a href="#2-3动态限制请求" class="headerlink" title="2.3动态限制请求"></a>2.3动态限制请求</h3><p>为了解决上面使用iptables recent方案的问题，重新梳理了一下问题。发现该问题的触发时间是随机的，而且触发间隔非常久,如果能得知服务器开始被攻击就马上限制请求,而不要实时运行,那效果就会非常不错了.</p>
<p>通过上面的命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">netstat -nat|grep ESTABLISHED|awk <span class="hljs-string">&#x27;&#123;split($5,ip_port,&quot;:&quot;);print ip_port[1]&#125;&#x27;</span> | sort | uniq -c | sort -rn<br></code></pre></td></tr></table></figure>
<p>可以得知目前系统同一ip请求最多的是连接数据库的请求（因为那个ip是数据库ip）,而且从来不会超过43(kamailio配置最多就43个子进程)，而恶意请求通常的ip都是从0开始的，而且是以200个请求/半分钟的频率增长，那我只要通过脚本定时运行判断哪个ip是数量多过，然后就加入iptables的限制，当数量少时把他移除就可以了。但是，每有一个ip就往iptables加入一条规则，如果规则多了，那每个包都要遍历一遍规则去判断，O(n)的时间复杂度太影响性能了，所以引用到了ipset模块，把复杂度从O(n)变为O(1)，同时由于ipset带有timeout的功能，移除规则的工作也可以去掉了，方便了许多。</p>
<p>脚本示例代码如下(如果要提高性能,可以把netstat改为ss)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><span class="hljs-comment"># ipset name</span><br>ipset_name=<span class="hljs-string">&#x27;ip_conn_limit_ipset&#x27;</span><br>conn_limit=60<br><span class="hljs-comment"># remove ip from ipset after 270(5min - 30s) seconds</span><br>timeout=270<br><span class="hljs-comment"># The number of TCP connections in which an ip is in the ESTABLISHED state. e.g(cnt,ip): 10 1.1.1.1</span><br>ip_conn=`netstat -nat | grep ESTABLISHED | awk <span class="hljs-string">&#x27;&#123;split($5,ip_port,&quot;:&quot;);print ip_port[1]&#125;&#x27;</span> | sort | uniq -c | sort -rn`<br><span class="hljs-comment"># 让for循环以换行分割，而不是默认的按空格分割</span><br><br>SAVEIFS=<span class="hljs-variable">$IFS</span><br>IFS=$(<span class="hljs-built_in">echo</span> -en <span class="hljs-string">&quot;\n\b&quot;</span>)<br><span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> <span class="hljs-variable">$ip_conn</span><br><span class="hljs-keyword">do</span><br>    cnt=`<span class="hljs-built_in">echo</span> <span class="hljs-variable">$line</span> | awk <span class="hljs-string">&#x27;&#123;print $1&#125;&#x27;</span>`<br>    ip=`<span class="hljs-built_in">echo</span> <span class="hljs-variable">$line</span> | awk <span class="hljs-string">&#x27;&#123;print $2&#125;&#x27;</span>`<br>    <span class="hljs-keyword">if</span> [ <span class="hljs-variable">$cnt</span> -lt <span class="hljs-variable">$conn_limit</span> ];<span class="hljs-keyword">then</span><br>        <span class="hljs-built_in">break</span><br>    <span class="hljs-keyword">fi</span><br>    <span class="hljs-comment"># echo cnt=$cnt ip=$ip</span><br>    /sbin/ipset -! add <span class="hljs-variable">$ipset_name</span> <span class="hljs-variable">$ip</span> timeout <span class="hljs-variable">$timeout</span> comment <span class="hljs-string">&quot;Conn Cnt: <span class="hljs-variable">$cnt</span> is greater than limit:<span class="hljs-variable">$conn_limit</span>&quot;</span><br><span class="hljs-keyword">done</span><br>IFS=<span class="hljs-variable">$SAVEIFS</span><br></code></pre></td></tr></table></figure>

<p>创建ipset和iptables规则如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 创建一个名为ip_conn_limit_ipset的ipset, 以ip为key 最大65536，默认timeout时间为300，可以使用comment功能(打日志可以分辨是哪个ip)</span><br><br>ipset create ip_conn_limit_ipset <span class="hljs-built_in">hash</span>:ip family inet hashsize 1024 maxelem 65536 timeout 300 comment<br><br><span class="hljs-comment"># 把iptables的规则改为如下规则</span><br>-A INPUT -m <span class="hljs-built_in">set</span> --match-set ip_conn_limit_ipset src -p tcp -j LOG --log-prefix <span class="hljs-string">&quot;ip-conn-limit-ipset:&quot;</span> --log-ip-options<br>-A INPUT -m <span class="hljs-built_in">set</span> --match-set ip_conn_limit_ipset src -p tcp -j DROP<br></code></pre></td></tr></table></figure>
<p>之后利用crontab 定时运行脚本即可,由于需要频繁读取日志,所以定时的间隔也需要考虑在内,不过后面通过日志解耦系统逻辑,所以也不用再跑脚本了,详情可以看我另一篇文章</p>
<h2 id="3-TCP调优"><a href="#3-TCP调优" class="headerlink" title="3.TCP调优"></a>3.TCP调优</h2><p>通过这个问题,也发现了服务器启用了长链接，有很多问题需要处理的，不然会加重服务器的负担，影响性能，如果客户端那边因为网络问题而掉线，但是并没有关闭链接，而此时服务器还是维持链接的打开，直到keep_alive机制在两小时后启动，并判断客户端没有在使用时才断开链接（部分来自于网络).至于为什么是两小时以及不怎么建议随便修改,那可以重新看一看TCP协议卷1.</p>
<ul>
<li><p>1.尽早关闭半开放链接</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 探测包间隔</span><br>net.ipv4.tcp_keepalive_intvl = 75<br><span class="hljs-comment"># 探测失败次数</span><br>net.ipv4.tcp_keepalive_probes = 3<br><span class="hljs-comment"># 建立链接后的多长时间开始发送探测包</span><br>net.ipv4.tcp_keepalive_time = 1200<br></code></pre></td></tr></table></figure>
</li>
<li><p>2.尽早关闭关闭失败的链接链接。<br>由于手机网络不是很稳定，会经常出现网络闪断的情况，当server端发现client端很久没有心跳，那我就得将该链接回收。由于Client端已经不可达，那server端链接会处在FIN-WAIT-1。这个时候该tcp链接已经是一个孤儿链接，也就是说它已经不属于任何一个进程。在不可达的情况下，它会默认发送9次，重试8次。由于该状态是非常占用资源的最大可占用64KB。所以我们得尽快让这个链接从FIN-WAIT-1中解放出来：</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">net.ipv4.tcp_orphan_retries=1<br></code></pre></td></tr></table></figure>
<ul>
<li>3.快速释放FIN-WAIT-2，虽然该状态没有FIN-WAIT-1那么耗资源。<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">net.ipv4.tcp_fin_timeout=30<br></code></pre></td></tr></table></figure></li>
<li>4.开启TCP syncookies，防止DDOS攻击<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">net.ipv4.tcp_syncookies = 1<br></code></pre></td></tr></table></figure></li>
<li>5.syn报文（每个报文都需要排队）队列长度，超过该长度，请求就被丢弃，内存大于128M的默认为1024<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">net.ipv4.tcp_max_syn_backlog = 65536<br></code></pre></td></tr></table></figure></li>
<li>6.每个网络接口接收数据包的速率比内核处理这些包的速率快时，允许送到队列的数据包的最大数目<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">net.core.netdev_max_backlog = 32768<br></code></pre></td></tr></table></figure></li>
<li>7.定义了系统中每一个端口最大的监听队列的长度,这是个全局的参数<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">net.core.somaxconn = 32768  <br></code></pre></td></tr></table></figure></li>
<li>8.是否启用时间戳选项，该选项会影响net.ipv4.tcp_tw_reuse，默认开启<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">net.ipv4.tcp_timestamps = 1<br></code></pre></td></tr></table></figure></li>
<li>9.是否快速回收处于TIME_WAIT状态下的socket，由于手机网络时间戳会出现乱跳，所以必须关闭，这个默认关闭。<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">net.ipv4.tcp_tw_recycle = 0<br></code></pre></td></tr></table></figure></li>
<li>10.被动接受tcp链接时，第二次握手发送SYNACKs的次数，默认为5，对应的时间大概为180秒，官方说法。<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">net.ipv4.tcp_synack_retries = 3<br></code></pre></td></tr></table></figure></li>
<li>11.跟上面刚好相反，是主动发起tcp链接，发送SYNs的次数，默认为5，对应的时间大概为180秒，官方时间。<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">net.ipv4.tcp_syn_retries = 3<br></code></pre></td></tr></table></figure></li>
<li>12.我们关闭了TIME_WAIT快速回收，我们通过tcp_tw_reuse和tcp_max_tw_buckets来控制TIME_WAIT避免吃光机器，该值默认180000.<br>如果服务器是作为客户端存在的，因为客户端连接受本地端口数限制，所以最好通过tcp_max_tw_buckets控制一下；如果服务器是作为服务端存在的，那么没有端口数的限制，只要情况允许，最好把tcp_max_tw_buckets设置大一些。纯粹就是防御dos攻击的，最好别认为降低该值。<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">net.ipv4.tcp_max_tw_buckets=180000<br></code></pre></td></tr></table></figure></li>
<li>13.开启处于TIME_WAIT态的socket重用，默认关闭。这个重用的是TIME_WAIT的端口，不是内存等，这个对客户端有意义。<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">net.ipv4.tcp_tw_reuse=1<br></code></pre></td></tr></table></figure></li>
<li>14.确定TCP栈如何使用内存，当大于上限是报文将丢弃。一般按照缺省值分配，上面的例子就是读写均为8KB，共16KB</li>
</ul>
<p>1.6GB TCP内存能容纳的连接数，约为  1600MB/16KB = 100K = 10万<br>4.0GB TCP内存能容纳的连接数，约为  4000MB/16KB = 250K = 25万</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">net.ipv4.tcp_mem = 786432 2097152 3145728<br></code></pre></td></tr></table></figure>
<ul>
<li>15.表示如果套接字由本端要求关闭，这个参数决定了它保持在FIN-WAIT-2状态的时间，2.2中默认180秒，之后默认为60秒  <figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">net.ipv4.tcp_fin_timeout=30<br></code></pre></td></tr></table></figure></li>
<li>16.丢弃已经建立的tcp链接之前，需要多少次重试，默认15次，根据RTO的值，大概13-30分钟<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">net.ipv4.tcp_retries2=5<br></code></pre></td></tr></table></figure></li>
<li>17.放弃回应一个tcp连接请求之前，需要多少次重试，默认为3<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">net.ipv4.tcp_retries1=3<br></code></pre></td></tr></table></figure></li>
<li>18.收包速度大于内核处理包的速度时，输入队列最大报文数<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">net.core.netdev_max_backlog =  32768<br></code></pre></td></tr></table></figure></li>
<li>19.listen系统调用，最大的accept队列长度，超过该值时，后续请求被丢弃<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">net.core.somaxconn=32768<br></code></pre></td></tr></table></figure></li>
<li>20.针对孤立的socket（已经从进程上下文中删除，可是还有些清理工作没有完成），我们重试的最大次数。也就是server端close之后发[F.]的次数-1（0会重试一次），重负载服务器建议调小，默认为7。<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">net.ipv4.tcp_orphan_retries=1<br></code></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Graphite小结</title>
    <url>/2019/03/27/%E4%BD%BF%E7%94%A8Graphite%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<h2 id="前记"><a href="#前记" class="headerlink" title="前记"></a>前记</h2><p>初次认识Graphite时,Graphite已经发展了十年了,那时在负责kamailio相关工作内容,为了监控和查看kamailio数据,查找到的文章<a href="https://acalustra.com/kamailio-statsd-better-statistics-in-your-voip-platform.html">Kamailio statsd, better statistics in your voip platform.</a>,虽然不太认同作者把statsd客户端的嵌入kamailio的理念,但发现Graphite这东西还是很不错的(虽然后面接触了Prometheus emmmm…….不过Graphite可以保存长期的历史数据,并根据时间自动做聚合旧数据, 这个优点Prometheus是无法代替的).</p>
<p>Graphite是一个包含了用于接收和整合数据的<code>carbon</code>,存储数据的时序数据库<code>Whisper</code>还有一个提供API的server.<br>它的理念十分简单,存的数据只有timestamp-value,该数据存在key的文件里面,用户可以用过以<code>*.*.*</code>的方式来设置数据维度或者标签.而写数据就更简单了只要发送TCP/UDP文本<code>&#123;key&#125; &#123;value&#125; &#123;timestamp&#125;</code>到carbon即可.同时他还提供按数据落盘时长来聚合数据的归档功能,觉得这个功能是非常棒的,因为数据的有分冷热的, 我们也不会专门去查看一年前的具体数据,只会去查看他的大概数据.</p>
<span id="more"></span>

<h2 id="1-Graphite的好处"><a href="#1-Graphite的好处" class="headerlink" title="1.Graphite的好处"></a>1.Graphite的好处</h2><ul>
<li>类似于RRD的时序数据库<code>Whisper</code>,支持Metrics的精度递减,如一天内10s一条,七天内合并为1m一条,一年内1h一条(<strong>这点最棒!</strong>)</li>
<li>带有丰富的查询函数,  sum/min/max/avg/alias等等</li>
<li>简单的TCP/UDP协议,很容易插入数据</li>
<li>通过carbon-relay实现一个完整的HA方案</li>
<li>通过carbon-aggregator时间数据聚合方案</li>
<li>查询结构支持REST-API,查询功能丰富,查询简单</li>
<li>配置简单方便</li>
<li>支持百万数据收集(官方说的,实际上会打折扣)</li>
</ul>
<h2 id="2-Graphite组件"><a href="#2-Graphite组件" class="headerlink" title="2.Graphite组件"></a>2.Graphite组件</h2><p>初次接触Graphite会比较蒙圈,因为一个最简单的完整Graphite需要由carbon-cache,Whisper,GraphiteWeb组合在一起</p>
<h3 id="2-1组件介绍"><a href="#2-1组件介绍" class="headerlink" title="2.1组件介绍"></a>2.1组件介绍</h3><ul>
<li>carbon-cache<br>它的主要功能是把接收到的数据先写在内存里,等过了一段时间后,把数据都flush 到whisper里.<br>carbon.conf中的[cache]定义了监听的端口和缓存策略,默认是2003端口接收文本协议,2004端口接收pick协议,此外还提供一个叫<code>CACHE_QUERY</code>的配置,方便GraphiteWeb从carbon-cache查询数据；<br>storage-schemas.conf 定义了Metric数据的retentions规则,当carbon-cache收到一个新的Metric时,就会创建一个新的.wsp文件,并把该规则应用到该文件上(所以文件创立后,再更改规则是没用的)</li>
<li>carbon-relay  提供复制和分片功能，为分布式而服务。carbon.conf中的[relay]定义了监听的主机、端口和分发模式；relay-rules.conf定义了在rules模式下详细的分发策略。</li>
<li>carbon-aggregator  负责数据的聚合，通过聚合减少数据库压力防止磁盘爆掉.涉及到的配置文件：carbon.conf中的[aggregator]定义了接收和分发的主机；aggregation-rules.conf定义的是聚合策略。</li>
<li>Whisper<br>存储数据的时序数据库,本身没有暴露出公共接口.但是Carbon-Cache会将以Whisper数据库格式将数据写入磁盘.以及直接从磁盘上的Whisper数据库文件查询数据.Graphite以上面两种形式来完成Whisper的读写.</li>
<li>GraphiteWeb 提供一些简单的图表和API功能,同时对一些查询到的数据进行缓存.GraphiteWeb在查询数据会通过carbon-cache来获得数据, carbon-cache会查询Whisper数据,以及还缓存在内存中的数据,再一起返回给调用者.</li>
</ul>
<h3 id="2-2结构介绍"><a href="#2-2结构介绍" class="headerlink" title="2.2结构介绍"></a>2.2结构介绍</h3><p>TODO</p>
<h2 id="3-与Graphite相关组件"><a href="#3-与Graphite相关组件" class="headerlink" title="3.与Graphite相关组件"></a>3.与Graphite相关组件</h2><p>由于Graphite十分简单,单纯使用Graphite是无法完成监控的,他还需要其他组件一起组合起来,才能变成一个完善的监控系统</p>
<ul>
<li><p>聚合数据-Statsd<br>Graphite只存单纯的value,没有像Prometheus有time,gauge,set等概念,所以我们把数据写入Graohite前,需要自己先聚合数据,好在出现了一个StatsD,我们可以把数据发送给Statsd,由他实现time,gauge,set等功能,然后每隔一段时间再统一发送到Graphite里面(每隔一段时间也是比较重要的,自己把value直接写入Graphite时,多个Client也要控制到相同的写入点,不然看数据很难受).</p>
</li>
<li><p>收集系统指标-Collectd<br>如果像从zabbix之类转过来的用户,应该会很怀念zabbix自带的报警指标,而collected就是这样的存在,通过配置,collected会收集机器上面的系统指标并发送到Graphite.</p>
</li>
<li><p>报警系统<br>这一点我觉得是Graphite最缺的生态了,到现在都找不到一个适合Graphite且操作界面简便,配置简单的报警系统..如果不需要拥有ui界面,可以考虑自己编写一个简单的报警系统,如果需要界面,我觉得<a href="https://github.com/moira-alert/moira">moira</a>和<a href="https://bosun.org/">Bosun</a>都是比较不错的选择(需要注意的是,截止到2020-04,bosun的快速入门docker版本并不是最新的,需要下载后再自己手动替换.不然看了官方的配置文档会一脸闷逼)</p>
<h2 id="4-优化"><a href="#4-优化" class="headerlink" title="4.优化"></a>4.优化</h2><p>Graphite的使用比较简单,只要更改下配置文件即可,比起使用,经常遇到的问题是如何去优化.虽然作者说Graphite很容易的去处理百万Metrics,但是实际上使用时觉得作者是有些场景没考虑进去.比如在查找某个metric中最大的前5个,而这个查询需要去打开所有的metric,消耗的时间和cpu都是非常痛苦的…</p>
</li>
<li><p>1.使用SSD,毕竟是存在硬盘上的,SSD的速度更快.</p>
</li>
<li><p>2.如果Metric太多,那就尽可能的减少数据精度.比如可以降到1分钟记录一次就不要10秒记录一次,这样可以减少写入的压力和文件的大小</p>
</li>
<li><p>3.使用Carbon-Aggratoe做预聚合.比如可以预聚合某个维度的Metric为All,这样在查询所有数据时,可以只查AlL的数据</p>
</li>
<li><p>4.写入层改用一些c或者go的方案如<code>carbon-relay</code>改为<code>carbon-c-relay</code>.</p>
</li>
<li><p>5.缓存部分预查询的数据  在使用图片时,可以配置让GraphiteWeb支持Memcached,缓存已查询的数据.在查询数据时只能自己实现一个proxy-api-server(把时间以某个间隔聚合再以查询查询变为key即可),并加上一个redis为查询的数据做缓存</p>
</li>
<li><p>6.替换GraphiteWeb为GraphiteApi,因为他只保留核心的Query功能,速度稍微快一些,同时他的插件功能也是很不错的.</p>
</li>
<li><p>7.替换Whisper为<a href="https://github.com/douban/Kenshin">Kenshin</a>,Kenshin通过把多个metric聚合到同一个文件里面,减少了查询时打开文件的开销,极大的降低了IOPS,不过由于底层逻辑已经变了,替换是需要一些成本</p>
</li>
<li><p>8.使用集群,集群能同时缓解读写的开销,同时增加系统可用性</p>
</li>
<li><p>9.使用标签功能,目前Graphite支持类似于Prometheus的标签功能,比原本的<code>*.*.*</code>好很多,对性能也带来一定的提升,不过使用了GraphiteApi的话,就没办法使用标签功能了,GraphiteAPI到目前还未支持标签功能.(注:carbon-cache的配置中,标签功能默认开启的,如果不想使用需要配置carbon.conf的ENABLE_TAGS = False,不然会打印出大量的日志,影响服务器I/O)</p>
</li>
</ul>
<h2 id="5-其他"><a href="#5-其他" class="headerlink" title="5.其他"></a>5.其他</h2><p>这里说的是平时遇到一些小问题或提高效率的方法说明</p>
<ul>
<li><p>写入间隔<br>如果数据先到Statsd,再从Statsd写入Carbon,那一定要配置好Statsd与Carbon的间隔,不然可能会出现一些null的数据.<br>如果是自己多节点聚合数据再发送到Carbon,那要统一每个节点的发送时间是一致的,不然会出现数据间隔波动,数据展示会十分奇怪,同时聚合数据有时会出现数据不准的问题.</p>
</li>
<li><p>Metric命名<br>因为Metric是数量非常多,我们需要把Metric根据命令来分类,方便管理与查询.<br>首先是Metric的大类,主要有</p>
<ul>
<li>server-服务</li>
<li>app-应用</li>
<li>system-系统指标</li>
<li>container-容器几大类.<br>之后再根据小类的情况进行细分,比如有这样一个Metric:<code>server.server_name.project.region.ip.key</code>, 就是按照服务名,项目名,地区,IP,最后才是Metric本来的名字.如果在命名遇到像region和ip这类Metric,不知道哪个先哪个后,那就要根据自己的业务查询情况,看看哪个先置被查询的文件数会少以点,以少的Metric来命名.</li>
</ul>
</li>
<li><p>批量查看Metric或者批量修改Metric(以whisper-resize.py为例子)<br>用久了Graphite,肯定会遇到Metric管理的问题,比如有个Metric命名为Server.so1n.{app1, app2, app3}<br>如果我们要用whisper-resize.py去操作Metric,那就会进入/path/Server/app路径里面,进行如下操作</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">whisper-resize.py Server.so1n.app1  <span class="hljs-comment"># 省略参数</span><br>whisper-resize.py Server.so1n.app2  <span class="hljs-comment"># 省略参数</span><br>whisper-resize.py Server.so1n.app3  <span class="hljs-comment"># 省略参数</span><br></code></pre></td></tr></table></figure>
<p>如果只有3个还好,有时有很多个或者是类似这样Metric:Server.{so1n, user_1}.{app1, app2}要进入多个路径更麻烦,这时候就需要借助其他命令进行批量处理了, 如: <code>find ./ -type f -name &#39;*.wsp&#39; -exec whisper-resize.py --nobackup &#123;&#125; 1s:2d 10s:31d 60s:365d \;</code> 这个命令要主要加上’{}’和’;‘具体见find使用方法, 也可以写成一个脚本来调用:</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">for</span> f <span class="hljs-keyword">in</span> $(find <span class="hljs-variable">$1</span> -iname <span class="hljs-string">&quot;*.wsp&quot;</span>); <span class="hljs-keyword">do</span> <br>    <span class="hljs-keyword">if</span> [ -a <span class="hljs-variable">$f</span> ]; <br>        <span class="hljs-keyword">then</span> whisper-resize.py <span class="hljs-comment"># 省略参数 </span><br>    <span class="hljs-keyword">fi</span>; <br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure></li>
<li><p>自动删除无用Metric<br>如果用Graphite来做监控时,被监控的机器会出现变动, 当机器被删除后,Graphite中对应的Metric并不会被删除,需要我们进行人工干预,同上面一样我们也是用find命令来处理</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">find /opt/graphite/storage/whisper/* -name <span class="hljs-string">&#x27;*\.wsp&#x27;</span> -mtime 1 -delete<br></code></pre></td></tr></table></figure>
<p>其中<code>/opt/graphite/storage/whisper/*</code>是whisper的路径, <code>-mtime 1</code>的1是代表文件最后修改时间是1天之前,<code>-delete</code>代表删除的动作<br>只要自己配置好命令的路径和天数,并运用到crontab中,即可自动删除无用Metric</p>
</li>
<li><p>预测磁盘容量<br>在用时序数据库时,我们必须要做的就是去预测我们的规则(在Graphite是retentions规则)对空间占用的影响,会不会跑满磁盘的总空间.<br>carbon-cache在初次接收时会为每个指标创建一个Whisper文件，大小是由配置的精度和retentions确定的,Whisper数据库文件永远不会单独变小或变大.<br>因为Whisper文件会根据精度和retentions确定生成多少个数据点,而数据点的大小固定为12位.<br>所以我们可以确定存储容量大小跟精度和retentions有关系,但是自己计算太麻烦了,直接使用<a href="https://gist.github.com/jjmaestro/5774063">whisper-calculator.py</a> 再输入retentions规则,如:<code>10s:30d,10m:180d</code>即可得知空间占用大小.</p>
</li>
</ul>
<h2 id="6-集群"><a href="#6-集群" class="headerlink" title="6.集群"></a>6.集群</h2><p>在使用Graphite时,最让我困惑的是,我该如何去横向拓展Graphite,以提高Graphite的可用性和性能.在13年之前国内外都很难找到关于Graphite的横向拓展文章(我18年才接触),截止到本文章发表之前,国内也没有搜索到几篇关于Graphite的集群相关文章,经过一番搜索也只看到豆瓣和微博在使用Graphite(限定于大厂).而豆瓣通过改造Whisper为Kenshin,并用了稍微不同的架构来达到横向拓展的能力,而微博只看到18年时疯狂招人并维护一套跟Graphite的体系,我还没找到他们发表的相关文章.</p>
<p>搜索一圈后有一些感慨(可能是我搜索姿势不对),明明是一个挺不错的监控软件(不止于监控),感觉国内用Graphite的公司真少,可能18年大家都已经掉头到了go体系或者上云了,还好还有很多关于Graphite的英文文章可以参考.</p>
<h3 id="6-1集群结构"><a href="#6-1集群结构" class="headerlink" title="6.1集群结构"></a>6.1集群结构</h3><p>Graphite的集群看起来复杂,实际上却是很简单的,因为Graphite的集群架构就是给一群单点Graphite的写入写出套上一层网关层处理数据和节点调用.集群的架构图如下,分为机器A,B,C. 其中A是最外层的carbon-relay和Gtaphite Web, 他们所属机器是Master机器, 负责处理写入数据和读取数据. 而另外两个小框是B,C机器, 他们负责数据的存取.</p>
<p>如图,  A机器代表网关层节点上面跑着接受Metric的carbon-relay以及GraphiteWeb,carbon-relay负责接受Metric并利用hash分配到不同的机器B,C.而GraphiteWeb则根据请求去B,C机器采集数据,合并后返回给调用者.</p>
<p>B,C机器代表存储节点,它的功能则是一样的,负责存储数据,基本与单机Graphite一样,由carbon-relay把Metric分发给两个carbon-cache,并由GraphiteWeb提供接口给master的GraphiteWeb获取数据</p>
<p>这个架构的优点就是简单,没引入其他比较复杂的技术,同时网关节点跟存储节点横向拓展比较方便,特别是在引入配置中心后,配置文件的更改就可以自动化,只要做到安装Graphtie即可.</p>
<p><img    class="lazyload" data-original="https://github.com/so1n/so1n_blog_photo/blob/master/blog_photo/graphite.png?raw=true" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">Graphite架构图</span></p>
<h3 id="6-2如何配置"><a href="#6-2如何配置" class="headerlink" title="6.2如何配置"></a>6.2如何配置</h3><h4 id="6-2-1存储节点"><a href="#6-2-1存储节点" class="headerlink" title="6.2.1存储节点"></a>6.2.1存储节点</h4><p>首先是改造存储节点,如果只使用单个carbon-cache的话,可以根据内核数增加新的<strong>carbon-cache</strong>,将配置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">[cache]<br>LINE_RECEIVER_INTERFACE = 0.0.0.0<br>LINE_RECEIVER_PORT = 2003<br>PICKLE_RECEIVER_INTERFACE = 0.0.0.0<br>PICKLE_RECEIVER_PORT = 2004<br>CACHE_QUERY_INTERFACE = 0.0.0.0<br>CACHE_QUERY_PORT = 7002<br></code></pre></td></tr></table></figure>
<p>改为</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">[cache]<br>LINE_RECEIVER_INTERFACE = 127.0.0.1<br>PICKLE_RECEIVER_INTERFACE = 127.0.0.1<br>CACHE_QUERY_INTERFACE = 127.0.0.1<br><br>[cache:a]<br>LINE_RECEIVER_PORT = 2013<br>PICKLE_RECEIVER_PORT = 2014<br>CACHE_QUERY_PORT = 7012<br><br>[cache:b]<br>LINE_RECEIVER_PORT = 2023<br>PICKLE_RECEIVER_PORT = 2024<br>CACHE_QUERY_PORT = 7022<br></code></pre></td></tr></table></figure>
<p>启动方式从<code>bin/carbon-cache.py start</code>改为<code>bin/carbon-cache.py –-instance=a start</code>和 <code>bin/carbon-cache.py –-instance=b start</code></p>
<p><strong>carbon-relay</strong>配置改成如下,可以根据metric的一致哈希自动分配给对应的carbon-cache,由于是carbon-relay与carbon-cache的数据交换,把传输方式改为PICKLE,这样子传输速度快一点.</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[relay]</span><br><span class="hljs-attr">LINE_RECEIVER_INTERFACE</span> = <span class="hljs-number">0.0</span>.<span class="hljs-number">0.0</span><br><span class="hljs-attr">LINE_RECEIVER_PORT</span> = <span class="hljs-number">2003</span><br><span class="hljs-attr">PICKLE_RECEIVER_INTERFACE</span> = <span class="hljs-number">0.0</span>.<span class="hljs-number">0.0</span><br><span class="hljs-attr">PICKLE_RECEIVER_PORT</span> = <span class="hljs-number">2004</span><br><span class="hljs-attr">RELAY_METHOD</span> = consistent-hashing<br><span class="hljs-attr">DESTINATIONS</span> = <span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">2014</span>:a, <span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">2024</span>:b<br></code></pre></td></tr></table></figure>
<p>接下来就是<strong>GraphiteWeb</strong>(如果用GraphiteAPI自行变通),通过更改<code>local-setting.py</code>文件的CARBONLINK_HOSTS:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python">CARBONLINK_HOSTS = [<span class="hljs-string">&#x27;127.0.0.1:7012&#x27;</span>, <span class="hljs-string">&#x27;127.0.0.1:7022&#x27;</span>]<br>DATABASES = &#123;<br>    <span class="hljs-string">&#x27;default&#x27;</span>: &#123;<br>        <span class="hljs-string">&#x27;NAME&#x27;</span>: <span class="hljs-string">&#x27;/opt/graphite/storage/graphite.db&#x27;</span>,<br>        <span class="hljs-string">&#x27;ENGINE&#x27;</span>: <span class="hljs-string">&#x27;django.db.backends.sqlite3&#x27;</span>,<br>        <span class="hljs-string">&#x27;USER&#x27;</span>: <span class="hljs-string">&#x27;&#x27;</span>,<br>        <span class="hljs-string">&#x27;PASSWORD&#x27;</span>: <span class="hljs-string">&#x27;&#x27;</span>,<br>        <span class="hljs-string">&#x27;HOST&#x27;</span>: <span class="hljs-string">&#x27;&#x27;</span>,<br>        <span class="hljs-string">&#x27;PORT&#x27;</span>: <span class="hljs-string">&#x27;&#x27;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>GraphiteWebc在查数据时,可以通过多个Carbon-cache一起查询,增加查询效率.</p>
<p>可以发现存储节点的配置是固定的,可以直接使用docker或者ansible一键部署.这样关于存储节点的配置就结束了,接下来就是配置网关层</p>
<h4 id="6-2-2网关节点"><a href="#6-2-2网关节点" class="headerlink" title="6.2.2网关节点"></a>6.2.2网关节点</h4><p>还是以B,Ｃ节点为例，假设Ｂ节点ip为10.0.1.10，Ｃ节点为10.0.1.11,由于网关层只是负责把数据写入指定存储节点与从存储节点读取数据,所以只需要配置<code>carbon-relay</code>以及<code>GraphiteWeb</code>即可.<br>首先是<code>carbon-relay</code>,同样也是配置一致哈希与目标位置,同时配置REPLICATION_FACTOR,一般REPLICATION_FACTOR的值应该大于等于3(示例是2),确保数据安全保存.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">[relay]<br>LINE_RECEIVER_INTERFACE = 0.0.0.0<br>LINE_RECEIVER_PORT = 2003<br>PICKLE_RECEIVER_INTERFACE = 0.0.0.0<br>PICKLE_RECEIVER_PORT = 2004<br>RELAY_METHOD = consistent-hashing<br>REPLICATION_FACTOR = 2<br>DESTINATIONS = 10.0.1.10:2004, 10.0.1.11:2004<br></code></pre></td></tr></table></figure>
<p>然后就是<code>GraphiteWeb</code>,他的配置跟存储节点一样,只要把<code>CLUSTER_SERVERS</code>配置为存储节点的GraphiteWeb,即可</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python">CLUSTER_SERVERS= [<span class="hljs-string">&quot;10.0.1.10:80&quot;</span>, <span class="hljs-string">&quot;10.0.1.11:80&quot;</span>]<br></code></pre></td></tr></table></figure>
<p>这样网关层就配置完毕了,唯一缺点就是每次新增存储节点时,网关层都需要重新更改配置并重启进程,这里可以根据自己的基础服务进行改进</p>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>StatsD, Graphite, Grafana方案唯一的缺点就是安装繁琐了,所以把自己的安装过程记录下来,当然目前有许多打包,如果需要可以参考打包安装的对应链接.<br>使用系统安装如(debian)的包会比较旧,一般都是python2,如无其他需要默认所有安装默认python2比较好</p>
<h4 id="1-打包安装"><a href="#1-打包安装" class="headerlink" title="1.打包安装"></a>1.打包安装</h4><ul>
<li><a href="https://github.com/obfuscurity/synthesize">Synthesize版</a></li>
<li><a href="https://github.com/graphite-project/docker-graphite-statsd">docker版</a></li>
</ul>
<h4 id="2-分步安装"><a href="#2-分步安装" class="headerlink" title="2.分步安装"></a>2.分步安装</h4><h5 id="2-1graphite"><a href="#2-1graphite" class="headerlink" title="2.1graphite"></a>2.1graphite</h5><p>若可以按以下安装的,之后安装方法查看此链接:<a href="https://www.digitalocean.com/community/tutorials/how-to-install-and-use-graphite-on-an-ubuntu-14-04-server">https://www.digitalocean.com/community/tutorials/how-to-install-and-use-graphite-on-an-ubuntu-14-04-server</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">sudo apt-get update<br>sudo apt-get install graphite-carbon<br></code></pre></td></tr></table></figure>
<p><strong>注:以该方式安装后路径是(pip):/etc/carbon/ or /etc/whisper/,而以下示例路径是(python setup.py install):/opt/graphite/</strong></p>
<h5 id="2-1-1carbon"><a href="#2-1-1carbon" class="headerlink" title="2.1.1carbon"></a>2.1.1carbon</h5><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">pip install carbon --install-option=<span class="hljs-string">&quot;--prefix=/opt/graphite&quot;</span> --install-option=<span class="hljs-string">&quot;--install-lib=/opt/graphite/lib&quot;</span><br></code></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">mkdir ./path/...<br><span class="hljs-built_in">cd</span> ./path/...<br>git <span class="hljs-built_in">clone</span> https://github.com/graphite-project/carbon.git<br><span class="hljs-built_in">cd</span> carbon<br>pip install twisted<br>python setup.py install<br><span class="hljs-comment"># 查看安装情况</span><br>ls -l /opt/graphite<br></code></pre></td></tr></table></figure>
<p>在bin文件夹下，能够找到如下三种不同类型的Carbon守护进程：</p>
<ul>
<li>Cache：接受通过各种协议传输来的指标项数据并以尽可能高的效率将它们写入磁盘；在接收到指标项时，将指标项值缓存在 RAM 中，并用底层的 Whisper 库按照指定的时间间隔将这些值写入磁盘。</li>
<li>Relay：有两个不同的用途：将输入的指标项复制并分区。</li>
<li>Aggregator：运行于 cache 前方，在 Whisper 中记录指标项之前，缓存这些指标项一段时间。</li>
</ul>
<h5 id="2-1-2-Whisper"><a href="#2-1-2-Whisper" class="headerlink" title="2.1.2 Whisper"></a>2.1.2 Whisper</h5><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">pip install whisper<br></code></pre></td></tr></table></figure>
<p>or</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 可能需要更新setuptools    </span><br><span class="hljs-comment"># pip install --upgrade setuptools</span><br>mkdir ./path/...<br><span class="hljs-built_in">cd</span> ./path/...<br>git <span class="hljs-built_in">clone</span> https://github.com/graphite-project/whisper.git<br><span class="hljs-built_in">cd</span> whisper <br>python setup.py install<br></code></pre></td></tr></table></figure>

<h5 id="2-1-3运行carbon"><a href="#2-1-3运行carbon" class="headerlink" title="2.1.3运行carbon"></a>2.1.3运行carbon</h5><p>使用默认配置文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /opt/graphite/conf<br>cp aggregation-rules.conf.example aggregation-rules.conf<br>cp blacklist.conf.example blacklist.conf<br>cp carbon.conf.example carbon.conf<br>cp carbon.amqp.conf.example carbon.amqp.conf<br>cp relay-rules.conf.example relay-rules.conf<br>cp rewrite-rules.conf.example rewrite-rules.conf<br>cp storage-schemas.conf.example storage-schemas.conf<br>cp storage-aggregation.conf.example storage-aggregation.conf<br>cp whitelist.conf.example whitelist.conf<br><span class="hljs-comment"># 确定ip和端口</span><br>vi carbon.conf<br><span class="hljs-comment"># 默认配置</span><br>[cache]<br>LINE_RECEIVER_INTERFACE = 0.0.0.0<br>LINE_RECEIVER_PORT = 2003<br><span class="hljs-comment"># 启动</span><br>/opt/graphite/bin/carbon-cache.py start<br><span class="hljs-comment">#　查看进程是否运行以及监听的端口</span><br>ps -efla | grep carbon-cache<br>netstat -nap | grep 2003<br></code></pre></td></tr></table></figure>
<h5 id="2-1-4查看whisper数据"><a href="#2-1-4查看whisper数据" class="headerlink" title="2.1.4查看whisper数据"></a>2.1.4查看whisper数据</h5><p>路径:/opt/graphite/storage/whisper<br>查看命令(对于后辍为.wsp的可用, 使用方法为命令+路径):</p>
<ul>
<li>whisper-info.py (whisper-info脚本获取为这些指标项创建的 Whisper 文件的元数据信息。)</li>
<li>whisper-dump.py(whisper-dump是一个更完整的脚本，可以输出所有存储保留周期内的原始数据以及 Whisper 文件的元数据信息。)<br>使用方法<figure class="highlight vim"><table><tr><td class="code"><pre><code class="hljs vim"># <span class="hljs-keyword">grep</span>是为了去除无效数据<br>whisper-dump.<span class="hljs-keyword">py</span> invite.wsp | <span class="hljs-keyword">grep</span> -v <span class="hljs-string">&#x27;: 0,&#x27;</span><br></code></pre></td></tr></table></figure>
<h5 id="2-1-5graphite-api"><a href="#2-1-5graphite-api" class="headerlink" title="2.1.5graphite-api"></a>2.1.5graphite-api</h5><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">pip install graphite-api --install-option=<span class="hljs-string">&quot;--prefix=/opt/graphite&quot;</span><br></code></pre></td></tr></table></figure>
或者<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 注:目前不支持python3, 请用上面的pip再加指定位置的方法,或者先安装cairocffi (0.9.0)</span><br>mkdir ./path/...<br><span class="hljs-built_in">cd</span> ./path/...<br>git <span class="hljs-built_in">clone</span> https://github.com/brutasse/graphite-api<br><span class="hljs-built_in">cd</span> graphite-api<br>python setup.py install<br></code></pre></td></tr></table></figure>
按需确定自己是否需要<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">sudo apt-get install libpango1.0-0<br> sudo apt-get install libcairo2<br> sudo apt-get install libpq-dev<br><span class="hljs-comment"># python2</span><br>sudo apt-get install python-dev  \<br>     build-essential libssl-dev libffi-dev \<br>     libxml2-dev libxslt1-dev zlib1g-dev \<br>     python-pip<br><span class="hljs-comment"># python3</span><br>sudo apt-get install python3 python-dev python3-dev \<br>     build-essential libssl-dev libffi-dev \<br>     libxml2-dev libxslt1-dev zlib1g-dev \<br>     python-pip<br></code></pre></td></tr></table></figure>
创建graphite-api的配置文件：<br>/opt/graphite/conf/graphite-api.yml<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">search_index: /opt/graphite/storage/index<br>finders:<br> - graphite_api.finders.whisper.WhisperFinder<br><span class="hljs-built_in">functions</span>:<br> - graphite_api.functions.SeriesFunctions<br> - graphite_api.functions.PieFunctions<br>whisper:<br> directories:<br> - /opt/graphite/storage/whisper<br>carbon:<br> hosts:<br> - 127.0.0.1:7002<br> timeout: 1<br> retry_delay: 15<br> carbon_prefix: carbon<br> replication_factor: 1<br></code></pre></td></tr></table></figure>

</li>
</ul>
<p>在这个配置文件中,<br>search_index的路径一般为:/opt/graphite/storage/index,如果没有则需要自己运行 build-index.sh(位于/opt/graphite/bin, 需要安装graphite-web, 由于使用了graphite-web所以不用生成)命令生成,记得运行命令chmod 0644 index更改权限<br>whisper的数据路径配置为/opt/graphite/storage/whisper，这个是在carbon配置文件 /opt/graphite/conf/carbon.conf 中使用配置项LOCAL_DATA_DIR进行定义的。</p>
<p><strong>注:如果遇到dlopen() failed to load a library: cairo / cairo-2且不会用到图形元素的可以屏蔽掉graphite_api/app.py526行以及下面相关的image代码,同时屏蔽/render/glyph.py<br>里的import cairocffi,不然需要安装更多依赖</strong></p>
<h5 id="2-1-6uwsgi"><a href="#2-1-6uwsgi" class="headerlink" title="2.1.6uwsgi"></a>2.1.6uwsgi</h5><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">apt-get install uwsgi<br></code></pre></td></tr></table></figure>
<p>debain和ubuntu系统或者运行后提示无法加载graphite_api.app模块的则需要先安装uwsgi-plugin-python(如debian:运行apt-get install uwsgi-plugin-python)<br>配置uwsgi</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">vi /etc/uwsgi/apps-enabled/graphite-api.ini <br><br>[uwsgi]<br>processes = 2<br><span class="hljs-comment"># 如果对接nginx则使用socket  如果直接调用则用http</span><br>socket = 127.0.0.1:5000<br>http = 127.0.0.1:5000<br>module = graphite_api.app:app<br><span class="hljs-comment"># python版本</span><br>plugins = python27<br>env = GRAPHITE_API_CONFIG=/opt/graphite/conf/graphite-api.yml<br></code></pre></td></tr></table></figure>
<p>如果搭配nginx ,也就是上面的uwsgi配置写的是socket而非http<br>在nginx配置中添加</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">location / &#123;<br>    include uwsgi_params;<br>    uwsgi_pass localhost:5000;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight maxima"><table><tr><td class="code"><pre><code class="hljs maxima">重启<br>service uwsgi <span class="hljs-built_in">restart</span><br></code></pre></td></tr></table></figure>
<h4 id="2-2StatsD"><a href="#2-2StatsD" class="headerlink" title="2.2StatsD"></a>2.2StatsD</h4><h5 id="2-2-1安装"><a href="#2-2-1安装" class="headerlink" title="2.2.1安装"></a>2.2.1安装</h5><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">sudo apt-get install nodejs devscripts debhelper dh-systemd<br><span class="hljs-comment"># 有些发行版带的nodejs比较老,需要大于8.0,可以到这里安装https://github.com/nodesource/distributions/blob/master/README.md</span><br>mkdir ./path/...<br><span class="hljs-built_in">cd</span> ./path/...<br>git <span class="hljs-built_in">clone</span> https://github.com/etsy/statsd.git <br><span class="hljs-built_in">cd</span> statsd<br><span class="hljs-comment"># *.deb 会在上级目录创建</span><br>dpkg-buildpackage<br><span class="hljs-built_in">cd</span> ..<br>dpkg -i statsd*.deb<br>service statsd start<br><span class="hljs-comment"># 配置文件:/etc/statsd/localConfig.js</span><br></code></pre></td></tr></table></figure>

<h5 id="2-2-2-更改配置"><a href="#2-2-2-更改配置" class="headerlink" title="2.2.2 更改配置"></a>2.2.2 更改配置</h5><p>在Graphite为StatsD更改匹配模式</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">vi /opt/graphite/conf/storage-schemas.conf<br><span class="hljs-comment"># 在文件增加以下匹配模式</span><br><span class="hljs-comment"># StatsD将带有stats前缀的数据发送到Graphite</span><br>[statsd]<br>pattern = ^stats.*<br>retentions = 10s:1d,1m:7d,10m:1y<br></code></pre></td></tr></table></figure>

<h5 id="2-2-3-重启"><a href="#2-2-3-重启" class="headerlink" title="2.2.3 重启"></a>2.2.3 重启</h5><figure class="highlight gradle"><table><tr><td class="code"><pre><code class="hljs gradle"><span class="hljs-regexp">/opt/g</span>raphite<span class="hljs-regexp">/bin/</span>carbon-cache.py stop<br><span class="hljs-regexp">/opt/g</span>raphite<span class="hljs-regexp">/bin/</span>carbon-cache.py start<br></code></pre></td></tr></table></figure>
<h5 id="2-3grafana"><a href="#2-3grafana" class="headerlink" title="2.3grafana"></a>2.3grafana</h5><blockquote>
<p>详见:<a href="https://grafana.com/docs/installation/debian/">https://grafana.com/docs/installation/debian/</a></p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">wget https://dl.grafana.com/oss/release/grafana_6.4.3_amd64.deb<br>sudo apt-get install -y adduser libfontconfig<br>sudo dpkg -i grafana_6.4.3_amd64.deb<br>sudo service grafana-server start<br><span class="hljs-comment"># 开机自启</span><br>sudo update-rc.d grafana-server defaults<br></code></pre></td></tr></table></figure>

<p>配置nginx反向代理grafana</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># nginx 配置</span><br>    location /grafana &#123;<br>        root   html;<br>        index  index.html index.htm;<br>        add_header <span class="hljs-string">&#x27;Access-Control-Allow-Origin&#x27;</span> <span class="hljs-string">&#x27;*&#x27;</span>;<br>        add_header Access-Control-Allow-Methods GET,POST,OPTIONS,DELETE;<br>        add_header <span class="hljs-string">&#x27;Access-Control-Allow-Headers&#x27;</span> <span class="hljs-string">&#x27;userId,DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type&#x27;</span>;<br>        proxy_pass http://localhost:3000; <br>        rewrite ^/grafana/(.*) /<span class="hljs-variable">$1</span> <span class="hljs-built_in">break</span>;<br>        proxy_set_header   Host <span class="hljs-variable">$host</span>;<br>    &#125;<br><span class="hljs-comment"># grafana配置</span><br><span class="hljs-comment"># /etc/grafana/grafana.ini</span><br>root_url=%(protocol)s://%(domain)s:%(http_port)s/grafana<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>Graphite</tag>
        <tag>监控</tag>
        <tag>基础服务</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis缓存穿透,缓存击穿,缓存雪崩</title>
    <url>/2019/03/21/Redis%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F,%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF,%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9/</url>
    <content><![CDATA[<h2 id="前记"><a href="#前记" class="headerlink" title="前记"></a>前记</h2><p>最近使用Redis越来越多了,使用Redis可以提升接口性能,同时也可以基于Redis实现分布式锁以及使用Redis限流等等.不过在使用Redis与Mysql结合时会遇到一些常见的单机缓存相关问题(基本是标配了)缓存穿透、击穿、雪崩.</p>
<p>缓存穿透,击穿,雪崩很像,如果不是为了面试准备,我也可能随时就忘了(逃)</p>
<ul>
<li>击穿  缓存和数据库都没有数据的时候</li>
<li>穿透  同一个key,缓存没数据,数据库有数据的时候</li>
<li>雪崩  很多个key在同一时刻,缓存没数据,数据库有数据的时候<span id="more"></span>
这类问题十分常见,所以我又是多水了一文啦,不过要确保在引入解决方案时,能尽可能的适应自己的业务,而不是为了引进解决方案而引进解决方案.</li>
</ul>
<p><strong>注:示例代码做了更新,使用的redis为aioredis,使用的mysql为aiomysql,同时已经把代码更新到Python3.6+可用</strong></p>
<h2 id="1-业务接口开发中的缓存实现方式"><a href="#1-业务接口开发中的缓存实现方式" class="headerlink" title="1.业务接口开发中的缓存实现方式"></a>1.业务接口开发中的缓存实现方式</h2><p>为了简单说明,这里使用的db为mysql,缓存为Redis,为了保证缓存能及时跟db同步更新数据,而更新数据一般分为同步刷新或者定时刷新,以下是更新缓存数据的方式说明:</p>
<ul>
<li>1.1在应用层同时更新缓存和db<br>写数据时先把数据写入到db,写成功后再把数据写入缓存.而读数据时先检查缓存中是否有数据,如果有则返回数据,如果没有则从db中获取数据,再把数据写入缓存,最后返回数据.<br>这个方式的最简单,最容易理解的,适用范围也是最大的,同时也是坑最多的.<ul>
<li>1.先更新db,再更新缓存造成的脏数据<br>假设有两个并发,当出现后抵达的操作先更新缓存数据,之后在把先操作的数据写入到缓存数据时就会造成缓存了脏数据,最好的解决办法就是当数据更新时,设置一个时间戳,之后再写入缓存时比较时间戳,如果写入的时间戳低于已缓存的时间戳,那就不进行缓存</li>
<li>2.先删除缓存,在删除db的数据<br>假设一个请求正在删除缓存数据后,准备删db数据时,另一个请求刚好在查缓存数据,发现查不到了,就从数据库拉数据,并把数据更新到缓存,操作完成后,第一个请求才把db的数据进行删除.造成了缓存有数据,而db没数据的数据不一致问题.比较好的解决方案是,先把数据库数据进行删除,再把缓存的key设置一个适当(结合业务)的过期时间,让其自动过期.(先删除数据库再删除缓存的数据理论上也是有坑的,但实际触发频率不高)</li>
</ul>
</li>
<li>1.2把db和缓存当成一个整体,由应用层调用<br>从上面的方法可以看出虽然灵活,但每次都要在应用层维护一次同步更新缓存和db会觉得很繁琐,所以可以使用一些封装,把mysql和redis当成一个整体,内部实现上面的方法,然后把写数据和读数据封装成一个接口,让应用层调用.该方式对于外部调用的人会觉得十分简单,但内部实现会十分复杂.</li>
<li>1.3先更新缓存,再定时把数据写入db<br>这种方式会带来极大的性能提升,但由于数据一致性的问题局限性比较大,一般用于像微博的点赞/取消这类的业务.因为这类业务更新快,而且对于用户来说不太关心具体数值的大小,只要知道大概的范围即可.<br>写数据都会先把数据写入到缓存,然后再使用定时脚本等把缓存的数据写入到db.读数据时都是从缓存中读数据,如果缓存没有数据,则从db中拉取.</li>
</ul>
<h2 id="2-缓存问题"><a href="#2-缓存问题" class="headerlink" title="2.缓存问题"></a>2.缓存问题</h2><p>介绍完上面几种业务接口开发中的缓存实现方式后,就可以说说缓存实现时容易遇到的常见的问题了</p>
<h3 id="2-1缓存穿透"><a href="#2-1缓存穿透" class="headerlink" title="2.1缓存穿透"></a>2.1缓存穿透</h3><p>如果db中没有数据,那么缓存中也是没有数据的,会造成大量的请求实际上还是请求到了db里,这样子缓存就没有意义了.</p>
<p>通用的解决方法是在缓存中把db返回None的key在缓存中设置一个标识位,其他请求过来时看到这个标识位就知道没有数据了,不必再向db拿数据,直接返回没有数据的响应.然后当插入数据到db时,再通过数据写入到缓存.</p>
<p>还有一个更简单的方法是使用布隆过滤器(只要这个key不存在,他就会告诉你这个key不存在)来检查key是否存在于redis,如果不存在就返回自己设定好的响应.</p>
<h3 id="2-2缓存击穿"><a href="#2-2缓存击穿" class="headerlink" title="2.2缓存击穿"></a>2.2缓存击穿</h3><p>在上面实现的方式中,都会出现缓存穿透的问题,假设有段数据,在查的时候需要花费1秒钟的时间,而此事的并发量很高,当这段数据不存在缓存中时,就会导致大量的并发请求在这1秒种内全部请求到db,使db的读写性能变差.</p>
<p>解决这个问题的方式可以先使用分布式锁,确保只有一个进程可以从db中获取到数据,其余进程可以等待第一个进程获取到数据后从缓存中拉取数据.而在进程内部,使用多线程或者协程都是共享进程内存的,所以可以使用一个类似于通知的机制,其他没从db拉取数据的线程/协程都可以等待数据拉完后,再从内存拿数据再返回响应.</p>
<h4 id="2-2-1缓存击穿解决方案"><a href="#2-2-1缓存击穿解决方案" class="headerlink" title="2.2.1缓存击穿解决方案"></a>2.2.1缓存击穿解决方案</h4><p>首先,就是设置一个锁,通过锁解决多个进程同时执行一个相同的操作,由于是单机方案,所以使用set…ex…nx即可,通过ex设置超时时间,防止程序挂了等造成死锁,再通过nx会让除了set成功返回1的原理来实现获取锁,如果是集群最好使用RedLock.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RDS</span>():</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>():</span><br>        <span class="hljs-comment"># 注:__init__逻辑里面并不能使用await,该行代码无法正常运行,这里只是简要说明初始化连接池</span><br>        self.conn_pool = <span class="hljs-keyword">await</span> aioredis.create_pool()<br>        <br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">execute</span>(<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">            self, command: <span class="hljs-built_in">str</span>, *args: Any, **kwargs: Any</span></span><br><span class="hljs-function"><span class="hljs-params">    </span>) -&gt; Optional[Any]:</span><br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> self.conn_pool.get() <span class="hljs-keyword">as</span> conn:<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> conn.execute(command, *args, **kwargs)<br>        <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>        	<span class="hljs-keyword">pass</span> <span class="hljs-comment"># 抛错自定义,与演示无关,先pass</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>        <br><span class="hljs-meta">    @asynccontextmanager</span><br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">lock</span>(<span class="hljs-params">self, name: <span class="hljs-built_in">str</span>, timeout: <span class="hljs-built_in">int</span> = <span class="hljs-number">1</span> * <span class="hljs-number">60</span></span>) -&gt; bool:</span><br>    	<span class="hljs-comment"># 这里锁粒度是天,可以根据自己业务定义</span><br>        today_string: <span class="hljs-built_in">str</span> = datetime.datetime.now().strftime(<span class="hljs-string">&quot;%Y-%m-%d&quot;</span>) <br>        key: <span class="hljs-built_in">str</span> = <span class="hljs-string">f&quot;project:lock:<span class="hljs-subst">&#123;name&#125;</span>:<span class="hljs-subst">&#123;today_string&#125;</span>&quot;</span><br>        <span class="hljs-keyword">try</span>:<br>            lock = <span class="hljs-keyword">await</span> self.execute(<span class="hljs-string">&#x27;set&#x27;</span>, key, <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;ex&#x27;</span>, timeout, <span class="hljs-string">&#x27;nx&#x27;</span>)<br>            <span class="hljs-keyword">if</span> lock == <span class="hljs-number">1</span>:<br>                lock = <span class="hljs-literal">True</span><br>            <span class="hljs-keyword">else</span>:<br>                lock = <span class="hljs-literal">False</span><br>            <span class="hljs-keyword">yield</span> lock<br>        <span class="hljs-keyword">finally</span>:<br>            <span class="hljs-keyword">await</span> self.execute(<span class="hljs-string">&#x27;del&#x27;</span>, key)<br></code></pre></td></tr></table></figure>
<p>之后每个程序就可以像如下逻辑去调用:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python">rds = RDS()<br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">api_demo</span>():</span><br>    <span class="hljs-keyword">while</span>:<br>        <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> rds.lock <span class="hljs-keyword">as</span> lock:<br>            <span class="hljs-keyword">if</span> lock:<br>                <span class="hljs-keyword">pass</span> <span class="hljs-comment"># 获得锁的逻辑</span><br>            <span class="hljs-keyword">await</span> <span class="hljs-keyword">async</span>.sleep(<span class="hljs-number">0.01</span>)<br></code></pre></td></tr></table></figure>
<p>这样可以解决了多个进程同时执行一个相同的操作,但是还没解决同个进程内重复获取的问题.<br>在Python的协程中,可以使用协程的Future对象来实现通知的机制,下面通过一个叫<code>Share</code>的类来实现,如果跟随web框架启动,需要把它绑定在全局变量里面,这里做了省略,代码和对应解释如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-comment"># 清理现场逻辑最好还是用计数器来保证所有调用调用结束后才进行清理现场,不过代码量会变多,所以这里简单的使用延迟清理逻辑来代替.</span><br><span class="hljs-comment"># 同时为了逻辑清晰,并没有全部使用asyncio.Future的功能</span><br><span class="hljs-keyword">import</span> asyncio<br><span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> partial<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Share</span>():</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, delay_clean_time=<span class="hljs-number">1</span></span>):</span><br>        self._future_dict = <span class="hljs-built_in">dict</span>()<br>        self._result_dict = <span class="hljs-built_in">dict</span>()<br>        self._error_dict = <span class="hljs-built_in">dict</span>()<br>        self._loop = asyncio.get_event_loop()<br>        self._delay_clean_time = delay_clean_time  <span class="hljs-comment"># 代表执行完毕后多少秒清理现场</span><br><br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">clean</span>(<span class="hljs-params">self, key</span>):</span><br>        <span class="hljs-keyword">await</span> asyncio.sleep(self._delay_clean_time)<br>        <span class="hljs-comment"># 清理现场</span><br>        <span class="hljs-keyword">if</span> key <span class="hljs-keyword">in</span> self._future_dict:<br>            <span class="hljs-keyword">del</span> self._future_dict[key]<br>        <span class="hljs-keyword">if</span> key <span class="hljs-keyword">in</span> self._result_dict:<br>            <span class="hljs-keyword">del</span> self._result_dict[key]<br>        <span class="hljs-keyword">if</span> key <span class="hljs-keyword">in</span> self._error_dict:<br>            <span class="hljs-keyword">del</span> self._error_dict[key]<br>    <br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">do</span>(<span class="hljs-params">self, key, fn</span>):</span><br>        <span class="hljs-keyword">if</span> key <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> self._future_dict:<br>            <span class="hljs-comment"># 第一个执行的协程,进入执行逻辑</span><br>            self._future_dict[key] = asyncio.Future()  <span class="hljs-comment"># 设置一个Future,其他协程可以等待这个Future直到他被执行set_result(True)</span><br>            <span class="hljs-keyword">try</span>:<br>                self._result_dict[key] = <span class="hljs-keyword">await</span> fn()  <span class="hljs-comment"># 执行函数(如果有同步和异步函数,需要做判断,这里只示范异步)</span><br>            <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>                self._error_dict[key] = e   <span class="hljs-comment"># 记录异常</span><br>            <span class="hljs-keyword">finally</span>:<br>                self._future_dict[key].set_result(<span class="hljs-literal">True</span>)  <span class="hljs-comment"># 代表执行完毕</span><br>                <br>                <span class="hljs-comment"># 执行延迟清理现场逻辑</span><br>                asyncio.ensure_future(self.clean(key))<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-comment"># 非第一个执行的协程进入等待逻辑</span><br>            <span class="hljs-keyword">await</span> self._future_dict[key]<br>            <br>        <span class="hljs-comment"># 有异常则抛异常</span><br>        <span class="hljs-keyword">if</span> key <span class="hljs-keyword">in</span> self._error_dict:<br>            <span class="hljs-keyword">raise</span> self._error_dict[key]<br>        <span class="hljs-comment"># 返回数据</span><br>        <span class="hljs-keyword">return</span> self._result_dict[key]<br></code></pre></td></tr></table></figure>
<p>通过Share类后可以把demo代码改为如下就可以解决缓存击穿(如果用集群的话,记得把lock更换为RedLock):</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python">rds = RDS()<br>share =  Share()<br>share_key = <span class="hljs-string">&#x27;so1n&#x27;</span><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_data_demo</span>():</span><br>    <span class="hljs-keyword">while</span>:<br>        <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> rds.lock <span class="hljs-keyword">as</span> lock:<br>            <span class="hljs-keyword">if</span> lock:<br>                <span class="hljs-keyword">pass</span> <span class="hljs-comment"># 获得锁的逻辑</span><br>            <span class="hljs-keyword">await</span> <span class="hljs-keyword">async</span>.sleep(<span class="hljs-number">0.01</span>)<br>            <br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">api_demo</span>():</span><br>    <span class="hljs-keyword">return</span> share.do(share_key, get_data_demo)<br></code></pre></td></tr></table></figure>
<h3 id="2-3缓存雪崩"><a href="#2-3缓存雪崩" class="headerlink" title="2.3缓存雪崩"></a>2.3缓存雪崩</h3><p>缓存雪崩是指缓存不可用或者大量缓存由于超时时间相同在同一时间段失效，大量请求直接访问数据库，数据库压力过大导致系统雪崩。<br>为了解决这个问题:</p>
<ul>
<li>需要有良好的过期时间设计,可以在设置过期时间时添加jitter值,比如设置jitter为10,那每次给key设置过期时间时,他的过期时间会在 +-10内波动.</li>
<li>如果是时点性数据,比如昨天活动有10%的奖励,今天是20%的奖励,那么jitter可能不好用,这时候需要在业务层让程序短暂的睡几毫秒或者秒,给更新热点key分散压力.</li>
<li>要做好监控,基于redis的info数据做监控,看那些时间段过期的key比较多,是否跟自己的设定值有关,如果有就要赶紧修改设定值.</li>
<li>还有一个办法就是使用多级缓存,一级缓存更新快,过期时间也快,二级缓存更新频率不高,能在一级缓存过期时,作为一个兜底的作用.但在使用这个方法时,要确保二级缓存的更新频率是否符合自己的要求.</li>
</ul>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>收藏</title>
    <url>/2019/03/20/github_start/</url>
    <content><![CDATA[<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>由于github的start功能比较废，所以把自己的start整理下，可以按照以下标签或每个项目对应说明快速查找</p>
<span id="more"></span>

<h3 id="标签列表"><a href="#标签列表" class="headerlink" title="标签列表"></a>标签列表</h3><ul>
<li>Python</li>
<li>书</li>
<li>工具</li>
<li>源码学习</li>
<li>英语学习</li>
<li>书籍</li>
<li>awesome</li>
<li>sip</li>
<li>知识整理</li>
<li>文档</li>
<li>NLP</li>
<li>Asynico</li>
<li>软件</li>
<li>渗透</li>
<li>算法</li>
</ul>
<h2 id="Start项目"><a href="#Start项目" class="headerlink" title="Start项目"></a>Start项目</h2><ul>
<li><p><a href="https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way">How-To-Ask-Questions-The-Smart-Way</a></p>
<ul>
<li>标签：书籍</li>
<li>说明：提问的智慧</li>
</ul>
</li>
<li><p><a href="https://github.com/coleifer/huey">coleifer / huey</a></p>
<ul>
<li>标签：Python，工具，源码学习</li>
<li>说明：基于Python实现的小型任务队列</li>
</ul>
</li>
<li><p><a href="https://github.com/laike9m/pdir2">laike9m / pdir2</a></p>
<ul>
<li>标签：Python，工具</li>
<li>说明：一个国人开发的类似Python 自带dir()的库，功能以及可视化效果比dir()好</li>
</ul>
</li>
<li><p><a href="https://github.com/mozilla/agithub">mozilla / agithub</a></p>
<ul>
<li>标签： 源码学习</li>
<li>说明：一个用Python写的RESR请求库，灵活的使用Python的动态功能</li>
</ul>
</li>
<li><p><a href="https://github.com/uber/pyflame">uber / pyflame</a></p>
<ul>
<li>标签：Python, 工具</li>
<li>说明：一个高性能的分析工具，可以分析Python的性能消耗</li>
</ul>
</li>
<li><p><a href="https://github.com/dabeaz/curio">dabeaz / curio</a></p>
<ul>
<li>标签：Python,工具</li>
<li>说明：一个类似于asynico的库，但并没有asynico的http内存溢出Bug</li>
</ul>
</li>
<li><p><a href="https://github.com/dabeaz/ply">dabeaz / ply</a></p>
<ul>
<li>标签：</li>
<li>说明：</li>
</ul>
</li>
<li><p><a href="https://github.com/agronholm/apscheduler">agronholm / apscheduler</a></p>
<ul>
<li>标签：Python,工具</li>
<li>说明：类似于cron调度任务的库，比cron灵活，但没有celery重，同时支持Ｐｙｔｈｏｎ的各种异步生态(asynico, gevent, Tornado, twisted)</li>
</ul>
</li>
<li><p><a href="https://github.com/yujiangshui/A-Programmers-Guide-to-English">yujiangshui / A-Programmers-Guide-to-English</a></p>
<ul>
<li>标签：</li>
<li>说明：</li>
</ul>
</li>
<li><p><a href="https://github.com/lancetw/ebook-1">lancetw / ebook-1</a></p>
<ul>
<li>标签：书籍</li>
<li>说明：主要有c语言，Linux,算法，操作系统，网络协议等书籍。</li>
</ul>
</li>
<li><p><a href="https://github.com/royeo/awesome-programming-books">royeo / awesome-programming-books</a></p>
<ul>
<li>标签：书籍</li>
<li>说明：经典技术书籍 PDF 文件，涵盖：编程语言、计算机系统、网络协议、数据库、代码艺术、设计模式、算法与数据结构、系统架构、微服务、测试、程序员职业修炼等相关书籍。</li>
</ul>
</li>
<li><p><a href="https://github.com/faif/python-patterns">faif / python-patterns</a></p>
<ul>
<li>标签：Python</li>
<li>说明:  由于Python是一门动态语言，所以用Python实现的设计模式没有像Jave那样繁琐，或者有些设计模式根本不需要，这个库主要存放着使用Python实现的设计模式的示例代码</li>
</ul>
</li>
<li><p><a href="https://github.com/Snowming04/The-Hacker-Playbook-3-Translation">Snowming04 / The-Hacker-Playbook-3-Translation</a></p>
<ul>
<li>标签：书籍</li>
<li>说明：渗透测试实战第三版（红队版）</li>
</ul>
</li>
<li><p><a href="https://github.com/WilliamRen/awesome-stars">WilliamRen / awesome-stars</a></p>
<ul>
<li>标签：awesome</li>
<li>说明：一份很广的github收藏列表</li>
</ul>
</li>
<li><p><a href="https://github.com/sipwise/rtpengine">sipwise / rtpengine</a></p>
<ul>
<li>标签：sip</li>
<li>说明：一个Sip的高性能媒体代理</li>
</ul>
</li>
<li><p><a href="https://github.com/farmerjohngit/myblog">farmerjohngit / myblog</a></p>
<ul>
<li>标签：</li>
<li>说明：</li>
</ul>
</li>
<li><p><a href="https://github.com/iwannay/jiacrontab">iwannay / jiacrontab</a></p>
<ul>
<li>标签：工具</li>
<li>说明：提供web界面的任务调度工具</li>
</ul>
</li>
<li><p><a href="https://github.com/taizilongxu/stackoverflow_python">taizilongxu / stackoverflow_python</a></p>
<ul>
<li>标签：翻译</li>
<li>说明：stackoverflow上关于python的翻译</li>
</ul>
</li>
<li><p><a href="https://github.com/vinta/awesome-python">vinta / awesome-python</a></p>
<ul>
<li>标签：awesome</li>
<li>说明：一份包括Python框架，库，软件等的github收藏列表</li>
</ul>
</li>
<li><p><a href="https://github.com/Snailclimb/JavaGuide">Snailclimb / JavaGuide</a></p>
<ul>
<li>标签：</li>
<li>说明：</li>
</ul>
</li>
<li><p><a href="https://github.com/zergtant/pytorch-handbook">zergtant / pytorch-handbook</a></p>
<ul>
<li>标签：书籍</li>
<li>说明：pytorch handbook是一本开源的书籍，目标是帮助那些希望和使用PyTorch进行深度学习开发和研究的朋友快速入门，其中包含的Pytorch教程全部通过测试保证可以成功运行</li>
</ul>
</li>
<li><p><a href="https://github.com/cr0hn/aiohttp-cache">cr0hn / aiohttp-cache</a></p>
<ul>
<li>标签：源码学习</li>
<li>说明：基于aiohttp server编写的缓存</li>
</ul>
</li>
<li><p><a href="https://github.com/kennethreitz/requests-html">kennethreitz / requests-html</a></p>
<ul>
<li>标签：</li>
<li>说明：</li>
</ul>
</li>
<li><p><a href="https://github.com/tom0li/collection-document">tom0li / collection-document</a></p>
<ul>
<li>标签：awesome</li>
<li>说明：一份跟信息安全相关知识的收集</li>
</ul>
</li>
<li><p><a href="https://github.com/tamlok/vnote">tamlok / vnote</a></p>
<ul>
<li>标签：软件</li>
<li>说明：一个基于vim的可视化md编辑器</li>
</ul>
</li>
<li><p><a href="https://github.com/Q1mi/Django-REST-framework-documentation">Q1mi / Django-REST-framework-documentation</a></p>
<ul>
<li>标签：文档</li>
<li>说明：DRF文档</li>
</ul>
</li>
<li><p><a href="https://github.com/w1109790800/penetration">w1109790800 / penetration</a></p>
<ul>
<li>标签：awesome</li>
<li>说明：渗透相关收集</li>
</ul>
</li>
<li><p><a href="https://github.com/shadowsocksrr/shadowsocks-rss">shadowsocksrr / shadowsocks-rss</a></p>
<ul>
<li>标签：软件</li>
<li>说明：Emmmmm</li>
</ul>
</li>
<li><p><a href="https://github.com/Alvin9999/new-pac">Alvin9999 / new-pac</a></p>
<ul>
<li>标签：</li>
<li>说明：</li>
</ul>
</li>
<li><p><a href="https://github.com/caochun/aosabook.cc">caochun / aosabook.cc</a></p>
<ul>
<li>标签：书籍</li>
<li>说明：The Architecture of Open Source Applications中文文档仓库，中文官方网站已经没办法访问</li>
</ul>
</li>
<li><p><a href="https://github.com/Jack-Liang/kalitools">Jack-Liang / kalitools</a></p>
<ul>
<li>标签：文档</li>
<li>说明：Kali Linux 中文文档</li>
</ul>
</li>
<li><p><a href="https://github.com/wuyouzhuguli/FEBS-Vue">wuyouzhuguli / FEBS-Vue</a></p>
<ul>
<li>标签：</li>
<li>说明：</li>
</ul>
</li>
<li><p><a href="https://github.com/pbertera/SIPPing">pbertera / SIPPing</a></p>
<ul>
<li>标签：SIP</li>
<li>说明：SIP ping通测试（可以拓展为SIP接口功能测试）</li>
</ul>
</li>
<li><p><a href="https://github.com/fighting41love/cocoNLP">fighting41love / cocoNLP</a></p>
<ul>
<li>标签：工具，NLP</li>
<li>说明：中英文敏感词、语言检测、中外手机/电话归属地/运营商查询、名字推断性别、手机号抽取、身份证抽取、邮箱抽取、中日文人名库、中文缩写库、拆字词典、词汇情感值、停用词、反动词表、暴恐词表、繁简体转换、英文模拟中文发音、汪峰歌词生成器、职业名称词库、同义词库、反义词库、否定词库、汽车品牌词库、汽车零件词库、连续英文切割、各种中文词向量、公司名字大全、古诗词库、IT词库、财经词库、成语词库、地名词库、…</li>
</ul>
</li>
<li><p><a href="https://github.com/fighting41love/funNLP">fighting41love / funNLP</a></p>
<ul>
<li>标签：工具，NLP</li>
<li>说明：中文信息提取工具</li>
</ul>
</li>
<li><p><a href="https://github.com/pjialin/py12306">pjialin / py12306</a></p>
<ul>
<li>标签：工具</li>
<li>说明：12306 购票助手，支持分布式，多账号，多任务购票以及 Web 页面管理</li>
</ul>
</li>
<li><p><a href="https://github.com/Eyepea/aiosip">Eyepea / aiosip</a></p>
<ul>
<li>标签：Asynico, SIP</li>
<li>说明: 支持异步的sip</li>
</ul>
</li>
<li><p><a href="https://github.com/xpurer/pythonbook">xpurer / pythonbook</a></p>
<ul>
<li>标签：</li>
<li>说明：</li>
</ul>
</li>
<li><p><a href="https://github.com/casbin/pycasbin">casbin / pycasbin</a></p>
<ul>
<li>标签：工具，Python，源码学习</li>
<li>说明：一个类似于ACL的访问控制模型</li>
</ul>
</li>
<li><p><a href="https://github.com/aliyun/alibabacloud-python-sdk-v2">aliyun / alibabacloud-python-sdk-v2</a></p>
<ul>
<li>标签：</li>
<li>说明：</li>
</ul>
</li>
<li><p><a href="https://github.com/VincentSit/ChinaMobilePhoneNumberRegex">VincentSit / ChinaMobilePhoneNumberRegex</a></p>
<ul>
<li>标签：工具</li>
<li>说明：一组匹配中国大陆手机号码的正则表达式。</li>
</ul>
</li>
<li><p><a href="https://github.com/xitu/gold-miner">xitu / gold-miner</a></p>
<ul>
<li>标签：文档</li>
<li>说明：掘金翻译计划</li>
</ul>
</li>
<li><p><a href="https://github.com/EnableSecurity/sipvicious">EnableSecurity / sipvicious</a></p>
<ul>
<li>标签：</li>
<li>说明：</li>
</ul>
</li>
<li><p><a href="https://github.com/wuzhouhui/awk">wuzhouhui / awk</a></p>
<ul>
<li>标签：书籍</li>
<li>说明：AWK 程序设计语言,</li>
</ul>
</li>
<li><p><a href="https://github.com/idf/pover">https://github.com/idf/pover</a></p>
<ul>
<li>标签：</li>
<li>说明</li>
</ul>
</li>
<li><p><a href="https://github.com/newnius/short-link">newnius / short-link</a></p>
<ul>
<li>标签：</li>
<li>说明</li>
</ul>
</li>
<li><p><a href="https://github.com/NVIDIA/FastPhotoStyle">NVIDIA / FastPhotoStyle</a></p>
<ul>
<li>标签：工具，Python</li>
<li>说明：曾经登上githubTop10的库，基于Pytorch通过算法把2张图片合成一张图片</li>
</ul>
</li>
<li><p><a href="https://github.com/zeo1/a">zeo1 / a</a></p>
<ul>
<li>标签：文档</li>
<li>说明：个人知识体系: 自我管理(软技能) + 编程(硬技能)</li>
</ul>
</li>
<li><p><a href="https://github.com/clllanqing/solve_captcha">clllanqing / solve_captcha</a></p>
<ul>
<li>标签：工具</li>
<li>说明：破解各类验证码</li>
</ul>
</li>
<li><p><a href="https://github.com/kakuilan/china_area_mysql">kakuilan / china_area_mysql</a></p>
<ul>
<li>标签：工具</li>
<li>说明：中国5级行政区域mysql库</li>
</ul>
</li>
<li><p><a href="https://github.com/changtuiqie/WeChatAgreement">changtuiqie / WeChatAgreement</a></p>
<ul>
<li>标签：工具</li>
<li>说明：微信ipad协议、微信mac协议，可实现微信80%功能；支持62数据登录、扫码登录、收发朋友圈、查看朋友圈、微信建群、微信拉人进群、微信公众号阅读、微信消息收发、微信附近的人定位、微信添加好友、微信红包接收、微信防撤回、分享小程序、微信加粉、微信收藏、微信标签等</li>
</ul>
</li>
<li><p><a href="https://github.com/wklken/stackoverflow-py-top-qa">wklken / stackoverflow-py-top-qa</a></p>
<ul>
<li>标签：翻译，知识整理，Python</li>
<li>说明：stackoverflow上Python相关回答整理翻译</li>
</ul>
</li>
<li><p><a href="https://github.com/DIYgod/RSSHub">DIYgod / RSSHub</a></p>
<ul>
<li>标签：工具，RSS，Python</li>
<li>说明</li>
</ul>
</li>
<li><p><a href="https://github.com/ShichaoMa/apistellar">ShichaoMa / apistellar</a></p>
<ul>
<li>标签：源码学习，工具</li>
<li>说明：web框架apistar增强版，轻松构建企业级web项目</li>
<li>备注：项目已经变为starlette，apistart成为一个apidoc功能库</li>
</ul>
</li>
<li><p><a href="https://github.com/encode/starlette">encode / starlette</a></p>
<ul>
<li>标签：Python，工具</li>
<li>说明：一个类似于Falsk的Web库，支持Python的ASGI，代码风格也比sanic好，不过目前版本还没到1.0</li>
</ul>
</li>
<li><p><a href="https://github.com/iceyhexman/onlinetools">iceyhexman / onlinetools</a></p>
<ul>
<li>标签：工具</li>
<li>说明：在线cms识别|旁站|c段|信息泄露|工控|系统|物联网安全|cms漏洞扫描|nmap端口扫描|子域名获取|待续..</li>
</ul>
</li>
<li><p><a href="https://github.com/frank-lam/fullstack-tutorial">frank-lam / fullstack-tutorial</a></p>
<ul>
<li>标签：文档，整理</li>
<li>说明： rocket fullstack tutorial 2019，后台技术栈/架构师之路/全栈开发社区，春招/秋招/校招/面试</li>
</ul>
</li>
<li><p><a href="https://github.com/seb-m/pyinotify">seb-m / pyinotify</a></p>
<ul>
<li>标签：Python，工具</li>
<li>说明：一个可以在Python通过inotify来监测文件变化的库</li>
</ul>
</li>
<li><p><a href="https://github.com/boramalper/himawaripy">boramalper / himawaripy</a></p>
<ul>
<li>标签：Python，工具</li>
<li>说明：Set near-realtime picture of Earth as your desktop background</li>
</ul>
</li>
<li><p><a href="https://github.com/rootclay/Powershell-Attack-Guide">rootclay / Powershell-Attack-Guide</a></p>
<ul>
<li>标签：Python，渗透</li>
<li>说明：Powershell攻击指南—-黑客后渗透之道</li>
</ul>
</li>
<li><p><a href="https://github.com/B2W-BIT/aiologger">B2W-BIT / aiologger</a></p>
<ul>
<li>标签：Python，工具</li>
<li>说明：Asynchronous logging for python and asyncio</li>
</ul>
</li>
<li><p><a href="https://github.com/SFLAQiu/web-develop">SFLAQiu / web-develop</a></p>
<ul>
<li>标签：文档</li>
<li>说明： sparkles《大话WEB开发》WEB开发相关经验总结分享 fire</li>
</ul>
</li>
<li><p><a href="https://github.com/fy0/Icarus">fy0 / Icarus</a></p>
<ul>
<li>标签：Python，源码学习</li>
<li>说明： dove An opensource community/forum project write with python3 aiohttp and vue.js. 一个开源的社区程序，临时测试站：<a href="https://t.myrpg.cn/">https://t.myrpg.cn</a></li>
</ul>
</li>
<li><p><a href="https://github.com/yinwang0/pysonar2">yinwang0 / pysonar2</a></p>
<ul>
<li>标签：工具</li>
<li>说明：可以在IDE等工具中，推断出变量的类型</li>
</ul>
</li>
<li><p><a href="https://github.com/Ehco1996/aioshadowsocks">Ehco1996 / aioshadowsocks</a></p>
<ul>
<li>标签：工具，源码学习</li>
<li>说明：用Python的asynico写的socks5，主要学习如何迁移到asynico以及学习socks</li>
</ul>
</li>
<li><p><a href="https://github.com/PanJiaChen/vue-element-admin">PanJiaChen / vue-element-admin</a></p>
<ul>
<li>标签：工具</li>
<li>说明：基于Vue实现的admin</li>
</ul>
</li>
<li><p><a href="https://github.com/zutianbiao/baize">zutianbiao / baize</a></p>
<ul>
<li>标签：工具</li>
<li>说明：白泽自动化运维系统：配置管理、网络探测、资产管理、业务管理、CMDB、CD、DevOps、作业编排、任务编排等功能,未来将添加监控、报警、日志分析、大数据分析等部分内容</li>
</ul>
</li>
<li><p><a href="https://github.com/Neeky/mysqltools">Neeky / mysqltools</a></p>
<ul>
<li>标签：工具</li>
<li>说明：一个用于快速构建大规模，高质量，全自动化的 mysql分布式集群环境的工具；包含mysql 安装、备份、监控、高可用、读写分离、优化、巡检、自行化运维</li>
</ul>
</li>
<li><p><a href="https://github.com/findneo/Newbie-Security-List">findneo / Newbie-Security-List</a></p>
<ul>
<li>标签：文档</li>
<li>说明：网络安全学习资料，欢迎补充</li>
</ul>
</li>
<li><p><a href="https://github.com/SohuTech/essay">SohuTech / essay </a> </p>
<ul>
<li>标签：Python，工具</li>
<li>说明：Python项目自动化多服务器部署的工具</li>
</ul>
</li>
<li><p><a href="https://github.com/zaxlct/python-django-learning">zaxlct / python-django-learning</a></p>
<ul>
<li>标签：Python，整理，文档</li>
<li>说明： python 和 diango 学习资料，书籍，文章，以及实战项目等等</li>
</ul>
</li>
<li><p><a href="https://github.com/flaggo/pydu">flaggo / pydu</a></p>
<ul>
<li>标签：Python，整理</li>
<li>说明：一些对Python基础数据结构的调用进行封装</li>
</ul>
</li>
<li><p><a href="https://github.com/ashleysommer/sanic-dispatcher">ashleysommer / sanic-dispatcher</a></p>
<ul>
<li>标签：Python，工具</li>
<li>说明：A Dispatcher extension for Sanic which also acts as a Sanic-to-WSGI adapter</li>
</ul>
</li>
<li><p><a href="https://github.com/Zephery/weiboanalysis">Zephery / weiboanalysis</a></p>
<ul>
<li>标签：NLP</li>
<li>说明：微博情感分析，文本分类，毕业设计项目</li>
</ul>
</li>
<li><p><a href="https://github.com/tabler/tabler">tabler / tabler</a></p>
<ul>
<li>标签：工具</li>
<li>说明：一个基于Bootstrap4的admin</li>
</ul>
</li>
<li><p><a href="https://github.com/apachecn/awesome-algorithm">apachecn / awesome-algorithm</a></p>
<ul>
<li>标签：整理，算法，awesome</li>
<li>说明：各个语言的算法题</li>
</ul>
</li>
<li><p><a href="https://github.com/bluedazzle/wechat_sender">bluedazzle / wechat_sender</a></p>
<ul>
<li>标签：Python，工具</li>
<li>说明：利用微信机器人发送通知</li>
</ul>
</li>
<li><p><a href="https://github.com/ScrappyZhang/python_web_Crawler_DA_ML_DL">ScrappyZhang / python_web_Crawler_DA_ML_DL</a></p>
<ul>
<li>标签：Python，整理</li>
<li>说明：Python学习整理（从入门到…的路程）</li>
</ul>
</li>
<li><p><a href="https://github.com/aio-libs/aiohttp-remotes">aio-libs / aiohttp-remotes</a></p>
<ul>
<li>标签：</li>
<li>说明：</li>
</ul>
</li>
<li><p><a href="https://github.com/fate233/openwebmonitor">fate233 / openwebmonitor</a></p>
<ul>
<li>标签：工具</li>
<li>说明：万能网页监控器，监控物价、订单、出货、外汇、折扣、彩票…无所不能 </li>
</ul>
</li>
<li><p><a href="https://github.com/cr0hn/aiohttp-swagger">cr0hn / aiohttp-swagger</a></p>
<ul>
<li>标签：Asynico，Python</li>
<li>说明：Swagger API Documentation builder for aiohttp server </li>
</ul>
</li>
<li><p><a href="https://github.com/aio-libs/async_lru">aio-libs / async_lru</a></p>
<ul>
<li>标签：Asynico，Python，源码学习</li>
<li>说明：基于Asynico实现的lru</li>
</ul>
</li>
<li><p><a href="https://github.com/chiuxingxiang/Django-Blog">chiuxingxiang / Django-Blog</a></p>
<ul>
<li>标签：</li>
<li>说明：</li>
</ul>
</li>
<li><p><a href="https://github.com/paypal/api-standards">paypal / api-standards</a></p>
<ul>
<li>标签：文档</li>
<li>说明：如何设计API以及一些常用的资源如ISO，时间等等</li>
</ul>
</li>
<li><p><a href="https://github.com/Tougee/food-note">Tougee / food-note</a></p>
<ul>
<li>标签：其他</li>
<li>说明：没事纪录片</li>
</ul>
</li>
<li><p><a href="https://github.com/ausaki/python-validator">ausaki / python-validator</a></p>
<ul>
<li>标签：Python，源码学习</li>
<li>说明：a data validator like Django ORM</li>
</ul>
</li>
<li><p><a href="https://github.com/InterviewMap/CS-Interview-Knowledge-Map">InterviewMap / CS-Interview-Knowledge-Map</a></p>
<ul>
<li>标签：文档</li>
<li>说明：前端面试资源</li>
</ul>
</li>
<li><p><a href="https://github.com/zhihu/kids">zhihu / kids</a></p>
<ul>
<li>标签：工具</li>
<li>说明：知乎的日志收集系统，从实现</li>
</ul>
</li>
<li><p><a href="https://github.com/HT524/500LineorLess_CN">HT524 / 500LineorLess_CN</a></p>
<ul>
<li>标签：文档</li>
<li>说明：500line的中文版</li>
</ul>
</li>
<li><p><a href="https://github.com/wzyonggege/statistical-learning-method">wzyonggege / statistical-learning-method</a></p>
<ul>
<li>标签：文档，Python</li>
<li>说明：《统计学习方法》笔记-基于Python算法实现</li>
</ul>
</li>
<li><p><a href="https://github.com/zwczou/weixin-python">zwczou / weixin-python</a></p>
<ul>
<li>标签：文档，Python</li>
<li>说明： 微信SDK - 包括微信支付,微信公众号,微信登陆,微信消息处理等</li>
</ul>
</li>
<li><p><a href="https://github.com/Jolly23/wx_pay_python">Jolly23 / wx_pay_python</a></p>
<ul>
<li>标签：文档，Python</li>
<li>说明：weixin pay python 微信支付功能集，前期开发借鉴zwczou <a href="https://github.com/zwczou/weixin-python">https://github.com/zwczou/weixin-python</a> ，后期补充及完善微信支付新功能，处理因微信支付调用规则修改而无法使用的旧代码，升级到最新微信支付接口配套代码</li>
</ul>
</li>
<li><p><a href="https://github.com/chai2010/advanced-go-programming-book">chai2010 / advanced-go-programming-book</a></p>
<ul>
<li>标签：书籍</li>
<li>说明：《Go语言高级编程》开源图书，涵盖CGO、Go汇编语言、RPC实现、Protobuf插件实现、Web框架实现、分布式系统等高阶主题(完稿)</li>
</ul>
</li>
<li><p><a href="https://github.com/aio-libs/aiologstash">aio-libs / aiologstash</a></p>
<ul>
<li>标签：Python，Asynico，工具，源码学习</li>
<li>说明： asyncio logging handler for logstash</li>
</ul>
</li>
<li><p><a href="https://github.com/aamalev/aiohttp_apiset">aamalev / aiohttp_apiset</a></p>
<ul>
<li>标签：</li>
<li>说明：</li>
</ul>
</li>
<li><p><a href="https://github.com/ashleysommer/sanicpluginsframework">ashleysommer / sanicpluginsframework</a></p>
<ul>
<li>标签：Python，Asynico，源码学习</li>
<li>说明：Sanic的增强插件</li>
</ul>
</li>
<li><p><a href="https://github.com/monobot/asyncorm">monobot / asyncorm</a></p>
<ul>
<li>标签：Python，Asynico</li>
<li>说明： Fully Async ORM inspired in django’s</li>
</ul>
</li>
<li><p><a href="https://github.com/yidao620c/core-algorithm">yidao620c / core-algorithm</a></p>
<ul>
<li>标签：算法，Python</li>
<li>说明：《算法导论》(第3版) 算法集锦，题目用Python 实现</li>
</ul>
</li>
<li><p><a href="https://github.com/mikeyy/nonoCAPTCHA">mikeyy / nonoCAPTCHA</a></p>
<ul>
<li>标签：</li>
<li>说明：</li>
</ul>
</li>
<li><p><a href="https://github.com/avidLearnerInProgress/pyCAIR">avidLearnerInProgress / pyCAIR</a></p>
<ul>
<li>标签：Python，NLP</li>
<li>说明：裁剪时，更改图片内容，使其内容看起来不会被拉伸</li>
</ul>
</li>
<li><p><a href="https://github.com/zhu327/doge">zhu327 / doge</a></p>
<ul>
<li>标签：Python，工具，源码学习</li>
<li>说明：一个基于Python的高性能开源RPC框架</li>
</ul>
</li>
<li><p><a href="https://github.com/huge-success/sanic-openapi">huge-success / sanic-openapi</a></p>
<ul>
<li>标签：Python，工具</li>
<li>说明： Easily document your Sanic API with a UI</li>
</ul>
</li>
<li><p><a href="https://github.com/bohea/sanic-limiter">bohea / sanic-limiter</a></p>
<ul>
<li>标签：Python，工具</li>
<li>说明： Provides rate limiting features for Sanic. Supports in-memory, redis and memcache as storage.</li>
</ul>
</li>
<li><p><a href="https://github.com/songcser/sanic-ms">songcser / sanic-ms</a></p>
<ul>
<li>标签：Python，源码学习</li>
<li>说明：基于sanic的微服务基础架构</li>
</ul>
</li>
<li><p><a href="https://github.com/toddmotto/public-apis">toddmotto / public-apis</a></p>
<ul>
<li>标签：整理</li>
<li>说明：软件和Web开发的免费API集合</li>
</ul>
</li>
<li><p><a href="https://github.com/mohanson/daze">mohanson / daze</a></p>
<ul>
<li>标签：</li>
<li>说明：</li>
</ul>
</li>
<li><p><a href="https://github.com/RobbieHan/gistandard">RobbieHan / gistandard</a></p>
<ul>
<li>标签：</li>
<li>说明：</li>
</ul>
</li>
<li><p><a href="https://github.com/python-attrs/attrs">python-attrs / attrs</a></p>
<ul>
<li>标签：Python，工具</li>
<li>说明：类似于PYthon dataclass的功能实现</li>
</ul>
</li>
<li><p><a href="https://github.com/encode/apistar">encode / apistar</a></p>
<ul>
<li>标签：</li>
<li>说明：</li>
</ul>
</li>
<li><p><a href="https://github.com/sonichy/CMDU_DDE_DOCK">sonichy / CMDU_DDE_DOCK</a></p>
<ul>
<li><p>标签：工具</p>
</li>
<li><p>说明：深度 Linux 系统网速任务栏插件，鼠标悬浮显示开机时间、CPU使用率、内存使用率、下载字节、上传字节。</p>
</li>
</ul>
</li>
<li><p><a href="https://github.com/ictar/python-doc">ctar / python-doc</a></p>
<ul>
<li>标签：文档，Python</li>
<li>说明： 简而言之，这里用来存放那些Python文档君们，并且尽力将其翻译成中文~~</li>
</ul>
</li>
<li><p><a href="https://github.com/jobbole/awesome-python-cn">jobbole / awesome-python-cn</a></p>
<ul>
<li>标签：文档，整理，awesome</li>
<li>说明：Python资源大全中文版，包括：Web框架、网络爬虫、模板引擎、数据库、数据可视化、图片处理等，由伯乐在线持续更新。</li>
</ul>
</li>
<li><p><a href="https://github.com/facert/python-data-structure-cn">facert / python-data-structure-cn</a></p>
<ul>
<li>标签：书籍，Python</li>
<li>说明： problem-solving-with-algorithms-and-data-structure-using-python 中文版</li>
</ul>
</li>
<li><p><a href="https://github.com/huginn/huginn">huginn / huginn</a></p>
<ul>
<li>标签：工具</li>
<li>说明：能通过监控自己要的网络数据，当网络数据发生变化时通知用户，支持的功能很多，可以通过文档了解。</li>
</ul>
</li>
<li><p><a href="https://github.com/donnemartin/system-design-primer">donnemartin / system-design-primer</a></p>
<ul>
<li>标签：文档</li>
<li>说明：了解如何设计大型系统。准备系统设计面试。</li>
</ul>
</li>
<li><p><a href="https://github.com/luhuisicnu/The-Flask-Mega-Tutorial-zh">luhuisicnu / The-Flask-Mega-Tutorial-zh</a></p>
<ul>
<li>标签：书籍</li>
<li>说明：翻译自Miguel Grinberg的blog <a href="https://blog.miguelgrinberg.com/">https://blog.miguelgrinberg.com</a> 的2017年新版The Flask Mega-Tutorial教程</li>
</ul>
</li>
<li><p><a href="https://github.com/shimohq/chinese-programmer-wrong-pronunciation">shimohq / chinese-programmer-wrong-pronunciation</a></p>
<ul>
<li>标签：整理</li>
<li>说明：中国程序员容易发音错误的单词</li>
</ul>
</li>
<li><p><a href="https://github.com/davideuler/architecture.of.internet-product">davideuler / architecture.of.internet-product</a></p>
<ul>
<li>标签：整理，文档</li>
<li>说明： 互联网公司技术架构，微信/淘宝/微博/腾讯/阿里/美团点评/百度/Google/Facebook/Amazon/eBay的架构</li>
</ul>
</li>
<li><p><a href="https://github.com/xingshaocheng/architect-awesome">xingshaocheng / architect-awesome</a></p>
<ul>
<li>标签：整理</li>
<li>说明： 后端架构师技术图谱</li>
</ul>
</li>
<li><p><a href="https://github.com/PyCN/Python-Guide-CN">PyCN / Python-Guide-CN</a></p>
<ul>
<li>标签：Python，整理</li>
<li>说明：Python最佳实践指南</li>
</ul>
</li>
<li><p><a href="https://github.com/jianshijiuyou/django-rest-framework-api-guide">jianshijiuyou / django-rest-framework-api-guide</a></p>
<ul>
<li>标签：书籍</li>
<li>说明： 《The Way to Go》中文译本，中文正式名《Go 入门指南》</li>
</ul>
</li>
<li><p><a href="https://github.com/jianshijiuyou/django-rest-framework-api-guide">jianshijiuyou / django-rest-framework-api-guide</a></p>
<ul>
<li>标签：文档</li>
<li>说明：DRF API指南文档</li>
</ul>
</li>
<li><p><a href="https://github.com/fantix/gino">fantix / gino</a></p>
<ul>
<li>标签：Python，Asynico，工具</li>
<li>说明： 是一个轻量级的异步ORM，构建在Python asyncio的 SQLAlchemy核心之上</li>
</ul>
</li>
<li><p><a href="https://github.com/locustio/locust">locustio / locust</a></p>
<ul>
<li>标签：Python，工具</li>
<li>说明：性能压测工具</li>
</ul>
</li>
<li><p><a href="https://github.com/laixintao/python-parallel-programming-cookbook-cn">laixintao / python-parallel-programming-cookbook-cn</a></p>
<ul>
<li>标签：书籍，Python</li>
<li>说明：Python Parallel Programming Cookbook》中文版</li>
</ul>
</li>
<li><p><a href="https://github.com/lepture/mistune">lepture / mistune</a></p>
<ul>
<li>标签：Python，工具，MarkDown</li>
<li>说明：使用纯Python的MarkDown解析器</li>
</ul>
</li>
<li><p><a href="https://github.com/wossl33/wossl">wossl33 / wossl</a></p>
<ul>
<li>标签：工具</li>
<li>说明：OpenSSL对称算法、哈希校验、非对称算法、证书管理、SSL安全</li>
</ul>
</li>
<li><p><a href="https://github.com/howie6879/Sanic-For-Pythoneer">howie6879 / Sanic-For-Pythoneer</a></p>
<ul>
<li>标签：</li>
<li>说明：</li>
</ul>
</li>
<li><p><a href="https://github.com/jpadilla/pyjwt">jpadilla / pyjwt</a></p>
<ul>
<li>标签：Python，工具</li>
<li>说明： JSON Web Token implementation in Python</li>
</ul>
</li>
<li><p><a href="https://github.com/coleifer/peewee">coleifer / peewee</a></p>
<ul>
<li>标签：Python，工具</li>
<li>说明： a small, expressive orm – supports postgresql, mysql and sqlite</li>
</ul>
</li>
<li><p><a href="https://github.com/falconry/falcon">falconry / falcon</a></p>
<ul>
<li>标签：Python，工具</li>
<li>说明： Falcon is a bare-metal Python web API framework for building high-performance microservices, app backends, and higher-level frameworks.</li>
</ul>
</li>
<li><p><a href="https://github.com/toastdriven/restless">toastdriven / restless</a></p>
<ul>
<li>标签：Python，工具</li>
<li>说明： A lightweight REST miniframework for Python.</li>
</ul>
</li>
<li><p><a href="https://github.com/pythonzhichan/DailyQuestion">pythonzhichan / DailyQuestion</a></p>
<ul>
<li>标签：</li>
<li>说明：</li>
</ul>
</li>
<li><p><a href="https://github.com/chaozh/awesome-blockchain-cn">chaozh / awesome-blockchain-cn</a></p>
<ul>
<li>标签：整理，awesome</li>
<li>说明： 收集所有区块链(BlockChain)技术开发相关资料，包括Fabric和Ethereum开发资料</li>
</ul>
</li>
<li><p><a href="https://github.com/CyC2018/CS-Notes">CyC2018 / CS-Notes</a></p>
<ul>
<li>标签：整理</li>
<li>说明： 技术面试必备基础知识</li>
</ul>
</li>
<li><p><a href="https://github.com/1c7/chinese-independent-developer">1c7 / chinese-independent-developer</a></p>
<ul>
<li>标签：整理</li>
<li>说明：中国独立开发者项目列表 – 分享大家都在做什么</li>
</ul>
</li>
<li><p><a href="https://github.com/enocom/gopher-reading-list">enocom / gopher-reading-list</a></p>
<ul>
<li>标签：整理</li>
<li>说明：gopher阅读清单</li>
</ul>
</li>
<li><p><a href="https://github.com/Prodesire/Python-Guide-CN">Prodesire / Python-Guide-CN</a></p>
<ul>
<li>标签：文档</li>
<li>说明： Python最佳实践指南</li>
</ul>
</li>
<li><p><a href="https://github.com/pavlodvornikov/aiocfscrape">pavlodvornikov / aiocfscrape</a></p>
<ul>
<li>标签：</li>
<li>说明：</li>
</ul>
</li>
<li><p><a href="https://github.com/byoungd/English-level-up-tips-for-Chinese">byoungd / English-level-up-tips-for-Chinese</a></p>
<ul>
<li>标签：英语</li>
<li>说明： 可能是让你受益匪浅的英语进阶指南</li>
</ul>
</li>
<li><p><a href="https://github.com/Miksztowi/Leetcode">Miksztowi / Leetcode</a></p>
<ul>
<li>标签：Python</li>
<li>说明： Code by Python and begin at 10 September 2017.</li>
</ul>
</li>
<li><p><a href="https://github.com/IFmiss/vue-music">IFmiss / vue-music</a></p>
<ul>
<li>标签：</li>
<li>说明：</li>
</ul>
</li>
<li><p><a href="https://github.com/iview/iview-admin">iview / iview-admin</a></p>
<ul>
<li>标签：</li>
<li>说明：</li>
</ul>
</li>
<li><p><a href="https://github.com/ant-design/ant-design-pro">ant-design / ant-design-pro</a></p>
<ul>
<li>标签：</li>
<li>说明：</li>
</ul>
</li>
<li><p><a href="https://github.com/coreui/coreui-free-vue-admin-template">coreui / coreui-free-vue-admin-template</a></p>
<ul>
<li>标签：</li>
<li>说明：</li>
</ul>
</li>
<li><p><a href="https://github.com/binux/pyspider">binux / pyspider</a></p>
<ul>
<li>标签：Python，工具</li>
<li>说明：基于Python的带web界面的爬虫框架</li>
</ul>
</li>
<li><p><a href="https://github.com/jiajunhuang/storm">jiajunhuang / storm</a></p>
<ul>
<li>标签：Python， 工具</li>
<li>说明： a Tornado-like web framework based on uvloop and Cython</li>
</ul>
</li>
<li><p><a href="https://github.com/gaojiuli/gain">gaojiuli / gain</a></p>
<ul>
<li>标签：Python，Asynico，工具</li>
<li>说明：基于asynico的爬虫框架</li>
</ul>
</li>
<li><p><a href="https://github.com/mqingyn/torngas">mqingyn / torngas</a></p>
<ul>
<li>标签：Python，工具</li>
<li>说明：基于<a href="https://github.com/tornadoweb/tornado">Tornado</a>的web mvc框架。Torngas 大量参考和借鉴了Django的设计模式，形成一套基于tornado的Django like应用层开发框架。tornado 建议使用4.0以上版本,注意：torngas不支持基于WSGI的应用。</li>
</ul>
</li>
<li><p><a href="https://github.com/aosabook/500lines">aosabook / 500lines</a></p>
<ul>
<li>标签：学习</li>
<li>说明： 500 Lines or Less</li>
</ul>
</li>
<li><p><a href="https://github.com/Manisso/fsociety">Manisso / fsociety</a></p>
<ul>
<li>标签：渗透</li>
<li>说明：一个渗透测试框架</li>
</ul>
</li>
<li><p><a href="https://github.com/keon/algorithms">keon / algorithms</a></p>
<ul>
<li>标签：算法</li>
<li>说明： Minimal examples of data structures and algorithms in Python</li>
</ul>
</li>
<li><p><a href="https://github.com/lebinh/ngxtop">lebinh / ngxtop</a></p>
<ul>
<li>标签：工具</li>
<li>说明： Real-time metrics for nginx server</li>
</ul>
</li>
<li><p><a href="https://github.com/tipsy/profile-summary-for-github">tipsy / profile-summary-for-github</a></p>
<ul>
<li>标签：工具</li>
<li>说明：根据用户名统计github上的数据</li>
</ul>
</li>
<li><p><a href="https://github.com/wangdoc/javascript-tutorial">wangdoc / javascript-tutorial</a></p>
<ul>
<li>标签：文档</li>
<li>说明：JS教程</li>
</ul>
</li>
<li><p><a href="https://github.com/smartFlash/pySecurity">smartFlash / pySecurity</a></p>
<ul>
<li>标签：文档</li>
<li>说明：Python部分入门教程翻译</li>
</ul>
</li>
<li><p><a href="https://github.com/7anshuai/pyreds">7anshuai / pyreds</a></p>
<ul>
<li>标签：Python，工具</li>
<li>说明：基于PYthon的简单全文搜索模块，backed by redis</li>
</ul>
</li>
<li><p><a href="https://github.com/taizilongxu/interview_python">taizilongxu / interview_python</a></p>
<ul>
<li>标签：Python</li>
<li>说明： 关于Python的面试题</li>
</ul>
</li>
<li><p><a href="https://github.com/BrambleXu/pydata-notebook">BrambleXu / pydata-notebook</a></p>
<ul>
<li>标签：Python，整理</li>
<li>说明： 利用Python进行数据分析 第二版 (2017) 中文翻译笔记</li>
</ul>
</li>
<li><p><a href="https://github.com/nekocode/tornaREST">nekocode / tornaREST</a></p>
<ul>
<li>标签：Python，工具</li>
<li>说明： A simple RESTful Web Service build with Tornado.</li>
</ul>
</li>
<li><p><a href="https://github.com/jasonding1354/pyDataScienceToolkits_Base">jasonding1354 / pyDataScienceToolkits_Base</a></p>
<ul>
<li>标签：Python，工具</li>
<li>说明： 使用Python进行数据分析实验工具NumPy、Pandas、Matplotlib、Scikit-learn的入门介绍，使用IPython Notebook格式</li>
</ul>
</li>
<li><p><a href="https://github.com/TonnyL/Awesome_APIs">TonnyL / Awesome_APIs</a></p>
<ul>
<li>标签：工具</li>
<li>说明：A collection of APIs</li>
</ul>
</li>
<li><p><a href="https://github.com/17mon/china_ip_list">17mon / china_ip_list</a></p>
<ul>
<li>标签：整理</li>
<li>说明：中国ip地址库</li>
</ul>
</li>
<li><p><a href="https://github.com/PyCN/opensource">PyCN / opensource</a></p>
<ul>
<li>标签：整理</li>
<li>说明：Python 开源库及示例代码</li>
</ul>
</li>
<li><p><a href="https://github.com/jokermonn/-Api">jokermonn / -Api</a></p>
<ul>
<li>标签：</li>
<li>说明：</li>
</ul>
</li>
<li><p><a href="https://github.com/gavin66/proxy_list">gavin66 / proxy_list</a></p>
<ul>
<li>标签：</li>
<li>说明：</li>
</ul>
</li>
<li><p><a href="https://github.com/lufficc/flask_ishuhui">lufficc / flask_ishuhui</a></p>
<ul>
<li>标签：</li>
<li>说明：</li>
</ul>
</li>
<li><p><a href="https://github.com/xtuJSer/CoCoMusic">xtuJSer / CoCoMusic</a></p>
<ul>
<li>标签：</li>
<li>说明：</li>
</ul>
</li>
<li><p><a href="https://github.com/satwikkansal/wtfpython">satwikkansal / wtfpython</a></p>
<ul>
<li>标签：Python</li>
<li>说明： A collection of surprising Python snippets and lesser-known features.</li>
</ul>
</li>
<li><p><a href="https://github.com/tensorflow/models">tensorflow / models</a></p>
<ul>
<li>标签：</li>
<li>说明：</li>
</ul>
</li>
<li><p><a href="https://github.com/hangsz/pandas-tutorial">hangsz / pandas-tutorial</a></p>
<ul>
<li>标签：</li>
<li>说明：</li>
</ul>
</li>
<li><p><a href="https://github.com/ziishaned/learn-regex">ziishaned / learn-regex</a></p>
<ul>
<li>标签：</li>
<li>说明：</li>
</ul>
</li>
<li><p><a href="https://github.com/jhao104/proxy_pool">jhao104 / proxy_pool</a></p>
<ul>
<li>标签：</li>
<li>说明：</li>
</ul>
</li>
<li><p><a href="https://github.com/PyCN/Nyspider">PyCN / Nyspider</a></p>
<ul>
<li>标签：</li>
<li>说明：</li>
</ul>
</li>
<li><p><a href="https://github.com/so1n/commentbox">so1n / commentbox</a></p>
<ul>
<li>标签：</li>
<li>说明：</li>
</ul>
</li>
<li><p><a href="https://github.com/luyishisi/Anti-Anti-Spider">luyishisi / Anti-Anti-Spider</a></p>
<ul>
<li>标签：</li>
<li>说明：</li>
</ul>
</li>
<li><p><a href="https://github.com/Nyloner/Nyspider">Nyloner / Nyspider</a></p>
<ul>
<li>标签：</li>
<li>说明：</li>
</ul>
</li>
<li><p><a href="https://github.com/tesseract-ocr/tesseract">tesseract-ocr / tesseract</a></p>
<ul>
<li>标签：</li>
<li>说明：</li>
</ul>
</li>
<li><p><a href="https://github.com/justjavac/free-programming-books-zh_CN">justjavac / free-programming-books-zh_CN</a></p>
<ul>
<li>标签：书籍</li>
<li>说明： 免费的计算机编程类中文书籍</li>
</ul>
</li>
<li><p><a href="https://github.com/wizardforcel/sicp-py-zh">wizardforcel / sicp-py-zh</a></p>
<ul>
<li>标签：书籍</li>
<li>说明：UCB CS61a SICP Python（中文版）</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>文档</category>
      </categories>
      <tags>
        <tag>收藏</tag>
      </tags>
  </entry>
  <entry>
    <title>使用python实现tail</title>
    <url>/2019/03/07/%E4%BD%BF%E7%94%A8Python%E5%AE%9E%E7%8E%B0tail/</url>
    <content><![CDATA[<h2 id="前记"><a href="#前记" class="headerlink" title="前记"></a>前记</h2><p>tail是一个常用的Linux命令, 它可以打印文件的后面n行数据, 也能实时输出文件的追加数据.<br>tail的实现很简单,但是要实现一个完善的tail却需要考虑很多细节,如果要注重性能,则需要引入一些其他的机制.</p>
<span id="more"></span>
<p>一开始只是为了单纯的实现Linux的<code>tail</code>的基本功能,后面随着需要对日志文件的高性能读取则需要的Linux的<code>inotify</code>机制去完善.<br>相关源码见:<a href="https://github.com/so1n/example/tree/master/example_python/example_python/tail">https://github.com/so1n/example/tree/master/example_python/example_python/tail</a></p>
<h2 id="1-第一版–从文件尾部读取实时数据"><a href="#1-第一版–从文件尾部读取实时数据" class="headerlink" title="1.第一版–从文件尾部读取实时数据"></a>1.第一版–从文件尾部读取实时数据</h2><p>主要思路是: 打开文件, 把指针移动到文件最后, 然后有数据则输出数据, 无数据则休眠一段时间.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> sys<br><br><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> Callable, NoReturn<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Tail</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">            self,</span></span><br><span class="hljs-function"><span class="hljs-params">            file_name: <span class="hljs-built_in">str</span>,</span></span><br><span class="hljs-function"><span class="hljs-params">            output: Callable[[<span class="hljs-built_in">str</span>], NoReturn] = sys.stdout.write,</span></span><br><span class="hljs-function"><span class="hljs-params">            interval: <span class="hljs-built_in">int</span> = <span class="hljs-number">1</span></span></span><br><span class="hljs-function"><span class="hljs-params">    </span>):</span><br>        self.file_name: <span class="hljs-built_in">str</span> = file_name<br>        self.output: Callable[[<span class="hljs-built_in">str</span>], NoReturn] = output<br>        self.interval: <span class="hljs-built_in">int</span> = interval<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__call__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(self.file_name) <span class="hljs-keyword">as</span> f:<br>            f.seek(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>)  <span class="hljs-comment"># 从文件结尾处开始seek</span><br>            <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>                line: <span class="hljs-built_in">str</span> = f.readline()<br>                <span class="hljs-keyword">if</span> line:<br>                    self.output(line)  <span class="hljs-comment"># 使用print都会每次都打印新的一行</span><br>                <span class="hljs-keyword">else</span>:<br>                    time.sleep(self.interval)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    filename: <span class="hljs-built_in">str</span> = sys.argv[<span class="hljs-number">0</span>]<br>    Tail(filename)()<br></code></pre></td></tr></table></figure>
<p>之后只要做如下调用即可:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs Bash">python xxx.py filename <br></code></pre></td></tr></table></figure>
<h2 id="2-第二版–实现tail-f"><a href="#2-第二版–实现tail-f" class="headerlink" title="2.第二版–实现tail -f"></a>2.第二版–实现<code>tail -f</code></h2><p><code>tail -f</code>默认先读取最后10行数据,再从文件尾部读取实时数据.如果对于小文件,可以先读取所有文件内容,并输出最后10行, 但是读取全文再获取最后10行的性能不高, 而从后滚10行的边界条件也很复杂, 先看先读取全文再获取最后10行的实现:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> sys<br><br><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> Callable, NoReturn<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Tail</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">            self,</span></span><br><span class="hljs-function"><span class="hljs-params">            file_name: <span class="hljs-built_in">str</span>,</span></span><br><span class="hljs-function"><span class="hljs-params">            output: Callable[[<span class="hljs-built_in">str</span>], NoReturn] = sys.stdout.write,</span></span><br><span class="hljs-function"><span class="hljs-params">            interval: <span class="hljs-built_in">int</span> = <span class="hljs-number">1</span></span></span><br><span class="hljs-function"><span class="hljs-params">    </span>):</span><br>        self.file_name: <span class="hljs-built_in">str</span> = file_name<br>        self.output: Callable[[<span class="hljs-built_in">str</span>], NoReturn] = output<br>        self.interval: <span class="hljs-built_in">int</span> = interval<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__call__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(self.file_name) <span class="hljs-keyword">as</span> f:<br>            self.read_last_line(f)<br>            <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>                line: <span class="hljs-built_in">str</span> = f.readline()<br>                <span class="hljs-keyword">if</span> line:<br>                    self.output(line)  <span class="hljs-comment"># 使用print都会每次都打印新的一行</span><br>                <span class="hljs-keyword">else</span>:<br>                    time.sleep(self.interval)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">read_last_line</span>(<span class="hljs-params">self, f</span>):</span><br>        last_lines = f.readlines()[-<span class="hljs-number">10</span>:]<br>        <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> last_lines:<br>            self.output(line)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    filename: <span class="hljs-built_in">str</span> = sys.argv[<span class="hljs-number">0</span>]<br>    Tail(filename)()   <br></code></pre></td></tr></table></figure>
<p>可以看到实现很简单, 相比第一版只多了个<code>read_last_line的函数</code>, 接下来就要解决性能的问题了, 当文件很大的时候, 这个逻辑是不行的, 特别是有些日志文件经常有几个G大, 如果全读出来内存就爆了. 而在Linux系统中, 没有一个接口可以指定指针跳到倒数10行, 只能使用如下方法来模拟输出倒数10行:</p>
<ul>
<li>首先游标跳转到最新的字符, 保存当前游标, 然后预估一行数据的字符长度, 最好偏多, 这里我按1024字符长度为一行来处理</li>
<li>然后利用seek的方法,跳转到seek(-1024 * 10, 2)的字符, 这就是我们预估的倒数10行内的内容</li>
<li>接着对内容进行判断, 如果跳转的字符长度小于 10 * 1024, 则证明整个文件没有10行, 则采用原来的<code>read_last_line</code>方法.</li>
<li>如果跳转到字符长度等于1024 * 10, 则利用换行符计算已取字符长度共有多少行,如果行数大于10,那只输出最后10行,如果只读了4行,则继续读6*1024,直到读满10行为止</li>
</ul>
<p>通过以上步奏, 就把倒数10行的数据计算好了可以打印出来, 可以进入追加数据了, 但是这时候文件内容可能发生改变了, 我们的游标也发生改变了, 这时候要把游标跳回到刚才保存的游标,防止漏打或者重复打印数据.</p>
<p>分析完毕后, 就可以开始重构<code>read_last_line</code>函数了.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> sys<br><br><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> Callable, List, NoReturn<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Tail</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">            self,</span></span><br><span class="hljs-function"><span class="hljs-params">            file_name: <span class="hljs-built_in">str</span>,</span></span><br><span class="hljs-function"><span class="hljs-params">            output: Callable[[<span class="hljs-built_in">str</span>], NoReturn] = sys.stdout.write,</span></span><br><span class="hljs-function"><span class="hljs-params">            interval: <span class="hljs-built_in">int</span> = <span class="hljs-number">1</span>,</span></span><br><span class="hljs-function"><span class="hljs-params">            len_line: <span class="hljs-built_in">int</span> = <span class="hljs-number">1024</span></span></span><br><span class="hljs-function"><span class="hljs-params">    </span>):</span><br>        self.file_name: <span class="hljs-built_in">str</span> = file_name<br>        self.output: Callable[[<span class="hljs-built_in">str</span>], NoReturn] = output<br>        self.interval: <span class="hljs-built_in">int</span> = interval<br>        self.len_line: <span class="hljs-built_in">int</span> = len_line<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__call__</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span> = <span class="hljs-number">10</span></span>):</span><br>        <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(self.file_name) <span class="hljs-keyword">as</span> f:<br>            self.read_last_line(f, n)<br>            <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>                line: <span class="hljs-built_in">str</span> = f.readline()<br>                <span class="hljs-keyword">if</span> line:<br>                    self.output(line)  <span class="hljs-comment"># 使用print都会每次都打印新的一行</span><br>                <span class="hljs-keyword">else</span>:<br>                    time.sleep(self.interval)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">read_last_line</span>(<span class="hljs-params">self, file, n</span>):</span><br>        read_len: <span class="hljs-built_in">int</span> = self.len_line * n<br><br>        <span class="hljs-comment"># 跳转游标到最后</span><br>        file.seek(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>)<br>        <span class="hljs-comment"># 获取当前结尾的游标位置</span><br>        now_tell: <span class="hljs-built_in">int</span> = file.tell()<br>        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>            <span class="hljs-keyword">if</span> read_len &gt; file.tell():<br>                <span class="hljs-comment"># 如果跳转的字符长度大于原来文件长度,那就把所有文件内容打印出来</span><br>                file.seek(<span class="hljs-number">0</span>) <span class="hljs-comment"># 由于read方法是按照游标进行打印, 所以要重置游标</span><br>                last_line_list: List[<span class="hljs-built_in">str</span>] = file.read().split(<span class="hljs-string">&#x27;\n&#x27;</span>)[-n:]<br>                <span class="hljs-comment"># 重新获取游标位置</span><br>                now_tell: <span class="hljs-built_in">int</span> = file.tell()<br>                <span class="hljs-keyword">break</span><br>            <span class="hljs-comment"># 跳转到我们预估的字符位置</span><br>            file.seek(-read_len, <span class="hljs-number">2</span>)<br>            read_str: <span class="hljs-built_in">str</span> = file.read(read_len)<br>            cnt: <span class="hljs-built_in">int</span> = read_str.count(<span class="hljs-string">&#x27;\n&#x27;</span>)<br>            <span class="hljs-keyword">if</span> cnt &gt;= n:<br>                <span class="hljs-comment"># 如果获取的行数大于要求的行数,则获取前n行的行数</span><br>                last_line_list: List[<span class="hljs-built_in">str</span>] = read_str.split(<span class="hljs-string">&#x27;\n&#x27;</span>)[-n:]<br>                <span class="hljs-keyword">break</span><br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-comment"># 如果获取的行数小于要求的行数,则预估需要获取的行数,继续获取</span><br>                <span class="hljs-keyword">if</span> cnt == <span class="hljs-number">0</span>:<br>                    line_per: <span class="hljs-built_in">int</span> = read_len<br>                <span class="hljs-keyword">else</span>:<br>                    line_per: <span class="hljs-built_in">int</span> = <span class="hljs-built_in">int</span>(read_len / cnt)<br>                read_len = line_per * n<br><br>        <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> last_line_list:<br>            self.output(line + <span class="hljs-string">&#x27;\n&#x27;</span>)<br>        <span class="hljs-comment"># 重置游标,确保接下来打印的数据不重复</span><br>        file.seek(now_tell)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-keyword">import</span> argparse<br><br>    parser = argparse.ArgumentParser()<br>    parser.add_argument(<span class="hljs-string">&quot;-f&quot;</span>, <span class="hljs-string">&quot;--filename&quot;</span>)<br>    parser.add_argument(<span class="hljs-string">&quot;-n&quot;</span>, <span class="hljs-string">&quot;--num&quot;</span>, default=<span class="hljs-number">10</span>)<br>    args, unknown = parser.parse_known_args()<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> args.filename:<br>        <span class="hljs-keyword">raise</span> RuntimeError(<span class="hljs-string">&#x27;filename args error&#x27;</span>)<br>    Tail(args.filename)(<span class="hljs-built_in">int</span>(args.num))<br></code></pre></td></tr></table></figure>

<h2 id="3-第三版–优雅的读取输出日志文件"><a href="#3-第三版–优雅的读取输出日志文件" class="headerlink" title="3.第三版–优雅的读取输出日志文件"></a>3.第三版–优雅的读取输出日志文件</h2><p>可以发现实时读取那块的逻辑性能还是很差, 如果每秒读一次文件,实时性就太慢了,把间隔改小了,则处理器占用太多. 性能最好的情况是如果能得知文件更新再进行打印文件, 那性能就能得到保障了.庆幸的是,在Linux中<code>inotify</code>提供了这样的功能.<br>此外,日志文件有一个特点就是会进行logrotate,如果日志被logrotate了,那我们就需要重新打开文件,并进一步读取数据, 这种情况也可以利用到<code>inotify</code>, 当<code>inotify</code>获取到文件重新打开的事件时,我们就重新打开文件,再读取.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> sys<br><br><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> Callable, List, NoReturn<br><br><span class="hljs-keyword">import</span> pyinotify<br><br>multi_event = pyinotify.IN_MODIFY | pyinotify.IN_MOVE_SELF  <span class="hljs-comment"># 监控多个事件</span><br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InotifyEventHandler</span>(<span class="hljs-params">pyinotify.ProcessEvent</span>):</span>  <span class="hljs-comment"># 定制化事件处理类，注意继承</span><br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    执行inotify event的封装</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    f: <span class="hljs-string">&#x27;open()&#x27;</span><br>    filename: <span class="hljs-built_in">str</span><br>    path: <span class="hljs-built_in">str</span><br>    wm: <span class="hljs-string">&#x27;pyinotify.WatchManager&#x27;</span><br>    output: Callable<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">my_init</span>(<span class="hljs-params">self, **kargs</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;pyinotify.ProcessEvent要求不能直接继承__init__, 而是要重写my_init, 我们重写这一段并进行初始化&quot;&quot;&quot;</span><br><br>        <span class="hljs-comment"># 获取文件</span><br>        filename: <span class="hljs-built_in">str</span> = kargs.pop(<span class="hljs-string">&#x27;filename&#x27;</span>)<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> os.path.exists(filename):<br>            <span class="hljs-keyword">raise</span> RuntimeError(<span class="hljs-string">&#x27;Not Found filename&#x27;</span>)<br>        <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;/&#x27;</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> filename:<br>            filename = os.getcwd() + <span class="hljs-string">&#x27;/&#x27;</span> + filename<br>        index = filename.rfind(<span class="hljs-string">&#x27;/&#x27;</span>)<br>        <span class="hljs-keyword">if</span> index == <span class="hljs-built_in">len</span>(filename) - <span class="hljs-number">1</span> <span class="hljs-keyword">or</span> index == -<span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">raise</span> RuntimeError(<span class="hljs-string">&#x27;Not a legal path&#x27;</span>)<br><br>        self.f = <span class="hljs-literal">None</span><br>        self.filename = filename<br>        self.output: Callable = kargs.pop(<span class="hljs-string">&#x27;output&#x27;</span>)<br>        self.wm = kargs.pop(<span class="hljs-string">&#x27;wm&#x27;</span>)<br>        <span class="hljs-comment"># 只监控路径,这样就能知道文件是否移动</span><br>        self.path = filename[:index]<br>        self.wm.add_watch(self.path, multi_event)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">read_line</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;统一的输出方法&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> self.f.readlines():<br>            self.output(line)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">process_IN_MODIFY</span>(<span class="hljs-params">self, event</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;必须为process_事件名称，event表示事件对象, 这里表示监控到文件发生变化, 进行文件读取&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> event.pathname == self.filename:<br>            self.read_line()<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">process_IN_MOVE_SELF</span>(<span class="hljs-params">self, event</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;必须为process_事件名称，event表示事件对象, 这里表示监控到文件发生重新打开, 进行文件读取&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> event.pathname == self.filename:<br>            <span class="hljs-comment"># 检测到文件被移动重新打开文件</span><br>            self.f.close()<br>            self.f = <span class="hljs-built_in">open</span>(self.filename)<br>            self.read_line()<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__enter__</span>(<span class="hljs-params">self</span>) -&gt; &#x27;InotifyEventHandler&#x27;:</span><br>        self.f = <span class="hljs-built_in">open</span>(self.filename)<br>        <span class="hljs-keyword">return</span> self<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__exit__</span>(<span class="hljs-params">self, exc_type, exc_val, exc_tb</span>):</span><br>        self.f.close()<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Tail</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">            self,</span></span><br><span class="hljs-function"><span class="hljs-params">            file_name: <span class="hljs-built_in">str</span>,</span></span><br><span class="hljs-function"><span class="hljs-params">            output: Callable[[<span class="hljs-built_in">str</span>], NoReturn] = sys.stdout.write,</span></span><br><span class="hljs-function"><span class="hljs-params">            interval: <span class="hljs-built_in">int</span> = <span class="hljs-number">1</span>,</span></span><br><span class="hljs-function"><span class="hljs-params">            len_line: <span class="hljs-built_in">int</span> = <span class="hljs-number">1024</span></span></span><br><span class="hljs-function"><span class="hljs-params">    </span>):</span><br>        self.file_name: <span class="hljs-built_in">str</span> = file_name<br>        self.output: Callable[[<span class="hljs-built_in">str</span>], NoReturn] = output<br>        self.interval: <span class="hljs-built_in">int</span> = interval<br>        self.len_line: <span class="hljs-built_in">int</span> = len_line<br><br>        wm = pyinotify.WatchManager()  <span class="hljs-comment"># 创建WatchManager对象</span><br>        inotify_event_handler = InotifyEventHandler(<br>            **<span class="hljs-built_in">dict</span>(filename=file_name, wm=wm, output=output)<br>        )  <span class="hljs-comment"># 实例化我们定制化后的事件处理类, 采用**dict传参数</span><br>        wm.add_watch(<span class="hljs-string">&#x27;/tmp&#x27;</span>, multi_event)  <span class="hljs-comment"># 添加监控的目录，及事件</span><br>        self.notifier = pyinotify.Notifier(wm, inotify_event_handler)  <span class="hljs-comment"># 在notifier实例化时传入,notifier会自动执行</span><br>        self.inotify_event_handle: <span class="hljs-string">&#x27;InotifyEventHandler&#x27;</span> = inotify_event_handler<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__call__</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span> = <span class="hljs-number">10</span></span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;通过inotify的with管理打开文件&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">with</span> self.inotify_event_handle <span class="hljs-keyword">as</span> i:<br>            <span class="hljs-comment"># 先读取指定的行数</span><br>            self.read_last_line(i.f, n)<br>            <span class="hljs-comment"># 启用inotify的监听</span><br>            self.notifier.loop()<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">read_last_line</span>(<span class="hljs-params">self, file, n</span>):</span><br>        read_len: <span class="hljs-built_in">int</span> = self.len_line * n<br><br>        <span class="hljs-comment"># 获取当前结尾的游标位置</span><br>        file.seek(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>)<br>        now_tell: <span class="hljs-built_in">int</span> = file.tell()<br>        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>            <span class="hljs-keyword">if</span> read_len &gt; file.tell():<br>                <span class="hljs-comment"># 如果跳转的字符长度大于原来文件长度,那就把所有文件内容打印出来</span><br>                file.seek(<span class="hljs-number">0</span>)<br>                last_line_list: List[<span class="hljs-built_in">str</span>] = file.read().split(<span class="hljs-string">&#x27;\n&#x27;</span>)[-n:]<br>                <span class="hljs-comment"># 重新获取游标位置</span><br>                now_tell: <span class="hljs-built_in">int</span> = file.tell()<br>                <span class="hljs-keyword">break</span><br>            file.seek(-read_len, <span class="hljs-number">2</span>)<br>            read_str: <span class="hljs-built_in">str</span> = file.read(read_len)<br>            cnt: <span class="hljs-built_in">int</span> = read_str.count(<span class="hljs-string">&#x27;\n&#x27;</span>)<br>            <span class="hljs-keyword">if</span> cnt &gt;= n:<br>                <span class="hljs-comment"># 如果获取的行数大于要求的行数,则获取前n行的行数</span><br>                last_line_list: List[<span class="hljs-built_in">str</span>] = read_str.split(<span class="hljs-string">&#x27;\n&#x27;</span>)[-n:]<br>                <span class="hljs-keyword">break</span><br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-comment"># 如果获取的行数小于要求的行数,则预估需要获取的行数,继续获取</span><br>                <span class="hljs-keyword">if</span> cnt == <span class="hljs-number">0</span>:<br>                    line_per: <span class="hljs-built_in">int</span> = read_len<br>                <span class="hljs-keyword">else</span>:<br>                    line_per: <span class="hljs-built_in">int</span> = <span class="hljs-built_in">int</span>(read_len / cnt)<br>                read_len = line_per * n<br><br>        <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> last_line_list:<br>            self.output(line + <span class="hljs-string">&#x27;\n&#x27;</span>)<br>        <span class="hljs-comment"># 重置游标,确保接下来打印的数据不重复</span><br>        file.seek(now_tell)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-keyword">import</span> argparse<br><br>    parser = argparse.ArgumentParser()<br>    parser.add_argument(<span class="hljs-string">&quot;-f&quot;</span>, <span class="hljs-string">&quot;--filename&quot;</span>)<br>    parser.add_argument(<span class="hljs-string">&quot;-n&quot;</span>, <span class="hljs-string">&quot;--num&quot;</span>, default=<span class="hljs-number">10</span>)<br>    args, unknown = parser.parse_known_args()<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> args.filename:<br>        <span class="hljs-keyword">raise</span> RuntimeError(<span class="hljs-string">&#x27;filename args error&#x27;</span>)<br>    Tail(args.filename)(<span class="hljs-built_in">int</span>(args.num))<br></code></pre></td></tr></table></figure>
<p>可以看到, 从原本的open打开文件改为用inotify打开文件(这时候会调用my_init方法进行初始化), 打开后还是运行我们打开原来n行的代码, 然后就交给inotify运行. 在inotify运行之前, 我们把重新打开文件方法和打印文件方法都挂载在inotifiy对应的事件里, 之后inotify运行时, 会根据对应的事件执行对应的方法.</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>2019plan</title>
    <url>/2019/01/31/2019_plan/</url>
    <content><![CDATA[<h2 id="前记"><a href="#前记" class="headerlink" title="前记"></a>前记</h2><p>mv 2018plan.md 2019plan.md</p>
<span id="more"></span>
<h2 id="amp"><a href="#amp" class="headerlink" title="%$*&amp;^"></a>%$*&amp;^</h2><p>过去这一年(18)，是学校过得美滋滋到出来被社会摧残的过度。</p>
<p>由于是通信工程专业，被家人强迫去考了一个ccna证书，看了挺过网络知识的，虽然高分拿证了，但是事实证明，不是自己感兴趣的，背的东西一下子就忘，现在还是重新了解计算机系统网络。</p>
<p>但是，为了考这个证书，就忘记去找实习了。还好，今年开年回学校后找到了实习，并在毕业后转正，虽然团队挺小，但是相处得挺好的，自己也从一个小渣渣变成一个懂点东西的小渣渣。</p>
<p>这一年经历过了疲累，有一段时间更是失去了奋斗的感觉 ，回来就玩玩手机玩玩电脑，看看东西，就可以准备睡觉了，这段时间几乎没有什么提升，好在及时睡醒了，重新安排规划，回到正规，而且在后期逐渐发现了自己的不足，同时也能逐渐修补自己对于操作系统等基础功能等知识的缺失。</p>
<h2 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h2><p>实习了才发现自己是多渣，在编写api服务器时，分层思想很差，层次分离不清晰，结构也安排的很差，造成业务代码逻辑一团遭，之后进行了一番恶补，在编写日志系统时，解析日志的结构安排就比较合理了，能越来越觉得自己之前的设计思想不合理，并改正，这部分是自己感受到进步最大的地方，同时在工作后发现自己有很多知识（包括一些偏底层的知识）还是不足的，更重要的是明确了自己的方向。</p>
<h2 id="身体"><a href="#身体" class="headerlink" title="身体"></a>身体</h2><p>今年实习时一直有跑步，但毕业搬家后附近没地方跑了，转为keep，但吃的也多，还是瘦不下来Orz。<br>keep没跑步爽，今年搬回车陂继续江边跑吧。</p>
<p>但是真的觉得人开始老了，大学的时候还可以陪朋友熬夜打机玩lol，第二天去吃点早餐再回去睡觉，现在每天不在一点前睡觉就感觉很难受。</p>
<h2 id="语言"><a href="#语言" class="headerlink" title="语言"></a>语言</h2><p>编程方面：18年只看了go，但是没有怎么运用到。</p>
<p>由于工作以及本人需要，而且还可以看python的源码，今年学习的编程语言主要为c，利用sip项目的机会，多学点c，今年上半年研究go的一些协程实现原理。</p>
<p>日语：emmmmmm 完全落下了（掩脸）且今年也没啥安排可以重启了….早起毁一天Orz<br>英语：通过sip项目以及阅读文档增进英语能力(工作以来接触的英文文档好多，英语太重要了)，外加最基本的背单词，以及根据课程学习</p>
<h2 id="读书"><a href="#读书" class="headerlink" title="读书"></a>读书</h2><p>过完新年买台ipad，可以在地铁看书。</p>
<p>今年想看的书比较有目的性（如何编写良好的代码，如何运用设计模式，了解系统以及底层），阅读/温习以下书籍：<br>    - 数据库系统概念<br>    - 算法导论<br>    - 编程之美<br>    - 代码简洁之道<br>    - 编写可读代码的艺术<br>    - 重构，改善既有代码的设计<br>    - 计算机网络-自顶向下<br>    - 软件架构<br>    - 高性能mysql（今年看一半断了，继续看！）</p>
<p>可能会阅读的书籍:<br>    - 微服务设计，Docker，k8s等（一直很想了解的，捉紧时代的尾巴）<br>    - 一本c语言的书（今年想学c语言）<br>    - python相关（今年要深入理解python的原理）<br>    - nginx相关(理解并学会如何使用，但不会深入到源码里面)<br>    - 运维与监控，日志传输统计等相关</p>
<h2 id="随心"><a href="#随心" class="headerlink" title="随心"></a>随心</h2><p>没想到被放鸽子， 重庆还没去，反倒去了新加坡，今年的旅游还是重庆吧！</p>
<h2 id="main"><a href="#main" class="headerlink" title="main"></a>main</h2><p>工作以来，发现自己的基础比较差特别是计算机底层/系统/网络等，考完ccna后由于没有怎么用到这方面的知识，也忘得差不多了。所以今年第一季度主攻计算机底层/系统/网络的知识，在今年第二季度前半段时间内完成。</p>
]]></content>
      <categories>
        <category>计划</category>
      </categories>
      <tags>
        <tag>计划</tag>
      </tags>
  </entry>
  <entry>
    <title>不太RESTurl的接口设计</title>
    <url>/2018/04/10/%E4%B8%8D%E5%A4%AARESTurl%E7%9A%84%E6%8E%A5%E5%8F%A3%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<h2 id="前记"><a href="#前记" class="headerlink" title="前记"></a>前记</h2><p>又是一篇水文- -. </p>
<p>在还没开始实习的时候,除了在弄一些练习项目或者刷面试题时,经常碰到RESTurl,知道这是一个非常重要的前后端交互的接口设计模式,也是很少人/公司能把RESTurl完全的应用到自己的业务逻辑里面.</p>
<p>实习时,一开始就用RESTurl方式去写API,写了一段时间的API后发现,其实没必要完全去追求RESTurl,虽然RESTurl的设计是很好的,但是从理论到落地总是会有一些偏差.</p>
<p>要永远记得,一切要以实际业务为准.</p>
<span id="more"></span>
<p>** 注:文章已经更新,目前已经使用starlette代替sanic作为web框架**</p>
<h2 id="1-HTTP-Method方法缺少云服务商的支持"><a href="#1-HTTP-Method方法缺少云服务商的支持" class="headerlink" title="1.HTTP Method方法缺少云服务商的支持"></a>1.HTTP Method方法缺少云服务商的支持</h2><p>在RESTurl中,最明显的就是对于同一个url,把url当做资源,再用http method方法去进行操作,比如用get去获取数据,post添加数据,put更新数据,delete删除数据,从设计上面来看这个设计的没问题的,但是在现实中却会带来一些bug.之前在API运用RESTurl的设计后运行了一段时间,结果在某一天套上了阿里云的CDN后发现接口不可用了,经过一段时间的排查后发现是阿里云的CDN只支持GET/POST方法…<br>在这次事故之后,所有API的HTTP Method改为GET/POST, get一般用于获取数据且数据一定能被CDN缓存的,其他都使用POST方法.在做了此次更改后,无论接了什么CDN,都再也没有出现云服务商无法支持的问题了.</p>
<h2 id="2-接口设计与抛错设计的"><a href="#2-接口设计与抛错设计的" class="headerlink" title="2.接口设计与抛错设计的"></a>2.接口设计与抛错设计的</h2><p>经常能发现很多人在一些编程论坛上吵着,全RESTurl,或者只要接口没问题,那就返回HTTP STATUS CODE 200,并自己在json里面写上业务的code,交由客户端判断.在经历过几次项目的设计后,我还是偏爱于后者的.先看看设计</p>
<h3 id="2-1接口返回设计"><a href="#2-1接口返回设计" class="headerlink" title="2.1接口返回设计"></a>2.1接口返回设计</h3><p>由于前端的部分库会设计在非200的错误码就抛错或者业务需求,正常情况下,只要web框架能响应,就返回HTTP Status Code:200,只有在下列情况下才会出现非200的情况:</p>
<ul>
<li>1.服务端当服务端鉴权失败时返回 HTTP Status Code 403(如果返回401要记得在 Response 的头里面去掉 [WWW-Authenticate: Basic realm=”Realm”],不然浏览器遇到 401 会弹出那个浏览器自带的输入帐号密码的东西)</li>
<li>2.中间件遇到问题返回的标准错误码，例如 Nginx 返回的 5** 错误码</li>
</ul>
<p>当接口返回HTTP Status Code:200时,对应的响应内容如下:</p>
<figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;code&quot;</span>: <span class="hljs-number">0</span>,<br>  <span class="hljs-attr">&quot;result&quot;</span>: &#123;&#125;,<br>  <span class="hljs-attr">&quot;msg&quot;</span>: <span class="hljs-string">&quot;&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>code<br>表示为业务状态码,以1位数字表示大类的错误,比如0为正常,1为数据库错误,2为限流等.以2位数的表示业务类的错误,如10为用户相关错误,11为功能块B相关错误等.,4位数为详细错误,如用户登录出错,用户密码错误,用户token过期等,能描述出来且能把该错误快速定位出来.<br>其中3位数留空是因为有些前端人员会在出现问题后只报出错误码,并不会去区分 HTTP Status Code或者业务状态码,所以3位数的业务状态码留空可以减少不必要的交流成本.</li>
<li>result<br>表示返回的数据,一般只有code为0才会有数据,没数据时result为null</li>
<li>msg<br>表示错误的信息,只有code不为0时才有数据,为0时留空.</li>
</ul>
<h3 id="2-2-如何编写抛错设计的代码"><a href="#2-2-如何编写抛错设计的代码" class="headerlink" title="2.2 如何编写抛错设计的代码"></a>2.2 如何编写抛错设计的代码</h3><p>一般基于上面设计时,都会自己封装一个response(code, msg, result=None)的代码,然后根据业务逻辑填写对应的值,久而久之就会发现,代码里太多if…else,同时在存在多层嵌套时,也需要多层if…else.</p>
<p>解决这个问题很简单,只要利用好框架中的中间件功能即可,框架中的中间件功能除了处理请求前与请求后的数据外,还能处理请求时的异常,所以可以利用这一点来编写接口返回中的异常返回.同时还能利用继承来完成我们上面所说的code分类.<br>先以如下个代码结构为例子:</p>
<figure class="highlight axapta"><table><tr><td class="code"><pre><code class="hljs axapta"><span class="hljs-meta"># 这里示例代码用的是starlette框架</span><br>├── custom.py  <span class="hljs-meta"># 存放中间件以及错误定义相关</span><br>└── <span class="hljs-keyword">server</span>.py  <span class="hljs-meta"># 主要入口代码</span><br></code></pre></td></tr></table></figure>
<p>在没引入错误设计前的HelloWord的代码如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs Python3">from starlette.applications import Starlette<br>from starlette.routing import Route, Router<br>from starlette.responses import JSONResponse<br><br><br>APP &#x3D; Starlette()<br><br><br>@APP.route(&#39;&#x2F;&#39;)<br>async def homepage(request):<br>    return JSONResponse(&#123;&#39;hello&#39;: &#39;world&#39;&#125;)<br></code></pre></td></tr></table></figure>
<h4 id="2-2-1-添加custom-py文件"><a href="#2-2-1-添加custom-py文件" class="headerlink" title="2.2.1 添加custom.py文件"></a>2.2.1 添加custom.py文件</h4><p>最主要的是针对中间件的封装以及错误定义</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 继承starlette框架的错误中间件接口,starlette会捕获handle.py中的错误,并发向api_exception,再由我们自定义的response返回给用户</span><br><span class="hljs-comment"># 这里的response也就是的HTTPException</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">APIException</span>(<span class="hljs-params">HTTPException</span>):</span><br>    API_CODE = <span class="hljs-number">1</span><br>    DETAIL = <span class="hljs-string">&quot;API Error&quot;</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">            self,</span></span><br><span class="hljs-function"><span class="hljs-params">            extend_detail: Optional[<span class="hljs-built_in">str</span>] = <span class="hljs-literal">None</span>,</span></span><br><span class="hljs-function"><span class="hljs-params">            api_code: Optional[<span class="hljs-built_in">int</span>] = <span class="hljs-literal">None</span>,</span></span><br><span class="hljs-function"><span class="hljs-params">            content: Any = <span class="hljs-literal">None</span>,</span></span><br><span class="hljs-function"><span class="hljs-params">            background_task: Optional[BackgroundTask] = <span class="hljs-literal">None</span></span></span><br><span class="hljs-function"><span class="hljs-params">    </span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        <span class="hljs-built_in">super</span>().__init__(<span class="hljs-number">200</span>, self.DETAIL) <span class="hljs-comment"># 这里的200是http状态码</span><br>        <span class="hljs-keyword">if</span> api_code:<br>            self.api_code = api_code<br>        <span class="hljs-keyword">else</span>:<br>            self.api_code = self.API_CODE<br>        self.content = content<br>        self.background_task = background_task<br><br><span class="hljs-comment"># 第二类错误且他属于第一类中状态码1错误的子类,所以直接继承APIException</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClientException</span>(<span class="hljs-params">APIException</span>):</span><br>    API_CODE = <span class="hljs-number">11</span><br>    DETAIL = <span class="hljs-string">&quot;Request Error&quot;</span><br><br><span class="hljs-comment"># 使用starlette框架的错误中间件接口,starlette会捕获handle.py中的错误,并发向api_exception,再由我们自定义的response返回给用户</span><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">api_exception</span>(<span class="hljs-params">request: Request, exc: APIException</span>) -&gt; Response:</span><br>    <span class="hljs-keyword">return</span> response(request, exc.status_code, exc.api_code, content=exc.content, error_type=exc.DETAIL)<br></code></pre></td></tr></table></figure>
<p>可以看到我们主要是为自己的抛错定义一个类,当有错误时,会把错误通过api_exception发送给我们的response,这里的response也就是返回给用户一个响应,http状态码为exc.status_code,返回的json内容为</p>
<figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;code&quot;</span>: exc.api_code,<br>  <span class="hljs-attr">&quot;result&quot;</span>: &#123;&#125;,<br>  <span class="hljs-attr">&quot;msg&quot;</span>: exc.content<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="2-2-1-修改server-py文件"><a href="#2-2-1-修改server-py文件" class="headerlink" title="2.2.1 修改server.py文件"></a>2.2.1 修改server.py文件</h4><p>先通过<code>APP.add_exception_handler(APIException, api_exception)</code>把我们的api_exception引入到starlette框架里面,成为他的异常中间件.</p>
<p>之后修改api接口为:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@APP.route(<span class="hljs-params"><span class="hljs-string">&#x27;/&#x27;</span></span>)</span><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">homepage</span>(<span class="hljs-params">request</span>):</span><br>    <span class="hljs-keyword">raise</span> APIException()<br></code></pre></td></tr></table></figure>
<p>修改后重启程序,重新调用就会看到网页显示</p>
<figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;code&quot;</span>: <span class="hljs-number">1</span>,<br>  <span class="hljs-attr">&quot;result&quot;</span>: &#123;&#125;,<br>  <span class="hljs-attr">&quot;msg&quot;</span>: <span class="hljs-string">&quot;API Error&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3.总结"></a>3.总结</h2><p>RESTurl的设计非常不错,需要学习他的思想,但由于以下原因,无法在项目上完整的应用.</p>
<ul>
<li>1.比较难与自由业务的融合(最重要的一点,比较公司需要的是你的产出,无法与业务融合,那再怎么高大上也没什么用)</li>
<li>2.云服务商缺少支持</li>
<li>3.客户端/前端人员的知识</li>
<li>4.客户端/前端框架的支持</li>
</ul>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>接口设计</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL断开重连</title>
    <url>/2018/03/20/MySql%E6%96%AD%E5%BC%80%E9%87%8D%E8%BF%9E/</url>
    <content><![CDATA[<h2 id="前记"><a href="#前记" class="headerlink" title="前记"></a>前记</h2><p>今天上班发现在在跑的业务接口无法访问了,查看的日志后发现MySQL断开连接,只有重启web程序后才能恢复正常.MySQL断开重连这个问题第一次遇到时还是有点懵逼的,主要与库选型有关才造成发现了这个问题,还有就是对MySQL的了解不熟悉,才会造成MySQL断开重连的问题需要经过一顿搜索后才能查明原因并解决.</p>
<span id="more"></span>

<h2 id="1-发生原因"><a href="#1-发生原因" class="headerlink" title="1.发生原因"></a>1.发生原因</h2><p>其实发生这个问题比较苛刻,因为MySQL断开重连是MySQL会去探测与自己相关的连接,当超过了设定的timeout时间后,MySQL服务器会断开这个链接,使用<code>show variables like &#39;%timeout%&#39;;</code>命令查询可以看到MySQL默认的超时时间是28800秒也就是8小时.而目前在写的业务并没有正式上线,所以基本除了自己人就没有用户在使用,所以睡了一觉后就会发现接口挂了.</p>
<p>自己在实习之前是只用Django写demo,Django自带的ORM除了让程序员可以用面向对象的思想去写SQL语句外,自己还做了一些封装如数据库链接池,还有就是针对与服务器链接断开时,会使用mysql的ping命令,检测并重新创建链接.</p>
<h2 id="2-修复问题"><a href="#2-修复问题" class="headerlink" title="2.修复问题"></a>2.修复问题</h2><p>在这个问题还没出现之前,MySQL相关部分代码是这样的:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs Python3"># 使用的是aiiomysql库,autocommit是一个封装好的链接池,执行sql后会自动commit<br># 这样还有其他细节,如果sql语句校验,重试等,不过与问题无关,就省略了<br>async with autocommit.acquire() as conn:<br>    async with conn.cursor() as cur:<br>        ret &#x3D; await cur.execute(sql, param)<br>        res &#x3D; await cur.fetchall()<br>        return ret, res<br></code></pre></td></tr></table></figure>
<p>由于用到的是aiomysql库,在发生断开重连时,他会抛出一个<code>aiomysql.OperationalError</code>的错误,从Django的ORM封装可以知道只要重新PING就可以解决断开重连这个问题了,所以只要把这个错误捕获,并且在里面重新执行conn.ping即可.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs Python3">async with autocommit.acquire() as conn:<br>    async with conn.cursor() as cur:<br>        try:<br>        	ret &#x3D; await cur.execute(sql, param)<br>        except aiomysql.OperationalError as e:<br>            await conn.ping()<br>        	ret &#x3D; await cur.execute(sql, param)<br>        res &#x3D; await cur.fetchall()<br>        return ret, res<br></code></pre></td></tr></table></figure>
<p>通过上面的代码即可修复断开重连的问题了,但是也有可能ping完还出现<code>aiomysql.OperationalError</code>错误,所以需要对整个操作层进行重试封装,才能比较完美的解决该问题.</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>WEB用户验证的几种方式</title>
    <url>/2018/03/01/27/</url>
    <content><![CDATA[<h2 id="前记"><a href="#前记" class="headerlink" title="前记"></a>前记</h2><p><code>HTTP</code>协议是非常简单流行的, 然而<code>HTTP</code>协议也是无状态的, 且没有用户标识. 目前业界已经有几套成熟的用户标识以及用户验证的方案, 让后端知道访问的用户是谁.常见的用户验证有：<br><code>Session</code>，<code>Cookies</code>，<code>Token</code>，<code>Jwt</code>等等</p>
<span id="more"></span>
<p><code>HTTP</code>是一个无状态的连接过程，每一次访问对于<code>Server</code>来说都是新用户，那么需要一些技术来让 <code>Server</code>知道这次连接过来的是谁。从而产生了<code>Session</code>和<code>Cookies</code>。其中<code>Cookies</code>是<code>HTTP</code> 协议中规定的，而<code>Session</code>是基于<code>Cookies</code>衍生出来的。</p>
<p>可是在App端中，不像浏览器一样, <code>Cookies</code>是没法有效储存，导致了<code>Cookies</code>和<code>Session</code>无法使用。所以我们会采用手动的形式来模拟浏览器处理<code>Cookies</code>的流程来创造一套属于自己的<code>HTTP</code>用户认证方式：<code>TOKEN</code>、<code>JWT</code>。</p>
<h2 id="1-HTTP-Auth-Authentication"><a href="#1-HTTP-Auth-Authentication" class="headerlink" title="1.HTTP Auth Authentication"></a>1.HTTP Auth Authentication</h2><p><code>HTTP</code>提供了一个用于权限控制和认证的方案, 目前最简单的就是<code>HTTP Basic Authentication</code>. 该方案非常简单, 在<code>Authorization</code>字段中存放一个<code>用户名:密码</code>的base64的字符串, 双方通过解析该字符串从而知道了用户是谁, 不过该方案太简单, 所以也很容易被破解.</p>
<h2 id="2-COOKIES"><a href="#2-COOKIES" class="headerlink" title="2.COOKIES"></a>2.COOKIES</h2><p>如果双方一直都用<code>HTTP Basic Authentication</code>验证用户, 那也太麻烦了,  而且容易泄露用户密码. 如果用户只登录一次,  后面只用一个标记身份的字符串代替, 那就非常方便了, <code>Cookies</code>就是这样的.<br><code>Cookies</code>是<code>HTTP</code>协议中自带的内容，所以浏览器对其的支持都是很好的，说白了就是一个简单的KV（key-value）的数组。同时 Cookies 是对用户透明的，所以后端都会对Cookies进行一定的编码，使cookies详细的数据不可见(但仍可以使用整段cookie来达到欺骗的效果)，用户不用做任何操作，浏览器会根据 HTTP 报文来做处理。</p>
<h3 id="2-1流程"><a href="#2-1流程" class="headerlink" title="2.1流程"></a>2.1流程</h3><p>Client 访问 Server 时会自动带上<code>Cookies</code>，具体实现是在<code>HTTP</code>头部的<code>Cookies</code>中传递过去。<br>Server 可以在 Client 中写入<code>Cookies</code>，具体是在<code>HTTP</code>响应报文头部中Set-Cookie 来告诉浏览器需要在 Client 中记录这些信息，以后访问的时候顺便带过来。<br>以访问google为栗子(提取于Django-book)：<br>第一次访问时：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><code class="hljs vim">GET / HTTP/<span class="hljs-number">1.1</span><br>Hos<span class="hljs-variable">t:</span> google.<span class="hljs-keyword">com</span><br>...<br></code></pre></td></tr></table></figure>
<p>响应：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros">HTTP/1.1 200 OK<br>Content-Type: text/html<br>Set-Cookie: <span class="hljs-attribute">PREF</span>=ID=5b14f22bdaf1e81c:TM=1167000671:LM=1167000671;<br>            <span class="hljs-attribute">expires</span>=Sun, 17-Jan-2038 19:14:07 GMT;<br>            <span class="hljs-attribute">path</span>=/; <span class="hljs-attribute">domain</span>=.google.com<br>Server: GWS/2.1<br><span class="hljs-built_in">..</span>.<br>可以看到里面是以`;`区分的key-value数据, 第一个为`Cookie`, 第二个是过期时间, 告诉浏览器服务端会在多久之后刷新Cookie. 后面还有当前的path以及domain信息<br></code></pre></td></tr></table></figure>
<p>之后客户端访问服务端时, 都会在<code>Cookie</code>字段填写Cookie：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros"><span class="hljs-builtin-name">GET</span> / HTTP/1.1<br>Host: google.com<br>Cookie: <span class="hljs-attribute">PREF</span>=ID=5b14f22bdaf1e81c:TM=1167000671:LM=1167000671<br><span class="hljs-built_in">..</span>.<br></code></pre></td></tr></table></figure>

<h3 id="2-2特性"><a href="#2-2特性" class="headerlink" title="2.2特性"></a>2.2特性</h3><p>除了过期时间外, 服务端还可以通过以下字段设置而<code>Cookie</code>的一些限制:</p>
<ul>
<li>setDomain：设置cookie范围</li>
<li>isHttpOnly：是否只是http协议使用。只能在后端通过getCookies()获取，js不能获取；</li>
</ul>
<p>而且需要注意的是每一个cookie文件大小：4kb ， 如果超过4kb浏览器不识别；cookie不安全，可能泄露用户信息，浏览器支持禁用cookie操作；</p>
<h2 id="3-SESSION"><a href="#3-SESSION" class="headerlink" title="3.SESSION"></a>3.SESSION</h2><p><code>Session</code>是在<code>Cookies</code>发展中为了解决<code>Cookies</code>某些弊端而产生的技术，为了绕开<code>Cookies</code>的各种限制，通常借助<code>Cookies</code>本身和后端存储实现的，一种更高级的会话状态实现，<code>Session</code>是存在服务器的，用于区分会话和不同用户的访问。<br>Session主要是为了跟踪会话，比如某些网站中网页有不同的访问权限，有只能登录的用户访问的网页或者用户级别不同不能访问的，但是http请求是无状态的，每次访问服务端是不知道是否是登录用户，很自然的想到在http请求报文中加入登录标识就可以了，这个登录标识就可以是cookie，这样的cookie服务端要保存有所有登录用户的cookie，这样请求报文来了之后拿到登录标识cookie，在服务端进行比较久可以了。再比如购物网站，多次点击添加商品到购物车客户端很容易知道哪些物品在购物车中，但是服务端怎么知道每次添加的物品放到哪个登录用户的购物车中呢？也需要请求报文中带着cookie才行，这些cookie都是为了跟踪会话用的，所以客户端有，服务端也有，并且服务端有全部的会话cookie。</p>
<h2 id="4-TOKEN"><a href="#4-TOKEN" class="headerlink" title="4.TOKEN"></a>4.TOKEN</h2><p>Token它可以是 Session-id，也可以是一串随机的字符。但是它的作用跟Session-id 一样都是为了识别不同的访问者，同时验证它的有效性。</p>
<p>Token 是一个很广泛的说法，是因为它只提供了一个验证的准则，而不是一个具体的做法，所以 JWT、OAUTH 都可以算是 Token 的一种实现。</p>
<blockquote>
<p>在我看来，Token的过程就是这么一回事：<br>Client —&gt; Server: 嘿，我是那个谁啊<br>Server —&gt; Client: 知道了，你记着你的票号 123456，半个小时内有有效<br>// 几分钟后<br>Client —&gt; Server: 嘿，我的票号是 123456，帮我买瓶水，钱从账户扣<br>Server —&gt; Client: （嗯，123456 在有效期内）好嘞<br>Client —&gt; Server: （我试下用别人的账号买东西）嘿，我的票号是 666666，帮我买瓶水，钱从账户扣<br>Server —&gt; Client: （嗯？我们根本就没有 666666 这个票号的记录啊）兄弟，你是来搞事的吧<br>// 半个小时后<br>Client —&gt; Server: 嘿，我的票号是 123456，帮我买瓶水，钱从账户扣<br>Server —&gt; Client: （em，好像过时了）诶诶诶，你的票号过期了，不办理了</p>
</blockquote>
<p>在token中，Token能明确这里明确告诉了用户他的识别id和有效期也就是说 Server 必须通过某种方式通知 Client，而不是像 Cookies 和 Session 那样使用 Set-Cookie就可以完成的。</p>
<p>服务器告知客户端的具体实现方法如下:<br>通过 HTTP RESPONSE 报文中 Headers 返回 Token:123456<br>通过 HTTP RESPONSE 报文中Content 返回{‘status’:’OK’, ‘data’:{‘token’:’123456’}}<br>ps:使用 Header 携带消息的方法使用较少，普遍都是使用 Content 来携带消息，因为通常情况下，需要返回的信息不只是 Token 本身，还有相关的附加信息：Expire-time 等等</p>
<p>客户端告知服务器的具体实现方法如下:<br>通过 HTTP REQUEST 报文中 Header 携带 Token:123456<br>通过 HTTP URL 携带：<a href="http://foo.com/buy?good=water&amp;number=1&amp;token=123456">http://foo.com/buy?good=water&amp;number=1&amp;token=123456</a><br>通过 HTTP FORM 携带：这个方法只能出现在非 GET 请求下。<br>上述讲的三种方法，最常见的是前两种，第三种少使用的原因是需要为 GET 设计另外一种 Token 携带方案，而前两种适合于所有 HTTP 访问</p>
<h3 id="5-JWT"><a href="#5-JWT" class="headerlink" title="5.JWT"></a>5.JWT</h3><p>JWT 是 Token 的具体且应用实现。<br>它具备两个特点：</p>
<ul>
<li><p>简洁(Compact)<br>可以通过URL, POST 参数或者在 HTTP header 发送，因为数据量小，传输速度快</p>
</li>
<li><p>自包含(Self-contained)<br>负载中包含了所有用户所需要的信息，避免了多次查询数据库</p>
</li>
</ul>
<p>同时JWT还具有两种特性：时效性，有效性。</p>
<p>时效性指 JWT 提供了 Token 的过期时间。<br>有效性指 JWT 可以验证当前的 Token 是否被修改。<br>JWT 的组成是这样的：Header||Payload||Signature<br>Header 标明了这是一个 JWT，而且使用了什么 Hash 算法<br>Payload 储存了你保存在用户数据和 JWT 自身的一些必要信息，必要信息常用的有iss（签发者），exp（过期时间），sub（面向的用户），aud（接收方），iat（签发时间）<br>Signature 是 Server 对 Header 和 Payload 的 HMAC 结果。也就是签名，签名的作用是保证 JWT 没有被篡改过。</p>
<p>虽然使用了签名能确保JWT是否被篡改，使用编码能使JWT变为非人类视角的代码，但是还是很容易破解，因此JWT适合用于向Web应用传递一些非敏感信息。所以JWT经常用于设计用户认证和授权系统，甚至实现Web应用的单点登录。</p>
<p>JWT流程：<br>1.首先，前端通过Web表单将自己的用户名和密码发送到后端的接口。这一过程一般是一个HTTP POST请求。建议的方式是通过SSL加密的传输（https协议），从而避免敏感信息被嗅探。<br>2.后端核对用户名和密码成功后，将用户的id等其他信息作为JWT Payload（负载），将其与头部分别进行Base64编码拼接后签名，形成一个JWT。形成的JWT就是一个形同lll.zzz.xxx的字符串。<br>3.后端将JWT字符串作为登录成功的返回结果返回给前端。前端可以将返回的结果保存在localStorage或sessionStorage上，退出登录时前端删除保存的JWT即可。<br>4.前端在每次请求时将JWT放入HTTP Header中的Authorization位。(解决XSS和XSRF问题)<br>5.后端检查是否存在，如存在验证JWT的有效性。例如，检查签名是否正确；检查Token是否过期；检查Token的接收方是否是自己（可选）。<br>6.验证通过后后端使用JWT中包含的用户信息进行其他逻辑操作，返回相应结果。</p>
<p>流程图:<br><img   class="lazyload" data-original="https://github.com/so1n/so1n_blog_photo/blob/master/blog_photo/JWT.jpg?raw=true" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" ></p>
<h3 id="单点登录"><a href="#单点登录" class="headerlink" title="单点登录"></a>单点登录</h3><p>还没使用过，待填坑<br>参考文章:<a href="https://juejin.im/post/5a982eb8f265da239f06cba3">1</a>,<a href="https://www.cnblogs.com/ywlaker/p/6113927.html">2</a></p>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>WEB用户验证</tag>
      </tags>
  </entry>
  <entry>
    <title>2018plan</title>
    <url>/2018/02/16/28_2018plan/</url>
    <content><![CDATA[<h2 id="前记"><a href="#前记" class="headerlink" title="前记"></a>前记</h2><p>mv 2017plan.md 2018plan.md</p>
<span id="more"></span>
<h2 id="amp"><a href="#amp" class="headerlink" title="%$*&amp;^"></a>%$*&amp;^</h2><p>从迷茫到有目标，这一年边摸坑边走过来，发现还是有点计划才不会半路迷路<br>接下来的一年也碰巧是在校与在外的交汇，希望能好好的走过这一年，不要有遗憾</p>
<h2 id="身体"><a href="#身体" class="headerlink" title="身体"></a>身体</h2><p>找个旁边有的可以跑步的地方/或锻炼（emmmm）<br>虽然去年跑了一年了，还没瘦下来，但是这一年没大病，状态也挺好的。所以运动还是得坚持下去</p>
<h2 id="语言"><a href="#语言" class="headerlink" title="语言"></a>语言</h2><p>编程方面，这一年多学java/go（优先go），还是很喜欢专研后端的东东<br>日语也要加油，看下明年能不能取考个证哈哈哈<br>英语就还是随着阅读文档和邮件列表、外网来长进吧(每周最少翻译一篇东东)</p>
<h2 id="读书"><a href="#读书" class="headerlink" title="读书"></a>读书</h2><p>去年电脑里放太多书了，今年争取能读完库存的一半（剩下的留给明年= =），还有一些邮件列表，也要跟这读<br>还有每周留点时间练练字，太久没写字，字都不能见人了。。。。<br>（有kindle是最吼的）</p>
<h2 id="随心"><a href="#随心" class="headerlink" title="随心"></a>随心</h2><p>毕业前，找个时间去重庆独自游玩！</p>
<h2 id="main"><a href="#main" class="headerlink" title="main"></a>main</h2><p>继续跟着大佬了解后端，踏进门后发现后端还是有许多东西还没接触到</p>
]]></content>
      <categories>
        <category>计划</category>
      </categories>
      <tags>
        <tag>计划</tag>
      </tags>
  </entry>
  <entry>
    <title>vim手册查阅</title>
    <url>/2018/02/16/29/</url>
    <content><![CDATA[<h2 id="前记"><a href="#前记" class="headerlink" title="前记"></a>前记</h2><p>之前照抄了一个关于vim命令的<a href="http://so1n.me/2017/08/17/11-vim/">文章</a>，其实就是vim的简单命令使用，但也是符合vim手册查阅哈哈哈。</p>
<h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><p>vim 快捷键很多，不常用的话一下子就忘记了，但是经常用的话，效率挺高的。</p>
<p><a href="https://www.runoob.com/w3cnote/all-vim-cheatsheat.html">vim快捷键查询</a></p>
<p><img    class="lazyload" data-original="/tmp/1550501639103.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">vim快捷键简体中文版</span></p>
]]></content>
      <categories>
        <category>计划</category>
      </categories>
      <tags>
        <tag>计划</tag>
      </tags>
  </entry>
  <entry>
    <title>收藏</title>
    <url>/2018/01/01/start-2018/</url>
    <content><![CDATA[<h2 id="前记"><a href="#前记" class="headerlink" title="前记"></a>前记</h2><p>平时浏览网页时，看到喜欢的网站都会发送到<a href="https://www.pushbullet.com/">pushbullet</a>，但没去整理，找起来十分麻烦。</p>
<span id="more"></span>

<h2 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h2><p><a href="https://blog.csdn.net/shu580231/article/details/76240611">git flow常用命令</a></p>
<p><a href="https://blog.laisky.com/p/gitflow/">使用 Git &amp; Gitflow 管理代码开发、发布流程</a></p>
<h2 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h2><p><a href="https://juejin.im/post/5ae3ee096fb9a07aa7676883">Python内建函数</a></p>
<p><a href="https://blog.ernest.me/post/asgi-draft-spec-zh">ASGI 异步服务网关接口规范中文译稿</a></p>
<p><a href="https://pycoders-weekly-chinese.readthedocs.io/en/latest/issue6/a-guide-to-pythons-magic-methods.html">Python 魔术方法指南</a></p>
<p><a href="https://julien.danjou.info/high-performance-in-python-with-zero-copy-and-the-buffer-protocol/">High-Performance in Python with Zero-Copy and the Buffer Protocol</a></p>
<h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><p><a href="http://blog.zhanglun.me/2017/10/10/HTTP%E5%A4%8D%E7%94%A8/">HTTP复用</a></p>
<h2 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h2><p><a href="https://www.aeracode.org/2018/02/19/python-async-simplified/">Python &amp; Async Simplified</a></p>
<p><a href="https://www.v2ex.com/t/347421">Python async 讨论 –V2EX</a></p>
<p><a href="https://drafts.damnever.com/2015/A-Web-Crawler-With-asyncio-Coroutines.html">&lt;译&gt; A Web Crawler With asyncio Coroutines</a></p>
<p><a href="http://blog.zhanglun.me/">Python3 asyncio 简介</a></p>
<p><a href="http://python.jobbole.com/87310/">Python黑魔法 — 异步IO（ asyncio） 协程</a></p>
<p><a href="https://juejin.im/entry/56ea295ed342d300546e1e22?utm_source=gold-miner&utm_medium=readme&utm_campaign=github"> Python 3.5 协程原理</a></p>
<h2 id="算法与数据结构"><a href="#算法与数据结构" class="headerlink" title="算法与数据结构"></a>算法与数据结构</h2><p><a href="https://36kr.com/p/5114077.html">36氪首发 | 今日头条推荐算法原理全文详解</a></p>
<h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><p><a href="https://mp.weixin.qq.com/s?__biz=MzA3MzYwNjQ3NA==&mid=400257019&idx=2&sn=3e37dd36b2a522283482b05f790549d7&scene=0">超级系统工具Sysdig，比 strace、tcpdump、lsof 加起来还强大</a><br>来自微信公众号:运维帮</p>
<h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><h2 id="shell以及linux"><a href="#shell以及linux" class="headerlink" title="shell以及linux"></a>shell以及linux</h2><p><a href="https://tinylab.gitbooks.io/shellbook/content/zh/preface/01-chapter1.html">shell编程示例</a></p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p><a href="https://www.javadoop.com/post/url-shortener">短链接服务系统开发</a></p>
<h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><p><a href="https://debugtalk.com/post/locustplus-talk-about-performance-test/">漫谈服务端性能测试</a></p>
<p><a href="https://juejin.im/entry/5b3c9eb3e51d4519610db547">如何提升网站的性能？</a></p>
<p><a href="https://juejin.im/post/5b9e4213f265da0abd350bce">服务端思维指南 | 常用性能监控指南</a></p>
<h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p><a href="https://www.cnblogs.com/8hao/archive/2016/04/12/5383143.html">揭秘微信红包：架构、抢红包算法、高并发和降级方案</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MDE0Mjc4MA==&mid=2650997771&idx=1&sn=63da21da52ac709d90080ff4837fb474&chksm=bdbefc588ac9754ef8dbc059ed9cbe43f03aa32828ba60f85869f2591a107eea4162805457f6&mpshare=1&scene=1&srcid=0914q64SkH3LWJmJx6UiT9zF#rd">如何设计高可用的微服务架构？</a></p>
<h2 id="在线书籍文档"><a href="#在线书籍文档" class="headerlink" title="在线书籍文档"></a>在线书籍文档</h2><p><a href="https://git-scm.com/book/zh/v2">git-book</a></p>
<p><a href="https://python-parallel-programmning-cookbook.readthedocs.io/zh_CN/latest/index.html">Python并行编程 中文版</a></p>
<p><a href="https://python3-cookbook.readthedocs.io/zh_CN/latest/copyright.html">python3-cookbook(cn)</a></p>
<p><a href="https://doc.oschina.net/grpc?t=56831">gRPC 官方文档中文版 V1.0</a></p>
<p><a href="https://learnku.com/docs/pymotw">Python 3 标准库实例教程</a></p>
<p><a href="https://gunicorn.readthedocs.io/en/latest/">gunicorn代码文档</a></p>
<p><a href="http://www.codingpy.com/books/thinkpython2/00-preface.html">Think Python 2e</a></p>
<p><a href="http://www.aosabook.org/en/index.html">aosabook</a><br>开源软件架构相关书籍两本和500line，可以了解别人为何进行这样的设计<br>中文:<a href="http://www.ituring.com.cn/book/1143">开源软件架构-图灵</a> <a href="https://github.com/caochun/aosabook.cc">开源软件架构-github</a></p>
<p><a href="http://accu.cc/">accu</a><br>数字图像，python, go等</p>
<h2 id="博客"><a href="#博客" class="headerlink" title="博客"></a>博客</h2><p><a href="https://coolshell.cn/">酷壳</a><br>左耳朵耗子，涵盖很多内容。</p>
<p><a href="https://blog.codingnow.com/">风云的BLOG</a><br>风云的博客，涵盖很多内容。</p>
<p><a href="https://debugtalk.com/">DebugTalk</a><br>源于搜索性能测试时搜索到文章<a href="https://debugtalk.com/post/locustplus-talk-about-performance-test/">漫谈服务端性能测试</a>，之后又在Pycon 2018深圳场见到博主。该微博主要说得是测试范围的知识</p>
<p><a href="https://www.xncoding.com/">熊能</a><br>一个先使用python后面转java的博主，源于<a href="https://python3-cookbook.readthedocs.io/zh_CN/latest/copyright.html">python3-cookbook(cn)</a>找到的博客</p>
<p><a href="https://blog.laisky.com/archives/1/">Laisky</a><br>后端开发博主，主要语言为python,go,java 源于找到文章<a href="https://blog.laisky.com/p/gitflow/">使用 Git &amp; Gitflow 管理代码开发、发布流程</a></p>
<p><a href="http://blog.zhanglun.me/">lunge</a><br>目前机器学习算法的比较多</p>
<p><a href="http://xiaorui.cc/">峰云就她了</a><br>专注于GOLANG、PYTHON、DB、CLUSTER</p>
<p><a href="https://blog.ansheng.me/archive">ansheng</a><br>Python相关</p>
<p><a href="http://mysql.taobao.org/monthly/">淘宝mysql内核月报</a></p>
<p><a href="http://www.wklken.me/">wkllen</a><br>一开始使用vim时就使用到wklen的k-vim配置，然后就找到她的博客，主要内容是vim, python 以及k8s</p>
<p><a href="https://www.zlovezl.cn/">zlovezl</a><br>内容大多都是Python,目前在腾讯工作的大佬</p>
<p><a href="https://harttle.land/">Harttle</a><br>js相关</p>
<p><a href="http://xidui.github.io/">xidui</a></p>
<p><a href="https://strcpy.me/">strcpy</a></p>
<p><a href="https://weizhimiao.github.io/">weizhimiao</a></p>
<p><a href="https://cmgs.me/archive">CMGS</a></p>
<h2 id="技术网站"><a href="#技术网站" class="headerlink" title="技术网站"></a>技术网站</h2><p><a href="https://www.infoq.cn/">InfoQ</a><br>经常会有很多技术干货，文章偏架构师</p>
<p><a href="http://blog.jobbole.com/">伯乐在线</a><br>一个挺好的网站，很多基础知识介绍的文章都有，不过近几年文章质量下滑了</p>
<p><a href="http://www.pythontutor.com/visualize.html#mode=edit">pythontutor</a><br>帮忙分析python程序运行的网站</p>
<p><a href="https://ops-coffee.cn/">运维咖啡吧</a></p>
<h2 id="sip"><a href="#sip" class="headerlink" title="sip"></a>sip</h2><p><a href="https://acalustra.com/how-can-i-monitor-my-voip-application.html">How can I monitor my Voip Application?</a></p>
<h2 id="js"><a href="#js" class="headerlink" title="js"></a>js</h2><p><a href="http://es6.ruanyifeng.com/#docs/function#">ECMAScript 6 入门</a></p>
<p><a href="https://zh.javascript.info/">现代 Javascript 教程</a></p>
]]></content>
      <categories>
        <category>收藏</category>
      </categories>
      <tags>
        <tag>收藏</tag>
      </tags>
  </entry>
  <entry>
    <title>redis-py</title>
    <url>/2017/12/30/27_tr_redis_py/</url>
    <content><![CDATA[<h2 id="前记"><a href="#前记" class="headerlink" title="前记"></a>前记</h2><p>之前自己渣渣翻译的<a href="https://pypi.python.org/pypi/redis">redi-py</a>文档,redis-py可以使用python操作redis数据库</p>
<span id="more"></span>
<h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><h3 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h3><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> redis<br><span class="hljs-meta">&gt;&gt;&gt; </span>r = redis.StrictRedis(host=<span class="hljs-string">&#x27;localhost&#x27;</span>, port=<span class="hljs-number">6379</span>, db=<span class="hljs-number">0</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>r.<span class="hljs-built_in">set</span>(<span class="hljs-string">&#x27;foo&#x27;</span>, <span class="hljs-string">&#x27;bar&#x27;</span>)<br><span class="hljs-literal">True</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>r.get(<span class="hljs-string">&#x27;foo&#x27;</span>)<br><span class="hljs-string">&#x27;bar&#x27;</span><br></code></pre></td></tr></table></figure>
<h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><p>Redis官方的命令文档<a href="https://redis.io/commands">英文</a>,<a href="http://www.redis.cn/documentation.html">中文</a>做了详细的讲解每个命令的的工作。redis-py公开了两个实现这些命令的类。StrictRedis类尝试遵守官方命令语法。不过有一些例外：</p>
<ul>
<li>SELECT：未实现。请参阅下面的“线程安全”部分中的说明。</li>
<li>DEL：“del”是Python语法中的保留关键字。因此redis-py使用’delete’来代替。</li>
<li>CONFIG GET | SET：这些分别以config_get或config_set来实现。</li>
<li>MULTI / EXEC：这些被实现为Pipeline类的一部分。在执行时，默认情况下，管道是用MULTI和EXEC语句包装的，可以通过指定transaction = False来禁用。查看下面更多关于管道的说明。</li>
<li>SUBSCRIBE / LISTEN：与管道类似，PubSub作为独立的类来实现，因为它将底层连接置于无法执行非pubsub命令的状态。从Redis客户端调用pubsub方法将返回一个PubSub实例，您可以在其中订阅频道并侦听消息。您只能从Redis客户端调用PUBLISH（ 有关详细信息，请参阅 第151期的此评论）。</li>
<li>SCAN / SSCAN / HSCAN / ZSCAN：* SCAN命令按Redis文档中存在的方式执行。另外，每个命令都有一个等价的迭代器方法。这些纯粹是为了方便，所以用户在迭代时不必跟踪光标。对此行为使用scan_iter / sscan_iter / hscan_iter / zscan_iter方法。</li>
</ul>
<p>除了上面所做的更改外，Redis类（StrictRedis的一个子类）还覆盖了其他几个命令，以便与redis-py的旧版本向后兼容：</p>
<ul>
<li>LREM：“num”和“value”参数的顺序相反，使得“num”可以提供默认值零。</li>
<li>ZADD：Redis在’value’之前指定’score’参数。人们使用它们之后才发现这些参数被意外交换。Redis类期望* args的形式为： name1，score1，name2，score2，…</li>
<li>SETEX：“时间”和“值”参数的顺序相反</li>
</ul>
<h3 id="连接池"><a href="#连接池" class="headerlink" title="连接池"></a>连接池</h3><p>redis-py使用连接池来管理与Redis服务器的连接。默认情况下，创建的每个Redis实例将依次创建自己的连接池。可以通过将已创建的连接池实例传递给Redis类的connection_pool参数来覆盖此行为并使用现有连接池。通过这样做，可以实现客户端分片或更好地控制连接的管理方式。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>pool = redis.ConnectionPool(host=<span class="hljs-string">&#x27;localhost&#x27;</span>, port=<span class="hljs-number">6379</span>, db=<span class="hljs-number">0</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>r = redis.Redis(connection_pool=pool)<br></code></pre></td></tr></table></figure>
<h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><p>ConnectionPools管理一组Connection实例。redis-py提供两种类型的连接。默认的Connection是一个普通的基于TCP  socke的连接。UnixDomainSocketConnection允许在与相同的服务器设备上运行的客户端通过unix域套接字进行连接。要使用UnixDomainSocketConnection连接，只需将unix_socket_path参数（它是一个字符串）传递给UnixDomainSocket文件。此外，请确保redis.conf文件中定义了unixsocket参数。因为它被默认注释掉了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>r = redis.Redis(unix_socket_path=<span class="hljs-string">&#x27;/tmp/redis.sock&#x27;</span>)<br></code></pre></td></tr></table></figure>
<p>您也可以创建自己的Connection子类。如果想在异步框架中控制套接字行为，这可能很有用。要使用自己的连接实例化客户端类，需要创建一个连接池，将类传递给connection_class参数。传递给池的其他关键字参数将传递给在初始化过程中指定的类。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>pool = redis.ConnectionPool(connection_class=YourConnectionClass,<br>                                your_arg=<span class="hljs-string">&#x27;...&#x27;</span>, ...)<br></code></pre></td></tr></table></figure>
<h3 id="解析器"><a href="#解析器" class="headerlink" title="解析器"></a>解析器</h3><p>解析器类提供了一种方法来控制如何解析来自Redis服务器的响应。redis-py提供了两个解析器类，PythonParser和HiredisParser。默认情况下，如果已安装hiredis模块，redis-py将尝试使用HiredisParser，否则将回退到PythonParser。</p>
<p>Hiredis是由Redis核心团队维护的C库。Pieter Noordhuis非常友好地创建了Python绑定。使用Hiredis可以使Redis服务器的响应速度提高10倍。当检索许多数据时（例如从LRANGE或SMEMBERS操作），性能提升最为明显<br>可以使用pip进行安装</p>
<h3 id="响应回调"><a href="#响应回调" class="headerlink" title="响应回调"></a>响应回调</h3><p>客户端类使用一组回调来将Redis响应转换为适当的Python类型。在名为RESPONSE_CALLBACKS的dict中，Redis客户端类中定义了许多这样的回调。<br>每个实例的基础上可以使用自定义回调set_response_callback方法添加。该方法接受两个参数：命令名称和回调。以这种方式添加的回调仅在添加了回调的实例上有效。如果要定义或覆盖全局回调，则应该创建Redis客户端的子类并将其回调添加到其RESPONSE_CALLBACKS类dict中。<br>响应回调至少需要一个参数：来自Redis服务器的响应。关键字参数也可以被接受，以便进一步控制如何解释响应。这些关键字参数在命令调用execute_command期间被指定。ZRANGE实现通过其“withscores”参数来演示响应回调关键字参数的使用。</p>
<h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><p>Redis客户端实例可以在线程之间安全地共享。在内部，连接实例只能在命令执行期间从连接池中获取，并在之后直接返回到池中。命令执行不会修改客户端实例的状态。<br>但是，有一个另外：Redis的SELECT命令。SELECT命令允许切换连接当前正在使用的数据库。该数据库保持选定状态，直到选择另一个数据库或连接关闭。这会产生一个问题，连接可能会返回到连接到不同数据库的池。<br>因此，redis-py不会在客户端实例上实现SELECT命令。如果在同一应用程序中使用多个Redis数据库，则应为每个数据库创建一个单独的客户端实例（可能还有一个单独的连接池）。<br>在线程之间传递PubSub或Pipeline对象是不安全的。</p>
<h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><p> 管道是Redis类的一个子类，它提供了在一个请求中缓存多个到服务器的命令的支持。通过减少客户端和服务器之间来回TCP数据包的数量，可以大大提高命令组的性能。<br> <figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"> &gt;&gt;&gt; r = redis.Redis(...)<br><span class="hljs-meta">&gt;&gt;&gt; </span>r.<span class="hljs-built_in">set</span>(<span class="hljs-string">&#x27;bing&#x27;</span>, <span class="hljs-string">&#x27;baz&#x27;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># Use the pipeline() method to create a pipeline instance</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>pipe = r.pipeline()<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># The following SET commands are buffered</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>pipe.<span class="hljs-built_in">set</span>(<span class="hljs-string">&#x27;foo&#x27;</span>, <span class="hljs-string">&#x27;bar&#x27;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>pipe.get(<span class="hljs-string">&#x27;bing&#x27;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># the EXECUTE call sends all buffered commands to the server, returning</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># a list of responses, one for each command.</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>pipe.execute()<br>[<span class="hljs-literal">True</span>, <span class="hljs-string">&#x27;baz&#x27;</span>]<br></code></pre></td></tr></table></figure><br> 为了便于使用，缓冲到管道中的所有命令都返回管道对象本身。因此，调用可以像链接一样<br> <figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"> &gt;&gt;&gt; pipe.<span class="hljs-built_in">set</span>(<span class="hljs-string">&#x27;foo&#x27;</span>, <span class="hljs-string">&#x27;bar&#x27;</span>).sadd(<span class="hljs-string">&#x27;faz&#x27;</span>, <span class="hljs-string">&#x27;baz&#x27;</span>).incr(<span class="hljs-string">&#x27;auto_number&#x27;</span>).execute()<br>[<span class="hljs-literal">True</span>, <span class="hljs-literal">True</span>, <span class="hljs-number">6</span>]<br></code></pre></td></tr></table></figure><br>此外，默认状态下，管道还可以确保缓冲的命令作为一个组自动执行。如果你想禁用管道的原子特性，但仍想缓冲命令，可以关闭事务。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>pipe = r.pipeline(transaction=<span class="hljs-literal">False</span>)<br></code></pre></td></tr></table></figure>
<h3 id="发布-订阅"><a href="#发布-订阅" class="headerlink" title="发布/订阅"></a>发布/订阅</h3><p>redis-py包含一个PubSub对象，用于订阅频道并侦听新消息。创建PubSub对象如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>r = redis.StrictRedis(...)<br><span class="hljs-meta">&gt;&gt;&gt; </span>p = r.pubsub()<br></code></pre></td></tr></table></figure>
<p>一旦创建了PubSub实例，可以订阅给定模式的频道。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>p.subscribe(<span class="hljs-string">&#x27;my-first-channel&#x27;</span>, <span class="hljs-string">&#x27;my-second-channel&#x27;</span>, ...)<br><span class="hljs-meta">&gt;&gt;&gt; </span>p.psubscribe(<span class="hljs-string">&#x27;my-*&#x27;</span>, ...)<br></code></pre></td></tr></table></figure>
<p>在PubSub的实例订阅的频道/模式后，可以通过阅读PubSub 实例的消息来查看订阅</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>p.get_message()<br>&#123;<span class="hljs-string">&#x27;pattern&#x27;</span>: <span class="hljs-literal">None</span>, <span class="hljs-string">&#x27;type&#x27;</span>: <span class="hljs-string">&#x27;subscribe&#x27;</span>, <span class="hljs-string">&#x27;channel&#x27;</span>: <span class="hljs-string">&#x27;my-second-channel&#x27;</span>, <span class="hljs-string">&#x27;data&#x27;</span>: <span class="hljs-number">1L</span>&#125;<br><span class="hljs-meta">&gt;&gt;&gt; </span>p.get_message()<br>&#123;<span class="hljs-string">&#x27;pattern&#x27;</span>: <span class="hljs-literal">None</span>, <span class="hljs-string">&#x27;type&#x27;</span>: <span class="hljs-string">&#x27;subscribe&#x27;</span>, <span class="hljs-string">&#x27;channel&#x27;</span>: <span class="hljs-string">&#x27;my-first-channel&#x27;</span>, <span class="hljs-string">&#x27;data&#x27;</span>: <span class="hljs-number">2L</span>&#125;<br><span class="hljs-meta">&gt;&gt;&gt; </span>p.get_message()<br>&#123;<span class="hljs-string">&#x27;pattern&#x27;</span>: <span class="hljs-literal">None</span>, <span class="hljs-string">&#x27;type&#x27;</span>: <span class="hljs-string">&#x27;psubscribe&#x27;</span>, <span class="hljs-string">&#x27;channel&#x27;</span>: <span class="hljs-string">&#x27;my-*&#x27;</span>, <span class="hljs-string">&#x27;data&#x27;</span>: <span class="hljs-number">3L</span>&#125;<br></code></pre></td></tr></table></figure>
<p>每个从PubSub实例读取的消息都是一个包含以下key的dict。</p>
<ul>
<li>类型： ‘subscribe’, ‘unsubscribe’, ‘psubscribe’, ‘punsubscribe’, ‘message’, ‘pmessage’。备注:发送者(pub)发送消息，订阅者(sub)接收消息</li>
<li>频道：订阅或消息发布到的频道</li>
<li>模式：匹配发布消息频道的模式。如果是None时，那模式就是除“pmessage”类型外的所有情况</li>
<li>数据：消息数据。订阅者订阅消息时，此值将是连接当前订阅的通道和模式的数量。发布者发布消息时，这个值将是实际发布消息的数量</li>
</ul>
<p>发布消息的栗子:<br>publish方法返回匹配频道和订阅模式的号码。 ‘my-first-channel’同时匹配’my-first-channel’和’my-*‘订阅模式，所以这个消息将被传送到2个通道/模式</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>r.publish(<span class="hljs-string">&#x27;my-first-channel&#x27;</span>, <span class="hljs-string">&#x27;some data&#x27;</span>)<br><span class="hljs-number">2</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>p.get_message()<br>&#123;<span class="hljs-string">&#x27;channel&#x27;</span>: <span class="hljs-string">&#x27;my-first-channel&#x27;</span>, <span class="hljs-string">&#x27;data&#x27;</span>: <span class="hljs-string">&#x27;some data&#x27;</span>, <span class="hljs-string">&#x27;pattern&#x27;</span>: <span class="hljs-literal">None</span>, <span class="hljs-string">&#x27;type&#x27;</span>: <span class="hljs-string">&#x27;message&#x27;</span>&#125;<br><span class="hljs-meta">&gt;&gt;&gt; </span>p.get_message()<br>&#123;<span class="hljs-string">&#x27;channel&#x27;</span>: <span class="hljs-string">&#x27;my-first-channel&#x27;</span>, <span class="hljs-string">&#x27;data&#x27;</span>: <span class="hljs-string">&#x27;some data&#x27;</span>, <span class="hljs-string">&#x27;pattern&#x27;</span>: <span class="hljs-string">&#x27;my-*&#x27;</span>, <span class="hljs-string">&#x27;type&#x27;</span>: <span class="hljs-string">&#x27;pmessage&#x27;</span>&#125;<br></code></pre></td></tr></table></figure>
<p>取消订阅就像订阅一样。如果没有参数传递给发送者取消订阅，则所有通道或模式都将取消订阅</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>p.unsubscribe()<br><span class="hljs-meta">&gt;&gt;&gt; </span>p.punsubscribe(<span class="hljs-string">&#x27;my-*&#x27;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>p.get_message()<br>&#123;<span class="hljs-string">&#x27;channel&#x27;</span>: <span class="hljs-string">&#x27;my-second-channel&#x27;</span>, <span class="hljs-string">&#x27;data&#x27;</span>: <span class="hljs-number">2L</span>, <span class="hljs-string">&#x27;pattern&#x27;</span>: <span class="hljs-literal">None</span>, <span class="hljs-string">&#x27;type&#x27;</span>: <span class="hljs-string">&#x27;unsubscribe&#x27;</span>&#125;<br><span class="hljs-meta">&gt;&gt;&gt; </span>p.get_message()<br>&#123;<span class="hljs-string">&#x27;channel&#x27;</span>: <span class="hljs-string">&#x27;my-first-channel&#x27;</span>, <span class="hljs-string">&#x27;data&#x27;</span>: <span class="hljs-number">1L</span>, <span class="hljs-string">&#x27;pattern&#x27;</span>: <span class="hljs-literal">None</span>, <span class="hljs-string">&#x27;type&#x27;</span>: <span class="hljs-string">&#x27;unsubscribe&#x27;</span>&#125;<br><span class="hljs-meta">&gt;&gt;&gt; </span>p.get_message()<br>&#123;<span class="hljs-string">&#x27;channel&#x27;</span>: <span class="hljs-string">&#x27;my-*&#x27;</span>, <span class="hljs-string">&#x27;data&#x27;</span>: <span class="hljs-number">0L</span>, <span class="hljs-string">&#x27;pattern&#x27;</span>: <span class="hljs-literal">None</span>, <span class="hljs-string">&#x27;type&#x27;</span>: <span class="hljs-string">&#x27;punsubscribe&#x27;</span>&#125;<br></code></pre></td></tr></table></figure>
<p>redis-py也允许注册回调函数来处理发布的消息。消息处理（函数）只接受一个参数:message（像上面的例子那样是一个dict）。要使用消息处理（函数）订阅通道/模式，请将通道或模式名称作为关键字参数传递，其值为回调函数。</p>
<p>当消息在消息处理的通道或模式中读取时，将创建消息字典并将其传递给消息处理。在这种情况下，get_message（）返回一个None值，因为消息已经被处理了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">my_handler</span>(<span class="hljs-params">message</span>):</span><br><span class="hljs-meta">... </span>    <span class="hljs-built_in">print</span> (<span class="hljs-string">&#x27;MY HANDLER: &#x27;</span>), message[<span class="hljs-string">&#x27;data&#x27;</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>p.subscribe(**&#123;<span class="hljs-string">&#x27;my-channel&#x27;</span>: my_handler&#125;)<br>＃阅读订阅确认消息<br><span class="hljs-meta">&gt;&gt;&gt; </span>p.get_message()<br>&#123;<span class="hljs-string">&#x27;pattern&#x27;</span>: <span class="hljs-literal">None</span>, <span class="hljs-string">&#x27;type&#x27;</span>: <span class="hljs-string">&#x27;subscribe&#x27;</span>, <span class="hljs-string">&#x27;channel&#x27;</span>: <span class="hljs-string">&#x27;my-channel&#x27;</span>, <span class="hljs-string">&#x27;data&#x27;</span>: <span class="hljs-number">1L</span>&#125;<br><span class="hljs-meta">&gt;&gt;&gt; </span>r.publish(<span class="hljs-string">&#x27;my-channel&#x27;</span>, <span class="hljs-string">&#x27;awesome data&#x27;</span>)<br><span class="hljs-number">1</span><br>＃对于消息处理程序的工作，可以通过get_message（）函数告诉实例读取数据<br><span class="hljs-meta">&gt;&gt;&gt; </span>message = p.get_message()<br>MY HANDLER:  awesome data<br><span class="hljs-meta">&gt;&gt;&gt; </span>print(message)<br><span class="hljs-literal">None</span><br></code></pre></td></tr></table></figure>
<p>如果对订阅/取消订阅的确认消息不感兴趣，则可以通过将ignore_subscribe_messages = True传递给r.pubsub（）来忽略它们 。这将导致所有订阅/取消订阅消息被读取</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>p = r.pubsub(ignore_subscribe_messages=<span class="hljs-literal">True</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>p.subscribe(<span class="hljs-string">&#x27;my-channel&#x27;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>p.get_message()  <span class="hljs-comment"># hides the subscribe message and returns None</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>r.publish(<span class="hljs-string">&#x27;my-channel&#x27;</span>)<br><span class="hljs-number">1</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>p.get_message()<br>&#123;<span class="hljs-string">&#x27;channel&#x27;</span>: <span class="hljs-string">&#x27;my-channel&#x27;</span>, <span class="hljs-string">&#x27;data&#x27;</span>: <span class="hljs-string">&#x27;my data&#x27;</span>, <span class="hljs-string">&#x27;pattern&#x27;</span>: <span class="hljs-literal">None</span>, <span class="hljs-string">&#x27;type&#x27;</span>: <span class="hljs-string">&#x27;message&#x27;</span>&#125;<br></code></pre></td></tr></table></figure>


<p>get_message（）使用系统的“select”模块快速查询连接的 socket。如果可以读取数据，get_message（）将读取它，格式化消息并返回，或者将消息传递给消息处理程序。如果没有要读取的数据，get_message（）会立即返回None。这使得将它集成到应用程序中的现有事件循环中变得容易</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br><span class="hljs-meta">&gt;&gt;&gt; </span>    message = p.get_message()<br><span class="hljs-meta">&gt;&gt;&gt; </span>    <span class="hljs-keyword">if</span> message:<br><span class="hljs-meta">&gt;&gt;&gt; </span>        <span class="hljs-comment"># 处理消息</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>    time.sleep(<span class="hljs-number">0.001</span>)  <span class="hljs-comment">#增加点延迟</span><br></code></pre></td></tr></table></figure>
<p>除了使用.get_message（）外还有其他的方式可以来阅读信息<br>1.阻塞<br>旧版本的redis-py只能用pubsub.listen（）读取消息。listen（）是一个生成器（直到有可用的消息，才解除阻塞）。如果应用程序不需要执行其他任何操作，只需接收和处理从redis接收到的消息，那么listen（）是最简单容易的方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">for</span> message <span class="hljs-keyword">in</span> p.listen():<br><span class="hljs-meta">... </span>    <span class="hljs-comment"># 处理消息</span><br></code></pre></td></tr></table></figure>
<p>2.非阻塞<br>pubsub.run_in_thread（）创建一个新线程并启动事件循环，线程对象返回给run_in_thread（）的调用者。调用者可以使用thread.stop（）方法关闭事件循环和线程。<br>run_in_thread（），其实只是get_message（）的一个封装，使它在一个单独的线程中运行时，本质上创建了一个非常小的非阻塞事件循环。 run_in_thread（）有一个可选的sleep_time参数。如果指定参数，则事件循环将调用每次迭代时time.sleep()的值。</p>
<p>注意：由于在一个单独的线程中运行，因此无法处理那些不能自动处理和注册小心的函数。因此，如果订阅了没有附加消息处理函数的模式/通道，redis-py将阻止调用run_in_thread（）。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>p.subscribe(**&#123;<span class="hljs-string">&#x27;my-channel&#x27;</span>: my_handler&#125;)<br><span class="hljs-meta">&gt;&gt;&gt; </span>thread = p.run_in_thread(sleep_time=<span class="hljs-number">0.001</span>)<br><span class="hljs-comment"># 事件循环现在正在后台处理消息</span><br><span class="hljs-comment"># 中，直到它被关闭的时...</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>thread.stop()<br></code></pre></td></tr></table></figure>
<p>一个PubSub对象的编码与创建它的客户端实例相同。在发送到Redis之前，任何使用unicode的通道/模式都将使用客户端上指定的字符串编码。如果客户端的decode_responses设置为False（缺省值），则消息字典中的’channel’，’pattern’和’data’值将是（Python 2中的str，Python 3中的bit）。如果客户端的 decode_responses为True，那么’channel’，’pattern’和’data’值将被自动解码为使用客户端字的 unicode字符串编码。</p>
<p>PubSub对象记住它订阅的频道和模式。如果发生网络错误或超时等断开事件，之后又重新连接时，PubSub对象将重新订阅之前的所有通道和模式。不过客户端断开连接时发布的消息则无法传送。所以，当使用完PubSub对象时，要调用 .close（）方法关闭连接。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>p = r.pubsub()<br><span class="hljs-meta">&gt;&gt;&gt; </span>...<br><span class="hljs-meta">&gt;&gt;&gt; </span>p.close()<br></code></pre></td></tr></table></figure>

<p>PubSub对象还支持PUBSUB子命令CHANNELS，NUMSUB和NUMPAT的设置</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>r.pubsub_channels()<br>[<span class="hljs-string">&#x27;foo&#x27;</span>, <span class="hljs-string">&#x27;bar&#x27;</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>r.pubsub_numsub(<span class="hljs-string">&#x27;foo&#x27;</span>, <span class="hljs-string">&#x27;bar&#x27;</span>)<br>[(<span class="hljs-string">&#x27;foo&#x27;</span>, <span class="hljs-number">9001</span>), (<span class="hljs-string">&#x27;bar&#x27;</span>, <span class="hljs-number">42</span>)]<br><span class="hljs-meta">&gt;&gt;&gt; </span>r.pubsub_numsub(<span class="hljs-string">&#x27;baz&#x27;</span>)<br>[(<span class="hljs-string">&#x27;baz&#x27;</span>, <span class="hljs-number">0</span>)]<br><span class="hljs-meta">&gt;&gt;&gt; </span>r.pubsub_numpat()<br><span class="hljs-number">1204</span><br></code></pre></td></tr></table></figure>
<h3 id="提供Sentinel支持"><a href="#提供Sentinel支持" class="headerlink" title="提供Sentinel支持"></a>提供Sentinel支持</h3><p><a href="http://doc.redisfans.com/topic/sentinel.html">关于Sentinel(哨兵)</a><br>redis-py可以与Redis Sentinel一起用于发现Redis节点。不过需要运行至少一个Sentinel守护进程才能使用redis-py的Sentinel支持。</p>
<p>将redis-py连接到Sentinel实例很容易。可以使用Sentinel连接来发现主从之间的网络地址：<br>ps:主设备（用于写操作）,从设备（用于只读操作）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> redis.sentinel <span class="hljs-keyword">import</span> Sentinel<br><span class="hljs-meta">&gt;&gt;&gt; </span>sentinel = Sentinel([(<span class="hljs-string">&#x27;localhost&#x27;</span>, <span class="hljs-number">26379</span>)], socket_timeout=<span class="hljs-number">0.1</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>sentinel.discover_master(<span class="hljs-string">&#x27;mymaster&#x27;</span>)<br>(<span class="hljs-string">&#x27;127.0.0.1&#x27;</span>, <span class="hljs-number">6379</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>sentinel.discover_slaves(<span class="hljs-string">&#x27;mymaster&#x27;</span>)<br>[(<span class="hljs-string">&#x27;127.0.0.1&#x27;</span>, <span class="hljs-number">6380</span>)]<br></code></pre></td></tr></table></figure>
<p>也可以从Sentinel实例创建Redis客户端连接主从设备。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>master = sentinel.master_for(<span class="hljs-string">&#x27;mymaster&#x27;</span>, socket_timeout=<span class="hljs-number">0.1</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>slave = sentinel.slave_for(<span class="hljs-string">&#x27;mymaster&#x27;</span>, socket_timeout=<span class="hljs-number">0.1</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>master.<span class="hljs-built_in">set</span>(<span class="hljs-string">&#x27;foo&#x27;</span>, <span class="hljs-string">&#x27;bar&#x27;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>slave.get(<span class="hljs-string">&#x27;foo&#x27;</span>)<br><span class="hljs-string">&#x27;bar&#x27;</span><br></code></pre></td></tr></table></figure>
<p>主对象和从属对象是正常的StrictRedis实例，其连接池绑定到Sentinel实例。当支持Sentinel的客户端尝试建立连接时，它首先查询Sentinel服务器以确定要连接的适当主机。如果找不到服务器，则会引发MasterNotFoundError或SlaveNotFoundError，这两个类都是ConnectionError的子类。<br>当尝试连接到从属客户端时，Sentinel连接池将遍历从属列表，直到找到可以连接的从属客户端。如果没有从属客户端可以连接，则与主站建立连接。</p>
<h3 id="扫描迭代器"><a href="#扫描迭代器" class="headerlink" title="扫描迭代器"></a>扫描迭代器</h3><p>redis-py可以通过自带的can_iter，hscan_iter， sscan_iter和zscan_iter方法方便的使用Python迭代器</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">for</span> key, value <span class="hljs-keyword">in</span> ((<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>), (<span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>), (<span class="hljs-string">&#x27;C&#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>)):<br><span class="hljs-meta">... </span>    r.<span class="hljs-built_in">set</span>(key, value)<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">for</span> key <span class="hljs-keyword">in</span> r.scan_iter():<br><span class="hljs-meta">... </span>    print(key, r.get(key))<br>A <span class="hljs-number">1</span><br>B <span class="hljs-number">2</span><br>C <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure>

<h3 id="操作文档"><a href="#操作文档" class="headerlink" title="操作文档"></a>操作文档</h3><p><a href="http://redis-py.readthedocs.io/en/latest/#indices-and-tables">文档</a></p>
]]></content>
      <categories>
        <category>文档</category>
      </categories>
      <tags>
        <tag>redis</tag>
        <tag>python</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>aiohttp文档翻译</title>
    <url>/2017/12/29/26_tr_aiohttp/</url>
    <content><![CDATA[<h2 id="前记"><a href="#前记" class="headerlink" title="前记"></a>前记</h2><p><strong>状态弃坑中，官方文档更新了结构要重新编排</strong><br>**完美弃坑，已有人翻译出来:<a href="https://hubertroy.gitbooks.io/aiohttp-chinese-documentation/content/">https://hubertroy.gitbooks.io/aiohttp-chinese-documentation/content/</a>  **</p>
<p>aiohtpp 是用于asyncio和Python的HTTP客户端/服务器。<br>也就是既能充当用户的请求，也能当做一个服务器。</p>
<span id="more"></span>
<p>ps：语法使用python3.5的语法，也就是从</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-meta">@asyncio.coroutine</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">coro</span>(<span class="hljs-params">...</span>):</span><br>    ret = <span class="hljs-keyword">yield</span> <span class="hljs-keyword">from</span> f()<br></code></pre></td></tr></table></figure>
<p>改为</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">coro</span>(<span class="hljs-params">...</span>):</span><br>    ret = <span class="hljs-keyword">await</span> f()<br></code></pre></td></tr></table></figure>

<p>之前为了学习英语+想查文档然后就简单的翻译下<br><a href="http://aiohttp.readthedocs.io/en/stable/toc.html#mastertoc">原网址</a></p>
<h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><p>aiohttp当做请求时:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> aiohttp<br><span class="hljs-keyword">import</span> asyncio<br><span class="hljs-keyword">import</span> async_timeout<br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fetch</span>(<span class="hljs-params">session, url</span>):</span><br>    <span class="hljs-keyword">with</span> async_timeout.timeout(<span class="hljs-number">10</span>):<br>        <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> session.get(url) <span class="hljs-keyword">as</span> response:<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> response.text()<br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> aiohttp.ClientSession() <span class="hljs-keyword">as</span> session:<br>        html = <span class="hljs-keyword">await</span> fetch(session, <span class="hljs-string">&#x27;http://python.org&#x27;</span>)<br>        print(html)<br><br>loop = asyncio.get_event_loop()<br>loop.run_until_complete(main())<br></code></pre></td></tr></table></figure>
<p>当做服务器时</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> aiohttp <span class="hljs-keyword">import</span> web<br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">handle</span>(<span class="hljs-params">request</span>):</span><br>    name = request.match_info.get(<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&quot;Anonymous&quot;</span>)<br>    text = <span class="hljs-string">&quot;Hello, &quot;</span> + name<br>    <span class="hljs-keyword">return</span> web.Response(text=text)<br><br>app = web.Application()<br>app.router.add_get(<span class="hljs-string">&#x27;/&#x27;</span>, handle)<br>app.router.add_get(<span class="hljs-string">&#x27;/&#123;name&#125;&#x27;</span>, handle)<br><br>web.run_app(app)<br></code></pre></td></tr></table></figure>

<h2 id="使用aiohttp进行请求"><a href="#使用aiohttp进行请求" class="headerlink" title="使用aiohttp进行请求"></a>使用aiohttp进行请求</h2><h3 id="提出请求"><a href="#提出请求" class="headerlink" title="提出请求"></a>提出请求</h3><p>先对 url:<a href="https://api.github.com/events">https://api.github.com/events</a> 进行请求，然后返回文本</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> aiohttp<br><span class="hljs-keyword">import</span> asyncio<br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> aiohttp.ClientSession() <span class="hljs-keyword">as</span> session:<br>        <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> session.get(<span class="hljs-string">&#x27;https://api.github.com/events&#x27;</span>) <span class="hljs-keyword">as</span> resp:<br>            print(resp.status)<br>            print(<span class="hljs-keyword">await</span> resp.text())<br><br>loop = asyncio.get_event_loop()<br>loop.run_until_complete(main())<br></code></pre></td></tr></table></figure>
<p>可以看出根requests的语法很像，代码中有一个ClientSession被调用session的ClientResponse对象resp。我们可以从响应中获得所需的所有信息，除了get外，也支持其他http协议</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python">session.post(<span class="hljs-string">&#x27;http://httpbin.org/post&#x27;</span>, data=<span class="hljs-string">b&#x27;data&#x27;</span>)<br>session.put(<span class="hljs-string">&#x27;http://httpbin.org/put&#x27;</span>, data=<span class="hljs-string">b&#x27;data&#x27;</span>)<br>session.delete(<span class="hljs-string">&#x27;http://httpbin.org/delete&#x27;</span>)<br>session.head(<span class="hljs-string">&#x27;http://httpbin.org/get&#x27;</span>)<br>session.options(<span class="hljs-string">&#x27;http://httpbin.org/get&#x27;</span>)<br>session.patch(<span class="hljs-string">&#x27;http://httpbin.org/patch&#x27;</span>, data=<span class="hljs-string">b&#x27;data&#x27;</span>)<br></code></pre></td></tr></table></figure>
<blockquote>
<p>需要注意的是，不必要为每个请求创建一个session，当有多个请求时，把url传入session就可以了，session中包含一个连接池，默认情况下打开连接重用和保持活动</p>
</blockquote>
<h3 id="JSON请求"><a href="#JSON请求" class="headerlink" title="JSON请求"></a>JSON请求</h3><p>通过以下设置，可以让aiohttp发起一个json请求</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> aiohttp.ClientSession() <span class="hljs-keyword">as</span> session:<br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> session.post(json=&#123;<span class="hljs-string">&#x27;test&#x27;</span>: <span class="hljs-string">&#x27;object&#x27;</span>&#125;)<br></code></pre></td></tr></table></figure>
<p>默认情况下使用python自带的json序列,如果需要更改可以更改ClientSession里的json_serialize参数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> ujson<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> aiohttp.ClientSession(json_serialize=ujson.dumps) <span class="hljs-keyword">as</span> session:<br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> session.post(json=&#123;<span class="hljs-string">&#x27;test&#x27;</span>: <span class="hljs-string">&#x27;object&#x27;</span>&#125;)<br></code></pre></td></tr></table></figure>

<h3 id="在url中传递参数"><a href="#在url中传递参数" class="headerlink" title="在url中传递参数"></a>在url中传递参数</h3><p>如果有多次相同请求，只是网址中的键/值不一样时，如httpbin.org/get?key=val，那可以使用params关键字参数，把封装好的dict给aiohttp调用</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">params = &#123;<span class="hljs-string">&#x27;key1&#x27;</span>: <span class="hljs-string">&#x27;value1&#x27;</span>, <span class="hljs-string">&#x27;key2&#x27;</span>: <span class="hljs-string">&#x27;value2&#x27;</span>&#125;<br><span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> session.get(<span class="hljs-string">&#x27;http://httpbin.org/get&#x27;</span>,<br>                       params=params) <span class="hljs-keyword">as</span> resp:<br>    <span class="hljs-keyword">assert</span> <span class="hljs-built_in">str</span>(resp.url) == <span class="hljs-string">&#x27;http://httpbin.org/get?key2=value2&amp;key1=value1&#x27;</span><br></code></pre></td></tr></table></figure>
<p>如果是需要一对多形式的键/值可以采用如下形式，为每个键指定多个值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python">params = [(<span class="hljs-string">&#x27;key&#x27;</span>, <span class="hljs-string">&#x27;value1&#x27;</span>), (<span class="hljs-string">&#x27;key&#x27;</span>, <span class="hljs-string">&#x27;value2&#x27;</span>)]<br><span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> session.get(<span class="hljs-string">&#x27;http://httpbin.org/get&#x27;</span>,<br>                       params=params) <span class="hljs-keyword">as</span> r:<br>    <span class="hljs-keyword">assert</span> <span class="hljs-built_in">str</span>(r.url) == <span class="hljs-string">&#x27;http://httpbin.org/get?key=value2&amp;key=value1&#x27;</span><br></code></pre></td></tr></table></figure>
<p>也可以使用str来当做参数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> session.get(<span class="hljs-string">&#x27;http://httpbin.org/get&#x27;</span>,<br>                       params=<span class="hljs-string">&#x27;key=value+1&#x27;</span>) <span class="hljs-keyword">as</span> r:<br>        <span class="hljs-keyword">assert</span> <span class="hljs-built_in">str</span>(r.url) == <span class="hljs-string">&#x27;http://httpbin.org/get?key=value+1&#x27;</span><br></code></pre></td></tr></table></figure>
<blockquote>
<p>aiohttp在发送请求之前在内部执行URL 标准化<br>例如URL(‘<a href="http://example.com/%D0%BF%D1%83%D1%82%D1%8C%30?a=1&#39;)%E8%A2%AB%E8%BD%AC%E6%8D%A2%E4%B8%BA">http://example.com/путь%30?a=%31&#39;)被转换为</a> URL(‘<a href="http://example.com/%D0%BF%D1%83%D1%82%D1%8C/0?a=1&#39;)%E3%80%82">http://example.com/%D0%BF%D1%83%D1%82%D1%8C/0?a=1&#39;)。</a><br>如果服务器不接受时，可以通过设置encoded来改变</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">await</span> session.get(URL(<span class="hljs-string">&#x27;http://example.com/%30&#x27;</span>, encoded=<span class="hljs-literal">True</span>))<br></code></pre></td></tr></table></figure>

<h3 id="解析的内容"><a href="#解析的内容" class="headerlink" title="解析的内容"></a>解析的内容</h3><ul>
<li>使用text()<br>在aiohttp中会根据网站定义的编码来自动解析网页中的内容，当然，也可以通过设置encoding变量来定义我们要解析的编码格式，如果习惯使用resquests的，要注意这里是text()，待括号的<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">await</span> resp.text(encoding=<span class="hljs-string">&#x27;windows-1251&#x27;</span>)<br></code></pre></td></tr></table></figure></li>
<li>使用read()<br>则解析出来的是二进制的内容，且网页内容过多时，无法全部解析<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">await</span> resp.read()<br></code></pre></td></tr></table></figure></li>
<li>使用json()<br>解析后自动转化为json格式<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> session.get(<span class="hljs-string">&#x27;https://api.github.com/events&#x27;</span>) <span class="hljs-keyword">as</span> resp:<br>    print(<span class="hljs-keyword">await</span> resp.json())<br></code></pre></td></tr></table></figure></li>
<li>流响应内容<br>就是像我们在用python打开文件时，如果文件过大，都不会一下子去打开的，可能是一行一行打开，也可能是一段一段打开，总之就是为了避免内存爆满，后面的东西无法写入。<br>可以使用这样写入<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> session.get(<span class="hljs-string">&#x27;https://api.github.com/events&#x27;</span>) <span class="hljs-keyword">as</span> resp:<br>    <span class="hljs-keyword">await</span> resp.content.read(<span class="hljs-number">10</span>)<br></code></pre></td></tr></table></figure>
但是最好的方式应该为:<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(filename, <span class="hljs-string">&#x27;wb&#x27;</span>) <span class="hljs-keyword">as</span> fd:<br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        chunk = <span class="hljs-keyword">await</span> resp.content.read(chunk_size)<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> chunk:<br>            <span class="hljs-keyword">break</span><br>        fd.write(chunk)<br></code></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="请求的信息-Headers，Cookies"><a href="#请求的信息-Headers，Cookies" class="headerlink" title="请求的信息(Headers，Cookies)"></a>请求的信息(Headers，Cookies)</h3><p>aiohttp中单的ClientResposeClientResponse对象包含request_info属性，其中包含Headers和cookies，可以通过一定的设置来向服务器发送不同的东西。</p>
<ul>
<li>定义Headers<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> json<br>url = <span class="hljs-string">&#x27;https://api.github.com/some/endpoint&#x27;</span><br>payload = &#123;<span class="hljs-string">&#x27;some&#x27;</span>: <span class="hljs-string">&#x27;data&#x27;</span>&#125;<br>headers = &#123;<span class="hljs-string">&#x27;content-type&#x27;</span>: <span class="hljs-string">&#x27;application/json&#x27;</span>&#125;<br><br><span class="hljs-keyword">await</span> session.post(url,<br>                   data=json.dumps(payload),<br>                   headers=headers)<br></code></pre></td></tr></table></figure></li>
<li>定义Cookies<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python">url = <span class="hljs-string">&#x27;http://httpbin.org/cookies&#x27;</span><br>cookies = &#123;<span class="hljs-string">&#x27;cookies_are&#x27;</span>: <span class="hljs-string">&#x27;working&#x27;</span>&#125;<br><span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> ClientSession(cookies=cookies) <span class="hljs-keyword">as</span> session:<br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> session.get(url) <span class="hljs-keyword">as</span> resp:<br>        <span class="hljs-keyword">assert</span> <span class="hljs-keyword">await</span> resp.json() == &#123;<br>           <span class="hljs-string">&quot;cookies&quot;</span>: &#123;<span class="hljs-string">&quot;cookies_are&quot;</span>: <span class="hljs-string">&quot;working&quot;</span>&#125;&#125;<br></code></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="发送表单请求"><a href="#发送表单请求" class="headerlink" title="发送表单请求"></a>发送表单请求</h3><p>在session.post()方法中通过定义data可以设置表单的内容</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python">payload = &#123;<span class="hljs-string">&#x27;key1&#x27;</span>: <span class="hljs-string">&#x27;value1&#x27;</span>, <span class="hljs-string">&#x27;key2&#x27;</span>: <span class="hljs-string">&#x27;value2&#x27;</span>&#125;<br><span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> session.post(<span class="hljs-string">&#x27;http://httpbin.org/post&#x27;</span>,<br>                        data=payload) <span class="hljs-keyword">as</span> resp:<br>    print(<span class="hljs-keyword">await</span> resp.text())<br></code></pre></td></tr></table></figure>

<h3 id="发送文件"><a href="#发送文件" class="headerlink" title="发送文件"></a>发送文件</h3><p>在发送文件时，也可以通过定义filename和content-type来设置文件名和类型</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python">url = <span class="hljs-string">&#x27;http://httpbin.org/post&#x27;</span><br>data = FormData()<br>data.add_field(<span class="hljs-string">&#x27;file&#x27;</span>,<br>               <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;report.xls&#x27;</span>, <span class="hljs-string">&#x27;rb&#x27;</span>),<br>               filename=<span class="hljs-string">&#x27;report.xls&#x27;</span>,<br>               content_type=<span class="hljs-string">&#x27;application/vnd.ms-excel&#x27;</span>)<br><br><span class="hljs-keyword">await</span> session.post(url, data=data)<br></code></pre></td></tr></table></figure>

<h3 id="发送大文件"><a href="#发送大文件" class="headerlink" title="发送大文件"></a>发送大文件</h3><p>如果文件过大，可以通过流的形式进行上传</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;massive-body&#x27;</span>, <span class="hljs-string">&#x27;rb&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>   <span class="hljs-keyword">await</span> session.post(<span class="hljs-string">&#x27;http://httpbin.org/post&#x27;</span>, data=f)<br></code></pre></td></tr></table></figure>
<p>或者可以使用@aiohttp.streamer装饰器</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@aiohttp.streamer</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">file_sender</span>(<span class="hljs-params">writer, file_name=<span class="hljs-literal">None</span></span>):</span><br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(file_name, <span class="hljs-string">&#x27;rb&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>        chunk = f.read(<span class="hljs-number">2</span>**<span class="hljs-number">16</span>)<br>        <span class="hljs-keyword">while</span> chunk:<br>            <span class="hljs-keyword">yield</span> <span class="hljs-keyword">from</span> writer.write(chunk)<br>            chunk = f.read(<span class="hljs-number">2</span>**<span class="hljs-number">16</span>)<br><br><span class="hljs-comment"># Then you can use `file_sender` as a data provider:</span><br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> session.post(<span class="hljs-string">&#x27;http://httpbin.org/post&#x27;</span>,<br>                        data=file_sender(file_name=<span class="hljs-string">&#x27;huge_file&#x27;</span>)) <span class="hljs-keyword">as</span> resp:<br>    print(<span class="hljs-keyword">await</span> resp.text())<br></code></pre></td></tr></table></figure>
<p>也可以使用StreamReader对象进行上传，比如从一个请求下来的内容再上传回去</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">feed_stream</span>(<span class="hljs-params">resp, stream</span>):</span><br>    h = hashlib.sha256()<br><br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        chunk = <span class="hljs-keyword">await</span> resp.content.readany()<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> chunk:<br>            <span class="hljs-keyword">break</span><br>        h.update(chunk)<br>        stream.feed_data(chunk)<br><br>    <span class="hljs-keyword">return</span> h.hexdigest()<br><br>resp = session.get(<span class="hljs-string">&#x27;http://httpbin.org/post&#x27;</span>)<br>stream = StreamReader()<br>loop.create_task(session.post(<span class="hljs-string">&#x27;http://httpbin.org/post&#x27;</span>, data=stream))<br><br>file_hash = <span class="hljs-keyword">await</span> feed_stream(resp, stream)<br></code></pre></td></tr></table></figure>

<h3 id="上传预压缩的数据"><a href="#上传预压缩的数据" class="headerlink" title="上传预压缩的数据"></a>上传预压缩的数据</h3><p>要将传递给aiohttp之前已压缩的数据上传，请使用所使用的压缩算法名称（通常是deflate或zlib）作为Content-Encoding头的值来调用请求函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">my_coroutine</span>(<span class="hljs-params">session, headers, my_data</span>):</span><br>    data = zlib.compress(my_data)<br>    headers = &#123;<span class="hljs-string">&#x27;Content-Encoding&#x27;</span>: <span class="hljs-string">&#x27;deflate&#x27;</span>&#125;<br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> session.post(<span class="hljs-string">&#x27;http://httpbin.org/post&#x27;</span>,<br>                            data=data,<br>                            headers=headers)<br>        <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure>

<h3 id="连接池，Keep-Alive和-cookie共享"><a href="#连接池，Keep-Alive和-cookie共享" class="headerlink" title="连接池，Keep-Alive和 cookie共享"></a>连接池，Keep-Alive和 cookie共享</h3><p>ClientSession 支持保持活动的请求和连接池的开箱即用<br>ClientSession 可用于在多个请求之间共享cookie</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> aiohttp.ClientSession() <span class="hljs-keyword">as</span> session:<br>    <span class="hljs-keyword">await</span> session.get(<br>        <span class="hljs-string">&#x27;http://httpbin.org/cookies/set?my_cookie=my_value&#x27;</span>)<br>    filtered = session.cookie_jar.filter_cookies(<span class="hljs-string">&#x27;http://httpbin.org&#x27;</span>)<br>    <span class="hljs-keyword">assert</span> filtered[<span class="hljs-string">&#x27;my_cookie&#x27;</span>].value == <span class="hljs-string">&#x27;my_value&#x27;</span><br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> session.get(<span class="hljs-string">&#x27;http://httpbin.org/cookies&#x27;</span>) <span class="hljs-keyword">as</span> r:<br>        json_body = <span class="hljs-keyword">await</span> r.json()<br>        <span class="hljs-keyword">assert</span> json_body[<span class="hljs-string">&#x27;cookies&#x27;</span>][<span class="hljs-string">&#x27;my_cookie&#x27;</span>] == <span class="hljs-string">&#x27;my_value&#x27;</span><br></code></pre></td></tr></table></figure>
<p>还可以为所有会话请求设置默认标题</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> aiohttp.ClientSession(<br>    headers=&#123;<span class="hljs-string">&quot;Authorization&quot;</span>: <span class="hljs-string">&quot;Basic bG9naW46cGFzcw==&quot;</span>&#125;) <span class="hljs-keyword">as</span> session:<br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> session.get(<span class="hljs-string">&quot;http://httpbin.org/headers&quot;</span>) <span class="hljs-keyword">as</span> r:<br>        json_body = <span class="hljs-keyword">await</span> r.json()<br>        <span class="hljs-keyword">assert</span> json_body[<span class="hljs-string">&#x27;headers&#x27;</span>][<span class="hljs-string">&#x27;Authorization&#x27;</span>] == \<br>            <span class="hljs-string">&#x27;Basic bG9naW46cGFzcw==&#x27;</span><br></code></pre></td></tr></table></figure>

<h3 id="cookie安全"><a href="#cookie安全" class="headerlink" title="cookie安全"></a>cookie安全</h3><p>RFC 2109明确禁止Cookie使用IP地址而不是DNS名称来接受URL（例如 <a href="http://127.0.0.1/cookie%EF%BC%89%E3%80%82">http://127.0.0.1:80/cookie）。</a><br>默认情况下ClientSession通过aiohttp.CookieJar提供该功能。<br>通过将unsafe = True传递给 aiohttp.CookieJar构造函数来完成，启用对这种cookie的支持</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python">jar = aiohttp.CookieJar(unsafe=<span class="hljs-literal">True</span>)<br>session = aiohttp.ClientSession(cookie_jar=jar)<br></code></pre></td></tr></table></figure>

<h3 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a>连接器</h3><p>要调整或更改传输层的请求，您可以将自定义连接器传递 给ClientSession</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python">conn = aiohttp.TCPConnector()<br>session = aiohttp.ClientSession(connector=conn)<br></code></pre></td></tr></table></figure>

<h3 id="通过连机器限制连接池大小"><a href="#通过连机器限制连接池大小" class="headerlink" title="通过连机器限制连接池大小"></a>通过连机器限制连接池大小</h3><p>默认是100个请求，但可以通过limit来设置连接池大小，如果limit是0则代表无限制</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python">conn = aiohttp.TCPConnector(limit=<span class="hljs-number">30</span>)<br></code></pre></td></tr></table></figure>
<p>如果要限制同时打开链接到同一个端点的数量，可以将limit_per_host 参数传递给连接器((host, port, is_ssl) triple)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">conn = aiohttp.TCPConnector(limit_per_host=<span class="hljs-number">30</span>)<br></code></pre></td></tr></table></figure>

<h3 id="使用自定义名称服务器解析"><a href="#使用自定义名称服务器解析" class="headerlink" title="使用自定义名称服务器解析"></a>使用自定义名称服务器解析</h3><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> aiohttp.resolver <span class="hljs-keyword">import</span> AsyncResolver<br><br>resolver = AsyncResolver(nameservers=[<span class="hljs-string">&quot;8.8.8.8&quot;</span>, <span class="hljs-string">&quot;8.8.4.4&quot;</span>])<br>conn = aiohttp.TCPConnector(resolver=resolver)<br></code></pre></td></tr></table></figure>
<p>默认情况下，aiohttp使用严格的HTTPS协议检查。通过将verify_ssl设置为False可以放宽认证检查</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">r = <span class="hljs-keyword">await</span> session.get(<span class="hljs-string">&#x27;https://example.com&#x27;</span>, verify_ssl=<span class="hljs-literal">False</span>)<br></code></pre></td></tr></table></figure>
<p>如果需要设置自定义ssl参数（例如使用自己的认证文件），您可以创建一个ssl.SSLContext实例并将其传递给ClientSession方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">sslcontext = ssl.create_default_context(<br>   cafile=<span class="hljs-string">&#x27;/path/to/ca-bundle.crt&#x27;</span>)<br>r = <span class="hljs-keyword">await</span> session.get(<span class="hljs-string">&#x27;https://example.com&#x27;</span>, ssl_context=sslcontext)<br></code></pre></td></tr></table></figure>
<p>如果您需要验证自签名证书，则可以执行与上一个示例相同的操作，但可以使用ssl.SSLContext.load_cert_chain()添加密钥</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">sslcontext = ssl.create_default_context(<br>   cafile=<span class="hljs-string">&#x27;/path/to/ca-bundle.crt&#x27;</span>)<br>sslcontext.load_cert_chain(<span class="hljs-string">&#x27;/path/to/client/public/device.pem&#x27;</span>,<br>                           <span class="hljs-string">&#x27;/path/to/client/private/device.jey&#x27;</span>)<br>r = <span class="hljs-keyword">await</span> session.get(<span class="hljs-string">&#x27;https://example.com&#x27;</span>, ssl_context=sslcontext)<br></code></pre></td></tr></table></figure>
<p>ssl验证失败时会有明显的错误</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#aiohttp.ClientConnectorSSLError:</span><br><br><span class="hljs-keyword">try</span>:<br>    <span class="hljs-keyword">await</span> session.get(<span class="hljs-string">&#x27;https://expired.badssl.com/&#x27;</span>)<br><span class="hljs-keyword">except</span> aiohttp.ClientConnectorSSLError <span class="hljs-keyword">as</span> e:<br>    <span class="hljs-keyword">assert</span> <span class="hljs-built_in">isinstance</span>(e, ssl.SSLError)<br></code></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#aiohttp.ClientConnectorCertificateError:</span><br><br><span class="hljs-keyword">try</span>:<br>    <span class="hljs-keyword">await</span> session.get(<span class="hljs-string">&#x27;https://wrong.host.badssl.com/&#x27;</span>)<br><span class="hljs-keyword">except</span> aiohttp.ClientConnectorCertificateError <span class="hljs-keyword">as</span> e:<br>    <span class="hljs-keyword">assert</span> <span class="hljs-built_in">isinstance</span>(e, ssl.CertificateError)<br></code></pre></td></tr></table></figure>
<p>如果需要跳过两个SSL相关的错误</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#aiohttp.ClientSSLError:</span><br><br><span class="hljs-keyword">try</span>:<br>    <span class="hljs-keyword">await</span> session.get(<span class="hljs-string">&#x27;https://expired.badssl.com/&#x27;</span>)<br><span class="hljs-keyword">except</span> aiohttp.ClientSSLError <span class="hljs-keyword">as</span> e:<br>    <span class="hljs-keyword">assert</span> <span class="hljs-built_in">isinstance</span>(e, ssl.SSLError)<br><br><span class="hljs-keyword">try</span>:<br>    <span class="hljs-keyword">await</span> session.get(<span class="hljs-string">&#x27;https://wrong.host.badssl.com/&#x27;</span>)<br><span class="hljs-keyword">except</span> aiohttp.ClientSSLError <span class="hljs-keyword">as</span> e:<br>    <span class="hljs-keyword">assert</span> <span class="hljs-built_in">isinstance</span>(e, ssl.CertificateError)<br></code></pre></td></tr></table></figure>
<p>也可以通过SHA256验证</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Attempt to connect to https://www.python.org</span><br><span class="hljs-comment"># with a pin to a bogus certificate:</span><br>bad_fingerprint = <span class="hljs-string">b&#x27;0&#x27;</span>*<span class="hljs-number">64</span><br>exc = <span class="hljs-literal">None</span><br><span class="hljs-keyword">try</span>:<br>    r = <span class="hljs-keyword">await</span> session.get(<span class="hljs-string">&#x27;https://www.python.org&#x27;</span>,<br>                          fingerprint=bad_fingerprint)<br><span class="hljs-keyword">except</span> aiohttp.FingerprintMismatch <span class="hljs-keyword">as</span> e:<br>    exc = e<br><span class="hljs-keyword">assert</span> exc <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span><br><span class="hljs-keyword">assert</span> exc.expected == bad_fingerprint<br><br><span class="hljs-comment"># www.python.org cert&#x27;s actual fingerprint</span><br><span class="hljs-keyword">assert</span> exc.got == <span class="hljs-string">b&#x27;...&#x27;</span><br></code></pre></td></tr></table></figure>

<h3 id="Unix域名sockets"><a href="#Unix域名sockets" class="headerlink" title="Unix域名sockets"></a>Unix域名sockets</h3><p>如果您的HTTP服务器使用UNIX域名sockets，则可以使用 UnixConnector：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python">conn = aiohttp.UnixConnector(path=<span class="hljs-string">&#x27;/path/to/socket&#x27;</span>)<br>session = aiohttp.ClientSession(connector=conn)<br></code></pre></td></tr></table></figure>

<h3 id="使用代理"><a href="#使用代理" class="headerlink" title="使用代理"></a>使用代理</h3><blockquote>
<p>原话:aiohttp supports支持http/https 代理</p>
</blockquote>
<p>然而使用时如果有https代理,会说只支持http代理- -…</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> aiohttp.ClientSession() <span class="hljs-keyword">as</span> session:<br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> session.get(<span class="hljs-string">&quot;http://python.org&quot;</span>,<br>                           proxy=<span class="hljs-string">&quot;http://some.proxy.com&quot;</span>) <span class="hljs-keyword">as</span> resp:<br>        print(resp.status)<br></code></pre></td></tr></table></figure>
<p>如果代理需要账户密码:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> aiohttp.ClientSession() <span class="hljs-keyword">as</span> session:<br>    proxy_auth = aiohttp.BasicAuth(<span class="hljs-string">&#x27;user&#x27;</span>, <span class="hljs-string">&#x27;pass&#x27;</span>)<br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> session.get(<span class="hljs-string">&quot;http://python.org&quot;</span>,<br>                           proxy=<span class="hljs-string">&quot;http://some.proxy.com&quot;</span>,<br>                           proxy_auth=proxy_auth) <span class="hljs-keyword">as</span> resp:<br>        print(resp.status)<br></code></pre></td></tr></table></figure>
<p>不过与requests库相反，它不会默认读取环境变量。但是，您以通过 trust_env=True传入aiohttp.ClientSession 构造函数来从HTTP_PROXY或HTTPS_PROXY 环境变量中提取代理配置 （两者都不区分大小写）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> aiohttp.ClientSession() <span class="hljs-keyword">as</span> session:<br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> session.get(<span class="hljs-string">&quot;http://python.org&quot;</span>, trust_env=<span class="hljs-literal">True</span>) <span class="hljs-keyword">as</span> resp:<br>        print(resp.status)<br></code></pre></td></tr></table></figure>
<h3 id="响应状态码"><a href="#响应状态码" class="headerlink" title="响应状态码"></a>响应状态码</h3><p>可以通过如下查看状态码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> session.get(<span class="hljs-string">&#x27;http://httpbin.org/get&#x27;</span>) <span class="hljs-keyword">as</span> resp:<br>    <span class="hljs-keyword">assert</span> resp.status == <span class="hljs-number">200</span><br></code></pre></td></tr></table></figure>
<h3 id="请求头"><a href="#请求头" class="headerlink" title="请求头"></a>请求头</h3><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-meta">&gt;&gt;&gt; </span>resp.headers<br>&#123;<span class="hljs-string">&#x27;ACCESS-CONTROL-ALLOW-ORIGIN&#x27;</span>: <span class="hljs-string">&#x27;*&#x27;</span>,<br> <span class="hljs-string">&#x27;CONTENT-TYPE&#x27;</span>: <span class="hljs-string">&#x27;application/json&#x27;</span>,<br> <span class="hljs-string">&#x27;DATE&#x27;</span>: <span class="hljs-string">&#x27;Tue, 15 Jul 2014 16:49:51 GMT&#x27;</span>,<br> <span class="hljs-string">&#x27;SERVER&#x27;</span>: <span class="hljs-string">&#x27;gunicorn/18.0&#x27;</span>,<br> <span class="hljs-string">&#x27;CONTENT-LENGTH&#x27;</span>: <span class="hljs-string">&#x27;331&#x27;</span>,<br> <span class="hljs-string">&#x27;CONNECTION&#x27;</span>: <span class="hljs-string">&#x27;keep-alive&#x27;</span>&#125;<br></code></pre></td></tr></table></figure>
<p>虽然是http文件，但是一份特殊的dict根据RFC 7230，HTTP标头名称是不区分大小写的。它也支持与HTTP协议相同的密钥的多个值。<br>所以，我们可以使用任何我们想要的大小来访问头文件</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-meta">&gt;&gt;&gt; </span>resp.headers[<span class="hljs-string">&#x27;Content-Type&#x27;</span>]<br><span class="hljs-string">&#x27;application/json&#x27;</span><br><br><span class="hljs-meta">&gt;&gt;&gt; </span>resp.headers.get(<span class="hljs-string">&#x27;content-type&#x27;</span>)<br><span class="hljs-string">&#x27;application/json&#x27;</span><br></code></pre></td></tr></table></figure>
<p>都使用UTF-8从二进制数据转换为 surrogateescape选项。这在大多数情况下工作正常，但有时如果服务器使用非标准编码，则需要未转换的数据，可以通过使用ClientResponse.raw_headers属性来检索 </p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-meta">&gt;&gt;&gt; </span>resp.raw_headers<br>((<span class="hljs-string">b&#x27;SERVER&#x27;</span>, <span class="hljs-string">b&#x27;nginx&#x27;</span>),<br> (<span class="hljs-string">b&#x27;DATE&#x27;</span>, <span class="hljs-string">b&#x27;Sat, 09 Jan 2016 20:28:40 GMT&#x27;</span>),<br> (<span class="hljs-string">b&#x27;CONTENT-TYPE&#x27;</span>, <span class="hljs-string">b&#x27;text/html; charset=utf-8&#x27;</span>),<br> (<span class="hljs-string">b&#x27;CONTENT-LENGTH&#x27;</span>, <span class="hljs-string">b&#x27;12150&#x27;</span>),<br> (<span class="hljs-string">b&#x27;CONNECTION&#x27;</span>, <span class="hljs-string">b&#x27;keep-alive&#x27;</span>))<br></code></pre></td></tr></table></figure>

<h3 id="获取请求的cookie"><a href="#获取请求的cookie" class="headerlink" title="获取请求的cookie"></a>获取请求的cookie</h3><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python">url = <span class="hljs-string">&#x27;http://example.com/some/cookie/setting/url&#x27;</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> session.get(url) <span class="hljs-keyword">as</span> resp:<br>    print(resp.cookies[<span class="hljs-string">&#x27;example_cookie_name&#x27;</span>])<br></code></pre></td></tr></table></figure>
<p>注意<br>响应cookie仅包含重定向链中最后一个请求Set-Cookie中的值。要在所有重定向请求之间收集cookie，请使用aiohttp.ClientSession对象</p>
<h3 id="请求历史"><a href="#请求历史" class="headerlink" title="请求历史"></a>请求历史</h3><p>如果请求被重定向，则可以使用history属性查看之前的响应</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>resp  =  等待 会话。get （<span class="hljs-string">&#x27;http://example.com/some/redirect/&#x27;</span> ）<br><span class="hljs-meta">&gt;&gt;&gt; </span>resp <br>&lt;ClientResponse（http://example.com/some/other/url/）[<span class="hljs-number">200</span>]&gt; <br><span class="hljs-meta">&gt;&gt;&gt; </span>resp 。历史<br>（&lt;ClientResponse（http://example.com/some/redirect/）[<span class="hljs-number">301</span>]&gt;）<br></code></pre></td></tr></table></figure>
<p>如果没有发生重定向或allow_redirects设置为False，历史记录将是一个空的序列</p>
<h3 id="WebSockets"><a href="#WebSockets" class="headerlink" title="WebSockets"></a>WebSockets</h3><p>在aiohttp中WebSockets是开箱即用的，但是必须使用aiohttp.ClientSession.ws_connect()协程来进行客户端websocket连接。它接受一个url作为第一个参数并返回ClientWebSocketResponse，通过该对象，你可以使用响应的方法与websocket服务器进行通信</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">session = aiohttp.ClientSession()<br><span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> session.ws_connect(<span class="hljs-string">&#x27;http://example.org/websocket&#x27;</span>) <span class="hljs-keyword">as</span> ws:<br><br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">for</span> msg <span class="hljs-keyword">in</span> ws:<br>        <span class="hljs-keyword">if</span> msg.<span class="hljs-built_in">type</span> == aiohttp.WSMsgType.TEXT:<br>            <span class="hljs-keyword">if</span> msg.data == <span class="hljs-string">&#x27;close cmd&#x27;</span>:<br>                <span class="hljs-keyword">await</span> ws.close()<br>                <span class="hljs-keyword">break</span><br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">await</span> ws.send_str(msg.data + <span class="hljs-string">&#x27;/answer&#x27;</span>)<br>        <span class="hljs-keyword">elif</span> msg.<span class="hljs-built_in">type</span> == aiohttp.WSMsgType.CLOSED:<br>            <span class="hljs-keyword">break</span><br>        <span class="hljs-keyword">elif</span> msg.<span class="hljs-built_in">type</span> == aiohttp.WSMsgType.ERROR:<br>            <span class="hljs-keyword">break</span><br></code></pre></td></tr></table></figure>
<p>注意:只能使用一个websocket任务进行读写(如await ws.receive() 和 async for msg in ws:)<br>但是可以使用多个异步读写数据(如:ws.send_str(‘data’)</p>
<h3 id="超时"><a href="#超时" class="headerlink" title="超时"></a>超时</h3><p>默认情况下所有IO操作都有5分钟的超时时间 可以通过传入timeout参数到ClientSession.get()来设置超时，当设置None或0时，禁用超时检查</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> session.get(<span class="hljs-string">&#x27;https://github.com&#x27;</span>, timeout=<span class="hljs-number">60</span>) <span class="hljs-keyword">as</span> r:<br></code></pre></td></tr></table></figure>
<p>如果是按流的形式写入数据，可以使用async_timeout.timeout()，为连接和响应正文读取过程添加了超时</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> async_timeout<br><br><span class="hljs-keyword">with</span> async_timeout.timeout(<span class="hljs-number">0.001</span>):<br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> session.get(<span class="hljs-string">&#x27;https://github.com&#x27;</span>) <span class="hljs-keyword">as</span> r:<br>        <span class="hljs-keyword">await</span> r.text()<br></code></pre></td></tr></table></figure>
<p>注意的是超时是累计时间，包括发送请求，重定向，响应解析，消费响应等所有操作。</p>
<h3 id="优雅的关闭-就是比较好的关闭协程？？？"><a href="#优雅的关闭-就是比较好的关闭协程？？？" class="headerlink" title="优雅的关闭(就是比较好的关闭协程？？？)"></a>优雅的关闭(就是比较好的关闭协程？？？)</h3><p>当ClientSession在块的末尾关闭（或通过直接调用）时，由于asyncio内部细节，基础连接保持打开状态在实践中，基础连接将在一段时间后关闭。但是，如果事件循环在底层连接关闭之前停止，则会发出警告（启用警告时）:</p>
<blockquote>
<p>async with.close()ResourceWarning: unclosed transport</p>
</blockquote>
<p>为了避免这种情况，必须在关闭事件循环之前添加一个小的延迟，以允许任何打开的底层连接关闭<br>对于ClientSession没有使用SSL：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">read_website</span>():</span><br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> aiohttp.ClientSession() <span class="hljs-keyword">as</span> session:<br>        <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> session.get(<span class="hljs-string">&#x27;http://example.org/&#x27;</span>) <span class="hljs-keyword">as</span> response:<br>            <span class="hljs-keyword">await</span> response.read()<br><br>loop = asyncio.get_event_loop()<br>loop.run_until_complete(read_website())<br><span class="hljs-comment"># Zero-sleep to allow underlying connections to close</span><br>loop.run_until_complete(asyncio.sleep(<span class="hljs-number">0</span>))<br>loop.close()<br></code></pre></td></tr></table></figure>
<p>对于ClientSession使用SSL，在结束之前必须等待很短的时间：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">read_website</span>():</span><br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> aiohttp.ClientSession() <span class="hljs-keyword">as</span> session:<br>        <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> session.get(<span class="hljs-string">&#x27;http://example.org/&#x27;</span>) <span class="hljs-keyword">as</span> response:<br>            <span class="hljs-keyword">await</span> response.read()<br><br>loop = asyncio.get_event_loop()<br>loop.run_until_complete(read_website())<br>loop.run_until_complete(asyncio.sleep(<span class="hljs-number">0.250</span>))<br>loop.close()<br></code></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>文档</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>aiohttp</tag>
      </tags>
  </entry>
  <entry>
    <title>设计RESTful(flask)</title>
    <url>/2017/12/26/25_how_to_design_RESTurl/</url>
    <content><![CDATA[<h2 id="前记"><a href="#前记" class="headerlink" title="前记"></a>前记</h2><p>当前很多WEB框架都有一些库来支持RESTful了，但是不了解的话还是会用得一头雾水。在找了一些资料后，找了RESTful设计的规范，并用falsk框架尝试写出RESTful 的api</p>
<span id="more"></span>

<h2 id="编写一个应用"><a href="#编写一个应用" class="headerlink" title="编写一个应用"></a>编写一个应用</h2><p>在未使用RESTful之前，简单的web应用可能是这样的(我全部都使用了get)<br>这个应用目前记录的书的isbn，书的名字，还有书的数据(以时间来记录)<br>忽略&lt;后的\</p>
<blockquote>
<p>url:/post/&lt;\int:isbn&gt;/&lt;\title&gt; 建立一本书的信息<br>url:/get/&lt;\int:isbn&gt;/ 获取一本书的信息<br>url:/put/&lt;\int:isbn&gt;/&lt;\data&gt; 更新书的日期<br>url:/delete/&lt;\int:isbn&gt; 删除书的信息</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Flask<br>app = Flask(__name__)<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Book</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        self.book_dict = &#123;&#125;<br><br><br>book = Book()<br><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/&#x27;</span></span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">Index</span>():</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Index Page&#x27;</span><br><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/get/&lt;int:isbn&gt;/&#x27;</span></span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get</span>(<span class="hljs-params">isbn</span>):</span><br>    get_book = book.book_dict[isbn] <br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;isbn:%d title:%s data:%s&quot;</span> %(isbn,get_book[<span class="hljs-string">&#x27;title&#x27;</span>],get_book[<span class="hljs-string">&#x27;data&#x27;</span>])<br><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/post/&lt;int:isbn&gt;/&lt;title&gt;&#x27;</span></span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">post</span>(<span class="hljs-params">isbn,title</span>):</span><br>    data = time.strftime(<span class="hljs-string">&#x27;%Y-%m-%d %H:%M&#x27;</span>,time.localtime(time.time()))<br>    book.book_dict[isbn] = <span class="hljs-built_in">dict</span>(title=title,data=data)<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;The new book title:%s,isbn:%d,data:%s&quot;</span> %(title,isbn,data)<br><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/put/&lt;int:isbn&gt;&#x27;</span></span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">put</span>(<span class="hljs-params">isbn</span>):</span><br>    put_book = book.book_dict[isbn]<br>    data_temp = put_book[<span class="hljs-string">&#x27;data&#x27;</span>]<br>    put_book[<span class="hljs-string">&#x27;data&#x27;</span>] = time.strftime(<span class="hljs-string">&#x27;%Y-%m-%d %H:%M&#x27;</span>,time.localtime(time.time()))<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Updata data: %s to %s&#x27;</span> % (data_temp,put_book[<span class="hljs-string">&#x27;data&#x27;</span>])<br><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/delete/&lt;int:isbn&gt;&#x27;</span></span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">delete</span>(<span class="hljs-params">isbn</span>):</span><br>    book.book_dict[isbn]=<span class="hljs-literal">None</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;isbn:%d delete!&#x27;</span> % isbn<br><br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    app.run(debug=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure>


<h2 id="url设计"><a href="#url设计" class="headerlink" title="url设计"></a>url设计</h2><h3 id="统一的url"><a href="#统一的url" class="headerlink" title="统一的url"></a>统一的url</h3><p>在RESTful设计中，统一接口，使用不同的http方法表达不同的行为：</p>
<ul>
<li>GET：从服务器获出资源（一项或多项）</li>
<li>POST：在服务器新建一个资源</li>
<li>PUT：在服务器更新资源（用户提供完整数据）</li>
<li>PATCH：在服务器更新资源（用户供需要修改的资源数据）</li>
<li>DELETE：从服务器删除资源</li>
</ul>
<h3 id="其他URL设计"><a href="#其他URL设计" class="headerlink" title="其他URL设计"></a>其他URL设计</h3><ul>
<li><p>版本<br>RESTful给出的方法是使用HTTPheader中的accept来传递版本信息，但也有一些是在url中添加版本信息，如：</p>
<blockquote>
<p>/api/v1/     #v1就是指版本1</p>
</blockquote>
</li>
<li><p>使用名词<br>设计url时，应使用名词而非动词</p>
</li>
<li><p>资源合集<br>获取资源合集时，有两种设计方法，一种是把要获取的资源当成一个子合集，另外一种是把需要的资源当成从总资源中过滤出来的。如书的例子，假设data有年，月，日三个值，我们要获取17年的十月的书时，url可以按照以下设计:</p>
<ul>
<li>子合集<blockquote>
<p>url: book/data/17/10</p>
</blockquote>
</li>
<li>过滤出来的资源<blockquote>
<p>url: book/data/?y=17&amp;m=10</p>
</blockquote>
</li>
</ul>
</li>
<li><p>url区分大小写</p>
</li>
<li><p>api/demo和api/demo/不一样<br>如果设计为：api/demo/时，用户输入api/demo会重定向到api/demo/。但是设计为api/demo时，用户输入api/demo/只能404 not found。</p>
</li>
<li><p>使用-而不使用_<br>由于网页的超链接会有下划线，所以_可能会让别人误会为空格</p>
</li>
</ul>
<h4 id="带有RESTful设计规范url的应用"><a href="#带有RESTful设计规范url的应用" class="headerlink" title="带有RESTful设计规范url的应用"></a>带有RESTful设计规范url的应用</h4><p>按照之前的应用，HTTP方法也只使用了’POST’, ‘GET’,’PUT’,’DELETE’。(PUT是模拟出用户提供了日期时间，实际代码中是自己获取了- -。)，可以把代码改为下面这样（其他URL设计中的资源合集并没有在这个例子体现出来）。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Flask, request<br>app = Flask(__name__)<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Book</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        self.book_dict = &#123;&#125;<br><br><br>book = Book()<br><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/api/v1/book/&lt;int:isbn&gt;/&#x27;</span>, methods=[<span class="hljs-string">&#x27;POST&#x27;</span>, <span class="hljs-string">&#x27;GET&#x27;</span>,<span class="hljs-string">&#x27;PUT&#x27;</span>,<span class="hljs-string">&#x27;DELETE&#x27;</span>]</span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">api</span>(<span class="hljs-params">isbn</span>):</span><br>    error = <span class="hljs-literal">None</span><br>    <span class="hljs-keyword">elif</span> request.method == <span class="hljs-string">&#x27;POST&#x27;</span>:<br>        title = request.args.get(<span class="hljs-string">&#x27;title&#x27;</span>)<br>        book.book_dict[isbn] = <span class="hljs-built_in">dict</span>(title=title,data=time.strftime(<span class="hljs-string">&#x27;%Y-%m-%d %H:%M&#x27;</span>,time.localtime(time.time())))<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;The new book title:%s,isbn:%d&quot;</span> %(title,isbn)<br>    <span class="hljs-keyword">elif</span> request.method == <span class="hljs-string">&#x27;GET&#x27;</span>:<br>        get_book = book.book_dict[isbn] <br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;isbn:%d title:%s data:%s&quot;</span> %(isbn,get_book[<span class="hljs-string">&#x27;title&#x27;</span>],get_book[<span class="hljs-string">&#x27;data&#x27;</span>])<br>    <span class="hljs-keyword">elif</span> request.method == <span class="hljs-string">&#x27;PUT&#x27;</span>:<br>        data = time.strftime(<span class="hljs-string">&#x27;%Y-%m-%d %H:%M&#x27;</span>,time.localtime(time.time()))<br>        put_book = book.book_dict[isbn]<br>        data_temp = put_book[<span class="hljs-string">&#x27;data&#x27;</span>]<br>        put_book[<span class="hljs-string">&#x27;data&#x27;</span>] = data<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Updata data: %s to %s&#x27;</span> % (data_temp,put_book[<span class="hljs-string">&#x27;data&#x27;</span>])<br>    <span class="hljs-keyword">elif</span> request.method == <span class="hljs-string">&#x27;DELETE&#x27;</span>:<br>        book.book_dict[isbn]=<span class="hljs-literal">None</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;isbn:%d delete!&#x27;</span> % isbn<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;methods not found&#x27;</span><br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    app.run(debug=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure>

<p>PS:测试RESTful如果也是CHROME浏览器的话可以使用postman REST client<br>输入以下url测试,并选择好对应的按钮，再点击send:</p>
<blockquote>
<p><a href="http://127.0.0.1:5000/api/v1/book/123/?title=abc">http://127.0.0.1:5000/api/v1/book/123/?title=abc</a>            POST<br><a href="http://127.0.0.1:5000/api/v1/book/123/">http://127.0.0.1:5000/api/v1/book/123/</a>                      GET<br><a href="http://127.0.0.1:5000/api/v1/book/123/">http://127.0.0.1:5000/api/v1/book/123/</a>                      PUT<br><a href="http://127.0.0.1:5000/api/v1/book/123/">http://127.0.0.1:5000/api/v1/book/123/</a>                      DELETE</p>
</blockquote>
<h2 id="后端返回的内容"><a href="#后端返回的内容" class="headerlink" title="后端返回的内容"></a>后端返回的内容</h2><h3 id="返回的数据类型"><a href="#返回的数据类型" class="headerlink" title="返回的数据类型"></a>返回的数据类型</h3><p>RESTful API规范统一的数据格式json或xml(一般都是json),如果API响应客户端请求后，<br>返回json，需要在header中添加Content-Type=application/json<br>返回xml，需要在header中添加Content-Type=application/atom+xml<br>在falsk中们可以使用json.jsonify返回json数据</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-comment">#导入</span><br><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> json<br><span class="hljs-comment">#使用</span><br><span class="hljs-keyword">return</span> json.jsonify<br></code></pre></td></tr></table></figure>

<h3 id="返回的状态码"><a href="#返回的状态码" class="headerlink" title="返回的状态码"></a>返回的状态码</h3><p>在客户端发送请求给服务器后，服务器也会返回信息给用户</p>
<ul>
<li>当GET, PUT和PATCH请求成功时，返回对应的数据，及状态码200</li>
<li>当POST创建数据成功时，返回创建的数据，及状态码201</li>
<li>当DELETE删除数据成功时，不返回数据，返回状态码204</li>
<li>当GET 不到数据时，返回状态码404</li>
<li>当验请求数据时发现错误，返回状态码 400</li>
<li>当API 请求需要用户认证时，如果request中的认证信息不正确，返回状态码 401</li>
<li>当API 请求需要验证用户权限时，如果当前用户无相应权限，返回状态码 403</li>
</ul>
<p>Flask的路由函数可以选择额外返回两个值，这两个值将被分别设为HTTP状态码和自定义的HTTP响应标头<br>也就是使用</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;abc&quot;</span> ,<span class="hljs-number">200</span> ,&#123;<span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;application/json&#x27;</span>&#125;<br></code></pre></td></tr></table></figure>
<p>就能返回文本，状态码，和http响应头，但是使用json.jsonify的话自带{‘Content-Type’: ‘application/json’}。</p>
<p>但如果要自己定义返回的错误信息的话，可以通过修改abort(状态码)和修饰器@app.errorhandler(状态码)来定义，不过比较繁琐,冗余比较多，可以自己定义一个类来自定义返回错误信息（<a href="https://www.jianshu.com/p/b569f6f7f181">原出处</a>）：<br>编写一个处理错误类</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomFlaskErr</span>(<span class="hljs-params">Exception</span>):</span><br><br>    <span class="hljs-comment"># 默认的返回码</span><br>    status_code = <span class="hljs-number">400</span><br><br>    <span class="hljs-comment"># 自己定义了一个 return_code，作为更细颗粒度的错误代码</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, return_code=<span class="hljs-literal">None</span>, status_code=<span class="hljs-literal">None</span>, payload=<span class="hljs-literal">None</span></span>):</span><br>        Exception.__init__(self)<br>        self.return_code = return_code<br>        <span class="hljs-keyword">if</span> status_code <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            self.status_code = status_code<br>        self.payload = payload<br><br>    <span class="hljs-comment"># 构造要返回的错误代码和错误信息的 dict</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">to_dict</span>(<span class="hljs-params">self</span>):</span><br>        rv = <span class="hljs-built_in">dict</span>(self.payload <span class="hljs-keyword">or</span> ())<br>        <br>        <span class="hljs-comment"># 增加 dict key: return code</span><br>        rv[<span class="hljs-string">&#x27;return_code&#x27;</span>] = self.return_code<br>        <br>        <span class="hljs-comment"># 增加 dict key: message, 具体内容由常量定义文件中通过 return_code 转化而来</span><br>        rv[<span class="hljs-string">&#x27;message&#x27;</span>] = J_MSG[self.return_code]<br>        <br>        <span class="hljs-comment"># 日志打印</span><br>        logger.warning(J_MSG[self.return_code])<br>        <br>        <span class="hljs-keyword">return</span> rv<br></code></pre></td></tr></table></figure>
<p>利用@app.errorhandler定义一个可以返回信息和状态码的函数，继承于我们编写的处理错误类</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-meta">@app.errorhandler(<span class="hljs-params">CustomFlaskErr</span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">handle_flask_error</span>(<span class="hljs-params">error</span>):</span><br><br>    <span class="hljs-comment"># response 的 json 内容为自定义错误代码和错误信息</span><br>    response = jsonify(error.to_dict())<br>    <br>    <span class="hljs-comment"># response 返回 error 发生时定义的标准错误代码</span><br>    response.status_code = error.status_code<br>    <br>    <span class="hljs-keyword">return</span> response<br></code></pre></td></tr></table></figure>
<p>调用示例:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">if</span> user_name <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>    <span class="hljs-keyword">raise</span> CustomFlaskErr(USER_NAME_ILLEGAL, status_code=<span class="hljs-number">400</span>)<br></code></pre></td></tr></table></figure>


<h3 id="提供分页url"><a href="#提供分页url" class="headerlink" title="提供分页url"></a>提供分页url</h3><p>由于使用RESTful后是无状态的，所以要提供类似与分页的url,如上一页和下一页</p>
<blockquote>
<p>如果服务器记录了应用的状态（stateful），那么你只要向服务询问『我要看下一页』，那么服务器自然就会返回第二页。类似的，如果你当前在第二页，想服务器请求『我要看下一页』，那就会得到第三页。但是REST的服务器恰恰是无状态的（stateless），服务器并没有保持你当前处于第几页，也就无法响应『下一页』这种具有状态性质的请求。因此客户端需要去维护当前应用的状态（application state），也就是『如何获取下一页资源』。当然，『下一页资源』的业务逻辑必然是由服务端来提供。服务器在文章列表的atom表征中加入一个URI超链接（hyper link），指向下一页文章列表对应的资源。客户端就可以使用统一接口（Uniform Interface）的方式，从这个URI中获取到他想要的下一页文章列表资源。上面的『能够进入下一页』就是应用的状态（State）。服务器把『能够进入下一页』这个状态以atom表征形式传输（Transfer）给客户端就是表征状态传输（REpresentational State Transfer）这个概念。<br>作者：季文昊<br>链接：<a href="https://www.zhihu.com/question/28557115/answer/48120528">https://www.zhihu.com/question/28557115/answer/48120528</a><br>来源：知乎</p>
</blockquote>
<p>假设应用里的书可以给别人查看一页一页的查看，那返回的数据需要这些(例如现在处于第二页):<br>xml返回的格式(忽略\link中的\):</p>
<blockquote>
<p>&lt;\link href=”http://***/book/page？pn=2” rel=”self” /&gt;<br>&lt;\link href=”http://***/book/page？pn=3” rel=”next” /&gt;<br>&lt;\link href=”http://***/book/page？pn=1” rel=”prev” /&gt;</p>
</blockquote>
<p>json返回的数据要包含:</p>
<blockquote>
<p>{“link”: {<br>  “rel”:   “http://<strong><em>/book/page？pn=2”,<br>  “next”:  “http://</em></strong>/book/page？pn=3”,<br>  “prev”： “http://***/book/page？pn=1”<br>  “title”: “book.title”,<br>  “type”:  “application/vnd.yourformat+json”<br>}}</p>
</blockquote>
<p>或者</p>
<blockquote>
<p>{<br>  “page”: 2,            # 当前是第几页<br>  “pages”: 3,           # 总共多少页<br>  “per_page”: 20,       # 每页多少数据<br>  “has_next”: true,     # 是否有下一页数据<br>  “has_prev”: true,    # 是否有前一页数据<br>  “total”: 59             # 总共多少数据<br>}</p>
</blockquote>
<p>按照以上规范进行修改，就可以得出一段代码不太好看的应用了- -(没有从数据库抽取数据，数据都是post生成的，很多判断都叠加在一起了)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Flask, request, json<br>app = Flask(__name__)<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Book</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        self.book_dict = &#123;&#125;<br><br><br>book = Book()<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">check</span>(<span class="hljs-params">isbn</span>):</span><br>    <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    第一个布尔量代表book_dict有没有资源，第二个代表isbn是否存在</span><br><span class="hljs-string">    &#x27;&#x27;&#x27;</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> book.book_dict:<br>        <span class="hljs-keyword">return</span> [<span class="hljs-literal">False</span>,<span class="hljs-literal">False</span>]<br><br>    <span class="hljs-keyword">for</span> k,v <span class="hljs-keyword">in</span> book.book_dict.items():<br>        <span class="hljs-keyword">if</span> isbn == k:<br>            <span class="hljs-keyword">return</span> [<span class="hljs-literal">True</span>,<span class="hljs-literal">True</span>,v]<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> [<span class="hljs-literal">True</span>,<span class="hljs-literal">False</span>,<span class="hljs-number">404</span>]<br><br><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/&#x27;</span></span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">Index</span>():</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Index Page&#x27;</span><br><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/api/v1/book/&lt;int:isbn&gt;/&#x27;</span>, methods=[<span class="hljs-string">&#x27;POST&#x27;</span>, <span class="hljs-string">&#x27;GET&#x27;</span>,<span class="hljs-string">&#x27;PUT&#x27;</span>,<span class="hljs-string">&#x27;DELETE&#x27;</span>]</span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">api</span>(<span class="hljs-params">isbn</span>):</span><br>    <span class="hljs-keyword">if</span> request.method == <span class="hljs-string">&#x27;POST&#x27;</span>:<br>        <span class="hljs-keyword">if</span> check(isbn)[<span class="hljs-number">0</span>]:<br>            message = <span class="hljs-built_in">dict</span>(message=<span class="hljs-string">&quot;isbn:%d Has been created&quot;</span> % isbn)<br>            <span class="hljs-keyword">return</span> json.jsonify(message), <span class="hljs-number">422</span><br>        title = request.args.get(<span class="hljs-string">&#x27;title&#x27;</span>)<br>        page_info = [<span class="hljs-string">&#x27;page1&#x27;</span>,<span class="hljs-string">&#x27;page2&#x27;</span>,<span class="hljs-string">&#x27;page3&#x27;</span>]       <span class="hljs-comment">#为书添加分页功能</span><br>        book.book_dict[isbn] = <span class="hljs-built_in">dict</span>(title=title,page=page_info,data=time.strftime(<span class="hljs-string">&#x27;%Y-%m-%d %H:%M&#x27;</span>,time.localtime(time.time())))<br>        data_json = <span class="hljs-built_in">dict</span>(isbn=isbn,data=book.book_dict[isbn])<br>        <span class="hljs-keyword">return</span> json.jsonify(data_json), <span class="hljs-number">201</span><br><br><br>    <span class="hljs-keyword">elif</span> request.method == <span class="hljs-string">&#x27;GET&#x27;</span>:<br>        page_data =<span class="hljs-literal">None</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> check(isbn)[<span class="hljs-number">1</span>]:<br>            message = <span class="hljs-built_in">dict</span>(message=<span class="hljs-string">&quot;isbn:%d not found!&quot;</span> % isbn)<br>            <span class="hljs-keyword">return</span> json.jsonify(message), check(isbn)[<span class="hljs-number">2</span>]<br>        <span class="hljs-keyword">elif</span> request.args.get(<span class="hljs-string">&#x27;page&#x27;</span>):<br>            page = <span class="hljs-built_in">int</span>(request.args.get(<span class="hljs-string">&#x27;page&#x27;</span>))<br>            page_info = book.book_dict[isbn][<span class="hljs-string">&#x27;page&#x27;</span>]<br>            <span class="hljs-keyword">if</span> page &gt; <span class="hljs-built_in">len</span>(page_info):<br>                message = <span class="hljs-built_in">dict</span>(message=<span class="hljs-string">&quot;isbn:%d,page%d not found!&quot;</span> % (isbn,page))<br>                <span class="hljs-keyword">return</span> json.jsonify(message), check(isbn)[<span class="hljs-number">2</span>]<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">if</span> page_info[page]:<br>                    has_next = <span class="hljs-literal">True</span><br>                <span class="hljs-keyword">else</span>:<br>                    has_next = <span class="hljs-literal">False</span><br>                <span class="hljs-keyword">if</span> page_info[page-<span class="hljs-number">2</span>]:<br>                    has_prev = <span class="hljs-literal">True</span><br>                <span class="hljs-keyword">else</span>:<br>                    has_prev = <span class="hljs-literal">False</span><br>                page_data = <span class="hljs-built_in">dict</span>(page=page,<br>                                 pages=<span class="hljs-built_in">len</span>(page_info),<br>                                 per_page=<span class="hljs-number">20</span>,<br>                                 has_next=has_next,<br>                                 has_prev=has_prev,<br>                                 total=<span class="hljs-built_in">len</span>(page_info)*<span class="hljs-number">20</span><br>                                 )<br>        <span class="hljs-keyword">else</span>:<br>            page_data = book.book_dict[isbn][<span class="hljs-string">&#x27;page&#x27;</span>]<br><br>        get_book = check(isbn)[<span class="hljs-number">2</span>]<br>        data_json = <span class="hljs-built_in">dict</span>(isbn=isbn,data=get_book,page_data=page_data)<br>        <span class="hljs-keyword">return</span> json.jsonify(data_json), <span class="hljs-number">200</span><br><br><br>    <span class="hljs-keyword">elif</span> request.method == <span class="hljs-string">&#x27;PUT&#x27;</span>:<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> check(isbn)[<span class="hljs-number">1</span>]:<br>            message = <span class="hljs-built_in">dict</span>(message=<span class="hljs-string">&quot;isbn:%d not found!&quot;</span> % isbn)<br>            <span class="hljs-keyword">return</span> json.jsonify(message), check(isbn)[<span class="hljs-number">2</span>]<br>        data = time.strftime(<span class="hljs-string">&#x27;%Y-%m-%d %H:%M&#x27;</span>,time.localtime(time.time()))<br>        put_book = book.book_dict[isbn]<br>        data_temp = put_book[<span class="hljs-string">&#x27;data&#x27;</span>]<br>        put_book[<span class="hljs-string">&#x27;data&#x27;</span>] = data<br>        data_json = <span class="hljs-built_in">dict</span>(data=book.book_dict[isbn],change_data=<span class="hljs-built_in">dict</span>(old_data=data_temp,new_data=data))<br>        <span class="hljs-keyword">return</span> json.jsonify(data_json), <span class="hljs-number">200</span><br><br><br>    <span class="hljs-keyword">elif</span> request.method == <span class="hljs-string">&#x27;DELETE&#x27;</span>:<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> check(isbn)[<span class="hljs-number">0</span>]:<br>            message = <span class="hljs-built_in">dict</span>(message=<span class="hljs-string">&quot;not isbn：%d&quot;</span> % isbn)<br>            <span class="hljs-keyword">return</span> json.jsonify(message), <span class="hljs-number">410</span><br><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> book.book_dict[isbn]:<br>            message = <span class="hljs-built_in">dict</span>(message=<span class="hljs-string">&quot;isbn:%d not found!&quot;</span> % isbn)<br>            <span class="hljs-keyword">return</span> json.jsonify(message), <span class="hljs-number">404</span><br><br>        book.book_dict[isbn]=<span class="hljs-literal">None</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-number">204</span><br><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;methods not found&#x27;</span><br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    app.run(debug=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure>
<p>如果返回的是要有url的话,如查看的是书的第二页，但书还有第三页，需要返回第三页的url，这个url可以使用url_for()来构造,在这个例子中的api是<br>api/v1/book/isbn/page<br>也就是调用api时能直接显示到书的对应页数的内容<br>用到的url_for()要引用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> url_for<br></code></pre></td></tr></table></figure>
<p>api_url调用的函数是这样</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/api/v1/book/&lt;int:isbn&gt;/&lt;int:id&gt;/&#x27;</span>, methods=[<span class="hljs-string">&#x27;POST&#x27;</span>, <span class="hljs-string">&#x27;GET&#x27;</span>,<span class="hljs-string">&#x27;PUT&#x27;</span>,<span class="hljs-string">&#x27;DELETE&#x27;</span>]</span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">new_api</span>(<span class="hljs-params">isbn</span>):</span><br></code></pre></td></tr></table></figure>
<p>构造URL的函数：<br>注意的是url_for中的’new_api’这样url_for()才知道要构建的是哪个URL</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">make_url</span>(<span class="hljs-params">page</span>):</span><br>    page = <span class="hljs-built_in">int</span>(page)<br>    page_info = book.book_dict[isbn][<span class="hljs-string">&#x27;page&#x27;</span>]<br>    <span class="hljs-keyword">if</span> page_info[page]:<br>        url_next = url_for(<span class="hljs-string">&#x27;new_api&#x27;</span>, page_info[page], _external=<span class="hljs-literal">True</span>)<br>    <span class="hljs-keyword">else</span>:<br>        url_next = <span class="hljs-literal">None</span><br>    <span class="hljs-keyword">if</span> page_info[page-<span class="hljs-number">2</span>]:<br>        url_prev = url_for(<span class="hljs-string">&#x27;new_api&#x27;</span>, page_info[page-<span class="hljs-number">2</span>], _external=<span class="hljs-literal">True</span>)<br>    <span class="hljs-keyword">else</span>:<br>        url_prev = <span class="hljs-literal">None</span><br>    page_data = <span class="hljs-built_in">dict</span>(page=page,<br>                     pages=<span class="hljs-built_in">len</span>(page_info),<br>                     per_page=<span class="hljs-number">20</span>,<br>                     has_next=url_next,<br>                     has_prev=url_prev,<br>                     total=<span class="hljs-built_in">len</span>(page_info)*<span class="hljs-number">20</span><br>                     )<br>    <span class="hljs-keyword">return</span> page_data<br></code></pre></td></tr></table></figure>
<p>当输入:api/v1/book/123/2/时，就会返回url</p>
<blockquote>
<p>api/v1/book/123/1/<br>api/v1/book/123/3/</p>
</blockquote>
<h2 id="验证与限制"><a href="#验证与限制" class="headerlink" title="验证与限制"></a>验证与限制</h2><h3 id="数据检验"><a href="#数据检验" class="headerlink" title="数据检验"></a>数据检验</h3><p>数据校验，有些是在前端进行校验，但是如果是给其他用户使用(如开发者API)时，数据校验需要放在后端进行，如果提交的字段不符合时，则需要返回对应的错误。虽然数据检验是RESTful设计中的一个可选项，但它对API的安全、服务器的开销和交互的友好性而言都具有重要意义。常见的数据类型校验如下：</p>
<ul>
<li>数据类型校验，如规定的字段类型是int或者str</li>
<li>数据格式校验，如字段需要满足相应的正则表达式</li>
<li>数据逻辑校验，如数据包含出生日期和年龄两个字段，如果这两个字段的数据不一致，则数据校验失败</li>
</ul>
<p>上面那段代码的check()函数就数据数据校验了</p>
<h3 id="速度限制"><a href="#速度限制" class="headerlink" title="速度限制"></a>速度限制</h3><p>为了避免请求泛滥，给API设置速度限制很重要。为此 RFC 6585 引入了HTTP状态码429（too many requests）。加入速度设置之后，应该提示用户，至于如何提示标准上没有说明，不过流行的方法是使用HTTP的返回头。<br>下面是几个必须的返回头（依照twitter的命名规则）：</p>
<p>X-Rate-Limit-Limit :当前时间段允许的并发请求数<br>X-Rate-Limit-Remaining:当前时间段保留的请求数。<br>X-Rate-Limit-Reset:当前时间段剩余秒数<br>为什么使用当前时间段剩余秒数而不是时间戳？</p>
<p>时间戳保存的信息很多，但是也包含了很多不必要的信息，用户只需要知道还剩几秒就可以再发请求了这样也避免了clock skew问题。</p>
<p>在flask中有个拓展提供了类似的功能<a href="https://github.com/alisaifee/flask-limiter">传送门</a></p>
<h3 id="用户认证与权限机制"><a href="#用户认证与权限机制" class="headerlink" title="用户认证与权限机制"></a>用户认证与权限机制</h3><p>一般都使用OAuth认证授权。Oauth认证会生成一个令牌，可以授权用户或者第三方系统在一定的时间内获取特定的资源。目前使用的几乎是Oauth 2.0。由于Oauth比较安全，现在Oauth已成为RESTful设计中最常用的认证机制。<br>关于使用RESTFUL认证，这里有篇文章写得不错——<a href="http://www.pythondoc.com/flask-restful/third.html">传送门</a></p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>到了这里，就已经能写出一个初步成形RESTful规范的后台应用了，为了更加深入RESTful和减少开发时间，可以使用一些RESTful库。</p>
<h3 id="python中web框架的RESTful库："><a href="#python中web框架的RESTful库：" class="headerlink" title="python中web框架的RESTful库："></a>python中web框架的RESTful库：</h3><ul>
<li>Django</li>
<li><a href="http://www.django-rest-framework.org/">django-rest-framework</a>：一个强大灵活的工具，用来构建 web API。</li>
<li><a href="http://tastypieapi.org/">django-tastypie</a>：为Django 应用开发API。</li>
<li><a href="https://github.com/5monkeys/django-formapi">django-formapi</a>：为 Django 的表单验证，创建 JSON APIs 。</li>
<li>Flask</li>
<li><a href="http://www.flaskapi.org/">flask-api</a>：为 flask 开发的，可浏览 Web APIs 。</li>
<li><a href="http://flask-restful.readthedocs.org/en/latest/">flask-restful</a>：为 flask 快速创建REST APIs 。</li>
<li><a href="https://flask-restless.readthedocs.org/en/latest/">flask-restless</a>：为 SQLAlchemy 定义的数据库模型创建 RESTful APIs 。</li>
<li><a href="https://github.com/marselester/flask-api-utils">flask-api-utils</a>：为 Flask 处理 API 表示和验证。</li>
<li><a href="https://github.com/nicolaiarocci/eve">eve</a>：REST API 框架，由 Flask, MongoDB 等驱动。</li>
<li>Pyramid</li>
<li><a href="https://cornice.readthedocs.org/en/latest/">cornice</a>：一个Pyramid 的 REST 框架 。</li>
<li>与框架无关的</li>
<li><a href="http://falconframework.org/">falcon</a>：一个用来建立云 API 和 web app 后端的高性能框架。</li>
<li><a href="https://github.com/jeffknupp/sandman">sandman</a>：为现存的数据库驱动系统自动创建 REST APIs 。</li>
<li><a href="http://restless.readthedocs.org/en/latest/">restless</a>：框架无关的 REST 框架 ，基于从 Tastypie 学到的知识。</li>
<li><a href="https://github.com/vertical-knowledge/ripozo">ripozo</a>：快速创建 REST/HATEOAS/Hypermedia APIs。</li>
</ul>
<h3 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h3><p>HTTP定义了很多有意义的状态码，你可以在你的API中使用。这些状态码可以帮助API消费者用来路由它们获取到的响应内容。整理了一个你肯定会用到的状态码列表：</p>
<p>200 OK - 对成功的GET、PUT、PATCH或DELETE操作进行响应。也可以被用在不创建新资源的POST操作上<br>201 Created - 对创建新资源的POST操作进行响应。应该带着指向新资源地址的Location header)<br>204 No Content - 对不会返回响应体的成功请求进行响应（比如DELETE请求）<br>304 Not Modified - HTTP缓存header生效的时候用<br>400 Bad Request - 请求异常，比如请求中的body无法解析<br>401 Unauthorized - 没有进行认证或者认证非法。当API通过浏览器访问的时候，可以用来弹出一个认证对话框<br>403 Forbidden - 当认证成功，但是认证过的用户没有访问资源的权限<br>404 Not Found - 当一个不存在的资源被请求<br>405 Method Not Allowed - 所请求的HTTP方法不允许当前认证用户访问<br>410 Gone - 表示当前请求的资源不再可用。当调用老版本API的时候很有用<br>415 Unsupported Media Type - 如果请求中的内容类型是错误的<br>422 Unprocessable Entity - 用来表示校验错误<br>429 Too Many Requests - 由于请求频次达到上限而被拒绝访问</p>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>RESTful</tag>
        <tag>flask</tag>
      </tags>
  </entry>
  <entry>
    <title>WEB</title>
    <url>/2017/12/13/20_web/</url>
    <content><![CDATA[<h2 id="前记"><a href="#前记" class="headerlink" title="前记"></a>前记</h2><p>【暂时废弃】<br>更新时间：2017-12-13 14:46:00</p>
<p>WEB有很多东西，有些框架/库的功能也是交叉着，所以有点混乱。今天闲的无聊，百度后觉得别人说的还是不明白，就把之前保存的文档全看了一遍。了解一下，应该有很多认知错误的，以后深入了解后再改正。<br>所以这里就是类似与 <a href="http://so1n.me/2017/10/19/15/#more">前端小功能收集</a>,<a href="http://so1n.me/2017/08/23/14-redis/">Redis命令</a>一样，内容简单，纯粹记录下我刚接触时的感想，顺便把以前的东西也写进来了。回头可以看一看，回顾下，还有就是以后找资料容易点。。。。。。</p>
<span id="more"></span>
<p>主要是在今天看了vue,Angular(js框架)，RESTful，tornado，wsgi文档后，才能把他们正式区分开的。<br>文字不好，使用度不频繁，所以写的不太好，以后更熟悉时再改，相比之前不知道为什么需要使用vue，也不知道服务器、容器和应用的关系好多了。。。。。。。</p>
<h2 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h2><p>之前我在找前端的资料时，就看到很多人在说前端更新很快，一不学习就要落后了，尤其是一个知乎的回复</p>
<blockquote>
<p>感谢前端，让我找回了大学学习的时光</p>
</blockquote>
<p><a href="https://www.awesomes.cn/">前端框架合集的网站</a></p>
<p>css框架：bootstrap,uikit(我喜欢这个)等<br>可以不用自己写css就可以做出一个美化的网站，之前第一次接触时，就觉得写个页面美化居然那么简单。。。</p>
<p>js框架：<a href="https://cn.vuejs.org/v2/guide/">vue.js</a>，<a href="https://doc.react-china.org/">React</a>，<a href="http://www.angularjs.net.cn/tutorial/">AngularJS</a>等<br>可以简化前端开发，提高生产力的东西，更让网页像个app一样，让后端只负责数据的传输、账户等校验和业务逻辑（要是之前看到就可以不用在模板上纠结那么久了，用vue代码几行就可以搞定[捂脸]）。<br>一开始以为就是个类似与jinja2的东西。，在看了同学发了个用前端实现路由（<a href="https://router.vuejs.org/zh-cn/">vue路由</a>）的朋友圈后，我就决定去看文档了(看的是vue)，发现真的是可以提高生产力，我这个js菜鸟可以边看文档边理解(AngularJS理解略难点？)，就可以写出很多之前觉得很难写出来的东西了(重点是，代码量也少）。也知道看我之前想实现的功能——spa，可以通过这些框架来实行。</p>
<p>模块化开发:目前没有用到，待补充</p>
<h2 id="中间"><a href="#中间" class="headerlink" title="中间"></a>中间</h2><p>那些tcp/ip协议啊,RFC(/d+)什么的虽然刚考完ccna还记得很清楚。。。但是感觉并不属于这个部分的</p>
<p><a href="http://www.ruanyifeng.com/blog/2014/05/restful_api.html">RESTful</a><br>RESTful,实际上只是一种设计风格，他是一种面向<em>资源</em>的设计<br>当前后端就只有服务器一个，前端的却后手机、平板、电脑等等，通过运用RESTful设计的url，可以让不同的前端一起使用共同的url，而且有充分利用了http的内容(一开始我都是post,get的,现在回头看觉得url设计的不是很好)</p>
<p>1.RESTful,有一个统一的url来调用资源<br>调用资源的方式通过http1.1协议的方法,分别以不同的方式操作资源</p>
<ul>
<li>get    ：从服务器取出资源</li>
<li>post   ：在服务器新建资源</li>
<li>put    ：在服务器更新资源（客户端提供完整资源数据）</li>
<li>patch  ：在服务器更新资源（客户端提供需要修改的资源数据）</li>
<li>delect ：在服务器删除资源</li>
</ul>
<p>2.RESTful要求无状态<br>即所有的资源，都可以通过URI定位，而且这个定位与其他资源无关，也不会因为其他资源的变化而改变。<br>无状态与有状态的区别（比如要从数据库拿到一个音乐资源）：</p>
<ul>
<li>无状态：该资源是无需付费的，访客访问时，也可以用资源推给用户</li>
<li>有状态：该资源是付费的，需要先登录，然后再判断这个用户是否有付费，有的时候才能把资源推给用户<br>可以看出，有状态通过url推送资源还需要进一步判断，而且上一步骤操作不成功时，后面的操作则无法进行，而无状态则不需要</li>
</ul>
<p>3.提供服务的服务器和使用服务的客户需要被隔离对待</p>
<p>4.服务器必须让客户知道请求是否可以被缓存</p>
<p>5.使用超媒体<br>不知道怎么说，等我看完《REST in Practice》，逃。</p>
<p>附:</p>
<p>1.简单来说，RESTful就是:</p>
<blockquote>
<p>看Url就知道要什么<br>看http method就知道干什么<br>看http status  code就知道结果如何<br>by 知乎:徐磊</p>
</blockquote>
<p>2.RESTful库：</p>
<ul>
<li>Django</li>
<li><a href="http://www.django-rest-framework.org/">django-rest-framework</a>：一个强大灵活的工具，用来构建 web API。</li>
<li><a href="http://tastypieapi.org/">django-tastypie</a>：为Django 应用开发API。</li>
<li><a href="https://github.com/5monkeys/django-formapi">django-formapi</a>：为 Django 的表单验证，创建 JSON APIs 。</li>
<li>Flask</li>
<li><a href="http://www.flaskapi.org/">flask-api</a>：为 flask 开发的，可浏览 Web APIs 。</li>
<li><a href="http://flask-restful.readthedocs.org/en/latest/">flask-restful</a>：为 flask 快速创建REST APIs 。</li>
<li><a href="https://flask-restless.readthedocs.org/en/latest/">flask-restless</a>：为 SQLAlchemy 定义的数据库模型创建 RESTful APIs 。</li>
<li><a href="https://github.com/marselester/flask-api-utils">flask-api-utils</a>：为 Flask 处理 API 表示和验证。</li>
<li><a href="https://github.com/nicolaiarocci/eve">eve</a>：REST API 框架，由 Flask, MongoDB 等驱动。</li>
<li>Pyramid</li>
<li><a href="https://cornice.readthedocs.org/en/latest/">cornice</a>：一个Pyramid 的 REST 框架 。</li>
<li>与框架无关的</li>
<li><a href="http://falconframework.org/">falcon</a>：一个用来建立云 API 和 web app 后端的高性能框架。</li>
<li><a href="https://github.com/jeffknupp/sandman">sandman</a>：为现存的数据库驱动系统自动创建 REST APIs 。</li>
<li><a href="http://restless.readthedocs.org/en/latest/">restless</a>：框架无关的 REST 框架 ，基于从 Tastypie 学到的知识。</li>
<li><a href="https://github.com/vertical-knowledge/ripozo">ripozo</a>：快速创建 REST/HATEOAS/Hypermedia APIs。</li>
</ul>
<p>3.初识时，可能觉得RESTful跟自己生成的api很像，但是还是有<strong>区别</strong>的</p>
<p>举个具体API的例子：请求：<br>GET /posts HTTP/1.1<br>Accept: application/atom+xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml">响应：<br>HTTP/1.1 200 OK<br>Content-Type: application/atom+xml<br><br><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">feed</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.w3.org/2005/Atom&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Posts<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;http://example.org/posts&quot;</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;self&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;http://example.org/posts?pn=2&quot;</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;next&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>urn:uuid:60a76c80-d399-11d9-b91C-0003939e0af6<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">updated</span>&gt;</span>2003-12-13T18:30:02Z<span class="hljs-tag">&lt;/<span class="hljs-name">updated</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">entry</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Post XXX<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;http://example.org/post-xxx&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>urn:uuid:1225c695-cfb8-4ebb-aaaa-80da344efa6a<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">updated</span>&gt;</span>2003-12-13T18:30:02Z<span class="hljs-tag">&lt;/<span class="hljs-name">updated</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">content</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;xhtml&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.w3.org/1999/xhtml&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>This is the post content.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">content</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">entry</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">entry</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">entry</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">feed</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p>注意上面atom格式中的多个<link>元素，它们分别定义了当前状态下合法的状态转移。例如，这是一个指向自己的链接，其中rel属性指定了状态转移的关系为自身。<link href="http://example.org/posts" rel="self" /><br>这是下一页的链接，<link href="http://example.org/posts?pn=2" rel="next" /><br>如果当前不是第一页的话，就会有类似如下的链接来表示上一页，<link href="http://example.org/posts?pn=2" rel="prev" /><br>而这个是某一篇文章的链接，<link href="http://example.org/post-xxx" /><br>总结一下，就是：服务器生成包含状态转移的表征数据，用来响应客户端对于一个资源的请求；客户端借助这份表征数据，记录了当前的应用状态以及对应可转移状态的方式。当然，为了要实现这一系列的功能，一个不可或缺的东西就是超文本（hypertext）或者说超媒体类型（hypermedia type）。这绝对不是一个简简单单的媒体类型（例如，JSON属性列表）可以做到的。（参考：REST APIs must be hypertext-driven）因此，像下面这种API，1、获取文章</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><code class="hljs gradle">请求：<br>GET <span class="hljs-regexp">/blog/</span>post<span class="hljs-regexp">/&#123;postId&#125; HTTP/</span><span class="hljs-number">1.1</span><br><br>响应：<br>HTTP/<span class="hljs-number">1.1</span> <span class="hljs-number">200</span> OK<br>&#123;<br>    <span class="hljs-string">&quot;title&quot;</span>: <span class="hljs-string">&quot;foobar&quot;</span>,<br>    <span class="hljs-string">&quot;content&quot;</span>: <span class="hljs-string">&quot;foobar&quot;</span>,<br>    <span class="hljs-string">&quot;comments&quot;</span>: [<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;&quot;</span>]<br>&#125;<br><br><span class="hljs-number">2</span>、发布文章<br><br>请求：<br>POST <span class="hljs-regexp">/blog/</span>post HTTP/<span class="hljs-number">1.1</span><br>&#123;<br>    <span class="hljs-string">&quot;title&quot;</span>: <span class="hljs-string">&quot;foobar&quot;</span>,<br>    <span class="hljs-string">&quot;content&quot;</span>: <span class="hljs-string">&quot;foobar&quot;</span>,<br>    <span class="hljs-string">&quot;comments&quot;</span>: [<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;&quot;</span>]<br>&#125;<br><br>响应：<br>HTTP/<span class="hljs-number">1.1</span> <span class="hljs-number">201</span> CREATED<br></code></pre></td></tr></table></figure>
<p>绝对不是RESTful！绝对不是RESTful！绝对不是RESTful！</p>
<p>以上引用：<br>作者：季文昊<br>链接：<a href="https://www.zhihu.com/question/28557115/answer/48120528">https://www.zhihu.com/question/28557115/answer/48120528</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<h2 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h2><p>web上的server都叫web server，但是大家分工也有不同的，有服务器，容器，应用<br>服务器主要是处理请求，决定分发到那个应用(静态文件也在此处理)，容器则是负责初始化环境(设置环境变量，如异步通信，websocket也在此处)，应用则是提供应用功能。</p>
<p>服务器: Apache/Nginx<br>容器:tonardo/Twisted<br>应用：用web框架开发的应用，web框架有Django,flask,Bottle,pyramid,CherryPy等(框架链接见<a href="https://github.com/jobbole/awesome-python-cn">这里</a>的web框架部分)</p>
<p>上面是按照主要功能划分的，很多框架对于上面每个领域都有一些涉足，但擅长的不一样，像tonardo(因为我今天才刚刚看了这个的文档，Twisted还没看- -)<br>Tornado既是一个容器，也是应用。而它作为容器 采用的是asynchronous IO的网络模型，这是一种很高效的模型。在<a href="http://www.tornadoweb.cn/">文档</a>中，前半部分讲了tornado作为一个应用是如何使用的，后面，也是最主要的讲了如何运用tornado来实现他的异步和长轮询问以及使用WebSocket实现双工通信。</p>
<p>大多时候后端都是通过服务器+容器+应用,栗子：<br>nginx+tornado+django:<br>1.Nginx作为反代理，分发到后端的torndo服务器<br>2.Django作为framwork搭建到tornado服务器上，使用其admin功能<br>在这个栗子中<br>服务器关心的是 HTTP 协议层面的传输和访问控制，所以在 Nginx上可以看到代理、负载均衡等功能。客户端通过服务器访问服务器上存储的资源（HTML 文件、图片文件等等）。通过 CGI 技术，也可以将处理过的内容通过服务器分发，但是一个服务器始终只是把服务器上的文件如实的通过 HTTP 协议传输给客户端。而容器，则是一个应用执行的容器。保证应用能够在应用服务器上正常运行。，我们可以通过框架来开发应用，让应用运行在应用执行的容器。他们能一起使用则是靠wsgi协议(容器那里可以说属于wsgi层，也就是通过wsgi协议分别连接服务器和应用的)</p>
<p>还有另外一个栗子</p>
<blockquote>
<p>Apache/lighttpd: 相当于一个request proxy，根据配置，把不同的请求转发给不同的server处理，例如静态的文件请求自己处理，这个时候它就像一个web server，对于fastcgi/python这样的请求转发给flup这样的Server/Gateway进行处理 flup: 一个用python写的web server，也就是cgi中所谓的Server/Gateway，它负责接受apache/lighttpd转发的请求，并调用你写的程序 (application)，并将application处理的结果返回到apache/lighttpdfastcgi: apache/lighttpd的一个模块，虽然flup可以作为一个独立的web server使用，但是对于浏览器请求处理一般都交给 apache/lighttpd处理，然后由apache/lighttpd转发给flup处理，这样就需要一个东西来把apache/lighttpd跟flup联系起来，这个东西就是fastcgi，它通过环境变量以及socket将客户端请求的信息传送给flup并接收flup返回的结果web.py: 应该说有了上面的东西你就可以开始编写你的web程序了，但是问题是你就要自己处理浏览器的输入输出，还有cookie、session、模板等各种各样的问题了，web.py的作用就是帮你把这些工作都做好了，它就是所谓的web framework，另外一个出名的是django，不过感觉太复杂了，web.py差不多就够用了WSGI : 除了flup Server/Gateway外还有很多其他人的写的Server/Gateway, 这个时候就会出问题了，如果你在flup上写了一个程序，现在由于各种原因你要使用xdly了，这个时候你的程序也许就要做很多痛苦的修改才能使用 xdly server了，WSGI就是一个规范，他规范了flup这个服务应该怎么写，应该使用什么方式什么参数调用你写的程序(application)等，当然同时也规范你的程序应该怎么写了，这样的话，只要flup跟xdly都遵守WSGI的话，你的程序在两个上面都可以使用了，flup就是一个WSGI server</p>
</blockquote>
<h3 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h3><p><a href="https://www.zhihu.com/question/20215561/answer/40316953">WebSocket 是什么原理？为什么可以实现持久连接？ - Ovear的回答 - 知乎</a></p>
<h3 id="nginx"><a href="#nginx" class="headerlink" title="nginx"></a>nginx</h3><p>HTTP Server，充当着反向代理，有着均衡负荷，和分发静态文件等功能。<br>nginx的能力比Apache好，但目前我对nginx是使用只会简单的配置。<a href="http://www.nginx.cn/doc/">nginx文档</a></p>
<h3 id="WSGI-uWSGI-uwsgi"><a href="#WSGI-uWSGI-uwsgi" class="headerlink" title="WSGI\uWSGI\uwsgi"></a>WSGI\uWSGI\uwsgi</h3><ul>
<li><a href="https://www.zhihu.com/question/19998865/answer/74748765">WSGI</a>是一种通信协议。</li>
<li>uwsgi是一种线路协议而不是通信协议，在此常用于在uWSGI服务器与其他网络服务器的数据通信。</li>
<li>而uWSGI是实现了uwsgi和WSGI两种协议的Web服务器。</li>
</ul>
<p>可以说WSGI是一种编程接口，而uwsgi是一种传输协议，而uWSGI是一个服务器(但是主要是链接nginx与框架的中间层(wsgi))。<br>相关文档:<a href="http://blog.csdn.net/midion9/article/details/51354774">1</a>,<a href="http://blog.csdn.net/sraing/article/details/8455242">2</a></p>
]]></content>
      <categories>
        <category>WEB</category>
      </categories>
      <tags>
        <tag>WEB</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql笔记(-第五章)</title>
    <url>/2017/12/13/24_high%20_performance_mySQL_3rd_notes/</url>
    <content><![CDATA[<h2 id="前记"><a href="#前记" class="headerlink" title="前记"></a>前记</h2><p>之前对数据库的使用都是写入，取出。最近想弄个数据库却涉及到太多东西去百度也百度不到自己想要的，然后在别人推荐下就看了《高性能Mysql》（第三版的书出版时5.6还没出来），所以这个文章是《高性能Mysql》读书笔记。由于太多了，所以我看多少就记多少。。。</p>
<span id="more"></span>
<h2 id="伪前记-mysql的命令"><a href="#伪前记-mysql的命令" class="headerlink" title="伪前记(mysql的命令)"></a>伪前记(mysql的命令)</h2><p><em>看书前温习了下命令，就顺便记下来了</em></p>
<h3 id="mysql术语"><a href="#mysql术语" class="headerlink" title="mysql术语"></a>mysql术语</h3><ul>
<li>关系型数据库<ul>
<li>能够实现一种具有表、列与索引的数据库。</li>
<li>保证不同表的行之间的引用完整性。</li>
<li>能自动更新索引。</li>
<li>能解释 SQL 查询，组合多张表的信息。</li>
</ul>
</li>
<li>数据库（Database）：数据库是带有相关数据的表的集合。</li>
<li>表（Table）：表是带有数据的矩阵。数据库中的表就像一种简单的电子表格。</li>
<li>列（Column）：每一列（数据元素）都包含着同种类型的数据，比如邮编。</li>
<li>行（Row）：行（又被称为元组、项或记录）是一组相关数据，比如有关订阅量的数据。</li>
<li>冗余（Redundancy）：存储两次数据，以便使系统更快速。</li>
<li>主键（Primary Key）：主键是唯一的。同一张表中不允许出现同样两个键值。一个键值只对应着一行。</li>
<li>外键（Foreign Key）：用于连接两张表。</li>
<li>复合键（Compound Key）：复合键（又称组合键）是一种由多列组成的键，因为一列并不足以确定唯一性。</li>
<li>索引（Index）：它在数据库中的作用就像书后的索引一样。</li>
<li>引用完整性（Referential Integrity）：用来确保外键一直指向已存在的一行。<h3 id="创建命令"><a href="#创建命令" class="headerlink" title="创建命令"></a>创建命令</h3>创建test数据库<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> DATABASE employee;<br></code></pre></td></tr></table></figure>
链接employee数据库<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">use employee;<br></code></pre></td></tr></table></figure>
创建表<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> 表的名字<br>(<br>列名a 数据类型(数据长度),<br>列名b 数据类型(数据长度)，<br>列名c 数据类型(数据长度)<br>);<br><br>#示例<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> employee (id <span class="hljs-type">int</span>(<span class="hljs-number">10</span>),name <span class="hljs-type">char</span>(<span class="hljs-number">20</span>),phone <span class="hljs-type">int</span>(<span class="hljs-number">12</span>));<br></code></pre></td></tr></table></figure>
向表插入数据<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> 表的名字(列名a,列名b,列名c) <span class="hljs-keyword">VALUES</span>(值<span class="hljs-number">1</span>,值<span class="hljs-number">2</span>,值<span class="hljs-number">3</span>);<br>#示例<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> employee(id,name,phone) <span class="hljs-keyword">VALUES</span>(<span class="hljs-number">01</span>,<span class="hljs-string">&#x27;Tom&#x27;</span>,<span class="hljs-number">110110110</span>);<br><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> employee <span class="hljs-keyword">VALUES</span>(<span class="hljs-number">02</span>,<span class="hljs-string">&#x27;Jack&#x27;</span>,<span class="hljs-number">119119119</span>);<br><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> employee(id,name) <span class="hljs-keyword">VALUES</span>(<span class="hljs-number">03</span>,<span class="hljs-string">&#x27;Rose&#x27;</span>);<br></code></pre></td></tr></table></figure>
<h3 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h3></li>
</ul>
<table>
<thead>
<tr>
<th>约束类型</th>
<th>主键</th>
<th>默认值</th>
<th>唯一</th>
<th>外键</th>
<th>非空</th>
</tr>
</thead>
<tbody><tr>
<td>关键字</td>
<td>PRIMARY KEY</td>
<td>DEFAULT</td>
<td>UNIQUE</td>
<td>FOREIGN KEY</td>
<td>NOT NULL</td>
</tr>
</tbody></table>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> department<br>(<br>  dpt_name   <span class="hljs-type">CHAR</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,              <span class="hljs-operator">/</span><span class="hljs-operator">/</span>非空约束<br>  people_num <span class="hljs-type">INT</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;10&#x27;</span>,           <span class="hljs-operator">/</span><span class="hljs-operator">/</span>默认值约束<br>  <span class="hljs-keyword">CONSTRAINT</span> dpt_pk <span class="hljs-keyword">PRIMARY</span> <span class="hljs-keyword">KEY</span> (dpt_name)   <span class="hljs-operator">/</span><span class="hljs-operator">/</span>主键约束<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span><span class="hljs-keyword">CONSTRAINT</span> 可自定义主键名 dpt_pk <span class="hljs-operator">=</span><span class="hljs-operator">=</span> dpt_name 均作为该表主键<br>);<br><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> employee<br>(<br>  id      <span class="hljs-type">INT</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">PRIMARY</span> <span class="hljs-keyword">KEY</span>,                     <span class="hljs-operator">/</span><span class="hljs-operator">/</span>主键约束 id 作为该表主键<br>  name    <span class="hljs-type">CHAR</span>(<span class="hljs-number">20</span>), <br>  age     <span class="hljs-type">INT</span>(<span class="hljs-number">10</span>),<br>  salary  <span class="hljs-type">INT</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,                        <span class="hljs-operator">/</span><span class="hljs-operator">/</span>非空约束<br>  phone   <span class="hljs-type">INT</span>(<span class="hljs-number">12</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,                        <span class="hljs-operator">/</span><span class="hljs-operator">/</span>非空约束<br>  in_dpt  <span class="hljs-type">CHAR</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,                      <span class="hljs-operator">/</span><span class="hljs-operator">/</span>非空约束<br>  <span class="hljs-keyword">UNIQUE</span>  (phone),                                <span class="hljs-operator">/</span><span class="hljs-operator">/</span>唯一值约束,phone值在该表中唯一<br>  <span class="hljs-keyword">CONSTRAINT</span> emp_fk <span class="hljs-keyword">FOREIGN</span> <span class="hljs-keyword">KEY</span> (in_dpt) <span class="hljs-keyword">REFERENCES</span> department(dpt_name)<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>外键约束 in_dpt，并自定义外键名 emp_fk 参考department表 dpt_name 列 <br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>使用<span class="hljs-keyword">INSERT</span>语句时，该表in_dpt列值必须在department表dpt_name中存在<br>);<br> <br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> project<br>(<br>  proj_num   <span class="hljs-type">INT</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  proj_name  <span class="hljs-type">CHAR</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  start_date <span class="hljs-type">DATE</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  end_date   <span class="hljs-type">DATE</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;2015-04-01&#x27;</span>, <span class="hljs-operator">/</span><span class="hljs-operator">/</span>默认约束<br>  of_dpt     <span class="hljs-type">CHAR</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">REFERENCES</span> department(dpt_name), <span class="hljs-operator">/</span><span class="hljs-operator">/</span>外键约束<br>  <span class="hljs-keyword">CONSTRAINT</span> proj_pk <span class="hljs-keyword">PRIMARY</span> <span class="hljs-keyword">KEY</span> (proj_num,proj_name)<br>   <span class="hljs-operator">/</span><span class="hljs-operator">/</span>复合主键约束(proj_num,proj_name)，并自定义主键名proj_pk<br> );<br></code></pre></td></tr></table></figure>
<h3 id="查询命令"><a href="#查询命令" class="headerlink" title="查询命令"></a>查询命令</h3><p>基本SELECT：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> 要查询的列名 <span class="hljs-keyword">FROM</span> 表名字 <span class="hljs-keyword">WHERE</span> 限制条件;<br></code></pre></td></tr></table></figure>
<p>数字符号条件限定，如(其中数字符号可以有:数学符号 (=,&lt;,&gt;,&gt;=,&lt;=)</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> name,age <span class="hljs-keyword">FROM</span> employee <span class="hljs-keyword">WHERE</span> age<span class="hljs-operator">&gt;</span><span class="hljs-number">25</span>;<br></code></pre></td></tr></table></figure>
<p>非数字条件限定</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">#小于<span class="hljs-number">25</span>或大于<span class="hljs-number">30</span><br><span class="hljs-keyword">SELECT</span> name,age <span class="hljs-keyword">FROM</span> employee <span class="hljs-keyword">WHERE</span> age<span class="hljs-operator">&lt;</span><span class="hljs-number">25</span> <span class="hljs-keyword">OR</span> age<span class="hljs-operator">&gt;</span><span class="hljs-number">30</span>;<br>#大于<span class="hljs-number">25</span>且小于<span class="hljs-number">30</span><br><span class="hljs-keyword">SELECT</span> name,age <span class="hljs-keyword">FROM</span> employee <span class="hljs-keyword">WHERE</span> age<span class="hljs-operator">&gt;</span><span class="hljs-number">25</span> <span class="hljs-keyword">AND</span> age<span class="hljs-operator">&lt;</span><span class="hljs-number">30</span>;<br>#该列数据的所有dpt3和dpt4<br><span class="hljs-keyword">SELECT</span> name,age,phone,in_dpt <span class="hljs-keyword">FROM</span> employee <span class="hljs-keyword">WHERE</span> in_dpt <span class="hljs-keyword">IN</span> (<span class="hljs-string">&#x27;dpt3&#x27;</span>,<span class="hljs-string">&#x27;dpt4&#x27;</span>);<br>#该列数据的除了dpt1和dpt3<br><span class="hljs-keyword">SELECT</span> name,age,phone,in_dpt <span class="hljs-keyword">FROM</span> employee <span class="hljs-keyword">WHERE</span> in_dpt <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">IN</span> (<span class="hljs-string">&#x27;dpt1&#x27;</span>,<span class="hljs-string">&#x27;dpt3&#x27;</span>);<br>#适配类似的数据_代表一个未知符，如果是两个就两个_<br><span class="hljs-keyword">SELECT</span> name,age,phone <span class="hljs-keyword">FROM</span> employee <span class="hljs-keyword">WHERE</span> phone <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;1101__&#x27;</span>;<br>#适配类似的数据<span class="hljs-operator">%</span>代表不定个未知符<br><span class="hljs-keyword">SELECT</span> name,age,phone <span class="hljs-keyword">FROM</span> employee <span class="hljs-keyword">WHERE</span> name <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;J%&#x27;</span>;<br></code></pre></td></tr></table></figure>
<p>对结果排序</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> name,age,salary,phone <span class="hljs-keyword">FROM</span> employee <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> salary <span class="hljs-keyword">ASC</span><span class="hljs-operator">/</span><span class="hljs-keyword">DESC</span>;<br>#其中<span class="hljs-keyword">ASC</span>为升序，<span class="hljs-keyword">DESC</span>为将序<br></code></pre></td></tr></table></figure>
<p>内置函数和计算</p>
<table>
<thead>
<tr>
<th>函数名</th>
<th>COUNT</th>
<th>SUM</th>
<th>AVG</th>
<th>MAX</th>
<th>MIN</th>
</tr>
</thead>
<tbody><tr>
<td>作用</td>
<td>计数</td>
<td>求和</td>
<td>求平均值</td>
<td>求最大</td>
<td></td>
</tr>
</tbody></table>
<blockquote>
<p>其中 COUNT 函数可用于任何数据类型(因为它只是计数)，而 SUM 、AVG 函数都只能对数字类数据类型做计算，MAX 和 MIN 可用于数值、字符串或是日期时间数据类型。</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">MAX</span>(salary) <span class="hljs-keyword">AS</span> max_salary,<span class="hljs-built_in">MIN</span>(salary) <span class="hljs-keyword">FROM</span> employee;<br>#从employee取出最大和最小值，<span class="hljs-keyword">AS</span>是把最大值呈现在列名max_salary中(可以说<span class="hljs-keyword">AS</span>是改了列名)<br></code></pre></td></tr></table></figure>
<p>关联表查询<br>显示of_dpt和count_project，而of_dpt存放在project的关联表employee里面</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> of_dpt,<span class="hljs-built_in">COUNT</span>(proj_name) <span class="hljs-keyword">AS</span> count_project <span class="hljs-keyword">FROM</span> project<br><span class="hljs-keyword">WHERE</span> of_dpt <span class="hljs-keyword">IN</span><br>(<span class="hljs-keyword">SELECT</span> in_dpt <span class="hljs-keyword">FROM</span> employee <span class="hljs-keyword">WHERE</span> name<span class="hljs-operator">=</span><span class="hljs-string">&#x27;Tom&#x27;</span>);<br></code></pre></td></tr></table></figure>
<p>连接查询<br>各员工所在部门的人数，其中员工的 id 和 name 来自 employee 表，people_num 来自 department 表</p>
<figure class="highlight n1ql"><table><tr><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> id,name,people_num<br><span class="hljs-keyword">FROM</span> employee,department<br><span class="hljs-keyword">WHERE</span> employee.in_dpt = department.dpt_name<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> id;<br></code></pre></td></tr></table></figure>
<p>也可以写为</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> id,name,people_num<br><span class="hljs-keyword">FROM</span> employee <span class="hljs-keyword">JOIN</span> department<br><span class="hljs-keyword">ON</span> employee.in_dpt <span class="hljs-operator">=</span> department.dpt_name<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> id;<br></code></pre></td></tr></table></figure>
<h3 id="修改和删除"><a href="#修改和删除" class="headerlink" title="修改和删除"></a>修改和删除</h3><p>删除</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> DATABASE test_01; #库<br><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> test_01;  #表<br></code></pre></td></tr></table></figure>
<p>修改</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">#重命名表名字<br>RENAME <span class="hljs-keyword">TABLE</span> 原名 <span class="hljs-keyword">TO</span> 新名字;<br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 原名 RENAME 新名;<br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 原名 RENAME <span class="hljs-keyword">TO</span> 新名;<br>#增加一列<br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 表名字 <span class="hljs-keyword">ADD</span> <span class="hljs-keyword">COLUMN</span> 列名字 数据类型 约束;<br>或： <span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 表名字 <span class="hljs-keyword">ADD</span> 列名字 数据类型 约束;<br>#增加的列在指定位置后面<br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> employee <span class="hljs-keyword">ADD</span> test <span class="hljs-type">INT</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">11</span> AFTER test;<br>#增加的列在第一个位置<br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> employee <span class="hljs-keyword">ADD</span> test <span class="hljs-type">INT</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">11</span> <span class="hljs-keyword">FIRST</span>;<br>#删除列<br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 表名字 <span class="hljs-keyword">DROP</span> <span class="hljs-keyword">COLUMN</span> 列名字;<br>或： <span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 表名字 <span class="hljs-keyword">DROP</span> 列名字;<br>#重改列<br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 表名字 CHANGE 原列名 新列名 数据类型 约束;<br>#更新列的值<br><span class="hljs-keyword">UPDATE</span> 表名字 <span class="hljs-keyword">SET</span> 列<span class="hljs-number">1</span><span class="hljs-operator">=</span>值<span class="hljs-number">1</span>,列<span class="hljs-number">2</span><span class="hljs-operator">=</span>值<span class="hljs-number">2</span> <span class="hljs-keyword">WHERE</span> 条件;<br>#删除<br><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> 表名字 <span class="hljs-keyword">WHERE</span> 条件;<br></code></pre></td></tr></table></figure>

<h2 id="12月21日更"><a href="#12月21日更" class="headerlink" title="12月21日更"></a>12月21日更</h2><h2 id="MySQL架构与基础"><a href="#MySQL架构与基础" class="headerlink" title="MySQL架构与基础"></a>MySQL架构与基础</h2><h3 id="MySQL架构"><a href="#MySQL架构" class="headerlink" title="MySQL架构"></a>MySQL架构</h3><p><img    class="lazyload" data-original="https://github.com/so1n/so1n_blog_photo/blob/master/blog_photo/MySQL%E6%9E%B6%E6%9E%84.png?raw=true" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">MySQL架构</span><br>正方形内是MySQL的核心服务功能层，包括查询解析，分析，优化，缓存以及所有与的内置函数(日期，时间，数学和加密函数等)，所有跨存储功能都在这一层实现：存储过程，触发器，视图等。<br>存储引擎。负责MySQL中数据的存储和提取。每个存储引擎都有它的优势和劣势。服务器通过API与存储引擎进行通信。这些接口屏蔽了不同的存储引擎之间的差异，使得这些差异对上层的查询过程透明。存储引擎API包括几十个底层函数，用于执行诸如“开始一个事务，或者：“根据主键提取一行记录”等操作，但存储引擎不会取解析SQL（InnoDB除外，它会解析外键定义）。不同存储引擎之间也不会相互通信</p>
<h3 id="MySQL锁策略"><a href="#MySQL锁策略" class="headerlink" title="MySQL锁策略"></a>MySQL锁策略</h3><p>为了并发读取数据时造出数据损坏，数据库也加了锁。理想是锁定方式是，只对会修改的数据片进行精确的锁定，任何时候，在给定的资源上，锁定的数据了越小，则系统的并发程度越高。<br><strong>读锁</strong> 由于可以多个用户读取一个文件，所以读锁是共享的，相互不阻塞。多个客户在同一时刻可以同时读取一个资源，而互不干扰。</p>
<p><strong>写锁</strong> 写锁是排他的，只有一个用户能执行写入，并防止其他用户读取正在写入的同一资源</p>
<p><strong>表锁</strong> 表锁是MySQL中最基本的锁策略，并且是开销最小的策略。它会锁定整张表，也就是一个用户在对表进行写操作前，需要先获得写锁，这时会阻塞其他用户对该表的所有读写操作。只有没有写锁时，其他读取的用户才能获得读锁，读锁之间是不互相阻塞的。<br>之中，写锁比读锁有更高优先级，因此一个写锁请求可能会被插入到读锁队列的前面（写锁可以插入到队列中读锁前面，反之毒素哦哦则不能）<br>尽管存储引擎可以管理自己的锁，MySQL本身还是会使用各种有效的表锁来实现不用的目的。例如，服务器会为诸如ALTER TABLE之类的语句使用表锁，而忽略存储引擎的锁机制。</p>
<p><strong>行级锁</strong> 行级锁可以最大程度的支持并发处理（同时也带来最大的锁开销）。<br>行级锁只在存储引擎层实现。</p>
<h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>事务就是一组原子性的SQL查询（原子性:不可切分的最小单位）或者说一个独立的工作单元。如果数据库引擎能够成功的对数据库应用该组查询的全部语句，就执行该组查询，如果其中有任何一条语句因为崩溃或其他原因无法执行，那么所有语句都不会执行。</p>
<blockquote>
<p>栗子：<br>假设银行的数据库有两张表：支票表和储蓄表。现在要从用户jane的支票账户转移200美元到她的账户</p>
<ol>
<li>检查支票账户的余额高于200美元。</li>
<li>从支票账户余额中减去200美元</li>
<li>在存蓄账户余额中增加200美元<br>这三个操作必须打包在一个事务中，任何一个步骤失败，则必须回滚所有的步骤。</li>
</ol>
</blockquote>
<p>可以用START TRANSACTION语句开始一个事务，然后要么使用commit提交事务将修改的数据持久保留，要么使用ROLLBACK撤销所有的修改。事务的样本如下:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">START</span> TRANSACTION;<br><span class="hljs-keyword">SELECT</span> balance <span class="hljs-keyword">FROM</span> checking <span class="hljs-keyword">WHERE</span> customer_id <span class="hljs-operator">=</span> <span class="hljs-number">10233276</span>;<br><span class="hljs-keyword">UPDATE</span> checking <span class="hljs-keyword">SET</span> balance <span class="hljs-operator">=</span> balance <span class="hljs-operator">-</span> <span class="hljs-number">200.00</span> <span class="hljs-keyword">WHERE</span> customer_id <span class="hljs-operator">=</span> <span class="hljs-number">10233276</span>;<br><span class="hljs-keyword">UPDATE</span> savings <span class="hljs-keyword">SET</span> balance <span class="hljs-operator">=</span> balance <span class="hljs-operator">+</span> <span class="hljs-number">200.00</span> <span class="hljs-keyword">WHERE</span> customer_id <span class="hljs-operator">=</span> <span class="hljs-number">10233276</span>;<br><span class="hljs-keyword">COMMIT</span>；<br></code></pre></td></tr></table></figure>
<p>为了事务能完好的执行，事务拥有ACID特性，ACID表示原子性，一致性，隔离性，持久性。</p>
<ul>
<li>原子性：一个人事务必须被视为一个不可分割的最小工作单元，整个十五中的所有操作要么成功要么失败回滚，对于一个事务来说，不可能只执行其中一个操作</li>
<li>一致性：数据库总是从一个一致性的状态切换到另外一个一致性的状态。</li>
<li>隔离性：通常来说(有隔离等级)一个事务所做的修改在最终提交以前，对其他事务是不可见的</li>
<li>持久性：一旦事务提交，则其所做的修改就会永久保存到数据库中。此时即使系统崩溃，修改的数据也不会丢失。持久性是个有点模糊的概念，因为实际上持久性也分很多不同的级别。</li>
</ul>
<p>由于ACID特性也会增加系统开销，增加了安全性，需要数据库系统做更多的额外工作。所以要根据业务来选择是否使用带有事务处理的存储引擎，即使存储引擎不支持事务，也可以通过LOCK TABLES 语句为应用提供一定程度的保护。</p>
<p><strong>隔离级别</strong></p>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>脏读可能性</th>
<th>不可重复读可能性</th>
<th>幻读可能性</th>
<th>加锁读</th>
</tr>
</thead>
<tbody><tr>
<td>未提交读</td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
<td>no</td>
</tr>
<tr>
<td>提交读</td>
<td>no</td>
<td>yes</td>
<td>yes</td>
<td>no</td>
</tr>
<tr>
<td>可重复读</td>
<td>no</td>
<td>no</td>
<td>yes</td>
<td>no</td>
</tr>
<tr>
<td>可串行化</td>
<td>no</td>
<td>no</td>
<td>no</td>
<td>yes</td>
</tr>
</tbody></table>
<p>ps脏读:事务中的修改，即使没有提交，对其他事务也都是可以见的，事务可以读取未提交的数据。</p>
<h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>死锁是值两个或者多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环的现象。当多个事务视图以不同的顺序锁定资源时，就可能产生死锁。<br>栗子：<br>下面两个事务同时处理StockPrice表：<br>事务1</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">START</span> TRANSACTION；<br><span class="hljs-keyword">UPDATE</span> StockPrice <span class="hljs-keyword">SET</span> <span class="hljs-keyword">close</span> <span class="hljs-operator">=</span> <span class="hljs-number">45.50</span> <span class="hljs-keyword">WHERE</span> stock_id <span class="hljs-operator">=</span><span class="hljs-number">4</span> <span class="hljs-keyword">and</span> <span class="hljs-type">date</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;2002-05-01&#x27;</span><br><span class="hljs-keyword">UPDATE</span> StockPrice <span class="hljs-keyword">SET</span> <span class="hljs-keyword">close</span> <span class="hljs-operator">=</span> <span class="hljs-number">19.80</span> <span class="hljs-keyword">WHERE</span> stock_id <span class="hljs-operator">=</span><span class="hljs-number">3</span> <span class="hljs-keyword">and</span> <span class="hljs-type">date</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;2002-05-02&#x27;</span><br></code></pre></td></tr></table></figure>
<p>事务2</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">START</span> TRANSACTION；<br><span class="hljs-keyword">UPDATE</span> StockPrice <span class="hljs-keyword">SET</span> hight <span class="hljs-operator">=</span> <span class="hljs-number">20.12</span> <span class="hljs-keyword">WHERE</span> stock_id <span class="hljs-operator">=</span> <span class="hljs-number">3</span> <span class="hljs-keyword">and</span> <span class="hljs-type">date</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;2002-05-02&#x27;</span><br><span class="hljs-keyword">UPDATE</span> StockPrice <span class="hljs-keyword">SET</span> hight <span class="hljs-operator">=</span> <span class="hljs-number">47.20</span> <span class="hljs-keyword">WHERE</span> stock_id <span class="hljs-operator">=</span> <span class="hljs-number">4</span> <span class="hljs-keyword">and</span> <span class="hljs-type">date</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;2002-05-01&#x27;</span><br></code></pre></td></tr></table></figure>
<p>如果凑齐，两个事务都执行了第一条update语句，更新一行数据，同时也锁定了该行数据，接着每个事务都尝试取执行第二条update语句，却发现该行已被对方锁定，然后两个事务都等待对方释放锁，同时又持有对方需要的锁，则陷入死循环。除非有外部因素介入才能解除死锁。<br>为了防止死锁，数据库系统实现了各种死锁检测和死锁超时机制。越复杂的系统，越能检测死锁的循环依赖，并立即返回一个错误，保证不会出现由于死锁出现了非常慢的查询。<br>还有一种解决方式，就是查询时间达到锁等待超时的设定后放弃锁请求。<br>InnoDB目前处理死锁的方法是，将持有最少行级排他锁的事务进行回滚。<br>锁的行为和顺序是存储引起相关的。以同样的顺序执行语句，有些存储引擎会产生死锁，有些则不会。死锁产生有双重原因：有些是因为真正的数据冲突，这种情况通常很难避免，但有些则完全是由于存储引擎的实现方式导致的。死多发生后，只有部分或者完全回滚其中一个事务，才能打破死锁，对于事务性的系统，这是无法避免的。</p>
<h4 id="事务日志"><a href="#事务日志" class="headerlink" title="事务日志"></a>事务日志</h4><p>使用事务日志，存储引擎在修改表的数据时只需要修改其内存拷贝，再把该修改行为记录到持久在硬盘上的事务日志中，而不用每次都将修改的数据本身持久到磁盘。事务日志采用的是追加的方式，因此写日志的操作是磁盘上以小块区域内的顺序I/o需要在磁盘的多个地方移动磁头，所以采用事务日志的港式相对来说要快的多。事务日志持久以后，内存中被修改的数据在后台可以慢慢的刷回到磁盘。目前大所属存储引擎都是这样实现的，我们通常称为预写式日志，修改数据需要写两次磁盘。</p>
<h4 id="MYSQL中的事务"><a href="#MYSQL中的事务" class="headerlink" title="MYSQL中的事务"></a>MYSQL中的事务</h4><p>MySQL提供了两种事务型的引擎:INnoDB\NDB Cluster。</p>
<p>MySQL默认采用自动提交模式。也就是每个查询都被当做一个事务执行提交操作。可以通过设置变量来启用或禁用，1为启用，0为禁用。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SHOW</span> VARIABLES <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;AUTOCOMMIT&#x27;</span>； <br><span class="hljs-keyword">SET</span> AUTOCOMMIT <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure>
<p>修改autocommit对非事务性的表，比如myisam或者内存吧，不会有任何影响。另外还有一些命令，在执行之前会强制执行commit提交当前的活动事务，典型的例子，在数据定义语言中，如果是会导致大量数据改变的操作，比如ALTER TABLE,就是如此，另外还有LOCK TABLES等其他语句也会导致同样的结果。</p>
<h5 id="不要在事务中混合使用存储引擎"><a href="#不要在事务中混合使用存储引擎" class="headerlink" title="不要在事务中混合使用存储引擎"></a>不要在事务中混合使用存储引擎</h5><p>事务是由下层的存储引擎实现的。所以在同一个事务中，使用多种存储引擎是不可靠的。<br>如果在十五中混合使用了事务型和非事务型的表，在正常提交的情况下不会有什么问题。<br>但如果该事务需要回滚，非事务型的变更就无法撤销，这回导致数据库处于不一致的状态，这种情况很难修复，事务的最终结果将无法确定。所以，为每张表选择合适的存储引擎非常重要。</p>
<h3 id="多版本并发控制-MVCC"><a href="#多版本并发控制-MVCC" class="headerlink" title="多版本并发控制(MVCC)"></a>多版本并发控制(MVCC)</h3><p>基于提升并发性能的考虑，数据库一般都实现了多版本并发控制，可以认为MVCC是行级锁的一个变种，但是它在很多情况下避免了加锁操作，因此开销更低。不同的存储引擎的MVCC实现是不同的，典型的有乐观和悲观并发控制。<br>MVCCD实现是通过保存数据在某个时间点的快照来实现的。也就是说，不管需要执行多长时间，每个事务看到的数据都是已知的。根据书屋开始的时间不同，每个事务对同一张表，同一时刻看到的数据可能是不一样的(<em>以空间换取时间？？？</em>)</p>
<p>InnoDB的MVCC是通过每行记录后面保存两个隐藏的列来实现的，这两个列，一个保存了行的创建时间，一个保存行的过期时间或删除时间（这里应该说是系统版本号)。每开始一个新的事务，系统版本号会自动递增，事务开始时刻的系统版本号会作为事务的版本号，用来和查询到的每行记录的版本号进行比较</p>
<ul>
<li><p>SELECT<br>InnoDB会根据以下两个条件检查每行记录:</p>
<ul>
<li>InnoDB只查找版本早于当前事务版本的数据行，也就是，行的系统版本号小鱼或等于事务的系统版本号，这样可以确保事务读取的行，要么是在事务开始之前已经存在，要么是事务自身插入或者修改过的。</li>
<li>行的删除版本要么未定义，要么大于当前事务版本号。这可以确保事务读取到的行，在事务开始之前未被删除。<br>只有符合上述两个条件的记录，才能返回作为查询结果</li>
</ul>
</li>
<li><p>INSERT<br>InnoDB为新插入的每一行保存当前系统版本号作为行版本号</p>
</li>
<li><p>DELETE<br>InnoDB为删除的每一行保存当前系统版本号作为删除标识</p>
</li>
<li><p>UPDATE<br>InnoDB为插入每一行新记录，保存当前系统版本号作为行版本号，同时保存当前系统版本号到原来的行作为行删除标识。</p>
<p>保存这两个额外系统版本号，使大多数读操作都可以不用加锁，这样设计使得读数据操作很简单，性能很好，并且也能保证只会读取到符合标准的行。不足之处是每行记录都需要额外的存储空间，需要做更多的行检查工作，以及一些额外的维护工作。但是mvcc只能在‘未提交读’，‘提交读’两个隔离级别下工作。</p>
</li>
</ul>
<h2 id="MySQL基准测试"><a href="#MySQL基准测试" class="headerlink" title="MySQL基准测试"></a>MySQL基准测试</h2><h3 id="为什么需要基准测试"><a href="#为什么需要基准测试" class="headerlink" title="为什么需要基准测试"></a>为什么需要基准测试</h3><p>基准测试可以完成一下工作：</p>
<ul>
<li><p>验证基于系统的一些假设，确认这些假设是否符合实际情况。</p>
</li>
<li><p>重现系统中的某些异常行为，以解决这些异常。</p>
</li>
<li><p>测试系统当前的运行情况。如果不清楚系统当前的性能，就无法确认某些优化的效果如何。也可以利用历史的基准测试结果来分析诊断一些无法预测的问题。</p>
</li>
<li><p>模拟比当前系统更高的负载，以找出系统随着压力增加而可能遇到的扩展行瓶颈。</p>
</li>
<li><p>规划未来的业务增长。基准测试可以评估在项目未来的负载下，需要什么样的硬件，需要多大容量的网络，以及其他相关资源。这由于主降低系统升级和重大变更的风险。</p>
</li>
<li><p>测试应用适应可变环境的能力。</p>
</li>
<li><p>测试不同的硬件、软件和操作系统配置。看哪个更适合。</p>
</li>
<li><p>证明新采购的设备是否配置正确。</p>
<h3 id="基准测试的策略"><a href="#基准测试的策略" class="headerlink" title="基准测试的策略"></a>基准测试的策略</h3><p>基准测试有两种主要的策略:一是针对整个系统的整体测试，另外是单独测试MySQL。分别被称为集成式以及单组件式基准测试。针对整个系统做集成式测试，而不是单独测试MySQL的原因主要有以下几点:</p>
</li>
<li><p>测试整个应用系统，包括web服务器、应用代码、网络和数据库是非常有用的，因为用户关注的并不止是MySQL本身的性能，而是应用整体的性能。</p>
</li>
<li><p>MySQL并非总是应用的瓶颈，通过整体的测试可以揭示这一点。</p>
</li>
<li><p>只有对应用做整体测试，才能发现各部分之间的缓存带来的影响。</p>
</li>
<li><p>整体应用的集成式测试更能揭示应用的真实表现而单独组件的测试很难做到这一点。</p>
<p>有时候单独测试MySQL的原因：</p>
</li>
<li><p>需要比较不同的schema或查询的性能</p>
</li>
<li><p>针对应用中某个具体的问题的测试。</p>
</li>
<li><p>为了避免漫长的基准测试，可以通过一个短期的基准测试，做快速的”舟求循环“，来检测出某些调整的效果</p>
</li>
</ul>
<h3 id="测试的指标"><a href="#测试的指标" class="headerlink" title="测试的指标"></a>测试的指标</h3><ul>
<li>吞吐量<br>吞吐量指的是单位时间内的事务处理数。非常适用于多用户的交互式应用。常用的测试单位是每秒实物数(TPS),有些也采用每分钟事务数(TPM)</li>
<li>响应时间或者延迟<br>这个指标用于测试任务所需的整体时间。根据具体的应用，测试的时间单位可能是微妙，毫秒，秒，分钟。根据不同的时间单位可以计算出平均响应时间、最小响应时间、最大响应时间和所占百分比，最大响应时间通常意义不大，因为测试时间越长，最大响应时间也可能越大。而且其结果通常不可重复，每次是都可能得到不同的最大响应时间。因此进行多次测试，再取测试后的响应时间的聚集范围。<br>例如：如果95%的响应时间都是5毫秒，则表示任务在95%的时间段内都可以在5毫秒之内完成。</li>
<li>并发性<br>WEB服务器的并发性更准确的度量指标应该是在任意时间有多少同时发生的并发请求，但是web服务器的并发会导致数据库的高并发（需要用到数据库的话，且有很多个MySQL数据库服务器查询链接）。<br>换句话说，并发性基准测试需要关注的是正在工作中的并发操作，或者是同时工作中的线程数或者连接数。当并发性增加是，需要测量吞吐量是否下降，响应时间是否边长。<br>数据库的并发性测量，可以通过sysbench指定32、64或者128个线程测试，然后在测试期间记录MySQL数据库的threads_running状态值。</li>
<li>可拓展性<br>可扩展性指的是，给系统增加一倍的工作，在理想情况下就能获得两倍的结果(即吞吐量增加一倍)或者说给系统增加一倍的资源，就可以获得两倍的吞吐量（理想情况下）。</li>
</ul>
<h3 id="基准测试方法"><a href="#基准测试方法" class="headerlink" title="基准测试方法"></a>基准测试方法</h3><p>在测试时，避免以下错误来避免错误导致测试结果无用或者不精确：</p>
<ul>
<li>使用真实数据的子集而不是全集。</li>
<li>例如应用需要处理几百gb的数据，但测试只有1gb数据，或者只使用当前数据进行测试，却希望模拟未来业务大幅度增长后的情况。</li>
<li>使用错误的数据分布，例如使用均匀分布的数据测试，而系统的真实数据有很多热点区域(随机生产的测试数据通常无法模拟真实的数据分布)</li>
<li>使用不真实的分布参数，例如假定所有用户的个人信息都会被平均地读取</li>
<li>在多用户场景中，只做单用户的测试</li>
<li>在单服务器测试分布式应用</li>
<li>与真实用户行为不匹配。</li>
<li>例如真实用户在请求一个页面后会阅读一段时间，而不是不停顿地一个接一个点击相关链接</li>
<li>反复执行同一个查询，真实的查询是不尽相同的，这可能会导致缓存命中率降低，而反复执行同一个查询在某种程度上，会全部或者部分缓存结果。</li>
<li>没有检查错误。<br>果测试的结果无法得到合理的解释，比如一个本应该很慢的查询突然变快了，就应该检查是否有错误产生，否则可能只是测试了MySQL检测语法错误的产生。否则可能只是测试了MySQL检测语法错误的速度。所以基准测试完成后，一定要检查以下错误日志。</li>
<li>忽略了系统预热的过程<br>例如系统重启后马上测试，有时候需要了解系统重启后需要多长时间才能达到正常的性能容量，要特别留意预热的时长。反过来说，如果要想分析正常的性能，需要注意，若基准测试在重启以后马上启动，则缓存是冷的、还没有数据，这时即使测试的压力相同，得到的结果也和缓存已经装满数据时的不同的</li>
<li>使用默认的服务器配置</li>
<li>测试时间太短。基准测试需要持续一定的时间。</li>
</ul>
<h3 id="测试工具（待补充）"><a href="#测试工具（待补充）" class="headerlink" title="测试工具（待补充）"></a>测试工具（待补充）</h3><p>略</p>
<h2 id="服务器性能剖析"><a href="#服务器性能剖析" class="headerlink" title="服务器性能剖析"></a>服务器性能剖析</h2><h3 id="性能优化简介"><a href="#性能优化简介" class="headerlink" title="性能优化简介"></a>性能优化简介</h3><p><strong>性能</strong>的定义为完成某件任务所需的时间度量。<br>注:</p>
<ul>
<li>性能优化并不是指降低cpu利用率<br>虽然出bug会提高cpu利用率，但是同一时间内，能消耗更多的性能去加快查询速度，这是提升了性能。</li>
</ul>
<h3 id="通过性能剖析进行优化"><a href="#通过性能剖析进行优化" class="headerlink" title="通过性能剖析进行优化"></a>通过性能剖析进行优化</h3><p>步骤:测量任务所花费的时间，然后对结果进行统计和排序，将重要的任务排到前面<br>性能剖析有两种：</p>
<ul>
<li>基于执行时间的分析<br>研究的是什么任务的执行时间最长</li>
<li>基于等待的分析<br>判断任务在什么地方被阻塞的时间最长</li>
</ul>
<h3 id="理解性能剖析"><a href="#理解性能剖析" class="headerlink" title="理解性能剖析"></a>理解性能剖析</h3><p>MySQL的性能剖析将最重要的任务展示在前面，但有时候没显示出来的信息也很重要。但是还是有很多需要的信息是缺失的。</p>
<ul>
<li>不值得优化的查询<br>一些只占总响应时间比重很小的查询是不值得优化的。<br>如果优化的成本大于收益，就应停止优化</li>
<li>异常情况<br>有些任务即使没有出现在性能剖析输出的前面也需要优化。比如某些任务执行次数很少，但每次执行都非常慢，严重影响用户体验，因为其执行频率低，所以总的响应时间占比并不突出。</li>
<li>未知的未知<br>一款好的性能剖析工具会显示可能的”丢失的时间“。丢失的时间指的是任务的总时间和实际测量到的时间之间的差。例如，如果处理器的cpu时间是10秒，而剖析到的任务总时间是9.7秒，那么就有300好秒的丢失时间。这可能是有些任务没有测量到，也可能是由于测量的误差和精度问题的缘故</li>
<li>掩藏的细节<br>有些时候不能相信平均值，例如有两次查询响应的时间是1秒。另外的所有响应时间缺失几十微妙，这时候平均值是无法发现的，但是这两次响应值可能代表一些会发生的异常</li>
</ul>
<h3 id="剖析MySQL查询"><a href="#剖析MySQL查询" class="headerlink" title="剖析MySQL查询"></a>剖析MySQL查询</h3><h4 id="剖析服务器负载"><a href="#剖析服务器负载" class="headerlink" title="剖析服务器负载"></a>剖析服务器负载</h4><h5 id="捕获MySQL的查询到日志文件中"><a href="#捕获MySQL的查询到日志文件中" class="headerlink" title="捕获MySQL的查询到日志文件中"></a>捕获MySQL的查询到日志文件中</h5><p>MySQL的<strong>慢查询</strong>日志的功能（最初只是捕获比较”慢“的查询）。现在可以通过设置long_query_time为0来捕获所有的查询。<br>慢查询日志开销是最低的、精度最高的测量查询时间的工具（一般不会带来额外的i/o开销，cpu密集型场景i\o开销的影响会较大），但是慢查询可能消耗大量的磁盘空间<br>Percona Server的慢查询日志比官方的记录了更多细节且有价值的信息，如查询执行计划、锁、i/o活动等<br>有时因为权限不够的原因，无法在服务器上记录查询。可以使用两种替代的技术。</p>
<ul>
<li>通过– processlist选项不断查看SHOW FULL PROCESSLIST的输出，记录查询第一次出现的时间和消失的时间。但是一些执行较快的查询可能在两次执行的间隙就执行完成了，从而无法捕获到。</li>
<li>通过tcp网络包，根据MySQL的客户端/服务端通信协议进行解析。可以先通过tcpdump将网络包数据保存到磁盘，然后使用pt-query-digest的–type=tcpdump选项来解析并分析查询，此方法的精度比较高，并且可以捕获所有查询，还可以解析更高级的协议特性，如二进制协议。</li>
</ul>
<h5 id="分析查询日志"><a href="#分析查询日志" class="headerlink" title="分析查询日志"></a>分析查询日志</h5><p>虽然生成了日志，但是打开整个慢查询日志进行分析很浪费时间。所以:<br>首先应该生成一个剖析报告，如果需要，则可以查看日志中需要特别关注的部分。生产剖析<br>报告的工具——pt-query-digest，可以将查询报告保存到数据库中，以及追踪工作负载时间的变化。<br><strong>详细介绍在书和<a href="http://blog.csdn.net/seteor/article/details/24017913">链接</a></strong></p>
<h4 id="剖析单挑语句"><a href="#剖析单挑语句" class="headerlink" title="剖析单挑语句"></a>剖析单挑语句</h4><p>定位到需要优化的单条查询后，就可以针对这个查询捉取更多的信息，确认为什么会花那么多时间取执行，以及如何取优化。以下是如何方便的测量查询执行的各部分花费了多少时间</p>
<ul>
<li><p>使用SHOW PROFILE<br>该命令默认是禁用的（我现在用的时候好像默认启用- -？），但可以通过服务器变量在会话（连接）级别动态地修改</p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SET</span> profiling <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure>
<p>  然后在服务器执行语句时，该工具都会测量其耗费的时间和其他一些查询执行状态变更相关的数据显示如：997rows in set (0.17sec)<br>输入命令：</p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span><span class="hljs-keyword">SHOW</span> PROFILES;<br></code></pre></td></tr></table></figure>
<p>  会返回一张表，记录了时间和所输入的命令</p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SHOW</span> PROFILE <span class="hljs-keyword">FOR</span> QUERY <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure>
<p>  命令可以剖析报告给出了查询执行的每个步骤及其花费的时间，但是输出是按照执行顺序排序的，而不是按花费了多少时间….也不嫩用ORDER BY之类的命令重新排序。<br>也可以按如下查询<br><img    class="lazyload" data-original="https://github.com/so1n/so1n_blog_photo/blob/master/blog_photo/MySQL%E4%BC%98%E5%8C%96%E7%A4%BA%E4%BE%8B.png?raw=true" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">enter description here</span><br>这样就可以找到消耗时间的排行了，再去接着优化。</p>
</li>
<li><p>使用SHOW STATUS<br>该命令会返回一些计数器，既有服务器级别的全局计数器，也有基于某个链接的会话级别的计数器。<br>如果执行<strong>SHOW GLOBAL STATUS</strong>则可以查看服务器级别的从服务器启动时开始计算的查询次数统计。<br>由于返回的结果只是计数器，可以显示某些活动如读索引的频繁程度，无法给出消耗了多少时间。但可以根据计数器来猜测那些操作待机较高或者消耗时间较多</p>
</li>
<li><p>使用慢查询日志<br>查看慢查询日志是，其标题部分一般有如下输出:<br>Query 1: 0 QPS, 0x concurrency, ID oxEE758C5EoD7EADEE at byte 3214 ___<br>表明可以通过这里的字节偏移值(3214)直接跳转到日志的对应部分，如以下命令：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">tail <span class="hljs-operator">-</span>c <span class="hljs-operator">+</span><span class="hljs-number">3214</span> <span class="hljs-operator">/</span>path<span class="hljs-operator">/</span><span class="hljs-keyword">to</span><span class="hljs-operator">/</span>query.log <span class="hljs-operator">|</span> head <span class="hljs-operator">-</span>n100<br></code></pre></td></tr></table></figure></li>
<li><p>使用Performance Schema<br>待查找5.6有无新特性</p>
</li>
</ul>
<h3 id="诊断间歇性问题"><a href="#诊断间歇性问题" class="headerlink" title="诊断间歇性问题"></a>诊断间歇性问题</h3><p>列出的案例:</p>
<ul>
<li>应用通过curl从一个运行得很慢的外部服务来获取汇率报价的数据</li>
<li>memcached缓存中的一些重要条目过去，导致大量请求落到mysql以重新生产缓存条目。</li>
<li>DNS查询偶尔会有超时现象</li>
<li>可能是由于互斥锁争用，或者内部删除查询缓存的算法效率太低的缘故，MySQL的查询缓存有时候会导致服务有短暂的停顿。</li>
<li>当并发度超过某个阀值时，InnoDC的扩展性限制导致查询计划的优化需要很长的时间。</li>
</ul>
<h4 id="单条查询问题还是服务器问题"><a href="#单条查询问题还是服务器问题" class="headerlink" title="单条查询问题还是服务器问题"></a>单条查询问题还是服务器问题</h4><ul>
<li>使用SHOW GLOBAL STATUS<br>这个方法实际上就是以较高的频率如一秒一次执行命令捕获数据，问题出现时，通过计数器（如:Threads_running,Threads_connected,Questions和Queries）的”尖刺“或”凹陷“来发现。这方法简单且对服务器影响小。<br><img    class="lazyload" data-original="https://github.com/so1n/so1n_blog_photo/blob/master/blog_photo/MYSQL%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AF%8A%E6%96%AD.png?raw=true" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">enter description here</span><br>这个命令是每秒捕获一次SHOW GLOBAL STATUS的数据，且输出给awk计算并输出每秒的:Threads_running,Threads_connected,Questions和Queries这几个数据的趋势对于服务器级别偶尔停顿的敏感性高。</li>
<li>使用SHOW PROCESSLIST<br>这个方法通过不停的捕获show processlist的输出，观察是否有大量线程处于不正常的状态或者有其他不正常的特征。可以使用以下命令查询(sort,uniq,sort计算某个列值出现的次数):<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">mysql <span class="hljs-operator">-</span>e <span class="hljs-string">&#x27;SHOW PROCESSLIST\G&#x27;</span> <span class="hljs-operator">|</span>grep State: <span class="hljs-operator">|</span>sort <span class="hljs-operator">|</span>uniq <span class="hljs-operator">-</span>c <span class="hljs-operator">|</span>sort <span class="hljs-operator">-</span>rn<br></code></pre></td></tr></table></figure>
<h2 id="Schema与数据类型优化"><a href="#Schema与数据类型优化" class="headerlink" title="Schema与数据类型优化"></a>Schema与数据类型优化</h2><h3 id="选择优化的数据类型"><a href="#选择优化的数据类型" class="headerlink" title="选择优化的数据类型"></a>选择优化的数据类型</h3>存储类型的选择</li>
<li>更小的通常更好<br>一般情况下，应尽量吃用可以正确存储数据的最小数据类型。如果无法确定哪个数据类型是最好的，就选择认为不会超过方位的最小类型。</li>
<li>简单就好<br>可以使用int就别用float，且使用MySQL内建的类型来存储日期和时间。（存储ip地址用int）</li>
<li>尽量避免使用null<br>通常情况下，最好指定列为NOT NULL,除非真的需要存储Null值。不过在InnoDB时影响不大</li>
</ul>
<h4 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h4><p>如果存储整数，可以使用这几种整数类型:TINYINT,SMALLINT.MEDIUMINT,INT,BIGINT,分别使用8,16,24,32,64位存储空间。<br>整数类型有可选的的UNSIGNED属性，表示不允许负值。<br>在TINYINTZHONGZHONG，不使用UNSIGNED属性:存储范围-128<del>128<br>使用UNSIGNED属性:存储范围0</del>255<br>此外，MySQL可以为整数类型指定宽度，例如INT(11)，对大多数应用是没意义的:它不会限制值的合法范围，只是规定一些MySQL交互工具用来显示字符的个数。</p>
<h4 id="实数类型"><a href="#实数类型" class="headerlink" title="实数类型"></a>实数类型</h4><p>有浮点和DECIMAL，浮点有FLOAT和DOUBLE，其中FLOAT占用4个字节存储，DOUBLE占用8个字节且相比FLOAT有更大的范围和更高的精度。<br>因为需要额外的空间和计算开销，所以尽量只在对小数进行精确计算时才使用DECIMAL。例如存储财务数据。但在数据了比较大的时候，可以考虑使用BIGINT代替DECIMAL，将需要存储的货币单位根据小数的位数乘以响应的倍数即可。这样可以避免浮点存储计算不精确和DECIMAL精确计算代价高的问题</p>
<h4 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h4><ul>
<li><p>VARCHAR(InnoDB/MYISAM引擎下的说明)<br>存储可变长字符串，比CHAR节省空间，但是，如果MySQL表使用ROW_FORMAT=FIXED创建的话，每一行都会使用定长存储。<br>VARCHAR需要使用额外字节记录字符长度，如果列的最大长度小于或等于255，则使用1个字节，否则使用2个字节。<br>适用VARCHAR的情况：</p>
<ul>
<li>字符串列的最大长度比平均长度大很多</li>
<li>列的更新很少</li>
<li>使用了像UTF-8这样复杂的字符串（每个字符串都使用不同的字节数进行存储）<br>在存储IP地址时，不应该使用VARCHAR(15)来存储，因为它本身是32位的二进制。MySQL提供了INET_ATON()和INET_NTOA()在这两种表示方法之间转换</li>
</ul>
</li>
<li><p>CHAR(InnoDB/MYISAM引擎下的说明)<br>CHAR类型是定长的，MySQL总是根据定义的字符串长度分配足够的空间，当存储CHAR值是，MySQL会删除所有的末尾空格。<br>使用CHAR的情况</p>
<ul>
<li>适合存储所有制都接近同一个长度（如MD5）</li>
<li>经常变更的数据（定长的CHAR不容易产生碎片）</li>
<li>非常短的列如(Y/N)</li>
</ul>
</li>
<li><p>BLOB和TEXT类型<br>BLOB和TEXT都是为了很大的数据而设计的字符串数据类型，分别采用存储二进制和字符串方式存储</p>
</li>
<li><p>使用枚举代替字符串类型</p>
</li>
<li><p>枚举列可以把一些不重复的字符串存储成一个预定义的集合。MySQL在存储枚举时非常紧凑，会根据列表值的数量压缩到一个或两个字节中。在内部会将每个值在列表中的未知保存为整数，并且在表的.frm文件中保存“数字-字符串”映射关系的”查找表”。<br>栗子：</p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> enum_test(<br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span>    e ENUM(<span class="hljs-string">&#x27;fish&#x27;</span>,<span class="hljs-string">&#x27;apple&#x27;</span>,<span class="hljs-string">&#x27;dog&#x27;</span>)<span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span><br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span>);<br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> enum_test(e) <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">&#x27;fish&#x27;</span>),(<span class="hljs-string">&#x27;dog&#x27;</span>),(<span class="hljs-string">&#x27;apple&#x27;</span>);<br></code></pre></td></tr></table></figure>
<p>  其中存储顺序是按照</p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> enum_test(e) <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">&#x27;fish&#x27;</span>),(<span class="hljs-string">&#x27;dog&#x27;</span>),(<span class="hljs-string">&#x27;apple&#x27;</span>);<br></code></pre></td></tr></table></figure>
<p>  进行排序的，而数字是按照</p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">e ENUM(<span class="hljs-string">&#x27;fish&#x27;</span>,<span class="hljs-string">&#x27;apple&#x27;</span>,<span class="hljs-string">&#x27;dog&#x27;</span>)<span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span><br></code></pre></td></tr></table></figure>
<p>  绑定的<br>  可以输入</p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span><span class="hljs-keyword">SELECT</span> e <span class="hljs-operator">+</span> <span class="hljs-number">0</span> <span class="hljs-keyword">FROM</span> enum_test;<br></code></pre></td></tr></table></figure>
<p>  查看对应的数字，而</p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> SELECE e <span class="hljs-keyword">FROM</span> enum_test <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> e;<br></code></pre></td></tr></table></figure>
<p>  可以查看按照e排序的表。</p>
<p>  枚举不好的地方是，字符串列表是固定的，天界或删除字符串必须使用ALTER TABLE。枚举把每个枚举值保存为整数，并且必须进行查找才能转换为字符串，所以枚举列有一些开销，所以枚举的列表要比较小。</p>
</li>
</ul>
<h4 id="日期和时间类型"><a href="#日期和时间类型" class="headerlink" title="日期和时间类型"></a>日期和时间类型</h4><p>MySQL可以使用许多类型来保存日期和是兼职，如year和date.MySQL能存储的最小时间粒度为秒。但是可以使用微妙级别的粒度进行临时运算，且提供了DATETIME和TIMESTAMP两种日期类型</p>
<ul>
<li><p>DATETIME<br>保存的范围为：1001～9999年，精度为秒，格式为YYYYMMDDHHMMSS,与时区无关，使用8个字节的存储空间</p>
</li>
<li><p>TIMESTAMP<br>同unix时间戳保存了1979/1/1以来的秒数（如果还是32位的话，就到2038年）。只使用4个字节存储空间。<br>FROM_UNIXTIME()把unix时间戳转换为日期<br>UNIX_TIMSTAMP()把日期转换为unix时间戳<br>如果在插入时没有指定第一个TIMESTAMP列的值，MySQL则设置这个列的值为当前时间。在插入一行记录是，MySQL默认也会更新第一个TIMESTAMP列的值(除非在UPDATE语句中明确指定了值。)</p>
<h4 id="位数据类型"><a href="#位数据类型" class="headerlink" title="位数据类型"></a>位数据类型</h4></li>
<li><p>BIT<br>可以使用BIT列在一列中存储一个或多个true/false值，BIT列的最大长度是64个位。<br>MySQL把BIT当做字符串类型，而不是数字类型。当检索是，结果是一个包含二进制的字符串而不是ASCII码。</p>
</li>
<li><p>SET<br>如果需要保存很多true/false值，可以考虑合并这些列到一个SET数据类型，它在MySQL内部是以一系列打包的位的集合来表示的。有效利用了存储空间。不过，它的主要缺点是该表列的定义的代价比较高，需要ALTER TABLE。</p>
</li>
</ul>
<h3 id="MySQL-schema设计中的陷阱"><a href="#MySQL-schema设计中的陷阱" class="headerlink" title="MySQL schema设计中的陷阱"></a>MySQL schema设计中的陷阱</h3><ul>
<li>太多的列<br>MySQL的存储引擎API工作时需要在服务器层和存储引擎层之间通过行缓冲格式拷贝数据，然后在服务器层将缓冲内容解码成各个列。从行缓冲中将编码过的列转换成行数据结构的操作代价是非常高的，而且转换的代价依赖于列的数据。所以可以拆分为多个表，再关联起来。</li>
<li>太多的关联<br>如果希望查询执行的快速且并发性好，单个查询最好在12个表以内做关联</li>
<li>全能的枚举<br>在MySQL中，当需要在枚举中增加一个新的数据时。就需要做一次ALTER TABLE操作。</li>
</ul>
<h3 id="范式和反范式"><a href="#范式和反范式" class="headerlink" title="范式和反范式"></a>范式和反范式</h3><p>在范式化的数据库中，每个事实数据会出现并且只出现一次，相反，在反范式化的数据库中，信息是冗余的。栗子：</p>
<table>
<thead>
<tr>
<th>EMPLOYEE</th>
<th>DEPARTMENT</th>
<th>HEAD</th>
</tr>
</thead>
<tbody><tr>
<td>Jones</td>
<td>Accounting</td>
<td>Jones</td>
</tr>
<tr>
<td>Smith</td>
<td>Engineering</td>
<td>Smith</td>
</tr>
<tr>
<td>Browm</td>
<td>Accounting</td>
<td>Jones</td>
</tr>
<tr>
<td>Green</td>
<td>Engineering</td>
<td>Smith</td>
</tr>
</tbody></table>
<p>假如Say Browm接任Accounting部门的领导。需要修改多行数据来反映这个变化。<br>在没有雇员信息情况下就无法表示一个部门。如果我们删除了所有Accounting部门的雇员，我们就失去了关于这个部门本身的所有记录。所以我们需要对这个表进行范式化，拆分雇员和部门项。<br>拆分后的表如下:<br>雇员表:<br>| EMPLOYEE | DEPARTMENT  |<br>| ——– | ———– |<br>| Jones    | Accounting  |<br>| Smith    | Engineering |<br>| Browm    |   Accounting  |<br>| Green    | Engineering  |<br>部门表:<br>| DEPARTMENT  | HEAD  |<br>| ———– | —– |<br>| Accounting  | Jones |<br>| Engineering | Smith |</p>
<h4 id="范式的优点和缺点"><a href="#范式的优点和缺点" class="headerlink" title="范式的优点和缺点"></a>范式的优点和缺点</h4><p>优点:</p>
<ul>
<li>范式化的更新操作通常比反范式化要快</li>
<li>当数据较好地范式化时，就只有很少或者有没重复数据，所以只需要修改更少的数据。</li>
<li>范式化的表通常更小，可以更好地放在内存里，所以操作会更快。</li>
<li>很少有多余的数据意味这检错列表数据时更少需要DISTINCT或者GROUP BY才能获得一份唯一的部门表。<br>缺点:通常需要关联，稍微复杂一些的查询语句在符合范式的schema上都可能需要至少一次关联，也许更多。</li>
</ul>
<h3 id="缓存表和汇总表"><a href="#缓存表和汇总表" class="headerlink" title="缓存表和汇总表"></a>缓存表和汇总表</h3><p>提升性能最好的方法除了在同一张表中保存衍生的冗余数据外，也可以通过创建一张完全独立的汇总表或缓存表。<br>缓存表:表示存储那些可以比较简单地从schema其他表获取(但每次获取的速度比较慢)的数据表（如逻辑冗余的数据）。<br>汇总表:保存的是使用GROUP BY 语句聚合数据的表。</p>
<p>汇总表栗子：如果一个网站需要计算之前24小时内发送的消息数，可以这样设计:<br>以每小时汇总表为基础，把前23个完整的小时的统计表中的计数全部加起来，最后再加上开始阶段和结束阶段不完整的小时内的计数。</p>
<p>而缓存表则不一样，对优化搜索和检索查询语句很有效。这些查询语句经常需要特殊的表和索引结构。栗子:如果需要很多不同的索引组合来加速各种类型的查询时，可以创建一张只包含主表中部分列的缓存表。这时可以使用不同的存储引擎，例如主表使用InnoDB ，缓存表用MyISAM将会得到更小的索引空间。</p>
<p>在重建表时，可以考虑通过使用”影子表”来实现，也就是创建一个新表，填充数据后与真实表做切换。栗子，原始表为my_summary<br>命令:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> IF <span class="hljs-keyword">EXISTS</span> my_summary_new,my_summary_old;<br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> my_summary_new <span class="hljs-keyword">LIKE</span> my_summary;<br><span class="hljs-comment">-- populate my_summary_new as desired</span><br>mysql<span class="hljs-operator">&gt;</span> RENAME <span class="hljs-keyword">TABLE</span> my_summary <span class="hljs-keyword">TO</span> my_summary_old, my_summary_new <span class="hljs-keyword">TO</span>  my_summary;<br></code></pre></td></tr></table></figure>
<h4 id="计数器表"><a href="#计数器表" class="headerlink" title="计数器表"></a>计数器表</h4><p>一般设计的计数器表只有一行数据，对于事务来说，这条记录上都有一个全局的互斥锁，会使得事务只能串行执行，如果要获得更高的并发更新性能，也可以将计数器保存在多行中，每次随机选择一行更新，要获得结果时，则使用聚合查询。<br>创建命令：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> CREAT <span class="hljs-keyword">TABLE</span> hit_counter(<br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span>    slot tinyint unsigned <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> <span class="hljs-keyword">primary</span> <span class="hljs-keyword">key</span>,<br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span>    cnt <span class="hljs-type">int</span> unsigned <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span><br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span>)   ENGINE<span class="hljs-operator">=</span>InnoDB;<br></code></pre></td></tr></table></figure>
<p>更新命令(创建100行):</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span><span class="hljs-keyword">UPDATE</span> hit_counter <span class="hljs-keyword">SET</span> cnt <span class="hljs-operator">=</span> cnt <span class="hljs-operator">+</span> <span class="hljs-number">1</span> <span class="hljs-keyword">WHERE</span> slot <span class="hljs-operator">=</span> RAND()<span class="hljs-operator">*</span><span class="hljs-number">100</span>;<br></code></pre></td></tr></table></figure>
<p>获得结果:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">SUM</span>(cnt) <span class="hljs-keyword">FROM</span> hit_counter;<br></code></pre></td></tr></table></figure>
<p>如果希望减少表的行数，可以写一个周期执行的任务，合并所有结果到0号槽并删除其他槽:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">UPDATE</span> daily_hit_counter <span class="hljs-keyword">as</span> c<br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span>    <span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span>(<br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span>        <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">day</span>,<span class="hljs-built_in">SUM</span>(cnt) <span class="hljs-keyword">AS</span> cnt,<span class="hljs-built_in">MIN</span>(slot) <span class="hljs-keyword">AS</span> mslot<br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span>        <span class="hljs-keyword">FROM</span> daily_hit_counter<br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span>        <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> <span class="hljs-keyword">day</span><br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span>    ) <span class="hljs-keyword">AS</span> xUSING(<span class="hljs-keyword">day</span>)<br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SET</span> c.cnt <span class="hljs-operator">=</span> IF(c.slot <span class="hljs-operator">=</span> x.mslot, x.cnt,<span class="hljs-number">0</span>), <br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span>     c.slot <span class="hljs-operator">=</span> IF(c.slot <span class="hljs-operator">=</span> x.mslot,<span class="hljs-number">0</span>,c<span class="hljs-operator">/</span>slot);<br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> daily_hit_counter <span class="hljs-keyword">WHERE</span> slot <span class="hljs-operator">&lt;&gt;</span> <span class="hljs-number">0</span><span class="hljs-keyword">AND</span> cnt <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure>
<h3 id="加快ALTER-TABLE-操作的速度"><a href="#加快ALTER-TABLE-操作的速度" class="headerlink" title="加快ALTER TABLE 操作的速度"></a>加快ALTER TABLE 操作的速度</h3><p>一般来说ALTER TABLE都是重建表，操作的性能都比较差，特别是大表<br>但有也有例外，例如，有两种方法可以改变或删除一个列的默认值(一种方法很快，一种很慢)。假如要修改电影的默认租赁限期，从三天改到五天，很慢的方式:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> sakila.film<br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> MODIFT <span class="hljs-keyword">COLUMN</span> rental_duration TINYINT(<span class="hljs-number">3</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">5</span>;<br></code></pre></td></tr></table></figure>
<p>该方式拷贝了整张表到一张新表，甚至列的类型、大小和可否为NULL属性都没改变。</p>
<p>快的方式:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> sakila.film<br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">COLUMN</span> rental_duration <span class="hljs-keyword">SET</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">5</span>;<br></code></pre></td></tr></table></figure>
<p>该方式会直接修改.frm文件而不涉及表数据。所以这个操作会很快。</p>
<h4 id="只修改-frm文件"><a href="#只修改-frm文件" class="headerlink" title="只修改.frm文件"></a>只修改.frm文件</h4><p>如果是这些操作则可能不需要重建:</p>
<ul>
<li>移除(不是增加)一个列的AUTO_INCREMENT属性</li>
<li>增加、移除、或更改ENUM和SET常量。如果移除的是已经有行数据用到其值的常量，查询将会返回一个空字符串值</li>
</ul>
<p>修改方法(为表结构创建一个新的.frm文件，然后用它替换掉已经存在的那张表.frm文件):</p>
<ol>
<li>创建一张有相同结构的空表，并进行所需的修改(如增加enum常量)</li>
<li>执行FLUSH TABLES WITH READ LOCK。这将会关闭所有正在使用的表，并且禁止任何表被打开。</li>
<li>交换.frm文件</li>
<li>执行UNLOCK TABLES 来释放第二步的读锁</li>
</ol>
<h4 id="快速创建MyISAM索引"><a href="#快速创建MyISAM索引" class="headerlink" title="快速创建MyISAM索引"></a>快速创建MyISAM索引</h4><p>为了高效地载入数据到MyISAM表中，有一个常用的技巧是先禁用索引，载入数据，然后再启用索引。这样之所以能加快的原因是构建索引的工作被延迟到数据完全载入后，这个时候已经可以通过排序来构建索引了。<br>操作步骤:</p>
<ol>
<li>用需要的表结构创建一张表，但是不包括索引</li>
<li>载入数据到表中以构建.MYD文件</li>
<li>按照需要的结构创建另外一张空表，这次要包含索引，这回创建需要的.frm和.MYI文件</li>
<li>获取读锁并刷新</li>
<li>重命名第二张表的.frm和.MYI文件，让MySQL认为是一张表的文件</li>
<li>释放读锁</li>
<li>使用REPAIR TABLE来重建表的索引。该操作会通过排序来构建所有索引，包括唯一索引</li>
</ol>
<h2 id="创建高性能的索引"><a href="#创建高性能的索引" class="headerlink" title="创建高性能的索引"></a>创建高性能的索引</h2><h3 id="索引基础"><a href="#索引基础" class="headerlink" title="索引基础"></a>索引基础</h3><p>索引原理栗子:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> first_name <span class="hljs-keyword">FROM</span> sakila.actor <span class="hljs-keyword">WHERE</span> actor_id <span class="hljs-operator">=</span> <span class="hljs-number">5</span>;<br></code></pre></td></tr></table></figure>
<p>如果在actor_id列上建有索引，则MySQL将使用该索引找到actor_id为5的行，也就是，MySQL先在索引上按值进行查找，然后返回所有包含该值的数据行。</p>
<p>索引可以包含一个或多个列的值。如果索引包含多个列，那么列的顺序也十分重要，因为MySQL只能高效地使用索引的最左前缀列，创建一个包含两个列的索引，和创建两个只包含一列的索引是大不相同的</p>
<h4 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h4><p>在MySQL中，索引是在存储引擎层而不是服务器层实现的，所以，并没有同一的索引标准，不同存储引擎的索引的工作方式并不一样，也不是所有的存储引擎都支持所有类型的索引。</p>
<ul>
<li><p>B-Tree索引<br>所有值都是按顺序存储的，并且每一个叶子页到根的距离相同。<br><img    class="lazyload" data-original="https://github.com/so1n/so1n_blog_photo/blob/master/blog_photo/sql-b-tree.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">innoDB的B-tree结构</span><br>存储引擎根据索引的根节点开始进行搜索。<br>B-Tree索引的查询类型适用于全键值、键值范围或键前缀查找。其中键前缀查找只使用于根据最左前缀的查找。前面所述的索引对如下类型的查询有效:</p>
<ul>
<li><p>全值匹配<br>全值匹配指的是和索引中的所有列进行匹配，例如可用于查找姓名为CUba Allen、出生与1960-01-01的人</p>
</li>
<li><p>匹配最左前缀<br>可用于查找所有姓为Allen的人，即只使用索引的第一列</p>
</li>
<li><p>匹配列前缀<br>匹配某一列的值的开头部分，如查找所有以J开头的姓的人</p>
</li>
<li><p>匹配范围值<br>例如查找姓位于Allen和Barrymore之间的人</p>
</li>
<li><p>精确匹配某一列并范围匹配另外一列<br>如查找所有姓为Allen且名字是字母K开头的人</p>
</li>
<li><p>只访问索引的查询<br>查询只需要访问索引而无需访问数据行</p>
<p>B-Tree索引的限制</p>
</li>
<li><p>如果不是按照索引的最左列开始查找，则无法使用索引。</p>
</li>
<li><p>不能跳过索引中的列</p>
</li>
<li><p>如果查询中有某个列的范围查询，则其右边所有列都无法使用索引优化查找。<br>如“WHERE last_name=’Smith’ AND first_name LIKe ‘J%’ AND dob = ‘1976-12-23’”这个查询只能使用索引的前两列，由于like是范围条件。</p>
</li>
</ul>
</li>
<li><p>哈希索引<br>哈希索引基于哈希表实现，只有精确到匹配索引所有列的查询才有效。对于每一行数据，存储引擎会对所有的索引列计算一个哈希码，哈希码是一个较小的值，并且不同键值的行计算出来的哈希码也不一样，哈希索引将所有的哈希码存储在索引中，同时在哈希表中保存指向每个数据行的指针。<br>在MySQL中只有Memory引擎显示支持哈希索引(注:经查阅，NDB也支持，而InnoDB支持的方式略不同，不能人为干与，只能自动创建)<br>由于索引本身只需存储对应的哈希值所以索引的结构十分紧凑，这也让哈希索引查找的速度非常快，不过哈希索引也有它的限制:</p>
<ul>
<li>哈希索引只包含哈希值和行指针，而不存储字段值，所以不能使用索引中的值来避免读取行。不过，访问内存中的行的速度很快，所以大部分情况下这一点对性能的影响并不明显。</li>
<li>哈希索引数据并不是按照索引值顺序存储的，所以就无法用于排序</li>
<li>哈希索引也不支持部分索引列匹配查找，因为哈希索引始终是使用索引列的全部内容来计算哈希值的。</li>
<li>哈希索引只支持等值比较查询，=、IN()、&lt;=&gt;</li>
<li>访问哈希索引的数据非常快，除非有很多哈希冲突。当出现冲突时，存储引擎必须遍历链表中所有的行指针，逐步进行比较，直到找到所有符合条件的行</li>
</ul>
</li>
</ul>
<p>关于innoDB的哈希索引:当innoDB注意到某些索引值被使用得非常频繁时，它会在内存中基于B-tree索引之上再创建一个哈希索引，这样就让B-Tree索引也具有哈希索引的一些优点，但这是一个完全自动的、内部的行为，用户无法控制或配置，但可以完全关闭该功能</p>
<pre><code>- 创建自定义哈希索引
如果引擎不支持哈希索引，则可以模拟像InnoDB一样创建哈希索引。
思路就是在用B-Tree查找时，它使用哈希值而不是键本身进行索引查找，需要做的就是在查询的WHERE子句中手动指定使用哈希函数。栗子（使用B-Tree存储URL）：
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> id <span class="hljs-keyword">FROM</span> url <span class="hljs-keyword">WHERE</span> url<span class="hljs-operator">=</span>&quot;http://www.mysql.com&quot;;<br></code></pre></td></tr></table></figure>
改用为：
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> id <span class="hljs-keyword">FROM</span> url <span class="hljs-keyword">WHERE</span> url<span class="hljs-operator">=</span>&quot;http://www.mysql.com&quot;<br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">AND</span> url_crc<span class="hljs-operator">=</span>CRC32(&quot;http://www.mysql.com&quot;);<br></code></pre></td></tr></table></figure>
这样的查询速度很快，不过需要自己来维护哈希值。可以使用触发器实现，下面的案例演示了触发器如何在插入和更新时维护url_crc列。首先创建下表:
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> pseudohash(<br>    id <span class="hljs-type">int</span> unsigned <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> auto_increment,<br>    url <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    url_crc <span class="hljs-type">int</span> unsigned <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">0</span>,<br>    <span class="hljs-keyword">PRIMARY</span> <span class="hljs-keyword">KEY</span>(id)<br>);<br></code></pre></td></tr></table></figure>
然后创建触发器。先临时修改以下语句分隔符，这样就可以在触发器定义中使用分好:
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">DELIMITER</span>//<br><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TRIGGER</span> pseudohash_crc_ins <span class="hljs-keyword">BEFORE</span> <span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">ON</span> pseudohash <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">EACH</span> <span class="hljs-keyword">ROW</span> <span class="hljs-keyword">BEGIN</span><br><span class="hljs-keyword">SET</span> <span class="hljs-built_in">NEW</span>.url_crc=crc32(<span class="hljs-built_in">NEW</span>.url);<br><span class="hljs-keyword">END</span>;<br>//<br><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TRIGGER</span> pseudohash_crc_UPD <span class="hljs-keyword">BEFORE</span> <span class="hljs-keyword">UPDATE</span> <span class="hljs-keyword">ON</span> pseudohash <span class="hljs-keyword">FOR</span>  <span class="hljs-keyword">EACH</span> <span class="hljs-keyword">ROW</span> <span class="hljs-keyword">BEGIN</span> <span class="hljs-keyword">SET</span> <span class="hljs-built_in">NEW</span>.uel_crc=crc32(<span class="hljs-built_in">NEW</span>.url);<br><span class="hljs-keyword">END</span>;<br>//<br></code></pre></td></tr></table></figure>
如果出现哈希冲突。查询时应该使用类似于:
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> word,crc <span class="hljs-keyword">FROM</span> words <span class="hljs-keyword">WHERE</span> crc <span class="hljs-operator">=</span> CRC(<span class="hljs-string">&#x27;gnu&#x27;</span>)<span class="hljs-keyword">AND</span> word <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;gnu&#x27;</span>;<br></code></pre></td></tr></table></figure>
而不是单单：
    <figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> word,crc <span class="hljs-keyword">FROM</span> words <span class="hljs-keyword">WHERE</span> crc <span class="hljs-operator">=</span> CRC(<span class="hljs-string">&#x27;gnu&#x27;</span>);<br></code></pre></td></tr></table></figure>
</code></pre>
<ul>
<li>空间数据索引<br>MyISAM表支持空间索引，可以用作地理数据存储，这种索引无需前缀查询，空间索引会从所有维度来索引数据，必须使用MySQL的GIS相关函数如MBRCONTAINS()等来维护数据，但MySQL支持并不完善</li>
<li>全文索引<br>是一种特殊类型的索引，查找的是文本中的关键词，而不是直接比较索引中的值，比较类似于搜索引擎坐的事情而不是简单的WHERE条件匹配。<br>在相同的列上同时创建全文索引和基于值的B-Tree索引不会有冲突，全文索引适用于MATCHI AGAINST操作，而不是普通的WHERE条件操作。</li>
</ul>
<h3 id="索引的优点"><a href="#索引的优点" class="headerlink" title="索引的优点"></a>索引的优点</h3><p>索引有三个优点:<br>1.索引大大减少了服务器需要扫描的数据量<br>2.索引可以帮助服务器避免排序和临时表<br>3.索引可以将随机I/O变为顺序I/O</p>
<h3 id="高性能的索引策略"><a href="#高性能的索引策略" class="headerlink" title="高性能的索引策略"></a>高性能的索引策略</h3><h4 id="不要索引独立的列"><a href="#不要索引独立的列" class="headerlink" title="不要索引独立的列"></a>不要索引独立的列</h4><p>独立的列，MySQL是不会使用索引的<br>独立的列是指索引列不能是表达式的一部分，也不能是函数的参数，例如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> actor_id <span class="hljs-keyword">FROM</span> sakila.actor <span class="hljs-keyword">WHERE</span> actor_id <span class="hljs-operator">+</span><span class="hljs-number">1</span> <span class="hljs-operator">=</span><span class="hljs-number">5</span>;<br></code></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> ... <span class="hljs-keyword">WHERE</span> TO_DAYS(<span class="hljs-built_in">CURRENT_DATE</span>) <span class="hljs-operator">-</span> TO_DAYS(date_col) <span class="hljs-operator">&lt;=</span><span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure>
<h4 id="前缀索引和索引选择性"><a href="#前缀索引和索引选择性" class="headerlink" title="前缀索引和索引选择性"></a>前缀索引和索引选择性</h4><p>索引的选择性：不重复的索引值和数据表记录总数(#T)的比值，范围从1/#T到1之间。索引的选择性越高则查询效率越高，因为选择性高的索引可以让MySQL子啊查找时过滤掉更多的行。唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的。</p>
<p>诀窍在于选择足够长的前缀以保证较高的选择性，同时又不能太长(以便节约空间)。换句话说，前缀的“基数”应该接近于完整列的“基数”,一般计算合适的前缀长度就是计算完整列的选择性:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">COUNT</span>(<span class="hljs-keyword">DISTINCT</span> ???)<span class="hljs-operator">/</span><span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">FROM</span> ???<br></code></pre></td></tr></table></figure>
<p>得出的数与</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">COUNT</span>(<span class="hljs-keyword">DISTINCT</span> <span class="hljs-keyword">LEFT</span>(???, <span class="hljs-number">3</span>))<span class="hljs-operator">/</span><span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">As</span> sel3 <span class="hljs-keyword">FROM</span> ???<br></code></pre></td></tr></table></figure>
<p>相近即可，其中3最前缀的数字的多少。</p>
<h4 id="选择合适的索引列顺序"><a href="#选择合适的索引列顺序" class="headerlink" title="选择合适的索引列顺序"></a>选择合适的索引列顺序</h4><p>在一个多列B-Tree索引中，索引列的顺序意味着索引首先按照最左列进行排序，其次是第二列，等等，索引可以按照升序或者降序进行扫描，以满足精确符合列顺序的ORDER BY、GROUP和DISTINCT等子句的查询需求<br>以下面的查询为例:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> payment <span class="hljs-keyword">WHERE</span> staff_id <span class="hljs-operator">=</span> <span class="hljs-number">2</span> <span class="hljs-keyword">AND</span> customer_id <span class="hljs-operator">=</span> <span class="hljs-number">584</span><br></code></pre></td></tr></table></figure>
<p>要使用什么索引可以用下面的查询预测以下，看看各个WHERE条件的分支对应的数据基数有多大:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&lt;</span><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">SUM</span>(staff_id<span class="hljs-operator">=</span><span class="hljs-number">2</span>),<span class="hljs-built_in">SUM</span>(customer_id <span class="hljs-operator">=</span> <span class="hljs-number">584</span>) <span class="hljs-keyword">FROM</span> payment\G<br><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-number">1.</span><span class="hljs-type">row</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><br><span class="hljs-built_in">SUM</span>(staff_id<span class="hljs-operator">=</span><span class="hljs-number">2</span>):<span class="hljs-number">7992</span><br><span class="hljs-built_in">SUM</span>(customer_id <span class="hljs-operator">=</span> <span class="hljs-number">584</span>):<span class="hljs-number">30</span><br></code></pre></td></tr></table></figure>
<p>这样可以发现选用customer_id在前面比较好，但是不能依赖与具体值，所以可以这样:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">COUNT</span>(DISTINC staff_id)<span class="hljs-operator">/</span><span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">AS</span> staff_id_selectivity,<br>    <span class="hljs-operator">&gt;</span><span class="hljs-built_in">COUNT</span>(DISTINC customer_id)<span class="hljs-operator">/</span><span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">AS</span> customer_id_selectivity,<br>    <span class="hljs-operator">&gt;</span><span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>)<br>    <span class="hljs-operator">&gt;</span><span class="hljs-keyword">FROM</span> payment\G<br><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-number">1.</span><span class="hljs-type">row</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><br>staff_id_selectivity：<span class="hljs-number">0.0001</span><br>customer_id_selectivity:<span class="hljs-number">0.0373</span><br><span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>):<span class="hljs-number">16049</span><br></code></pre></td></tr></table></figure>
<p>可以看出customer_id的选择性更高，所以答案是将其作为索引列的第一列。</p>
<h4 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h4><p>聚簇索引并不是一种单独的索引类型，而是一种数据存储方式，具体细节依赖于其实现方式，但InnoDB的聚簇索引实际上在同一个结构中保存了B-Tree索引和数据行。当表有聚簇索引时，它的数据行实际上存放在索引的叶子页中。聚簇表示数据行和相邻的键值紧凑地存储在一起，因为无法同时把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引。<br><img    class="lazyload" data-original="https://github.com/so1n/so1n_blog_photo/blob/master/blog_photo/%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95.png?raw=true" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">enter description here</span><br>图展示了聚簇索中的记录是如何存放的。注意到，叶子页包含了行的全部数据，但是节点页只包含了索引列。InnoDB将通过主键聚集数据，这就是说图中“被索引的列”就是主键列。如果没有定义主键，InnoDB会选择一个唯一的非空索引代替。如果没有这样的索引，InnoDB会隐式定义一个主键来作为聚簇索引。InnoDB只聚集在同一个页面中的记录。包含相邻键值的页面可能会相聚甚远。</p>
<p>聚集的数据有一些重要的优点:</p>
<ul>
<li>可以把相关数据保存在一起。例如实现电子邮箱时，可以根据用户ID来聚集数据，这样只需要从磁盘读取少数的数据页就能获取某个用户的全部邮件。如果没有使用聚簇索引，则每封邮件都可能导致一次磁盘I/O</li>
<li>数据访问更快。因为聚簇索引将索引和数据保存在同一个B-Tree</li>
<li>使用覆盖索引扫描的查询可以直接使用页节点中的主键值。<br>也有一些缺点:</li>
<li>聚簇数据最大限度地提高了I/O密集型应用的性能，但如果数据全部都放在内存中，则访问的顺序就没那么重要了，也没有优势</li>
<li>插入速度严重依赖于插入顺序。按照主键的顺序插入是加载数据到InnoDB表中速度最快的方式。但如果不是按照主键顺序加载数据，那么在加载完成后最好使用OPTIMIZE TABLE 命令重新组织一下表。</li>
<li>更新更新聚簇索引的表在插入新行，或者主键被更新导致需要移动行的时候，可能面临“页分裂”的问题。当行的主键值要求必须将这一行插入到某个已满的页中时，存储引擎会将该页分裂成两个页面来容纳该行，这就是一次页分裂操作，页分裂会导致表占用更多的磁盘空间。</li>
<li>聚簇索引可能导致权标扫面变慢，尤其是行比较稀疏，或者由于页分裂导致数据存储不连续的时候。</li>
<li>二级索引可能不想象的要更大，因为在二级索引的叶子节点包含了引用行的主键列。</li>
<li>二级索引访问需要两次索引查找，而不是一次（因为二级索引叶子节点保存的不是指向行的物理位置的指针，而是行的主键值，然后根据这个值取聚簇索引中查找对应的行）。</li>
</ul>
<h4 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h4><p>如果一个索引包含所有需要查询的字段的值，我们就称为覆盖索引</p>
<p>覆盖索引是非常有用的能够极大地提高性能，如果查询只需要扫描索引而无须回表，会带来很多好处:</p>
<ul>
<li>索引条目通常远小于数据行大小，所以如果只需要读取索引，那么MySQL就会极大地减少数据访问量。</li>
<li>由于索引是按照列值顺序存储的所以对于I/O密集型的范围查询会比随机从磁盘读取每一行数据的I/o要少得多。</li>
<li>由于InnoDB的聚簇索引，覆盖索引对InnoDB表特别有用，InnoDB的二级索引在叶子节点中保存了行的主键值，所以如果二级主键能够覆盖查询，则可以避免对主键索引的二次查询。</li>
</ul>
<p>由于B-Tree索引能够存储索引列的值，所以只有它才能称为覆盖索引。当发起一个被索引覆盖的查询时，在EXPLAIN的Extra列可以看到“Using index”的信息。假如表有一个多列索引(store_id,film_id)。MySQL如果只需要访问这两列，就可以使用这个索引做覆盖索引。</p>
<h4 id="使用索引扫描来做排序"><a href="#使用索引扫描来做排序" class="headerlink" title="使用索引扫描来做排序"></a>使用索引扫描来做排序</h4><p>MySQL有两种方式可以生产有序的结果:通过排序操作和按索引顺序扫描，如果EXPLAIN出来的tyre列的值为index，则说明使用了索引扫描来做排序。</p>
<p>扫描索引本事很快的，但如果索引不能覆盖查询所需的全部列，那就不得不每扫描一条索引记录就都回表查询一次对应的行，这基本上都是随机I/O，因此按索引顺序读取数据的速度通常要比顺序地全表扫描慢，尤其是在I、O密集型的工作负载时。所以要设计MySQL可以使用同一个索引既能满足排序又能用于查找行。<br>Ps:只有当索引的列顺序和ORDER BY子句的顺序完全已知，并且所有列的排序方向都一样时，MySQL才能都使用索引来对结果做排序。如果查询需要关联多张表，则只有当ORDER BY子句引用的字段全部为第一个表时，才能使用索引做排序。ORDER BY子句和查找型查询的限制是一样的:需要满足索引的最左前缀的要求；否则MySQL都需要执行排序操作，而无法利用索引排序。</p>
<h3 id="索引案例学习"><a href="#索引案例学习" class="headerlink" title="索引案例学习"></a>索引案例学习</h3><p>案例直接看书</p>
<h4 id="支持多种过滤条件"><a href="#支持多种过滤条件" class="headerlink" title="支持多种过滤条件"></a>支持多种过滤条件</h4><p>in()与where的诀窍使用，见书。</p>
<h4 id="避免多个范围条件"><a href="#避免多个范围条件" class="headerlink" title="避免多个范围条件"></a>避免多个范围条件</h4><h4 id="优化排序"><a href="#优化排序" class="headerlink" title="优化排序"></a>优化排序</h4><h3 id="维护索引和表"><a href="#维护索引和表" class="headerlink" title="维护索引和表"></a>维护索引和表</h3><p>当需要找到并修复损坏的表，维护准确的缩影统计信息，减少碎片时，看书。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>python设计模式</title>
    <url>/2017/11/10/18_python_design_patterns/</url>
    <content><![CDATA[<h2 id="前记"><a href="#前记" class="headerlink" title="前记"></a>前记</h2><p>设计模式都是前人根据代码经验汇总而来的, 我们需要学习如何使用设计模式, 但是切忌被设计模式囚禁住我们的思想<br>设计模式虽然都是在描述编程的，但是很多也是来源于生活的实例，就拿一台单反来举例:</p>
<ul>
<li>工厂模式  单反的外观由很多塑料来制作的，其中塑料属于原料，但通过不同的模具生产出不一样的模块。</li>
<li>造者模式  组成一台单反有很多原件，需要机器或工人按照规划好的程序，把部件组装起来，只有部件组装完成，单反才可以使用。</li>
<li>抽象工厂模式  单反里面有m档,a档p档s档等，选择不同的档，就有不一样的功能</li>
<li>单例模式  单反中有个反光镜，拍摄前，反光镜把景像反射到取景器，拍摄时，反光镜把景物反射给cmos，然后进行拍摄，其中景象的呈现只能2选1，不能两个都选取</li>
<li>原型模式  现在单反一开始有个raw格式，这是刚出来的格式，但是jpg格式是通过一定的程序修图后呈现出来的图片，这时，raw格式的图片不会被影响。</li>
<li>适配器模式  单反通过更改不同的镜头，可以用来拍摄微距，或者拍星空和人像等等</li>
<li>修饰器模式  通过在单反镜头前面加个不同uv镜片，可以让拍出来的照片可以减光，或者灯光有星芒。</li>
<li>外观模式  自动挡在点击拍摄时，单反自己进行对焦，决定用什么快门，光圈等等，用户不知道这些是如何执行，只知道按了拍摄按钮</li>
<li>状态模式  单反的闪光灯，在选择自动，打开，或关闭时。闪关灯在拍照时有不同的执行的操作，切闪光灯的这三个选项还可以进行切换。<span id="more"></span>
<h2 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h2>如果后面带有星号就是认为比较重要的模式，虽然这个是阅读完《python编程实战》的设计模式部分，《精通python设计模式》，以及c语言和java语言版本的《设计模式》后才写出来的，但电脑里有《精通python设计模式》的电子书和代码，所以很多都引用了这本书（之所以会读这样多相同的书，是因为在备考ccna时很闷，有时就翻一翻其他书看一看）</li>
</ul>
<p>2020-12-19代码进行了重构</p>
<h2 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h2><h3 id="工厂模式-（-）"><a href="#工厂模式-（-）" class="headerlink" title="工厂模式 （*）"></a>工厂模式 （*）</h3><blockquote>
<p>在工厂设计模式中，客户端可以请求一个对象，而无需知道这个对象来自哪里；也就是，使用哪个类来生成这个对象。工厂背后的思想是简化对象的创建。与客户端自己基于类实例化直接创建对象相比，基于一个中心化函数来实现，更易于追踪创建了哪些对象。通过将创建对象的代码和使用对象的代码解耦，工厂能够降低应用维护的复杂度</p>
</blockquote>
<blockquote>
<p>工厂通常有两种形式：一种是工厂方法（Factory Method），它是一个方法（或以地道的Python术语来说，是一个函数），对不同的输入参数返回不同的对象,第二种是抽象工厂，它是一组用于创建一系列相关事物对象的工厂方法</p>
</blockquote>
<p>现实中用到工厂方法模式思想的一个例子是塑料玩具制造。制造塑料玩具的压塑粉都是一样的，但使用不同的塑料模具就能产出不同的外形。比如，有一个工厂方法，输入是目标外形（鸭子或小车）的名称，输出则是要求的塑料外形</p>
<p>工厂模式使用场景</p>
<blockquote>
<p>如果因为应用创建对象的代码分布在多个不同的地方，而不是仅在一个函数/方法中，你发现没法跟踪这些对象，那么应该考虑使用工厂方法模式。工厂方法集中地在一个地方创建对象，使对象跟踪变得更容易。注意，创建多个工厂方法也完全没有问题，实践中通常也这么做，对相似的对象创建进行逻辑分组，每个工厂方法负责一个分组。例如，有一个工厂方法负责连接到不同的数据库（MySQL、 SQLite），另一个工厂方法负责创建要求的几何对象（圆形、三角形），等等。<br>若需要将对象的创建和使用解耦，工厂方法也能派上用场。创建对象时，我们并没有与某个特定类耦合/绑定到一起，而只是通过调用某个函数来提供关于我们想要什么的部分信息。这意味着修改这个函数比较容易，不需要同时修改使用这个函数的代码。<br>另外一个值得一提的应用案例与应用性能及内存使用相关。工厂方法可以在必要时创建新的对象，从而提高性能和内存使用率。若直接实例化类来创建对象，那么每次创建新对象就需要分配额外的内存（除非这个类内部使用了缓存，一般情况下不会这样）。</p>
</blockquote>
<p>代码示例（来自于《精通python设计模式》）：<br>最主要的是connection_factory函数里，根据不同的文件，选择不同的方法加工，再传回去</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> xml.etree.ElementTree <span class="hljs-keyword">as</span> etree<br><span class="hljs-keyword">import</span> json<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JSONConnector</span>:</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, filepath</span>):</span><br>        self.data = <span class="hljs-built_in">dict</span>()<br>        <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(filepath, mode=<span class="hljs-string">&#x27;r&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>            self.data = json.load(f)<br><br><span class="hljs-meta">    @property</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">parsed_data</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> self.data<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">XMLConnector</span>:</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, filepath</span>):</span><br>        self.tree = etree.parse(filepath)<br><br><span class="hljs-meta">    @property</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">parsed_data</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> self.tree<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">connection_factory</span>(<span class="hljs-params">filepath</span>):</span><br>    <span class="hljs-keyword">if</span> filepath.endswith(<span class="hljs-string">&#x27;json&#x27;</span>):<br>        connector = JSONConnector<br>    <span class="hljs-keyword">elif</span> filepath.endswith(<span class="hljs-string">&#x27;xml&#x27;</span>):<br>        connector = XMLConnector<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&#x27;Cannot connect to &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(filepath))<br>    <span class="hljs-keyword">return</span> connector(filepath)<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">connect_to</span>(<span class="hljs-params">filepath</span>):</span><br>    factory = <span class="hljs-literal">None</span><br>    <span class="hljs-keyword">try</span>:<br>        factory = connection_factory(filepath)<br>    <span class="hljs-keyword">except</span> ValueError <span class="hljs-keyword">as</span> ve:<br>        print(ve)<br>    <span class="hljs-keyword">return</span> factory<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    sqlite_factory = connect_to(<span class="hljs-string">&#x27;data/person.sq3&#x27;</span>)<br>    print()<br><br>    xml_factory = connect_to(<span class="hljs-string">&#x27;data/person.xml&#x27;</span>)<br>    xml_data = xml_factory.parsed_data<br>    liars = xml_data.findall(<span class="hljs-string">&quot;.//&#123;&#125;[&#123;&#125;=&#x27;&#123;&#125;&#x27;]&quot;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-string">&#x27;person&#x27;</span>,<br>                                                     <span class="hljs-string">&#x27;lastName&#x27;</span>, <span class="hljs-string">&#x27;Liar&#x27;</span>))<br>    print(<span class="hljs-string">&#x27;found: &#123;&#125; persons&#x27;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">len</span>(liars)))<br>    <span class="hljs-keyword">for</span> liar <span class="hljs-keyword">in</span> liars:<br>        print(<span class="hljs-string">&#x27;first name: &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(liar.find(<span class="hljs-string">&#x27;firstName&#x27;</span>).text))<br>        print(<span class="hljs-string">&#x27;last name: &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(liar.find(<span class="hljs-string">&#x27;lastName&#x27;</span>).text))<br>        [print(<span class="hljs-string">&#x27;phone number (&#123;&#125;)&#x27;</span>.<span class="hljs-built_in">format</span>(p.attrib[<span class="hljs-string">&#x27;type&#x27;</span>]),<br>               p.text) <span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> liar.find(<span class="hljs-string">&#x27;phoneNumbers&#x27;</span>)]<br><br>    print()<br><br>    json_factory = connect_to(<span class="hljs-string">&#x27;data/donut.json&#x27;</span>)<br>    json_data = json_factory.parsed_data<br>    print(<span class="hljs-string">&#x27;found: &#123;&#125; donuts&#x27;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">len</span>(json_data)))<br>    <span class="hljs-keyword">for</span> donut <span class="hljs-keyword">in</span> json_data:<br>        print(<span class="hljs-string">&#x27;name: &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(donut[<span class="hljs-string">&#x27;name&#x27;</span>]))<br>        print(<span class="hljs-string">&#x27;price: $&#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(donut[<span class="hljs-string">&#x27;ppu&#x27;</span>]))<br>        [print(<span class="hljs-string">&#x27;topping: &#123;&#125; &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(t[<span class="hljs-string">&#x27;id&#x27;</span>], t[<span class="hljs-string">&#x27;type&#x27;</span>])) <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> donut[<span class="hljs-string">&#x27;topping&#x27;</span>]]<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    main()<br></code></pre></td></tr></table></figure>
<h3 id="建造者模式（-）"><a href="#建造者模式（-）" class="headerlink" title="建造者模式（*）"></a>建造者模式（*）</h3><blockquote>
<p>假设我们想要创建一个HTML页面生成器， HTML页面的基本结构（构造组件）通常是一样的：以&lt;html&gt;开始&lt;/html&gt;结束，在HTML部分中有&lt;head&gt;和&lt;/head&gt;元素，在head部分中又有&lt;title&gt;和&lt;/title&gt;元素，等等；但页面在表现上可以不同。每个页面有自己的页面标题、文本标题以及不同的&lt;body/&gt;内容。此外，页面通常是经过多个步骤创建完成的：有一个函数添加页面标题，另一个添加主文本标题，还有一个添加页脚，等等。仅当一个页面的结构全部完成后，才能使用一个最终的渲染函数将该页面展示在客户端。我们甚至可以更进一步扩展这个HTML生成器，让它可以生成一些完全不同的HTML页面。一个页面可能包含表格，另一个页面可能包含图像库，还有一个页面包含联系表单，等等。<br>HTML页面生成问题可以使用建造者模式来解决。该模式中，有两个参与者：建造者 （builder）和指挥者（director）。建造者负责创建复杂对象的各个组成部分。在HTML例子中，这些组成部分是页面标题、文本标题、内容主体及页脚。指挥者使用一个建造者实例控制建造的过程。对于HTML示例，这是指调用建造者的函数设置页面标题、文本标题等。使用不同的建造者实例让我们可以创建不同的HTML页面，而无需变更指挥者的代码</p>
</blockquote>
<p>说白了就是在金拱门点了餐后，工作人员按着订单拿着汉堡，薯条，可乐等到餐盘上，东西都弄好后，就可以递给我了（其中，其他人工作人员就有专门做薯条的，做汉堡的）<br>其中的我就相当于建造者模式的客户端，按着订单取货的工作人员是指挥员，其他工作人员是建造者</p>
<p>如果我们知道一个对象必须经过多个步骤来创建，并且要求同一个构造过程可以产生不同的表现，就可以使用建造者模式。这种需求存在于许多应用中，例如页面生成器、文档转换器以及用户界面（User Interface，UI）表单创建工具</p>
<p>工厂模式和建造者模式有两个区别：</p>
<ul>
<li>主要的区别在于工厂模式以单个步骤创建对象，而建造者模式以多个步骤创建对象，并且几乎始终会使用一个指挥者。一些有针对性的建造者模式实现并未使用指挥者，如Java的StringBuilder，但这只是例外。</li>
<li>另一个区别是，在工厂模式下，会立即返回一个创建好的对象；而在建造者模式下，仅在需要时客户端代码才显式地请求指挥者返回最终的对象<br>就像直接买配置好的笔记本电脑和组装的台式机一样</li>
</ul>
<p>示例代码如下（来自于《精通python设计模式》）:<br>改例中，使用工厂模式，有两个pizza类可以选取，然后通过指挥者(Waiter)来一步一步创建，这里并没返回数据，当创建完时，才一起返回数据</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> enum <span class="hljs-keyword">import</span> Enum<br><span class="hljs-keyword">import</span> time<br><br>PizzaProgress = Enum(<span class="hljs-string">&#x27;PizzaProgress&#x27;</span>, <span class="hljs-string">&#x27;queued preparation baking ready&#x27;</span>)<br>PizzaDough = Enum(<span class="hljs-string">&#x27;PizzaDough&#x27;</span>, <span class="hljs-string">&#x27;thin thick&#x27;</span>)<br>PizzaSauce = Enum(<span class="hljs-string">&#x27;PizzaSauce&#x27;</span>, <span class="hljs-string">&#x27;tomato creme_fraiche&#x27;</span>)<br>PizzaTopping = Enum(<span class="hljs-string">&#x27;PizzaTopping&#x27;</span>, <span class="hljs-string">&#x27;mozzarella double_mozzarella bacon ham mushrooms red_onion oregano&#x27;</span>)<br>STEP_DELAY = <span class="hljs-number">3</span>          <span class="hljs-comment"># 考虑是示例，单位为秒</span><br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pizza</span>:</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, name</span>):</span><br>        self.name = name<br>        self.dough = <span class="hljs-literal">None</span><br>        self.sauce = <span class="hljs-literal">None</span><br>        self.topping = []<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__str__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> self.name<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">prepare_dough</span>(<span class="hljs-params">self, dough</span>):</span><br>        self.dough = dough<br>        print(<span class="hljs-string">&#x27;preparing the &#123;&#125; dough of your &#123;&#125;...&#x27;</span>.<span class="hljs-built_in">format</span>(self.dough.name, self))<br>        time.sleep(STEP_DELAY)<br>        print(<span class="hljs-string">&#x27;done with the &#123;&#125; dough&#x27;</span>.<span class="hljs-built_in">format</span>(self.dough.name))<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MargaritaBuilder</span>:</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        self.pizza = Pizza(<span class="hljs-string">&#x27;margarita&#x27;</span>)<br>        self.progress = PizzaProgress.queued<br>        self.baking_time = <span class="hljs-number">5</span>        <span class="hljs-comment"># 考虑是示例，单位为秒</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">prepare_dough</span>(<span class="hljs-params">self</span>):</span><br>        self.progress = PizzaProgress.preparation<br>        self.pizza.prepare_dough(PizzaDough.thin)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add_sauce</span>(<span class="hljs-params">self</span>):</span><br>        print(<span class="hljs-string">&#x27;adding the tomato sauce to your margarita...&#x27;</span>)<br>        self.pizza.sauce = PizzaSauce.tomato<br>        time.sleep(STEP_DELAY)<br>        print(<span class="hljs-string">&#x27;done with the tomato sauce&#x27;</span>)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add_topping</span>(<span class="hljs-params">self</span>):</span><br>        print(<span class="hljs-string">&#x27;adding the topping (double mozzarella, oregano) to your margarita&#x27;</span>)<br>        self.pizza.topping.append([i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span><br>                                   (PizzaTopping.double_mozzarella, PizzaTopping.oregano)])<br>        time.sleep(STEP_DELAY)<br>        print(<span class="hljs-string">&#x27;done with the topping (double mozzarrella, oregano)&#x27;</span>)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">bake</span>(<span class="hljs-params">self</span>):</span><br>        self.progress = PizzaProgress.baking<br>        print(<span class="hljs-string">&#x27;baking your margarita for &#123;&#125; seconds&#x27;</span>.<span class="hljs-built_in">format</span>(self.baking_time))<br>        time.sleep(self.baking_time)<br>        self.progress = PizzaProgress.ready<br>        print(<span class="hljs-string">&#x27;your margarita is ready&#x27;</span>)<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CreamyBaconBuilder</span>:</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        self.pizza = Pizza(<span class="hljs-string">&#x27;creamy bacon&#x27;</span>)<br>        self.progress = PizzaProgress.queued<br>        self.baking_time = <span class="hljs-number">7</span>        <span class="hljs-comment"># 考虑是示例，单位为秒</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">prepare_dough</span>(<span class="hljs-params">self</span>):</span><br>        self.progress = PizzaProgress.preparation<br>        self.pizza.prepare_dough(PizzaDough.thick)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add_sauce</span>(<span class="hljs-params">self</span>):</span><br>        print(<span class="hljs-string">&#x27;adding the crème fraîche sauce to your creamy bacon&#x27;</span>)<br>        self.pizza.sauce = PizzaSauce.creme_fraiche<br>        time.sleep(STEP_DELAY)<br>        print(<span class="hljs-string">&#x27;done with the crème fraîche sauce&#x27;</span>)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add_topping</span>(<span class="hljs-params">self</span>):</span><br>        print(<span class="hljs-string">&#x27;adding the topping (mozzarella, bacon, ham, mushrooms, red onion, oregano) to your creamy bacon&#x27;</span>)<br>        self.pizza.topping.append([t <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span><br>                                   (PizzaTopping.mozzarella, PizzaTopping.bacon,<br>                                    PizzaTopping.ham, PizzaTopping.mushrooms,<br>                                    PizzaTopping.red_onion, PizzaTopping.oregano)])<br>        time.sleep(STEP_DELAY)<br>        print(<span class="hljs-string">&#x27;done with the topping (mozzarella, bacon, ham, mushrooms, red onion, oregano)&#x27;</span>)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">bake</span>(<span class="hljs-params">self</span>):</span><br>        self.progress = PizzaProgress.baking<br>        print(<span class="hljs-string">&#x27;baking your creamy bacon for &#123;&#125; seconds&#x27;</span>.<span class="hljs-built_in">format</span>(self.baking_time))<br>        time.sleep(self.baking_time)<br>        self.progress = PizzaProgress.ready<br>        print(<span class="hljs-string">&#x27;your creamy bacon is ready&#x27;</span>)<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Waiter</span>:</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        self.builder = <span class="hljs-literal">None</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">construct_pizza</span>(<span class="hljs-params">self, builder</span>):</span><br>        self.builder = builder<br>        [step() <span class="hljs-keyword">for</span> step <span class="hljs-keyword">in</span> (builder.prepare_dough,<br>                             builder.add_sauce, builder.add_topping, builder.bake)]<br><br><span class="hljs-meta">    @property</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">pizza</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> self.builder.pizza<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">validate_style</span>(<span class="hljs-params">builders</span>):</span><br>    <span class="hljs-keyword">try</span>:<br>        pizza_style = <span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;What pizza would you like, [m]argarita or [c]reamy bacon? &#x27;</span>)<br>        builder = builders[pizza_style]()<br>        valid_input = <span class="hljs-literal">True</span><br>    <span class="hljs-keyword">except</span> KeyError <span class="hljs-keyword">as</span> err:<br>        print(<span class="hljs-string">&#x27;Sorry, only margarita (key m) and creamy bacon (key c) are available&#x27;</span>)<br>        <span class="hljs-keyword">return</span> (<span class="hljs-literal">False</span>, <span class="hljs-literal">None</span>)<br>    <span class="hljs-keyword">return</span> (<span class="hljs-literal">True</span>, builder)<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    builders = <span class="hljs-built_in">dict</span>(m=MargaritaBuilder, c=CreamyBaconBuilder)<br>    valid_input = <span class="hljs-literal">False</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-keyword">not</span> valid_input:<br>        valid_input, builder = validate_style(builders)<br>    print()<br>    waiter = Waiter()<br>    waiter.construct_pizza(builder)<br>    pizza = waiter.pizza<br>    print()<br>    print(<span class="hljs-string">&#x27;Enjoy your &#123;&#125;!&#x27;</span>.<span class="hljs-built_in">format</span>(pizza))<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    main()<br><br></code></pre></td></tr></table></figure>
<h3 id="抽象工厂模式（-）"><a href="#抽象工厂模式（-）" class="headerlink" title="抽象工厂模式（*）"></a>抽象工厂模式（*）</h3><blockquote>
<p>抽象工厂设计模式是抽象方法的一种泛化。概括来说，一个抽象工厂是（逻辑上的）一组工<br>厂方法，其中的每个工厂方法负责产生不同种类的对象</p>
</blockquote>
<blockquote>
<p>汽车制造业应用了抽象工厂的思想。冲压不同汽车模型的部件（车门、仪表盘、车篷、挡泥<br>板及反光镜等）所使用的机件是相同的。机件装配起来的模型随时可配置，且易于改变</p>
</blockquote>
<p>因为抽象工厂模式是工厂方法模式的一种泛化，所以它能提供相同的好处：让对象的创建更容易追踪；将对象创建与使用解耦；提供优化内存占用和应用性能的潜力。这样会产生一个问题：我们怎么知道何时该使用工厂方法，何时又该使用抽象工厂？答案是，通常一开始时使用工厂方法，因为它更简单。如果后来发现应用需要许多工厂方法，那么将创建一系列对象的过程合并在一起更合理，从而最终引入抽象工厂。<br>抽象工厂有一个优点，在使用工厂方法时从用户视角通常是看不到的，那就是抽象工厂能够通过改变激活的工厂方法动态地（运行时）改变应用行为。</p>
<p>代码示例如下(来自于《精通python设计模式》)：<br>这段代码就是使用了游戏进入前，可以选择不同的难度一样（这里为小孩和大人），选择完后game就有对应的类，小孩的类的方法和大人的类的方法执行着不同的操作</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Frog</span>:</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, name</span>):</span><br>        self.name = name<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__str__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> self.name<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">interact_with</span>(<span class="hljs-params">self, obstacle</span>):</span><br>        print(<span class="hljs-string">&#x27;&#123;&#125; the Frog encounters &#123;&#125; and &#123;&#125;!&#x27;</span>.<span class="hljs-built_in">format</span>(self,<br>                                                         obstacle, obstacle.action()))<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bug</span>:</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__str__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;a bug&#x27;</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">action</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;eats it&#x27;</span><br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FrogWorld</span>:</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, name</span>):</span><br>        print(self)<br>        self.player_name = name<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__str__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;\n\n\t------ Frog World ———&#x27;</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">make_character</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> Frog(self.player_name)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">make_obstacle</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> Bug()<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Wizard</span>:</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, name</span>):</span><br>        self.name = name<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__str__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> self.name<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">interact_with</span>(<span class="hljs-params">self, obstacle</span>):</span><br>        print(<span class="hljs-string">&#x27;&#123;&#125; the Wizard battles against &#123;&#125; and &#123;&#125;!&#x27;</span>.<span class="hljs-built_in">format</span>(self, obstacle, obstacle.action()))<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Ork</span>:</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__str__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;an evil ork&#x27;</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">action</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;kills it&#x27;</span><br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WizardWorld</span>:</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, name</span>):</span><br>        print(self)<br>        self.player_name = name<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__str__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;\n\n\t------ Wizard World ———&#x27;</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">make_character</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> Wizard(self.player_name)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">make_obstacle</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> Ork()<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GameEnvironment</span>:</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, factory</span>):</span><br>        self.hero = factory.make_character()<br>        self.obstacle = factory.make_obstacle()<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">play</span>(<span class="hljs-params">self</span>):</span><br>        self.hero.interact_with(self.obstacle)<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">validate_age</span>(<span class="hljs-params">name</span>):</span><br>    <span class="hljs-keyword">try</span>:<br>        age = <span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;Welcome &#123;&#125;. How old are you? &#x27;</span>.<span class="hljs-built_in">format</span>(name))<br>        age = <span class="hljs-built_in">int</span>(age)<br>    <span class="hljs-keyword">except</span> ValueError <span class="hljs-keyword">as</span> err:<br>        print(<span class="hljs-string">&quot;Age &#123;&#125; is invalid, please try \</span><br><span class="hljs-string">        again…&quot;</span>.<span class="hljs-built_in">format</span>(age))<br>        <span class="hljs-keyword">return</span> (<span class="hljs-literal">False</span>, age)<br>    <span class="hljs-keyword">return</span> (<span class="hljs-literal">True</span>, age)<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    name = <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;Hello. What&#x27;s your name? &quot;</span>)<br>    valid_input = <span class="hljs-literal">False</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-keyword">not</span> valid_input:<br>        valid_input, age = validate_age(name)<br>    game = FrogWorld <span class="hljs-keyword">if</span> age &lt; <span class="hljs-number">18</span> <span class="hljs-keyword">else</span> WizardWorld<br>    environment = GameEnvironment(game(name))<br>    environment.play()<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    main()<br><br></code></pre></td></tr></table></figure>

<h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><blockquote>
<p>在它的核心结构中只包含一个被称为单例的特殊类。通过单例模式可以保证系统中，应用该模式的类一个类只有一个实例。即一个类只有一个对象实例</p>
</blockquote>
<blockquote>
<p>单例模式的要点有三个；一是某个类只能有一个实例；二是它必须自行创建这个实例；三是它必须自行向整个系统提供这个实例。<br>从具体实现角度来说，就是以下三点：一是单例模式的类只提供私有的构造函数，二是类定义中含有一个该类的静态私有对象，三是该类提供了一个静态的公有的函数用于创建或获取它本身的静态私有对象。</p>
</blockquote>
<blockquote>
<p>对于系统中的某些类来说，只有一个实例很重要，例如，一个系统中可以存在多个打印任务，但是只能有一个正在工作的任务；一个系统只能有一个窗口管理器或文件系统；一个系统只能有一个计时工具或ID(序号)生成器。如在Windows中就只能打开一个任务管理器。如果不使用机制对窗口对象进行唯一化，将弹出多个窗口，如果这些窗口显示的内容完全一致，则是重复对象，浪费内存资源；如果这些窗口显示的内容不一致，则意味着在某一瞬间系统有多个状态，与实际不符，也会给用户带来误解，不知道哪一个才是真实的状态。因此有时确保系统中某个对象的唯一性即一个类只能有一个实例非常重要。[3]<br>如何保证一个类只有一个实例并且这个实例易于被访问呢？定义一个全局变量可以确保对象随时都可以被访问，但不能防止我们实例化多个对象。一个更好的解决办法是让类自身负责保存它的唯一实例。这个类可以保证没有其他实例被创建，并且它可以提供一个访问该实例的方法。这就是单例模式的模式动机。</p>
</blockquote>
<p>示例代码:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    __instance=<span class="hljs-literal">None</span><br>    def__init__(self):<br>        <span class="hljs-keyword">pass</span><br>    def__new__(cls,*args,**kwd):<br>        <span class="hljs-keyword">if</span> Singleton.__instance <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            Singleton.__instance=<span class="hljs-built_in">object</span>.__new__(cls,*args,**kwd)<br>        <span class="hljs-keyword">return</span> Singleton.__instance<br></code></pre></td></tr></table></figure>
<p>python中__new__是在__init__之前执行的，用于创建示例，使用__instance来判断这个实例是否被创建，从而限制只有单例</p>
<p>这样使用的单例模式只能对自己的类进行限制，也不灵活。可以使用装饰器实现的单例模式，以达到灵活使用:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">Singleton</span>(<span class="hljs-params">cls</span>):</span>  <br>    _instance = &#123;&#125;  <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_singleton</span>(<span class="hljs-params">*args, **kargs</span>):</span>  <br>        <span class="hljs-keyword">if</span> cls <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> _instance:  <br>            _instance[cls] = cls(*args, **kargs)  <br>        <span class="hljs-keyword">return</span> _instance[cls]  <br>    <span class="hljs-keyword">return</span> _singleton  <br> <br> <br><span class="hljs-meta">@Singleton  </span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span>  <br>    a = <span class="hljs-number">1</span>  <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, x = <span class="hljs-number">0</span></span>):</span>  <br>        self.x = x  <br>  <br>  <br>a1 = A(<span class="hljs-number">2</span>)  <br>a2 = A(<span class="hljs-number">3</span>)  <br><span class="hljs-built_in">print</span> <span class="hljs-built_in">id</span>(a1)  <br><span class="hljs-built_in">print</span> <span class="hljs-built_in">id</span>(a2)  <br>print(a1.x)  <br>print(a2.x)  <br></code></pre></td></tr></table></figure>
<h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3><p>原型模式的应用就像在github等版本管理器一样，有个人po上段代码后，别人可以copy他，并进行修改，这时是一个副本而不是上传者po的代码，上传者也可以new一个分支来修改。<br>其实就像生活中的有丝分裂一样，在复制一份后，两份的改变不互相影响</p>
<p>示例代码如下(来自于《精通python设计模式》)：<br>代码中是在说一本书，发布第二版后的改变，如年代，字数，价格等</p>
<p>注意：<br>浅副本（copy.copy()）和深副本（copy.deepcopy()）之间的区别</p>
<ul>
<li>浅副本构造一个新的复合对象后，（会尽可能地）将在原始对象中找到的对象的引用插入<br>新对象中。</li>
<li>深副本构造一个新的复合对象后，会递归地将在原始对象中找到的对象的副本插入新对<br>象中。<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># coding: utf-8</span><br><br><span class="hljs-keyword">import</span> copy<br><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> OrderedDict<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Book</span>:</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, name, authors, price, **rest</span>):</span><br>        <span class="hljs-string">&#x27;&#x27;&#x27;rest的例子有：出版商，长度，标签，出版日期&#x27;&#x27;&#x27;</span><br>        self.name = name<br>        self.authors = authors<br>        self.price = price      <span class="hljs-comment"># 单位为美元</span><br>        self.__dict__.update(rest)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__str__</span>(<span class="hljs-params">self</span>):</span><br>        mylist = []<br>        ordered = OrderedDict(<span class="hljs-built_in">sorted</span>(self.__dict__.items()))<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> ordered.keys():<br>            mylist.append(<span class="hljs-string">&#x27;&#123;&#125;: &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(i, ordered[i]))<br>            <span class="hljs-keyword">if</span> i == <span class="hljs-string">&#x27;price&#x27;</span>:<br>                mylist.append(<span class="hljs-string">&#x27;$&#x27;</span>)<br>            mylist.append(<span class="hljs-string">&#x27;\n&#x27;</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#x27;</span>.join(mylist)<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Prototype</span>:</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        self.objects = <span class="hljs-built_in">dict</span>()<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">register</span>(<span class="hljs-params">self, identifier, obj</span>):</span><br>        self.objects[identifier] = obj<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">unregister</span>(<span class="hljs-params">self, identifier</span>):</span><br>        <span class="hljs-keyword">del</span> self.objects[identifier]<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">clone</span>(<span class="hljs-params">self, identifier, **attr</span>):</span><br>        found = self.objects.get(identifier)<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> found:<br>            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&#x27;Incorrect object identifier: &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(identifier))<br>        obj = copy.deepcopy(found)<br>        obj.__dict__.update(attr)<br>        <span class="hljs-keyword">return</span> obj<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    b1 = Book(<span class="hljs-string">&#x27;The C Programming Language&#x27;</span>, (<span class="hljs-string">&#x27;Brian W. Kernighan&#x27;</span>, <span class="hljs-string">&#x27;Dennis M.Ritchie&#x27;</span>), price=<span class="hljs-number">118</span>, publisher=<span class="hljs-string">&#x27;Prentice Hall&#x27;</span>,<br>              length=<span class="hljs-number">228</span>, publication_date=<span class="hljs-string">&#x27;1978-02-22&#x27;</span>, tags=(<span class="hljs-string">&#x27;C&#x27;</span>, <span class="hljs-string">&#x27;programming&#x27;</span>, <span class="hljs-string">&#x27;algorithms&#x27;</span>, <span class="hljs-string">&#x27;data structures&#x27;</span>))<br><br>    prototype = Prototype()<br>    cid = <span class="hljs-string">&#x27;k&amp;r-first&#x27;</span><br>    prototype.register(cid, b1)<br>    b2 = prototype.clone(cid, name=<span class="hljs-string">&#x27;The C Programming Language(ANSI)&#x27;</span>, price=<span class="hljs-number">48.99</span>,<br>                         length=<span class="hljs-number">274</span>, publication_date=<span class="hljs-string">&#x27;1988-04-01&#x27;</span>, edition=<span class="hljs-number">2</span>)<br><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> (b1, b2):<br>        print(i)<br>    print(<span class="hljs-string">&#x27;ID b1 : &#123;&#125; != ID b2 : &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">id</span>(b1), <span class="hljs-built_in">id</span>(b2)))<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    main()<br><br></code></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h2><h3 id="适配器模式（-）"><a href="#适配器模式（-）" class="headerlink" title="适配器模式（*）"></a>适配器模式（*）</h3><p>适配器模式就像是苹果最近出的macbook和iphone8他们的接口使得线无法一起使用，这时，他们就造出了接口转换器，又能多赚点钱了，美滋滋。比如之前有个已经做好的项目了，现在想把另外一个写好的代码当做组件融入项目里，但由于之前没有规划好，这时候就要运用适配器模式，写个适配代码，让这段代码能在项目中运行。但这个时候要遵守2个原则：</p>
<ul>
<li>不要求访问他方接口的源代码</li>
<li>不违反开放/封闭原则</li>
</ul>
<blockquote>
<p>适配器模式（Adapter pattern）是一种结构型设计模式，帮助我们实现两个不兼容接口之间的兼容。首先，解释一下不兼容接口的真正含义。如果我们希望把一个老组件用于一个新系统中，或者把一个新组件用于一个老系统中，不对代码进行任何修改两者就能够通信的情况很少见。但又并非总是能修改代码，或因为我们无法访问这些代码（例如，组件以外部库的方式提供），或因为修改代码本身就不切实际。在这些情况下，我们可以编写一个额外的代码层，该代码层包含让两个接口之间能够通信需要进行的所有修改。这个代码层就叫适配器</p>
</blockquote>
<p>示例代码如下(来自于《精通python设计模式》)：<br>第二部分是组件，第一部分的Adapter为适配器，适配器使用字典进行封装，虽然执行了execute方法，但在Synthesizer和Human中，对应执行的却是play和speak，但客户端不care这些，客户端仅知道如何调用execute()方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> external <span class="hljs-keyword">import</span> Synthesizer, Human<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Computer</span>:</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, name</span>):</span><br>        self.name = name<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__str__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;the &#123;&#125; computer&#x27;</span>.<span class="hljs-built_in">format</span>(self.name)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">execute</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;executes a program&#x27;</span><br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Adapter</span>:</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, obj, adapted_methods</span>):</span><br>        self.obj = obj<br>        self.__dict__.update(adapted_methods)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__str__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">str</span>(self.obj)<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    objects = [Computer(<span class="hljs-string">&#x27;Asus&#x27;</span>)]<br>    synth = Synthesizer(<span class="hljs-string">&#x27;moog&#x27;</span>)<br>    objects.append(Adapter(synth, <span class="hljs-built_in">dict</span>(execute=synth.play)))<br>    human = Human(<span class="hljs-string">&#x27;Bob&#x27;</span>)<br>    objects.append(Adapter(human, <span class="hljs-built_in">dict</span>(execute=human.speak)))<br><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> objects:<br>        print(<span class="hljs-string">&#x27;&#123;&#125; &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">str</span>(i), i.execute()))<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    main()<br><br></code></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Synthesizer</span>:</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, name</span>):</span><br>        self.name = name<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__str__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;the &#123;&#125; synthesizer&#x27;</span>.<span class="hljs-built_in">format</span>(self.name)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">play</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;is playing an electronic song&#x27;</span><br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Human</span>:</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, name</span>):</span><br>        self.name = name<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__str__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#123;&#125; the human&#x27;</span>.<span class="hljs-built_in">format</span>(self.name)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">speak</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;says hello&#x27;</span><br><br></code></pre></td></tr></table></figure>
<h3 id="修饰器模式（-）"><a href="#修饰器模式（-）" class="headerlink" title="修饰器模式（*）"></a>修饰器模式（*）</h3><p>修饰器模式和Python修饰器之间并不是一对一的等价关系</p>
<h4 id="修饰器模式"><a href="#修饰器模式" class="headerlink" title="修饰器模式"></a>修饰器模式</h4><p>修饰器就像单反/微单一样。一开始买来时，大家都会选择带上自带的狗头。如果要去拍人像的话，就会换上一个大光圈的定焦头。如果要取拍星星，打鸟，就会换上长焦距镜头。如果要拍微距的话，就可以换一个微距镜头。其中，机身为修饰器模式中要修饰的部分，而镜头就是修饰器。</p>
<blockquote>
<p>在许多编程语言中，使用子类化（继承）来实现修饰器模式在Python中，我们可以（并且应该）使用内置的修饰器特性。一个Python修饰器就是对Python语法的一个特定改变，用于扩展一个类、方法或函数的行为，而无需使用继承。从实现的角度来说，Python修饰器是一个可调用对象（函数、方法、类），接受一个函数对象fin作为输入，并返回另一 个函 数对象 fout。这意味着可以将任何具有这些属性的可调用对象当作一个修饰器。<br>最常见的python秀时期应该就是内置的，property修饰器让一个方法表现为一个变量。但是修饰器模式和Python修饰器之间并不是一对一的等价关系。 Python修饰器能做的实际上比修饰器模式多得多，其中之一就是实现修饰器模式</p>
</blockquote>
<p>这里的内容主要是我阅读完《python编程实战后整理的》<br>首先是原型函数，用来计算平均值的</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">mean</span>(<span class="hljs-params">first,second, *rest</span>):</span><br>    numbers = (first, second) + rest<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">sum</span>(numbers)/<span class="hljs-built_in">len</span>(numbers)<br></code></pre></td></tr></table></figure>
<p>还有一个修饰函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">float_args_and_return</span>(<span class="hljs-params">functiong</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">wrapper</span>(<span class="hljs-params">*args, **kwargs</span>):</span><br>        args = [<span class="hljs-built_in">float</span>(arg) <span class="hljs-keyword">for</span> arg <span class="hljs-keyword">in</span> args]<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">float</span>(function(*args, **kwargs))<br>    <span class="hljs-keyword">return</span> wrapper<br></code></pre></td></tr></table></figure>
<p>通过修饰器模式使用该语句就可以完成</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">mean = float_args_and_return(mean)<br></code></pre></td></tr></table></figure>
<p>在python中可以使用@语法糖来解决，由于在修饰函数中，使用这样的写法，那么修饰后的函数的__name__属性就和原函数不用了（变成了”wrapper”），而且即便原函数有docstring,修饰后的函数也不会有了。这时加上python标准库提供的@functools.wraps修饰器，我们就可以确保修改后的属性和名称与原函数相同<br>即代码如下：<br>可以发现str和int在修饰器后，都可以互相计算</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> functools<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">float_args_and_return</span>(<span class="hljs-params">function</span>):</span><br><span class="hljs-meta">    @functools.wraps(<span class="hljs-params">function</span>)</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">wrapper</span>(<span class="hljs-params">*args, **kwargs</span>):</span><br>        args = [<span class="hljs-built_in">float</span>(arg) <span class="hljs-keyword">for</span> arg <span class="hljs-keyword">in</span> args]<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">float</span>(function(*args, **kwargs))<br>    <span class="hljs-keyword">return</span> wrapper<br><br><span class="hljs-meta">@float_args_and_return</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">mean</span>(<span class="hljs-params">first,second, *rest</span>):</span><br>    numbers = (first, second) + rest<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">sum</span>(numbers)/<span class="hljs-built_in">len</span>(numbers)<br><br>print(mean(<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>))<br>print(mean(<span class="hljs-number">3</span>,<span class="hljs-string">&quot;4&quot;</span>,<span class="hljs-number">6</span>))<br></code></pre></td></tr></table></figure>
<h4 id="修饰器工厂"><a href="#修饰器工厂" class="headerlink" title="修饰器工厂"></a>修饰器工厂</h4><p>先看代码：<br>该例子只是用来描述python的灵活性以及创建修饰器工厂的可行性，实际中这样用不太python</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> functools<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">statically_typed</span>(<span class="hljs-params">*types, return_type=<span class="hljs-literal">None</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">decorator</span>(<span class="hljs-params">function</span>):</span><br><span class="hljs-meta">        @functools.wraps(<span class="hljs-params">function</span>)</span><br>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">wrapper</span>(<span class="hljs-params">*args, **kwargs</span>):</span><br>            <span class="hljs-comment">#判断传入参数是否超过定义的参数</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(args) &gt; <span class="hljs-built_in">len</span>(types):                                   <br>                <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&quot;too many arguments&quot;</span>)<br>            <span class="hljs-keyword">elif</span> <span class="hljs-built_in">len</span>(args) &lt; <span class="hljs-built_in">len</span>(types):<br>                <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&quot;too few arguments&quot;</span>)<br>            <span class="hljs-comment">#判断传入参数类型是否为指定参数类型</span><br>            <span class="hljs-keyword">for</span> i, (arg, type_) <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(<span class="hljs-built_in">zip</span>(args, types)):<br>                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">isinstance</span>(arg, type_):<br>                    <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&quot;argument &#123;&#125; must be of type &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(i, type_.__name__))<br>            <span class="hljs-comment">#返回的结果</span><br>            result = function(*args, **kwargs)<br>            <span class="hljs-comment">#判断是否指定返回参数类型以及返回的参数类型是否为制定的参数类型</span><br>            <span class="hljs-keyword">if</span>(return_type <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">isinstance</span>(result, return_type)):<br>                <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&quot;return value must be of type &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(return_type.__name__))<br>            <span class="hljs-keyword">return</span> result<br>        <span class="hljs-keyword">return</span> wrapper<br>    <span class="hljs-keyword">return</span> decorator<br><br><span class="hljs-meta">@statically_typed(<span class="hljs-params"><span class="hljs-built_in">str</span>, <span class="hljs-built_in">str</span>, return_type=<span class="hljs-built_in">str</span></span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">make_tagged</span>(<span class="hljs-params">text, tag</span>):</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&lt;&#123;0&#125;&gt;&#123;1&#125;&lt;/&#123;0&#125;&gt;&quot;</span>.<span class="hljs-built_in">format</span>(tag, text)<br><span class="hljs-meta">@statically_typed(<span class="hljs-params"><span class="hljs-built_in">str</span>, <span class="hljs-built_in">int</span>, <span class="hljs-built_in">str</span></span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">repeat</span>(<span class="hljs-params">what, count, separator</span>):</span><br>    <span class="hljs-keyword">return</span>((what + separator) * count)[:-<span class="hljs-built_in">len</span>(separator)]<br><br>print(make_tagged(<span class="hljs-string">&quot;Aaa&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>))<br>print(repeat(<span class="hljs-string">&quot;3&quot;</span>, <span class="hljs-number">4</span>, <span class="hljs-string">&quot;6&quot;</span>))<br></code></pre></td></tr></table></figure>
<p>可以看出statically_typed()里面很乱很乱。。。。。<br>然而这个函数并不是修饰器，而是修饰器工厂，也就是一种能制作修饰器的函数。当想用一套模板来制造修饰器时。可以使用这种方法。<br>正如起名修饰器工厂，这里是遵循工程模式来创建修饰器函数的</p>
<h4 id="类修饰器"><a href="#类修饰器" class="headerlink" title="类修饰器"></a>类修饰器</h4><p>类修饰器，也就是对类的修饰器。<br>下面的例子是书的类，Book()的实习都要重复使用getter与setter.可以通过类修饰器来减少重复使用<br>代码如下：<br>不过要注意以下几点</p>
<ul>
<li>代码中，3个修饰器执行时，是从下往上执行</li>
<li>is_non_empty_str()，is_in_range()是用于验证的验证器</li>
<li>在修饰器ensure中传入的分别是实例需要的属性分别为名字，函数，和doc</li>
<li>decorator()中的getter是用来返回保存在私有atttribute的值也就是属性的名字，setter()中的setattr用来设置实例属性的值</li>
<li>而这两个则是通过decorator的setattr来绑定类的实例和实例的值</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> functools<br><span class="hljs-keyword">import</span> numbers<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">is_non_empty_str</span>(<span class="hljs-params">name, value</span>):</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">isinstance</span>(value, <span class="hljs-built_in">str</span>):<br>        <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&quot;&#123;&#125; must be of type str&quot;</span>.<span class="hljs-built_in">format</span>(name))<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">bool</span>(value):<br>        <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&quot;&#123;&#125; may not be empty&quot;</span>.<span class="hljs-built_in">format</span>(name))<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">is_in_range</span>(<span class="hljs-params">minimum=<span class="hljs-literal">None</span>, maximum=<span class="hljs-literal">None</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">is_in_range</span>(<span class="hljs-params">name, value</span>):</span><br>        <span class="hljs-comment">#numbers.Number用于确保该参数为数字</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">isinstance</span>(value, numbers.Number):<br>            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&quot;&#123;&#125; must be a number&quot;</span>.<span class="hljs-built_in">format</span>(name))<br>        <span class="hljs-keyword">if</span> minimum <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> value &lt; minimum:<br>            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&quot;&#123;&#125; &#123;&#125; is too small&quot;</span>.<span class="hljs-built_in">format</span>(name, value))<br>        <span class="hljs-keyword">if</span> maximum <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> value &gt; maximum:<br>            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&quot;&#123;&#125; &#123;&#125; is too big&quot;</span>.<span class="hljs-built_in">format</span>(name, value))<br>    <span class="hljs-keyword">return</span> is_in_range<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">ensure</span>(<span class="hljs-params">name, validate, doc=<span class="hljs-literal">None</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">decorator</span>(<span class="hljs-params">Class</span>):</span><br>        privateName = <span class="hljs-string">&quot;_&quot;</span> + name<br>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getter</span>(<span class="hljs-params">self</span>):</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">getattr</span>(self, privateName)<br>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">setter</span>(<span class="hljs-params">self, value</span>):</span><br>            validate(name, value)<br>            <span class="hljs-built_in">setattr</span>(self, privateName, value)<br>        <span class="hljs-built_in">setattr</span>(Class, name, <span class="hljs-built_in">property</span>(getter, setter, doc=doc))<br>        <span class="hljs-keyword">return</span> Class<br>    <span class="hljs-keyword">return</span> decorator<br><br><span class="hljs-meta">@ensure(<span class="hljs-params"><span class="hljs-string">&quot;title&quot;</span>, is_non_empty_str</span>)</span><br><span class="hljs-meta">@ensure(<span class="hljs-params"><span class="hljs-string">&quot;price&quot;</span>, is_in_range(<span class="hljs-params"><span class="hljs-number">1</span>, <span class="hljs-number">10000</span></span>)</span>)</span><br><span class="hljs-meta">@ensure(<span class="hljs-params"><span class="hljs-string">&quot;quantity&quot;</span>, is_in_range(<span class="hljs-params"><span class="hljs-number">0</span>, <span class="hljs-number">1000000</span></span>)</span>)</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Book</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, title,  price, quantity</span>):</span><br>        self.title = title<br>        self.price = price<br>        self.quantity = quantity<br><br><span class="hljs-meta">    @property</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">value</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> self.price * self.quantity<br><br>A = Book(<span class="hljs-string">&quot;english&quot;</span>,<span class="hljs-number">60</span>,<span class="hljs-number">3</span>)<br>print(A.value)       <span class="hljs-comment"># 180</span><br>print(A.price)       <span class="hljs-comment"># 60</span><br>print(A._title)      <span class="hljs-comment"># english</span><br></code></pre></td></tr></table></figure>

<p>优化后的代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> functools<br><span class="hljs-keyword">import</span> numbers<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">is_non_empty_str</span>(<span class="hljs-params">name, value</span>):</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">isinstance</span>(value, <span class="hljs-built_in">str</span>):<br>        <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&quot;&#123;&#125; must be of type str&quot;</span>.<span class="hljs-built_in">format</span>(name))<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">bool</span>(value):<br>        <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&quot;&#123;&#125; may not be empty&quot;</span>.<span class="hljs-built_in">format</span>(name))<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">is_in_range</span>(<span class="hljs-params">minimum=<span class="hljs-literal">None</span>, maximum=<span class="hljs-literal">None</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">is_in_range</span>(<span class="hljs-params">name, value</span>):</span><br>        <span class="hljs-comment">#numbers.Number用于确保该参数为数字</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">isinstance</span>(value, numbers.Number):<br>            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&quot;&#123;&#125; must be a number&quot;</span>.<span class="hljs-built_in">format</span>(name))<br>        <span class="hljs-keyword">if</span> minimum <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> value &lt; minimum:<br>            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&quot;&#123;&#125; &#123;&#125; is too small&quot;</span>.<span class="hljs-built_in">format</span>(name, value))<br>        <span class="hljs-keyword">if</span> maximum <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> value &gt; maximum:<br>            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&quot;&#123;&#125; &#123;&#125; is too big&quot;</span>.<span class="hljs-built_in">format</span>(name, value))<br>    <span class="hljs-keyword">return</span> is_in_range<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Ensure</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, validate, doc=<span class="hljs-literal">None</span></span>):</span><br>        self.validate = validate<br>        self.doc= doc<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">do_ensure</span>(<span class="hljs-params">Class</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">make_property</span>(<span class="hljs-params">name, attribute</span>):</span><br>        privateName = <span class="hljs-string">&quot;_&quot;</span> + name<br>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getter</span>(<span class="hljs-params">self</span>):</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">getattr</span>(self, privateName)<br>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">setter</span>(<span class="hljs-params">self, value</span>):</span><br>            attribute.validate(name, value)<br>            <span class="hljs-built_in">setattr</span>(self, privateName, value)<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">property</span>(getter, setter, doc=attribute.doc)<br>    <span class="hljs-keyword">for</span> name, attribute <span class="hljs-keyword">in</span> Class.__dict__.items():<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(attribute, Ensure):<br>            <span class="hljs-built_in">setattr</span>(Class, name, make_property(name, attribute))<br>    <span class="hljs-keyword">return</span> Class<br><br><span class="hljs-meta">@do_ensure</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">do_Book</span>:</span><br><br>    title = Ensure(is_non_empty_str)<br>    price = Ensure(is_in_range(<span class="hljs-number">1</span>, <span class="hljs-number">10000</span>))<br>    quantity = Ensure(is_in_range(<span class="hljs-number">0</span>, <span class="hljs-number">1000000</span>))<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, title,  price, quantity</span>):</span><br>        self.title = title<br>        self.price = price<br>        self.quantity = quantity<br><br><span class="hljs-meta">    @property</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">value</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> self.price * self.quantity<br><br><br>B = do_Book(<span class="hljs-string">&quot;english&quot;</span>,<span class="hljs-number">60</span>,<span class="hljs-number">3</span>)<br>print(B.value)<br>print(B.price)<br>print(B._title)<br><br></code></pre></td></tr></table></figure>

<h3 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h3><p>在客户端代码想要使用一个复杂系统但又不关心系统复杂性之时，外观模式是为复杂系统提供一个简单接口的理想方式。一台计算机是一个外观，因为当我们使用它时需要做的事情仅是按一个按钮来启动它；其余的所有硬件复杂性都用户无感知地交由BIOS、引导加载程序以及其他系统软件来处理。</p>
<p>示例代码如下(来自于《精通python设计模式》)： </p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># coding: utf-8</span><br><br><span class="hljs-keyword">from</span> enum <span class="hljs-keyword">import</span> Enum<br><span class="hljs-keyword">from</span> abc <span class="hljs-keyword">import</span> ABCMeta, abstractmethod<br><br>State = Enum(<span class="hljs-string">&#x27;State&#x27;</span>, <span class="hljs-string">&#x27;new running sleeping restart zombie&#x27;</span>)<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span>:</span><br>    <span class="hljs-keyword">pass</span><br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Process</span>:</span><br>    <span class="hljs-keyword">pass</span><br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">File</span>:</span><br>    <span class="hljs-keyword">pass</span><br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Server</span>(<span class="hljs-params">metaclass=ABCMeta</span>):</span><br><br><span class="hljs-meta">    @abstractmethod</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">pass</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__str__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> self.name<br><br><span class="hljs-meta">    @abstractmethod</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">boot</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">pass</span><br><br><span class="hljs-meta">    @abstractmethod</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">kill</span>(<span class="hljs-params">self, restart=<span class="hljs-literal">True</span></span>):</span><br>        <span class="hljs-keyword">pass</span><br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileServer</span>(<span class="hljs-params">Server</span>):</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-string">&#x27;&#x27;&#x27;初始化文件服务进程要求的操作&#x27;&#x27;&#x27;</span><br>        self.name = <span class="hljs-string">&#x27;FileServer&#x27;</span><br>        self.state = State.new<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">boot</span>(<span class="hljs-params">self</span>):</span><br>        print(<span class="hljs-string">&#x27;booting the &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(self))<br>        <span class="hljs-string">&#x27;&#x27;&#x27;启动文件服务进程要求的操作&#x27;&#x27;&#x27;</span><br>        self.state = State.running<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">kill</span>(<span class="hljs-params">self, restart=<span class="hljs-literal">True</span></span>):</span><br>        print(<span class="hljs-string">&#x27;Killing &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(self))<br>        <span class="hljs-string">&#x27;&#x27;&#x27;杀死文件服务进程要求的操作&#x27;&#x27;&#x27;</span><br>        self.state = State.restart <span class="hljs-keyword">if</span> restart <span class="hljs-keyword">else</span> State.zombie<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">create_file</span>(<span class="hljs-params">self, user, name, permissions</span>):</span><br>        <span class="hljs-string">&#x27;&#x27;&#x27;检查访问权限的有效性、用户权限，等等&#x27;&#x27;&#x27;</span><br><br>        print(<span class="hljs-string">&quot;trying to create the file &#x27;&#123;&#125;&#x27; for user &#x27;&#123;&#125;&#x27; with permissions &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(name, user, permissions))<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProcessServer</span>(<span class="hljs-params">Server</span>):</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-string">&#x27;&#x27;&#x27;初始化进程服务进程要求的操作&#x27;&#x27;&#x27;</span><br>        self.name = <span class="hljs-string">&#x27;ProcessServer&#x27;</span><br>        self.state = State.new<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">boot</span>(<span class="hljs-params">self</span>):</span><br>        print(<span class="hljs-string">&#x27;booting the &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(self))<br>        <span class="hljs-string">&#x27;&#x27;&#x27;启动进程服务进程要求的操作&#x27;&#x27;&#x27;</span><br>        self.state = State.running<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">kill</span>(<span class="hljs-params">self, restart=<span class="hljs-literal">True</span></span>):</span><br>        print(<span class="hljs-string">&#x27;Killing &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(self))<br>        <span class="hljs-string">&#x27;&#x27;&#x27;杀死进程服务进程要求的操作&#x27;&#x27;&#x27;</span><br>        self.state = State.restart <span class="hljs-keyword">if</span> restart <span class="hljs-keyword">else</span> State.zombie<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">create_process</span>(<span class="hljs-params">self, user, name</span>):</span><br>        <span class="hljs-string">&#x27;&#x27;&#x27;检查用户权限、生成PID，等等&#x27;&#x27;&#x27;</span><br><br>        print(<span class="hljs-string">&quot;trying to create the process &#x27;&#123;&#125;&#x27; for user &#x27;&#123;&#125;&#x27;&quot;</span>.<span class="hljs-built_in">format</span>(name, user))<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WindowServer</span>:</span><br>    <span class="hljs-keyword">pass</span><br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NetworkServer</span>:</span><br>    <span class="hljs-keyword">pass</span><br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OperatingSystem</span>:</span><br><br>    <span class="hljs-string">&#x27;&#x27;&#x27;外观&#x27;&#x27;&#x27;</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        self.fs = FileServer()<br>        self.ps = ProcessServer()<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">start</span>(<span class="hljs-params">self</span>):</span><br>        [i.boot() <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> (self.fs, self.ps)]<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">create_file</span>(<span class="hljs-params">self, user, name, permissions</span>):</span><br>        <span class="hljs-keyword">return</span> self.fs.create_file(user, name, permissions)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">create_process</span>(<span class="hljs-params">self, user, name</span>):</span><br>        <span class="hljs-keyword">return</span> self.ps.create_process(user, name)<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    os = OperatingSystem()<br>    os.start()<br>    os.create_file(<span class="hljs-string">&#x27;foo&#x27;</span>, <span class="hljs-string">&#x27;hello&#x27;</span>, <span class="hljs-string">&#x27;-rw-r-r&#x27;</span>)<br>    os.create_process(<span class="hljs-string">&#x27;bar&#x27;</span>, <span class="hljs-string">&#x27;ls /tmp&#x27;</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    main()<br><br></code></pre></td></tr></table></figure>
<h3 id="享元模式（-）"><a href="#享元模式（-）" class="headerlink" title="享元模式（*）"></a>享元模式（*）</h3><p>由于对象创建的开销，面向对象的系统可能会面临性能问题。所以有了享元模式，享元模式可以让多个单元一起共享同一个需要的数据。类似于玩游戏时，每个人其实都差不多，只是表情或者帽子等有差别，那些没差别的部位可以来自同一个对象，减少内存开销</p>
<p>示例代码如下(来自于《精通python设计模式》)：<br>代码中，通过__new__的方式和pool限制了只创建了三个对象，通过输出，可以看出虽然生产了30课树，但除了年龄，位置外，其余的属性都是这三个对象的其中一个</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># coding: utf-8</span><br><br><span class="hljs-keyword">import</span> random<br><span class="hljs-keyword">from</span> enum <span class="hljs-keyword">import</span> Enum<br><br>TreeType = Enum(<span class="hljs-string">&#x27;TreeType&#x27;</span>, <span class="hljs-string">&#x27;apple_tree cherry_tree peach_tree&#x27;</span>)<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Tree</span>:</span><br>    pool = <span class="hljs-built_in">dict</span>()<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__new__</span>(<span class="hljs-params">cls, tree_type</span>):</span><br>        obj = cls.pool.get(tree_type, <span class="hljs-literal">None</span>)<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> obj:<br>            obj = <span class="hljs-built_in">object</span>.__new__(cls)<br>            cls.pool[tree_type] = obj<br>            obj.tree_type = tree_type<br>        <span class="hljs-keyword">return</span> obj<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">render</span>(<span class="hljs-params">self, age, x, y</span>):</span><br>        print(<span class="hljs-string">&#x27;render a tree of type &#123;&#125; and age &#123;&#125; at (&#123;&#125;, &#123;&#125;)&#x27;</span>.<span class="hljs-built_in">format</span>(self.tree_type, age, x, y))<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    rnd = random.Random()<br>    age_min, age_max = <span class="hljs-number">1</span>, <span class="hljs-number">30</span>    <span class="hljs-comment"># 单位为年</span><br>    min_point, max_point = <span class="hljs-number">0</span>, <span class="hljs-number">100</span><br>    tree_counter = <span class="hljs-number">0</span><br><br>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):<br>        t1 = Tree(TreeType.apple_tree)<br>        t1.render(rnd.randint(age_min, age_max),<br>                  rnd.randint(min_point, max_point),<br>                  rnd.randint(min_point, max_point))<br>        tree_counter += <span class="hljs-number">1</span><br><br>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>):<br>        t2 = Tree(TreeType.cherry_tree)<br>        t2.render(rnd.randint(age_min, age_max),<br>                  rnd.randint(min_point, max_point),<br>                  rnd.randint(min_point, max_point))<br>        tree_counter += <span class="hljs-number">1</span><br><br>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>):<br>        t3 = Tree(TreeType.peach_tree)<br>        t3.render(rnd.randint(age_min, age_max),<br>                  rnd.randint(min_point, max_point),<br>                  rnd.randint(min_point, max_point))<br>        tree_counter += <span class="hljs-number">1</span><br><br>    print(<span class="hljs-string">&#x27;trees rendered: &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(tree_counter))<br>    print(<span class="hljs-string">&#x27;trees actually created: &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">len</span>(Tree.pool)))<br><br>    t4 = Tree(TreeType.cherry_tree)<br>    t5 = Tree(TreeType.cherry_tree)<br>    t6 = Tree(TreeType.apple_tree)<br>    print(<span class="hljs-string">&#x27;&#123;&#125; == &#123;&#125;? &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">id</span>(t4), <span class="hljs-built_in">id</span>(t5), <span class="hljs-built_in">id</span>(t4) == <span class="hljs-built_in">id</span>(t5)))<br>    print(<span class="hljs-string">&#x27;&#123;&#125; == &#123;&#125;? &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">id</span>(t5), <span class="hljs-built_in">id</span>(t6), <span class="hljs-built_in">id</span>(t5) == <span class="hljs-built_in">id</span>(t6)))<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    main()<br><br></code></pre></td></tr></table></figure>
<h3 id="模型-视图-控制器模式（-）"><a href="#模型-视图-控制器模式（-）" class="headerlink" title="模型-视图-控制器模式（*）"></a>模型-视图-控制器模式（*）</h3><p>MVC模式要是有接触到ui的几乎都见过。该模式通过分层设计，把视图和模型分开，再通过控制器把他们联系起来，但视图和模型可以互相不用知道对方如何工作。<br>例如在Django中，view+url为C，model为m，template为V，MVC运行方式如下：</p>
<ul>
<li><p>用户通过单击（键入、触摸等）某个按钮触发一个视图</p>
</li>
<li><p>视图把用户操作告知控制器</p>
</li>
<li><p>控制器处理用户输入，并与模型交互</p>
</li>
<li><p>模型执行所有必要的校验和状态改变，并通知控制器应该做什么</p>
</li>
<li><p>控制器按照模型给出的指令，指导视图适当地更新和显示输出</p>
<Br/>
MVC模式有3个好处</li>
<li><p>视图与模型的分离允许美工一心搞UI部分，程序员一心搞开发，不会相互干扰。</p>
</li>
<li><p>由于视图与模型之间的松耦合，每个部分可以单独修改/扩展，不会相互影响。例如，添加一个新视图的成本很小，只要为其实现一个控制器就可以了。</p>
</li>
<li><p>因为职责明晰，维护每个部分也更简单</p>
<Br/>
创建MVC时要确保：模型很智能，控制器很瘦，视图很傻瓜</li>
<li><p>智能模型</p>
<ul>
<li>包含所有的校验/业务规则/逻辑</li>
<li>处理应用的状态</li>
<li>访问应用数据（数据库、云或其他）</li>
<li>不依赖UI<Br/></li>
</ul>
</li>
<li><p>瘦控制器</p>
<ul>
<li>在用户与视图交互时，更新模型</li>
<li>在模型改变时，更新视图</li>
<li>如果需要，在数据传递给模型/视图之前进行处理</li>
<li>不展示数据</li>
<li>不直接访问应用数据</li>
<li>不包含校验/业务规则/逻辑<Br/></li>
</ul>
</li>
<li><p>傻瓜视图</p>
<ul>
<li>展示数据</li>
<li>允许用户与其交互</li>
<li>仅做最小的数据处理，通常由一种模板语言提供处理能力（例如，使用简单的变量和循环控制）</li>
<li>不存储任何数据</li>
<li>不直接访问应用数据</li>
<li>不包含校验/业务规则/逻辑</li>
</ul>
</li>
</ul>
<p>示例代码如下(来自于《精通python设计模式》)：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">quotes = (<span class="hljs-string">&#x27;A man is not complete until he is married. Then he is finished.&#x27;</span>,<br>          <span class="hljs-string">&#x27;As I said before, I never repeat myself.&#x27;</span>,<br>          <span class="hljs-string">&#x27;Behind a successful man is an exhausted woman.&#x27;</span>,<br>          <span class="hljs-string">&#x27;Black holes really suck...&#x27;</span>, <span class="hljs-string">&#x27;Facts are stubborn things.&#x27;</span>)<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">QuoteModel</span>:</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_quote</span>(<span class="hljs-params">self, n</span>):</span><br>        <span class="hljs-keyword">try</span>:<br>            value = quotes[n]<br>        <span class="hljs-keyword">except</span> IndexError <span class="hljs-keyword">as</span> err:<br>            value = <span class="hljs-string">&#x27;Not found!&#x27;</span><br>        <span class="hljs-keyword">return</span> value<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">QuoteTerminalView</span>:</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show</span>(<span class="hljs-params">self, quote</span>):</span><br>        print(<span class="hljs-string">&#x27;And the quote is: &quot;&#123;&#125;&quot;&#x27;</span>.<span class="hljs-built_in">format</span>(quote))<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">error</span>(<span class="hljs-params">self, msg</span>):</span><br>        print(<span class="hljs-string">&#x27;Error: &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(msg))<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">select_quote</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;Which quote number would you like to see?&#x27;</span>)<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">QuoteTerminalController</span>:</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        self.model = QuoteModel()<br>        self.view = QuoteTerminalView()<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span>(<span class="hljs-params">self</span>):</span><br>        valid_input = <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">while</span> <span class="hljs-keyword">not</span> valid_input:<br>            n = self.view.select_quote()<br>            <span class="hljs-keyword">try</span>:<br>                n = <span class="hljs-built_in">int</span>(n)<br>            <span class="hljs-keyword">except</span> ValueError <span class="hljs-keyword">as</span> err:<br>                self.view.error(<span class="hljs-string">&quot;Incorrect index &#x27;&#123;&#125;&#x27;&quot;</span>.<span class="hljs-built_in">format</span>(n))<br>            <span class="hljs-keyword">else</span>:<br>                valid_input = <span class="hljs-literal">True</span><br>        quote = self.model.get_quote(n)<br>        self.view.show(quote)<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    controller = QuoteTerminalController()<br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        controller.run()<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    main()<br><br></code></pre></td></tr></table></figure>
<h3 id="代理模式（-）"><a href="#代理模式（-）" class="headerlink" title="代理模式（*）"></a>代理模式（*）</h3><p>代理，就是把这个步骤交给其他的去做，然后返回结果。代理模式有很多种：</p>
<ul>
<li>远程代理：实际存在于不同地址空间（例如，某个网络服务器）的对象在本地的代理者。</li>
<li>虚拟代理：用于懒初始化，将一个大计算量对象的创建延迟到真正需要的时候进行。</li>
<li>保护/防护代理：控制对敏感对象的访问。</li>
<li>智能（引用）代理：在对象被访问时执行额外的动作。此类代理的例子包括引用计数和线程安全检查。<Br/>
虚拟代理的应用：
示例代码如下(来自于《精通python设计模式》)：
通过LazyProperty修饰器来达到代理。可以通过输出来理解
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># coding: utf-8</span><br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LazyProperty</span>:</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, method</span>):</span><br>        self.method = method<br>        self.method_name = method.__name__<br>        print(<span class="hljs-string">&#x27;function overriden: &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(self.method))<br>        print(<span class="hljs-string">&quot;function&#x27;s name: &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(self.method_name))<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__get__</span>(<span class="hljs-params">self, obj, cls</span>):</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> obj:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>        value = self.method(obj)<br>        print(<span class="hljs-string">&#x27;value &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(value))<br>        <span class="hljs-built_in">setattr</span>(obj, self.method_name, value)<br>        <span class="hljs-keyword">return</span> value<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span>:</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        self.x = <span class="hljs-string">&#x27;foo&#x27;</span><br>        self.y = <span class="hljs-string">&#x27;bar&#x27;</span><br>        self._resource = <span class="hljs-literal">None</span><br><br><span class="hljs-meta">    @LazyProperty</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">resource</span>(<span class="hljs-params">self</span>):</span><br>        print(<span class="hljs-string">&#x27;initializing self._resource which is: &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(self._resource))<br>        self._resource = <span class="hljs-built_in">tuple</span>(<span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>))    <span class="hljs-comment"># 代价大的</span><br>        <span class="hljs-keyword">return</span> self._resource<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    t = Test()<br>    print(t.x)<br>    print(t.y)<br>    <span class="hljs-comment"># 做更多的事情。。。</span><br>    print(t.resource)<br>    print(t.resource)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    main()<br></code></pre></td></tr></table></figure>
输出部分：
可以从输出部分看到t = Test()时，代理修饰器已经运行了。
第一个print(t.resource) 开始加载，当来到
LazyProperty的value = self.method(obj)语句时，调用到了Text的resource(self)，开始生成数值，取代原先的None并返回给代理。代理使用setattr把数据与method_name绑定，当再次调用print(t.resource)时，调用的是代理的method_name的数据，所以直接返回数据
总结的说，就是在第一次获取数据时，是获取到Test.resource的值（这时才刚加载），并把值存在代理的value里面（所以之后都不用加载Test.resource的值）。加载之后的每次调用，返回的都是代理的value(包括第一调用时返回的值)
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">function overriden: &lt;function Test.resource at <span class="hljs-number">0x7fad622c4d90</span>&gt;<br>function<span class="hljs-string">&#x27;s name: resource</span><br><span class="hljs-string">foo</span><br><span class="hljs-string">bar</span><br><span class="hljs-string">initializing self._resource which is: None</span><br><span class="hljs-string">value (0, 1, 2, 3, 4)</span><br><span class="hljs-string">(0, 1, 2, 3, 4)</span><br><span class="hljs-string">(0, 1, 2, 3, 4)</span><br></code></pre></td></tr></table></figure>
防护代理的应用：
示例代码如下(来自于《精通python设计模式》)：
注：密码不应该明文出现在代码里面，以下代码仅为示例所需
可以从代码看出Info类仅是个代理，调用的数据还是来自于SensitiveInfo类，不过info类多了个密码验证功能，如果不能验证成功，就不会访问到SensitiveInfo类的数据。从而利用代理达到防护数据被窃取的可能
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># coding: utf-8</span><br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SensitiveInfo</span>:</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        self.users = [<span class="hljs-string">&#x27;nick&#x27;</span>, <span class="hljs-string">&#x27;tom&#x27;</span>, <span class="hljs-string">&#x27;ben&#x27;</span>, <span class="hljs-string">&#x27;mike&#x27;</span>]<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">read</span>(<span class="hljs-params">self</span>):</span><br>        print(<span class="hljs-string">&#x27;There are &#123;&#125; users: &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">len</span>(self.users), <span class="hljs-string">&#x27; &#x27;</span>.join(self.users)))<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span>(<span class="hljs-params">self, user</span>):</span><br>        self.users.append(user)<br>        print(<span class="hljs-string">&#x27;Added user &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(user))<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Info</span>:</span><br><br>    <span class="hljs-string">&#x27;&#x27;&#x27;SensitiveInfo的保护代理&#x27;&#x27;&#x27;</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        self.protected = SensitiveInfo()<br>        self.secret = <span class="hljs-string">&#x27;0xdeadbeef&#x27;</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">read</span>(<span class="hljs-params">self</span>):</span><br>        self.protected.read()<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span>(<span class="hljs-params">self, user</span>):</span><br>        sec = <span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;what is the secret? &#x27;</span>)<br>        self.protected.add(user) <span class="hljs-keyword">if</span> sec == self.secret <span class="hljs-keyword">else</span> print(<span class="hljs-string">&quot;That&#x27;s wrong!&quot;</span>)<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    info = Info()<br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        print(<span class="hljs-string">&#x27;1. read list |==| 2. add user |==| 3. quit&#x27;</span>)<br>        key = <span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;choose option: &#x27;</span>)<br>        <span class="hljs-keyword">if</span> key == <span class="hljs-string">&#x27;1&#x27;</span>:<br>            info.read()<br>        <span class="hljs-keyword">elif</span> key == <span class="hljs-string">&#x27;2&#x27;</span>:<br>            name = <span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;choose username: &#x27;</span>)<br>            info.add(name)<br>        <span class="hljs-keyword">elif</span> key == <span class="hljs-string">&#x27;3&#x27;</span>:<br>            exit()<br>        <span class="hljs-keyword">else</span>:<br>            print(<span class="hljs-string">&#x27;unknown option: &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(key))<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    main()<br><br></code></pre></td></tr></table></figure>
## 行为型模式
### 责任链模式
责任链模式就像广播网络一样，一台机器发出一个广播，同个本地局域网的其他主机就会开始接收，如果这个数据是自己可以用的，就给自己执行，如果不是就丢给下一个主机。
就像python里面的if....elif...elif....else（我认为这就是责任链模式。。这是我搜索时没有答案可以验证我的这个认为）
>其原则如下所示。
(1) 存在一个对象链（链表、树或任何其他便捷的数据结构）。
(2) 我们一开始将请求发送给链中的第一个对象。
(3) 对象决定其是否要处理该请求。
(4) 对象将请求转发给下一个对象。
(5) 重复该过程，直到到达链尾。

</li>
</ul>
<p>示例代码如下(来自于《精通python设计模式》)：<br>可以通过输出查看事件的显示</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Event</span>:</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, name</span>):</span><br>        self.name = name<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__str__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> self.name<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Widget</span>:</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, parent=<span class="hljs-literal">None</span></span>):</span><br>        self.parent = parent<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">handle</span>(<span class="hljs-params">self, event</span>):</span><br>        handler = <span class="hljs-string">&#x27;handle_&#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(event)<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">hasattr</span>(self, handler):<br>            method = <span class="hljs-built_in">getattr</span>(self, handler)<br>            method(event)<br>        <span class="hljs-keyword">elif</span> self.parent:<br>            self.parent.handle(event)<br>        <span class="hljs-keyword">elif</span> <span class="hljs-built_in">hasattr</span>(self, <span class="hljs-string">&#x27;handle_default&#x27;</span>):<br>            self.handle_default(event)<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainWindow</span>(<span class="hljs-params">Widget</span>):</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">handle_close</span>(<span class="hljs-params">self, event</span>):</span><br>        print(<span class="hljs-string">&#x27;MainWindow: &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(event))<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">handle_default</span>(<span class="hljs-params">self, event</span>):</span><br>        print(<span class="hljs-string">&#x27;MainWindow Default: &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(event))<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SendDialog</span>(<span class="hljs-params">Widget</span>):</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">handle_paint</span>(<span class="hljs-params">self, event</span>):</span><br>        print(<span class="hljs-string">&#x27;SendDialog: &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(event))<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MsgText</span>(<span class="hljs-params">Widget</span>):</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">handle_down</span>(<span class="hljs-params">self, event</span>):</span><br>        print(<span class="hljs-string">&#x27;MsgText: &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(event))<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    mw = MainWindow()<br>    sd = SendDialog(mw)<br>    msg = MsgText(sd)<br><br>    <span class="hljs-keyword">for</span> e <span class="hljs-keyword">in</span> (<span class="hljs-string">&#x27;down&#x27;</span>, <span class="hljs-string">&#x27;paint&#x27;</span>, <span class="hljs-string">&#x27;unhandled&#x27;</span>, <span class="hljs-string">&#x27;close&#x27;</span>):<br>        evt = Event(e)<br>        print(<span class="hljs-string">&#x27;\nSending event -&#123;&#125;- to MainWindow&#x27;</span>.<span class="hljs-built_in">format</span>(evt))<br>        mw.handle(evt)<br>        print(<span class="hljs-string">&#x27;Sending event -&#123;&#125;- to SendDialog&#x27;</span>.<span class="hljs-built_in">format</span>(evt))<br>        sd.handle(evt)<br>        print(<span class="hljs-string">&#x27;Sending event -&#123;&#125;- to MsgText&#x27;</span>.<span class="hljs-built_in">format</span>(evt))<br>        msg.handle(evt)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    main()<br><br></code></pre></td></tr></table></figure>
<h3 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h3><p>命令模式就是通过封装，使代码能够通过一些选项终端运行不一样的功能</p>
<p>示例代码如下(来自于《精通python设计模式》)：<br>通过命令来打开文件</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br><br>verbose = <span class="hljs-literal">True</span><br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RenameFile</span>:</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, path_src, path_dest</span>):</span><br>        self.src, self.dest = path_src, path_dest<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">execute</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">if</span> verbose:<br>            print(<span class="hljs-string">&quot;[renaming &#x27;&#123;&#125;&#x27; to &#x27;&#123;&#125;&#x27;]&quot;</span>.<span class="hljs-built_in">format</span>(self.src, self.dest))<br>        os.rename(self.src, self.dest)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">undo</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">if</span> verbose:<br>            print(<span class="hljs-string">&quot;[renaming &#x27;&#123;&#125;&#x27; back to &#x27;&#123;&#125;&#x27;]&quot;</span>.<span class="hljs-built_in">format</span>(self.dest, self.src))<br>        os.rename(self.dest, self.src)<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CreateFile</span>:</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, path, txt=<span class="hljs-string">&#x27;hello world\n&#x27;</span></span>):</span><br>        self.path, self.txt = path, txt<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">execute</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">if</span> verbose:<br>            print(<span class="hljs-string">&quot;[creating file &#x27;&#123;&#125;&#x27;]&quot;</span>.<span class="hljs-built_in">format</span>(self.path))<br>        <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(self.path, mode=<span class="hljs-string">&#x27;w&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>) <span class="hljs-keyword">as</span> out_file:<br>            out_file.write(self.txt)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">undo</span>(<span class="hljs-params">self</span>):</span><br>        delete_file(self.path)<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReadFile</span>:</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, path</span>):</span><br>        self.path = path<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">execute</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">if</span> verbose:<br>            print(<span class="hljs-string">&quot;[reading file &#x27;&#123;&#125;&#x27;]&quot;</span>.<span class="hljs-built_in">format</span>(self.path))<br>        <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(self.path, mode=<span class="hljs-string">&#x27;r&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>) <span class="hljs-keyword">as</span> in_file:<br>            print(in_file.read(), end=<span class="hljs-string">&#x27;&#x27;</span>)<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">delete_file</span>(<span class="hljs-params">path</span>):</span><br>    <span class="hljs-keyword">if</span> verbose:<br>        print(<span class="hljs-string">&quot;deleting file &#x27;&#123;&#125;&#x27;&quot;</span>.<span class="hljs-built_in">format</span>(path))<br>    os.remove(path)<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    orig_name, new_name = <span class="hljs-string">&#x27;file1&#x27;</span>, <span class="hljs-string">&#x27;file2&#x27;</span><br><br>    commands = []<br>    <span class="hljs-keyword">for</span> cmd <span class="hljs-keyword">in</span> CreateFile(orig_name), ReadFile(orig_name), RenameFile(orig_name, new_name):<br>        commands.append(cmd)<br><br>    [c.execute() <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> commands]<br><br>    answer = <span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;reverse the executed commands? [y/n] &#x27;</span>)<br><br>    <span class="hljs-keyword">if</span> answer <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> <span class="hljs-string">&#x27;yY&#x27;</span>:<br>        print(<span class="hljs-string">&quot;the result is &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(new_name))<br>        exit()<br><br>    <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> <span class="hljs-built_in">reversed</span>(commands):<br>        <span class="hljs-keyword">try</span>:<br>            c.undo()<br>        <span class="hljs-keyword">except</span> AttributeError <span class="hljs-keyword">as</span> e:<br>            <span class="hljs-keyword">pass</span><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    main()<br><br></code></pre></td></tr></table></figure>
<h3 id="解释器模式"><a href="#解释器模式" class="headerlink" title="解释器模式"></a>解释器模式</h3><p>封装自己写好的代码，操作者通过命令来调用代码来完成自己想要的操作就是解释器模式所提供的功能<br>很多应用都会提供命令模式，像A家的Ae，Pr，Ps等产品，让操作这个应用的人都能以自己的能力取更好的制作出自己的作品，python有很多命令操作工具包，通过封装能使操作的人按照命令来操作代码。<br>或者说，我们打开一个解释器在运行一段代码时，该解释器就是在利用解释器模式运行我们的代码<br>示例代码如下(来自于《精通python设计模式》)：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-comment"># coding: utf-8</span><br><br><span class="hljs-keyword">from</span> pyparsing <span class="hljs-keyword">import</span> Word, OneOrMore, Optional, Group, Suppress, alphanums<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Gate</span>:</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        self.is_open = <span class="hljs-literal">False</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__str__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;open&#x27;</span> <span class="hljs-keyword">if</span> self.is_open <span class="hljs-keyword">else</span> <span class="hljs-string">&#x27;closed&#x27;</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">open</span>(<span class="hljs-params">self</span>):</span><br>        print(<span class="hljs-string">&#x27;opening the gate&#x27;</span>)<br>        self.is_open = <span class="hljs-literal">True</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">close</span>(<span class="hljs-params">self</span>):</span><br>        print(<span class="hljs-string">&#x27;closing the gate&#x27;</span>)<br>        self.is_open = <span class="hljs-literal">False</span><br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Garage</span>:</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        self.is_open = <span class="hljs-literal">False</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__str__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;open&#x27;</span> <span class="hljs-keyword">if</span> self.is_open <span class="hljs-keyword">else</span> <span class="hljs-string">&#x27;closed&#x27;</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">open</span>(<span class="hljs-params">self</span>):</span><br>        print(<span class="hljs-string">&#x27;opening the garage&#x27;</span>)<br>        self.is_open = <span class="hljs-literal">True</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">close</span>(<span class="hljs-params">self</span>):</span><br>        print(<span class="hljs-string">&#x27;closing the garage&#x27;</span>)<br>        self.is_open = <span class="hljs-literal">False</span><br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Aircondition</span>:</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        self.is_on = <span class="hljs-literal">False</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__str__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;on&#x27;</span> <span class="hljs-keyword">if</span> self.is_on <span class="hljs-keyword">else</span> <span class="hljs-string">&#x27;off&#x27;</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">turn_on</span>(<span class="hljs-params">self</span>):</span><br>        print(<span class="hljs-string">&#x27;turning on the aircondition&#x27;</span>)<br>        self.is_on = <span class="hljs-literal">True</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">turn_off</span>(<span class="hljs-params">self</span>):</span><br>        print(<span class="hljs-string">&#x27;turning off the aircondition&#x27;</span>)<br>        self.is_on = <span class="hljs-literal">False</span><br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Heating</span>:</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        self.is_on = <span class="hljs-literal">False</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__str__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;on&#x27;</span> <span class="hljs-keyword">if</span> self.is_on <span class="hljs-keyword">else</span> <span class="hljs-string">&#x27;off&#x27;</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">turn_on</span>(<span class="hljs-params">self</span>):</span><br>        print(<span class="hljs-string">&#x27;turning on the heating&#x27;</span>)<br>        self.is_on = <span class="hljs-literal">True</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">turn_off</span>(<span class="hljs-params">self</span>):</span><br>        print(<span class="hljs-string">&#x27;turning off the heating&#x27;</span>)<br>        self.is_on = <span class="hljs-literal">False</span><br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Boiler</span>:</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        self.temperature = <span class="hljs-number">83</span>  <span class="hljs-comment"># in celsius</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__str__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;boiler temperature: &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(self.temperature)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">increase_temperature</span>(<span class="hljs-params">self, amount</span>):</span><br>        print(<span class="hljs-string">&quot;increasing the boiler&#x27;s temperature by &#123;&#125; degrees&quot;</span>.<span class="hljs-built_in">format</span>(amount))<br>        self.temperature += amount<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">decrease_temperature</span>(<span class="hljs-params">self, amount</span>):</span><br>        print(<span class="hljs-string">&quot;decreasing the boiler&#x27;s temperature by &#123;&#125; degrees&quot;</span>.<span class="hljs-built_in">format</span>(amount))<br>        self.temperature -= amount<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Fridge</span>:</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        self.temperature = <span class="hljs-number">2</span>  <span class="hljs-comment"># 单位为摄氏度</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__str__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;fridge temperature: &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(self.temperature)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">increase_temperature</span>(<span class="hljs-params">self, amount</span>):</span><br>        print(<span class="hljs-string">&quot;increasing the fridge&#x27;s temperature by &#123;&#125; degrees&quot;</span>.<span class="hljs-built_in">format</span>(amount))<br>        self.temperature += amount<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">decrease_temperature</span>(<span class="hljs-params">self, amount</span>):</span><br>        print(<span class="hljs-string">&quot;decreasing the fridge&#x27;s temperature by &#123;&#125; degrees&quot;</span>.<span class="hljs-built_in">format</span>(amount))<br>        self.temperature -= amount<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    word = Word(alphanums)<br>    command = Group(OneOrMore(word))<br>    token = Suppress(<span class="hljs-string">&quot;-&gt;&quot;</span>)<br>    device = Group(OneOrMore(word))<br>    argument = Group(OneOrMore(word))<br>    event = command + token + device + Optional(token + argument)<br><br>    gate = Gate()<br>    garage = Garage()<br>    airco = Aircondition()<br>    heating = Heating()<br>    boiler = Boiler()<br>    fridge = Fridge()<br><br>    tests = (<span class="hljs-string">&#x27;open -&gt; gate&#x27;</span>,<br>             <span class="hljs-string">&#x27;close -&gt; garage&#x27;</span>,<br>             <span class="hljs-string">&#x27;turn on -&gt; aircondition&#x27;</span>,<br>             <span class="hljs-string">&#x27;turn off -&gt; heating&#x27;</span>,<br>             <span class="hljs-string">&#x27;increase -&gt; boiler temperature -&gt; 5 degrees&#x27;</span>,<br>             <span class="hljs-string">&#x27;decrease -&gt; fridge temperature -&gt; 2 degrees&#x27;</span>)<br>    open_actions = &#123;<span class="hljs-string">&#x27;gate&#x27;</span>: gate.<span class="hljs-built_in">open</span>,<br>                    <span class="hljs-string">&#x27;garage&#x27;</span>: garage.<span class="hljs-built_in">open</span>,<br>                    <span class="hljs-string">&#x27;aircondition&#x27;</span>: airco.turn_on,<br>                    <span class="hljs-string">&#x27;heating&#x27;</span>: heating.turn_on,<br>                    <span class="hljs-string">&#x27;boiler temperature&#x27;</span>: boiler.increase_temperature,<br>                    <span class="hljs-string">&#x27;fridge temperature&#x27;</span>: fridge.increase_temperature&#125;<br>    close_actions = &#123;<span class="hljs-string">&#x27;gate&#x27;</span>: gate.close,<br>                     <span class="hljs-string">&#x27;garage&#x27;</span>: garage.close,<br>                     <span class="hljs-string">&#x27;aircondition&#x27;</span>: airco.turn_off,<br>                     <span class="hljs-string">&#x27;heating&#x27;</span>: heating.turn_off,<br>                     <span class="hljs-string">&#x27;boiler temperature&#x27;</span>: boiler.decrease_temperature,<br>                     <span class="hljs-string">&#x27;fridge temperature&#x27;</span>: fridge.decrease_temperature&#125;<br><br>    <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> tests:<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(event.parseString(t)) == <span class="hljs-number">2</span>:  <span class="hljs-comment"># 没有参数</span><br>            cmd, dev = event.parseString(t)<br>            cmd_str, dev_str = <span class="hljs-string">&#x27; &#x27;</span>.join(cmd), <span class="hljs-string">&#x27; &#x27;</span>.join(dev)<br>            <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;open&#x27;</span> <span class="hljs-keyword">in</span> cmd_str <span class="hljs-keyword">or</span> <span class="hljs-string">&#x27;turn on&#x27;</span> <span class="hljs-keyword">in</span> cmd_str:<br>                open_actions[dev_str]()<br>            <span class="hljs-keyword">elif</span> <span class="hljs-string">&#x27;close&#x27;</span> <span class="hljs-keyword">in</span> cmd_str <span class="hljs-keyword">or</span> <span class="hljs-string">&#x27;turn off&#x27;</span> <span class="hljs-keyword">in</span> cmd_str:<br>                close_actions[dev_str]()<br>        <span class="hljs-keyword">elif</span> <span class="hljs-built_in">len</span>(event.parseString(t)) == <span class="hljs-number">3</span>:  <span class="hljs-comment"># 有参数</span><br>            cmd, dev, arg = event.parseString(t)<br>            cmd_str, dev_str, arg_str = <span class="hljs-string">&#x27; &#x27;</span>.join(cmd), <span class="hljs-string">&#x27; &#x27;</span>.join(dev), <span class="hljs-string">&#x27; &#x27;</span>.join(arg)<br>            num_arg = <span class="hljs-number">0</span><br>            <span class="hljs-keyword">try</span>:<br>                num_arg = <span class="hljs-built_in">int</span>(arg_str.split()[<span class="hljs-number">0</span>])  <span class="hljs-comment"># 抽取数值部分</span><br>            <span class="hljs-keyword">except</span> ValueError <span class="hljs-keyword">as</span> err:<br>                print(<span class="hljs-string">&quot;expected number but got: &#x27;&#123;&#125;&#x27;&quot;</span>.<span class="hljs-built_in">format</span>(arg_str[<span class="hljs-number">0</span>]))<br>            <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;increase&#x27;</span> <span class="hljs-keyword">in</span> cmd_str <span class="hljs-keyword">and</span> num_arg &gt; <span class="hljs-number">0</span>:<br>                open_actions[dev_str](num_arg)<br>            <span class="hljs-keyword">elif</span> <span class="hljs-string">&#x27;decrease&#x27;</span> <span class="hljs-keyword">in</span> cmd_str <span class="hljs-keyword">and</span> num_arg &gt; <span class="hljs-number">0</span>:<br>                close_actions[dev_str](num_arg)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    main()<br><br></code></pre></td></tr></table></figure>
<h3 id="观察者模式（-）"><a href="#观察者模式（-）" class="headerlink" title="观察者模式（*）"></a>观察者模式（*）</h3><blockquote>
<p>有时，我们希望在一个对象的状态改变时更新另外一组对象。在MVC模式中有这样一个非常常见的例子，假设在两个视图（例如，一个饼图和一个电子表格）中使用同一个模型的数据，无论何时更改了模型，都需要更新两个视图。这就是观察者设计模式要处理的问题。观察者模式描述单个对象（发布者，又称为主持者或可观察者）与一个或多个对象（订阅者，又称为观察者）之间的发布—订阅关系。在MVC例子中，发布者是模型，订阅者是视图。然而，MVC并非是仅有的发布—订阅例子。信息聚合订阅（比如， RSS或Atom）是另一种例子。许多读者通常会使用一个信息聚合阅读器订阅信息流，每当增加一条新信息时，他们就能自动地获取到更新。观察者模式背后的思想等同于MVC和关注点分离原则背后的思想，即降低发布者与订阅者之间的耦合度，从而易于在运行时添加/删除订阅者。此外，发布者不关心它的订阅者是谁。它只是将通知发送给所有订阅者。</p>
</blockquote>
<p>观察者模式经常被用于社交网络，当用户关注的人更新文章时，社交网络使用事件驱动推送更新给用户<br>示例代码如下(来自于《精通python设计模式》)：<br>在输出中我们看到，添加额外的观察者，就会出现更多（相关的）输出；一个观察者被删除后，就再也不会被通知到。删除一个不存在的观察者或者两次添加相同的观察者。这都是通过Publisher类了来实行的</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Publisher</span>:</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        self.observers = []<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span>(<span class="hljs-params">self, observer</span>):</span><br>        <span class="hljs-keyword">if</span> observer <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> self.observers:<br>            self.observers.append(observer)<br>        <span class="hljs-keyword">else</span>:<br>            print(<span class="hljs-string">&#x27;Failed to add: &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(observer))<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">remove</span>(<span class="hljs-params">self, observer</span>):</span><br>        <span class="hljs-keyword">try</span>:<br>            self.observers.remove(observer)<br>        <span class="hljs-keyword">except</span> ValueError:<br>            print(<span class="hljs-string">&#x27;Failed to remove: &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(observer))<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">notify</span>(<span class="hljs-params">self</span>):</span><br>        [o.notify(self) <span class="hljs-keyword">for</span> o <span class="hljs-keyword">in</span> self.observers]<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DefaultFormatter</span>(<span class="hljs-params">Publisher</span>):</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, name</span>):</span><br>        Publisher.__init__(self)<br>        self.name = name<br>        self._data = <span class="hljs-number">0</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__str__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&#123;&#125;: &#x27;&#123;&#125;&#x27; has data = &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">type</span>(self).__name__, self.name, self._data)<br><br><span class="hljs-meta">    @property</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">data</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> self._data<br><br><span class="hljs-meta">    @data.setter</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">data</span>(<span class="hljs-params">self, new_value</span>):</span><br>        <span class="hljs-keyword">try</span>:<br>            self._data = <span class="hljs-built_in">int</span>(new_value)<br>        <span class="hljs-keyword">except</span> ValueError <span class="hljs-keyword">as</span> e:<br>            print(<span class="hljs-string">&#x27;Error: &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(e))<br>        <span class="hljs-keyword">else</span>:<br>            self.notify()<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HexFormatter</span>:</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">notify</span>(<span class="hljs-params">self, publisher</span>):</span><br>        print(<span class="hljs-string">&quot;&#123;&#125;: &#x27;&#123;&#125;&#x27; has now hex data = &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">type</span>(self).__name__,<br>                                                      publisher.name, <span class="hljs-built_in">hex</span>(publisher.data)))<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BinaryFormatter</span>:</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">notify</span>(<span class="hljs-params">self, publisher</span>):</span><br>        print(<span class="hljs-string">&quot;&#123;&#125;: &#x27;&#123;&#125;&#x27; has now bin data = &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">type</span>(self).__name__,<br>                                                      publisher.name, <span class="hljs-built_in">bin</span>(publisher.data)))<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    df = DefaultFormatter(<span class="hljs-string">&#x27;test1&#x27;</span>)<br>    print(df)<br><br>    print()<br>    hf = HexFormatter()<br>    df.add(hf)<br>    df.data = <span class="hljs-number">3</span><br>    print(df)<br><br>    print()<br>    bf = BinaryFormatter()<br>    df.add(bf)<br>    df.data = <span class="hljs-number">21</span><br>    print(df)<br><br>    print()<br>    df.remove(hf)<br>    df.data = <span class="hljs-number">40</span><br>    print(df)<br><br>    print()<br>    df.remove(hf)<br>    df.add(bf)<br>    df.data = <span class="hljs-string">&#x27;hello&#x27;</span><br>    print(df)<br><br>    print()<br>    df.data = <span class="hljs-number">15.8</span><br>    print(df)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    main()<br><br></code></pre></td></tr></table></figure>
<h3 id="状态模式（-）"><a href="#状态模式（-）" class="headerlink" title="状态模式（*）"></a>状态模式（*）</h3><blockquote>
<p>状态模式是一个或多个有限状态机（简称状态机）的实现，用于解决一个特定的软件工程问题。状态机是一个抽象机器，具有两个主要部分：状态和转换。状态是指一个系统的当前状况。一个状态机在任意时间点只会有一个激活状态。转换是指从当前状态到一个新状态的切换。在一个转换发生之前或之后通常会执行一个或多个动作。状态机可以使用状态图进行视觉上的展现。状态机用于解决许多计算机问题和非计算机问题，其中包括交通灯、停车计时器、硬件设计和编程语言解析等。我们也看到零食自动贩卖机是如何与状态机的工作方式相关联的。</p>
</blockquote>
<p>玩游戏时，我们可以经常看到状态模式，比如玩lol时，敌方有座防御塔，如果是你一个人走进去，你会被防御塔打，如果小兵先进去，你再进去时，防御塔会打小兵，如果敌方防御塔在范围内没监测到我方单位在里面，他就进入不攻击模式。<br>所以状态模式最重要的有两个点，一个是多个状态，第二是多个状态可以互相切换</p>
<p>示例代码如下(来自于《精通python设计模式》)：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> state_machine <span class="hljs-keyword">import</span> State, Event, acts_as_state_machine, after, before, InvalidStateTransition<br><br><br><span class="hljs-meta">@acts_as_state_machine</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Process</span>:</span><br>    created = State(initial=<span class="hljs-literal">True</span>)<br>    waiting = State()<br>    running = State()<br>    terminated = State()<br>    blocked = State()<br>    swapped_out_waiting = State()<br>    swapped_out_blocked = State()<br><br>    wait = Event(from_states=(created, running, blocked,<br>                              swapped_out_waiting), to_state=waiting)<br>    run = Event(from_states=waiting, to_state=running)<br>    terminate = Event(from_states=running, to_state=terminated)<br>    block = Event(from_states=(running, swapped_out_blocked),<br>                  to_state=blocked)<br>    swap_wait = Event(from_states=waiting, to_state=swapped_out_waiting)<br>    swap_block = Event(from_states=blocked, to_state=swapped_out_blocked)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, name</span>):</span><br>        self.name = name<br><br><span class="hljs-meta">    @after(<span class="hljs-params"><span class="hljs-string">&#x27;wait&#x27;</span></span>)</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">wait_info</span>(<span class="hljs-params">self</span>):</span><br>        print(<span class="hljs-string">&#x27;&#123;&#125; entered waiting mode&#x27;</span>.<span class="hljs-built_in">format</span>(self.name))<br><br><span class="hljs-meta">    @after(<span class="hljs-params"><span class="hljs-string">&#x27;run&#x27;</span></span>)</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run_info</span>(<span class="hljs-params">self</span>):</span><br>        print(<span class="hljs-string">&#x27;&#123;&#125; is running&#x27;</span>.<span class="hljs-built_in">format</span>(self.name))<br><br><span class="hljs-meta">    @before(<span class="hljs-params"><span class="hljs-string">&#x27;terminate&#x27;</span></span>)</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">terminate_info</span>(<span class="hljs-params">self</span>):</span><br>        print(<span class="hljs-string">&#x27;&#123;&#125; terminated&#x27;</span>.<span class="hljs-built_in">format</span>(self.name))<br><br><span class="hljs-meta">    @after(<span class="hljs-params"><span class="hljs-string">&#x27;block&#x27;</span></span>)</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">block_info</span>(<span class="hljs-params">self</span>):</span><br>        print(<span class="hljs-string">&#x27;&#123;&#125; is blocked&#x27;</span>.<span class="hljs-built_in">format</span>(self.name))<br><br><span class="hljs-meta">    @after(<span class="hljs-params"><span class="hljs-string">&#x27;swap_wait&#x27;</span></span>)</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">swap_wait_info</span>(<span class="hljs-params">self</span>):</span><br>        print(<span class="hljs-string">&#x27;&#123;&#125; is swapped out and waiting&#x27;</span>.<span class="hljs-built_in">format</span>(self.name))<br><br><span class="hljs-meta">    @after(<span class="hljs-params"><span class="hljs-string">&#x27;swap_block&#x27;</span></span>)</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">swap_block_info</span>(<span class="hljs-params">self</span>):</span><br>        print(<span class="hljs-string">&#x27;&#123;&#125; is swapped out and blocked&#x27;</span>.<span class="hljs-built_in">format</span>(self.name))<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">transition</span>(<span class="hljs-params">process, event, event_name</span>):</span><br>    <span class="hljs-keyword">try</span>:<br>        event()<br>    <span class="hljs-keyword">except</span> InvalidStateTransition <span class="hljs-keyword">as</span> err:<br>        print(<span class="hljs-string">&#x27;Error: transition of &#123;&#125; from &#123;&#125; to &#123;&#125; failed&#x27;</span>.<span class="hljs-built_in">format</span>(process.name,<br>                                                                    process.current_state, event_name))<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">state_info</span>(<span class="hljs-params">process</span>):</span><br>    print(<span class="hljs-string">&#x27;state of &#123;&#125;: &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(process.name, process.current_state))<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    RUNNING = <span class="hljs-string">&#x27;running&#x27;</span><br>    WAITING = <span class="hljs-string">&#x27;waiting&#x27;</span><br>    BLOCKED = <span class="hljs-string">&#x27;blocked&#x27;</span><br>    TERMINATED = <span class="hljs-string">&#x27;terminated&#x27;</span><br><br>    p1, p2 = Process(<span class="hljs-string">&#x27;process1&#x27;</span>), Process(<span class="hljs-string">&#x27;process2&#x27;</span>)<br>    [state_info(p) <span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> (p1, p2)]<br><br>    print()<br>    transition(p1, p1.wait, WAITING)<br>    transition(p2, p2.terminate, TERMINATED)<br>    [state_info(p) <span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> (p1, p2)]<br><br>    print()<br>    transition(p1, p1.run, RUNNING)<br>    transition(p2, p2.wait, WAITING)<br>    [state_info(p) <span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> (p1, p2)]<br><br>    print()<br>    transition(p2, p2.run, RUNNING)<br>    [state_info(p) <span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> (p1, p2)]<br><br>    print()<br>    [transition(p, p.block, BLOCKED) <span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> (p1, p2)]<br>    [state_info(p) <span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> (p1, p2)]<br><br>    print()<br>    [transition(p, p.terminate, TERMINATED) <span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> (p1, p2)]<br>    [state_info(p) <span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> (p1, p2)]<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    main()<br><br></code></pre></td></tr></table></figure>
<h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h3><p>策略模式，它最主要的特点是，可以把一系列（可互换的）算法封装起来，并根据用户需求来选择其中一种。例如python里面的sorted函数，根据key的不同，能按不同的方式排序。<br>我感觉是很多策略模式的集成于者？看后觉得是很多设计模式的都需要使用他，就像工厂模式里面，可以理解为根据用户选择不同的读取方式，把数据注入不同的工厂，再读取出来。（这里就不上代码了）</p>
<h3 id="模板模式-（-）"><a href="#模板模式-（-）" class="headerlink" title="模板模式 （*）"></a>模板模式 （*）</h3><p>这个模式在我写爬虫时就使用过了，但是我并不知道这叫模板模式。当时都思考了好久好久改了好多方案，包括用来效率比较差一点的if…elif…else的方法(这是由于其中一个网站的编码不一样导致我想用这种方法)。所以。。设计模式是之前的人归纳自己能提高自己写代码能力的方法，我们早点理解设计模式，就能少遇一些坑，也能更容易写出代码。</p>
<p>模板模式，就是几个函数的代码里面，只有小部分代码不同时。可以把这些函数的相同代码归为一个函数，根据不同的调用形成不同的原先的代码，旨在减少代码沉宇<br>以下代码来自于我的爬虫代码（修改于12月5日）：<br>其中url_parse就运用了模板模式通过传入的不同action之后就调用不同的数据清理函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> re<br><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">import</span> json<br><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">from</span> bs4 <span class="hljs-keyword">import</span> BeautifulSoup<br><span class="hljs-keyword">from</span> datetime <span class="hljs-keyword">import</span> datetime<br><span class="hljs-keyword">import</span> asyncio<br><span class="hljs-keyword">import</span> aiohttp<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">pinpaigongyu_58city</span>(<span class="hljs-params">soup,city,page=<span class="hljs-number">1</span></span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    数据来自58品牌公寓</span><br><span class="hljs-string">    url由于是移动端提取的，所以拼接为电脑端（我网页只运行为电脑端）</span><br><span class="hljs-string">    address+info_title后期拼接后，高德能找到对应的位置，准确率提高</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    print(<span class="hljs-string">&#x27;开始爬取58同城&#x27;</span>+city+<span class="hljs-string">&#x27;的信息，第&#x27;</span>+<span class="hljs-built_in">str</span>(page)+<span class="hljs-string">&#x27;页&#x27;</span>)<br>    house_info_list = soup.find_all(<span class="hljs-string">&quot;li&quot;</span>,&#123;<span class="hljs-string">&quot;class&quot;</span>:<span class="hljs-string">&quot;item&quot;</span>&#125;)<br>    pattern_58city = re.<span class="hljs-built_in">compile</span>(<span class="hljs-string">r&quot;%s(.+)&quot;</span> %city)<br>    <span class="hljs-keyword">for</span> house_info <span class="hljs-keyword">in</span> house_info_list:<br>        house_url = house_info.find(<span class="hljs-string">&quot;a&quot;</span>).get(<span class="hljs-string">&#x27;href&#x27;</span>)<br>        house_url = <span class="hljs-string">&#x27;http://&#x27;</span>+city+<span class="hljs-string">&#x27;.58.com&#x27;</span>+re.findall(pattern_58city, house_url)[<span class="hljs-number">0</span>]<br>        info_title = house_info.find(<span class="hljs-string">&quot;dt&quot;</span>,&#123;<span class="hljs-string">&quot;class&quot;</span>:<span class="hljs-string">&quot;info-title&quot;</span>&#125;).text.split(<span class="hljs-string">&quot;|&quot;</span>)[<span class="hljs-number">1</span>].split(<span class="hljs-string">&quot;-&quot;</span>)[<span class="hljs-number">0</span>].split(<span class="hljs-string">&quot;(&quot;</span>)[<span class="hljs-number">0</span>].strip()<br>        address = house_info.find(<span class="hljs-string">&quot;em&quot;</span>).text.strip()+info_title<br>        price = house_info.find(<span class="hljs-string">&quot;span&quot;</span>,&#123;<span class="hljs-string">&quot;class&quot;</span>:<span class="hljs-string">&quot;info-line2-price&quot;</span>&#125;).text.strip()<br>        price = re.findall(re.<span class="hljs-built_in">compile</span>(<span class="hljs-string">r&#x27;\d+&#x27;</span>),price)[<span class="hljs-number">0</span>]<br>        room_info = house_info.find(<span class="hljs-string">&quot;dd&quot;</span>,&#123;<span class="hljs-string">&quot;class&quot;</span>:<span class="hljs-string">&quot;room_icon&quot;</span>&#125;).text.split(<span class="hljs-string">&quot;\n&quot;</span>)[<span class="hljs-number">1</span>:-<span class="hljs-number">2</span>]<br>        room_info = <span class="hljs-string">&quot;,&quot;</span>.join(room_info)<br>        sql_data(house_url,address,info_title,price,room_info)<br>    print(<span class="hljs-string">&#x27;爬取了58同城&#x27;</span>+city+<span class="hljs-string">&#x27;的信息，第&#x27;</span>+<span class="hljs-built_in">str</span>(page)+<span class="hljs-string">&#x27;页&#x27;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">anjuke</span>(<span class="hljs-params">soup,city,page=<span class="hljs-number">1</span></span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    数据来自安居客，速度比较慢</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    print(<span class="hljs-string">&#x27;开始爬取安居客&#x27;</span>+city+<span class="hljs-string">&#x27;的信息，第&#x27;</span>+<span class="hljs-built_in">str</span>(page)+<span class="hljs-string">&#x27;页&#x27;</span>)<br>    house_info_list = soup.find_all(<span class="hljs-string">&quot;div&quot;</span>,&#123;<span class="hljs-string">&quot;class&quot;</span>:<span class="hljs-string">&quot;zu-itemmod&quot;</span>&#125;)<br>    <span class="hljs-keyword">for</span> house_info <span class="hljs-keyword">in</span> house_info_list:<br>        house_url = house_info.get(<span class="hljs-string">&#x27;link&#x27;</span>)<br>        address_info_title = house_info.find(<span class="hljs-string">&quot;address&quot;</span>,&#123;<span class="hljs-string">&quot;class&quot;</span>:<span class="hljs-string">&quot;details-item&quot;</span>&#125;).text.split(<span class="hljs-string">&quot;［&quot;</span>)<br>        address = address_info_title[<span class="hljs-number">1</span>].strip().rstrip(<span class="hljs-string">&#x27;］&#x27;</span>)<br>        info_title = address_info_title[<span class="hljs-number">0</span>].strip()<br>        price = house_info.find(<span class="hljs-string">&quot;strong&quot;</span>).text<br>        room_info = house_info.find(<span class="hljs-string">&quot;p&quot;</span>,&#123;<span class="hljs-string">&quot;class&quot;</span>:<span class="hljs-string">&quot;details-item tag&quot;</span>&#125;).text.split(<span class="hljs-string">&quot;|&quot;</span>)<br>        room_info = <span class="hljs-string">&quot;,&quot;</span>.join(room_info)<br>        print(house_url,address,info_title,price,room_info)<br>        sql_data(house_url,address,info_title,price,room_info)<br>    print(<span class="hljs-string">&#x27;爬取了安居客&#x27;</span>+city+<span class="hljs-string">&#x27;的信息，第&#x27;</span>+<span class="hljs-built_in">str</span>(page)+<span class="hljs-string">&#x27;页&#x27;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fang</span>(<span class="hljs-params">soup,city,page=<span class="hljs-number">1</span></span>):</span><br>    print(<span class="hljs-string">&#x27;开始爬取房天下&#x27;</span>+city+<span class="hljs-string">&#x27;的信息，第&#x27;</span>+<span class="hljs-built_in">str</span>(page)+<span class="hljs-string">&#x27;页&#x27;</span>)<br>    house_info_list = soup.find_all(<span class="hljs-string">&quot;dl&quot;</span>,&#123;<span class="hljs-string">&quot;class&quot;</span>:<span class="hljs-string">&quot;list hiddenMap rel&quot;</span>&#125;)<br>    <span class="hljs-keyword">for</span> house_info <span class="hljs-keyword">in</span> house_info_list:<br>        house_url = <span class="hljs-string">&#x27;http://zu.&#x27;</span>+city+<span class="hljs-string">&#x27;.fang.com&#x27;</span>+house_info.find(<span class="hljs-string">&quot;a&quot;</span>,&#123;<span class="hljs-string">&quot;target&quot;</span>:<span class="hljs-string">&quot;_blank&quot;</span>&#125;).get(<span class="hljs-string">&#x27;href&#x27;</span>)<br>        address = house_info.find(<span class="hljs-string">&quot;p&quot;</span>,&#123;<span class="hljs-string">&quot;class&quot;</span>:<span class="hljs-string">&quot;gray6 mt20&quot;</span>&#125;).text<br>        info_title = address.split(<span class="hljs-string">&quot;-&quot;</span>)[-<span class="hljs-number">1</span>].strip()<br>        price = house_info.find(<span class="hljs-string">&quot;span&quot;</span>,&#123;<span class="hljs-string">&quot;class&quot;</span>:<span class="hljs-string">&quot;price&quot;</span>&#125;).text<br>        <span class="hljs-keyword">try</span>:<br>            room_info = (house_info.find(<span class="hljs-string">&quot;span&quot;</span>,&#123;<span class="hljs-string">&quot;class&quot;</span>:<span class="hljs-string">&quot;note colorGreen&quot;</span>&#125;).text<br>                        +<span class="hljs-string">&#x27;-&#x27;</span>+house_info.find(<span class="hljs-string">&quot;span&quot;</span>,&#123;<span class="hljs-string">&quot;class&quot;</span>:<span class="hljs-string">&quot;note colorBlue&quot;</span>&#125;).text<br>                        +<span class="hljs-string">&#x27;-&#x27;</span>+house_info.find(<span class="hljs-string">&quot;span&quot;</span>,&#123;<span class="hljs-string">&quot;class&quot;</span>:<span class="hljs-string">&quot;note colorRed&quot;</span>&#125;).text).strip()<br>        <span class="hljs-keyword">except</span>:<br>            room_info = <span class="hljs-string">&#x27;没有房间具体信息&#x27;</span><br>        sql_data(house_url,address,info_title,price,room_info)<br>    print(<span class="hljs-string">&#x27;爬取了房天下&#x27;</span>+city+<span class="hljs-string">&#x27;的信息，第&#x27;</span>+<span class="hljs-built_in">str</span>(page)+<span class="hljs-string">&#x27;页&#x27;</span>)<br><br><br><br><br><br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sql_data</span>(<span class="hljs-params">house_url,address,info_title,price,room_info</span>):</span><br>    <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    写入数据</span><br><span class="hljs-string">    &#x27;&#x27;&#x27;</span><br>    print(house_url+<span class="hljs-string">&#x27;|&#x27;</span>+address+<span class="hljs-string">&#x27;|&#x27;</span>+info_title+<span class="hljs-string">&#x27;|&#x27;</span>+price+<span class="hljs-string">&#x27;|&#x27;</span>+room_info)<br>    print(<span class="hljs-string">&#x27;--------&#x27;</span>)<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">url_parse</span>(<span class="hljs-params">url,city,page,action</span>):</span><br>    <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    解析网页，之后转入对应的函数进行数据清理</span><br><span class="hljs-string">    使用协程启动，对这两个库还没那么了解，之后再改动得好点</span><br><span class="hljs-string">    &#x27;&#x27;&#x27;</span><br>    headers=&#123;<span class="hljs-string">&#x27;User-Agent&#x27;</span>:<span class="hljs-string">&#x27;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36&#x27;</span>&#125;<br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> aiohttp.ClientSession() <span class="hljs-keyword">as</span> session:<br>        <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> session.get(url,headers=headers) <span class="hljs-keyword">as</span> resp:<br>            print(url, resp.status)<br>            <span class="hljs-keyword">if</span> resp.status == <span class="hljs-number">200</span>:<br>                <span class="hljs-keyword">try</span>:<br>                    soup = BeautifulSoup(<span class="hljs-keyword">await</span> resp.text(),<span class="hljs-string">&quot;html.parser&quot;</span>)<br>                <span class="hljs-keyword">except</span>:<br>                    soup = BeautifulSoup(<span class="hljs-keyword">await</span> resp.text(encoding=<span class="hljs-string">&#x27;gbk&#x27;</span>),<span class="hljs-string">&quot;html.parser&quot;</span>)<span class="hljs-comment">#网站差评，写了gb2312里面却有不是gb2312的符号</span><br>                action(soup,city,page)<br>            <span class="hljs-keyword">elif</span> url <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> url_temp_list:<br>                url_temp_list.append(url)<br>                url_parse(url,city,page) <span class="hljs-comment">#重新爬取一次</span><br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">return</span> (<span class="hljs-string">&quot;该url无法爬取:%s&quot;</span> % url)<br><br><br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br><br>    tasks = []                  <span class="hljs-comment">#协程启动的list</span><br>    url_temp_list = []          <span class="hljs-comment">#爬去失败暂存的url</span><br>    page_all = <span class="hljs-number">2</span>                <span class="hljs-comment">#爬取页数</span><br>    city_list = [<span class="hljs-string">&#x27;sz&#x27;</span>,<span class="hljs-string">&#x27;gz&#x27;</span>]     <span class="hljs-comment">#爬取的城市</span><br><br>    <span class="hljs-comment">#url列表，把url的城市换为city，页码换为page</span><br>    url_list = [<br>               [<span class="hljs-string">&#x27;http://m.58.com/city/pinpaigongyu/pnpage/?segment=true&#x27;</span>,pinpaigongyu_58city],<br>               [<span class="hljs-string">&#x27;https://city.zu.anjuke.com/fangyuan/ppage&#x27;</span>,anjuke],<br>               [<span class="hljs-string">&#x27;http://zu.city.fang.com/house/i3page&#x27;</span>,fang]<br>               ]<br><br>    <span class="hljs-comment">#生成tasks</span><br>    <span class="hljs-keyword">for</span> page <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(page_all):<br>        page = page+<span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> city <span class="hljs-keyword">in</span> city_list:<br>            <span class="hljs-keyword">for</span> url <span class="hljs-keyword">in</span> url_list:<br>                url_temp = url[<span class="hljs-number">0</span>].replace(<span class="hljs-string">&#x27;city&#x27;</span>,city)<br>                url_temp = url_temp.replace(<span class="hljs-string">&#x27;page&#x27;</span>,<span class="hljs-built_in">str</span>(page))<br>                tasks.append(url_parse(url_temp,city,page,url[<span class="hljs-number">1</span>]))<br><br>    start_time = time.time()<br>    loop = asyncio.get_event_loop()                 <span class="hljs-comment"># 得到一个事件循环模型</span><br>    loop.run_until_complete(asyncio.wait(tasks))    <span class="hljs-comment"># 执行任务</span><br>    loop.close()   <br><br>    end_time = time.time()<br>    print(end_time-start_time)<br></code></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>设计模式，是对编程的一个规范，各个设计模式之间会有许多相连，或者有很多共同的地方。就像我们在写代码时，可能一个代码就运用了很多设计模式，有时觉得能不能分清他们并不是最重要的，最重要的是如何使用他们，理解好他们，来提高我们的生产力。</p>
]]></content>
      <categories>
        <category>编程基础</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>学习笔记</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>python记录</title>
    <url>/2017/11/07/17_python_notes/</url>
    <content><![CDATA[<h2 id="前记"><a href="#前记" class="headerlink" title="前记"></a>前记</h2><p><a href="http://zh-google-styleguide.readthedocs.io/en/latest/google-python-styleguide/contents/">使用python风格写更好的代码</a><br>记录能提升编写代码能力的方法，以及其他一些小方法，方便日后查看了解</p>
<span id="more"></span>
<h2 id="Effective-Python部分"><a href="#Effective-Python部分" class="headerlink" title="Effective Python部分"></a>Effective Python部分</h2><p>由于书是在图书馆借的，不能划很难受，所以记下来</p>
<h3 id="EP9-用生成器表达式来改写数据量较大的列表推导（EP16考虑用生成器来改写直接返回列表的函数）"><a href="#EP9-用生成器表达式来改写数据量较大的列表推导（EP16考虑用生成器来改写直接返回列表的函数）" class="headerlink" title="EP9 用生成器表达式来改写数据量较大的列表推导（EP16考虑用生成器来改写直接返回列表的函数）"></a>EP9 用生成器表达式来改写数据量较大的列表推导（EP16考虑用生成器来改写直接返回列表的函数）</h3><p>当数据量不确定或者过大时，为了避免程序消耗大量内存而崩溃，可以使用生成器</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_movie_info_tpp</span>():</span><br>    <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    从淘票票从的正在上映获取电影的showid和电影名</span><br><span class="hljs-string">    执行</span><br><span class="hljs-string">    for i in get_movie_info_tpp():</span><br><span class="hljs-string">        print(i)</span><br><span class="hljs-string">    返回字典&#123;&#x27;name&#x27;: &#x27;猩球崛起3：终极之战&#x27;, &#x27;id&#x27;: [&#x27;179611&#x27;]&#125;</span><br><span class="hljs-string">    &#x27;&#x27;&#x27;</span><br>    url = <span class="hljs-string">&#x27;https://dianying.taobao.com/showList.htm&#x27;</span><br>    response = requests.get(url)<br>    soup = BeautifulSoup(response.text,<span class="hljs-string">&quot;html.parser&quot;</span>)<br>    showId_href_list = soup.find_all(<span class="hljs-string">&quot;a&quot;</span>,&#123;<span class="hljs-string">&quot;class&quot;</span>:<span class="hljs-string">&quot;movie-card&quot;</span>&#125;)<br>    pattern_id = re.<span class="hljs-built_in">compile</span>(<span class="hljs-string">r&#x27;\d+&#x27;</span>)<br>    <span class="hljs-keyword">for</span> showId_href <span class="hljs-keyword">in</span> showId_href_list:<br>        movie_card_href = showId_href.get(<span class="hljs-string">&#x27;href&#x27;</span>)<br>        get_showId = re.findall(pattern_id, movie_card_href)<br>        pattern_name = re.<span class="hljs-built_in">compile</span>(<span class="hljs-string">r&#x27;.+&#x27;</span>)<br>        get_movie_name = re.findall(pattern_name, showId_href.text)<br>        movie_tpp_dict = <span class="hljs-built_in">dict</span>(<span class="hljs-built_in">id</span>=get_showId, name=get_movie_name[<span class="hljs-number">0</span>])<br>        <span class="hljs-keyword">yield</span> movie_tpp_dict<br></code></pre></td></tr></table></figure>
<p>功能类似于</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_movie_info_tpp</span>():</span><br>    <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    从淘票票从的正在上映获取电影的showid和电影名</span><br><span class="hljs-string">    执行print(get_movie_info_tpp())</span><br><span class="hljs-string">    返回字典&#123;&#x27;name&#x27;: &#x27;猩球崛起3：终极之战&#x27;, &#x27;id&#x27;: [&#x27;179611&#x27;]&#125;</span><br><span class="hljs-string">    &#x27;&#x27;&#x27;</span><br>    url = <span class="hljs-string">&#x27;https://dianying.taobao.com/showList.htm&#x27;</span><br>    response = requests.get(url)<br>    soup = BeautifulSoup(response.text,<span class="hljs-string">&quot;html.parser&quot;</span>)<br>    showId_href_list = soup.find_all(<span class="hljs-string">&quot;a&quot;</span>,&#123;<span class="hljs-string">&quot;class&quot;</span>:<span class="hljs-string">&quot;movie-card&quot;</span>&#125;)<br>    pattern_id = re.<span class="hljs-built_in">compile</span>(<span class="hljs-string">r&#x27;\d+&#x27;</span>)<br>    movie_tpp_list = []<br>    <span class="hljs-keyword">for</span> showId_href <span class="hljs-keyword">in</span> showId_href_list:<br>        movie_card_href = showId_href.get(<span class="hljs-string">&#x27;href&#x27;</span>)<br>        get_showId = re.findall(pattern_id, movie_card_href)<br>        pattern_name = re.<span class="hljs-built_in">compile</span>(<span class="hljs-string">r&#x27;.+&#x27;</span>)<br>        get_movie_name = re.findall(pattern_name, showId_href.text)<br>        movie_tpp_dict = <span class="hljs-built_in">dict</span>(<span class="hljs-built_in">id</span>=get_showId, name=get_movie_name[<span class="hljs-number">0</span>])<br>        movie_tpp_list.append(movie_tpp_dict)<br>    <span class="hljs-keyword">return</span> movie_tpp_list<br></code></pre></td></tr></table></figure>
<h3 id="EP10-用enumerate取代range"><a href="#EP10-用enumerate取代range" class="headerlink" title="EP10 用enumerate取代range"></a>EP10 用enumerate取代range</h3><p>当需要获取到列表的下表时，可以改用这种写法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">list_1 = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>]<br><span class="hljs-keyword">for</span> i, flavor <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(list_1):<br>    print(<span class="hljs-string">&#x27;%d: %s&#x27;</span> %(i+<span class="hljs-number">1</span>, flavor))<br>&gt;&gt;&gt;<br><span class="hljs-number">1</span>:a<br><span class="hljs-number">2</span>:b<br></code></pre></td></tr></table></figure>
<h3 id="EP15-获取闭包内的数据"><a href="#EP15-获取闭包内的数据" class="headerlink" title="EP15 获取闭包内的数据"></a>EP15 获取闭包内的数据</h3><p>有些场合我们需要用到闭包，而在闭包里面会定义一个标志变量，返回调用者。python的语言设计防止函数中的局部变量污染函数外面的模块，此时应使用nonlocal语句</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#代码：两个list,numbers中的数字出现在group的话就排在前面</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sort_priority3</span>(<span class="hljs-params">numbers, group</span>):</span><br>    found = <span class="hljs-literal">False</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">helper</span>(<span class="hljs-params">x</span>):</span><br>        <span class="hljs-keyword">nonlocal</span> found<br>        <span class="hljs-keyword">if</span> x <span class="hljs-keyword">in</span> group:<br>            found = <span class="hljs-literal">True</span><br>            <span class="hljs-keyword">return</span> (<span class="hljs-number">0</span>,x)<br>        <span class="hljs-keyword">return</span> (<span class="hljs-number">1</span>,x)<br>    numbers.sort(key=helper)<br>    <span class="hljs-keyword">return</span> found<br></code></pre></td></tr></table></figure>
<h3 id="EP22-尽量用辅助类来维护程序状态"><a href="#EP22-尽量用辅助类来维护程序状态" class="headerlink" title="EP22　尽量用辅助类来维护程序状态"></a>EP22　尽量用辅助类来维护程序状态</h3><p>这些类的代码量可能比较多，但理解起来要容易许多，也容易拓展</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#编写表示科目的类，该类包含一系列考试成绩</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Subject</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        self._grades = []<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">report_grade</span>(<span class="hljs-params">self, score, weight</span>):</span><br>        self._grades.append(Grade(score, weight))<br>        <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">average_grade</span>(<span class="hljs-params">self</span>):</span><br>        total, total_weight = <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> grade <span class="hljs-keyword">in</span> self._grades:<br>            total += grade.score * grade.weight<br>            total_weight += grade.weight<br>        <span class="hljs-keyword">return</span> total/ total_weight<br><span class="hljs-comment">#编写学生类，该类包含学生正在学习的各项课程</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        self._subjects = &#123;&#125;<br>        <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">subject</span>(<span class="hljs-params">self, name</span>):</span><br>        <span class="hljs-keyword">if</span> name <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> self._subjects:<br>            self._subjects[name] = Subject()<br>        <span class="hljs-keyword">return</span> self._subjects[name]<br>        <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">average_grade</span>(<span class="hljs-params">self</span>):</span><br>        total, count =<span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> subject <span class="hljs-keyword">in</span> self._subjects.values():<br>            total += subject.average_grade()<br>            count +=<span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> total / count<br><span class="hljs-comment">#编写包好所有学生考试成绩的容器类，该容器以学生名字为键，可以动态添加学生</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Gradebook</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        self._students = &#123;&#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">student</span>(<span class="hljs-params">self, name</span>):</span><br>        <span class="hljs-keyword">if</span> name <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> self._students:<br>            self._student[name] = Student()<br>        <span class="hljs-keyword">return</span> self._students[name]<br><br><br><br>book = Gradebook()<br>albert = book.student(<span class="hljs-string">&#x27;Albert Einstein&#x27;</span>)<br>math = albert.subject(<span class="hljs-string">&#x27;Math&#x27;</span>)<br>math.report_grade(<span class="hljs-number">80</span>, <span class="hljs-number">0.10</span>)<br><span class="hljs-comment">#...</span><br>print(albert.average_grade())<br>&gt;&gt;&gt;<br><span class="hljs-number">81.5</span><br></code></pre></td></tr></table></figure>
<h3 id="EP23-简单的借口应该接受函数，而不是类的实例"><a href="#EP23-简单的借口应该接受函数，而不是类的实例" class="headerlink" title="EP23 简单的借口应该接受函数，而不是类的实例"></a>EP23 简单的借口应该接受函数，而不是类的实例</h3><p>我好想吐槽这个题目- -，看了好久才知道要表达什么<br>示例是通过挂钩函数来说明，调用类的实例的时候，别人会难以理解这个类的意图，最后使用__call__的方法，使相关对象能够像函数一样得到调用，但是我总觉得如果是简单的功能，直接使用闭包就好了- -</p>
<p>3种方法对比：</p>
<ul>
<li>原始函数：<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> defaultdict<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">log_missing</span>():</span><br>    print(<span class="hljs-string">&#x27;key added&#x27;</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br><br>current = &#123;<span class="hljs-string">&#x27;green&#x27;</span>:<span class="hljs-number">12</span>,<span class="hljs-string">&#x27;blue&#x27;</span>:<span class="hljs-number">3</span>&#125;<br>increments = [<br>    (<span class="hljs-string">&#x27;red&#x27;</span>,<span class="hljs-number">5</span>),<br>    (<span class="hljs-string">&#x27;blue&#x27;</span>,<span class="hljs-number">17</span>),<br>    (<span class="hljs-string">&#x27;prange&#x27;</span>,<span class="hljs-number">9</span>),<br>    ]<br>result = defaultdict(log_missing,current)<br>print(<span class="hljs-string">&#x27;Before:&#x27;</span>, <span class="hljs-built_in">dict</span>(result))<br><span class="hljs-keyword">for</span> key, amount <span class="hljs-keyword">in</span> increments:<br>    result[key] += amount<br>print(<span class="hljs-string">&#x27;After:&#x27;</span>, <span class="hljs-built_in">dict</span>(result))<br></code></pre></td></tr></table></figure></li>
<li>修改挂钩函数，通过闭包的方式，总计挂钩函数调用次数<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">increment_with_report</span>(<span class="hljs-params">current, increments</span>):</span><br>    added_count = <span class="hljs-number">0</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">missing</span>():</span><br>        <span class="hljs-keyword">nonlocal</span> added_count<br>        added_count += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br><br>    result = defaultdict(missing,current)<br>    <span class="hljs-keyword">for</span> key, amount <span class="hljs-keyword">in</span> increments:<br>        result[key] += amount<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">dict</span>(result), added_count<br><br>print(increment_with_report(current, increments))<br></code></pre></td></tr></table></figure></li>
<li>通过__call__方法，使相关对象能够像函数一样得到调用<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BetterCountMissing</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        self.added = <span class="hljs-number">0</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__call__</span>(<span class="hljs-params">self</span>):</span><br>        self.added += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br><br>counter = BetterCountMissing()<br>result = defaultdict(counter, current)<br><span class="hljs-keyword">for</span> key, amount <span class="hljs-keyword">in</span> increments:<br>    result[key] += amount<br>print(<span class="hljs-built_in">dict</span>(result))<br><span class="hljs-keyword">assert</span> counter.added ==<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure>
<h3 id="EP24-以-classmethod形式的多台去通用地构建对象"><a href="#EP24-以-classmethod形式的多台去通用地构建对象" class="headerlink" title="EP24 以@classmethod形式的多台去通用地构建对象"></a>EP24 以@classmethod形式的多台去通用地构建对象</h3>手工构建相关对象，并通过辅助函数将这些对象联系起来的方法有一个问题就是函数不够通用，如果要编写其他子类，就得重写函数，在其他语言中，可以通过构造器多态来解决，但是python中只允许名为__init__的构造器方法，也就是每个类只有一个构造器，这时候就可以用@classmethod形式的多台来解决了。它针对的不是整个类，而是从该类构建出来的对象。<br>以下两种方法中，第二种的方法虽然需要的参数变多了，但是我们在编写子类时不用修改刚才写好的拼接方法了<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#定义一个表示输入的基类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InputData</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">read</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">raise</span> NotImplementedError <span class="hljs-comment">#尚未实现的方法返回的异常</span><br><br><span class="hljs-comment">#编写InputData类的具体子类，以便从磁盘文件里读取数据</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PathInputData</span>(<span class="hljs-params">InputData</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self,path</span>):</span><br>        <span class="hljs-built_in">super</span>().__init__()<br>        self.path = path<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">read</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">open</span>(self.path).read()<br>        <br><span class="hljs-comment">#为工作线程定义一套类似的抽象借口，以便使用标准的方式来处理输入的数据</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Worker</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, input_data</span>):</span><br>        self.input_data = input_data<br>        self.result = <span class="hljs-literal">None</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">map</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">raise</span> NotImplementedError<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reduce</span>(<span class="hljs-params">self, other</span>):</span><br>        <span class="hljs-keyword">raise</span> NotImplementedError<br><br><span class="hljs-comment">#定义具体的Worker子类。本例所实现的功能是一个简单的换行符计数器：</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LineCountWorker</span>(<span class="hljs-params">Worker</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">map</span>(<span class="hljs-params">self</span>):</span><br>        data = self.input_data.read()<br>        self.result = data.count(<span class="hljs-string">&#x27;\n&#x27;</span>)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reduce</span>(<span class="hljs-params">self, other</span>):</span><br>        self.result += other.result<br><br><span class="hljs-comment">#以下是手工构建相关对象</span><br><span class="hljs-comment">#列出某个目录的内容，并为该目录下的每个文件创建一个PathInputData实例</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">generate_inputs</span>(<span class="hljs-params">data_dir</span>):</span><br>    <span class="hljs-keyword">for</span> name <span class="hljs-keyword">in</span> os.listdir(data_dir):<br>        <span class="hljs-keyword">yield</span> PathInputData(os.path.join(data_dir, name))<br><br><span class="hljs-comment">#用generate_inputs方法所返回的InputData实例创建LineCountWorket实例</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">create_workers</span>(<span class="hljs-params">input_list</span>):</span><br>    workers = []<br>    <span class="hljs-keyword">for</span> input_data <span class="hljs-keyword">in</span> input_list:<br>        workers.append(LineCountWorker(input_data))<br>    <span class="hljs-keyword">return</span> workers<br><br><span class="hljs-comment">#执行Worket实例，以便将流程中的map的步骤派发到多个线程之中，接下来反复调用reduce方法，将map步骤的结构合并成一个最终值</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">execute</span>(<span class="hljs-params">workers</span>):</span><br>    threads = [Thread(target=w.<span class="hljs-built_in">map</span>) <span class="hljs-keyword">for</span> w <span class="hljs-keyword">in</span> workers]<br>    <span class="hljs-keyword">for</span> thead <span class="hljs-keyword">in</span> threads: thread.start()<br>    <span class="hljs-keyword">for</span> thead <span class="hljs-keyword">in</span> threads: thread.join()<br>    <br>    first, rest = workers[.],workers[<span class="hljs-number">1</span>:]<br>    <span class="hljs-keyword">for</span> worker <span class="hljs-keyword">in</span> rest:<br>        first.reduce(worker)<br>    <span class="hljs-keyword">return</span> first.result<br><br><span class="hljs-comment">#最后把上面这些代码拼装到函数里面</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">mapreduce</span>(<span class="hljs-params">data_dir</span>):</span><br>    inputs = generate_inputs(data_dir)<br>    worker = create_workers(inputs)<br>    <span class="hljs-keyword">return</span> execute(workers)<br><br></code></pre></td></tr></table></figure>
@classmethod方法<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#添加的generate_inputs类方法，该方法会根据通用的借口来创建新的InputData实例，</span><br><span class="hljs-comment">#新添加的generate_inputs方法，接受一份含有配置参数的字典，而具体的GenericInputData子类则可以解读这些参数</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GenericInputData</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">read</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">raise</span> NotImplementedError <br><br><span class="hljs-meta">    @classmethod</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">generate_inputs</span>(<span class="hljs-params">cls, config</span>):</span><br>        <span class="hljs-keyword">raise</span> NotImplementedError<br><br><span class="hljs-comment">#通过config字典来查询输入文件所在的目录</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PathInputData</span>(<span class="hljs-params">GenericInputData</span>):</span><br>    <span class="hljs-comment">#...</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">read</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">open</span>(self.path).read()<br><br><span class="hljs-meta">    @classmethod</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">generate_inputs</span>(<span class="hljs-params">cls, config</span>):</span><br>        data_dir = config[<span class="hljs-string">&#x27;data_dir&#x27;</span>]<br>        <span class="hljs-keyword">for</span> name <span class="hljs-keyword">in</span> os.listdir(data_dir):<br>            <span class="hljs-keyword">yield</span> cls(os.path.join(data_dir, name))<br><br><span class="hljs-comment">#使用cls（）形式的通用构造器，来构造具体的GenericWorker子类实例</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GenericWorker</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    这段代码的重点，是input_class.generate_inputs，它是个类级别的多态方法。此外，create_workers方法用另外一种方式够造了</span><br><span class="hljs-string">    GenericWorker对象，它是通过clas形式来构造的，而不是像以前那样，直接使用__init__方法</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-comment">#...</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">map</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">raise</span> NotImplementedError<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reduce</span>(<span class="hljs-params">self, other</span>):</span><br>        <span class="hljs-keyword">raise</span> NotImplementedError<br><br><span class="hljs-meta">    @classmethod</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">create_workers</span>(<span class="hljs-params">cls, input_class, config</span>):</span><br>        workers = []<br>        <span class="hljs-keyword">for</span> input_data <span class="hljs-keyword">in</span> input_class.generate_inputs(config):<br>            workers.append(cls(input_data))<br>        <span class="hljs-keyword">return</span> workers<br><br><span class="hljs-comment">#修改继承的父类就可以了</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LineCountWorker</span>(<span class="hljs-params">GenericWorker</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">map</span>(<span class="hljs-params">self</span>):</span><br>        data = self.input_data.read()<br>        self.result = data.count(<span class="hljs-string">&#x27;\n&#x27;</span>)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reduce</span>(<span class="hljs-params">self, other</span>):</span><br>        self.result += other.result<br><br><span class="hljs-comment">#重写mapreduce函数</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">mapreduce</span> (<span class="hljs-params">worker_class, input_class, config</span>):</span><br>    workers = worker_class.create_workers(input_class, config)<br>    <span class="hljs-keyword">return</span> execute(workers) <span class="hljs-comment">#调用到上第一个方法的execute</span><br></code></pre></td></tr></table></figure>
<h3 id="EP31-用秒速福来改写需要复用的-property方法"><a href="#EP31-用秒速福来改写需要复用的-property方法" class="headerlink" title="EP31 用秒速福来改写需要复用的@property方法"></a>EP31 用秒速福来改写需要复用的@property方法</h3>使用@property修饰器，有个明显的缺点，就是不方便复用。<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Homework</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        self._grade = <span class="hljs-number">0</span><br><br><span class="hljs-meta">    @property</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">grade</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> self._grade<br><br><span class="hljs-meta">    @grade.setter</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">grade</span>(<span class="hljs-params">self, value</span>):</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> (<span class="hljs-number">0</span>&lt;= value &lt;=<span class="hljs-number">100</span>):<br>            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&#x27;Grade must be between 0 and 100&#x27;</span>)<br>        self._grade = value<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Exam</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">sefl</span>):</span><br>        self._writing_grade = <span class="hljs-number">0</span><br>        self._math_grade = <span class="hljs-number">0</span><br><br><span class="hljs-meta">    @staticmethod</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_check_grade</span>(<span class="hljs-params">value</span>):</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span>(<span class="hljs-number">0</span>&lt;= value &lt;=<span class="hljs-number">100</span>):<br>            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&#x27;Grade must be between 0 and 100&#x27;</span>)<br></code></pre></td></tr></table></figure>
像上面这种方法，每添加一门科目，就要多编写多一次@property的方法<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@property</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">writing_grade</span>(<span class="hljs-params">self</span>):</span><br>    <span class="hljs-keyword">return</span> self._writing_grade<br><br><span class="hljs-meta">@writing_grade.setter</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">writing_grade</span>(<span class="hljs-params">self, value</span>):</span><br>    self._check_grade(value)<br>    self._writing_grade = value<br><br><span class="hljs-meta">@property</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">math_grade</span>(<span class="hljs-params">self</span>):</span><br>    <span class="hljs-keyword">return</span> self._math_grade<br><br><br><span class="hljs-meta">@math_grade.setter</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">math_grade</span>(<span class="hljs-params">self, value</span>):</span><br>    self._check_grade(value)<br>    self._math_grade = value<br></code></pre></td></tr></table></figure>
所以我们可以使用描述符的方法，再用字典来保存每个实例的状态<br>ps 对于__set__方法的每个Exam实例来说，字典都会保存指向该实例的一份引用，这就导致该实例的引用计数无法降为0，从而使垃圾收集器无法将其回收，会引起内存泄露。<br>使用Python内置的weakref模块可以解决此问题，该模块提供的名为WeakKeyDictionary的特殊字典，特殊之处在于：如果运行期间系统发现这种字典所持有的引用，是整个程序里面指向Exam实例的最后一份引用，那么系统就会自动将该实例从字典的键中移除<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> weakref <span class="hljs-keyword">import</span> WeakKeyDictionary<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Grade</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        self._values = WeakKeyDictionary()<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__get__</span>(<span class="hljs-params">self, instance, instance_type</span>):</span><br>        <span class="hljs-keyword">if</span> instance <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>: <span class="hljs-keyword">return</span> self<br>        <span class="hljs-keyword">return</span> self._values.get(instance, <span class="hljs-number">0</span>)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__set__</span>(<span class="hljs-params">self, instance, value</span>):</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> (<span class="hljs-number">0</span> &lt;= value &lt;=<span class="hljs-number">100</span>):<br>            <span class="hljs-keyword">raise</span> ValueErrror(<span class="hljs-string">&#x27;Grade must be between 0 and 100&#x27;</span>)<br>        self._values[instance] = value<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Exam</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    math_grade = Grade()<br>    writing_grade = Grade()<br>    science_grade = Grade()<br><br>first_exam = Exam()<br>second_exam = Exam()<br>first_exam.writing_grade = <span class="hljs-number">82</span><br>first_exam.science_grade = <span class="hljs-number">83</span><br>second_exam.writing_grade = <span class="hljs-number">92</span><br>second_exam.science_grade = <span class="hljs-number">93</span><br>print(first_exam.writing_grade,second_exam.science_grade)<br>&gt;&gt;&gt;<br><span class="hljs-number">82</span> <span class="hljs-number">93</span><br></code></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="EP38-在线程中使用Lock来防止数据竞争"><a href="#EP38-在线程中使用Lock来防止数据竞争" class="headerlink" title="EP38 在线程中使用Lock来防止数据竞争"></a>EP38 在线程中使用Lock来防止数据竞争</h3><p>使用多线程时，会发生数据竞争现象，通过使用Lock类可以解决<br>原本的代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Couter</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        self.count = <span class="hljs-number">0</span><br>    <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">increment</span>(<span class="hljs-params">self, offset</span>):</span><br>        self.count += offset<br></code></pre></td></tr></table></figure>
<p>修改为</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LockingCounter</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        self.lock = Lock()<br>        self.count = <span class="hljs-number">0</span><br>    <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">increment</span>(<span class="hljs-params">self, offset</span>):</span><br>        <span class="hljs-keyword">with</span> self.lock:<br>            self.count += offset<br></code></pre></td></tr></table></figure>

<h3 id="EP39-用Queue来协调各线程之间的工作"><a href="#EP39-用Queue来协调各线程之间的工作" class="headerlink" title="EP39 用Queue来协调各线程之间的工作"></a>EP39 用Queue来协调各线程之间的工作</h3><p>在各种协调方式中，较为高效的一种，则是采用函数管线<br>工作原理，与制造业中的组装生产线相似。管线分为许多首尾相连的阶段，每个阶段都由一种具体的函数来负。程序总是把待处理的新不见添加到管线的开端。每一种函数都可以在它所负责的那个阶段内，并发地处理位于该阶段的部件。等负责本阶段的那个函数，把某个部件处理好之后，该部件就会传送到管线中的下一个阶段，以此类推，知道全部阶段都经理一遍。涉及阻塞式I/O操作或子进程的工作任务，尤其适用此方法处理，因为这样的任务蛮狠容易分配到多个Python线程或进程之中<br>在管线中，每个阶段的工作函数，其执行速度可能会有所差别，这就使得前一阶段可能会拖慢后一阶段的进度，从而令整条管线迟滞。后一个阶段会在其循环语句中，反复查询输入队列，以求获取新的任务，而前一个阶段又迟迟不能把任务交过来，于是就令后一个阶段陷入了饥饿。这样做的结果是：工作线程会白白地浪费CPU时间，去执行一些没有用的操作，也就是说，它们会持续地抛出并捕获IndexError异常<br>此外还有三个问题，也应该避免。首先，为了判断所有的任务是否都彻底处理完毕，我们必须再编写一个循环，持续判断done_queue队列中的任务数量。其次Worker线程的run方法，会一直执行其巡皇。即便到了退出的时候，我们也没有办法通知Worker线程停止这以循环<br>还有另外一个更严重的问题是，如果管线的某个阶段发送迟滞，那么随时都可能导致程序崩溃，若第一个阶段的处理速度很快，而第二阶段的处理速度较慢，则链接这两个阶段的哪个队列的容量会不断增大。第二阶段始终没有办法跟上第一阶段的节奏，这种现象持续一段时间后，程序就会因为收到大量的输入数据而耗尽内存，进而崩溃<br>在python中，可以用Queue类来弥补自编队列的缺陷</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> queue <span class="hljs-keyword">import</span> Queue<br><span class="hljs-keyword">from</span> threading <span class="hljs-keyword">import</span> Thread<br><br>queue = Queue()<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">consumer</span>():</span><br>    print(<span class="hljs-string">&#x27;waiting&#x27;</span>)<br>    queue.get()<br>    print(<span class="hljs-string">&#x27;done&#x27;</span>)<br><br>thread = Thread(target = consumer)<br>thread.start()<br><span class="hljs-comment">#&gt;&gt;&gt;</span><br><span class="hljs-comment">#waiting</span><br>print(<span class="hljs-string">&#x27;putting&#x27;</span>)<br>queue.put(<span class="hljs-built_in">object</span>())<br>thread.join()<br>print(<span class="hljs-string">&#x27;done1&#x27;</span>)<br><span class="hljs-comment">#&gt;&gt;&gt;</span><br><span class="hljs-comment">#waiting</span><br><span class="hljs-comment">#putting</span><br><span class="hljs-comment">#done</span><br><span class="hljs-comment">#done1</span><br></code></pre></td></tr></table></figure>
<p>上面的代码中。Queue类是的工作线程无需再频繁地查询输入队列的状态，因为它的get方法会持续阻塞，直到有新的数据加入，所以会卡在queue.get()那里，调用Queue的put方法，给队列中放入一项任务，方能使queue.get()方法得以返回</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> queue <span class="hljs-keyword">import</span> Queue<br><span class="hljs-keyword">from</span> threading <span class="hljs-keyword">import</span> Thread<br><span class="hljs-keyword">import</span> time<br><br>queue = Queue()<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">consumer</span>():</span><br>    time.sleep(<span class="hljs-number">0.1</span>)<br>    queue.get()<br>    print(<span class="hljs-string">&#x27;1&#x27;</span>)<br>    queue.get()<br>    print(<span class="hljs-string">&#x27;2&#x27;</span>)<br><br>thread = Thread(target=consumer)<br>thread.start()<br><br>queue.put(<span class="hljs-built_in">object</span>())<br>print(<span class="hljs-string">&#x27;put1&#x27;</span>)<br>queue.put(<span class="hljs-built_in">object</span>())<br>print(<span class="hljs-string">&#x27;put2&#x27;</span>)<br>thread.join()<br>print(<span class="hljs-string">&#x27;done&#x27;</span>)<br></code></pre></td></tr></table></figure>
<p>Queue类可以通过限定队列中待处理的最大任务数量，使得相邻的两个阶段，通过队列平滑的衔接起来</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> queue <span class="hljs-keyword">import</span> Queue<br><span class="hljs-keyword">from</span> threading <span class="hljs-keyword">import</span> Thread<br><br>in_queue = Queue()<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">consumer</span>():</span><br>    print(<span class="hljs-string">&#x27;waiting1&#x27;</span>)<br>    work = in_queue.get()<br>    print(<span class="hljs-string">&#x27;workinga&#x27;</span>)<br>    print(<span class="hljs-string">&#x27;donea&#x27;</span>)<br>    in_queue.task_done()<br>    work1 = in_queue.get()<br>    print(<span class="hljs-string">&#x27;workingb&#x27;</span>)<br>    print(<span class="hljs-string">&#x27;doneb&#x27;</span>)<br>    in_queue.task_done()<br><br>Thread(target=consumer).start()<br><br>in_queue.put(<span class="hljs-built_in">object</span>())<br>print(<span class="hljs-string">&#x27;waiting1put&#x27;</span>)<br>in_queue.put(<span class="hljs-built_in">object</span>())<br>print(<span class="hljs-string">&#x27;waiting2put&#x27;</span>)<br>in_queue.join()<br>print(<span class="hljs-string">&#x27;done&#x27;</span>)<br></code></pre></td></tr></table></figure>
<p>上面这个代码是通过Queue类的task_done方法来追踪工作进度。有了这个方法，我们就不用再像原理那样。再管线末端的done_queue处进行轮训，而是可以直接判断：管线中的某个阶段，是否将输入对垒中的任务处理完毕</p>
<h3 id="EP40-考虑用concurrent-futures来实现真正的平行计算"><a href="#EP40-考虑用concurrent-futures来实现真正的平行计算" class="headerlink" title="EP40 考虑用concurrent.futures来实现真正的平行计算"></a>EP40 考虑用concurrent.futures来实现真正的平行计算</h3><p> 最好是符合两个条件。<br> 1/运行的函数不需要与程序中的其他部分共享状态。<br> 2/只需要在主进程与子进程之间传递一小部分数据，就能完成大量的运算<br> <figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">from</span> concurrent.futures <span class="hljs-keyword">import</span> ProcessPoolExecutor<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">gcd</span>(<span class="hljs-params">pair</span>):</span><br>    a, b = pair<br>    low = <span class="hljs-built_in">min</span>(a,b)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(low, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">if</span> a%i ==<span class="hljs-number">0</span> <span class="hljs-keyword">and</span> b% i == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> i<br><br>numbers = [(<span class="hljs-number">1963309</span>, <span class="hljs-number">2265973</span>), (<span class="hljs-number">2030677</span>, <span class="hljs-number">3814172</span>),<br>           (<span class="hljs-number">1551645</span>, <span class="hljs-number">2229620</span>), (<span class="hljs-number">2039045</span>, <span class="hljs-number">2020802</span>)]<br><br>start = time.time()<br>pool = ProcessPoolExecutor(max_workers=<span class="hljs-number">2</span>)<br>results = <span class="hljs-built_in">list</span>(pool.<span class="hljs-built_in">map</span>(gcd, numbers))<br>end = time.time()<br>print(end - start)<br></code></pre></td></tr></table></figure><br> 在双核电脑上。运行时间接近快一倍</p>
<p> ProcessPoolExecutor操作过程如下：<br> 1.把numbers列表中的每一项数据都传给map<br> 2.用pickle模块对数据进行序列化，将其变成二进制形式<br> 3.通过本地套接字，将序列化之后的数据从主解释器所在的进程，发送到子解释器所在的进程。<br> 4.接下来，在子进程中，用pickle对二进制数据进行反序列化操作，将其还原为python对象。<br> 5.引入包含gcd函数的哪个python模块<br> 6.各条子进程平行地针对各自的输入数据，来运行gcd函数<br> 7.对运行结果进行序列化操作，将其转变为字节<br> 8.将这些字节通过socket复制到主进程之中<br> 9.主进程对这些字节执行反序列化操作，将其还原为python对象<br> 10.最后，把每条子进程所求出的计算结果合并到一份列表之中，并返回给调用者</p>
<h2 id="Class部分"><a href="#Class部分" class="headerlink" title="Class部分"></a>Class部分</h2><p>由于class的我有些总记不住，所以写在这里，有空时可以看一看增加记忆</p>
<h3 id="isinstance-函数"><a href="#isinstance-函数" class="headerlink" title="isinstance()函数"></a>isinstance()函数</h3><p>对于class的继承关系来说，使用type()就很不方便。我们要判断class的类型，可以使用isinstance()函数。isinstance()判断的是一个对象是否是该类型本身，或者位于该类型的父继承链上。</p>
<h3 id="dir-函数"><a href="#dir-函数" class="headerlink" title="dir()函数"></a>dir()函数</h3><p>如果要获得一个对象的所有属性和方法，可以使用dir()函数，它返回一个包含字符串的list，比如，获得一个str对象的所有属性和方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">dir</span>(<span class="hljs-string">&#x27;ABC&#x27;</span>)<br>[<span class="hljs-string">&#x27;__add__&#x27;</span>, <span class="hljs-string">&#x27;__class__&#x27;</span>, <span class="hljs-string">&#x27;__contains__&#x27;</span>, <span class="hljs-string">&#x27;__delattr__&#x27;</span>, <span class="hljs-string">&#x27;__dir__&#x27;</span>, <span class="hljs-string">&#x27;__doc__&#x27;</span>, <span class="hljs-string">&#x27;__eq__&#x27;</span>, <span class="hljs-string">&#x27;__format__&#x27;</span>, <span class="hljs-string">&#x27;__ge__&#x27;</span>, <span class="hljs-string">&#x27;__getattribute__&#x27;</span>, <span class="hljs-string">&#x27;__getitem__&#x27;</span>, <span class="hljs-string">&#x27;__getnewargs__&#x27;</span>, <span class="hljs-string">&#x27;__gt__&#x27;</span>, <span class="hljs-string">&#x27;__hash__&#x27;</span>, <span class="hljs-string">&#x27;__init__&#x27;</span>, <span class="hljs-string">&#x27;__iter__&#x27;</span>, <span class="hljs-string">&#x27;__le__&#x27;</span>, <span class="hljs-string">&#x27;__len__&#x27;</span>, <span class="hljs-string">&#x27;__lt__&#x27;</span>, <span class="hljs-string">&#x27;__mod__&#x27;</span>, <span class="hljs-string">&#x27;__mul__&#x27;</span>, <span class="hljs-string">&#x27;__ne__&#x27;</span>, <span class="hljs-string">&#x27;__new__&#x27;</span>, <span class="hljs-string">&#x27;__reduce__&#x27;</span>, <span class="hljs-string">&#x27;__reduce_ex__&#x27;</span>, <span class="hljs-string">&#x27;__repr__&#x27;</span>, <span class="hljs-string">&#x27;__rmod__&#x27;</span>, <span class="hljs-string">&#x27;__rmul__&#x27;</span>, <span class="hljs-string">&#x27;__setattr__&#x27;</span>, <span class="hljs-string">&#x27;__sizeof__&#x27;</span>, <span class="hljs-string">&#x27;__str__&#x27;</span>, <span class="hljs-string">&#x27;__subclasshook__&#x27;</span>, <span class="hljs-string">&#x27;capitalize&#x27;</span>, <span class="hljs-string">&#x27;casefold&#x27;</span>, <span class="hljs-string">&#x27;center&#x27;</span>, <span class="hljs-string">&#x27;count&#x27;</span>, <span class="hljs-string">&#x27;encode&#x27;</span>, <span class="hljs-string">&#x27;endswith&#x27;</span>, <span class="hljs-string">&#x27;expandtabs&#x27;</span>, <span class="hljs-string">&#x27;find&#x27;</span>, <span class="hljs-string">&#x27;format&#x27;</span>, <span class="hljs-string">&#x27;format_map&#x27;</span>, <span class="hljs-string">&#x27;index&#x27;</span>, <span class="hljs-string">&#x27;isalnum&#x27;</span>, <span class="hljs-string">&#x27;isalpha&#x27;</span>, <span class="hljs-string">&#x27;isdecimal&#x27;</span>, <span class="hljs-string">&#x27;isdigit&#x27;</span>, <span class="hljs-string">&#x27;isidentifier&#x27;</span>, <span class="hljs-string">&#x27;islower&#x27;</span>, <span class="hljs-string">&#x27;isnumeric&#x27;</span>, <span class="hljs-string">&#x27;isprintable&#x27;</span>, <span class="hljs-string">&#x27;isspace&#x27;</span>, <span class="hljs-string">&#x27;istitle&#x27;</span>, <span class="hljs-string">&#x27;isupper&#x27;</span>, <span class="hljs-string">&#x27;join&#x27;</span>, <span class="hljs-string">&#x27;ljust&#x27;</span>, <span class="hljs-string">&#x27;lower&#x27;</span>, <span class="hljs-string">&#x27;lstrip&#x27;</span>, <span class="hljs-string">&#x27;maketrans&#x27;</span>, <span class="hljs-string">&#x27;partition&#x27;</span>, <span class="hljs-string">&#x27;replace&#x27;</span>, <span class="hljs-string">&#x27;rfind&#x27;</span>, <span class="hljs-string">&#x27;rindex&#x27;</span>, <span class="hljs-string">&#x27;rjust&#x27;</span>, <span class="hljs-string">&#x27;rpartition&#x27;</span>, <span class="hljs-string">&#x27;rsplit&#x27;</span>, <span class="hljs-string">&#x27;rstrip&#x27;</span>, <span class="hljs-string">&#x27;split&#x27;</span>, <span class="hljs-string">&#x27;splitlines&#x27;</span>, <span class="hljs-string">&#x27;startswith&#x27;</span>, <span class="hljs-string">&#x27;strip&#x27;</span>, <span class="hljs-string">&#x27;swapcase&#x27;</span>, <span class="hljs-string">&#x27;title&#x27;</span>, <span class="hljs-string">&#x27;translate&#x27;</span>, <span class="hljs-string">&#x27;upper&#x27;</span>, <span class="hljs-string">&#x27;zfill&#x27;</span>]<br></code></pre></td></tr></table></figure>
<h3 id="getattr-、setattr-以及hasattr"><a href="#getattr-、setattr-以及hasattr" class="headerlink" title="getattr()、setattr()以及hasattr()"></a>getattr()、setattr()以及hasattr()</h3><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">hasattr</span>(obj, <span class="hljs-string">&#x27;x&#x27;</span>) <span class="hljs-comment"># 有属性&#x27;x&#x27;吗？</span><br><span class="hljs-literal">True</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>obj.x<br><span class="hljs-number">9</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">hasattr</span>(obj, <span class="hljs-string">&#x27;y&#x27;</span>) <span class="hljs-comment"># 有属性&#x27;y&#x27;吗？</span><br><span class="hljs-literal">False</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">setattr</span>(obj, <span class="hljs-string">&#x27;y&#x27;</span>, <span class="hljs-number">19</span>) <span class="hljs-comment"># 设置一个属性&#x27;y&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">hasattr</span>(obj, <span class="hljs-string">&#x27;y&#x27;</span>) <span class="hljs-comment"># 有属性&#x27;y&#x27;吗？</span><br><span class="hljs-literal">True</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">getattr</span>(obj, <span class="hljs-string">&#x27;y&#x27;</span>) <span class="hljs-comment"># 获取属性&#x27;y&#x27;</span><br><span class="hljs-number">19</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>obj.y <span class="hljs-comment"># 获取属性&#x27;y&#x27;</span><br><span class="hljs-number">19</span><br></code></pre></td></tr></table></figure>
<h3 id="slots"><a href="#slots" class="headerlink" title="__ slots__"></a>__ slots__</h3><p>为了达到限制的目的，Python允许在定义class的时候，定义一个特殊的__slots__变量，来限制该class实例能添加的属性</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    __slots__ = (<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>) <span class="hljs-comment"># 用tuple定义允许绑定的属性名称</span><br></code></pre></td></tr></table></figure>
<p>这样就不能添加除了name,age外的属性了<br>如果有添加其他属性，将得到AttributeError的错误<br>使用__slots__要注意，__slots__定义的属性仅对当前类实例起作用，对继承的子类是不起作用的</p>
<h3 id="property装饰器"><a href="#property装饰器" class="headerlink" title="@property装饰器"></a>@property装饰器</h3><p>使用@property装饰器后既能检查参数，又可以用类似属性这样简单的方式来访问类的变量</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br><br><span class="hljs-meta">    @property</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">score</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> self._score<br><br><span class="hljs-meta">    @score.setter</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">score</span>(<span class="hljs-params">self, value</span>):</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">isinstance</span>(value, <span class="hljs-built_in">int</span>):<br>            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&#x27;score must be an integer!&#x27;</span>)<br>        <span class="hljs-keyword">if</span> value &lt; <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> value &gt; <span class="hljs-number">100</span>:<br>            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&#x27;score must between 0 ~ 100!&#x27;</span>)<br>        self._score = value<br></code></pre></td></tr></table></figure>
<p>这样后就可以直接get或者set了</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>s = Student()<br><span class="hljs-meta">&gt;&gt;&gt; </span>s.score = <span class="hljs-number">60</span> <span class="hljs-comment"># OK，实际转化为s.set_score(60)</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>s.score <span class="hljs-comment"># OK，实际转化为s.get_score()</span><br><span class="hljs-number">60</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>s.score = <span class="hljs-number">9999</span><br>Traceback (most recent call last):<br>  ...<br>ValueError: score must between <span class="hljs-number">0</span> ~ <span class="hljs-number">100</span>!<br></code></pre></td></tr></table></figure>

<h3 id="call"><a href="#call" class="headerlink" title="__ call__"></a>__ call__</h3><p>可以让我们直接在实例本身上调用</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, name</span>):</span><br>        self.name = name<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__call__</span>(<span class="hljs-params">self</span>):</span><br>        print(<span class="hljs-string">&#x27;My name is %s.&#x27;</span> % self.name)<br></code></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>s = Student(<span class="hljs-string">&#x27;Michael&#x27;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>s() <span class="hljs-comment"># self参数不要传入</span><br>My name <span class="hljs-keyword">is</span> Michael.<br></code></pre></td></tr></table></figure>
<h3 id="repr"><a href="#repr" class="headerlink" title="__ repr__"></a>__ repr__</h3><p>__ repr__ 是一个专用的方法，在当调用 repr(instance) 时被调用。repr 函数是一个内置函数，它返回一个对象的字符串表示。它可以用在任何对象上，不仅仅是类的实例</p>
<h3 id="cmp"><a href="#cmp" class="headerlink" title="__ cmp__"></a>__ cmp__</h3><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__cmp__</span>(<span class="hljs-params">self, <span class="hljs-built_in">dict</span></span>):</span>                       <br>     <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(<span class="hljs-built_in">dict</span>, UserDict):            <br>         <span class="hljs-keyword">return</span> cmp(self.data, <span class="hljs-built_in">dict</span>.data)      <br>     <span class="hljs-keyword">else</span>:                                     <br>         <span class="hljs-keyword">return</span> cmp(self.data, <span class="hljs-built_in">dict</span>)  <br></code></pre></td></tr></table></figure>
<p>__ cmp__ 在比较类实例时被调用。通常，你可以通过使用 == 比较任意两个 Python 对象，不只是类实例。有一些规则，定义了何时内置数据类型被认为是相等的，例如，字典在有着全部相同的关键字和值时是相等的。对于类实例，你可以定义 __ cmp__ 方法，自已编写比较逻辑，然后你可以使用 == 来比较你的类，Python 将会替你调用你的 __ cmp__ 专用方法。</p>
<h3 id="getslice-、-setslice-、-delslice"><a href="#getslice-、-setslice-、-delslice" class="headerlink" title="__ getslice__、__ setslice__、__ delslice__"></a>__ getslice__、__ setslice__、__ delslice__</h3><p>该三个方法用于分片操作，如：列表</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__getslice__</span>(<span class="hljs-params">self, i, j</span>):</span><br>        <span class="hljs-built_in">print</span> <span class="hljs-string">&#x27;__getslice__&#x27;</span>,i,j<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__setslice__</span>(<span class="hljs-params">self, i, j, sequence</span>):</span><br>        <span class="hljs-built_in">print</span> <span class="hljs-string">&#x27;__setslice__&#x27;</span>,i,j<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__delslice__</span>(<span class="hljs-params">self, i, j</span>):</span><br>        <span class="hljs-built_in">print</span> <span class="hljs-string">&#x27;__delslice__&#x27;</span>,i,j<br>obj = Foo()<br>obj[-<span class="hljs-number">1</span>:<span class="hljs-number">1</span>]                   <span class="hljs-comment"># 自动触发执行 __getslice__</span><br>obj[<span class="hljs-number">0</span>:<span class="hljs-number">1</span>] = [<span class="hljs-number">11</span>,<span class="hljs-number">22</span>,<span class="hljs-number">33</span>,<span class="hljs-number">44</span>]    <span class="hljs-comment"># 自动触发执行 __setslice__</span><br><span class="hljs-keyword">del</span> obj[<span class="hljs-number">0</span>:<span class="hljs-number">2</span>]                <span class="hljs-comment"># 自动触发执行 __delslice__</span><br></code></pre></td></tr></table></figure>
<h3 id="new-和-metaclass"><a href="#new-和-metaclass" class="headerlink" title="__ new__ 和 __ metaclass__"></a>__ new__ 和 __ metaclass__</h3><p>关于<a href="http://www.cnblogs.com/ifantastic/p/3175735.html">__ new__</a><br>关于<a href="http://blog.jobbole.com/21351/">__ metaclass__</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyType</span>(<span class="hljs-params"><span class="hljs-built_in">type</span></span>):</span><br> <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, what, bases=<span class="hljs-literal">None</span>, <span class="hljs-built_in">dict</span>=<span class="hljs-literal">None</span></span>):</span><br>        <span class="hljs-built_in">super</span>(MyType, self).__init__(what, bases, <span class="hljs-built_in">dict</span>)<br> <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__call__</span>(<span class="hljs-params">self, *args, **kwargs</span>):</span><br>        obj = self.__new__(self, *args, **kwargs)<br> <br>        self.__init__(obj)<br> <br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br> <br>    __metaclass__ = MyType<br> <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, name</span>):</span><br>        self.name = name<br> <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__new__</span>(<span class="hljs-params">cls, *args, **kwargs</span>):</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">object</span>.__new__(cls, *args, **kwargs)<br> <br><span class="hljs-comment"># 第一阶段：解释器从上到下执行代码创建Foo类</span><br><span class="hljs-comment"># 第二阶段：通过Foo类创建obj对象</span><br>obj = Foo()<br></code></pre></td></tr></table></figure>
<h2 id="Django部分"><a href="#Django部分" class="headerlink" title="Django部分"></a>Django部分</h2><h3 id="随机抽取数据库数据"><a href="#随机抽取数据库数据" class="headerlink" title="随机抽取数据库数据"></a>随机抽取数据库数据</h3><p>.objects.order_by(‘?’)[:2]来获取数据库数据，一般情况下性能并不差<br><a href="https://www.2cto.com/kf/201312/262772.html">关于DJango随机抽取数据性能说明</a></p>
<h3 id="根据链接来获取数据库内容"><a href="#根据链接来获取数据库内容" class="headerlink" title="根据链接来获取数据库内容"></a>根据链接来获取数据库内容</h3><p>前端的表单提取数据后，把选项封装成url向Django索要数据并封装为json给前端<br>代码来自以查房的代码<br>URL部分<br>Django根据正则来提取url中想要的关键字</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">url(<span class="hljs-string">r&#x27;^mapjson/(?P&lt;pk_city&gt;\d+)/(?P&lt;pk_house_for&gt;\d+)/(?P&lt;pk_price&gt;\w+)/$&#x27;</span>, views.map_json, name=<span class="hljs-string">&#x27;map_json&#x27;</span>),<br></code></pre></td></tr></table></figure>
<p>view部分<br>就可以根据url来过得数据库的筛选条件</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">map_json</span>(<span class="hljs-params">request, pk_city, pk_house_for, pk_price</span>):</span><br><br>    city_name = get_object_or_404(city, pk=pk_city)<br>    house_for_name = get_object_or_404(house_for ,pk=pk_house_for)<br>    price = pk_price.split(<span class="hljs-string">&#x27;_&#x27;</span>)<br>    name_lict = house.objects.<span class="hljs-built_in">filter</span>(city_name=city_name, house_for_name=house_for_name)<br></code></pre></td></tr></table></figure>
<p>model部分<br>根据view的条件，从数据库获取数据</p>
<p>def get_absolute_url(self):里面的说明<br>注意到 URL 配置中的url(r’^mapjson_(?P<pk_city>\w+)/(?P<pk_house_for>\w+)/$’, views.map_json, name=’map_json’),<br>设定的 name=’map_json’在这里派上了用场。reverse 函数，它的第一个参数的值是 ‘building:map_json’，意思是 building 应用下的 name=map_json<br>的函数，由于上面通过 app_name = ‘building’ 告诉了 Django 这个 URL 模块是属于building 应用的，因此 Django 能够顺利地找到 blog 应用下<br>name 为 map_json 的视图函数，于是 reverse 函数会去解析这个视图函数对应的 URL</p>
<p>然后重点是。。。我设置错了，程序还能没有出现bug的运行，不过还是按照要求来，虽然有点乱<br>由于pk是view传过来的，所以这边不需要更改</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">city</span>(<span class="hljs-params">models.Model</span>):</span><br>    city_name = models.CharField(max_length=<span class="hljs-number">100</span>)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_absolute_url</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> reverse(<span class="hljs-string">&#x27;building:map_json&#x27;</span>, kwargs=&#123;<span class="hljs-string">&#x27;pk&#x27;</span>: self.pk&#125;)<br><br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Meta</span>:</span><br>        app_label = <span class="hljs-string">&quot;building&quot;</span><br></code></pre></td></tr></table></figure>

<h3 id="利用模板限制在前端输出的字符"><a href="#利用模板限制在前端输出的字符" class="headerlink" title="利用模板限制在前端输出的字符"></a>利用模板限制在前端输出的字符</h3><p>由于输出的文字长度不一，可以使用Django自带的方法判断是否大于某个长度，如果是就只输出定义的长度加…不是则输出全部</p>
<figure class="highlight django"><table><tr><td class="code"><pre><code class="hljs django"><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">if</span></span> movie.movie_name|<span class="hljs-name">length</span> &gt; 7 %&#125;</span><br><span class="xml">    </span><span class="hljs-template-variable">&#123;&#123;movie.movie_name|<span class="hljs-name">slice</span>:<span class="hljs-string">&quot;7&quot;</span>&#125;&#125;</span><span class="xml">...</span><br><span class="hljs-template-tag">&#123;%<span class="hljs-name"><span class="hljs-name">else</span></span>%&#125;</span><br><span class="xml">    </span><span class="hljs-template-variable">&#123;&#123; movie.movie_name &#125;&#125;</span><br><span class="hljs-template-tag">&#123;%<span class="hljs-name"><span class="hljs-name">endif</span></span>%&#125;</span><br></code></pre></td></tr></table></figure>

<h3 id="待整理"><a href="#待整理" class="headerlink" title="待整理"></a>待整理</h3>]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>django与缓存</title>
    <url>/2017/10/21/22_django_cache/</url>
    <content><![CDATA[<h2 id="前记"><a href="#前记" class="headerlink" title="前记"></a>前记</h2><p>简单的缓存设计与在django使用缓存</p>
<span id="more"></span>

<h2 id="1-浏览器的缓存"><a href="#1-浏览器的缓存" class="headerlink" title="1.浏览器的缓存"></a>1.浏览器的缓存</h2><p><a href="https://www.cnblogs.com/chenqf/p/6386163.html">关于浏览器与服务器缓存机制</a></p>
<h3 id="1-1浏览器缓存机制"><a href="#1-1浏览器缓存机制" class="headerlink" title="1.1浏览器缓存机制"></a>1.1浏览器缓存机制</h3><h4 id="1-1-1-http报文的Cache-Control头域"><a href="#1-1-1-http报文的Cache-Control头域" class="headerlink" title="1.1.1 http报文的Cache-Control头域"></a>1.1.1 http报文的Cache-Control头域</h4><p>　　Cache-Control指定请求和响应遵循的缓存机制。在请求消息或响应消息中设置Cache-Control并不会修改另一个消息处理过程中的缓存处理过程。请求时的缓存指令包括no-cache、no-store、max-age、max-stale、min-fresh、only-if-cached，响应消息中的指令包括public、private、no-cache、no-store、no-transform、must-revalidate、proxy-revalidate、max-age。各个消息中的指令含义如下：<br>　　Public指示响应可被任何缓存区缓存。<br>　　Private指示对于单个用户的整个或部分响应消息，不能被共享缓存处理。这允许服务器仅仅描述当用户的部分响应消息，此响应消息对于其他用户的请求无效。<br>　　no-cache指示请求或响应消息不能缓存<br>　　no-store用于防止重要的信息被无意的发布。在请求消息中发送将使得请求和响应消息都不使用缓存。<br>　　max-age指示客户机可以接收生存期不大于指定时间（以秒为单位）的响应。<br>　　min-fresh指示客户机可以接收响应时间小于当前时间加上指定时间的响应。<br>　　max-stale指示客户机可以接收超出超时期间的响应消息。如果指定max-stale消息的值，那么客户机可以接收超出超时期指定值之内的响应消息。<br>综述：<br>Cache-Control指定请求和响应遵循的缓存机制。在请求消息或响应消息中设置Cache-Control并不会修改另一个消息处理过程中的缓存处理过程。请求时的缓存指令包括no-cache、no-store、max-age、max-stale、min-fresh、only-if-cached，响应消息中的指令包括public、private、no-cache、no-store、no-transform、must-revalidate、proxy-revalidate、max-age。网页的缓存通过HTTP消息头中的“Cache-control”来控制，常见的取值有private、no-cache、max-age、must-revalidate等，默认为private。</p>
<h4 id="1-1-1-http报文的Last-Modified-If-Modified-Since"><a href="#1-1-1-http报文的Last-Modified-If-Modified-Since" class="headerlink" title="1.1.1  http报文的Last-Modified/If-Modified-Since"></a>1.1.1  http报文的Last-Modified/If-Modified-Since</h4><h5 id="Last-Modified-If-Modified-Since要配合Cache-Control使用。"><a href="#Last-Modified-If-Modified-Since要配合Cache-Control使用。" class="headerlink" title="Last-Modified/If-Modified-Since要配合Cache-Control使用。"></a>Last-Modified/If-Modified-Since要配合Cache-Control使用。</h5><p>   Last-Modified：标示这个响应资源的最后修改时间。web服务器在响应请求时，告诉浏览器资源的最后修改时间。<br>   If-Modified-Since：当资源过期时（使用Cache-Control标识的max-age），发现资源具有Last-Modified声明，则再次向web服务器请求时带上头 If-Modified-Since，表示请求时间。web服务器收到请求后发现有头If-Modified-Since 则与被请求资源的最后修改时间进行比对。若最后修改时间较新，说明资源又被改动过，则响应整片资源内容（写在响应消息包体内），HTTP 200；若最后修改时间较旧，说明资源无新修改，则响应HTTP 304 (无需包体，节省浏览)，告知浏览器继续使用所保存的cache。</p>
<h5 id="If-None-Match"><a href="#If-None-Match" class="headerlink" title="If-None-Match"></a>If-None-Match</h5><p>作用: If-None-Match和ETag一起工作，工作原理是在HTTP Response中添加ETag信息。 当用户再次请求该资源时，将在HTTP Request 中加入If-None-Match信息(ETag的值)。如果服务器验证资源的ETag没有改变（该资源没有更新），将返回一个304状态告诉客户端使用本地缓存文件。否则将返回200状态和新的资源和Etag.  使用这样的机制将提高网站的性能</p>
<h5 id="Pragma"><a href="#Pragma" class="headerlink" title="Pragma"></a>Pragma</h5><p>作用： 防止页面被缓存， 在HTTP/1.1版本中，它和Cache-Control:no-cache作用一模一样<br>Pargma只有一个用法， 例如： Pragma: no-cache</p>
<h2 id="2-Django的缓存"><a href="#2-Django的缓存" class="headerlink" title="2.Django的缓存"></a>2.Django的缓存</h2><h3 id="2-1Django缓存原理："><a href="#2-1Django缓存原理：" class="headerlink" title="2.1Django缓存原理："></a>2.1Django缓存原理：</h3><p>Django根据设置的缓存方式，浏览器第一次请求时，cache会缓存单个变量或整个网页等内容到硬盘或者内存中，同时设置response头部，当浏览器再次发起请求时，附带f-Modified-Since请求时间到Django，Django 发现f-Modified-Since会先去参数之后，会与缓存中的过期时间相比较，如果缓存时间比较新，则会重新请求数据，并缓存起来然后返回response给客户端，如果缓存没有过期，则直接从缓存中提取数据，返回给response给客户端。</p>
<h3 id="2-2通用设置"><a href="#2-2通用设置" class="headerlink" title="2.2通用设置"></a>2.2通用设置</h3><h4 id="2-2-1设置中间件"><a href="#2-2-1设置中间件" class="headerlink" title="2.2.1设置中间件"></a>2.2.1设置中间件</h4><p>django接受请求时，中间件的访问顺序是从上到下<br>返回响应时，中间件的访问顺序是从下到上，所以中间件的位置要放对</p>
<figure class="highlight hsp"><table><tr><td class="code"><pre><code class="hljs hsp"><span class="hljs-string">&#x27;django.middleware.cache.UpdateCacheMiddleware&#x27;</span>,  <span class="hljs-meta">#必须设置在第一个位置 </span><br>...其他中间件...<br><span class="hljs-string">&#x27;django.middleware.cache.FetchFromCacheMiddleware&#x27;</span>,<span class="hljs-meta">#必须设置在最后一个位置</span><br></code></pre></td></tr></table></figure>
<p>缓存中间件缓存每个没有GET或者POST参数的页面。 或者，如果CACHE_MIDDLEWARE_ANONYMOUS_ONLY设置为True，只有匿名请求（即不是由登录的用户）将被缓存。 如果想取消用户相关页面（user-specific pages）的缓存，例如Djangos 的管理界面，这是一种既简单又有效的方法。 CACHE_MIDDLEWARE_ANONYMOUS_ONLY，你应该确保你已经启动AuthenticationMiddleware。</p>
<p>此外，缓存中间件为每个HttpResponse自动设置了几个头部信息：</p>
<p>当一个新(没缓存的)版本的页面被请求时设置Last-Modified头部为当前日期/时间。</p>
<p>设置Expires头部为当前日期/时间加上定义的CACHE_MIDDLEWARE_SECONDS。</p>
<p>设置Cache-Control头部来给页面一个最长的有效期，值来自于CACHE_MIDDLEWARE_SECONDS设置。</p>
<h4 id="2-2-2通用设置"><a href="#2-2-2通用设置" class="headerlink" title="2.2.2通用设置"></a>2.2.2通用设置</h4><figure class="highlight ini"><table><tr><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">CACHE_MIDDLEWARE_ALIAS</span> = <span class="hljs-string">&#x27;default&#x27;</span>    <span class="hljs-comment">#用来存储的缓存别名</span><br><span class="hljs-attr">CACHE_MIDDLEWARE_SECONDS</span> = <span class="hljs-number">0</span>  <span class="hljs-comment">#所有页面默认缓存时间,默认600</span><br><span class="hljs-attr">CACHE_MIDDLEWARE_KEY_PREFIX</span> =<span class="hljs-string">&#x27;www.demo.com&#x27;</span>  <span class="hljs-comment">#关键的前缀，当多个站点使用同一个配置的时候，这个可以设置可以避免发生冲突,一般设置为网站域名</span><br><span class="hljs-attr">CACHE_MIDDLEWARE_ANONYMOUS_ONLY</span> = <span class="hljs-literal">False</span> <span class="hljs-comment">#那么只有匿名的请求会被缓存，这是一个禁用缓存非匿名用户页面的最简单的做法，注意确保已经启用了Django用户认证中间件</span><br></code></pre></td></tr></table></figure>

<h3 id="2-3-选择缓存方式"><a href="#2-3-选择缓存方式" class="headerlink" title="2.3 选择缓存方式"></a>2.3 选择缓存方式</h3><h4 id="2-3-1memcached缓存-推荐"><a href="#2-3-1memcached缓存-推荐" class="headerlink" title="2.3.1memcached缓存(推荐)"></a>2.3.1memcached缓存(推荐)</h4><p>需要pip安装memcached的插件Python-mencached和pylibmc，可以同时支持多个服务器上面的memcached</p>
<figure class="highlight clean"><table><tr><td class="code"><pre><code class="hljs clean"><span class="hljs-string">&#x27;django.core.cache.backends.memcached.MemcachedCache&#x27;</span><br><span class="hljs-string">&#x27;django.core.cache.backends.memcached.PyLibMCCache&#x27;</span><br>CACHES = &#123;<br>    <span class="hljs-string">&#x27;default&#x27;</span>: &#123;<br>        <span class="hljs-string">&#x27;BACKEND&#x27;</span>: <span class="hljs-string">&#x27;django.core.cache.backends.memcached.MemcachedCache&#x27;</span>,<br>        <span class="hljs-string">&#x27;LOCATION&#x27;</span>: [<br>            <span class="hljs-string">&#x27;172.19.26.240:11211&#x27;</span>,   #服务器<span class="hljs-number">1</span><br>            <span class="hljs-string">&#x27;172.19.26.242:11211&#x27;</span>,   #服务器<span class="hljs-number">2</span><br>        ]<br>#<span class="hljs-string">&#x27;LOCATION&#x27;</span>: <span class="hljs-string">&#x27;unix:/tmp/memcached.sock&#x27;</span>,   #unix的socket的方式<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="2-3-2数据库缓存-不推荐"><a href="#2-3-2数据库缓存-不推荐" class="headerlink" title="2.3.2数据库缓存(不推荐)"></a>2.3.2数据库缓存(不推荐)</h4><p>注意的是数据库缓存使用的是你配置文件中的数据库作为默认的数据库，如果一定要选用其他的数据库，则需要修改数据库缓存表，不过量多的话，数据库缓存效用也会变差<br>生成数据库表：<br>运行命令：python manage.py createcachetable my_cache_table<br>配置:</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">CACHES</span> = &#123;<br>    <span class="hljs-string">&#x27;default&#x27;</span>: &#123;<br>        <span class="hljs-string">&#x27;BACKEND&#x27;</span>: <span class="hljs-string">&#x27;django.core.cache.backends.db.DatabaseCache&#x27;</span>,<br>        <span class="hljs-string">&#x27;LOCATION&#x27;</span>: <span class="hljs-string">&#x27;my_cache_table&#x27;</span>,<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>2#### 2.3.3文件系统缓存<br>注意是绝对位置（从根目录开始），必须保证服务器对你列出的路径具有读写权限</p>
<figure class="highlight clean"><table><tr><td class="code"><pre><code class="hljs clean">CACHES = &#123;<br>    <span class="hljs-string">&#x27;default&#x27;</span>: &#123;<br>        <span class="hljs-string">&#x27;BACKEND&#x27;</span>: <span class="hljs-string">&#x27;django.core.cache.backends.filebased.FileBasedCache&#x27;</span>,<br>        <span class="hljs-string">&#x27;LOCATION&#x27;</span>: <span class="hljs-string">&#x27;/var/tmp/django_cache&#x27;</span>,#这个是文件夹的路径<br>        #<span class="hljs-string">&#x27;LOCATION&#x27;</span>: <span class="hljs-string">&#x27;c:\foo\bar&#x27;</span>,#windows下的示例<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="2-3-4本地内存缓存（生产环境下不建议使用）"><a href="#2-3-4本地内存缓存（生产环境下不建议使用）" class="headerlink" title="2.3.4本地内存缓存（生产环境下不建议使用）"></a>2.3.4本地内存缓存（生产环境下不建议使用）</h4><p>本地内存缓存，这个缓存是多进程和线程安全的</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">CACHES</span> = &#123;<br>    <span class="hljs-string">&#x27;default&#x27;</span>: &#123;<br>        <span class="hljs-string">&#x27;BACKEND&#x27;</span>: <span class="hljs-string">&#x27;django.core.cache.backends.locmem.LocMemCache&#x27;</span>,<br>        <span class="hljs-string">&#x27;LOCATION&#x27;</span>: <span class="hljs-string">&#x27;unique-snowflake&#x27;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>缓存LOCATION用来区分每个内存存储，如果只有一个本地内存缓存，可以忽略这个设置；但如果有多个的时候，需要至少给他们中一个赋予名字以区分他们。<br>注意每个进程都有它们自己的私有缓存实例，所以跨进陈缓存是不可能的，因此，本地内存缓存不是特别有效率的，建议只是在内部开发测时使用，不建议在生产环境中使用</p>
<h4 id="2-3-5虚拟缓存-开发时使用"><a href="#2-3-5虚拟缓存-开发时使用" class="headerlink" title="2.3.5虚拟缓存(开发时使用)"></a>2.3.5虚拟缓存(开发时使用)</h4><p>虚拟缓存，实际是没有缓存，只不过设置缓存时间，请求的时候一样会设置这个时间，但是服务器并没有缓存起来，这个在开发测试阶段，不希望缓存，发布之后则希望缓存，非常实用，到发布的时候，直接把dummy.DummyCache缓存真真的缓存方式即可，其他的无需修改代码</p>
<figure class="highlight roboconf"><table><tr><td class="code"><pre><code class="hljs roboconf">CACHES = &#123;<br>    &#x27;<span class="hljs-attribute">default&#x27;</span>: &#123;<br>        &#x27;BACKEND&#x27;: &#x27;django<span class="hljs-variable">.core</span><span class="hljs-variable">.cache</span><span class="hljs-variable">.backends</span><span class="hljs-variable">.dummy</span><span class="hljs-variable">.DummyCache</span>&#x27;,<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="2-3-6自定义缓存"><a href="#2-3-6自定义缓存" class="headerlink" title="2.3.6自定义缓存"></a>2.3.6自定义缓存</h4><p>配置参数来使用其他缓存  如Redis</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">CACHES</span> = &#123;<br>    <span class="hljs-string">&#x27;default&#x27;</span>: &#123;<br>        <span class="hljs-string">&#x27;BACKEND&#x27;</span>: <span class="hljs-string">&#x27;path.to.backend&#x27;</span>,<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="2-4缓存级别-本篇来自于于djang-book"><a href="#2-4缓存级别-本篇来自于于djang-book" class="headerlink" title="2.4缓存级别(本篇来自于于djang-book)"></a>2.4缓存级别(本篇来自于于djang-book)</h3><h4 id="2-4-1view级别缓存"><a href="#2-4-1view级别缓存" class="headerlink" title="2.4.1view级别缓存"></a>2.4.1view级别缓存</h4><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">from</span> django.views.decorators.cache <span class="hljs-keyword">import</span> cache_page<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">my_view</span>(<span class="hljs-params">request</span>):</span><br>    <span class="hljs-comment"># ...</span><br><br>my_view = cache_page(my_view, <span class="hljs-number">60</span> * <span class="hljs-number">15</span>)<br><br></code></pre></td></tr></table></figure>
<p>也可以使用</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-meta">@cache_page(<span class="hljs-params"><span class="hljs-number">60</span> * <span class="hljs-number">15</span></span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">my_view</span>(<span class="hljs-params">request</span>):</span><br>    <span class="hljs-comment"># ... </span><br></code></pre></td></tr></table></figure>

<p>cache_page 只接受一个参数： 以秒计的缓存超时时间。 （注意： 为了提高可读性，该参数被书写为 60 * 15 。 60 * 15 将被计算为 900 ，也就是说15 分钟乘以每分钟 60 秒。）</p>
<p>和站点缓存一样，视图缓存与 URL 无关。 如果多个 URL 指向同一视图，每个视图将会分别缓存。 继续 my_view 范例，如果 URLconf 如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">urlpatterns = (<span class="hljs-string">&#x27;&#x27;</span>,<br>    (<span class="hljs-string">r&#x27;^foo/(\d+)/$&#x27;</span>, my_view),<br>)<br></code></pre></td></tr></table></figure>

<h4 id="2-4-2-在-URLconf-中指定视图缓存"><a href="#2-4-2-在-URLconf-中指定视图缓存" class="headerlink" title="2.4.2 在 URLconf 中指定视图缓存"></a>2.4.2 在 URLconf 中指定视图缓存</h4><p>假设有不同的url指向同一个view但是只想让foo  url缓存，那么可以在 URLconf 中指定视图缓存。</p>
<p>把</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">urlpatterns = (<span class="hljs-string">&#x27;&#x27;</span>,<br>    (<span class="hljs-string">r&#x27;^foo/(\d+)/$&#x27;</span>, my_view),<br>)<br></code></pre></td></tr></table></figure>
<p>改为</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.views.decorators.cache <span class="hljs-keyword">import</span> cache_page<br><br>urlpatterns = (<span class="hljs-string">&#x27;&#x27;</span>,<br>    (<span class="hljs-string">r&#x27;^foo/(\d+)/$&#x27;</span>, cache_page(my_view, <span class="hljs-number">60</span> * <span class="hljs-number">15</span>)),<br>)<br></code></pre></td></tr></table></figure>
<p>即可完成</p>
<h4 id="2-4-3模板碎片缓存"><a href="#2-4-3模板碎片缓存" class="headerlink" title="2.4.3模板碎片缓存"></a>2.4.3模板碎片缓存</h4><p>你同样可以使用cache标签来缓存模板片段。 在模板的顶端附近加入</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html">&#123;% load cache %&#125;<br></code></pre></td></tr></table></figure>
<p>以通知模板存取缓存标签。</p>
<p>模板标签</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html">&#123;% cache %&#125;<br></code></pre></td></tr></table></figure>
<p>在给定的时间内缓存了块的内容。 它至少需要两个参数: 缓存超时时间（以秒计）和指定缓存片段的名称。 示例：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html">&#123;% load cache %&#125;<br>&#123;% cache 500 sidebar %&#125;<br>    .. sidebar ..<br>&#123;% endcache %&#125;<br></code></pre></td></tr></table></figure>
<p>有时你可能想缓存基于片段的动态内容的多份拷贝。 比如，你想为上一个例子的每个用户分别缓存侧边栏。 这样只需要给</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html">&#123;% cache %&#125;<br></code></pre></td></tr></table></figure>
<p>传递额外的参数以标识缓存片段。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html">&#123;% load cache %&#125;<br>&#123;% cache 500 sidebar request.user.username %&#125;<br>    .. sidebar for logged in user ..<br>&#123;% endcache %&#125;<br></code></pre></td></tr></table></figure>
<p>传递不止一个参数也是可行的。 简单地把参数传给</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html">&#123;% cache %&#125;。<br></code></pre></td></tr></table></figure>
<p>缓存超时时间可以作为模板变量，只要它可以解析为整数值。 例如，如果模板变量my_timeout值为600，那么以下两个例子是等价的。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html">&#123;% cache 600 sidebar %&#125; ... &#123;% endcache %&#125;<br>&#123;% cache my_timeout sidebar %&#125; ... &#123;% endcache %&#125;<br></code></pre></td></tr></table></figure>
<p>这个特性在避免模板重复方面非常有用。 可以把超时时间保存在变量里，然后在别的地方复用。</p>
<h4 id="2-4-4低层次缓存API"><a href="#2-4-4低层次缓存API" class="headerlink" title="2.4.4低层次缓存API"></a>2.4.4低层次缓存API</h4><p>有些时候，对整个经解析的页面进行缓存并不会给你带来太多好处，事实上可能会过犹不及。</p>
<p>比如说，也许你的站点所包含的一个视图依赖几个费时的查询，每隔一段时间结果就会发生变化。 在这种情况下，使用站点级缓存或者视图级缓存策略所提供的整页缓存并不是最理想的，因为你可能不会想对整个结果进行缓存（因为一些数据经常变化），但你仍然会想对很少变化的部分进行缓存。</p>
<p>针对这样的情况，Django提供了简单低级的缓存API。 你可以通过这个API，以任何你需要的粒度来缓存对象。 你可以对所有能够安全进行 pickle 处理的 Python 对象进行缓存： 字符串、字典和模型对象列表等等。 （查阅 Python 文档可以了解到更多关于 pickling 的信息。）</p>
<p>缓存模块django.core.cache拥有一个自动依据CACHE_BACKEND设置创建的django.core.cache对象。</p>
<blockquote>
<blockquote>
<blockquote>
<p>from django.core.cache import cache</p>
</blockquote>
</blockquote>
</blockquote>
<p>基本的接口是 set(key, value, timeout_seconds) 和 get(key) :</p>
<blockquote>
<blockquote>
<blockquote>
<p>cache.set(‘my_key’, ‘hello, world!’, 30)<br>cache.get(‘my_key’)<br>‘hello, world!’<br>timeout_seconds 参数是可选的, 并且默认为前面讲过的 CACHE_BACKEND 设置中的 timeout 参数.</p>
</blockquote>
</blockquote>
</blockquote>
<p>如果缓存中不存在该对象，那么cache.get()会返回None。</p>
<blockquote>
<blockquote>
<blockquote>
<p>#Wait 30 seconds for ‘my_key’ to expire…</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>cache.get(‘my_key’)<br>None</p>
</blockquote>
</blockquote>
</blockquote>
<p>我们不建议在缓存中保存 None 常量，因为你将无法区分你保存的 None 变量及由返回值 None 所标识的缓存未命中。</p>
<p>cache.get() 接受一个 缺省 参数。 它指定了当缓存中不存在该对象时所返回的值：</p>
<blockquote>
<blockquote>
<blockquote>
<p>cache.get(‘my_key’, ‘has expired’)<br>‘has expired’</p>
</blockquote>
</blockquote>
</blockquote>
<p>使用add()方法来新增一个原来没有的键值。 它接受的参数和set()一样，但是并不去尝试更新已经存在的键值。</p>
<blockquote>
<blockquote>
<blockquote>
<p>cache.set(‘add_key’, ‘Initial value’)<br>cache.add(‘add_key’, ‘New value’)<br>cache.get(‘add_key’)<br>‘Initial value’</p>
</blockquote>
</blockquote>
</blockquote>
<p>如果想确定add()是否成功添加了缓存值，你应该测试返回值。 成功返回True，失败返回False。</p>
<p>还有个get_many()接口。 get_many() 所返回的字典包括了你所请求的存在于缓存中且未超时的所有键值。</p>
<blockquote>
<blockquote>
<blockquote>
<p>cache.set(‘a’, 1)<br>cache.set(‘b’, 2)<br>cache.set(‘c’, 3)<br>cache.get_many([‘a’, ‘b’, ‘c’])<br>{‘a’: 1, ‘b’: 2, ‘c’: 3}</p>
</blockquote>
</blockquote>
</blockquote>
<p>最后,你可以用 cache.delete() 显式地删除关键字。</p>
<blockquote>
<blockquote>
<blockquote>
<p>cache.delete(‘a’)</p>
</blockquote>
</blockquote>
</blockquote>
<p>也可以使用incr()或者decr()来增加或者减少已经存在的键值。 默认情况下，增加或减少的值是1。可以用参数来制定其他值。 如果尝试增减不存在的键值会抛出ValueError。</p>
<blockquote>
<blockquote>
<blockquote>
<p>cache.set(‘num’, 1)<br>cache.incr(‘num’)<br>2<br>cache.incr(‘num’, 10)<br>12<br>cache.decr(‘num’)<br>11<br>cache.decr(‘num’, 5)<br>6</p>
</blockquote>
</blockquote>
</blockquote>
<p>注意<br>incr()/decr()方法不是原子操作。 在支持原子增减的缓存后端上（最著名的是memcached），增减操作才是原子的。 然而，如果后端并不原生支持增减操作，也可以通过取值/更新两步操作来实现。</p>
<h2 id="3-BACKEND缓存设置"><a href="#3-BACKEND缓存设置" class="headerlink" title="3 BACKEND缓存设置"></a>3 BACKEND缓存设置</h2><p>除了在服务器与浏览器设置缓存外，还可以在BACKEND设置缓存。<br>比如收藏数量，用户每点击一次收藏时，收藏量就+1.如果每次都写会数据库，不免数据量太大(而且存在单一行数据时，写锁优先于读锁，那么碰巧在写数据时，服务器要先等写完才可以进行读)，而且数据库还要求一致性。<br>而同时，浏览数并不要求保证一致性，只要大概准确就行了。<br>所以这时候，我们可以先将收藏数写入 redis，满足一定条件后，再回写数据库。每次都是+1,+1。当满足于10条或者100条时，就可以一起写入数据库。</p>
<h2 id="4-1使用示例"><a href="#4-1使用示例" class="headerlink" title="4.1使用示例"></a>4.1使用示例</h2><h3 id="模板碎片缓存"><a href="#模板碎片缓存" class="headerlink" title="模板碎片缓存"></a>模板碎片缓存</h3><p>在搭建一个项目时，打算使用缓存，会发现网页是酱子的<br><img    class="lazyload" data-original="https://github.com/so1n/so1n_blog_photo/blob/master/blog_photo/django%E4%B8%8E%E7%BC%93%E5%AD%98.jpeg?raw=true" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">示例</span><br>页面中有3个组件<br>组件1数据更新量最低，只要新加入的机构是以上城市或是类别外，这个组件的数据才会更新。<br>组件3的数据更新量第二低，由于都是通过统计点击量或者学习人数在进行排名，可能会半天或者一天才更新一次。<br>组件3由于有课程更新或者学习变化就要更新，所以更新周期可能在小时级别。<br>所以我们在设置缓存时不能整页统一缓存，而是要分开缓存。<br>如果这时候我们是通过一个view放回整个页面的话，就需要使用模板碎片缓存，为每个组件设置不同的缓存时间。</p>
<p>如果每个组件使用ajax控制的话，可以使用view级别的缓存，为每个view设置对应的缓存时间。</p>
<h3 id="被动过期缓存"><a href="#被动过期缓存" class="headerlink" title="被动过期缓存"></a>被动过期缓存</h3><p>上面的是使用主动过期缓存，除了主动过期缓存外，还可以使用被动过期缓存<br><img    class="lazyload" data-original="https://github.com/so1n/so1n_blog_photo/blob/master/blog_photo/django%E7%BC%93%E5%AD%982.png?raw=true" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">示例</span><br>图中是整个html一起加载的(未用ajax)。可以看出章节部分是短时间内改动比较少的，而评论是会经常改动的，如果这个资源不算热门的话(或者发布比较久，现在访问的比较少了)，评论的变动周期就会比较长，评论如果是用富文本或者markdowm渲染的话却会花费一些资源，这时候可以使用被动过去缓存。可以考虑在评论的models加上一个统计数量，取出评论时，向BACKEND缓存评论数量和评论的内容，每当有用户访问时，比较BACKEND缓存的评论数量和models的统计数量，如果一致则返回缓存内容，不一致则从Model重新生成数据并返回。</p>
<h2 id="附-http协议的缓存"><a href="#附-http协议的缓存" class="headerlink" title="附:http协议的缓存"></a><a href="http://www.cnblogs.com/TankXiao/archive/2012/11/28/2793365.html">附:http协议的缓存</a></h2>]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>django</tag>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title>基于django和celery的邮件异步发送(记录)</title>
    <url>/2017/10/21/21_Asynchronous%20sending%20of%20mail%20based%20on%20django%20and%20celery/</url>
    <content><![CDATA[<h2 id="前记"><a href="#前记" class="headerlink" title="前记"></a>前记</h2><p>在验证用户邮箱时，需要发送一个链接给用户的邮箱，让用户点击以确保用户输入的邮箱是他本人所有。<br>但是email是由提供商进行发送的，我们需要先把请求发给提供商再由提供商发送，如果不使用异步发送，在用户点击按钮后，必须等到后台收到提供商的返回结果，我们才能把数据返回给用户。</p>
<span id="more"></span>

<h2 id="1-Celery介绍"><a href="#1-Celery介绍" class="headerlink" title="1.Celery介绍"></a>1.Celery介绍</h2><p>由于使用同步发送带来了许多麻烦，所以可以考虑用任务队列进行异步发送，在python中的Celery库发挥的就是这个作用，而且Celery接口简单，开发容易，5分钟就写出了一个异步发送邮件的服务。Celery本身不含消息服务，它使用第三方消息服务来传递任务，目前，Celery支持的消息服务有RabbitMQ、Redis甚至是数据库。<br><a href="http://python.jobbole.com/87238/">更多介绍以及入门</a></p>
<h2 id="2-与django结合异步发送邮件的服务"><a href="#2-与django结合异步发送邮件的服务" class="headerlink" title="2.与django结合异步发送邮件的服务"></a>2.与django结合异步发送邮件的服务</h2><p>假设之前已经完成了email发送逻辑（同步方式）</p>
<h3 id="2-1setting-py设置"><a href="#2-1setting-py设置" class="headerlink" title="2.1setting.py设置"></a>2.1setting.py设置</h3><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python">EMAIL_HOST = <span class="hljs-string">&#x27;smtp.163.com&#x27;</span>                <span class="hljs-comment"># 服务提供商</span><br>EMAIL_PORT = <span class="hljs-number">25</span>                            <span class="hljs-comment"># 端口</span><br>EMAIL_HOST_USER = <span class="hljs-string">&quot;***&quot;</span>                    <span class="hljs-comment"># 用户名</span><br>EMAIL_HOST_PASSWORD = <span class="hljs-string">&quot;***&quot;</span>                <span class="hljs-comment"># 密码</span><br>EMAIL_USE_TLS = <span class="hljs-literal">False</span>                      <span class="hljs-comment"># False就好了</span><br>EMAIL_FROM = <span class="hljs-string">&quot;***&quot;</span>                         <span class="hljs-comment"># 来源名字</span><br><br><br><span class="hljs-comment">###配置Broker</span><br>BROKER_URL = <span class="hljs-string">&#x27;redis://127.0.0.1:6379/0&#x27;</span>    <br>BROKER_TRANSPORT = <span class="hljs-string">&#x27;redis&#x27;</span><br></code></pre></td></tr></table></figure>

<h3 id="2-2celery文件"><a href="#2-2celery文件" class="headerlink" title="2.2celery文件"></a>2.2celery文件</h3><p>在自己的project文件夹内（与setting.py同级）<br>创建celery.py文件，代码如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> django<br><br><span class="hljs-keyword">from</span> celery <span class="hljs-keyword">import</span> Celery<br><span class="hljs-keyword">from</span> django.conf <span class="hljs-keyword">import</span> settings<br><br>os.environ.setdefault(<span class="hljs-string">&#x27;DJANGO_SETTINGS_MODULE&#x27;</span>, <span class="hljs-string">&#x27;django_project.settings&#x27;</span>)   <span class="hljs-comment"># django_project 为自己的project名</span><br>django.setup()<br><br>app = Celery(<span class="hljs-string">&#x27;django_project&#x27;</span>)            <span class="hljs-comment"># 定义自己的app名字后面调用需要用到</span><br><br>app.config_from_object(<span class="hljs-string">&#x27;django.conf:settings&#x27;</span>)<br>app.autodiscover_tasks(<span class="hljs-keyword">lambda</span>: settings.INSTALLED_APPS)<br><br></code></pre></td></tr></table></figure>

<h3 id="2-3发送邮件的py"><a href="#2-3发送邮件的py" class="headerlink" title="2.3发送邮件的py"></a>2.3发送邮件的py</h3><p>主要是从celery文件导入app并在自己发送的函数上面使用@app.task装饰器<br>其他的全是我自己的发送邮件规则</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">from</span> random <span class="hljs-keyword">import</span> Random<br><br><br><span class="hljs-keyword">from</span> django.core.mail <span class="hljs-keyword">import</span> send_mail<br><span class="hljs-keyword">from</span> django_project.settings <span class="hljs-keyword">import</span> EMAIL_FROM<br><br><span class="hljs-keyword">from</span> users.models <span class="hljs-keyword">import</span> EmailVerifyRecord<br><span class="hljs-keyword">from</span> django_project.celery <span class="hljs-keyword">import</span> app<br><br><br><span class="hljs-meta">@app.task</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">send_register_email</span>(<span class="hljs-params">email, send_type=<span class="hljs-string">&quot;register&quot;</span>, num=<span class="hljs-number">16</span></span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    发送注册邮件时的链接</span><br><span class="hljs-string">    :param email: email</span><br><span class="hljs-string">    :param send_type: &#x27;register&#x27;or&#x27;forget&#x27;</span><br><span class="hljs-string">    :return: </span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    email_record = EmailVerifyRecord()<br>    code_str = random_str(num)<br>    email_record.code = code_str<br>    email_record.email = email<br>    email_record.send_type = send_type<br>    email_record.save()<br><br>    <span class="hljs-keyword">if</span> send_type == <span class="hljs-string">&#x27;register&#x27;</span>:<br>        email_title = <span class="hljs-string">&quot;注册激活链接&quot;</span><br>        email_body = <span class="hljs-string">&quot;请点击下面的链接激活你的账号：http://127.0.0.1:8000/active/&#123;0&#125;&quot;</span>.<span class="hljs-built_in">format</span>(code_str)<br><br>        send_mail(email_title, email_body, EMAIL_FROM, [email])<br><br>    <span class="hljs-keyword">elif</span> send_type == <span class="hljs-string">&#x27;forget&#x27;</span>:<br>        email_title = <span class="hljs-string">&quot;重置密码链接&quot;</span><br>        email_body = <span class="hljs-string">&quot;请点击下面的链接重置你的密码：http://127.0.0.1:8000/reset/&#123;0&#125;&quot;</span>.<span class="hljs-built_in">format</span>(code_str)<br><br>        send_mail(email_title, email_body, EMAIL_FROM, [email])<br><br>    <span class="hljs-keyword">elif</span> send_type == <span class="hljs-string">&#x27;update_email&#x27;</span>:<br>        email_title = <span class="hljs-string">&quot;邮箱修改验证码&quot;</span><br>        email_body = <span class="hljs-string">&quot;验证码为：&#123;0&#125;&quot;</span>.<span class="hljs-built_in">format</span>(code_str)<br><br>        send_mail(email_title, email_body, EMAIL_FROM, [email])<br><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">pass</span><br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">random_str</span>(<span class="hljs-params">random_length=<span class="hljs-number">8</span></span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    随机字符串生成</span><br><span class="hljs-string">    :param random_length: 生成字符串长度(init)</span><br><span class="hljs-string">    :return: 返回字符串(str)</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    code_str = <span class="hljs-string">&#x27;&#x27;</span><br>    generate_random_str = [<span class="hljs-built_in">chr</span>(i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">65</span>, <span class="hljs-number">91</span>)] + \<br>                          [<span class="hljs-built_in">chr</span>(i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">97</span>, <span class="hljs-number">123</span>)] + \<br>                          [<span class="hljs-built_in">str</span>(i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>)]<br>    chars = <span class="hljs-string">&#x27;&#x27;</span>.join(generate_random_str)<br>    length = <span class="hljs-built_in">len</span>(chars) - <span class="hljs-number">1</span><br>    random = Random()<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(random_length):<br>        code_str += chars[random.randint(<span class="hljs-number">0</span>, length)]<br>    <span class="hljs-keyword">return</span> code_str<br><br><br></code></pre></td></tr></table></figure>

<h3 id="2-4view"><a href="#2-4view" class="headerlink" title="2.4view"></a>2.4view</h3><p>将原本发送邮件的函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python">send_register_email(email, <span class="hljs-string">&quot;update_email&quot;</span>, num=<span class="hljs-number">4</span>)<br></code></pre></td></tr></table></figure>
<p>改为</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python">send_register_email.delay(email, <span class="hljs-string">&quot;update_email&quot;</span>, num=<span class="hljs-number">4</span>)<br></code></pre></td></tr></table></figure>

<h3 id="2-5运行celery服务"><a href="#2-5运行celery服务" class="headerlink" title="2.5运行celery服务"></a>2.5运行celery服务</h3><p>Broker设置为redis所以必须先启动</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql">service redis <span class="hljs-keyword">start</span><br></code></pre></td></tr></table></figure>
<p>检查是否启动并监听端口</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">ps</span> aux|<span class="hljs-keyword">grep</span> redis<br></code></pre></td></tr></table></figure>
<p>在celery所在目录输入命令启动celery</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">celery</span> -A (自己定义的名字) worker -l <span class="hljs-literal">debug</span><br></code></pre></td></tr></table></figure>

<h3 id="2-6测试"><a href="#2-6测试" class="headerlink" title="2.6测试"></a>2.6测试</h3><p>发送时celery服务的提示，显示succeeded<br><img    class="lazyload" data-original="https://github.com/so1n/so1n_blog_photo/blob/master/blog_photo/celery%E5%8F%91%E9%82%AE%E4%BB%B611.png?raw=true" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">image</span></p>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>django</tag>
        <tag>celery</tag>
      </tags>
  </entry>
  <entry>
    <title>xadmin的使用</title>
    <url>/2017/10/21/23_use_xadmin/</url>
    <content><![CDATA[<h2 id="前记"><a href="#前记" class="headerlink" title="前记"></a>前记</h2><p>Django自身带的admin功能众多，但基于admin开发的xadmin功能更完善，开发也简便且美观</p>
<span id="more"></span>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>在seeting.py的INSTALLED_APPS引入xadmin</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">INSTALLED_APPS = [<br>    <span class="hljs-string">&#x27;django.contrib.admin&#x27;</span>,<br>    <span class="hljs-string">&#x27;django.contrib.auth&#x27;</span>,<br>    <span class="hljs-string">&#x27;django.contrib.contenttypes&#x27;</span>,<br>    <span class="hljs-string">&#x27;django.contrib.sessions&#x27;</span>,<br>    <span class="hljs-string">&#x27;django.contrib.messages&#x27;</span>,<br>    <span class="hljs-string">&#x27;django.contrib.staticfiles&#x27;</span>,<br>    <span class="hljs-string">&#x27;users&#x27;</span>,<br>    <span class="hljs-string">&#x27;xadmin&#x27;</span>,<br>]<br></code></pre></td></tr></table></figure>
<p>配置url</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> xadmin<br><br>urlpatterns = [<br>    url(<span class="hljs-string">r&#x27;^admin/&#x27;</span>, xadmin.site.urls),<br>]<br></code></pre></td></tr></table></figure>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h3><p>新建一个.py文件，一般放在uesr app里面<br>配置页面</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> xadmin<br><br><span class="hljs-comment"># 主题设置</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseMyAdminView</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    enable_themes 启动更改主题</span><br><span class="hljs-string">    use_bootswatch 启用网上主题</span><br><span class="hljs-string">    &#x27;&#x27;&#x27;</span><br>    enable_themes = <span class="hljs-literal">True</span><br>    use_bootswatch = <span class="hljs-literal">True</span><br><br><span class="hljs-comment"># 页面设置</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GlobalSettings</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    site_title 左上角名称</span><br><span class="hljs-string">    site_footer 底部名称</span><br><span class="hljs-string">    menu_style 更改左边样式</span><br><span class="hljs-string">    &#x27;&#x27;&#x27;</span><br>    site_title = <span class="hljs-string">&quot;学习网后台管理系统&quot;</span><br>    site_footer = <span class="hljs-string">&quot;学习网&quot;</span><br>    menu_style = <span class="hljs-string">&quot;accordion&quot;</span><br><br><span class="hljs-comment"># 注册函数</span><br>xadmin.site.register(views.BaseAdminView, BaseMyAdminView)<br>xadmin.site.register(views.CommAdminView, GlobalSettings)<br></code></pre></td></tr></table></figure>

<h3 id="2-定义自己的model在后台的显示"><a href="#2-定义自己的model在后台的显示" class="headerlink" title="2.定义自己的model在后台的显示"></a>2.定义自己的model在后台的显示</h3><p>使用xadmin可以非常方便的定义我们的后台管理，在同样的自己定义的app文件增加如下代码:<br>一个简单的栗子</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 引入自己的model</span><br><span class="hljs-keyword">from</span> .models <span class="hljs-keyword">import</span> EmailVerifyRecord<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EmailVerifyRecordAdmin</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    list_display = [<span class="hljs-string">&#x27;email&#x27;</span>, <span class="hljs-string">&#x27;code&#x27;</span>, <span class="hljs-string">&#x27;send_type&#x27;</span>, <span class="hljs-string">&#x27;send_time&#x27;</span>]    <span class="hljs-comment"># 选择需要显示的数据</span><br>    search_fields = [<span class="hljs-string">&#x27;email&#x27;</span>, <span class="hljs-string">&#x27;code&#x27;</span>, <span class="hljs-string">&#x27;send_type&#x27;</span>]                <span class="hljs-comment"># 选择可以搜索的数据</span><br>    list_filter = [<span class="hljs-string">&#x27;email&#x27;</span>, <span class="hljs-string">&#x27;code&#x27;</span>, <span class="hljs-string">&#x27;send_type&#x27;</span>, <span class="hljs-string">&#x27;send_time&#x27;</span>]     <span class="hljs-comment"># 选择可以过滤的数据</span><br>    model_icon = <span class="hljs-string">&#x27;fa fa-address-book-o&#x27;</span>   <span class="hljs-comment"># 选择该models在左边的图标显示，可以从该网页选择图标https://fontawesome.com/icons?d=gallery</span><br><br><br><br><br><span class="hljs-comment"># 同样进行注册</span><br>xadmin.site.register(EmailVerifyRecord, EmailVerifyRecordAdmin)<br></code></pre></td></tr></table></figure>
<h4 id="1-过滤器"><a href="#1-过滤器" class="headerlink" title="1.过滤器"></a>1.过滤器</h4><p>过滤器除了如上的list_filter，还有其他属性<br>在 Model OptionClass 中设置以下属性:</p>
<ul>
<li>list_filter 属性:<br>  该属性指定可以过滤的列的名字, 系统会自动生成搜索器</li>
<li>search_fields 属性:<br>  属性指定可以通过搜索框搜索的数据列的名字, 搜索框搜索使用的是模糊查找的方式, 一般用来搜素名字等字符串字段</li>
<li>free_query_filter 属性:<br>  默认为 True , 指定是否可以自由搜索. 如果开启自有搜索, 用户可以通过 url 参数来进行特定的搜索, 例如:<br>  <a href="http://xxx.com/xadmin/auth/user/?name__contains=tony">http://xxx.com/xadmin/auth/user/?name__contains=tony</a><h4 id="2-图表"><a href="#2-图表" class="headerlink" title="2.图表"></a>2.图表</h4>在 Model OptionClass 中设定 data_charts 属性, 该属性为 dict 类型, key 是图表的标示名称, value 是图表的具体设置属性. 使用示例:<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RecordAdmin</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    data_charts = &#123;<br>        <span class="hljs-string">&quot;user_count&quot;</span>: &#123;<span class="hljs-string">&#x27;title&#x27;</span>: <span class="hljs-string">u&quot;User Report&quot;</span>, <span class="hljs-string">&quot;x-field&quot;</span>: <span class="hljs-string">&quot;date&quot;</span>, <span class="hljs-string">&quot;y-field&quot;</span>: (<span class="hljs-string">&quot;user_count&quot;</span>, <span class="hljs-string">&quot;view_count&quot;</span>), <span class="hljs-string">&quot;order&quot;</span>: (<span class="hljs-string">&#x27;date&#x27;</span>,)&#125;,<br>        <span class="hljs-string">&quot;avg_count&quot;</span>: &#123;<span class="hljs-string">&#x27;title&#x27;</span>: <span class="hljs-string">u&quot;Avg Report&quot;</span>, <span class="hljs-string">&quot;x-field&quot;</span>: <span class="hljs-string">&quot;date&quot;</span>, <span class="hljs-string">&quot;y-field&quot;</span>: (<span class="hljs-string">&#x27;avg_count&#x27;</span>,), <span class="hljs-string">&quot;order&quot;</span>: (<span class="hljs-string">&#x27;date&#x27;</span>,)&#125;<br>    &#125;<br></code></pre></td></tr></table></figure>
图表的主要属性为:</li>
<li>title : 图表的显示名称</li>
<li>x-field : 图表的 X 轴数据列, 一般是日期, 时间等</li>
<li>y-field : 图表的 Y 轴数据列, 该项是一个 list, 可以同时设定多个列, 这样多个列的数据会在同一个图表中显示</li>
<li>order : 排序信息, 如果不写则使用数据列表的排序</li>
</ul>
<h4 id="3-书签"><a href="#3-书签" class="headerlink" title="3.书签"></a>3.书签</h4><p>书签：记录数据列表页面特定的数据过滤, 排序等结果. 添加的书签还可以在首页仪表盘中作为小组件添加</p>
<p>在 Model OptionClass 中设定如下属性:</p>
<ul>
<li>show_bookmarks 属性:<br>  设置是否开启书签功能, 默认为 True</li>
<li>list_bookmarks 属性:<br>  设置默认的书签. 用户可以在列表页面添加自己的书签, 你也可以实现设定好一些书签, 使用实例如下:  <figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserAdmin</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    list_bookmarks = [&#123;<br>        <span class="hljs-string">&#x27;title&#x27;</span>: <span class="hljs-string">&quot;Female&quot;</span>,         <span class="hljs-comment"># 书签的名称, 显示在书签菜单中</span><br>        <span class="hljs-string">&#x27;query&#x27;</span>: &#123;<span class="hljs-string">&#x27;gender&#x27;</span>: <span class="hljs-literal">True</span>&#125;, <span class="hljs-comment"># 过滤参数, 是标准的 queryset 过滤</span><br>        <span class="hljs-string">&#x27;order&#x27;</span>: (<span class="hljs-string">&#x27;-age&#x27;</span>),         <span class="hljs-comment"># 排序参数</span><br>        <span class="hljs-string">&#x27;cols&#x27;</span>: (<span class="hljs-string">&#x27;first_name&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>, <span class="hljs-string">&#x27;phones&#x27;</span>),  <span class="hljs-comment"># 显示的列</span><br>        <span class="hljs-string">&#x27;search&#x27;</span>: <span class="hljs-string">&#x27;Tom&#x27;</span>    <span class="hljs-comment"># 搜索参数, 指定搜索的内容</span><br>        &#125;, &#123;...&#125;<br>    ]<br></code></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="4-导出选项"><a href="#4-导出选项" class="headerlink" title="4.导出选项"></a>4.导出选项</h4><p>ps：如果想要导出 Excel 数据, 需要安装 xlwt.</p>
<p>默认情况下, xadmin 会提供 Excel, CSV, XML, json 四种格式的数据导出. 可以通过设置 OptionClass 的 list_export 属性来指定使用哪些导出格式 (四种各使用分别用 xls, csv, xml, json 表示), 或是将 list_export 设置为 None 来禁用数据导出功能. 示例如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyModelAdmin</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    list_export = (<span class="hljs-string">&#x27;xls&#x27;</span>, <span class="hljs-string">&#x27;xml&#x27;</span>, <span class="hljs-string">&#x27;json&#x27;</span>)<br></code></pre></td></tr></table></figure>

<h4 id="5-定时刷新"><a href="#5-定时刷新" class="headerlink" title="5.定时刷新"></a>5.定时刷新</h4><p>该插件在数据列表页面提供了定时刷新功能, 对于需要实时刷新列表页面查看即时数据的情况非常有用.</p>
<p>设置 OptionClass 的 refresh_times 属性即可实现自动刷新. refresh_times 属性是存有刷新时间的数组. xadmin 默认不开启该插件.示例如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyModelAdmin</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span> <br>    <span class="hljs-comment"># 这会显示一个下拉列表, 用户可以选择3秒或5秒刷新一次页面.</span><br>    refresh_times = (<span class="hljs-number">3</span>, <span class="hljs-number">5</span>)<br></code></pre></td></tr></table></figure>

<h4 id="6-数据详情"><a href="#6-数据详情" class="headerlink" title="6.数据详情"></a>6.数据详情</h4><p>该插件可以在列表页中显示相关字段的详细信息, 使用 Ajax 在列表页中显示.（右边有个感叹号）</p>
<p>使用该插件主要设置 OptionClass 的 show_detail_fields, show_all_rel_details 两个属性. show_detail_fields 属性设置哪些字段要显示详细信息, show_all_rel_details 属性设置时候自动显示所有关联字段的详细信息, 该属性默认为 True. 示例如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyModelAdmin</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <br>    show_detail_fields = [<span class="hljs-string">&#x27;group&#x27;</span>, <span class="hljs-string">&#x27;father&#x27;</span>, ...]<br></code></pre></td></tr></table></figure>

<h4 id="7-数据即时编辑"><a href="#7-数据即时编辑" class="headerlink" title="7.数据即时编辑"></a>7.数据即时编辑</h4><p>该插件可以在列表页中即时编辑某字段的值, 使用 Ajax 技术, 无需提交或刷新页面即可完成数据的修改, 对于需要频繁修改的字段(如: 状态)相当有用.</p>
<p>使用该插件主要设置 OptionClass 的 list_editable 属性. list_editable 属性设置哪些字段需要即时修改功能. 示例如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyModelAdmin</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <br>    list_editable = [<span class="hljs-string">&#x27;price&#x27;</span>, <span class="hljs-string">&#x27;status&#x27;</span>, ...]<br></code></pre></td></tr></table></figure>

<h4 id="8-设置只读字段"><a href="#8-设置只读字段" class="headerlink" title="8.设置只读字段"></a>8.设置只读字段</h4><p> 在使用xadmin的时候，ModelAdmin默认只有对于model的增删改查，但是总是有些字段是不希望用户来编辑的。而 readonly_fields 设置之后不管是admin还是其他用户都会变成只读，而我们通常只是想限制普通用户。 这时我们就可以通过重写 get_readonly_fields 方法来实现对特定用户的只读显示。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserInfoAdmin</span>():</span><br> <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_readonly_fields</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;  重新定义此函数，限制普通用户所能修改的字段  &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> self.user.is_superuser:<br>            self.readonly_fields = []<br>        <span class="hljs-keyword">return</span> self.readonly_fields<br>     <br>    readonly_fields = (<span class="hljs-string">&#x27;user_email&#x27;</span>,)<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>django</tag>
        <tag>xadmin</tag>
      </tags>
  </entry>
  <entry>
    <title>学习网开发</title>
    <url>/2017/10/21/p2/</url>
    <content><![CDATA[<h2 id="前记"><a href="#前记" class="headerlink" title="前记"></a>前记</h2><p>升级版的增删改查项目，并使用xadmin来替代django自带的admin为后台</p>
<span id="more"></span>

<h2 id="github"><a href="#github" class="headerlink" title="github"></a>github</h2><p><a href="https://github.com/so1n/Django_project/tree/master/project2">代码仓</a></p>
<h2 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h2><p>学生可以通过机构，老师或课程进入学习课程。</p>
<ul>
<li>用户登录设计<ul>
<li>异步发送邮件</li>
</ul>
</li>
<li>缓存设计</li>
<li>后台管理</li>
</ul>
<h2 id="new"><a href="#new" class="headerlink" title="new"></a>new</h2><h3 id="缓存设计"><a href="#缓存设计" class="headerlink" title="缓存设计"></a>缓存设计</h3><p>篇幅稍长，<a href="/2017/10/21/20b2/#3-1%E4%B8%80%E4%B8%AA%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B">点击跳转</a></p>
<h3 id="异步发送邮件"><a href="#异步发送邮件" class="headerlink" title="异步发送邮件"></a>异步发送邮件</h3><p>篇幅稍长，<a href="/2017/10/21/20b1/">点击跳转</a></p>
<h3 id="xadmin"><a href="#xadmin" class="headerlink" title="xadmin"></a>xadmin</h3><p>篇幅稍长，<a href="/2017/10/21/20b3/">点击跳转</a></p>
<h3 id="模板使用"><a href="#模板使用" class="headerlink" title="模板使用"></a>模板使用</h3><h4 id="for循环里面的自增"><a href="#for循环里面的自增" class="headerlink" title="for循环里面的自增"></a>for循环里面的自增</h4><figure class="highlight handlebars"><table><tr><td class="code"><pre><code class="hljs handlebars"><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">forloop.counter</span>&#125;&#125;</span><br><span class="xml">实现for里面数字递增</span><br><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">forloop.counter0</span>&#125;&#125;</span><br><span class="xml">则从0开始递增</span><br></code></pre></td></tr></table></figure>
<h4 id="显示model的带有choice字段"><a href="#显示model的带有choice字段" class="headerlink" title="显示model的带有choice字段"></a>显示model的带有choice字段</h4><p>models 例如degree中有choice(1,名字)<br>在模板中要输入get_degree_display 才会显示  名字<br>如果输入degree 只会显示1</p>
<h4 id="调用外键数据"><a href="#调用外键数据" class="headerlink" title="调用外键数据"></a>调用外键数据</h4><p>***_set可以反向调用以自己为外键的数据库</p>
<h4 id="导航块的active"><a href="#导航块的active" class="headerlink" title="导航块的active"></a>导航块的active</h4><p>通过request.path判断当前url是否等于我们要的url如果是就付于active。<br>如果是首页则使用’/‘就可以了，其他的需要用slice获取前几位数。<br>需要注意的是slice获取的是包有前面的’/‘却没包含后面的’/‘,如’/course’</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs HTML"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> &#123;% <span class="hljs-attr">if</span> <span class="hljs-attr">request.path</span> == <span class="hljs-string">&#x27;/&#x27;</span> %&#125;<span class="hljs-attr">class</span>=<span class="hljs-string">&quot;active&quot;</span>&#123;% <span class="hljs-attr">endif</span> %&#125;&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;&#123;% url &#x27;index&#x27; %&#125;&quot;</span>&gt;</span>首页<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">li</span> &#123;% <span class="hljs-attr">if</span> <span class="hljs-attr">request.path</span>|<span class="hljs-attr">slice:</span>&#x27;<span class="hljs-attr">7</span>&#x27; == <span class="hljs-string">&#x27;/course&#x27;</span> %&#125;<span class="hljs-attr">class</span>=<span class="hljs-string">&quot;active&quot;</span>&#123;% <span class="hljs-attr">endif</span> %&#125;&gt;</span><br></code></pre></td></tr></table></figure>

<h3 id="django-pure-pagination的使用"><a href="#django-pure-pagination的使用" class="headerlink" title="django pure pagination的使用"></a>django pure pagination的使用</h3><p>view的修改<br>将从数据库查询到的数据和获取到的page放入Paginator中,并返回给html</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrgView</span>(<span class="hljs-params">View</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    课程机构列表</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get</span>(<span class="hljs-params">self, request</span>):</span><br><br>        all_orgs = CourseOrg.objects.<span class="hljs-built_in">all</span>()<br><br>        <span class="hljs-comment">#分页</span><br>        <span class="hljs-keyword">try</span>:<br>            page = request.GET.get(<span class="hljs-string">&#x27;page&#x27;</span>, <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">except</span> PageNotAnInteger:<br>            page = <span class="hljs-number">1</span><br><br>        <span class="hljs-comment">#第二个的参数为每页显示多少数量</span><br>        p = Paginator(all_orgs, <span class="hljs-number">10</span>, request=request)<br>        orgs = p.page(page)<br><br>        <span class="hljs-keyword">return</span> render(request, <span class="hljs-string">&quot;org-list.html&quot;</span>, &#123;<br>            <span class="hljs-string">&quot;all_orgs&quot;</span>: orgs,<br>        &#125;)<br></code></pre></td></tr></table></figure>
<p>HTML中原for循环</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs HTML">&#123;% for course_org in all_orgs %&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs HTML">&#123;% for course_org in all_orgs.object_list %&#125;<br></code></pre></td></tr></table></figure>
<p>html中分页的组件改为</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs HTML"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;pageturn&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;pagelist&quot;</span>&gt;</span><br>    &#123;% if all_orgs.has_previous %&#125;<br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;long&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;?&#123;&#123; all_orgs.previous_page_number.querystring &#125;&#125;&quot;</span>&gt;</span>上一页<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    &#123;% endif %&#125;<br><br>    &#123;% for page in all_orgs.pages %&#125;<br>        &#123;% if page %&#125;<br>            &#123;% ifequal page all_orgs.number %&#125;<br>                <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;active&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span>&#123;&#123; page &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>            &#123;% else %&#125;<br>                <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;page&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;?&#123;&#123; page.querystring &#125;&#125;&quot;</span>&gt;</span>&#123;&#123; page &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>            &#123;% endifequal %&#125;<br>        &#123;% else %&#125;<br>            <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;none&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>        &#123;% endif %&#125;<br>    &#123;% endfor %&#125;<br>    &#123;% if all_orgs.has_next %&#125;<br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;long&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;?&#123;&#123; all_orgs.next_page_number.querystring &#125;&#125;&quot;</span>&gt;</span>下一页<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>    &#123;% endif %&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h2 id="坑"><a href="#坑" class="headerlink" title="坑"></a>坑</h2><h3 id="数据库使用"><a href="#数据库使用" class="headerlink" title="数据库使用"></a>数据库使用</h3><p>在project的__init__文件添加</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pymysql<br>pymysql.install_as_MySQLdb()<br></code></pre></td></tr></table></figure>
<p>后可以使用数据库</p>
<h3 id="定义自己的user表"><a href="#定义自己的user表" class="headerlink" title="定义自己的user表"></a>定义自己的user表</h3><p>定义自己的user表时，先生成表再，AUTH_USER_MODEL = “users.UserProfile”指定自己的user表，不然django会报找不到外键的错。</p>
<p>原因:在models.py中定义了一个User表，此表继承django.contrib.auth中的User表。python manage.py migrate在建表的过程中先创建了我在models.py 中创建的User表，这样问题就来了，找不到父类的表，就出现can not add foreign key constraint 这个错误。所以，先保证django.contrib.auth中的user表建立，然后在创建自己定义的user表就可以了</p>
<p>也可以删除所有表除了auth_user，还有删除migration所有类型0001_initial.py文件。再重新生成表</p>
<h3 id="xadmin的版本问题"><a href="#xadmin的版本问题" class="headerlink" title="xadmin的版本问题"></a>xadmin的版本问题</h3><p>xadmin 有多个版本，由于我使用django 1.11, 代码仓关于1.11的分支已经删除了，所以重新找了一个<br><a href="https://github.com/nocmt/Xadmin1.11.x/archive/master.zip">https://github.com/nocmt/Xadmin1.11.x/archive/master.zip</a><br>版本支持django 1.11</p>
<h3 id="MEDIA-URL空值"><a href="#MEDIA-URL空值" class="headerlink" title="MEDIA_URL空值"></a>MEDIA_URL空值</h3><p>做如下处理可以防止</p>
<figure class="highlight handlebars"><table><tr><td class="code"><pre><code class="hljs handlebars"><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">MEDIA_URL</span>&#125;&#125;</span><br></code></pre></td></tr></table></figure>
<p>空值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">TEMPLATES = [<br>    &#123;<br>        <span class="hljs-string">&#x27;BACKEND&#x27;</span>: <span class="hljs-string">&#x27;django.template.backends.django.DjangoTemplates&#x27;</span>,<br>        <span class="hljs-string">&#x27;DIRS&#x27;</span>: [os.path.join(BASE_DIR,<span class="hljs-string">&#x27;templates&#x27;</span>)],<br>        <span class="hljs-string">&#x27;APP_DIRS&#x27;</span>: <span class="hljs-literal">True</span>,<br>        <span class="hljs-string">&#x27;OPTIONS&#x27;</span>: &#123;<br>            <span class="hljs-string">&#x27;context_processors&#x27;</span>: [<br>                <span class="hljs-string">&#x27;django.template.context_processors.debug&#x27;</span>,<br>                <span class="hljs-string">&#x27;django.template.context_processors.request&#x27;</span>,<br>                <span class="hljs-string">&#x27;django.contrib.auth.context_processors.auth&#x27;</span>,<br>                <span class="hljs-string">&#x27;django.contrib.messages.context_processors.messages&#x27;</span>,<br>                <span class="hljs-string">&#x27;django.template.context_processors.media&#x27;</span>,添加这行或者下面一行<br>                <span class="hljs-comment">#&#x27;django.core.context_processors.media&#x27;,python3会报错</span><br>            ],<br>        &#125;,<br>    &#125;,<br>]<br></code></pre></td></tr></table></figure>

<h3 id="限制网页需要登录的用户访问"><a href="#限制网页需要登录的用户访问" class="headerlink" title="限制网页需要登录的用户访问"></a>限制网页需要登录的用户访问</h3><p>在django中限制用户需要登录才能访问某些页面时可以自己在django_project定义如下.py文件</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.contrib.auth.decorators <span class="hljs-keyword">import</span> login_required<br><span class="hljs-keyword">from</span> django.utils.decorators <span class="hljs-keyword">import</span> method_decorator<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginRequiredMixin</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    验证是否登录（需要登录的页面可以配置该函数）</span><br><span class="hljs-string">    &#x27;&#x27;&#x27;</span><br><span class="hljs-meta">    @method_decorator(<span class="hljs-params">login_required(<span class="hljs-params">login_url=<span class="hljs-string">&#x27;/login/&#x27;</span></span>)</span>)</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dispatch</span>(<span class="hljs-params">self, request, *args, **kwargs</span>):</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>(LoginRequiredMixin, self).dispatch(request, *args, **kwargs)<br></code></pre></td></tr></table></figure>
<p>然后在页面对应的view 类视图函数 放入LoginRequiredMixin</p>
<h3 id="models-form验证数据"><a href="#models-form验证数据" class="headerlink" title="models.form验证数据"></a>models.form验证数据</h3><p>使用models.form来验证并取数据时，要确保要获取的数据的html的id和自己定义的model名称要对应，不然clean_data取不了数据，会认为数据不通过</p>
<h3 id="不使用-Login-required的登录跳转"><a href="#不使用-Login-required的登录跳转" class="headerlink" title="不使用@Login_required的登录跳转"></a>不使用@Login_required的登录跳转</h3><p>@Login_required有些坑，在不考虑使用@Login_required可以通过以下方法设置跳转</p>
<p>login页面的html的form写入以下代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs HTML"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;hidden&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;next_url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;&#123;&#123; next_url &#125;&#125;&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>login view函数设置</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginView</span>(<span class="hljs-params">View</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    LoginForm验证数据(./forms.py)</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">post</span>(<span class="hljs-params">self, request</span>):</span><br>        login_from = LoginForm(request.POST)<br>        <span class="hljs-keyword">if</span> login_from.is_valid():<br>            user_name = request.POST.get(<span class="hljs-string">&quot;username&quot;</span>, <span class="hljs-string">&quot;&quot;</span>)<br>            pass_word = request.POST.get(<span class="hljs-string">&quot;password&quot;</span>, <span class="hljs-string">&quot;&quot;</span>)<br> +          next_url = request.POST.get(<span class="hljs-string">&quot;next_url&quot;</span>, <span class="hljs-string">&quot;&quot;</span>)      <br>            user = authenticate(username=user_name, password=pass_word)<br>            <span class="hljs-keyword">if</span> user:         <span class="hljs-comment">#用户是否存在</span><br>                <span class="hljs-keyword">if</span> user.is_active:           <span class="hljs-comment">#用户是否处于激活状态</span><br>                    login(request, user)<br> +                  <span class="hljs-keyword">if</span> next_url:<br> +                      <span class="hljs-keyword">return</span> HttpResponseRedirect(next_url)<br> +                  <span class="hljs-keyword">else</span>:<br> +                      <span class="hljs-keyword">return</span> HttpResponseRedirect(reverse(<span class="hljs-string">&quot;index&quot;</span>))<br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-keyword">return</span> render(request, <span class="hljs-string">&quot;login.html&quot;</span>, &#123;<span class="hljs-string">&quot;msg&quot;</span>: <span class="hljs-string">&quot;请激活账户&quot;</span>&#125;)<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">return</span> render(request, <span class="hljs-string">&quot;login.html&quot;</span>, &#123;<span class="hljs-string">&quot;msg&quot;</span>: <span class="hljs-string">&quot;用户名或密码错误&quot;</span>&#125;)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> render(request, <span class="hljs-string">&quot;login.html&quot;</span>, &#123;<br>                <span class="hljs-string">&quot;login_form&quot;</span>: login_from<br>            &#125;)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get</span>(<span class="hljs-params">self, request</span>):</span><br>+       next_url = request.META[<span class="hljs-string">&#x27;HTTP_REFERER&#x27;</span>]<br>        <span class="hljs-keyword">return</span> render(request, <span class="hljs-string">&quot;login.html&quot;</span>, &#123;<br>+           <span class="hljs-string">&quot;next_url&quot;</span>: next_url<br>        &#125;)<br></code></pre></td></tr></table></figure>
<p>关注左边带有+的代码<br>利用Miscellaneous 头域的Referer传递的跳转url写入login的html里面，然后在post时获取next_url的数值，验证登录成功时通过HttpResponseRedirect(next_url)返回到刚才的url。</p>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>django</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法-算法</title>
    <url>/2017/10/20/19/</url>
    <content><![CDATA[<h2 id="前记"><a href="#前记" class="headerlink" title="前记"></a>前记</h2><p>这里是补充数据结构里面缺失的对应算法，略产促</p>
<span id="more"></span>
<h2 id="字符串匹配"><a href="#字符串匹配" class="headerlink" title="字符串匹配"></a>字符串匹配</h2><p>字符串匹配一般是有一大串字符串target_str, 给给一个待匹配的字符串pattern_str, 找出pattern_str是否在target_str之中, 一般来说target_str会很大而pattern_str会很小.<br>最简单的就是暴力算法, 然后有Sunday算法和KMP算法, 暴力算法是一个字符一个字符的比较多, 思路简单, 但是计算资源会重复, 而后面两种算法只是基于前面的查找计算资源, 判断是否可以多跳几个字符, 减少计算资源的使用.</p>
<h3 id="朴素的模式匹配算法"><a href="#朴素的模式匹配算法" class="headerlink" title="朴素的模式匹配算法"></a>朴素的模式匹配算法</h3><p>假设字母列表长度为m, 想要寻找的长度为n，则从头开始找，到第m-n+1位，寻找是否有相同的字母.<br>一般都是把n的长度当做滑动窗口的大小, 然后一位一位的增加, 直到窗口内容跟n一致</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">str_match</span>(<span class="hljs-params">target_str: <span class="hljs-built_in">str</span>, pattern_str: <span class="hljs-built_in">str</span></span>) -&gt; bool:</span>  <br>    m: <span class="hljs-built_in">int</span> = <span class="hljs-built_in">len</span>(target_str)<br>    n: <span class="hljs-built_in">int</span> = <span class="hljs-built_in">len</span>(pattern_str)  <br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m-n+<span class="hljs-number">1</span>):<span class="hljs-comment">#起始指针i  </span><br>        <span class="hljs-keyword">if</span> target_str[i:i+n] == pattern_str:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>  <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>  <br><br>str_match(<span class="hljs-string">&quot;BBC ABCDAB ABCDABCDABDE&quot;</span>, <span class="hljs-string">&quot;ABCDABD&quot;</span>)<br></code></pre></td></tr></table></figure>
<h3 id="Sunday算法"><a href="#Sunday算法" class="headerlink" title="Sunday算法"></a>Sunday算法</h3><p>Sunday算法跟暴力算法一样, 会先检查是否匹配, 不过在检查到不匹配后, 并不是马上移位一位, 而是根据计算来判断是否可以进行跳位, 这一步也是Sunday算法比暴力算法快点秘诀, 但是遇到像上面的<code>BBC ABCDAB ABCDABCDABDE</code>和<code>ABCDABD</code>则性能会变差, 以下是Sunday算法的流程, 以<code>How are you</code>和<code>you</code>为例子:</p>
<ul>
<li>第一次匹配:  <figure class="highlight ebnf"><table><tr><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">How are you</span><br><span class="hljs-attribute">you</span><br></code></pre></td></tr></table></figure>
  发现匹配失败, 这时候就会去获取target_str字符串的第四位(因为you为3位), 发现第4位是空格, 不在<code>you</code>里面, 所以后面三位<code> ar</code>也不可能跟<code>you</code>匹配, 则直接跳到<code>are</code>的e进行匹配.</li>
<li>第二次匹配:  <figure class="highlight ebnf"><table><tr><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">How are you</span><br><span class="hljs-attribute">      you</span><br></code></pre></td></tr></table></figure>
  从e开始检查, 发现匹配仍然是失败的, 则检查target_str字符串中<code>you</code>的<code>o</code>, 发现<code>o</code>存在与待匹配字符串中, 只能下移一位继续匹配, 最后发现后面都you是匹配成功.</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">str_match</span>(<span class="hljs-params">target_str: <span class="hljs-built_in">str</span>, pattern_str: <span class="hljs-built_in">str</span></span>) -&gt; bool:</span>  <br>    m: <span class="hljs-built_in">int</span> = <span class="hljs-built_in">len</span>(target_str)<br>    n: <span class="hljs-built_in">int</span> = <span class="hljs-built_in">len</span>(pattern_str)  <br><br>    <span class="hljs-keyword">while</span> i &lt; m:<br>        <span class="hljs-keyword">if</span> target_str[i: i + n] == pattern_str:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>        skip_index: <span class="hljs-built_in">int</span> = i + n<br>        <span class="hljs-keyword">if</span> skip_index &lt; m - <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> target_str[skip_index] <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> pattern_str:<br>            i += n * <span class="hljs-number">2</span><br>        <span class="hljs-keyword">else</span>:<br>            i += <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br>str_match(<span class="hljs-string">&quot;BBC ABCDAB ABCDABCDABDE&quot;</span>, <span class="hljs-string">&quot;ABCDABD&quot;</span>)<br></code></pre></td></tr></table></figure>

<h3 id="KMP模式匹配算法"><a href="#KMP模式匹配算法" class="headerlink" title="KMP模式匹配算法"></a>KMP模式匹配算法</h3><p>KMP算法减少了一些已经计算过的计算量，但是他需要我们自己创建一个匹配表<br>对KMP算法的讲解：<a href="http://blog.csdn.net/chinwuforwork/article/details/51939826">http://blog.csdn.net/chinwuforwork/article/details/51939826</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">kmp_match</span>(<span class="hljs-params">s, p</span>):</span>  <br>    m = <span class="hljs-built_in">len</span>(s); n = <span class="hljs-built_in">len</span>(p)  <br>    cur = <span class="hljs-number">0</span><span class="hljs-comment">#起始指针cur  </span><br>    table = partial_table(p)  <br>    <span class="hljs-keyword">while</span> cur&lt;=m-n:  <br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            <span class="hljs-keyword">if</span> s[i+cur]!=p[i]:  <br>                cur += <span class="hljs-built_in">max</span>(i - table[i-<span class="hljs-number">1</span>], <span class="hljs-number">1</span>)<span class="hljs-comment">#有了部分匹配表,我们不只是单纯的1位1位往右移,可以一次移动多位  </span><br>                <span class="hljs-keyword">break</span>  <br>        <span class="hljs-keyword">else</span>:  <br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>  <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>  <br>  <br><span class="hljs-comment">#部分匹配表  </span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">partial_table</span>(<span class="hljs-params">p</span>):</span>  <br>    <span class="hljs-string">&#x27;&#x27;&#x27;&#x27;&#x27;partial_table(&quot;ABCDABD&quot;) -&gt; [0, 0, 0, 0, 1, 2, 0]</span><br><span class="hljs-string">    prefix&amp;postfix or &#123;&#x27;&#x27;&#125;求集合的交集，如果没有则为空</span><br><span class="hljs-string">    pop()可以取出里面的数值</span><br><span class="hljs-string">    &#x27;&#x27;&#x27;</span>  <br>    prefix = <span class="hljs-built_in">set</span>()  <br>    postfix = <span class="hljs-built_in">set</span>()  <br>    ret = [<span class="hljs-number">0</span>]  <br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-built_in">len</span>(p)):  <br>        prefix.add(p[:i])  <br>        postfix = &#123;p[j:i+<span class="hljs-number">1</span>] <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,i+<span class="hljs-number">1</span>)&#125;  <br>        ret.append(<span class="hljs-built_in">len</span>((prefix&amp;postfix <span class="hljs-keyword">or</span> &#123;<span class="hljs-string">&#x27;&#x27;</span>&#125;).pop()))  <br>    <span class="hljs-keyword">return</span> ret  <br>  <br><br><span class="hljs-built_in">print</span> (partial_table(<span class="hljs-string">&quot;ABCDABD&quot;</span>)  )<br><span class="hljs-built_in">print</span> (kmp_match(<span class="hljs-string">&quot;BBC ABCDAB ABCDABCDABDE&quot;</span>, <span class="hljs-string">&quot;ABCDABD&quot;</span>)  )<br></code></pre></td></tr></table></figure>
<h2 id="图的最小生成树"><a href="#图的最小生成树" class="headerlink" title="图的最小生成树"></a>图的最小生成树</h2><p>在一个有权的图中，既要做到遍历到所有点，同时要保证遍历顺序的权加起来是最小的</p>
<h3 id="普里姆算法"><a href="#普里姆算法" class="headerlink" title="普里姆算法"></a>普里姆算法</h3><p>普里姆算法的基本思想：普里姆算法是另一种构造最小生成树的算法，它是按逐个将顶点连通的方式来构造最小生成树的</p>
<p>从连通网络 N = { V, E }中的某一顶点 u0 出发，选择与它关联的具有最小权值的边(u0, v)，将其顶点加入到生成树的顶点集合U中。以后每一步从一个顶点在U中，而另一个顶点不在U中的各条边中选择权值最小的边(u, v),把该边加入到生成树的边集TE中，把它的顶点加入到集合U中。如此重复执行，直到网络中的所有顶点都加入到生成树顶点集合U中为止。</p>
<p><img    class="lazyload" data-original="https://github.com/so1n/so1n_blog_photo/blob/master/blog_photo/%E6%99%AE%E5%88%A9%E6%AF%8D%E7%AE%97%E6%B3%95?raw=true" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">普利母算法过程</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">prim</span>(<span class="hljs-params"> graph, vertex_num </span>):</span>  <br>      <br>    INF      = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">10</span>  <br>    visit    = [<span class="hljs-literal">False</span>] * vertex_num   <span class="hljs-comment">#检测是否遍历过</span><br>    dist     = [INF] * vertex_num     <span class="hljs-comment">#该集合是用于记录且判断权的最小值（需要与visit一起判断）</span><br>    <span class="hljs-comment">#利用dist可以做到，假如到了某个点，哪个点已经没有可以遍历的点了，就可以回到之前记录的点的没记录粿点的最小权</span><br>    my_list = []<br><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>( vertex_num ):  <br>          <br>        minDist = INF + <span class="hljs-number">1</span>  <br>        nextIndex = -<span class="hljs-number">1</span>  <br>          <br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>( vertex_num ):  <br>            <span class="hljs-comment">#查找第i个点与未遍历的点的最小权值的对应点</span><br>            <span class="hljs-keyword">if</span> dist[j] &lt; minDist <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> visit[j]:  <br>                    minDist = dist[j]  <br>                    nextIndex = j<br><br>        <span class="hljs-keyword">for</span> j,n <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(graph[nextIndex]):<br>            <span class="hljs-comment">#查找该点的前驱</span><br>            <span class="hljs-keyword">if</span> minDist == INF:<br>                a = <span class="hljs-number">0</span><br>            <span class="hljs-keyword">elif</span> n == minDist:<br>                a = j+<span class="hljs-number">1</span><br><br>        <span class="hljs-comment">#记录改点(poin_list的第一个为前驱，第二个为点)</span><br>        poin_list = [a,nextIndex+<span class="hljs-number">1</span>]<br>        my_list.append(poin_list)   <br>        visit[nextIndex] = <span class="hljs-literal">True</span>  <br>          <br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>( vertex_num ):<br>            <span class="hljs-comment">#为所查找的点附上与之对应点的权</span><br>            <span class="hljs-keyword">if</span> dist[j] &gt; graph[nextIndex][j] <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> visit[j]:  <br>                dist[j] = graph[nextIndex][j]<br><br>    <span class="hljs-keyword">return</span> my_list<br>  <br>_ = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">10</span>  <br><span class="hljs-comment">#&lt;&lt;的解释https://zhidao.baidu.com/question/583597339.html</span><br><span class="hljs-comment">#所以_是1024，代表无穷大</span><br><br>graph=[<br>    [<span class="hljs-number">0</span>,<span class="hljs-number">6</span>,<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,_,_],<br>    [<span class="hljs-number">6</span>,<span class="hljs-number">0</span>,<span class="hljs-number">5</span>,_,<span class="hljs-number">3</span>,_],<br>    [<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">0</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">4</span>],<br>    [<span class="hljs-number">5</span>,_,<span class="hljs-number">5</span>,<span class="hljs-number">0</span>,_,<span class="hljs-number">2</span>],<br>    [_,<span class="hljs-number">3</span>,<span class="hljs-number">6</span>,_,<span class="hljs-number">0</span>,<span class="hljs-number">6</span>],<br>    [_,_,<span class="hljs-number">4</span>,<span class="hljs-number">2</span>,<span class="hljs-number">6</span>,<span class="hljs-number">0</span>],<br>]  <br>  <br>print(prim( graph, <span class="hljs-number">6</span> ))  <br></code></pre></td></tr></table></figure>
<h3 id="克鲁斯卡尔算法（优化版）"><a href="#克鲁斯卡尔算法（优化版）" class="headerlink" title="克鲁斯卡尔算法（优化版）"></a>克鲁斯卡尔算法（优化版）</h3><p>克鲁斯卡尔算法是一种用来寻找最小生成树的算法。在剩下的所有未选取的边中，找最小边，如果和已选取的边构成回路，则放弃，选取次小边<br>找最小边很容易，判断是不是回路就让我蒙了好久（现在还蒙- -），由于判断边的两个断点的最终根节点是否相同等于判断是不是构成回路，所以可以使用并查集来解决<br>构建最小生成树时，还要使等级低的指向等级高的，这样可以变成线性表，查找时速度就能得到提高</p>
<p>关于并查集：<a href="http://blog.csdn.net/qq_34594236/article/details/51834882">http://blog.csdn.net/qq_34594236/article/details/51834882</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#Kruskal’s Algorithm</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">find</span>(<span class="hljs-params">C, u</span>):</span><br>    <span class="hljs-comment">#输出该节点的根</span><br>    <span class="hljs-comment">#案例中，到了边14时，查找1获得3，再查找3获得6，最后才知道1的跟是6,4一步得出4的跟是6。在这个期间，就把1的跟转换为6</span><br>    <span class="hljs-comment">#案例中，到了边32时(25和13通过23连接了，但2指向5,1指向3指向6，并没有1指向3指向2，这个路径)</span><br>    <span class="hljs-comment">#       由于32边才通过逐级查找，判断出2跟5的跟是6</span><br>    <span class="hljs-keyword">if</span> C[u] != u:      <span class="hljs-comment">#判断这个点是不是根，如果不是向顶点查找(由于做了路径压缩处理，查找很快)</span><br>        C[u] = find(C, C[u])                    <br>    <span class="hljs-keyword">return</span> C[u]<br> <br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">union</span>(<span class="hljs-params">C, R, u, v</span>):</span><br>    <span class="hljs-comment">#将其视为平衡树，等级小的指向等级大的，如果两者等级一样，则前者指像后者。最后后者等级加1</span><br>    u, v = find(C, u), find(C, v)<br>    <span class="hljs-comment">#这句if,else是由等级来判断是否需要转换跟</span><br>    <span class="hljs-keyword">if</span> R[u] &gt; R[v]:                             <br>        C[v] = u<br>    <span class="hljs-keyword">else</span>:<br>        C[u] = v<br>    <span class="hljs-keyword">if</span> R[u] == R[v]:                            <span class="hljs-comment">#等级加1</span><br>        R[v] += <span class="hljs-number">1</span><br> <br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">kruskal</span>(<span class="hljs-params">G</span>):</span><br>    E = [(G[u][v],u,v) <span class="hljs-keyword">for</span> u <span class="hljs-keyword">in</span> G <span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> G[u]] <span class="hljs-comment">#生成的E是(边的权，边的起点，边的终点)的列表</span><br>    T = <span class="hljs-built_in">set</span>()<br>    C, R = &#123;u:u <span class="hljs-keyword">for</span> u <span class="hljs-keyword">in</span> G&#125;, &#123;u:<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> u <span class="hljs-keyword">in</span> G&#125;   <br>    <span class="hljs-comment"># 定义的c是通过路径压缩后，点的对应的最终顶节点，也就是树的根，</span><br>    <span class="hljs-comment">#R定义的是点的等级</span><br>    <span class="hljs-keyword">for</span> _, u, v <span class="hljs-keyword">in</span> <span class="hljs-built_in">sorted</span>(E): <span class="hljs-comment">#由于使用sorted所以排序先按权排序再按起点排序，所以这样生成的树中都是数字小的充当子节点，大的充当节点（但是在整颗树中并不是这样的）</span><br>        print(<span class="hljs-string">&quot;(&quot;</span>,u,v,<span class="hljs-string">&quot;)&quot;</span>)<br>        print(<span class="hljs-string">&quot;C&quot;</span>, C)<br>        print(<span class="hljs-string">&quot;R&quot;</span>, R)<br>        print(<span class="hljs-string">&quot;u,v&quot;</span>, u, v)<br>        print(<span class="hljs-string">&quot;C[u],u&quot;</span>,C[u],u)<br>        print(<span class="hljs-string">&quot;C[v],v&quot;</span>,C[v],v)<br>        <span class="hljs-keyword">if</span> find(C, u) != find(C, v):<br>            <span class="hljs-comment">#如果两个段点的根不同，就代表没有构成回路</span><br>            print(<span class="hljs-string">&quot;录入u,v&quot;</span>,u,v)<br>            T.add((u, v))<br>            union(C, R, u, v)<br>        print(<span class="hljs-string">&quot;------&quot;</span>)<br>    <span class="hljs-keyword">return</span> T<br><br><br><br>G = &#123;<br>    <span class="hljs-number">1</span>: &#123;<span class="hljs-number">2</span>:<span class="hljs-number">6</span>, <span class="hljs-number">3</span>:<span class="hljs-number">1</span>, <span class="hljs-number">4</span>:<span class="hljs-number">5</span>&#125;,<br>    <span class="hljs-number">2</span>: &#123;<span class="hljs-number">1</span>:<span class="hljs-number">6</span>, <span class="hljs-number">3</span>:<span class="hljs-number">5</span>, <span class="hljs-number">5</span>:<span class="hljs-number">3</span>&#125;,<br>    <span class="hljs-number">3</span>: &#123;<span class="hljs-number">1</span>:<span class="hljs-number">1</span>, <span class="hljs-number">2</span>:<span class="hljs-number">5</span>, <span class="hljs-number">4</span>:<span class="hljs-number">5</span>, <span class="hljs-number">5</span>:<span class="hljs-number">6</span>, <span class="hljs-number">6</span>:<span class="hljs-number">4</span>&#125;,<br>    <span class="hljs-number">4</span>: &#123;<span class="hljs-number">1</span>:<span class="hljs-number">5</span>, <span class="hljs-number">3</span>:<span class="hljs-number">5</span>, <span class="hljs-number">6</span>:<span class="hljs-number">2</span>&#125;,<br>    <span class="hljs-number">5</span>: &#123;<span class="hljs-number">2</span>:<span class="hljs-number">3</span>, <span class="hljs-number">3</span>:<span class="hljs-number">6</span>, <span class="hljs-number">6</span>:<span class="hljs-number">6</span>&#125;,<br>    <span class="hljs-number">6</span>: &#123;<span class="hljs-number">3</span>:<span class="hljs-number">4</span>, <span class="hljs-number">4</span>:<span class="hljs-number">2</span>, <span class="hljs-number">5</span>:<span class="hljs-number">6</span>&#125;,<br>    &#125;<br><br><br><span class="hljs-built_in">print</span> (<span class="hljs-built_in">list</span>(kruskal(G))) <br></code></pre></td></tr></table></figure>

<h2 id="图的最小路径"><a href="#图的最小路径" class="headerlink" title="图的最小路径"></a>图的最小路径</h2><h3 id="迪杰斯特拉算法-Dijkstra"><a href="#迪杰斯特拉算法-Dijkstra" class="headerlink" title="迪杰斯特拉算法(Dijkstra)"></a>迪杰斯特拉算法(Dijkstra)</h3><p>该算法执行过程中，把途中的顶点分为两个集合，当时已知最短路径的顶点集合U，以及尚不知道最短路径的顶点集合V-U。算法执行过程中，逐步扩充已知最短路径的顶点集合，每步从顶点集合V-U中找出一个顶点（它是当时已经能确定最短路径的顶点）加入U。反复执行这样的操作，直到从找到顶点v0到其他所有顶点的最短路径。该算法能同时给出这些路径以及长度<br><img    class="lazyload" data-original="https://github.com/so1n/so1n_blog_photo/blob/master/blog_photo/Dijkstra%E5%9B%BE%E7%A4%BA%E5%9B%BE.png?raw=true" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">图示图</span><br>图中(1)状态，只有a在集合u，这是有两条边界变分别到顶点c和d。选择距离a最近的d加入u并标记相应的变，标出新发现的到顶点e的边界点，得到图(2)。这是最近的非u顶点是c，将其加入u后发现了3条新的边界边，找到的顶点e的新路径比原来的已知路径更短，记录这是的边界边和顶点的已知距离得到图（3）。将这是最近的非u顶点e加入集合u，记录到e的最短路径。由于新发现了从e一步可以到达g，记录相应的边界边，得到图(4)。这是虽然边界边中最短的是到g的边，但顶点b距离a更近，因此应该把b加入u。将b加入u后发现了一条到f的新路径，但其长度并不断与此时已知到f的最短路径（事实上，两条路径一样长），因此不需要更新路径，得到图（5）.再经过两步，最后状态6给出了所有路径</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># dijkstra算法实现，有向图和路由的源点作为函数的输入，最短路径最为输出</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dijkstra</span>(<span class="hljs-params">graph,src</span>):</span><br>    <span class="hljs-comment"># 判断图是否为空，如果为空直接退出</span><br>    <span class="hljs-keyword">if</span> graph <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>    nodes = [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(graph))]  <span class="hljs-comment"># 获取图中所有节点</span><br>    visited=[]  <span class="hljs-comment"># 表示已经路由到最短路径的节点集合</span><br>    <span class="hljs-keyword">if</span> src <span class="hljs-keyword">in</span> nodes:<br>        visited.append(src)<br>        nodes.remove(src)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>    distance=&#123;src:<span class="hljs-number">0</span>&#125;  <span class="hljs-comment"># 记录源节点到各个节点的距离</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> nodes:<br>        distance[i]=graph[src][i]  <span class="hljs-comment"># 初始化</span><br>    <span class="hljs-comment"># print(distance)</span><br>    path=&#123;src:&#123;src:[]&#125;&#125;  <span class="hljs-comment"># 记录源节点到每个节点的路径</span><br>    k=pre=src<br>    <span class="hljs-keyword">while</span> nodes:<br>        mid_distance=<span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;inf&#x27;</span>)<br>        <span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> visited:<br>            <span class="hljs-keyword">for</span> d <span class="hljs-keyword">in</span> nodes:<br>                new_distance = graph[src][v]+graph[v][d]<br>                <span class="hljs-keyword">if</span> new_distance &lt; mid_distance:<br>                    mid_distance=new_distance<br>                    graph[src][d]=new_distance  <span class="hljs-comment"># 进行距离更新</span><br>                    k=d<br>                    pre=v<br>        distance[k]=mid_distance  <span class="hljs-comment"># 最短路径</span><br>        path[src][k]=[i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> path[src][pre]]<br>        path[src][k].append(k)<br>        <span class="hljs-comment"># 更新两个节点集合</span><br>        visited.append(k)<br>        nodes.remove(k)<br>        print(visited,nodes)  <span class="hljs-comment"># 输出节点的添加过程</span><br>    <span class="hljs-keyword">return</span> distance,path<br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    graph_list = [ [<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>],<br>            [<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>],<br>            [<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>],<br>            [<span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>],<br>            [<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>],<br>            [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">7</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>]]<br><br>    distance,path= dijkstra(graph_list, <span class="hljs-number">0</span>)  <span class="hljs-comment"># 查找从源点0开始带其他节点的最短路径</span><br>    print(distance,path)<br></code></pre></td></tr></table></figure>
<h3 id="沸洛伊德算法"><a href="#沸洛伊德算法" class="headerlink" title="沸洛伊德算法"></a>沸洛伊德算法</h3><p>如果我要求顶点A到顶点B之间的距离的话，我可以先找一个顶点C，求解顶点A到顶点C加上顶点C到顶点B的距离和，如何这个距离和小于顶点A直接到顶点B的距离的话，那么这个时候就要更新一下距离矩阵中的值，将顶点A到顶点B的距离更新为：顶点A到顶点C加上顶点C到顶点B的距离和。这就是Folyd的核心思想了，那么如果要找到全局最优的解就要在选取中间顶点的过程中遍历所有的节点才行</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">make_mat</span>(<span class="hljs-params">m, n, fill=<span class="hljs-literal">None</span></span>):</span><br>    mat = []<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):<br>        mat.append([fill] * n)<br>    <span class="hljs-keyword">return</span> mat<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_edges</span>(<span class="hljs-params">graph</span>):</span><br>    n = <span class="hljs-built_in">len</span>(graph)<br>    edges = []<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            <span class="hljs-keyword">if</span> graph[i][j] != <span class="hljs-number">0</span>:<br>                edges.append((i, j, graph[i][j]))<br>    <span class="hljs-keyword">return</span> edges<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">ford</span>(<span class="hljs-params">graph, v0</span>):</span><br>    n = <span class="hljs-built_in">len</span>(graph)<br>    edges = get_edges(graph)<br>    dis = [INF] * n<br>    dis[v0] = <span class="hljs-number">0</span><br>    path = [<span class="hljs-number">0</span>] * n<br><br>    <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n-<span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">for</span> edge <span class="hljs-keyword">in</span> edges:<br>            <span class="hljs-comment"># relax</span><br>            <span class="hljs-keyword">if</span> dis[edge[<span class="hljs-number">0</span>]] + edge[<span class="hljs-number">2</span>] &lt; dis[edge[<span class="hljs-number">1</span>]]:<br>                dis[edge[<span class="hljs-number">1</span>]] = dis[edge[<span class="hljs-number">0</span>]] + edge[<span class="hljs-number">2</span>]<br>                path[edge[<span class="hljs-number">1</span>]] = edge[<span class="hljs-number">0</span>]<br><br>    <span class="hljs-comment"># check negative loop</span><br>    flag = <span class="hljs-literal">False</span><br>    <span class="hljs-keyword">for</span> edge <span class="hljs-keyword">in</span> edges:<br>        <span class="hljs-comment"># try to relax</span><br>        <span class="hljs-keyword">if</span> dis[edge[<span class="hljs-number">0</span>]] + edge[<span class="hljs-number">2</span>] &lt; dis[edge[<span class="hljs-number">1</span>]]:<br>            flag = <span class="hljs-literal">True</span><br>            <span class="hljs-keyword">break</span><br>    <span class="hljs-keyword">if</span> flag:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>    <span class="hljs-keyword">return</span> dis, path<br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    INF = <span class="hljs-number">1e6</span><br>    graph_list = [ [<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>],<br>            [<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>],<br>            [<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>],<br>            [<span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>],<br>            [<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>],<br>            [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">7</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>]]<br><br>    distance,path= ford(graph_list, <span class="hljs-number">0</span>)  <span class="hljs-comment"># 查找从源点0开始带其他节点的最短路径</span><br>    print(distance,path)<br></code></pre></td></tr></table></figure>
<h2 id="图的拓扑排序"><a href="#图的拓扑排序" class="headerlink" title="图的拓扑排序"></a>图的拓扑排序</h2><h3 id="拓扑排序算法"><a href="#拓扑排序算法" class="headerlink" title="拓扑排序算法"></a>拓扑排序算法</h3><p>拓扑顺序就是：每次找到一个只指向别人的点 (学术性说法：入度为0)，记录下来；然后忽略掉这个点和它所指出去的线，再找到下一个只指向别人的点，记录下来，直到剩最后一个点，所有记录的点的顺序就是拓扑顺序<br><img    class="lazyload" data-original="https://github.com/so1n/so1n_blog_photo/blob/master/blog_photo/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.png?raw=true" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">拓扑排序</span><br>上图中，只有点1只指向别人，输出1；去掉点1和它伸出的两根线外只有点2只指向别人，输出2；…类推下去，得到拓扑排序结构: 1 2 4 3 5</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">indegree0</span>(<span class="hljs-params">v,e</span>):</span> <br>    <span class="hljs-keyword">if</span> v==[]:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>    tmp=v[:]<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> e:<br>        <span class="hljs-keyword">if</span> i[<span class="hljs-number">1</span>] <span class="hljs-keyword">in</span> tmp:<br>            tmp.remove(i[<span class="hljs-number">1</span>])<br>    <span class="hljs-keyword">if</span> tmp==[]:<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br><br>    <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> tmp:<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(e)):<br>            <span class="hljs-keyword">if</span> t <span class="hljs-keyword">in</span> e[i]:<br>                e[i]=<span class="hljs-string">&#x27;toDel&#x27;</span> <span class="hljs-comment">#占位，之后删掉</span><br>    <span class="hljs-keyword">if</span> e:<br>        eset=<span class="hljs-built_in">set</span>(e)<br>        eset.remove(<span class="hljs-string">&#x27;toDel&#x27;</span>)<br>        e[:]=<span class="hljs-built_in">list</span>(eset)<br>    <span class="hljs-keyword">if</span> v:<br>        <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> tmp:<br>            v.remove(t)<br>    <span class="hljs-keyword">return</span> tmp<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">topoSort</span>(<span class="hljs-params">v,e</span>):</span><br>    result=[]<br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        nodes=indegree0(v,e)<br>        <span class="hljs-keyword">if</span> nodes==<span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">break</span><br>        <span class="hljs-keyword">if</span> nodes==-<span class="hljs-number">1</span>:<br>            print(<span class="hljs-string">&#x27;there\&#x27;s a circle.&#x27;</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>        result.extend(nodes)<br>    <span class="hljs-keyword">return</span> result<br><br>v=[<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>,<span class="hljs-string">&#x27;d&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>]<br>e=[(<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>),(<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;d&#x27;</span>),(<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>),(<span class="hljs-string">&#x27;d&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>),(<span class="hljs-string">&#x27;d&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>),(<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>)]<br>res=topoSort(v,e)<br>print(res)<br></code></pre></td></tr></table></figure>
<h2 id="图的关键路径"><a href="#图的关键路径" class="headerlink" title="图的关键路径"></a>图的关键路径</h2><h3 id="关键路径算法"><a href="#关键路径算法" class="headerlink" title="关键路径算法"></a>关键路径算法</h3><p>关键路径：在AOE网中，从始点到终点具有最大路径长度（该路径上的各个活动所持续的时间之和）的路径称为关键路径。</p>
<p>关键活动：关键路径上的活动称为关键活动。关键活动：e[i]=l[i]的活动</p>
<p>　　由于AOE网中的某些活动能够同时进行，故完成整个工程所必须花费的时间应该为始点到终点的最大路径长度。关键路径长度是整个工程所需的最短工期。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pro</span>:</span>  <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self,pro_id,require_time,previous,pro_list</span>):</span>  <br>        self.pro_id = pro_id  <br>        self.require_time = require_time  <br>        self.previous = previous  <br>        <span class="hljs-comment">#self.status = False  </span><br>        pro_list.append(self)  <br>  <br>    <span class="hljs-comment"># def Test(self):  </span><br>    <span class="hljs-comment">#   for item in self.previous:  </span><br>    <span class="hljs-comment">#       if pro_list[item].status == False:  </span><br>    <span class="hljs-comment">#           return False  </span><br>    <span class="hljs-comment">#   return True  </span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">ShowSelf</span>(<span class="hljs-params">self</span>):</span>  <br>        <span class="hljs-built_in">print</span> (self.<span class="hljs-built_in">id</span>,self.require_time,self.previous)<span class="hljs-comment">#self.status,  </span><br>    <span class="hljs-comment"># def Pro_Finish(self):  </span><br>    <span class="hljs-comment">#   self.status = True  </span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span>(<span class="hljs-params">self</span>):</span>  <br>        total = <span class="hljs-number">0</span>  <br>        tmp = []  <br>        <span class="hljs-keyword">if</span> self.pro_id == <span class="hljs-number">0</span>:  <br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>  <br>        a = <span class="hljs-built_in">len</span>(self.previous)  <br>        <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(a):  <br>            tmp.append(pro_list[self.previous[x]].run() + self.require_time)  <br>        <span class="hljs-built_in">print</span> (tmp) <br>        total = <span class="hljs-built_in">max</span>(tmp)  <br>        <span class="hljs-built_in">print</span> (total)  <br>        <span class="hljs-keyword">return</span> total  <br>  <br>  <br>  <br>  <br>pro_list = []  <br>pro_0 = Pro(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, [<span class="hljs-number">0</span>], pro_list)  <br><span class="hljs-comment"># pro_0.status = True  </span><br>  <br><span class="hljs-comment">#init the pro_list  </span><br>pro_1 = Pro(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, [<span class="hljs-number">0</span>], pro_list)  <br>pro_2 = Pro(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, [<span class="hljs-number">1</span>], pro_list)  <br>pro_3 = Pro(<span class="hljs-number">3</span>, <span class="hljs-number">2</span>, [<span class="hljs-number">1</span>], pro_list)  <br>pro_4 = Pro(<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, [<span class="hljs-number">2</span>], pro_list)  <br>pro_5 = Pro(<span class="hljs-number">5</span>, <span class="hljs-number">3</span>, [<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">8</span>], pro_list)  <br>pro_6 = Pro(<span class="hljs-number">6</span>, <span class="hljs-number">1</span>, [<span class="hljs-number">4</span>], pro_list)  <br>pro_7 = Pro(<span class="hljs-number">7</span>, <span class="hljs-number">3</span>, [<span class="hljs-number">5</span>,<span class="hljs-number">6</span>], pro_list)  <br>pro_8 = Pro(<span class="hljs-number">8</span>, <span class="hljs-number">5</span>, [<span class="hljs-number">1</span>], pro_list)  <br>pro_9 = Pro(<span class="hljs-number">9</span>, <span class="hljs-number">4</span>, [<span class="hljs-number">7</span>], pro_list)  <br>  <br>  <br>  <br>total_time = pro_9.run()    <span class="hljs-comment">#此处为总项目，也可以是单个项目  </span><br><span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;Total_time:&quot;</span>,total_time ) <br>  <br></code></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>编程基础</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构</title>
    <url>/2017/10/20/16-data-structure/</url>
    <content><![CDATA[<p>利用python实现 链表，栈与队列，树，图的数据结构</p>
<span id="more"></span>

<h2 id="0-前记"><a href="#0-前记" class="headerlink" title="0.前记"></a>0.前记</h2><p>python内置了很多高级数据结构，list，dict，tuple，string，set等，在使用的时候十分舒心。现在自己想了解下数据结构，所以重新查阅资料，写下数据结构的实现方式<br>Python内置多种数据结构的时间复杂度说明：<a href="https://wiki.python.org/moin/TimeComplexity">https://wiki.python.org/moin/TimeComplexity</a><br>网友总结的数据结构时间复杂度说明：<a href="http://blog.csdn.net/u010366748/article/details/51469937">http://blog.csdn.net/u010366748/article/details/51469937</a></p>
<h2 id="1-一维数据结构"><a href="#1-一维数据结构" class="headerlink" title="1.一维数据结构"></a>1.一维数据结构</h2><p>一维数据结构, 是最简单和常用的数据结构, 常见的有数组, 链表, 栈和队列.</p>
<h3 id="1-1顺序表"><a href="#1-1顺序表" class="headerlink" title="1.1顺序表"></a>1.1顺序表</h3><p>数组是一个每一项都内存相连的数据结构, 查找子项的时间复杂度是O(1), 插入数据的时间复杂度为O(n). 而顺序表是经过更改的数组, 插入最后一项数据的时间复杂度为O(1).</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> Any<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LinearTable</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;在Python中使用list模拟线性表...&quot;&quot;&quot;</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, max_length: <span class="hljs-built_in">int</span> = <span class="hljs-number">10</span>, extend_num: <span class="hljs-built_in">int</span> = <span class="hljs-number">8</span></span>):</span><br>        self.max_length: <span class="hljs-built_in">int</span> = max_length<br><br>        <span class="hljs-comment"># 当前有效的数组最长值</span><br>        <span class="hljs-comment"># 比如数组实际长度为20, 当只用了10个, 那么num为10</span><br>        self.num: <span class="hljs-built_in">int</span> = <span class="hljs-number">0</span><br>        <span class="hljs-comment"># 扩容的长度</span><br>        self.extend_num: <span class="hljs-built_in">int</span> = extend_num<br>        self.data = [<span class="hljs-literal">None</span>] * self.max_length<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">is_empty</span>(<span class="hljs-params">self</span>) -&gt; bool:</span><br>        <span class="hljs-keyword">return</span> self.num == <span class="hljs-number">0</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">is_full</span>(<span class="hljs-params">self</span>) -&gt; bool:</span><br>        <span class="hljs-keyword">return</span> self.num == self.max_length<br><br><span class="hljs-meta">    @classmethod</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">from_list</span>(<span class="hljs-params">cls, raw_list: <span class="hljs-built_in">list</span></span>):</span><br>        instance: <span class="hljs-string">&quot;LinearTable&quot;</span> = cls()<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> raw_list:<br>            instance.append(i)<br>        <span class="hljs-keyword">return</span> instance<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">to_list</span>(<span class="hljs-params">self</span>) -&gt; list:</span><br>        <span class="hljs-keyword">return</span> self.data[: self.num]<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_extend</span>(<span class="hljs-params">self</span>):</span><br>        self.data.extend([<span class="hljs-literal">None</span>] * self.extend_num)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__getitem__</span>(<span class="hljs-params">self, index: <span class="hljs-built_in">int</span></span>) -&gt; Any:</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">isinstance</span>(index, <span class="hljs-built_in">int</span>):<br>            <span class="hljs-keyword">raise</span> TypeError<br>        <span class="hljs-keyword">if</span> <span class="hljs-number">0</span> &lt;= index &lt; self.num:<br>            <span class="hljs-keyword">return</span> self.data[index]<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-comment"># 表为空或者索引超出范围都会引发索引错误</span><br>            <span class="hljs-keyword">raise</span> IndexError<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__setitem__</span>(<span class="hljs-params">self, index: <span class="hljs-built_in">int</span>, value: Any</span>):</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">isinstance</span>(index, <span class="hljs-built_in">int</span>):<br>            <span class="hljs-keyword">raise</span> TypeError<br>        <span class="hljs-comment"># 只能访问列表里已有的元素,self.num=0时，一个都不能访问,self.num=1时，只能访问0</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-number">0</span> &lt;= index &lt; self.num:<br>            self.data[index] = value<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">raise</span> IndexError<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">clear</span>(<span class="hljs-params">self</span>):</span><br>        self.__init__()<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__len__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> self.num<br><br>    <span class="hljs-comment"># 加入元素的方法 append()和insert()</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">append</span>(<span class="hljs-params">self, value: Any</span>):</span><br>        <span class="hljs-keyword">if</span> self.is_full():<br>            <span class="hljs-comment"># 如果满了则进行扩容</span><br>            self._extend()<br>        self.data[self.num] = value<br>        self.num += <span class="hljs-number">1</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">insert</span>(<span class="hljs-params">self, index: <span class="hljs-built_in">int</span>, value: Any</span>):</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">isinstance</span>(index, <span class="hljs-built_in">int</span>):<br>            <span class="hljs-keyword">raise</span> TypeError<br>        <span class="hljs-keyword">if</span> index &lt; <span class="hljs-number">0</span>:  <span class="hljs-comment"># 暂时不考虑负数索引</span><br>            <span class="hljs-keyword">raise</span> IndexError<br>        <span class="hljs-comment"># 当key大于元素个数时，默认尾部插入</span><br>        <span class="hljs-keyword">if</span> index &gt; self.num:<br>            self.append(value)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">if</span> self.is_full():<br>                self._extend()<br>            self.num += <span class="hljs-number">1</span><br><br>            <span class="hljs-comment"># 移动key后的元素</span><br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(self.num, index, -<span class="hljs-number">1</span>):<br>                self.data[i] = self.data[i - <span class="hljs-number">1</span>]<br>            <span class="hljs-comment"># 赋值</span><br>            self.data[index] = value<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">remove</span>(<span class="hljs-params">self, index: <span class="hljs-built_in">int</span> = -<span class="hljs-number">1</span></span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;假删除, 只是把值往前挪, 缩小一个有效范围&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">isinstance</span>(index, <span class="hljs-built_in">int</span>):<br>            <span class="hljs-keyword">raise</span> TypeError<br>        <span class="hljs-keyword">if</span> self.num - <span class="hljs-number">1</span> &lt; <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">raise</span> IndexError(<span class="hljs-string">&quot;pop from empty list&quot;</span>)<br>        <span class="hljs-keyword">elif</span> index == -<span class="hljs-number">1</span>:<br>            <span class="hljs-comment"># 原来的数还在，但列表不识别他</span><br>            self.num -= <span class="hljs-number">1</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(index, self.num - <span class="hljs-number">1</span>):<br>                self.data[i] = self.data[i + <span class="hljs-number">1</span>]<br>            self.num -= <span class="hljs-number">1</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">index</span>(<span class="hljs-params">self, value: Any, start: <span class="hljs-built_in">int</span> = <span class="hljs-number">0</span></span>) -&gt; int:</span><br>        <span class="hljs-string">&quot;&quot;&quot;从第几个开始找, 找到则返回索引&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(start, self.num):<br>            <span class="hljs-keyword">if</span> self.data[i] == value:<br>                <span class="hljs-keyword">return</span> i<br>        <span class="hljs-comment"># 没找到</span><br>        <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&quot;%d is not in the list&quot;</span> % value)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reverse</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;列表反转&quot;&quot;&quot;</span><br>        i, j = <span class="hljs-number">0</span>, self.num - <span class="hljs-number">1</span><br>        <span class="hljs-keyword">while</span> i &lt; j:<br>            self.data[i], self.data[j] = self.data[j], self.data[i]<br>            i, j = i + <span class="hljs-number">1</span>, j - <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>
<h3 id="1-2单链表"><a href="#1-2单链表" class="headerlink" title="1.2单链表"></a>1.2单链表</h3><p>单链表与顺序表不同的是, 每个子项都是通过指针连接起来的, 在内存中是不连续的. 由于每个子项都需要通过上个子项查出来, 所以查找的时间复杂度是O(n),不过由于在内存中是不连续的, 所以对中间的数据进行增删时, 只需要更改指针, 而不用把受到影响的所有子项进行挪动.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> Any, Optional<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;创建数据和数据对应的指针&quot;&quot;&quot;</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, val: Any, node: Optional[<span class="hljs-string">&quot;Node&quot;</span>] = <span class="hljs-literal">None</span></span>):</span><br>        self.data: Any = val<br>        self.<span class="hljs-built_in">next</span>: Optional[<span class="hljs-string">&quot;Node&quot;</span>] = node<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LinkList</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        self.head: Optional[Node] = <span class="hljs-literal">None</span><br>        self.length: <span class="hljs-built_in">int</span> = <span class="hljs-number">0</span><br><br><span class="hljs-meta">    @classmethod</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">from_list</span>(<span class="hljs-params">cls, raw_list: <span class="hljs-built_in">list</span></span>) -&gt; &quot;LinkList&quot;:</span><br>        <span class="hljs-string">&quot;&quot;&quot;通过list写入数据&quot;&quot;&quot;</span><br>        instance: <span class="hljs-string">&quot;LinkList&quot;</span> = cls()<br>        instance.head = Node(raw_list[<span class="hljs-number">0</span>])<br>        node: Node = instance.head<br><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> raw_list[<span class="hljs-number">1</span>:]:<br>            new_node: Node = Node(i)<br>            <span class="hljs-comment"># 定义指针</span><br>            node.<span class="hljs-built_in">next</span> = new_node<br>            <span class="hljs-comment"># 定义下一个数</span><br>            node = new_node<br>        instance.length = <span class="hljs-built_in">len</span>(raw_list)<br>        <span class="hljs-keyword">return</span> instance<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">to_list</span>(<span class="hljs-params">self, left: <span class="hljs-built_in">int</span> = <span class="hljs-number">0</span>, right: <span class="hljs-built_in">int</span> = -<span class="hljs-number">1</span></span>) -&gt; list:</span><br>        <span class="hljs-string">&quot;&quot;&quot;获取列表的函数，如果没输入right时，则默认读取到最后面，如果没输入left和right则输出全部数据.left不能大于等于right&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> self.is_empty():<br>            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&#x27;Linklist is empty.&#x27;</span>)<br>        cursor: <span class="hljs-built_in">int</span> = <span class="hljs-number">0</span><br>        node: Node = self.head<br>        <span class="hljs-keyword">if</span> right == -<span class="hljs-number">1</span>:<br>            right = self.length<br>        <span class="hljs-keyword">if</span> right &gt; self.length <span class="hljs-keyword">or</span> left &gt;= right:<br>            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&#x27;right param error&#x27;</span>)<br><br>        <span class="hljs-keyword">while</span> node.<span class="hljs-built_in">next</span> <span class="hljs-keyword">and</span> cursor &lt; left:<br>            node = node.<span class="hljs-built_in">next</span><br>            cursor += <span class="hljs-number">1</span><br>        new_list: <span class="hljs-built_in">list</span> = []<br>        <span class="hljs-keyword">while</span> node <span class="hljs-keyword">and</span> cursor &lt;= right:<br>            new_list.append(node.data)<br>            cursor += <span class="hljs-number">1</span><br>            node = node.<span class="hljs-built_in">next</span><br>        <span class="hljs-keyword">return</span> new_list<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__len__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> self.length<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">is_empty</span>(<span class="hljs-params">self</span>) -&gt; bool:</span><br>        <span class="hljs-keyword">return</span> self.length == <span class="hljs-number">0</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">clear</span>(<span class="hljs-params">self</span>):</span><br>        self.head = <span class="hljs-literal">None</span><br>        self.length = <span class="hljs-number">0</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">append</span>(<span class="hljs-params">self, item: Any</span>):</span><br>        <span class="hljs-comment"># 在列表最后面添加一个数据</span><br>        new_node: Node = Node(item)<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self.head:<br>            self.head = new_node<br>        <span class="hljs-keyword">else</span>:<br>            node: Node = self.head<br>            <span class="hljs-keyword">while</span> node.<span class="hljs-built_in">next</span>:<br>                node = node.<span class="hljs-built_in">next</span><br>            node.<span class="hljs-built_in">next</span> = new_node<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__getitem__</span>(<span class="hljs-params">self, index: <span class="hljs-built_in">int</span></span>) -&gt; Any:</span><br>        self._check_index(index)<br><br>        cursor: <span class="hljs-built_in">int</span> = <span class="hljs-number">0</span><br>        node: Node = self.head<br><br>        <span class="hljs-keyword">while</span> node:<br>            node = node.<span class="hljs-built_in">next</span><br>            cursor += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> cursor == index:<br>                <span class="hljs-keyword">return</span> node.data<br><br>        <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&#x27;target is not exist!&#x27;</span>)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_check_index</span>(<span class="hljs-params">self, index: <span class="hljs-built_in">int</span></span>):</span><br>        <span class="hljs-keyword">if</span> self.is_empty() <span class="hljs-keyword">or</span> index &lt; <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> index &gt; self.length:<br>            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">f&quot;index:<span class="hljs-subst">&#123;index&#125;</span> error&quot;</span>)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__setitem__</span>(<span class="hljs-params">self, index: <span class="hljs-built_in">int</span>, item: Any</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;单独实现替换, 节省一遍查询&quot;&quot;&quot;</span><br>        self._check_index(index)<br><br>        node: Node = self.head<br>        <span class="hljs-keyword">if</span> index == <span class="hljs-number">0</span>:<br>            new_node: Node = node.<span class="hljs-built_in">next</span><br>            self.head = new_node<br>        <span class="hljs-keyword">elif</span> index == self.length - <span class="hljs-number">1</span>:<br>            self.append(item)<br>        <span class="hljs-keyword">else</span>:<br>            cursor: <span class="hljs-built_in">int</span> = <span class="hljs-number">0</span><br>            <span class="hljs-keyword">while</span> node:<br>                prev_node = node<br>                node = node.<span class="hljs-built_in">next</span><br>                cursor += <span class="hljs-number">1</span><br><br>                <span class="hljs-keyword">if</span> index == cursor:<br>                    new_node = Node(item, node.<span class="hljs-built_in">next</span>)<br>                    prev_node.<span class="hljs-built_in">next</span> = new_node<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">insert</span>(<span class="hljs-params">self, index: <span class="hljs-built_in">int</span>, item: Any</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;向指定位置插入数据&quot;&quot;&quot;</span><br>        self._check_index(index)<br><br>        <span class="hljs-keyword">if</span> index == <span class="hljs-number">0</span>:<br>            new_node: Node = Node(item, self.head)<br>            self.head = new_node<br>        <span class="hljs-keyword">elif</span> index == self.length - <span class="hljs-number">1</span>:<br>            self.append(item)<br>        <span class="hljs-keyword">else</span>:<br>            node: Node = self.head<br>            cursor: <span class="hljs-built_in">int</span> = <span class="hljs-number">0</span><br>            <span class="hljs-keyword">while</span> node:<br>                prev_node = node<br>                node = node.<span class="hljs-built_in">next</span><br>                cursor += <span class="hljs-number">1</span><br><br>                <span class="hljs-keyword">if</span> index == cursor:<br>                    new_node = Node(item, node)<br>                    prev_node.<span class="hljs-built_in">next</span> = new_node<br>                    new_node.<span class="hljs-built_in">next</span> = node<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">delete</span>(<span class="hljs-params">self, index: <span class="hljs-built_in">int</span></span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;删除指定位置数据&quot;&quot;&quot;</span><br>        self._check_index(index)<br><br>        node: Node = self.head<br>        <span class="hljs-comment"># 如果是0的话，起点改为第二个数据</span><br>        <span class="hljs-keyword">if</span> index == <span class="hljs-number">0</span>:<br>            new_node: Node = node.<span class="hljs-built_in">next</span><br>            self.head = new_node<br>        <span class="hljs-keyword">else</span>:<br>            cursor: <span class="hljs-built_in">int</span> = <span class="hljs-number">1</span><br>            <span class="hljs-keyword">while</span> node:<br>                prev_node = node<br>                node = node.<span class="hljs-built_in">next</span><br>                cursor += <span class="hljs-number">1</span><br>                <span class="hljs-comment"># 把下一个数据的指针，改为下下个数据的指针</span><br>                <span class="hljs-keyword">if</span> index == cursor:<br>                    prev_node.<span class="hljs-built_in">next</span> = node.<span class="hljs-built_in">next</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__contains__</span>(<span class="hljs-params">self, item: Any</span>) -&gt; bool:</span><br>        <span class="hljs-string">&quot;&quot;&quot;查找元素是否在里面&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> self.is_empty():<br>            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&#x27;Linklist is empty.&#x27;</span>)<br><br>        node: Node = self.head<br>        <span class="hljs-keyword">while</span> node:<br>            <span class="hljs-keyword">if</span> item == node.data:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>            node = node.<span class="hljs-built_in">next</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure>

<h3 id="1-3双向链表"><a href="#1-3双向链表" class="headerlink" title="1.3双向链表"></a>1.3双向链表</h3><p>双向链表与单链表一样, 只是每个节点多存放了一个前驱指针, 经过拓展可以很快的查出该节点的上一个节点是哪个</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> Any, Optional<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;创建数据和数据对应的指针&quot;&quot;&quot;</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, val: Any, next_node: Optional[<span class="hljs-string">&quot;Node&quot;</span>] = <span class="hljs-literal">None</span>, prev_node: Optional[<span class="hljs-string">&quot;Node&quot;</span>] = <span class="hljs-literal">None</span></span>):</span><br>        self.data: Any = val<br>        self.<span class="hljs-built_in">next</span>: Optional[<span class="hljs-string">&quot;Node&quot;</span>] = next_node<br>        self.prev: Optional[<span class="hljs-string">&quot;None&quot;</span>] = prev_node<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LinkList</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        self.head: Optional[Node] = <span class="hljs-literal">None</span><br>        self.length: <span class="hljs-built_in">int</span> = <span class="hljs-number">0</span><br><br><span class="hljs-meta">    @classmethod</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">from_list</span>(<span class="hljs-params">cls, raw_list: <span class="hljs-built_in">list</span></span>) -&gt; &quot;LinkList&quot;:</span><br>        <span class="hljs-string">&quot;&quot;&quot;通过list写入数据&quot;&quot;&quot;</span><br>        instance: <span class="hljs-string">&quot;LinkList&quot;</span> = cls()<br>        instance.head = Node(raw_list[<span class="hljs-number">0</span>])<br>        node: Node = instance.head<br><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> raw_list[<span class="hljs-number">1</span>:]:<br>            new_node: Node = Node(i)<br>            <span class="hljs-comment"># 定义指针</span><br>            node.<span class="hljs-built_in">next</span> = new_node<br>            new_node.prev = node<br>            <span class="hljs-comment"># 定义下一个数</span><br>            node = new_node<br>        instance.length = <span class="hljs-built_in">len</span>(raw_list)<br>        <span class="hljs-keyword">return</span> instance<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">to_list</span>(<span class="hljs-params">self, left: <span class="hljs-built_in">int</span> = <span class="hljs-number">0</span>, right: <span class="hljs-built_in">int</span> = -<span class="hljs-number">1</span></span>) -&gt; list:</span><br>        <span class="hljs-string">&quot;&quot;&quot;获取列表的函数，如果没输入right时，则默认读取到最后面，如果没输入left和right则输出全部数据.left不能大于等于right&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> self.is_empty():<br>            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&#x27;Linklist is empty.&#x27;</span>)<br>        cursor: <span class="hljs-built_in">int</span> = <span class="hljs-number">0</span><br>        node: Node = self.head<br>        <span class="hljs-keyword">if</span> right == -<span class="hljs-number">1</span>:<br>            right = self.length<br>        <span class="hljs-keyword">if</span> right &gt; self.length <span class="hljs-keyword">or</span> left &gt;= right:<br>            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&#x27;right param error&#x27;</span>)<br><br>        <span class="hljs-keyword">while</span> node.<span class="hljs-built_in">next</span> <span class="hljs-keyword">and</span> cursor &lt; left:<br>            node = node.<span class="hljs-built_in">next</span><br>            cursor += <span class="hljs-number">1</span><br>        new_list: <span class="hljs-built_in">list</span> = []<br>        <span class="hljs-keyword">while</span> node <span class="hljs-keyword">and</span> cursor &lt;= right:<br>            new_list.append(node.data)<br>            cursor += <span class="hljs-number">1</span><br>            node = node.<span class="hljs-built_in">next</span><br>        <span class="hljs-keyword">return</span> new_list<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__len__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> self.length<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">is_empty</span>(<span class="hljs-params">self</span>) -&gt; bool:</span><br>        <span class="hljs-keyword">return</span> self.length == <span class="hljs-number">0</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">clear</span>(<span class="hljs-params">self</span>):</span><br>        self.head = <span class="hljs-literal">None</span><br>        self.length = <span class="hljs-number">0</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">append</span>(<span class="hljs-params">self, item: Any</span>):</span><br>        <span class="hljs-comment"># 在列表最后面添加一个数据</span><br>        new_node: Node = Node(item)<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self.head:<br>            self.head = new_node<br>        <span class="hljs-keyword">else</span>:<br>            node: Node = self.head<br>            <span class="hljs-keyword">while</span> node.<span class="hljs-built_in">next</span>:<br>                node = node.<span class="hljs-built_in">next</span><br>            node.<span class="hljs-built_in">next</span> = new_node<br>            new_node.prev = node<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__getitem__</span>(<span class="hljs-params">self, index: <span class="hljs-built_in">int</span></span>) -&gt; Any:</span><br>        self._check_index(index)<br><br>        cursor: <span class="hljs-built_in">int</span> = <span class="hljs-number">0</span><br>        node: Node = self.head<br><br>        <span class="hljs-keyword">while</span> node:<br>            node = node.<span class="hljs-built_in">next</span><br>            cursor += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> cursor == index:<br>                <span class="hljs-keyword">return</span> node.data<br><br>        <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&#x27;target is not exist!&#x27;</span>)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_check_index</span>(<span class="hljs-params">self, index: <span class="hljs-built_in">int</span></span>):</span><br>        <span class="hljs-keyword">if</span> self.is_empty() <span class="hljs-keyword">or</span> index &lt; <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> index &gt; self.length:<br>            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">f&quot;index:<span class="hljs-subst">&#123;index&#125;</span> error&quot;</span>)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__setitem__</span>(<span class="hljs-params">self, index: <span class="hljs-built_in">int</span>, item: Any</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;单独实现替换, 节省一遍查询&quot;&quot;&quot;</span><br>        self._check_index(index)<br><br>        node: Node = self.head<br>        <span class="hljs-keyword">if</span> index == <span class="hljs-number">0</span>:<br>            new_node: Node = node.<span class="hljs-built_in">next</span><br>            self.head = new_node<br>        <span class="hljs-keyword">elif</span> index == self.length - <span class="hljs-number">1</span>:<br>            self.append(item)<br>        <span class="hljs-keyword">else</span>:<br>            cursor: <span class="hljs-built_in">int</span> = <span class="hljs-number">0</span><br>            <span class="hljs-keyword">while</span> node:<br>                prev_node = node<br>                node = node.<span class="hljs-built_in">next</span><br>                cursor += <span class="hljs-number">1</span><br><br>                <span class="hljs-keyword">if</span> index == cursor:<br>                    new_node = Node(item, node.<span class="hljs-built_in">next</span>)<br>                    prev_node.<span class="hljs-built_in">next</span> = new_node<br>                    new_node.prev = prev_node<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">insert</span>(<span class="hljs-params">self, index: <span class="hljs-built_in">int</span>, item: Any</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;向指定位置插入数据&quot;&quot;&quot;</span><br>        self._check_index(index)<br><br>        <span class="hljs-keyword">if</span> index == <span class="hljs-number">0</span>:<br>            new_node: Node = Node(item, self.head)<br>            self.head = new_node<br>        <span class="hljs-keyword">elif</span> index == self.length - <span class="hljs-number">1</span>:<br>            self.append(item)<br>        <span class="hljs-keyword">else</span>:<br>            node: Node = self.head<br>            cursor: <span class="hljs-built_in">int</span> = <span class="hljs-number">0</span><br>            <span class="hljs-keyword">while</span> node:<br>                prev_node = node<br>                node = node.<span class="hljs-built_in">next</span><br>                cursor += <span class="hljs-number">1</span><br><br>                <span class="hljs-keyword">if</span> index == cursor:<br>                    new_node = Node(item, node)<br>                    prev_node.<span class="hljs-built_in">next</span> = new_node<br>                    new_node.<span class="hljs-built_in">next</span> = node<br>                    new_node.prev = prev_node<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">delete</span>(<span class="hljs-params">self, index: <span class="hljs-built_in">int</span></span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;删除指定位置数据&quot;&quot;&quot;</span><br>        self._check_index(index)<br><br>        node: Node = self.head<br>        <span class="hljs-comment"># 如果是0的话，起点改为第二个数据</span><br>        <span class="hljs-keyword">if</span> index == <span class="hljs-number">0</span>:<br>            new_node: Node = node.<span class="hljs-built_in">next</span><br>            self.head = new_node<br>        <span class="hljs-keyword">else</span>:<br>            cursor: <span class="hljs-built_in">int</span> = <span class="hljs-number">1</span><br>            <span class="hljs-keyword">while</span> node:<br>                prev_node = node<br>                node = node.<span class="hljs-built_in">next</span><br>                cursor += <span class="hljs-number">1</span><br>                <span class="hljs-comment"># 把下一个数据的指针，改为下下个数据的指针</span><br>                <span class="hljs-keyword">if</span> index == cursor:<br>                    prev_node.<span class="hljs-built_in">next</span> = node.<span class="hljs-built_in">next</span><br>                    node.prev = prev_node<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__contains__</span>(<span class="hljs-params">self, item: Any</span>) -&gt; bool:</span><br>        <span class="hljs-string">&quot;&quot;&quot;查找元素是否在里面&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> self.is_empty():<br>            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&#x27;Linklist is empty.&#x27;</span>)<br><br>        node: Node = self.head<br>        <span class="hljs-keyword">while</span> node:<br>            <span class="hljs-keyword">if</span> item == node.data:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>            node = node.<span class="hljs-built_in">next</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure>
<h3 id="1-4循环链表"><a href="#1-4循环链表" class="headerlink" title="1.4循环链表"></a>1.4循环链表</h3><p>循环链表是特殊的双向链, 特殊之处在于链表最后一个数据的指针要指向第一个数据</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> Any, Optional<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;创建数据和数据对应的指针&quot;&quot;&quot;</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, val: Any, next_node: Optional[<span class="hljs-string">&quot;Node&quot;</span>] = <span class="hljs-literal">None</span>, prev_node: Optional[<span class="hljs-string">&quot;Node&quot;</span>] = <span class="hljs-literal">None</span></span>):</span><br>        self.data: Any = val<br>        self.<span class="hljs-built_in">next</span>: Optional[<span class="hljs-string">&quot;Node&quot;</span>] = next_node<br>        self.prev: Optional[<span class="hljs-string">&quot;None&quot;</span>] = prev_node<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LinkList</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        self.head: Optional[Node] = <span class="hljs-literal">None</span><br>        self.length: <span class="hljs-built_in">int</span> = <span class="hljs-number">0</span><br><br><span class="hljs-meta">    @classmethod</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">from_list</span>(<span class="hljs-params">cls, raw_list: <span class="hljs-built_in">list</span></span>) -&gt; &quot;LinkList&quot;:</span><br>        <span class="hljs-string">&quot;&quot;&quot;通过list写入数据&quot;&quot;&quot;</span><br>        instance: <span class="hljs-string">&quot;LinkList&quot;</span> = cls()<br>        instance.head = Node(raw_list[<span class="hljs-number">0</span>])<br>        node: Node = instance.head<br><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> raw_list[<span class="hljs-number">1</span>:]:<br>            new_node: Node = Node(i)<br>            <span class="hljs-comment"># 定义指针</span><br>            node.<span class="hljs-built_in">next</span> = new_node<br>            new_node.prev = node<br>            <span class="hljs-comment"># 定义下一个数</span><br>            node = new_node<br>        node.<span class="hljs-built_in">next</span> = instance.head<br>        instance.head.prev = node<br>        instance.length = <span class="hljs-built_in">len</span>(raw_list)<br>        <span class="hljs-keyword">return</span> instance<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">to_list</span>(<span class="hljs-params">self, left: <span class="hljs-built_in">int</span> = <span class="hljs-number">0</span>, right: <span class="hljs-built_in">int</span> = -<span class="hljs-number">1</span></span>) -&gt; list:</span><br>        <span class="hljs-string">&quot;&quot;&quot;获取列表的函数，如果没输入right时，则默认读取到最后面，如果没输入left和right则输出全部数据.left不能大于等于right&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> self.is_empty():<br>            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&#x27;Linklist is empty.&#x27;</span>)<br>        cursor: <span class="hljs-built_in">int</span> = <span class="hljs-number">0</span><br>        node: Node = self.head<br>        <span class="hljs-keyword">if</span> right == -<span class="hljs-number">1</span>:<br>            right = self.length<br>        <span class="hljs-keyword">if</span> right &gt; self.length <span class="hljs-keyword">or</span> left &gt;= right:<br>            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&#x27;right param error&#x27;</span>)<br><br>        <span class="hljs-keyword">while</span> node.<span class="hljs-built_in">next</span> <span class="hljs-keyword">and</span> cursor &lt; left:<br>            node = node.<span class="hljs-built_in">next</span><br>            cursor += <span class="hljs-number">1</span><br>        new_list: <span class="hljs-built_in">list</span> = []<br>        <span class="hljs-keyword">while</span> node <span class="hljs-keyword">and</span> cursor &lt;= right:<br>            new_list.append(node.data)<br>            <span class="hljs-keyword">if</span> node.<span class="hljs-built_in">next</span> <span class="hljs-keyword">is</span> self.head:<br>                <span class="hljs-keyword">break</span><br>            cursor += <span class="hljs-number">1</span><br>            node = node.<span class="hljs-built_in">next</span><br>        <span class="hljs-keyword">return</span> new_list<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__len__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> self.length<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">is_empty</span>(<span class="hljs-params">self</span>) -&gt; bool:</span><br>        <span class="hljs-keyword">return</span> self.length == <span class="hljs-number">0</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">clear</span>(<span class="hljs-params">self</span>):</span><br>        self.head = <span class="hljs-literal">None</span><br>        self.length = <span class="hljs-number">0</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">append</span>(<span class="hljs-params">self, item: Any</span>):</span><br>        <span class="hljs-comment"># 在列表最后面添加一个数据</span><br>        new_node: Node = Node(item)<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self.head:<br>            self.head = new_node<br>        <span class="hljs-keyword">else</span>:<br>            node: Node = self.head<br>            <span class="hljs-keyword">while</span> node.<span class="hljs-built_in">next</span> <span class="hljs-keyword">and</span> node.<span class="hljs-built_in">next</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> self.head:<br>                node = node.<span class="hljs-built_in">next</span><br><br>            node.<span class="hljs-built_in">next</span> = new_node<br>            new_node.prev = node<br>            new_node.<span class="hljs-built_in">next</span> = self.head<br>            self.head.prev = new_node<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__getitem__</span>(<span class="hljs-params">self, index: <span class="hljs-built_in">int</span></span>) -&gt; Any:</span><br>        self._check_index(index)<br><br>        cursor: <span class="hljs-built_in">int</span> = <span class="hljs-number">0</span><br>        node: Node = self.head<br><br>        <span class="hljs-keyword">while</span> node <span class="hljs-keyword">and</span> node.<span class="hljs-built_in">next</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> self.head:<br>            node = node.<span class="hljs-built_in">next</span><br>            cursor += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> cursor == index:<br>                <span class="hljs-keyword">return</span> node.data<br><br>        <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&#x27;target is not exist!&#x27;</span>)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_check_index</span>(<span class="hljs-params">self, index: <span class="hljs-built_in">int</span></span>):</span><br>        <span class="hljs-keyword">if</span> self.is_empty() <span class="hljs-keyword">or</span> index &lt; <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> index &gt; self.length:<br>            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">f&quot;index:<span class="hljs-subst">&#123;index&#125;</span> error&quot;</span>)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__setitem__</span>(<span class="hljs-params">self, index: <span class="hljs-built_in">int</span>, item: Any</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;单独实现替换, 节省一遍查询&quot;&quot;&quot;</span><br>        self._check_index(index)<br><br>        node: Node = self.head<br>        <span class="hljs-keyword">if</span> index == <span class="hljs-number">0</span>:<br>            new_node: Node = node.<span class="hljs-built_in">next</span><br>            self.head = new_node<br>        <span class="hljs-keyword">elif</span> index == self.length - <span class="hljs-number">1</span>:<br>            self.append(item)<br>        <span class="hljs-keyword">else</span>:<br>            cursor: <span class="hljs-built_in">int</span> = <span class="hljs-number">0</span><br>            <span class="hljs-keyword">while</span> node <span class="hljs-keyword">and</span> node.<span class="hljs-built_in">next</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> self.head:<br>                prev_node = node<br>                node = node.<span class="hljs-built_in">next</span><br>                cursor += <span class="hljs-number">1</span><br><br>                <span class="hljs-keyword">if</span> index == cursor:<br>                    new_node = Node(item, node.<span class="hljs-built_in">next</span>)<br>                    prev_node.<span class="hljs-built_in">next</span> = new_node<br>                    new_node.prev = prev_node<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">insert</span>(<span class="hljs-params">self, index: <span class="hljs-built_in">int</span>, item: Any</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;向指定位置插入数据&quot;&quot;&quot;</span><br>        self._check_index(index)<br><br>        <span class="hljs-keyword">if</span> index == <span class="hljs-number">0</span>:<br>            new_node: Node = Node(item, self.head)<br>            self.head = new_node<br>        <span class="hljs-keyword">elif</span> index == self.length - <span class="hljs-number">1</span>:<br>            self.append(item)<br>        <span class="hljs-keyword">else</span>:<br>            node: Node = self.head<br>            cursor: <span class="hljs-built_in">int</span> = <span class="hljs-number">0</span><br>            <span class="hljs-keyword">while</span> node <span class="hljs-keyword">and</span> node.<span class="hljs-built_in">next</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> self.head:<br>                prev_node = node<br>                node = node.<span class="hljs-built_in">next</span><br>                cursor += <span class="hljs-number">1</span><br><br>                <span class="hljs-keyword">if</span> index == cursor:<br>                    new_node = Node(item, node)<br>                    prev_node.<span class="hljs-built_in">next</span> = new_node<br>                    new_node.<span class="hljs-built_in">next</span> = node<br>                    new_node.prev = prev_node<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">delete</span>(<span class="hljs-params">self, index: <span class="hljs-built_in">int</span></span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;删除指定位置数据&quot;&quot;&quot;</span><br>        self._check_index(index)<br><br>        node: Node = self.head<br>        <span class="hljs-comment"># 如果是0的话，起点改为第二个数据</span><br>        <span class="hljs-keyword">if</span> index == <span class="hljs-number">0</span>:<br>            new_node: Node = node.<span class="hljs-built_in">next</span><br>            new_node.prev = self.head.prev<br>            self.head = new_node<br>        <span class="hljs-keyword">else</span>:<br>            cursor: <span class="hljs-built_in">int</span> = <span class="hljs-number">1</span><br>            <span class="hljs-keyword">while</span> node <span class="hljs-keyword">and</span> node.<span class="hljs-built_in">next</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> self.head:<br>                prev_node = node<br>                node = node.<span class="hljs-built_in">next</span><br>                cursor += <span class="hljs-number">1</span><br>                <span class="hljs-comment"># 把下一个数据的指针，改为下下个数据的指针</span><br>                <span class="hljs-keyword">if</span> index == cursor:<br>                    prev_node.<span class="hljs-built_in">next</span> = node.<span class="hljs-built_in">next</span><br>                    node.prev = prev_node<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__contains__</span>(<span class="hljs-params">self, item: Any</span>) -&gt; bool:</span><br>        <span class="hljs-string">&quot;&quot;&quot;查找元素是否在里面&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> self.is_empty():<br>            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&#x27;Linklist is empty.&#x27;</span>)<br><br>        node: Node = self.head<br>        <span class="hljs-keyword">while</span> node:<br>            <span class="hljs-keyword">if</span> item == node.data:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>            node = node.<span class="hljs-built_in">next</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure>
<h3 id="1-5队列"><a href="#1-5队列" class="headerlink" title="1.5队列"></a>1.5队列</h3><p>队列，是一种先进先出的数据结构, 实际的应用场景很多，像抢手机时，有个排队页面，这里就用到队列排队<br>这里使用list这个数据结构封装成队列.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> Any, Optional<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;创建数据和数据对应的指针&quot;&quot;&quot;</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, val: Any, node: Optional[<span class="hljs-string">&quot;Node&quot;</span>] = <span class="hljs-literal">None</span></span>):</span><br>        self.data: Any = val<br>        self.<span class="hljs-built_in">next</span>: Optional[<span class="hljs-string">&quot;Node&quot;</span>] = node<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Queue</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, max_length: <span class="hljs-built_in">int</span></span>):</span><br>        <span class="hljs-comment"># 定义队列长度</span><br>        self.size: <span class="hljs-built_in">int</span> = <span class="hljs-number">0</span><br>        self.max_length: <span class="hljs-built_in">int</span> = max_length<br><br>        <span class="hljs-comment"># 定义首尾node</span><br>        self.head_node: Optional[Node] = <span class="hljs-literal">None</span><br>        self.tail_node: Optional[Node] = <span class="hljs-literal">None</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">put</span>(<span class="hljs-params">self, value: Any</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;入队操作&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> self.is_full():<br>            <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">&quot;queue is full&quot;</span>)<br>        <span class="hljs-keyword">elif</span> self.is_empty():<br>            node: Node = Node(value)<br>            self.head_node = node<br>            self.tail_node = node<br>        <span class="hljs-keyword">else</span>:<br>            node: Node = Node(value)<br>            self.tail_node.<span class="hljs-built_in">next</span> = node<br>            self.tail_node = node<br>        self.size += <span class="hljs-number">1</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get</span>(<span class="hljs-params">self</span>) -&gt; Any:</span><br>        <span class="hljs-comment"># 出队操作，切片取数据是O(1)，如果要使用remove复杂度为O(k)</span><br>        <span class="hljs-keyword">if</span> self.is_empty():<br>            <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">&quot;queue is empty&quot;</span>)<br>        <span class="hljs-keyword">else</span>:<br>            self.size -= <span class="hljs-number">1</span><br>            value: Any = self.head_node.data<br>            self.head_node = self.head_node.<span class="hljs-built_in">next</span><br>            <span class="hljs-keyword">return</span> value<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__len__</span>(<span class="hljs-params">self</span>) -&gt; int:</span><br>        <span class="hljs-keyword">if</span> self.is_empty():<br>            <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">&quot;queue is empty&quot;</span>)<br>        <span class="hljs-keyword">return</span> self.size<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">is_full</span>(<span class="hljs-params">self</span>) -&gt; bool:</span><br>        <span class="hljs-keyword">return</span> self.size == self.max_length<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">is_empty</span>(<span class="hljs-params">self</span>) -&gt; bool:</span><br>        <span class="hljs-keyword">return</span> self.size == <span class="hljs-number">0</span><br><br><span class="hljs-meta">    @classmethod</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">from_list</span>(<span class="hljs-params">cls, raw_list: <span class="hljs-built_in">list</span></span>) -&gt; &quot;Queue&quot;:</span><br>        instance: <span class="hljs-string">&quot;Queue&quot;</span> = cls(<span class="hljs-built_in">len</span>(raw_list))<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> raw_list:<br>            instance.put(i)<br>        <span class="hljs-keyword">return</span> instance<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">to_list</span>(<span class="hljs-params">self</span>) -&gt; list:</span><br>        <span class="hljs-keyword">if</span> self.is_empty():<br>            <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">&quot;queue is empty&quot;</span>)<br>        _list: <span class="hljs-built_in">list</span> = []<br>        node: Node = self.head_node<br>        <span class="hljs-keyword">while</span> node:<br>            _list.append(node.data)<br>            node = node.<span class="hljs-built_in">next</span><br>        <span class="hljs-keyword">return</span> _list<br></code></pre></td></tr></table></figure>
<h3 id="1-6双端队列"><a href="#1-6双端队列" class="headerlink" title="1.6双端队列"></a>1.6双端队列</h3><p>正常的队列是只有一进一出, 比如右进左出, 但是双端队列可以左进左出, 右进右出, 右进左出, 左进右出. 如果把队列的底层实现看做单链表, 那么双端队列的实现就是循环链表, 只需要在队列的Node添加prev前驱指针, 并把最后一个Node的next指针指向head node, head node的prev前驱指针指向tail node即可</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> Any, Optional<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;创建数据和数据对应的指针&quot;&quot;&quot;</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, val: Any, next_node: Optional[<span class="hljs-string">&quot;Node&quot;</span>] = <span class="hljs-literal">None</span>, prev_node: Optional[<span class="hljs-string">&quot;Node&quot;</span>] = <span class="hljs-literal">None</span></span>):</span><br>        self.data: Any = val<br>        self.<span class="hljs-built_in">next</span>: Optional[<span class="hljs-string">&quot;Node&quot;</span>] = next_node<br>        self.prev: Optional[<span class="hljs-string">&quot;None&quot;</span>] = prev_node<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Deque</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, max_length: <span class="hljs-built_in">int</span></span>):</span><br>        <span class="hljs-comment"># 定义队列长度</span><br>        self.size: <span class="hljs-built_in">int</span> = <span class="hljs-number">0</span><br>        self.max_length: <span class="hljs-built_in">int</span> = max_length<br><br>        <span class="hljs-comment"># 定义首尾node</span><br>        self.head_node: Optional[Node] = <span class="hljs-literal">None</span><br>        self.tail_node: Optional[Node] = <span class="hljs-literal">None</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">put_left</span>(<span class="hljs-params">self, value: Any</span>):</span><br>        <span class="hljs-keyword">if</span> self.is_full():<br>            <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">&quot;queue is full&quot;</span>)<br>        <span class="hljs-keyword">elif</span> self.is_empty():<br>            node: Node = Node(value)<br>            self.head_node = node<br>            self.tail_node = node<br>        <span class="hljs-keyword">else</span>:<br>            node: Node = Node(value, self.head_node, self.tail_node)<br>            self.tail_node.<span class="hljs-built_in">next</span> = node<br>            self.head_node = node<br>        self.size += <span class="hljs-number">1</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">put</span>(<span class="hljs-params">self, value: Any</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;入队操作&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> self.is_full():<br>            <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">&quot;queue is full&quot;</span>)<br>        <span class="hljs-keyword">elif</span> self.is_empty():<br>            node: Node = Node(value)<br>            self.head_node = node<br>            self.tail_node = node<br>        <span class="hljs-keyword">else</span>:<br>            node: Node = Node(value, self.head_node, self.tail_node)<br>            self.tail_node.<span class="hljs-built_in">next</span> = node<br>            self.tail_node = node<br>        self.size += <span class="hljs-number">1</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get</span>(<span class="hljs-params">self</span>) -&gt; Any:</span><br>        <span class="hljs-comment"># 出队操作，切片取数据是O(1)，如果要使用remove复杂度为O(k)</span><br>        <span class="hljs-keyword">if</span> self.is_empty():<br>            <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">&quot;queue is empty&quot;</span>)<br>        <span class="hljs-keyword">else</span>:<br>            self.size -= <span class="hljs-number">1</span><br>            value: Any = self.head_node.data<br>            self.head_node = self.head_node.<span class="hljs-built_in">next</span><br>            <span class="hljs-keyword">return</span> value<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">pop</span>(<span class="hljs-params">self</span>) -&gt; Any:</span><br>        <span class="hljs-keyword">if</span> self.is_empty():<br>            <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">&quot;queue is empty&quot;</span>)<br>        <span class="hljs-keyword">else</span>:<br>            self.size -= <span class="hljs-number">1</span><br>            value: Any = self.tail_node.data<br>            self.tail_node = self.tail_node.prev<br>            self.tail_node.<span class="hljs-built_in">next</span> = self.head_node<br>            self.head_node.prev = self.tail_node<br>            <span class="hljs-keyword">return</span> value<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__len__</span>(<span class="hljs-params">self</span>) -&gt; int:</span><br>        <span class="hljs-keyword">if</span> self.is_empty():<br>            <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">&quot;queue is empty&quot;</span>)<br>        <span class="hljs-keyword">return</span> self.size<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">is_full</span>(<span class="hljs-params">self</span>) -&gt; bool:</span><br>        <span class="hljs-keyword">return</span> self.size == self.max_length<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">is_empty</span>(<span class="hljs-params">self</span>) -&gt; bool:</span><br>        <span class="hljs-keyword">return</span> self.size == <span class="hljs-number">0</span><br><br><span class="hljs-meta">    @classmethod</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">from_list</span>(<span class="hljs-params">cls, raw_list: <span class="hljs-built_in">list</span></span>) -&gt; &quot;Deque&quot;:</span><br>        instance: <span class="hljs-string">&quot;Deque&quot;</span> = cls(<span class="hljs-built_in">len</span>(raw_list))<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> raw_list:<br>            instance.put(i)<br>        <span class="hljs-keyword">return</span> instance<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">to_list</span>(<span class="hljs-params">self</span>) -&gt; list:</span><br>        <span class="hljs-keyword">if</span> self.is_empty():<br>            <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">&quot;queue is empty&quot;</span>)<br>        _list: <span class="hljs-built_in">list</span> = []<br>        node: Node = self.head_node<br>        <span class="hljs-keyword">while</span> node:<br>            _list.append(node.data)<br>            <span class="hljs-keyword">if</span> node.<span class="hljs-built_in">next</span> <span class="hljs-keyword">is</span> self.head_node:<br>                <span class="hljs-keyword">break</span><br>            node = node.<span class="hljs-built_in">next</span><br>        <span class="hljs-keyword">return</span> _list<br></code></pre></td></tr></table></figure>
<h3 id="1-7栈"><a href="#1-7栈" class="headerlink" title="1.7栈"></a>1.7栈</h3><p>栈可以看做是一个顺序表的订制版, 他只能对最后一个子项进行处理, 只能在最后添加子项或者弹出最后一个子项.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> Any<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Stack</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;在Python中使用list模拟线性表...&quot;&quot;&quot;</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, max_length: <span class="hljs-built_in">int</span> = <span class="hljs-number">10</span>, extend_num: <span class="hljs-built_in">int</span> = <span class="hljs-number">8</span></span>):</span><br>        self.max_length: <span class="hljs-built_in">int</span> = max_length<br><br>        <span class="hljs-comment"># 当前有效的数组最长值</span><br>        <span class="hljs-comment"># 比如数组实际长度为20, 当只用了10个, 那么num为10</span><br>        self.num: <span class="hljs-built_in">int</span> = <span class="hljs-number">0</span><br>        <span class="hljs-comment"># 扩容的长度</span><br>        self.extend_num: <span class="hljs-built_in">int</span> = extend_num<br>        self.data = [<span class="hljs-literal">None</span>] * self.max_length<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">is_empty</span>(<span class="hljs-params">self</span>) -&gt; bool:</span><br>        <span class="hljs-keyword">return</span> self.num == <span class="hljs-number">0</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">is_full</span>(<span class="hljs-params">self</span>) -&gt; bool:</span><br>        <span class="hljs-keyword">return</span> self.num == self.max_length<br><br><span class="hljs-meta">    @classmethod</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">from_list</span>(<span class="hljs-params">cls, raw_list: <span class="hljs-built_in">list</span></span>):</span><br>        instance: <span class="hljs-string">&quot;Stack&quot;</span> = cls()<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> raw_list:<br>            instance.append(i)<br>        <span class="hljs-keyword">return</span> instance<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">to_list</span>(<span class="hljs-params">self</span>) -&gt; list:</span><br>        <span class="hljs-keyword">return</span> self.data[: self.num]<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_extend</span>(<span class="hljs-params">self</span>):</span><br>        self.data.extend([<span class="hljs-literal">None</span>] * self.extend_num)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__len__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> self.num<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">append</span>(<span class="hljs-params">self, value: Any</span>):</span><br>        <span class="hljs-keyword">if</span> self.is_full():<br>            <span class="hljs-comment"># 如果满了则进行扩容</span><br>            self._extend()<br>        self.data[self.num] = value<br>        self.num += <span class="hljs-number">1</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">pop</span>(<span class="hljs-params">self</span>) -&gt; Any:</span><br>        <span class="hljs-string">&quot;&quot;&quot;假删除, 只是把值往前挪, 缩小一个有效范围&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> self.num - <span class="hljs-number">1</span> &lt; <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">raise</span> IndexError(<span class="hljs-string">&quot;pop from empty list&quot;</span>)<br>        <span class="hljs-keyword">else</span>:<br>            value: Any = self.data[self.num]<br>            self.num -= <span class="hljs-number">1</span><br>            <span class="hljs-keyword">return</span> value<br></code></pre></td></tr></table></figure>
<h2 id="2-二维数据结构–树"><a href="#2-二维数据结构–树" class="headerlink" title="2.二维数据结构–树"></a>2.二维数据结构–树</h2><p>树是链表的一个变体, 但链表有一个节点有一个分叉时,这个链表就是树. 树有很简单的二叉树, 也有复杂的红黑树, 树的应用很多.<br>树有很多专属名词:</p>
<ul>
<li>路径  从树中一个结点到另一个结点之间的分支构成两个结点之间的路径.</li>
<li>路径长度  路径上的分支数目称作路径长度。</li>
<li>树的路径长度  树的路径长度就是从根节点到每一结点的路径长度之和。</li>
<li>结点的带权路径长度  结点的带权路径长度就是从该结点到根节点之间的路径长度与结点上权的乘积。</li>
<li>树的带权路径长度  树的带权路径长度就是树中所有叶子结点的带权路径长度之和，通常记做WPL。</li>
</ul>
<h3 id="2-1二叉树以及遍历"><a href="#2-1二叉树以及遍历" class="headerlink" title="2.1二叉树以及遍历"></a>2.1二叉树以及遍历</h3><p><img    class="lazyload" data-original="https://github.com/so1n/so1n_blog_photo/blob/master/blog_photo/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86.jpg?raw=true" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">树以及遍历</span><br>图是一个二叉树以及遍历的说明, 可以看出各种遍历的规律:</p>
<ul>
<li>层级遍历  一层一层的遍历, 为了达到遍历左节点后能再遍历右节点, 需要利用队列的先进先出来实现.</li>
<li>前序遍历  从跟节点开始, 如果有左节点就读左节点的数据, 没有则读右节点的数据</li>
<li>中序遍历  优先读取最深子节点, 没有则读最深子节点的上一个节点, 再读上一个节点的右节点  </li>
<li>后序遍历  优先读取的最深子节点, 同时也保持优先读取左节点再读右节点的原则</li>
</ul>
<p>我们根据图实现一个二叉树, 并实现各种遍历:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> queue <span class="hljs-keyword">import</span> Queue<br><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> Any, Optional<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BinaryTreeNode</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, data: Any, left: Optional[<span class="hljs-string">&quot;BinaryTreeNode&quot;</span>] = <span class="hljs-literal">None</span>, right: Optional[<span class="hljs-string">&quot;BinaryTreeNode&quot;</span>] = <span class="hljs-literal">None</span></span>):</span><br>        self.left: Optional[<span class="hljs-string">&quot;BinaryTreeNode&quot;</span>] = left<br>        self.right: Optional[<span class="hljs-string">&quot;BinaryTreeNode&quot;</span>] = right<br>        self.data: Any = data<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BinaryTreeHelper</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, root: BinaryTreeNode</span>):</span><br>        self.root: BinaryTreeNode = root<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">pre_order</span>(<span class="hljs-params">self, node: Optional[BinaryTreeNode] = <span class="hljs-literal">None</span></span>) -&gt; list:</span><br>        <span class="hljs-string">&quot;&quot;&quot;前序遍历&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> node <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            node = self.root<br>        _list: <span class="hljs-built_in">list</span> = []<br><br>        <span class="hljs-keyword">if</span> node <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            _list.append(node.data)<br>            <span class="hljs-keyword">if</span> node.left <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>                _list.extend(self.pre_order(node.left))<br>            <span class="hljs-keyword">if</span> node.right <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>                _list.extend(self.pre_order(node.right))<br>        <span class="hljs-keyword">return</span> _list<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">in_order</span>(<span class="hljs-params">self, node: Optional[BinaryTreeNode] = <span class="hljs-literal">None</span></span>) -&gt; list:</span><br>        <span class="hljs-string">&quot;&quot;&quot;中序遍历&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> node <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            node = self.root<br>        _list: <span class="hljs-built_in">list</span> = []<br>        <span class="hljs-keyword">if</span> node <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">if</span> node.left <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>                _list.extend(self.in_order(node.left))<br>            _list.append(node.data)<br>            <span class="hljs-keyword">if</span> node.right <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>                _list.extend(self.in_order(node.right))<br>        <span class="hljs-keyword">return</span> _list<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">post_order</span>(<span class="hljs-params">self, node: Optional[BinaryTreeNode] = <span class="hljs-literal">None</span></span>) -&gt; list:</span><br>        <span class="hljs-string">&quot;&quot;&quot;后序遍历&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> node <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            node = self.root<br>        _list: <span class="hljs-built_in">list</span> = []<br>        <span class="hljs-keyword">if</span> node <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">if</span> node.left <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>                _list.extend(self.post_order(node.left))<br>            <span class="hljs-keyword">if</span> node.right <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>                _list.extend(self.post_order(node.right))<br>            _list.append(node.data)<br>        <span class="hljs-keyword">return</span> _list<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">level_order</span>(<span class="hljs-params">self, node: Optional[BinaryTreeNode] = <span class="hljs-literal">None</span></span>) -&gt; list:</span><br>        <span class="hljs-string">&quot;&quot;&quot;层级遍历&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> node <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            node = self.root<br>        _list: <span class="hljs-built_in">list</span> = []<br><br>        queue: <span class="hljs-string">&quot;Queue&quot;</span> = Queue()<br>        <span class="hljs-keyword">while</span> node <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            _list.append(node.data)<br>            <span class="hljs-keyword">if</span> node.left <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>                queue.put(node.left)<br>            <span class="hljs-keyword">if</span> node.right <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>                queue.put(node.right)<br>            <span class="hljs-keyword">if</span> queue.empty():<br>                node = <span class="hljs-literal">None</span><br>            <span class="hljs-keyword">else</span>:<br>                node = queue.get()<br>        <span class="hljs-keyword">return</span> _list<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    binary_tree: BinaryTreeNode = BinaryTreeNode(<br>        <span class="hljs-string">&quot;0&quot;</span>,<br>        BinaryTreeNode(<br>            <span class="hljs-string">&quot;1&quot;</span>,<br>            BinaryTreeNode(<br>                <span class="hljs-string">&quot;3&quot;</span>,<br>                BinaryTreeNode(<span class="hljs-string">&quot;7&quot;</span>),<br>                BinaryTreeNode(<span class="hljs-string">&quot;8&quot;</span>)<br>            ),<br>            BinaryTreeNode(<br>                <span class="hljs-string">&quot;4&quot;</span>,<br>                BinaryTreeNode(<span class="hljs-string">&quot;9&quot;</span>)<br>            )<br>        ),<br>        BinaryTreeNode(<br>            <span class="hljs-string">&quot;2&quot;</span>,<br>            BinaryTreeNode(<span class="hljs-string">&quot;5&quot;</span>),<br>            BinaryTreeNode(<span class="hljs-string">&quot;6&quot;</span>),<br>        )<br>    )<br>    binary_tree_helper: BinaryTreeHelper = BinaryTreeHelper(binary_tree)<br>    print(<span class="hljs-string">&quot;层级遍历&quot;</span>, binary_tree_helper.level_order())<br>    print(<span class="hljs-string">&quot;前序遍历&quot;</span>, binary_tree_helper.pre_order())<br>    print(<span class="hljs-string">&quot;中序遍历&quot;</span>, binary_tree_helper.in_order())<br>    print(<span class="hljs-string">&quot;后序遍历&quot;</span>, binary_tree_helper.post_order())<br></code></pre></td></tr></table></figure>
<h3 id="2-2哈弗曼树"><a href="#2-2哈弗曼树" class="headerlink" title="2.2哈弗曼树"></a>2.2哈弗曼树</h3><p>哈弗曼树是树的应用之一<br>利用哈弗曼树做出了最早的压缩编码哈弗曼编码，根据每个字母的出现频率来定义他们如：<br>(‘C’, 2), (‘G’, 2), (‘E’, 3), (‘K’, 3), (‘B’, 4),(‘F’, 4), (‘I’, 4), (‘J’, 4), (‘D’, 5), (‘H’, 6),(‘N’, 6), (‘L’, 7), (‘M’, 9), (‘A’, 10),(‘O’,5)<br>按照频路形成由上到下，由左到右的二叉树，且左树的权为0，右树的权为1<br>利用哈弗曼树输出哈弗曼编码<br>代码来自于：<a href="https://www.2cto.com/kf/201503/385537.html">https://www.2cto.com/kf/201503/385537.html</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self,freq</span>):</span><br>        self.left = <span class="hljs-literal">None</span><br>        self.right = <span class="hljs-literal">None</span><br>        self.father = <span class="hljs-literal">None</span><br>        self.freq = freq<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isLeft</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> self.father.left == self<br><span class="hljs-comment">#create nodes创建叶子节点</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">createNodes</span>(<span class="hljs-params">freqs</span>):</span><br>    <span class="hljs-keyword">return</span> [Node(freq) <span class="hljs-keyword">for</span> freq <span class="hljs-keyword">in</span> freqs]<br><br><span class="hljs-comment">#create Huffman-Tree创建Huffman树</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">createHuffmanTree</span>(<span class="hljs-params">nodes</span>):</span><br>    queue = nodes[:]<br>    <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(queue) &gt; <span class="hljs-number">1</span>:<br>        queue.sort(key=<span class="hljs-keyword">lambda</span> item:item.freq)<br>        node_left = queue.pop(<span class="hljs-number">0</span>)<br>        node_right = queue.pop(<span class="hljs-number">0</span>)<br>        node_father = Node(node_left.freq + node_right.freq)<br>        node_father.left = node_left<br>        node_father.right = node_right<br>        node_left.father = node_father<br>        node_right.father = node_father<br>        queue.append(node_father)<br>    queue[<span class="hljs-number">0</span>].father = <span class="hljs-literal">None</span><br>    <span class="hljs-keyword">return</span> queue[<span class="hljs-number">0</span>]<br><span class="hljs-comment">#Huffman编码</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">huffmanEncoding</span>(<span class="hljs-params">nodes,root</span>):</span><br>    codes = [<span class="hljs-string">&#x27;&#x27;</span>] * <span class="hljs-built_in">len</span>(nodes)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nodes)):<br>        node_tmp = nodes[i]<br>        <span class="hljs-keyword">while</span> node_tmp != root:<br>            <span class="hljs-keyword">if</span> node_tmp.isLeft():<br>                codes[i] = <span class="hljs-string">&#x27;0&#x27;</span> + codes[i]<br>            <span class="hljs-keyword">else</span>:<br>                codes[i] = <span class="hljs-string">&#x27;1&#x27;</span> + codes[i]<br>            node_tmp = node_tmp.father<br>    <span class="hljs-keyword">return</span> codes<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-comment">#chars = [&#x27;A&#x27;,&#x27;B&#x27;,&#x27;C&#x27;,&#x27;D&#x27;,&#x27;E&#x27;,&#x27;F&#x27;,&#x27;G&#x27;,&#x27;H&#x27;,&#x27;I&#x27;,&#x27;J&#x27;,&#x27;K&#x27;,&#x27;L&#x27;,&#x27;M&#x27;,&#x27;N&#x27;]</span><br>    <span class="hljs-comment">#freqs = [10,4,2,5,3,4,2,6,4,4,3,7,9,6]</span><br>    chars_freqs = [(<span class="hljs-string">&#x27;C&#x27;</span>, <span class="hljs-number">2</span>), (<span class="hljs-string">&#x27;G&#x27;</span>, <span class="hljs-number">2</span>), (<span class="hljs-string">&#x27;E&#x27;</span>, <span class="hljs-number">3</span>), (<span class="hljs-string">&#x27;K&#x27;</span>, <span class="hljs-number">3</span>), (<span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-number">4</span>),<br>                   (<span class="hljs-string">&#x27;F&#x27;</span>, <span class="hljs-number">4</span>), (<span class="hljs-string">&#x27;I&#x27;</span>, <span class="hljs-number">4</span>), (<span class="hljs-string">&#x27;J&#x27;</span>, <span class="hljs-number">4</span>), (<span class="hljs-string">&#x27;D&#x27;</span>, <span class="hljs-number">5</span>), (<span class="hljs-string">&#x27;H&#x27;</span>, <span class="hljs-number">6</span>),<br>                   (<span class="hljs-string">&#x27;N&#x27;</span>, <span class="hljs-number">6</span>), (<span class="hljs-string">&#x27;L&#x27;</span>, <span class="hljs-number">7</span>), (<span class="hljs-string">&#x27;M&#x27;</span>, <span class="hljs-number">9</span>), (<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-number">10</span>)]<br>    nodes = createNodes([item[<span class="hljs-number">1</span>] <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> chars_freqs])<br>    root = createHuffmanTree(nodes)<br>    codes = huffmanEncoding(nodes,root)<br>    <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(chars_freqs,codes):<br>        <span class="hljs-built_in">print</span> (<span class="hljs-string">&#x27;Character:%s freq:%-2d   encoding: %s&#x27;</span> % (item[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>],item[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>],item[<span class="hljs-number">1</span>]))<br></code></pre></td></tr></table></figure>
<h2 id="3-图-Graph"><a href="#3-图-Graph" class="headerlink" title="3.图(Graph)"></a>3.图(Graph)</h2><h3 id="3-1图的遍历"><a href="#3-1图的遍历" class="headerlink" title="3.1图的遍历"></a>3.1图的遍历</h3><p>来源于：<a href="http://www.cnblogs.com/yupeng/p/3414736.html">http://www.cnblogs.com/yupeng/p/3414736.html</a></p>
<blockquote>
<p>首先有一个概念：回溯<br>　　回溯法(探索与回溯法)是一种选优搜索法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。<br>深度优先算法：<br>（1）访问初始顶点v并标记顶点v已访问。<br>（2）查找顶点v的第一个邻接顶点w。<br>（3）若顶点v的邻接顶点w存在，则继续执行；否则回溯到v，再找v的另外一个未访问过的邻接点。<br>（4）若顶点w尚未被访问，则访问顶点w并标记顶点w为已访问。<br>（5）继续查找顶点w的下一个邻接顶点wi，如果v取值wi转到步骤（3）。直到连通图中所有顶点全部访问过为止。<br>广度优先算法：<br>（1）顶点v入队列。<br>（2）当队列非空时则继续执行，否则算法结束。<br>（3）出队列取得队头顶点v；访问顶点v并标记顶点v已被访问。<br>（4）查找顶点v的第一个邻接顶点col。<br>（5）若v的邻接顶点col未被访问过的，则col入队列。<br>（6）继续查找顶点v的另一个新的邻接顶点col，转到步骤（5）。直到顶点v的所有未被访问过的邻接点处理完。转到步骤（2）。</p>
</blockquote>
<p>通俗点讲<br>假如有个房屋，房屋里有3间房，每间房有桌子，抽屉，床。而我们要的钥匙可能在桌子，抽屉，床上面。<br>而钥匙放在抽屉的概率&gt;桌子&gt;床<br>深度优先遍历就是先找一间房间，找完房间里的桌子，抽屉，床后再找另外一个房间<br>广度优先遍历则是先找每间房间里的抽屉，找完后再找每间房间的桌子，找完后再找每间房间的床<br>ps广度优先遍历类似于树的层级遍历<br>实现代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Graph</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self,*args,**kwargs</span>):</span><br>        self.node_neighbors = &#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add_nodes</span>(<span class="hljs-params">self,nodelist</span>):</span><br>        <span class="hljs-comment">#批量添加节点</span><br>        <span class="hljs-keyword">for</span> node <span class="hljs-keyword">in</span> nodelist:<br>            self.add_node(node)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add_node</span>(<span class="hljs-params">self,node</span>):</span><br>        <span class="hljs-comment">#添加节点</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> node <span class="hljs-keyword">in</span> self.nodes():<br>            self.node_neighbors[node] = []<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add_edge</span>(<span class="hljs-params">self,edge</span>):</span><br>        <span class="hljs-comment">#定义节点的邻接点(双向的)</span><br>        u,v = edge<br>        <span class="hljs-keyword">if</span>(v <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> self.node_neighbors[u]) <span class="hljs-keyword">and</span> ( u <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> self.node_neighbors[v]):<br>            self.node_neighbors[u].append(v)<br><br>            <span class="hljs-keyword">if</span>(u!=v):<br>                self.node_neighbors[v].append(u)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">nodes</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-comment">#返回节点</span><br>        <span class="hljs-keyword">return</span> self.node_neighbors.keys()<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">depth_first_search</span>(<span class="hljs-params">self,root=<span class="hljs-literal">None</span></span>):</span><br>        <span class="hljs-comment">#深度遍历</span><br>        visited = &#123;&#125;<br>        order = [] <span class="hljs-comment">#记录遍历好的节点</span><br>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dfs</span>(<span class="hljs-params">node</span>):</span><br>            visited[node] = <span class="hljs-literal">True</span> <span class="hljs-comment">#代表该节点标记为读取过了</span><br>            order.append(node) <span class="hljs-comment">#记录</span><br>            <span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> self.node_neighbors[node]:<br>                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> n <span class="hljs-keyword">in</span> visited:<br>                    dfs(n) <span class="hljs-comment">#取出第一个节点，利用回调，遍历该节点的第一个邻节点</span><br><br><br>        <span class="hljs-keyword">if</span> root:<br>            dfs(root)<br><br>        <span class="hljs-comment">#如果定义了开始节点，此步骤就是最后循环一遍，把未遍历的点再遍历一次</span><br>        <span class="hljs-comment">#如果没定义节点，此步骤就是记录要遍历的点</span><br>        <span class="hljs-keyword">for</span> node <span class="hljs-keyword">in</span> self.nodes():<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> node <span class="hljs-keyword">in</span> visited:<br>                dfs(node)<br><br>        <span class="hljs-built_in">print</span> (order)<br><br>        <span class="hljs-keyword">return</span> order<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">breadth_first_search</span>(<span class="hljs-params">self,root=<span class="hljs-literal">None</span></span>):</span><br>        <span class="hljs-comment">#广度遍历</span><br>        visited = &#123;&#125;<br>        queue = [] <span class="hljs-comment">#记录要遍历的节点</span><br>        order = [] <span class="hljs-comment">#记录遍历好的节点</span><br>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">bfs</span>():</span><br>            <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(queue)&gt; <span class="hljs-number">0</span>:<br>                node  = queue.pop(<span class="hljs-number">0</span>) <span class="hljs-comment">#取出顶点</span><br>                visited[node] = <span class="hljs-literal">True</span> <span class="hljs-comment">#代表该节点标记为读取过了</span><br>                <span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> self.node_neighbors[node]: <span class="hljs-comment">#self.node_neighbors[node]为读取对应key的value也就是读取节点对应的邻节点</span><br>                    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">not</span> n <span class="hljs-keyword">in</span> visited) <span class="hljs-keyword">and</span> (<span class="hljs-keyword">not</span> n <span class="hljs-keyword">in</span> queue):<br>                        <span class="hljs-comment">#not n in self.visited判断这个节点是否读取过，not n in queue用来对节点对应的邻节点去重</span><br>                        queue.append(n) <span class="hljs-comment">#添加要遍历的节点</span><br>                        order.append(n) <span class="hljs-comment">#记录遍历好的节点</span><br><br>        <span class="hljs-keyword">if</span> root:<br>            queue.append(root)<br>            order.append(root)<br>            bfs()<br><br>        <span class="hljs-comment">#如果定义了开始节点，此步骤就是最后循环一遍，把未遍历的点再遍历一次</span><br>        <span class="hljs-comment">#如果没定义节点，此步骤就是记录要遍历的点</span><br>        <span class="hljs-keyword">for</span> node <span class="hljs-keyword">in</span> self.nodes():<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> node <span class="hljs-keyword">in</span> visited:<br>                queue.append(node)<br>                order.append(node)<br>                bfs()<br>        <span class="hljs-built_in">print</span> (order)<br><br>        <span class="hljs-keyword">return</span> order<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    g = Graph()<br>g.add_nodes([i+<span class="hljs-number">1</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">8</span>)])<br>g.add_edge((<span class="hljs-number">1</span>, <span class="hljs-number">2</span>))<br>g.add_edge((<span class="hljs-number">1</span>, <span class="hljs-number">3</span>))<br>g.add_edge((<span class="hljs-number">2</span>, <span class="hljs-number">4</span>))<br>g.add_edge((<span class="hljs-number">2</span>, <span class="hljs-number">5</span>))<br>g.add_edge((<span class="hljs-number">4</span>, <span class="hljs-number">8</span>))<br>g.add_edge((<span class="hljs-number">5</span>, <span class="hljs-number">8</span>))<br>g.add_edge((<span class="hljs-number">3</span>, <span class="hljs-number">6</span>))<br>g.add_edge((<span class="hljs-number">3</span>, <span class="hljs-number">7</span>))<br>g.add_edge((<span class="hljs-number">6</span>, <span class="hljs-number">7</span>))<br><span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;nodes:&quot;</span>, g.nodes())<br><br>order = g.breadth_first_search(<span class="hljs-number">1</span>)<br>order = g.depth_first_search(<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure>


<h3 id="3-2图的路径"><a href="#3-2图的路径" class="headerlink" title="3.2图的路径"></a>3.2图的路径</h3><p>代码来于：<a href="http://www.cnblogs.com/yupeng/p/3414569.html">http://www.cnblogs.com/yupeng/p/3414569.html</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">find_path</span>(<span class="hljs-params">graph, start, end, path=[]</span>):</span><br>        path = path + [start]<br>        <span class="hljs-keyword">if</span> start == end:<br>            <span class="hljs-keyword">return</span> path<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> start <span class="hljs-keyword">in</span> graph:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>        <span class="hljs-keyword">for</span> node <span class="hljs-keyword">in</span> graph[start]:<br>            <span class="hljs-keyword">if</span> node <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> path:<br>                newpath = find_path(graph, node, end, path)<br>                <span class="hljs-keyword">if</span> newpath: <br>                    <span class="hljs-keyword">return</span> newpath<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">find_all_paths</span>(<span class="hljs-params">graph, start, end, path=[]</span>):</span><br>        path = path + [start]<br>        <span class="hljs-keyword">if</span> start == end:<br>            <span class="hljs-keyword">return</span> [path]<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> start <span class="hljs-keyword">in</span> graph:<br>            <span class="hljs-keyword">return</span> []<br>        paths = []<br>        <span class="hljs-keyword">for</span> node <span class="hljs-keyword">in</span> graph[start]:<br>            <span class="hljs-keyword">if</span> node <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> path:<br>                newpaths = find_all_paths(graph, node, end, path)<br>                <span class="hljs-keyword">for</span> newpath <span class="hljs-keyword">in</span> newpaths:<br>                    paths.append(newpath)<br>        <span class="hljs-keyword">return</span> paths<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">find_shortest_path</span>(<span class="hljs-params">graph, start, end, path=[]</span>):</span><br>        path = path + [start]<br>        <span class="hljs-keyword">if</span> start == end:<br>            <span class="hljs-keyword">return</span> path<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> start <span class="hljs-keyword">in</span> graph:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>        shortest = <span class="hljs-literal">None</span><br>        <span class="hljs-keyword">for</span> node <span class="hljs-keyword">in</span> graph[start]:<br>            <span class="hljs-keyword">if</span> node <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> path:<br>                newpath = find_shortest_path(graph, node, end, path)<br>                <span class="hljs-keyword">if</span> newpath:<br>                    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> shortest <span class="hljs-keyword">or</span> <span class="hljs-built_in">len</span>(newpath) &lt; <span class="hljs-built_in">len</span>(shortest):<br>                        shortest = newpath<br>        <span class="hljs-keyword">return</span> shortest<br><br>graph = &#123;<span class="hljs-string">&#x27;A&#x27;</span>: [<span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>],<br>             <span class="hljs-string">&#x27;B&#x27;</span>: [<span class="hljs-string">&#x27;C&#x27;</span>, <span class="hljs-string">&#x27;D&#x27;</span>],<br>             <span class="hljs-string">&#x27;C&#x27;</span>: [<span class="hljs-string">&#x27;D&#x27;</span>],<br>             <span class="hljs-string">&#x27;D&#x27;</span>: [<span class="hljs-string">&#x27;C&#x27;</span>],<br>             <span class="hljs-string">&#x27;E&#x27;</span>: [<span class="hljs-string">&#x27;F&#x27;</span>],<br>             <span class="hljs-string">&#x27;F&#x27;</span>: [<span class="hljs-string">&#x27;C&#x27;</span>]&#125;<br><br>print(find_path(graph,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;C&#x27;</span>))<br>print(find_all_paths(graph,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;C&#x27;</span>))<br>print(find_shortest_path(graph,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;C&#x27;</span>))<br></code></pre></td></tr></table></figure>
<p>其中遍历的最关键代码在于：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#1        path = path + [start]</span><br><span class="hljs-comment">#2        if start == end:</span><br><span class="hljs-comment">#3            return [path]</span><br><span class="hljs-comment">#4        if not start in graph:</span><br><span class="hljs-comment">#5            return []</span><br><span class="hljs-comment">#6        paths = []</span><br><span class="hljs-comment">#7        for node in graph[start]:</span><br><span class="hljs-comment">#8            if node not in path:</span><br><span class="hljs-comment">#9               newpaths = （对应自己的函数，再次遍历）(graph, node, end, path)</span><br></code></pre></td></tr></table></figure>
<p>这段代码采用深度遍历<br>理解的顺序如下<br>步骤0. #4如果终点不在图里面，直接返回空路径表<br>步骤1. #1把start添加到路径列表（末尾添加）<br>步骤2. #7遍历start对应字典的value<br>步骤3. #8判断value是否在路径列表<br>步骤4. #9回调函数，但起点已经换回刚才的value<br>步骤5. #2判断这个value是不是等于自己要的结束点，如果是就是一条路径，否则继续遍历</p>
<p>对于find_path。如果找到路径就直接返回<br>对于find_all_paths。找到了路径就添加到另一个列表里面，直到遍历完整个图<br>对于find_shortest_path。找到路径就跟之前的路径对比，如果长度短的就保存，遍历结束后，返回最后一条保存的路径</p>
]]></content>
      <categories>
        <category>编程基础</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>前端小功能收集</title>
    <url>/2017/10/19/15/</url>
    <content><![CDATA[<p>【废弃】前端渣渣收集自己用过的前端小功能</p>
<span id="more"></span>


<h1 id="前端小功能收集"><a href="#前端小功能收集" class="headerlink" title="前端小功能收集"></a>前端小功能收集</h1><h2 id="前记"><a href="#前记" class="headerlink" title="前记"></a>前记</h2><p>这个月在做个项目，由于自己前端几乎零基础，所以是想到什么就搜什么或者做什么。以下是功能记录<br>ps由于使用到了uikit前端，本身提供了很多功能，能引用到的我只了解下原理，但在这里就没记录了</p>
<h2 id="2017-10-18更新"><a href="#2017-10-18更新" class="headerlink" title="2017.10.18更新"></a>2017.10.18更新</h2><ul>
<li><a href="#%E6%90%9C%E7%B4%A2%E6%A1%86%E8%87%AA%E5%8A%A8%E8%A1%A5%E5%85%A8">搜索框自动补全</a></li>
<li><a href="#%E8%B7%9F%E9%9A%8F%E9%BC%A0%E6%A0%87%E5%9D%90%E6%A0%87%E5%BC%B9%E7%AA%97">跟随鼠标坐标弹窗</a></li>
<li><a href="#%E5%88%B7%E6%96%B0%E5%90%8E%E6%89%A7%E8%A1%8C%E4%BA%8B%E4%BB%B6">刷新后执行事件</a></li>
<li><a href="#%E9%9A%8F%E6%9C%BA%E6%98%BE%E7%A4%BA">随机显示</a></li>
<li><a href="#%E7%9B%91%E5%90%AC%E6%BB%9A%E5%8A%A8%E6%9D%A1%E6%98%BE%E7%A4%BA%E6%8C%89%E9%92%AE">监听滚动条显示按钮</a></li>
<li><a href="#%E7%AB%96%E5%88%86%E9%9A%94%E6%9D%A1">竖分隔条</a></li>
</ul>
<h3 id="搜索框自动补全"><a href="#搜索框自动补全" class="headerlink" title="搜索框自动补全"></a>搜索框自动补全</h3><p><img    class="lazyload" data-original="https://github.com/so1n/so1n_blog_photo/blob/master/blog_photo/%E5%89%8D%E7%AB%AF%E5%B0%8F%E5%8A%9F%E8%83%BD%E6%94%B6%E9%9B%86-%E8%87%AA%E5%8A%A8%E8%A1%A5%E5%85%A8.gif?raw=true" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">示例图</span><br>如果数据固定的就交给前端处理，数据是动态加载的就交给后端处理<br>部分html代码</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;from_station&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;from_station&quot;</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;&#123;&#123; from_station &#125;&#125;&quot;</span> <span class="hljs-attr">list</span>=<span class="hljs-string">&quot;list1&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">datalist</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;list1&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">datalist</span>&gt;</span><br><br></code></pre></td></tr></table></figure>
<p>js代码（结合后端（Django））</p>
<figure class="highlight vbscript"><table><tr><td class="code"><pre><code class="hljs vbscript">$(document).ready(<span class="hljs-keyword">function</span>()&#123;   <br>var ele_f_key = document.getElementById(<span class="hljs-string">&quot;from_station&quot;</span>);<br>var ele_t_key = document.getElementById(<span class="hljs-string">&quot;to_station&quot;</span>);<br>var val = <span class="hljs-string">&quot;&quot;</span><br>var html_result = <span class="hljs-string">&quot;&quot;</span><br>/*可以半自动补全车站名的*/<br>/*onpropertychange的话，只要当前对象属性发生改变，都会触发事件，但是它是IE专属的；<br>oninput是onpropertychange的非IE浏览器版本，支持firefox和opera等浏览器，但有一点不同，它绑定于对象时，并非该对象所有属性改变都能触发事<br>件，它只在对象value值发生改变时奏效。*/<br>ele_f_key.oninput = <span class="hljs-keyword">function</span> (e) &#123;<br>    val = $(<span class="hljs-string">&quot;#from_station&quot;</span>).val();<br>    html_result = <span class="hljs-string">&quot;&quot;</span><br>    document.getElementById(<span class="hljs-comment">&#x27;list1&#x27;).innerHTML =html_result;</span><br>    /*判断是不是空可以防止输入拼音时自动报错*/<br>    <span class="hljs-keyword">if</span> (val !== <span class="hljs-string">&quot;&quot;</span>)&#123;<br>        url1 = <span class="hljs-string">&quot;search/&quot;</span>+val<br>        $.<span class="hljs-keyword">get</span>(url1,<span class="hljs-keyword">function</span>(result)&#123;<br>            a = result.<span class="hljs-built_in">split</span>(<span class="hljs-comment">&#x27;,&#x27;)</span><br>        $.<span class="hljs-keyword">each</span>(a, <span class="hljs-keyword">function</span>(i,item)&#123;<br>            html_result += <span class="hljs-comment">&#x27;&lt;option&gt;&#x27;+a[i]+&#x27;&lt;/option&gt;&#x27;</span><br>        &#125;);<br>        document.getElementById(<span class="hljs-comment">&#x27;list1&#x27;).innerHTML =html_result;</span><br>        &#125;);   <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>js代码（前端自己运行的）<br>前面的定义</p>
<figure class="highlight vbscript"><table><tr><td class="code"><pre><code class="hljs vbscript">$(document).ready(<span class="hljs-keyword">function</span>()&#123;   <br>var ele_f_key = document.getElementById(<span class="hljs-string">&quot;from_station&quot;</span>);<br>var ele_t_key = document.getElementById(<span class="hljs-string">&quot;to_station&quot;</span>);<br>var data = 自己定义的数据<br></code></pre></td></tr></table></figure>
<p>关键部分更改</p>
<figure class="highlight vbscript"><table><tr><td class="code"><pre><code class="hljs vbscript">//更改为利用indexOf()判断字符串里面有关键字就是我想要的数据<br>ele_f_key.oninput = <span class="hljs-keyword">function</span> (e) &#123;<br>    val = $(<span class="hljs-string">&quot;#from_station&quot;</span>).val();<br>    html_result = <span class="hljs-string">&quot;&quot;</span><br>    document.getElementById(<span class="hljs-comment">&#x27;list1&#x27;).innerHTML =html_result;</span><br>    //判断是不是空可以防止输入拼音时自动报错<br>    <span class="hljs-keyword">if</span> (val !== <span class="hljs-string">&quot;&quot;</span>)&#123;<br>          <span class="hljs-keyword">for</span> (var i = <span class="hljs-number">0</span>; i &lt; data.length; i++) &#123;<br>            //indexOf() 方法可返回某个指定的字符串值在字符串中首次出现的位置。<br>            console.<span class="hljs-built_in">log</span>(data[i].indexOf(val))<br>            <span class="hljs-keyword">if</span> (val.<span class="hljs-built_in">trim</span>().length &gt; <span class="hljs-number">0</span> &amp;&amp; data[i].indexOf(val) &gt; <span class="hljs-number">-1</span>) &#123;<br>               html_result += <span class="hljs-comment">&#x27;&lt;option&gt;&#x27;+data[i]+&#x27;&lt;/option&gt;&#x27;</span><br>            &#125;<br>          &#125; <br>          document.getElementById(<span class="hljs-comment">&#x27;list1&#x27;).innerHTML =html_result;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>


<h3 id="跟随鼠标坐标弹窗"><a href="#跟随鼠标坐标弹窗" class="headerlink" title="跟随鼠标坐标弹窗"></a>跟随鼠标坐标弹窗</h3><p><img    class="lazyload" data-original="https://github.com/so1n/so1n_blog_photo/blob/master/blog_photo/%E5%89%8D%E7%AB%AF%E5%B0%8F%E5%8A%9F%E8%83%BD%E6%94%B6%E9%9B%86-%E8%B7%9F%E9%9A%8F%E9%BC%A0%E6%A0%87%E5%9D%90%E6%A0%87%E5%BC%B9%E7%AA%97.gif?raw=true" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">示例图</span></p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><br></code></pre></td></tr></table></figure>
<p>js代码，Django后端<br>主要代码在边框定位<br>先获取点击事件的坐标，然后进行判断，如果靠近底端就固定一个高度，最后赋值给css</p>
<figure class="highlight vbscript"><table><tr><td class="code"><pre><code class="hljs vbscript">$(document).ready(<span class="hljs-keyword">function</span>()&#123;  <br>&#123;% <span class="hljs-keyword">for</span> ticket_info <span class="hljs-keyword">in</span> view_list %&#125;<br>$(<span class="hljs-comment">&#x27;#&#123;&#123; ticket_info.train_num &#125;&#125;&#x27;).click(function(e)&#123;  </span><br>        var train_num = <span class="hljs-string">&quot;&#123;&#123; ticket_info.train_num &#125;&#125;&quot;</span>; <br>        var info = <span class="hljs-keyword">new</span> <span class="hljs-keyword">Set</span>();<br>        var html_resultinfo = <span class="hljs-string">&quot; &quot;</span><br>        var time = $(<span class="hljs-string">&quot;#time&quot;</span>).val(); <br>        var train_no = <span class="hljs-string">&quot;&#123;&#123; ticket_info.train_no &#125;&#125;&quot;</span><br>        var t_station = <span class="hljs-string">&quot;&#123;&#123; ticket_info.from_station &#125;&#125;&quot;</span><br>        var f_station = <span class="hljs-string">&quot;&#123;&#123; ticket_info.to_station &#125;&#125;&quot;</span><br>        //边框定位<br>        var pageX = e.pageX+<span class="hljs-number">20</span>,<br>            pageY = e.pageY<span class="hljs-number">-150</span>;<br>        var abc = document.body.clientHeight;<br>        <span class="hljs-keyword">if</span> (pageY&gt;abc*<span class="hljs-number">0.5</span>)&#123;<br>            $(<span class="hljs-comment">&#x27;#train_display&#x27;).css(&#123;</span><br>                left: pageX,<br>                top: abc*<span class="hljs-number">0.5</span><br>            &#125;); <br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            $(<span class="hljs-comment">&#x27;#train_display&#x27;).css(&#123;</span><br>                top: pageY,<br>                left: pageX<br>            &#125;);  <br>        &#125;<br>        url = <span class="hljs-string">&quot;time/&quot;</span>+time.<span class="hljs-built_in">split</span>(<span class="hljs-comment">&#x27;-&#x27;)[0]+&quot;_&quot;+time.split(&#x27;-&#x27;)[1]+&quot;_&quot;+time.split(&#x27;-&#x27;)[2]+&quot;_&quot;+train_no+&quot;_&quot;+f_station+&quot;_&quot;+t_station</span><br>        train_display.style.display=<span class="hljs-string">&quot;block&quot;</span>;<br>        $.getJSON(url,<span class="hljs-keyword">function</span>(ret,result)&#123;<br>            <span class="hljs-keyword">if</span> (ret.httpstatus == <span class="hljs-number">200</span>)&#123;<br>                a = ret.data.data<br>                document.getElementById(<span class="hljs-comment">&#x27;train_no&#x27;).innerHTML = train_num;</span><br>                document.getElementById(<span class="hljs-comment">&#x27;train_start&#x27;).innerHTML = &quot;&#123;&#123; ticket_info.f_station &#125;&#125;&quot;;</span><br>                document.getElementById(<span class="hljs-comment">&#x27;train_end&#x27;).innerHTML = &quot;&#123;&#123; ticket_info.t_station &#125;&#125;&quot;;</span><br>                $.<span class="hljs-keyword">each</span>(a, <span class="hljs-keyword">function</span>(i,item)&#123;<br>                    html_resultinfo += <span class="hljs-comment">&#x27;&lt;tr&gt;&lt;td&gt;&#x27; + a[i].arrive_time + &#x27;&lt;/td&gt;&#x27; +</span><br>                            <span class="hljs-comment">&#x27;&lt;td&gt;&#x27; + a[i].start_time + &#x27;&lt;/td&gt;&#x27; +</span><br>                            <span class="hljs-comment">&#x27;&lt;td&gt;&#x27; + a[i].station_name + &#x27;&lt;/td&gt;&#x27; +</span><br>                            <span class="hljs-comment">&#x27;&lt;td&gt;&#x27; + a[i].stopover_time + &#x27;&lt;/td&gt;&#x27; +</span><br>                            <span class="hljs-comment">&#x27;&lt;/tr&gt;&#x27;;</span><br>                &#125;);<br>                document.getElementById(<span class="hljs-comment">&#x27;ticket-tbody&#x27;).innerHTML =html_resultinfo;</span><br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                document.getElementById(<span class="hljs-comment">&#x27;train_no&#x27;).innerHTML = train_num;</span><br>                document.getElementById(<span class="hljs-comment">&#x27;train_start&#x27;).innerHTML = &quot;&quot;;</span><br>                document.getElementById(<span class="hljs-comment">&#x27;train_end&#x27;).innerHTML = &quot;&quot;;</span><br>                document.getElementById(<span class="hljs-comment">&#x27;ticket-tbody&#x27;).innerHTML = &quot;暂无该列车信息&quot;</span><br>            &#125;<br>        &#125;);    <br>        return <span class="hljs-literal">false</span>;  <br>    &#125;);  <br>&#123;% <span class="hljs-literal">empty</span> %&#125;<br>&#123;% endfor %&#125;<br>&#125;);<br></code></pre></td></tr></table></figure>

<h3 id="刷新后执行事件"><a href="#刷新后执行事件" class="headerlink" title="刷新后执行事件"></a>刷新后执行事件</h3><p>如果需要在刷新后执行某一个操作，可以执行中低端代码<br>js代码</p>
<figure class="highlight vbscript"><table><tr><td class="code"><pre><code class="hljs vbscript">//200毫秒后自动点击绑定id的按钮<br>setTimeout(<span class="hljs-keyword">function</span>() &#123;<br>    // IE<br>    <span class="hljs-keyword">if</span>(document.all) &#123;<br>        document.getElementById(<span class="hljs-string">&quot;search_button&quot;</span>).click();<br>    &#125;<br>    // 其它浏览器<br>    <span class="hljs-keyword">else</span> &#123;<br>        var e = document.createEvent(<span class="hljs-string">&quot;MouseEvents&quot;</span>);<br>        e.initEvent(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-literal">true</span>, <span class="hljs-literal">true</span>);<br>        document.getElementById(<span class="hljs-string">&quot;search_button&quot;</span>).dispatchEvent(e);<br>    &#125;<br>&#125;, <span class="hljs-number">200</span>        ); <br></code></pre></td></tr></table></figure>

<h3 id="随机显示"><a href="#随机显示" class="headerlink" title="随机显示"></a>随机显示</h3><p>每次打开或刷新页面时出现的提示不一样<br>js代码</p>
<figure class="highlight vbscript"><table><tr><td class="code"><pre><code class="hljs vbscript">/*随机显示函数*/<br><span class="hljs-keyword">function</span> randomp()&#123;<br>tips = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-number">4</span>);<br>tips[<span class="hljs-number">0</span>] =<span class="hljs-string">&quot;如果加载不成功请刷新&quot;</span>;<br>tips[<span class="hljs-number">1</span>] =<span class="hljs-string">&quot;工作地点可以手动选择或者输入获取&quot;</span>;<br>tips[<span class="hljs-number">2</span>] =<span class="hljs-string">&quot;58同城的房源有少部分几率出现定位错误&quot;</span>;<br>tips[<span class="hljs-number">3</span>] =<span class="hljs-string">&quot;到达圈仅供参考&quot;</span>;<br>index = Math.floor(Math.random() * tips.length);<br>document.getElementById(<span class="hljs-comment">&#x27;randomp&#x27;).innerHTML = &quot;Tip:&quot;+tips[index];</span><br>&#125;  <br></code></pre></td></tr></table></figure>

<h3 id="监听滚动条显示按钮"><a href="#监听滚动条显示按钮" class="headerlink" title="监听滚动条显示按钮"></a>监听滚动条显示按钮</h3><p><img    class="lazyload" data-original="https://github.com/so1n/so1n_blog_photo/blob/master/blog_photo/%E5%89%8D%E7%AB%AF%E5%B0%8F%E5%8A%9F%E8%83%BD%E6%94%B6%E9%9B%86-%E7%9B%91%E5%90%AC%E6%BB%9A%E5%8A%A8%E6%9D%A1%E6%98%BE%E7%A4%BA%E6%8C%89%E9%92%AE.gif?raw=true" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">示例图</span><br>js代码</p>
<figure class="highlight vbscript"><table><tr><td class="code"><pre><code class="hljs vbscript">$(document).ready(<span class="hljs-keyword">function</span>()&#123;  <br>    $(<span class="hljs-string">&quot;#go_top&quot;</span>).hide();  <br>    $(<span class="hljs-keyword">function</span> () &#123;  <br>        //检测屏幕高度  <br>        //下面这段代码检测是否超过当前屏幕一页，由于增加了顶栏，所以不准，改用监控滚动<br>        //var height=$(window).height();  <br>        //scroll() 方法为滚动事件  <br>        $(window).scroll(<span class="hljs-keyword">function</span>()&#123;  <br>            <span class="hljs-keyword">if</span> ($(window).scrollTop()&gt;<span class="hljs-number">50</span>)&#123;  <br>                $(<span class="hljs-string">&quot;#go_top&quot;</span>).fadeIn(<span class="hljs-number">500</span>);  <br>            &#125;<span class="hljs-keyword">else</span>&#123;  <br>                $(<span class="hljs-string">&quot;#go_top&quot;</span>).fadeOut(<span class="hljs-number">500</span>);  <br>                &#125;  <br>        &#125;);  <br>        $(<span class="hljs-string">&quot;#go_top&quot;</span>).click(<span class="hljs-keyword">function</span>()&#123;  <br>            $(<span class="hljs-comment">&#x27;body,html&#x27;).animate(&#123;scrollTop:0&#125;,100);  </span><br>            return <span class="hljs-literal">false</span>;  <br>        &#125;);  <br>    &#125;);  <br>&#125;);<br></code></pre></td></tr></table></figure>

<h3 id="竖分隔条"><a href="#竖分隔条" class="headerlink" title="竖分隔条"></a>竖分隔条</h3><p><img    class="lazyload" data-original="https://github.com/so1n/so1n_blog_photo/blob/master/blog_photo/%E5%89%8D%E7%AB%AF%E5%B0%8F%E5%8A%9F%E8%83%BD%E6%94%B6%E9%9B%86-%E6%A8%A1%E6%8B%9F%E7%AB%96%E5%88%86%E5%89%B2%E7%BA%BF.png?raw=true" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">示例图</span><br>html代码</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#x27;border:1px solid #E8E8E8;float:left;height:100%;&#x27;</span>&gt;</span><span class="hljs-comment">&lt;!--这个div模拟一条垂直分割线--&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>用户与浏览器交互的过程</title>
    <url>/2017/08/24/26/</url>
    <content><![CDATA[<h2 id="前记"><a href="#前记" class="headerlink" title="前记"></a>前记</h2><p>查阅资料后总结的范围从大到小，用户与浏览器交互的过程。<br>用户端以浏览器示例。</p>
<span id="more"></span>

<h3 id="OSI7层"><a href="#OSI7层" class="headerlink" title="OSI7层"></a>OSI7层</h3><p>当浏览器需要访问资源时，浏览器与应用层相关协议(http、htpps)进行交互，并将数据传给表示层进行数据转换再传给传输层（https还需要会话层 TLS、SSL 等协议）<br>由于http、htpps基于TCP协议，所以需要经历三次握手过程，也就是：<br>第一个是“连接协定”数据段，用于请求同步（syn）<br>接下来的数据段确认请求（ack），并在主机之间确定连接参数，同时同步接收方排序<br>最后一个数据段也是确认通知目标主机，接受了协定且连接已确立<br>3次握手与4次分手流程图如下：<br><img    class="lazyload" data-original="https://github.com/so1n/so1n_blog_photo/blob/master/blog_photo/18D3B9C2-D3F5-4F89-82BB-53B717D89BB5.jpg?raw=true" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">enter description here</span><br>由于从这一层开始提供端到端的服务。措意可以实现流量控制、负载均衡，同时数据段也多了端口、控制字和校验和<br>传输层之后是网络层，这里主要是通过路由协议进行路由转发，还有访问控制表限制，网络地址转换等。再向下数据链路层主要是 ARP、RARP 协议完成 IP 和 Mac 地址互解析，再向下到最底层物理层基本就是 IEEE 802.X 等协议进行数据比特流转成高低电平的的一些定义等等。下面的这几层已经偏向于网络与路由交换机方面，故不展开。</p>
<h3 id="浏览器与服务器"><a href="#浏览器与服务器" class="headerlink" title="浏览器与服务器"></a>浏览器与服务器</h3><p>当输入完url并按下回车时，浏览器与服务器的数据交互就开始了<br>首先浏览器要通过DNS服务器来查询网址对应的Ip地址，查询顺序如下：<br>浏览器缓存→系统缓存→路由器缓存→ISP DNS缓存→从根域名服务器递归搜索<br>浏览器获得ip地址后，就把请求发送给服务器，除了url本身中的资源路径外，在报头中还有写参数<br>  Accept和Accept-Encoding（表明希望收到的数据）、User-Agent（识别浏览器类型的UA）、Connection（用以表明获取后就关闭链接还是保持开启）、Host、Cookie（储存的cookie）<br>服务器根据请求回复相关数据，如果url中没填写www或者这个服务端对应多个url  服务端会发送301让浏览器重定向到正确的url<br>服务端根据url请求的路径和参数，从数据库中获取数据并和对应的前端3宝返回给浏览器<br>浏览器根据服务器回复的数据和前端3宝渲染页面</p>
<h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><p>服务端由 反向代理服务器、后端服务器、web应用组成。反向代理服务器如Nginx，在拿到请求后，进行一些验证，比如黑名单拦截之类的，然后 Nginx 直接处理静态资源请求，其他请求 Nginx 转发给后端服务器。在python web中后端服务器一般为WSGI，通过 uwsgi 协议通讯，uWSGI 拿到请求，可以进行一些逻辑， 验证黑名单、判断爬虫等，之后根据 wsgi 标准（<a href="http://python.jobbole.com/87361/">wsgi说明</a>），把拿到的 environs 参数扔给web应用。web应用以Django为例，Django 根据 wsgi 标准接收请求和 env， 然后开始 start_response ，先跑 Django 相关后台逻辑，Django 拿到请求执行 request middleware 内的相关逻辑，然后路由到相应 view 执行逻辑，出错执行 exception middleware 相关逻辑，接着 response 前执行 response middleware 逻辑，最后通过 wsgi 标准构造 response，再通过 uWSGI 给 Nginx ，Nginx 返回给浏览器。<br>Django执行流程图如下：<br><img    class="lazyload" data-original="https://github.com/so1n/so1n_blog_photo/blob/master/blog_photo/180016921.png?raw=true" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">enter description here</span></p>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis命令</title>
    <url>/2017/08/23/14-redis/</url>
    <content><![CDATA[<p>Redis常用命令</p>
<span id="more"></span>

<h2 id="Redis命令"><a href="#Redis命令" class="headerlink" title="Redis命令"></a>Redis命令</h2><h3 id="1-数据类型命令"><a href="#1-数据类型命令" class="headerlink" title="1.数据类型命令"></a>1.数据类型命令</h3><p>启动</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> sudo service redis<span class="hljs-literal">-server</span> <span class="hljs-built_in">start</span><br><span class="hljs-variable">$</span> redis<span class="hljs-literal">-cli</span><br></code></pre></td></tr></table></figure>
<p>存入与获取value</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">&gt;</span><span class="bash"> <span class="hljs-built_in">set</span> mykey somevalue        <span class="hljs-comment">#存入   按kev-value形式</span></span><br><br><span class="hljs-meta">&gt;</span><span class="bash"> get mykey         <span class="hljs-comment">#读取key对应的value</span></span><br></code></pre></td></tr></table></figure>
<p>数据操作（加法器）</p>
<figure class="highlight accesslog"><table><tr><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">127.0.0.1:6379</span>&gt; set counter <span class="hljs-number">100</span><br>OK<br><span class="hljs-number">127.0.0.1:6379</span>&gt; incr counter        #  +<span class="hljs-number">1</span><br>(integer) <span class="hljs-number">101</span><br><span class="hljs-number">127.0.0.1:6379</span>&gt; incrby counter <span class="hljs-number">50</span>          #   +<span class="hljs-number">50</span><br>(integer) <span class="hljs-number">151</span><br><span class="hljs-number">127.0.0.1:6379</span>&gt; <br></code></pre></td></tr></table></figure>
<p>一次写入多个对应关系</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">127</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span>:<span class="hljs-number">6379</span>&gt; mset a <span class="hljs-number">10</span> b <span class="hljs-number">20</span> c <span class="hljs-number">30</span><br><span class="hljs-attribute">OK</span><br><span class="hljs-attribute">127</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span>:<span class="hljs-number">6379</span>&gt; mget a b c <br><span class="hljs-attribute">1</span>) <span class="hljs-string">&quot;10&quot;</span><br><span class="hljs-attribute">2</span>) <span class="hljs-string">&quot;20&quot;</span><br><span class="hljs-attribute">3</span>) <span class="hljs-string">&quot;30&quot;</span><br><span class="hljs-attribute">127</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span>:<span class="hljs-number">6379</span>&gt; <br></code></pre></td></tr></table></figure>
<p>Redis列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边） LPUSH 命令插入一个新的元素到头部, 而 RPUSH插入一个新元素到尾部.当一个这两个操作在一个空的Key上被执行的时候一个新的列表被创建。相似的，如果一个列表操作清空一个列表那么对应的key将被从key空间删除。这是非常方便的语义，因为他们被调用使用一个空列表完全就像他们被调用时使用一个不存在的键值（可以）做为参数。</p>
<figure class="highlight tcl"><table><tr><td class="code"><pre><code class="hljs tcl"><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; rpush mylist A    在列表mylist后面加A<br>(integer) <span class="hljs-number">2</span><br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; rpush mylist B<br>(integer) <span class="hljs-number">3</span><br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; lpush mylist first   在列表mylist前面加first<br>(integer) <span class="hljs-number">4</span><br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; <span class="hljs-keyword">lrange</span> mylist <span class="hljs-number">0</span> <span class="hljs-number">-1</span>    显示列表mylist从第一个到最后一个的值<br><span class="hljs-number">1</span>) <span class="hljs-string">&quot;first&quot;</span><br><span class="hljs-number">2</span>) <span class="hljs-string">&quot;b&quot;</span><br><span class="hljs-number">3</span>) <span class="hljs-string">&quot;A&quot;</span><br><span class="hljs-number">4</span>) <span class="hljs-string">&quot;B&quot;</span><br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; rpush mylist <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-string">&quot;foo bar&quot;</span><br>(integer) <span class="hljs-number">10</span><br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; <span class="hljs-keyword">lrange</span> mylist <span class="hljs-number">0</span> <span class="hljs-number">-1</span><br> <span class="hljs-number">1</span>) <span class="hljs-string">&quot;first&quot;</span><br> <span class="hljs-number">2</span>) <span class="hljs-string">&quot;b&quot;</span><br> <span class="hljs-number">3</span>) <span class="hljs-string">&quot;A&quot;</span><br> <span class="hljs-number">4</span>) <span class="hljs-string">&quot;B&quot;</span><br> <span class="hljs-number">5</span>) <span class="hljs-string">&quot;1&quot;</span><br> <span class="hljs-number">6</span>) <span class="hljs-string">&quot;2&quot;</span><br> <span class="hljs-number">7</span>) <span class="hljs-string">&quot;3&quot;</span><br> <span class="hljs-number">8</span>) <span class="hljs-string">&quot;4&quot;</span><br> <span class="hljs-number">9</span>) <span class="hljs-string">&quot;5&quot;</span><br><span class="hljs-number">10</span>) <span class="hljs-string">&quot;foo bar&quot;</span><br></code></pre></td></tr></table></figure>
<p>pop操作</p>
<figure class="highlight accesslog"><table><tr><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">127.0.0.1:6379</span>&gt; del mylist         #删除整个表<br>(integer) <span class="hljs-number">1</span>                  #显示<span class="hljs-number">1</span>为操作删除成功<br><span class="hljs-number">127.0.0.1:6379</span>&gt; rpush mylist a b c <br>(integer) <span class="hljs-number">3</span><br><span class="hljs-number">127.0.0.1:6379</span>&gt; rpop mylist            #删除表里面的最后一个<br><span class="hljs-string">&quot;c&quot;</span><br><span class="hljs-number">127.0.0.1:6379</span>&gt; lrange mylist <span class="hljs-number">0</span> -<span class="hljs-number">1</span><br><span class="hljs-number">1</span>) <span class="hljs-string">&quot;a&quot;</span><br><span class="hljs-number">2</span>) <span class="hljs-string">&quot;b&quot;</span><br><span class="hljs-number">127.0.0.1:6379</span>&gt; lpop mylist             #删除表里面的第一个<br><span class="hljs-string">&quot;a&quot;</span><br><span class="hljs-number">127.0.0.1:6379</span>&gt; lrange mylist <span class="hljs-number">0</span> -<span class="hljs-number">1</span><br><span class="hljs-number">1</span>) <span class="hljs-string">&quot;b&quot;</span><br></code></pre></td></tr></table></figure>
<p>Redis Hashes是字符串字段和字符串值之间的映射,因此他们是展现对象的完美数据类型。 (例如:一个有名，姓，年龄等等属性的用户):一个带有一些字段的hash仅仅需要一块很小的空间存储,因此你可以存储数以百万计的对象在一个小的Redis实例中。 哈希主要用来表现对象，他们有能力存储很多对象，因此你可以将哈希用于许多其他的任务。</p>
<figure class="highlight accesslog"><table><tr><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">127.0.0.1:6379</span>&gt; hmset user:<span class="hljs-number">1000</span> username antirez birthyear <span class="hljs-number">1977</span> verified <span class="hljs-number">1</span><br>OK<br><span class="hljs-number">127.0.0.1:6379</span>&gt; hget user:<span class="hljs-number">1000</span> username<br><span class="hljs-string">&quot;antirez&quot;</span><br><span class="hljs-number">127.0.0.1:6379</span>&gt; hget user:<span class="hljs-number">1000</span> birthyear<br><span class="hljs-string">&quot;1977&quot;</span><br><span class="hljs-number">127.0.0.1:6379</span>&gt; hgetall user:<span class="hljs-number">1000</span>        #GET全部<br><span class="hljs-number">1</span>) <span class="hljs-string">&quot;username&quot;</span><br><span class="hljs-number">2</span>) <span class="hljs-string">&quot;antirez&quot;</span><br><span class="hljs-number">3</span>) <span class="hljs-string">&quot;birthyear&quot;</span><br><span class="hljs-number">4</span>) <span class="hljs-string">&quot;1977&quot;</span><br><span class="hljs-number">5</span>) <span class="hljs-string">&quot;verified&quot;</span><br><span class="hljs-number">6</span>) <span class="hljs-string">&quot;1&quot;</span><br> <span class="hljs-number">127</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span>:<span class="hljs-number">6379</span>&gt; hincrby user:<span class="hljs-number">1000</span> birthyear <span class="hljs-number">10</span>         #给birthyear加<span class="hljs-number">10</span><br>(integer) <span class="hljs-number">1987</span><br></code></pre></td></tr></table></figure>
<p>无序集合<br>Redis 集合（Set）是一个无序的字符串集合. Redis 集合拥有令人满意的不允许包含相同成员的属性。多次添加相同的元素，最终在集合里只会有一个元素。 实际上说这些就是意味着在添加元素的时候无须检测元素是否存在。 一个Redis集合的非常有趣的事情是他支持一些服务端的命令从现有的集合出发去进行集合运算，因此你可以在非常短的时间内进行合并（unions）, 求交集（intersections）,找出不同的元素（differences of sets）。</p>
<figure class="highlight accesslog"><table><tr><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">127.0.0.1:6379</span>&gt; sadd myset <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>            #生成一个无序集合<br>(integer) <span class="hljs-number">3</span><br><span class="hljs-number">127.0.0.1:6379</span>&gt; smembers myset<br><span class="hljs-number">1</span>) <span class="hljs-string">&quot;1&quot;</span><br><span class="hljs-number">2</span>) <span class="hljs-string">&quot;2&quot;</span><br><span class="hljs-number">3</span>) <span class="hljs-string">&quot;3&quot;</span><br><span class="hljs-number">127.0.0.1:6379</span>&gt; sismember myset <span class="hljs-number">3</span>           #检查有没有这个无序集合，有且有这个值时返回<span class="hljs-number">1</span>，没有返回<span class="hljs-number">0</span><br>(integer) <span class="hljs-number">1</span><br><span class="hljs-number">127.0.0.1:6379</span>&gt; sismember myset <span class="hljs-number">30</span><br>(integer) <span class="hljs-number">0</span><br><span class="hljs-number">127.0.0.1:6379</span>&gt; sismember mys <span class="hljs-number">3</span><br>(integer) <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>
<p>有序集合<br>Redis有序集合与普通集合非常相似，是一个没有重复元素的字符串集合。不同之处是有序集合的每一个成员都关联了一个评分，这个评分被用来按照从最低分到最高分的方式排序集合中的成员。集合的成员是唯一的，但是评分可以是重复了。 使用有序集合你可以以非常快的速度（O(log(N))）添加，删除和更新元素。因为元素是有序的, 所以你也可以很快的根据评分（score）或者次序（position）来获取一个范围的元素。访问有序集合的中间元素也是非常快的,因此你能够使用有序集合作为一个没有重复成员的智能列表。在有序集合中，你可以很快捷的访问一切你需要的东西：有序的元素，快速的存在性测试，快速访问集合的中间元素！ 简而言之使用有序集合你可以做完成许多对性能有极端要求的任务，而那些任务使用其他类型的数据库真的是很难完成的。</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><code class="hljs ruby"><span class="hljs-meta">127.0.0.1:6379&gt;</span> zadd hackers <span class="hljs-number">1940</span> <span class="hljs-string">&quot;Alan Kay&quot;</span><br>(integer) <span class="hljs-number">1</span><br><span class="hljs-meta">127.0.0.1:6379&gt;</span> zadd hackers <span class="hljs-number">1957</span> <span class="hljs-string">&quot;Sophie Wilson&quot;</span><br>(integer) <span class="hljs-number">1</span><br><span class="hljs-meta">127.0.0.1:6379&gt;</span> zadd hackers <span class="hljs-number">1953</span> <span class="hljs-string">&quot;Richard Stallman&quot;</span><br>(integer) <span class="hljs-number">1</span><br><span class="hljs-meta">127.0.0.1:6379&gt;</span> zadd hackers <span class="hljs-number">1949</span> <span class="hljs-string">&quot;Anita Borg&quot;</span><br>(integer) <span class="hljs-number">1</span><br><span class="hljs-meta">127.0.0.1:6379&gt;</span> zadd hackers <span class="hljs-number">1965</span> <span class="hljs-string">&quot;Yukihiro Matsumoto&quot;</span><br>(integer) <span class="hljs-number">1</span><br><span class="hljs-meta">127.0.0.1:6379&gt;</span> zadd hackers <span class="hljs-number">1914</span> <span class="hljs-string">&quot;Hedy Lamarr&quot;</span><br>(integer) <span class="hljs-number">1</span><br><span class="hljs-meta">127.0.0.1:6379&gt;</span> zadd hackers <span class="hljs-number">1916</span> <span class="hljs-string">&quot;Claude Shannon&quot;</span><br>(integer) <span class="hljs-number">1</span><br><span class="hljs-meta">127.0.0.1:6379&gt;</span> zadd hackers <span class="hljs-number">1969</span> <span class="hljs-string">&quot;Linus Torvalds&quot;</span><br>(integer) <span class="hljs-number">1</span><br><span class="hljs-meta">127.0.0.1:6379&gt;</span> zadd hackers <span class="hljs-number">1912</span> <span class="hljs-string">&quot;Alan Turing&quot;</span><br>(integer) <span class="hljs-number">1</span><br><span class="hljs-meta">127.0.0.1:6379&gt;</span> zrange hackers <span class="hljs-number">0</span> -<span class="hljs-number">1</span>          <span class="hljs-comment">#正序查找</span><br><span class="hljs-number">1</span>) <span class="hljs-string">&quot;Alan Turing&quot;</span><br><span class="hljs-number">2</span>) <span class="hljs-string">&quot;Hedy Lamarr&quot;</span><br><span class="hljs-number">3</span>) <span class="hljs-string">&quot;Claude Shannon&quot;</span><br><span class="hljs-number">4</span>) <span class="hljs-string">&quot;Alan Kay&quot;</span><br><span class="hljs-number">5</span>) <span class="hljs-string">&quot;Anita Borg&quot;</span><br><span class="hljs-number">6</span>) <span class="hljs-string">&quot;Richard Stallman&quot;</span><br><span class="hljs-number">7</span>) <span class="hljs-string">&quot;Sophie Wilson&quot;</span><br><span class="hljs-number">8</span>) <span class="hljs-string">&quot;Yukihiro Matsumoto&quot;</span><br><span class="hljs-number">9</span>) <span class="hljs-string">&quot;Linus Torvalds&quot;</span><br><span class="hljs-meta">127.0.0.1:6379&gt;</span> zrevrange hackers <span class="hljs-number">0</span> -<span class="hljs-number">1</span>      <span class="hljs-comment">#反序查找</span><br><span class="hljs-number">1</span>) <span class="hljs-string">&quot;Linus Torvalds&quot;</span><br><span class="hljs-number">2</span>) <span class="hljs-string">&quot;Yukihiro Matsumoto&quot;</span><br><span class="hljs-number">3</span>) <span class="hljs-string">&quot;Sophie Wilson&quot;</span><br><span class="hljs-number">4</span>) <span class="hljs-string">&quot;Richard Stallman&quot;</span><br><span class="hljs-number">5</span>) <span class="hljs-string">&quot;Anita Borg&quot;</span><br><span class="hljs-number">6</span>) <span class="hljs-string">&quot;Alan Kay&quot;</span><br><span class="hljs-number">7</span>) <span class="hljs-string">&quot;Claude Shannon&quot;</span><br><span class="hljs-number">8</span>) <span class="hljs-string">&quot;Hedy Lamarr&quot;</span><br><span class="hljs-number">9</span>) <span class="hljs-string">&quot;Alan Turing&quot;</span><br><span class="hljs-meta">127.0.0.1:6379&gt;</span> zrange hackers <span class="hljs-number">0</span> -<span class="hljs-number">1</span> withscores          <span class="hljs-comment">#正序查找且显示记录值</span><br> <span class="hljs-number">1</span>) <span class="hljs-string">&quot;Alan Turing&quot;</span><br> <span class="hljs-number">2</span>) <span class="hljs-string">&quot;1912&quot;</span><br> <span class="hljs-number">3</span>) <span class="hljs-string">&quot;Hedy Lamarr&quot;</span><br> <span class="hljs-number">4</span>) <span class="hljs-string">&quot;1914&quot;</span><br> <span class="hljs-number">5</span>) <span class="hljs-string">&quot;Claude Shannon&quot;</span><br> <span class="hljs-number">6</span>) <span class="hljs-string">&quot;1916&quot;</span><br> <span class="hljs-number">7</span>) <span class="hljs-string">&quot;Alan Kay&quot;</span><br> <span class="hljs-number">8</span>) <span class="hljs-string">&quot;1940&quot;</span><br> <span class="hljs-number">9</span>) <span class="hljs-string">&quot;Anita Borg&quot;</span><br><span class="hljs-number">10</span>) <span class="hljs-string">&quot;1949&quot;</span><br><span class="hljs-number">11</span>) <span class="hljs-string">&quot;Richard Stallman&quot;</span><br><span class="hljs-number">12</span>) <span class="hljs-string">&quot;1953&quot;</span><br><span class="hljs-number">13</span>) <span class="hljs-string">&quot;Sophie Wilson&quot;</span><br><span class="hljs-number">14</span>) <span class="hljs-string">&quot;1957&quot;</span><br><span class="hljs-number">15</span>) <span class="hljs-string">&quot;Yukihiro Matsumoto&quot;</span><br><span class="hljs-number">16</span>) <span class="hljs-string">&quot;1965&quot;</span><br><span class="hljs-number">17</span>) <span class="hljs-string">&quot;Linus Torvalds&quot;</span><br><span class="hljs-number">18</span>) <span class="hljs-string">&quot;1969&quot;</span><br></code></pre></td></tr></table></figure>
<h3 id="2-Redis系统管理"><a href="#2-Redis系统管理" class="headerlink" title="2.Redis系统管理"></a>2.Redis系统管理</h3><p>EXISTS key 判断一个key是否存在;存在返回 1;否则返回0;<br>DEL key 删除某个key,或是一系列key;DEL key1 key2 key3 key4。成功返回1，失败返回0（key值不存在）。</p>
<figure class="highlight accesslog"><table><tr><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">127.0.0.1:6379</span>&gt; set mykey hello<br>OK<br><span class="hljs-number">127.0.0.1:6379</span>&gt; exists mykey<br>(integer) <span class="hljs-number">1</span><br><span class="hljs-number">127.0.0.1:6379</span>&gt; del mykey<br>(integer) <span class="hljs-number">1</span><br><span class="hljs-number">127.0.0.1:6379</span>&gt; exists mykey<br>(integer) <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>
<p>TYPE key：返回某个key元素的数据类型 ( none:不存在,string:字符,list,set,zset,hash)，key不存在返回空。<br>KEYS key—pattern ：返回匹配的key列表 (KEYS foo*:查找foo开头的keys)</p>
<figure class="highlight accesslog"><table><tr><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">127.0.0.1:6379</span>&gt; set mykey x<br>OK<br><span class="hljs-number">127.0.0.1:6379</span>&gt; type mykey<br>string<br><span class="hljs-number">127.0.0.1:6379</span>&gt; del mykey<br>(integer) <span class="hljs-number">1</span><br><span class="hljs-number">127.0.0.1:6379</span>&gt; type mykey<br>none<br></code></pre></td></tr></table></figure>
<p>RANDOMKEY ： 随机获得一个已经存在的key，如果当前数据库为空，则返回空字符串</p>
<figure class="highlight accesslog"><table><tr><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">127.0.0.1:6379</span>&gt; randomkey<br><span class="hljs-string">&quot;c&quot;</span><br><span class="hljs-number">127.0.0.1:6379</span>&gt; randomkey<br><span class="hljs-string">&quot;a&quot;</span><br></code></pre></td></tr></table></figure>
<p>RENAME oldname newname：改key的名字，新键如果存在将被覆盖<br>RENAMENX oldname newname：更改key的名字,如果newname存在,则更新失败;</p>
<figure class="highlight accesslog"><table><tr><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">127.0.0.1:6379</span>&gt; rename a aa       #把key为a改名为aa<br>OK<br><span class="hljs-number">127.0.0.1:6379</span>&gt; exists a<br>(integer) <span class="hljs-number">0</span><br><span class="hljs-number">127.0.0.1:6379</span>&gt; exists aa<br>(integer) <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>
<p>EXPIRE：设置某个key的过期时间（秒）,(EXPIRE bruce 1000：设置bruce这个key1000秒后系统自动删除)注意：如果在还没有过期的时候，对值进行了改变，那么那个值会被清除。</p>
<figure class="highlight accesslog"><table><tr><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">127.0.0.1:6379</span>&gt; expire key <span class="hljs-number">10</span><br>(integer) <span class="hljs-number">1</span><br><span class="hljs-number">127.0.0.1:6379</span>&gt; get key<br><span class="hljs-string">&quot;some-value&quot;</span><br><span class="hljs-number">127.0.0.1:6379</span>&gt; get key      #10s后执行<br>(nil)<br></code></pre></td></tr></table></figure>
<p>TTL：查找某个key还有多长时间过期,返回时间秒</p>
<figure class="highlight accesslog"><table><tr><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">127.0.0.1:6379</span>&gt; set key <span class="hljs-number">100</span> ex <span class="hljs-number">30</span><br>OK<br><span class="hljs-number">127.0.0.1:6379</span>&gt; ttl key<br>(integer) <span class="hljs-number">23</span><br><span class="hljs-number">127.0.0.1:6379</span>&gt; ttl key<br>(integer) <span class="hljs-number">21</span><br></code></pre></td></tr></table></figure>

<p>CLEAR ：清除界面。<br>DBSIZE ：返回当前数据库的key的总数<br>FLUSHDB：清空当前数据库中的所有键<br>FLUSHALL：清空所有数据库中的所有键</p>
<ul>
<li>INFO命令可以查询Redis几乎所有的信息，其命令选项有如下：<br>server: Redis server的常规信息<br>clients: Client的连接选项<br>memory: 存储占用相关信息<br>persistence: RDB and AOF 相关信息<br>stats: 常规统计<br>replication: Master/slave请求信息<br>cpu: CPU 占用信息统计<br>cluster: Redis 集群信息<br>keyspace: 数据库信息统计<br>all: 返回所有信息<br>default: 返回常规设置信息<br>若命令参数为空，info命令返回所有信息。</li>
</ul>
<h3 id="3-高级应用"><a href="#3-高级应用" class="headerlink" title="3.高级应用"></a>3.高级应用</h3><p><a href="https://www.shiyanlou.com/courses/106/labs/915/document">见这里</a></p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Scrapy爬虫（1）-爬取知乎用户信息</title>
    <url>/2017/08/23/13-scrapy-zhihu-easy/</url>
    <content><![CDATA[<p>阅读scrapy后做了一个简单的scrapy爬虫</p>
<span id="more"></span>


<h2 id="Scrapy爬虫（1）-知乎"><a href="#Scrapy爬虫（1）-知乎" class="headerlink" title="Scrapy爬虫（1）-知乎"></a>Scrapy爬虫（1）-知乎</h2><p>第一次用Scrap创建的爬虫，详细记录下<br>完整代码请访问<a href="https://github.com/so1n/learn-python/tree/master/6-zhihuSpider">这里</a>,不过代码可能有所不同</p>
<h3 id="1-前记"><a href="#1-前记" class="headerlink" title="-1.前记"></a>-1.前记</h3><p>本来是昨天弄好代码，今天写文章的。然后今天早上在逛台风吧看台风天鸽状况，天鸽近岸爆发加上机构被妮妲狼来了戏耍后都保持谨慎态度，珠海到早上上班时间后才挂红色预警，澳门则到了快登录才挂10号风球，珠三角没有做好防范，还有近岸爆发和赶上天文大潮导致受灾加重，希望那里灾情不重。付上两张图，一张是澳门海水倒灌一张是天鸽高层图，很像鸽子头<br><img    class="lazyload" data-original="https://github.com/so1n/so1n_blog_photo/blob/master/blog_photo/scrapy%E5%8F%B0%E9%A3%8E1.jpg?raw=true" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">enter description here</span><br><img    class="lazyload" data-original="https://github.com/so1n/so1n_blog_photo/blob/master/blog_photo/Scrapy%E5%8F%B0%E9%A3%8E2.jpg?raw=true" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">enter description here</span></p>
<h3 id="0-思路验证"><a href="#0-思路验证" class="headerlink" title="0.思路验证"></a>0.思路验证</h3><p>在创建这个工程前，我先用段代码来检验基本功能可否运行<br>知乎可以不用登录获取用户信息，对我来说，方便太多了，而且知乎的查看关注页面那里同时显示有个人用户信息所以直接访问：<a href="https://www.zhihu.com/people/%EF%BC%88token%EF%BC%89/following">https://www.zhihu.com/people/（token）/following</a><br>就可以找到我要的信息了（虽然关注列表只有20个，不过无所谓）<br><img    class="lazyload" data-original="https://github.com/so1n/so1n_blog_photo/blob/master/blog_photo/%E7%9F%A5%E4%B9%8E-%E6%9F%A5%E7%9C%8B%E7%9F%A5%E4%B9%8E%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE.png?raw=true" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">enter description here</span><br>提取信息如图，直接copy这段数据去相应网站分析后，可以得出我要的数据在两个部分，<br>一个是在[‘people’][‘followingByUser’][urltoken][‘ids’]<br>另一个是在[‘entities’][‘users’][urltoken]<br>找到后就可以写代码开始爬下来了。<br>不过知乎的json会有空，比如这个用户没有学校的值时，json就没有相应的节点，如果直接爬就会报错，然后我也没有找到比较简便的处理方法，就写了try…except（如果用了对象，一个方法来复用，最后代码量也差不多，我就放弃了）<br>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> json<br><span class="hljs-keyword">from</span> bs4 <span class="hljs-keyword">import</span> BeautifulSoup<br><span class="hljs-keyword">import</span> requests<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">user</span>(<span class="hljs-params">urltoken</span>):</span><br>    headers = &#123;<span class="hljs-string">&#x27;User-Agent&#x27;</span>: <span class="hljs-string">&#x27;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36&#x27;</span>&#125;<br>    url = <span class="hljs-string">&#x27;https://www.zhihu.com/people/&#x27;</span>+urltoken+<span class="hljs-string">&#x27;/following&#x27;</span><br>    html = requests.get(url, headers=headers).text<br>    soup = BeautifulSoup(html, <span class="hljs-string">&#x27;html.parser&#x27;</span>)<br>    json_text = soup.body.contents[<span class="hljs-number">1</span>].attrs[<span class="hljs-string">&#x27;data-state&#x27;</span>]<br>    ob_json = json.loads(json_text)<br>    followinglist = ob_json[<span class="hljs-string">&#x27;people&#x27;</span>][<span class="hljs-string">&#x27;followingByUser&#x27;</span>][urltoken][<span class="hljs-string">&#x27;ids&#x27;</span>]<br>    tempset = <span class="hljs-built_in">set</span>(followinglist)<br>    tempset.remove(<span class="hljs-literal">None</span>)<br>    followinglist = <span class="hljs-built_in">list</span>(tempset)<br>    user_json = ob_json[<span class="hljs-string">&#x27;entities&#x27;</span>][<span class="hljs-string">&#x27;users&#x27;</span>][urltoken]<br>    user_info = user_json[<span class="hljs-string">&#x27;headline&#x27;</span>]<br>    <span class="hljs-keyword">try</span>:<br>        school = user_json[<span class="hljs-string">&#x27;educations&#x27;</span>][<span class="hljs-number">0</span>][<span class="hljs-string">&#x27;school&#x27;</span>][<span class="hljs-string">&#x27;name&#x27;</span>]<br>    <span class="hljs-keyword">except</span>:<br>        school = <span class="hljs-string">&#x27;&#x27;</span><br>    <span class="hljs-keyword">try</span>:<br>        major = user_json[<span class="hljs-string">&#x27;educations&#x27;</span>][<span class="hljs-number">0</span>][<span class="hljs-string">&#x27;major&#x27;</span>][<span class="hljs-string">&#x27;name&#x27;</span>]<br>    <span class="hljs-keyword">except</span>:<br>        major = <span class="hljs-string">&#x27;&#x27;</span><br>    <span class="hljs-keyword">try</span>:<br>        job = user_json[<span class="hljs-string">&#x27;employments&#x27;</span>][<span class="hljs-number">0</span>][<span class="hljs-string">&#x27;job&#x27;</span>][<span class="hljs-string">&#x27;name&#x27;</span>]<br>    <span class="hljs-keyword">except</span>:<br>        job = <span class="hljs-string">&#x27;&#x27;</span><br>    <span class="hljs-keyword">try</span>:<br>        company = user_json[<span class="hljs-string">&#x27;employments&#x27;</span>][<span class="hljs-number">0</span>][<span class="hljs-string">&#x27;company&#x27;</span>][<span class="hljs-string">&#x27;name&#x27;</span>]<br>    <span class="hljs-keyword">except</span>:<br>        company = <span class="hljs-string">&#x27;&#x27;</span><br>    <span class="hljs-keyword">try</span>: <br>        description = user_json[<span class="hljs-string">&#x27;description&#x27;</span>]<br>    <span class="hljs-keyword">except</span>:<br>        description = <span class="hljs-string">&#x27;&#x27;</span><br>    <span class="hljs-keyword">try</span>:<br>        business = user_json[<span class="hljs-string">&#x27;business&#x27;</span>][<span class="hljs-string">&#x27;name&#x27;</span>]<br>    <span class="hljs-keyword">except</span>:<br>        business = <span class="hljs-string">&#x27;&#x27;</span><br>    <span class="hljs-keyword">try</span>:<br>        zhihu_name = user_json[<span class="hljs-string">&#x27;name&#x27;</span>]<br>    <span class="hljs-keyword">except</span>:<br>        zhihu_name = <span class="hljs-string">&#x27;&#x27;</span><br>    <span class="hljs-keyword">try</span>:<br>        location = user_json[<span class="hljs-string">&#x27;locations&#x27;</span>][<span class="hljs-number">0</span>][<span class="hljs-string">&#x27;name&#x27;</span>]<br>    <span class="hljs-keyword">except</span>:<br>        location = <span class="hljs-string">&#x27;&#x27;</span><br>    gender = user_json[<span class="hljs-string">&#x27;gender&#x27;</span>]<br>    <span class="hljs-keyword">if</span> gender == <span class="hljs-number">1</span>:<br>        gender = <span class="hljs-string">&#x27;男&#x27;</span><br>    <span class="hljs-keyword">elif</span> gender == <span class="hljs-number">0</span>:<br>        gender = <span class="hljs-string">&#x27;女&#x27;</span><br>    <span class="hljs-keyword">else</span>:<br>        gender = <span class="hljs-string">&#x27;未知&#x27;</span><br>    uesr_list = [user_info, job, company, description, business, zhihu_name, location, gender, school, major]<br>    print(uesr_list)<br>    <span class="hljs-keyword">return</span> followinglist<br><br><br>urltoken = <span class="hljs-string">&#x27;sgai&#x27;</span><br><span class="hljs-keyword">for</span> urltoken <span class="hljs-keyword">in</span> user(urltoken):<br>    print(user(urltoken))<br></code></pre></td></tr></table></figure>
<p>呈现的结果部分如下：</p>
<figure class="highlight scheme"><table><tr><td class="code"><pre><code class="hljs scheme">[<span class="hljs-symbol">&#x27;喜欢用数据讲故事。</span>&#x27;, <span class="hljs-symbol">&#x27;数据挖掘工程师</span>&#x27;, <span class="hljs-symbol">&#x27;物流</span>&#x27;, <span class="hljs-symbol">&#x27;有关于我的工作和生活都在微信公众号：一个程序员的日常；会接数据采集、爬虫定制、数据分析相关的单子，请直接私信我。</span>&#x27;, <span class="hljs-symbol">&#x27;互联网</span>&#x27;, <span class="hljs-symbol">&#x27;路人甲</span>&#x27;, <span class="hljs-symbol">&#x27;上海</span>&#x27;, <span class="hljs-symbol">&#x27;男</span>&#x27;, &#x27;&#x27;, &#x27;&#x27;]<br>[<span class="hljs-symbol">&#x27;不追先圣脚步，我行处，皆道路！</span>&#x27;, <span class="hljs-symbol">&#x27;二当家</span>&#x27;, <span class="hljs-symbol">&#x27;游戏公司</span>&#x27;, <span class="hljs-symbol">&#x27;此心光明，亦复何言。我已委托“维权骑士”（&lt;a</span> href=<span class="hljs-string">&quot;https://link.zhihu.com/?target=http%3A//rightknights.com&quot;</span> class=<span class="hljs-string">&quot; external&quot;</span> target=<span class="hljs-string">&quot;_blank&quot;</span> rel=<span class="hljs-string">&quot;nofollow noreferrer&quot;</span>&gt;&lt;span class=<span class="hljs-string">&quot;invisible&quot;</span>&gt;http://&lt;/span&gt;&lt;span class=<span class="hljs-string">&quot;visible&quot;</span>&gt;rightknights.com&lt;/span&gt;&lt;span class=<span class="hljs-string">&quot;invisible&quot;</span>&gt;&lt;/span&gt;&lt;i class=<span class="hljs-string">&quot;icon-external&quot;</span>&gt;&lt;/i&gt;&lt;/a&gt;）为我的文章进行维权行动&#x27;, <span class="hljs-symbol">&#x27;互联网</span>&#x27;, <span class="hljs-symbol">&#x27;断罪小学赵日天</span>&#x27;, <span class="hljs-symbol">&#x27;深圳/南京/上海</span>&#x27;, <span class="hljs-symbol">&#x27;男</span>&#x27;, &#x27;&#x27;, &#x27;&#x27;]<br>[<span class="hljs-symbol">&#x27;yang-ze-yong-3</span>&#x27;, <span class="hljs-symbol">&#x27;zhong-wen-40-43</span>&#x27;, <span class="hljs-symbol">&#x27;ni-ke-ri-xiang-ji</span>&#x27;, <span class="hljs-symbol">&#x27;miloyip</span>&#x27;, <span class="hljs-symbol">&#x27;zuo-wen-jie</span>&#x27;, <span class="hljs-symbol">&#x27;lxghost</span>&#x27;, <span class="hljs-symbol">&#x27;mukadas-kadir</span>&#x27;, <span class="hljs-symbol">&#x27;justin-99-9</span>&#x27;, <span class="hljs-symbol">&#x27;wang-ruo-shan-88</span>&#x27;, <span class="hljs-symbol">&#x27;zhaoyanbo0098</span>&#x27;, <span class="hljs-symbol">&#x27;guo-tao-45-48</span>&#x27;, <span class="hljs-symbol">&#x27;mtjj</span>&#x27;, <span class="hljs-symbol">&#x27;satanzhangdi</span>&#x27;, <span class="hljs-symbol">&#x27;wang-hong-hao-99</span>&#x27;, <span class="hljs-symbol">&#x27;bei-mang-4</span>&#x27;, <span class="hljs-symbol">&#x27;water-five</span>&#x27;, <span class="hljs-symbol">&#x27;li-ji-ren</span>&#x27;, <span class="hljs-symbol">&#x27;he-jing-92-23</span>&#x27;, <span class="hljs-symbol">&#x27;wei-lan-tian-4</span>&#x27;, <span class="hljs-symbol">&#x27;yang-da-bao-32</span>&#x27;]<br>[<span class="hljs-symbol">&#x27;个人微信：Maekcurtain</span>&#x27;, <span class="hljs-symbol">&#x27;414632028</span>&#x27;, <span class="hljs-symbol">&#x27;UI设计交流群</span>&#x27;, &#x27;&#x27;, <span class="hljs-symbol">&#x27;互联网</span>&#x27;, <span class="hljs-symbol">&#x27;莫若</span>&#x27;, &#x27;&#x27;, <span class="hljs-symbol">&#x27;男</span>&#x27;, <span class="hljs-symbol">&#x27;微信公众号</span>&#x27;, <span class="hljs-symbol">&#x27;imui1060</span>&#x27;]<br>[<span class="hljs-symbol">&#x27;chenqin</span>&#x27;, <span class="hljs-symbol">&#x27;xia-ji-ji-28</span>&#x27;, <span class="hljs-symbol">&#x27;yunshu</span>&#x27;, <span class="hljs-symbol">&#x27;sizhuren</span>&#x27;, <span class="hljs-symbol">&#x27;sgai</span>&#x27;, <span class="hljs-symbol">&#x27;hua-sha-94</span>&#x27;, <span class="hljs-symbol">&#x27;guahu</span>&#x27;, <span class="hljs-symbol">&#x27;sun-lin-li-72-11</span>&#x27;, <span class="hljs-symbol">&#x27;luo-pan-57</span>&#x27;, <span class="hljs-symbol">&#x27;wang-ni-ma-94</span>&#x27;, <span class="hljs-symbol">&#x27;si-tu-ying-ying-18</span>&#x27;, <span class="hljs-symbol">&#x27;zheng-gong-si</span>&#x27;, <span class="hljs-symbol">&#x27;cao-rui-ting-18</span>&#x27;, <span class="hljs-symbol">&#x27;tian-ji-shun</span>&#x27;, <span class="hljs-symbol">&#x27;ding-xiang-yi-sheng</span>&#x27;, <span class="hljs-symbol">&#x27;jue-qiang-de-nu-li</span>&#x27;, <span class="hljs-symbol">&#x27;ma-bo-yong</span>&#x27;, <span class="hljs-symbol">&#x27;xiaoxueli</span>&#x27;, <span class="hljs-symbol">&#x27;ai-an-dong-ni-tu-zi-73</span>&#x27;, <span class="hljs-symbol">&#x27;guo-zi-501</span>&#x27;]<br>[<span class="hljs-symbol">&#x27;孤独享受者</span>&#x27;, &#x27;&#x27;, &#x27;&#x27;, <span class="hljs-symbol">&#x27;愿你梦里有喝不完的酒</span>&#x27;, &#x27;&#x27;, <span class="hljs-symbol">&#x27;奥LiVia</span>&#x27;, <span class="hljs-symbol">&#x27;北京</span>&#x27;, <span class="hljs-symbol">&#x27;女</span>&#x27;, &#x27;&#x27;, &#x27;&#x27;]<br>[<span class="hljs-symbol">&#x27;metrodatateam</span>&#x27;, <span class="hljs-symbol">&#x27;jllijlli</span>&#x27;, <span class="hljs-symbol">&#x27;zao-meng-zhe-62-62</span>&#x27;, <span class="hljs-symbol">&#x27;kaiserwang730</span>&#x27;, <span class="hljs-symbol">&#x27;olivia-60-10</span>&#x27;, <span class="hljs-symbol">&#x27;qi-e-chi-he-zhi-nan</span>&#x27;, <span class="hljs-symbol">&#x27;fandaidai</span>&#x27;, <span class="hljs-symbol">&#x27;an-cheng-98</span>&#x27;, <span class="hljs-symbol">&#x27;zhou-zuo</span>&#x27;, <span class="hljs-symbol">&#x27;yang-ru-55-52</span>&#x27;, <span class="hljs-symbol">&#x27;wang-tiao-tiao-91</span>&#x27;, <span class="hljs-symbol">&#x27;EDASP</span>&#x27;, <span class="hljs-symbol">&#x27;ma-ke-28</span>&#x27;, <span class="hljs-symbol">&#x27;shirley-shan-63</span>&#x27;, <span class="hljs-symbol">&#x27;lens-27</span>&#x27;, <span class="hljs-symbol">&#x27;mo-zhi-xian-sheng</span>&#x27;, <span class="hljs-symbol">&#x27;hu-yang-zi</span>&#x27;, <span class="hljs-symbol">&#x27;tu-si-ji-da-lao-ye</span>&#x27;, <span class="hljs-symbol">&#x27;summer-world</span>&#x27;, <span class="hljs-symbol">&#x27;liusonglin</span>&#x27;]<br>[<span class="hljs-symbol">&#x27;非正经演绎派厨艺新鲜人，公众号：餐桌奇谈</span>&#x27;, <span class="hljs-symbol">&#x27;吃货担当</span>&#x27;, <span class="hljs-symbol">&#x27;美食圈</span>&#x27;, <span class="hljs-symbol">&#x27;我有一颗馋嘴痣～~所有文章及答案均需付费转载，不允许擅自搬运~我已委托“维权骑士”（&lt;a</span> href=<span class="hljs-string">&quot;https://link.zhihu.com/?target=http%3A//rightknights.com&quot;</span> class=<span class="hljs-string">&quot; external&quot;</span> target=<span class="hljs-string">&quot;_blank&quot;</span> rel=<span class="hljs-string">&quot;nofollow noreferrer&quot;</span>&gt;&lt;span class=<span class="hljs-string">&quot;invisible&quot;</span>&gt;http://&lt;/span&gt;&lt;span class=<span class="hljs-string">&quot;visible&quot;</span>&gt;rightknights.com&lt;/span&gt;&lt;span class=<span class="hljs-string">&quot;invisible&quot;</span>&gt;&lt;/span&gt;&lt;i class=<span class="hljs-string">&quot;icon-external&quot;</span>&gt;&lt;/i&gt;&lt;/a&gt;）为我的文章进行维权行动&#x27;, <span class="hljs-symbol">&#x27;互联网</span>&#x27;, <span class="hljs-symbol">&#x27;芊芊呐小桌儿</span>&#x27;, <span class="hljs-symbol">&#x27;北京</span>&#x27;, <span class="hljs-symbol">&#x27;女</span>&#x27;, &#x27;&#x27;, &#x27;&#x27;]<br>[<span class="hljs-symbol">&#x27;feiyucz</span>&#x27;, <span class="hljs-symbol">&#x27;richard-45-75</span>&#x27;, <span class="hljs-symbol">&#x27;nusbrant</span>&#x27;, <span class="hljs-symbol">&#x27;sgai</span>&#x27;, <span class="hljs-symbol">&#x27;zhou-dong-yu-55-93</span>&#x27;, <span class="hljs-symbol">&#x27;easteregg</span>&#x27;, <span class="hljs-symbol">&#x27;cai-lan-80-17</span>&#x27;, <span class="hljs-symbol">&#x27;zhao-yu-67-63</span>&#x27;, <span class="hljs-symbol">&#x27;MrBurning</span>&#x27;, <span class="hljs-symbol">&#x27;zhouzhao</span>&#x27;, <span class="hljs-symbol">&#x27;excited-vczh</span>&#x27;, <span class="hljs-symbol">&#x27;justjavac.com</span>&#x27;, <span class="hljs-symbol">&#x27;mu-se-wan-sheng-ge</span>&#x27;, <span class="hljs-symbol">&#x27;simona-wen</span>&#x27;, <span class="hljs-symbol">&#x27;wstcbh</span>&#x27;, <span class="hljs-symbol">&#x27;BoomberLiu</span>&#x27;, <span class="hljs-symbol">&#x27;qing-yuan-zi-84</span>&#x27;, <span class="hljs-symbol">&#x27;cocokele</span>&#x27;, <span class="hljs-symbol">&#x27;hei-bai-hui-11-79</span>&#x27;, <span class="hljs-symbol">&#x27;wangxiaofeng</span>&#x27;]<br></code></pre></td></tr></table></figure>
<p>由此知道我的想法可以运行起来，所以开始创建工程</p>
<h3 id="1-创建工程"><a href="#1-创建工程" class="headerlink" title="1.创建工程"></a>1.创建工程</h3><blockquote>
<p>整个流程：从起始url中解析出用户信息，然后进入关注者界面和被关注者界面，提取关系用户ID和新的用户链接，将用户信息和关系用户ID存储到MongoDB中，将新的用户链接交给用户信息解析模块，依次类推。完成循环抓取任务</p>
</blockquote>
<p>在终端输入</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>scrapy startproject zhihuSpider<br></code></pre></td></tr></table></figure>
<p>之后会在当前目录生成以下结构</p>
<figure class="highlight coq"><table><tr><td class="code"><pre><code class="hljs coq">zhihuSpider<br>    |<span class="hljs-type">- scrapy</span>.cfg                        项目部署文件<br>    |<span class="hljs-type">- zhihuSpider</span>                     该项目的python模块，可以在这里加入代码<br>        |<span class="hljs-type">- __init__</span>.py                 <br>        |<span class="hljs-type">- items</span>.py                       主要是将爬取的非结构性的数据源提取结构性数据<br>        |<span class="hljs-type">- middlewares</span>.py          <br>        |<span class="hljs-type">- pipelines</span>.py                  将爬取的数据进行持久化存储<br>        |<span class="hljs-type">-  __pycache__</span>  <br>        |<span class="hljs-type">-  settings</span>.py                  配置文件<br>        |<span class="hljs-type">-  spiders</span>                       放置spider代码的目录<br>            |<span class="hljs-type">-  __init__</span>.py <br>            |<span class="hljs-type">-  __pycache__</span><br></code></pre></td></tr></table></figure>
<h3 id="2-创建爬虫模块"><a href="#2-创建爬虫模块" class="headerlink" title="2.创建爬虫模块"></a>2.创建爬虫模块</h3><p>在终端输入</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><code class="hljs vim">$ <span class="hljs-keyword">cd</span> zhihuSpider<br>$ scrapy genspider -t crawl zhihu.<span class="hljs-keyword">com</span> zhihu.<span class="hljs-keyword">com</span><br></code></pre></td></tr></table></figure>
<p>这里是用scpry的bench的genspider<br>语法是scrapy genspider[-t template] &lt;name&gt; &lt;domain&gt;<br>可以用模板来创建spider<br>之后spider文件夹下面会多出一个zhihu_com.py的文件，里面有段代码为：</p>
<figure class="highlight basic"><table><tr><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">7 </span>    <span class="hljs-keyword">name</span> = <span class="hljs-comment">&#x27;zhihu.com&#x27;</span><br><span class="hljs-symbol">8 </span>    allowed_domains = [<span class="hljs-comment">&#x27;zhihu.com&#x27;]</span><br><span class="hljs-symbol">9 </span>    start_urls = [<span class="hljs-comment">&#x27;http://zhihu.com/&#x27;]</span><br><br></code></pre></td></tr></table></figure>
<p>其中<br>name是定义spider名字的字符串，它是必须且唯一的<br> allowed_domains是可选的，它包含了spider允许爬取的域名列表。当OffsiteMiddleware组件启用是，域名不在列表中的url不会被跟进<br> start_urls为url列表，当没有使用start_requests()方法配置Requests时，Spider将从该列表中开始进行爬取<br> 重新回到开头看到<br> <figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">ZhihuComSpider</span>(<span class="hljs-symbol">CrawlSpider</span>):<br></code></pre></td></tr></table></figure><br> Spider有3大类，最基本的是Spieder，他的属性有name, allowed_domains, start_urls,custom_settings,crawler,start_requests().除了Spieder外还有CrawlSpider和XMLFeedSpider。<br> CraelCpider除了从Spider继承过来的属性外，还提供了一个新的属性rules，rules是一个包含一个或多个Rule对象的集合，每个Rule对爬取网站的动作定义了特定的规则。如果多个Rule匹配了相同的链接，则根据它们在rules属性中被定义的顺序，第一个会被使用。<br> Rule类的原型为：<br> <figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml">scrapy.contrib,spiders.<span class="hljs-constructor">Rule(<span class="hljs-params">link_extractor</span>,<span class="hljs-params">callback</span>=None,<span class="hljs-params">cb_kwargs</span>=None,<span class="hljs-params">follow</span>=None,<span class="hljs-params">process_links</span>=None, <span class="hljs-params">process_request</span>=None)</span><br></code></pre></td></tr></table></figure><br> 参数说明</p>
<blockquote>
<p>link_extractor 是一个LinkExtractor对象，定义了如何从爬取到的页面提取链接。<br>callback回调函数接受一个response作为一个参数，应避免使用parse作为回调函数<br>cb_kwargs包含传递给回调函数的参数的字典<br>follow是一个布尔值，指定了根据规则从respose提取的链接是否需要跟进</p>
</blockquote>
<p> 然而，知乎跳转到关注人的链接不是完整的，而是类似/perople/xxx/following的，crawlSpider没办法识别，所以不能使用rules（或者是我食用crawlSpider方法不对？我都弄了半天了）<br> 了解了这样多，结果我就直接套上去，不使用rules，因为我的链接不是从网页里面提取的，要自己创造的<br> 直接把url注释掉，因为CrawlSpider属于Spider类，所以调用parse解析就好了<br> <figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ZhihuComSpider</span>(<span class="hljs-params">CrawlSpider</span>):</span><br>   name = <span class="hljs-string">&#x27;zhihu.com&#x27;</span><br>   allowed_domains = [<span class="hljs-string">&#x27;zhihu.com&#x27;</span>]<br>   start_urls = [<span class="hljs-string">&#x27;https://www.zhihu.com/people/sgai/following&#x27;</span>]<br><br><br>   <span class="hljs-comment">#rules = (</span><br>   <span class="hljs-comment">#    Rule(LinkExtractor(allow=r&#x27;/people/(\w+)/following$&#x27;, process_value=&#x27;my_process_value&#x27;, unique=True, deny_domains=deny), callback=&#x27;parse_item&#x27;, follow=True),</span><br>   <span class="hljs-comment">#)</span><br><br><br>   <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">parse</span>(<span class="hljs-params">self, response</span>):</span><br></code></pre></td></tr></table></figure><br> 然后到setting.py下面更改3个数值<br> <figure class="highlight vbnet"><table><tr><td class="code"><pre><code class="hljs vbnet"> 请求头<br> USER_AGENT = <span class="hljs-comment">&#x27;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36&#x27;</span><br>关闭robot<br>ROBOTSTXT_OBEY = <span class="hljs-literal">False</span><br>关闭cookies追踪<br>COOKIES_ENABLED = <span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure></p>
<h3 id="3-解析网页"><a href="#3-解析网页" class="headerlink" title="3.解析网页"></a>3.解析网页</h3><p>解析网页直接照搬我之前测试是否可以运行的代码，并进行了相对应的修改</p>
<ul>
<li>建立一个url存放列表，进行url去重</li>
<li>从网页捕获用户urltoken</li>
<li>tempset部分用户存在没有none存在的情况，捕获错误并pass</li>
<li>description部分存在有些用户含有html代码，但是我不知道怎么去除只获取中文。。。。</li>
<li>把获取的数据封装到item里面</li>
<li>判断捉取的用户列表有没有存在False（用户关注数量低于20个就会出现，由于直接返回False，所以直接用if判断）<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">parse</span>(<span class="hljs-params">self, response</span>):</span><br>        deny = []<br>        html = response.text<br>        soup = BeautifulSoup(html, <span class="hljs-string">&#x27;html.parser&#x27;</span>)<br>        token = soup.find(<span class="hljs-string">&quot;a&quot;</span>,&#123;<span class="hljs-string">&quot;class&quot;</span>:<span class="hljs-string">&quot;Tabs-link&quot;</span>&#125;)<br>        pattern = <span class="hljs-string">r&#x27;e/(.+)/ac&#x27;</span><br>        urltoken = re.findall(pattern, <span class="hljs-built_in">str</span>(token))[<span class="hljs-number">0</span>]<br>        json_text = soup.body.contents[<span class="hljs-number">1</span>].attrs[<span class="hljs-string">&#x27;data-state&#x27;</span>]<br>        ob_json = json.loads(json_text)<br>        followinglist = ob_json[<span class="hljs-string">&#x27;people&#x27;</span>][<span class="hljs-string">&#x27;followingByUser&#x27;</span>][urltoken][<span class="hljs-string">&#x27;ids&#x27;</span>]<br>        tempset = <span class="hljs-built_in">set</span>(followinglist)<br>        <span class="hljs-keyword">try</span>:<br>            tempset.remove(<span class="hljs-literal">None</span>)<br>        <span class="hljs-keyword">except</span>:<br>            <span class="hljs-keyword">pass</span><br>        followinglist = <span class="hljs-built_in">list</span>(tempset)<br>        user_json = ob_json[<span class="hljs-string">&#x27;entities&#x27;</span>][<span class="hljs-string">&#x27;users&#x27;</span>][urltoken]<br>        user_info = user_json[<span class="hljs-string">&#x27;headline&#x27;</span>]<br>        <span class="hljs-keyword">try</span>:<br>            school = user_json[<span class="hljs-string">&#x27;educations&#x27;</span>][<span class="hljs-number">0</span>][<span class="hljs-string">&#x27;school&#x27;</span>][<span class="hljs-string">&#x27;name&#x27;</span>]<br>        <span class="hljs-keyword">except</span>:<br>            school = <span class="hljs-string">&#x27;该用户尚未填写&#x27;</span><br>        <span class="hljs-keyword">try</span>:<br>            major = user_json[<span class="hljs-string">&#x27;educations&#x27;</span>][<span class="hljs-number">0</span>][<span class="hljs-string">&#x27;major&#x27;</span>][<span class="hljs-string">&#x27;name&#x27;</span>]<br>        <span class="hljs-keyword">except</span>:<br>            major = <span class="hljs-string">&#x27;该用户尚未填写&#x27;</span><br>        <span class="hljs-keyword">try</span>:<br>            job = user_json[<span class="hljs-string">&#x27;employments&#x27;</span>][<span class="hljs-number">0</span>][<span class="hljs-string">&#x27;job&#x27;</span>][<span class="hljs-string">&#x27;name&#x27;</span>]<br>        <span class="hljs-keyword">except</span>:<br>            job = <span class="hljs-string">&#x27;该用户尚未填写&#x27;</span><br>        <span class="hljs-keyword">try</span>:<br>            company = user_json[<span class="hljs-string">&#x27;employments&#x27;</span>][<span class="hljs-number">0</span>][<span class="hljs-string">&#x27;company&#x27;</span>][<span class="hljs-string">&#x27;name&#x27;</span>]<br>        <span class="hljs-keyword">except</span>:<br>            company = <span class="hljs-string">&#x27;该用户尚未填写&#x27;</span><br>        <span class="hljs-keyword">try</span>: <br>            description = user_json[<span class="hljs-string">&#x27;description&#x27;</span>]<br>        <span class="hljs-keyword">except</span>:<br>            description = <span class="hljs-string">&#x27;该用户尚未填写&#x27;</span><br>        <span class="hljs-keyword">try</span>:<br>            business = user_json[<span class="hljs-string">&#x27;business&#x27;</span>][<span class="hljs-string">&#x27;name&#x27;</span>]<br>        <span class="hljs-keyword">except</span>:<br>            business = <span class="hljs-string">&#x27;该用户尚未填写&#x27;</span><br>        <span class="hljs-keyword">try</span>:<br>            zhihu_name = user_json[<span class="hljs-string">&#x27;name&#x27;</span>]<br>        <span class="hljs-keyword">except</span>:<br>            zhihu_name = <span class="hljs-string">&#x27;该用户尚未填写&#x27;</span><br>        <span class="hljs-keyword">try</span>:<br>            location = user_json[<span class="hljs-string">&#x27;locations&#x27;</span>][<span class="hljs-number">0</span>][<span class="hljs-string">&#x27;name&#x27;</span>]<br>        <span class="hljs-keyword">except</span>:<br>            location = <span class="hljs-string">&#x27;该用户尚未填写&#x27;</span><br>        gender = user_json[<span class="hljs-string">&#x27;gender&#x27;</span>]<br>        <span class="hljs-keyword">if</span> gender == <span class="hljs-number">1</span>:<br>            gender = <span class="hljs-string">&#x27;男&#x27;</span><br>        <span class="hljs-keyword">elif</span> gender == <span class="hljs-number">0</span>:<br>            gender = <span class="hljs-string">&#x27;女&#x27;</span><br>        <span class="hljs-keyword">else</span>:<br>            gender = <span class="hljs-string">&#x27;未知&#x27;</span><br><br>        item =UserInfoItem(urltoken=urltoken,user_info=user_info, job=job, company=company, description=description, business=business, zhihu_name=zhihu_name, location=location, gender=gender, school=school, major=major) <br>        <span class="hljs-keyword">yield</span> item<br>        <span class="hljs-comment">#print(followinglist)</span><br>        <span class="hljs-keyword">for</span> following <span class="hljs-keyword">in</span> followinglist:<br>            <span class="hljs-keyword">if</span> following:<br>                url = <span class="hljs-string">&#x27;https://www.zhihu.com/people/&#x27;</span>+following+<span class="hljs-string">&#x27;/following&#x27;</span><br>            <span class="hljs-comment">#else:</span><br>                <span class="hljs-comment">#url = &#x27;https://www.zhihu.com/people/&#x27;+urltoken+&#x27;/following&#x27;</span><br><br>            <span class="hljs-keyword">if</span> url <span class="hljs-keyword">in</span> deny:<br>                <span class="hljs-keyword">pass</span><br>            <span class="hljs-keyword">else</span>:<br>                deny.append(url)    <br>                <span class="hljs-keyword">yield</span> scrapy.Request(url=url,callback=self.parse)<br><br></code></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="4-定义item"><a href="#4-定义item" class="headerlink" title="4.定义item"></a>4.定义item</h3><p>定义两个item</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> scrapy<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserInfoItem</span>(<span class="hljs-params">scrapy.Item</span>):</span><br><br>    <span class="hljs-comment">#id</span><br>    urltoken = scrapy.Field()<br>    <span class="hljs-comment">#个人简介</span><br>    user_info = scrapy.Field()<br>    <span class="hljs-comment">#姓名</span><br>    zhihu_name = scrapy.Field()<br>    <span class="hljs-comment">#居住地</span><br>    location = scrapy.Field()<br>    <span class="hljs-comment">#技术领域</span><br>    business = scrapy.Field()<br>    <span class="hljs-comment">#性别</span><br>    gender = scrapy.Field()<br>    <span class="hljs-comment">#公司</span><br>    company = scrapy.Field()<br>    <span class="hljs-comment">#职位</span><br>    job = scrapy.Field()<br>    <span class="hljs-comment">#学校</span><br>    school = scrapy.Field()<br>    <span class="hljs-comment">#教育经历</span><br>    major = scrapy.Field()<br>    <span class="hljs-comment">#简介</span><br>    description = scrapy.Field()<br><br></code></pre></td></tr></table></figure>
<h3 id="5-Pipeline"><a href="#5-Pipeline" class="headerlink" title="5.Pipeline"></a>5.Pipeline</h3><p>定义一个Pipeline，让scrapy把数据从item存入到mongodb数据库里面，配套设置在settings.py里面</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pymongo<br><br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ZhihuspiderPipeline</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, mongo_url, mongo_db</span>):</span><br>        self.mongo_url = mongo_url<br>        self.mongo_db = mongo_db<br><br><span class="hljs-meta">    @classmethod</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">from_crawler</span>(<span class="hljs-params">cls, crawler</span>):</span><br>        <span class="hljs-keyword">return</span> cls(<br>            mongo_url=crawler.settings.get(<span class="hljs-string">&#x27;MONGO_URL&#x27;</span>),<br>            mongo_db=crawler.settings.get(<span class="hljs-string">&#x27;MONGO_DATABASE&#x27;</span>, <span class="hljs-string">&#x27;items&#x27;</span>)<br>        )<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">open_spider</span>(<span class="hljs-params">self, spider</span>):</span><br>        self.client = pymongo.MongoClient(self.mongo_url)<br>        self.db = self.client[self.mongo_db]<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">close_spider</span>(<span class="hljs-params">self, spider</span>):</span><br>        self.client.close()<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">process_item</span>(<span class="hljs-params">self, item, spider</span>):</span><br>    	self.db.UserInfo.insert(<span class="hljs-built_in">dict</span>(item))<br>    	<span class="hljs-keyword">return</span> item<br></code></pre></td></tr></table></figure>
<h3 id="6-其他补充"><a href="#6-其他补充" class="headerlink" title="6.其他补充"></a>6.其他补充</h3><h4 id="6-1-利用middlewares-py实现ip代理"><a href="#6-1-利用middlewares-py实现ip代理" class="headerlink" title="6.1.利用middlewares.py实现ip代理"></a>6.1.利用middlewares.py实现ip代理</h4><p>配到设置在settings.py里面</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> random<br><br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RandomProxy</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self,iplist</span>):</span><br>        self.iplist=iplist<br><br><span class="hljs-meta">    @classmethod</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">from_crawler</span>(<span class="hljs-params">cls,crawler</span>):</span><br>        <span class="hljs-keyword">return</span> cls(crawler.settings.getlist(<span class="hljs-string">&#x27;IPLIST&#x27;</span>))<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">process_request</span>(<span class="hljs-params">self, request, spider</span>):</span><br>        proxy = random.choice(self.iplist)<br>        request.meta[<span class="hljs-string">&#x27;proxy&#x27;</span>] =proxy<br></code></pre></td></tr></table></figure>
<h4 id="6-2setting设置"><a href="#6-2setting设置" class="headerlink" title="6.2setting设置"></a>6.2setting设置</h4><p>请求头添加</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">USER_AGENT</span> = &#x27;Mozilla/<span class="hljs-number">5</span>.<span class="hljs-number">0</span> (X<span class="hljs-number">11</span>; Linux x<span class="hljs-number">86</span>_<span class="hljs-number">64</span>) AppleWebKit/<span class="hljs-number">537</span>.<span class="hljs-number">36</span> (KHTML, like Gecko) Chrome/<span class="hljs-number">58</span>.<span class="hljs-number">0</span>.<span class="hljs-number">3029</span>.<span class="hljs-number">110</span> Safari/<span class="hljs-number">537</span>.<span class="hljs-number">36</span>&#x27;<br></code></pre></td></tr></table></figure>
<p>激活item和中间件</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">DOWNLOADER_MIDDLEWARES</span> = &#123;<br>    <span class="hljs-string">&#x27;zhihuSpider.middlewares.RandomProxy&#x27;</span>:543<br>&#125;<br><br>ITEM_PIPELINES = &#123;<br>    <span class="hljs-string">&#x27;zhihuSpider.pipelines.ZhihuspiderPipeline&#x27;</span>: 300,<br>&#125;<br></code></pre></td></tr></table></figure>
<p>激活随机爬取时间</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">AUTOTHROTTLE_ENABLED</span> = <span class="hljs-literal">True</span><br><span class="hljs-comment"># The initial download delay</span><br><span class="hljs-attr">AUTOTHROTTLE_START_DELAY</span> = <span class="hljs-number">5</span><br><span class="hljs-comment"># The maximum download delay to be set in case of high latencies</span><br><span class="hljs-attr">AUTOTHROTTLE_MAX_DELAY</span> = <span class="hljs-number">60</span><br></code></pre></td></tr></table></figure>
<p>MONGODB配置</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">MONGO_URL</span> = <span class="hljs-string">&#x27;mongodb://localhost:27017/&#x27;</span><br><span class="hljs-attr">MONGO_DATABASE</span>=<span class="hljs-string">&#x27;zhihu&#x27;</span><br></code></pre></td></tr></table></figure>
<p>ip代理列表<br>这个ip我是从免费代理IP拿的，测试一下ip代理是否可行，我的ip代理池捉不到什么有效 ip了- -。。。</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">IPLIST</span>=[<span class="hljs-string">&quot;https://14.112.76.235:65309&quot;</span>]<br></code></pre></td></tr></table></figure>
<h3 id="7-结果"><a href="#7-结果" class="headerlink" title="7.结果"></a>7.结果</h3><p>用几个数据测试一下是否有保存，要爬取全部的话还要等重新换个ip代理池<br><img    class="lazyload" data-original="https://github.com/so1n/so1n_blog_photo/blob/master/blog_photo/scrapy%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9F%A5%E8%AF%A2.jpg?raw=true" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">enter description here</span></p>
<h3 id="7-优化与补充"><a href="#7-优化与补充" class="headerlink" title="7.优化与补充"></a>7.优化与补充</h3><ul>
<li><a href="http://www.jianshu.com/p/63638e1b8c65">Scrapy 自定义settings–简化编写爬虫操作–加快爬虫速度</a></li>
<li><a href="https://www.v2ex.com/t/232070">v2ex讨论《scrapy 抓取速度问题》</a><br>还有scrapyd部署和scrapyd-client部署见上一篇文章</li>
</ul>
]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>学习笔记</tag>
        <tag>爬虫</tag>
        <tag>scrapy</tag>
      </tags>
  </entry>
  <entry>
    <title>基于django的博客(1)</title>
    <url>/2017/08/23/p1/</url>
    <content><![CDATA[<h2 id="前记"><a href="#前记" class="headerlink" title="前记"></a>前记</h2><p>一开始为了熟悉django而按照教程或者文章写的基于django的博客</p>
<p>一个非常简单的博客实现</p>
<span id="more"></span>

<h2 id="github"><a href="#github" class="headerlink" title="github"></a>github</h2><p><a href="https://github.com/so1n/Django_project/tree/master/project1">代码仓</a></p>
<h2 id="基本功能"><a href="#基本功能" class="headerlink" title="基本功能"></a>基本功能</h2><p>代码量比较少只是简单的实现增删改</p>
<ul>
<li>管理员发表文章</li>
<li>访问者查看文章<ul>
<li> 归档</li>
<li> 标签</li>
<li> 分类</li>
<li> 搜索</li>
</ul>
</li>
</ul>
<h2 id="new"><a href="#new" class="headerlink" title="new"></a>new</h2><h3 id="DetailView与ListView"><a href="#DetailView与ListView" class="headerlink" title="DetailView与ListView"></a>DetailView与ListView</h3><p>为了减少代码使用量等，在django中可以使用基于view来编写视图。常用的有DetailView与ListView，他们有些细微的却别:</p>
<ul>
<li>主要功能<ul>
<li>ListView-从数据库中获取模型列表的数据</li>
<li>DetailView从数据库获取模型的一条记录数据。比如查看某篇文章的详情，就是从数据库中获取这篇文章的记录然后渲染模板。</li>
</ul>
</li>
</ul>
<p>方法：</p>
<ul>
<li><p>DetailView 有以下方法：</p>
<ul>
<li>dispatch()</li>
<li>http_method_not_allowed()</li>
<li>get_template_names()</li>
<li>get_slug_field()</li>
<li>get_queryset()</li>
<li>get_object()</li>
<li>get_context_object_name()</li>
<li>get_context_data()</li>
<li>get()</li>
<li>render_to_response()</li>
</ul>
</li>
<li><p>ListView 有以下方法：</p>
<ul>
<li>dispatch()</li>
<li>http_method_not_allowed()</li>
<li>get_template_names()</li>
<li>get_queryset()</li>
<li>get_context_object_name()</li>
<li>get_context_data()</li>
<li>get()</li>
<li>render_to_response()</li>
</ul>
</li>
</ul>
<p>内部结构：<br>ListView类图<br><img    class="lazyload" data-original="https://github.com/so1n/so1n_blog_photo/blob/master/blog_photo/django%E5%8D%9A%E5%AE%A21-1.png?raw=true" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">ListView类图</span><br>DetailView类图<br><img    class="lazyload" data-original="https://github.com/so1n/so1n_blog_photo/blob/master/blog_photo/django1-2.png?raw=true" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">DetailView类图</span><br>在这两个类图中，最关键的组件就是MultiObjectMixin和SingleObjectMixin这两个类了，他们实现的功能是从数据库中读取数据，并且构建要传入template的context。每个类都有一些属性和方法可以覆盖，实现自定制，比如可以覆盖context_object_name变量，用来指定传入template的context的对象的变量名；可以覆盖get_context_data()方法，用来将其他的变量放到context中；为queryset赋值，就可以自己指定这个View操作的对象(列表)；或者是直接重写get_queryset()/get_object()方法，简单暴力。</p>
<p>注意，这两个类，也是继承自TemplateResponseMixin，也就是说它们也是直接返回的TemplateResponse对象。</p>
<h3 id="django的处理流程"><a href="#django的处理流程" class="headerlink" title="django的处理流程"></a>django的处理流程</h3><p><a href="/2017/08/24/26/">浏览器访问流程</a></p>
<h4 id="web-server"><a href="#web-server" class="headerlink" title="web server"></a>web server</h4><p>django拥有一个自己的web server-runserver，主要用于开发和调试中，部署到线上环境时用的都是别的web server 如：nginx+uwsgi</p>
<p>runserver运行时主要是完成以下两件事：</p>
<ol>
<li>解析参数，并通过django.core.servers.basehttp.get_internal_wsgi_application方法获取wsgi handler;</li>
<li>根据ip_address和port生成一个WSGIServer对象，接受用户请求<br>get_internal_wsgi_application的源码如下：</li>
</ol>
<p><img    class="lazyload" data-original="http://of66as8gb.bkt.clouddn.com/blog/20161017/174541324.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">image</span></p>
<p>通过上面的代码可知道，Django会先根据settings中的WSGI_APPLICATION来获取handler；<br>在创建project的时候，Django会默认创建一个wsgi.py文件，而settings中的WSGI_APPLICATION配置也会默认指向这个文件。看一下这个wsgi.py文件，其实它也和上面的逻辑一样，最终调用get_wsgi_application实现。</p>
<h4 id="django-http请求处理流程-来源于网上"><a href="#django-http请求处理流程-来源于网上" class="headerlink" title="django http请求处理流程(来源于网上)"></a>django http请求处理流程(来源于网上)</h4><p>Django的具体处理流程大致如下：</p>
<ol>
<li><p>加载settings.py</p>
<blockquote>
<p>在通过django-admin.py创建project的时候，Django会自动生成默认的settings文件和manager.py等文件，在创建WSGIServer之前会执行下面的引用:</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.conf <span class="hljs-keyword">import</span> settings<br></code></pre></td></tr></table></figure>
<p>上面引用在执行时，会读取os.environ中的DJANGO_SETTINGS_MODULE配置，加载项目配置文件，生成settings对象。所以，在manager.py文件中你可以看到，在获取WSGIServer之前，会先将project的settings路径加到os路径中。</p>
</li>
<li><p>创建WSGIServer</p>
</li>
</ol>
<p>不管是使用哪个web server运行Django项目，在启动时都会调用django.core.servers.basehttp中的run()方法<br>创建一个django.core.servers.basehttp.WSGIServer类的实例，之后调用其serve_forever()方法启动HTTP服务。<br>run方法的源码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span>(<span class="hljs-params">addr, port, wsgi_handler, ipv6=<span class="hljs-literal">False</span>, threading=<span class="hljs-literal">False</span></span>):</span><br>    server_address = (addr, port)<br>    <span class="hljs-keyword">if</span> threading:<br>        httpd_cls = <span class="hljs-built_in">type</span>(<span class="hljs-built_in">str</span>(<span class="hljs-string">&#x27;WSGIServer&#x27;</span>), (socketserver.ThreadingMixIn, WSGIServer), &#123;&#125;)<br>    <span class="hljs-keyword">else</span>:<br>        httpd_cls = WSGIServer<br>    httpd = httpd_cls(server_address, WSGIRequestHandler, ipv6=ipv6)<br>    <span class="hljs-keyword">if</span> threading:<br>        <span class="hljs-comment"># ThreadingMixIn.daemon_threads indicates how threads will behave on an</span><br>        <span class="hljs-comment"># abrupt shutdown; like quitting the server by the user or restarting</span><br>        <span class="hljs-comment"># by the auto-reloader. True means the server will not wait for thread</span><br>        <span class="hljs-comment"># termination before it quits. This will make auto-reloader faster</span><br>        <span class="hljs-comment"># and will prevent the need to kill the server manually if a thread</span><br>        <span class="hljs-comment"># isn&#x27;t terminating correctly.</span><br>        httpd.daemon_threads = <span class="hljs-literal">True</span><br>    httpd.set_app(wsgi_handler)<br>    httpd.serve_forever()<br></code></pre></td></tr></table></figure>

<blockquote>
<blockquote>
<p>如上，我们可以看到：在创建WSGIServer实例的时候会指定HTTP请求的Handler，<br>上述代码使用WSGIRequestHandler。当用户的HTTP请求到达服务器时，<br>WSGIServer会创建WSGIRequestHandler实例，使用其handler方法来处理HTTP请求(其实最终是调用wsgiref.handlers.BaseHandler中的run方法处理)。<br>WSGIServer通过set_app方法设置一个可调用(callable)的对象作为application，上面提到的handler方法最终会调用设置的application处理request，并返回response。<br>其中，WSGIServer继承自wsgiref.simple_server.WSGIServer，而WSGIRequestHandler继承自wsgiref.simple_server.WSGIRequestHandler，wsgiref是python标准库给出的WSGI的参考实现。其源码可自行到wsgiref参看，这里不再细说。</p>
</blockquote>
</blockquote>
<ol start="3">
<li>处理Request</li>
</ol>
<blockquote>
<p>第二步中说到的application，在Django中一般是django.core.handlers.wsgi.WSGIHandler对象，WSGIHandler继承自django.core.handlers.base.BaseHandler，这个是Django处理request的核心逻辑，它会创建一个WSGIRequest实例，而WSGIRequest是从http.HttpRequest继承而来</p>
</blockquote>
<ol start="4">
<li>返回Response</li>
</ol>
<blockquote>
<p>上面提到的BaseHandler中有个get_response方法，该方法会先加载Django项目的ROOT_URLCONF，然后根据url规则找到对应的view方法(类)，view逻辑会根据request实例生成并返回具体的response。<br>在Django返回结果之后，第二步中提到wsgiref.handlers.BaseHandler.run方法会调用finish_response结束请求，并将内容返回给用户</p>
</blockquote>
<h4 id="Django处理Request的流程"><a href="#Django处理Request的流程" class="headerlink" title="Django处理Request的流程"></a>Django处理Request的流程</h4><p>1.用户通过浏览器输入url请求一个页面<br>2.请求到达Request Middlewares，中间件对request做一些预处理或者直接response请求(处理包括ip判断用户判断等)<br>3.URLConf通过urls.py文件和请求的URL的对比，找到相应的View<br>4.View Middlewares被访问，同样可以对request做一些处理或者直接返回response<br>5.调用View中的函数，进行逻辑判断<br>6.如果需要访问数据库获取或修改数据时，则通过Models访问底层的数据<br>7.view把对应的数据生成一个字典并返回给Template<br>8.Template接受数据并生成页面<br>    8.1Template使用Filters和Tags去渲染输出<br>    8.2HTTPResponse被发送到Response Middlewares<br>    8.3任何Response Middlewares都可以丰富response或者返回一个完全不同的response<br>    8.4Response返回到浏览器，呈现给用户</p>
<h4 id="Middleware-中间件"><a href="#Middleware-中间件" class="headerlink" title="Middleware(中间件)"></a>Middleware(中间件)</h4><p>Middleware是在Django BaseHandler的load_middleware方法执行时加载的，加载之后会建立四个列表作为处理器的实例变量：</p>
<blockquote>
<p>_request_middleware：process_request方法的列表<br>_view_middleware：process_view方法的列表<br>_response_middleware：process_response方法的列表<br>_exception_middleware：process_exception方法的列表</p>
</blockquote>
<p>Django的中间件是在其配置文件(settings.py)的MIDDLEWARE_CLASSES元组中定义的。在MIDDLEWARE_CLASSES中，中间件组件用字符串表示：指向中间件类名的完整python路径。例如</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">`MIDDLEWARE_CLASSES = [<br>    <span class="hljs-string">&#x27;django.middleware.security.SecurityMiddleware&#x27;</span>,<br>    <span class="hljs-string">&#x27;django.contrib.sessions.middleware.SessionMiddleware&#x27;</span>,<br>    <span class="hljs-string">&#x27;django.middleware.common.CommonMiddleware&#x27;</span>,<br>    <span class="hljs-string">&#x27;django.middleware.csrf.CsrfViewMiddleware&#x27;</span>,<br>    <span class="hljs-string">&#x27;django.contrib.auth.middleware.AuthenticationMiddleware&#x27;</span>,<br>    <span class="hljs-string">&#x27;django.contrib.auth.middleware.SessionAuthenticationMiddleware&#x27;</span>,<br>    <span class="hljs-string">&#x27;django.contrib.messages.middleware.MessageMiddleware&#x27;</span>,<br>    <span class="hljs-string">&#x27;django.middleware.clickjacking.XFrameOptionsMiddleware&#x27;</span>,<br>]`<br></code></pre></td></tr></table></figure>
<p>中间件出现的顺序非常重要：在request和view的处理阶段，Django按照MIDDLEWARE_CLASSES中出现的顺序来应用中间件，而在response和exception异常处理阶段，Django则按逆序来调用它们。也就是说，Django将MIDDLEWARE_CLASSES视为view函数外层的顺序包装子：在request阶段按顺序从上到下穿过，而在response则反过来。</p>
<h4 id="URLConf"><a href="#URLConf" class="headerlink" title="URLConf"></a>URLConf</h4><p>URLConf相当于Django使用的地图告诉django要怎么去寻找url<br>第一个参数是url，可以通过正则去比对相应的url。<br>第二个参数是view，告诉Django如果这个url对应的view</p>
<p>ps:第二个参数也可以是url把匹配到的url导向另一个app下面的url。使得url不会集成于一页,同时可以把二级url区分开</p>
<p>第三个参数是命名空间，告诉那些需要调用url的（如模板），输入这个命名空间的名称就能获取到对应的url</p>
<h4 id="Template"><a href="#Template" class="headerlink" title="Template"></a>Template</h4><p>django通过模板把动态数据导入html文件并返回给用户，需要注意的是，模板里不能编写python代码</p>
<h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><p><a href="https://code.ziqiangxuetang.com/django/django-nginx-deploy.html">部署教程</a></p>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>django</tag>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>scrapy学习笔记(有示例版）</title>
    <url>/2017/08/22/12-scrapy/</url>
    <content><![CDATA[<p>Scrapy学习笔记，每个都带有示例</p>
<span id="more"></span>

<h1 id="scrapy学习笔记-有示例版）"><a href="#scrapy学习笔记-有示例版）" class="headerlink" title="scrapy学习笔记(有示例版）"></a>scrapy学习笔记(有示例版）</h1><h2 id="1-使用scrapy"><a href="#1-使用scrapy" class="headerlink" title="1.使用scrapy"></a>1.使用scrapy</h2><blockquote>
<p>ps:linux环境</p>
</blockquote>
<p>安装：sudo install Scrapy</p>
<h3 id="1-1创建工程"><a href="#1-1创建工程" class="headerlink" title="1.1创建工程"></a>1.1创建工程</h3><p>$ scrapy startproject Spider<br>就创建属于自己的项目<br>同时生成一个Spider目录：</p>
<figure class="highlight coq"><table><tr><td class="code"><pre><code class="hljs coq">Spider<br>    |<span class="hljs-type">- scrapy</span>.cfg                        项目部署文件<br>    |<span class="hljs-type">- Spider</span>                     该项目的python模块，可以在这里加入代码<br>        |<span class="hljs-type">- __init__</span>.py                 <br>        |<span class="hljs-type">- items</span>.py                       主要是将爬取的非结构性的数据源提取结构性数据<br>        |<span class="hljs-type">- middlewares</span>.py          <br>        |<span class="hljs-type">- pipelines</span>.py                  将爬取的数据进行持久化存储<br>        |<span class="hljs-type">-  __pycache__</span>  <br>        |<span class="hljs-type">-  settings</span>.py                  配置文件<br>        |<span class="hljs-type">-  spiders</span>                       放置spider代码的目录<br>            |<span class="hljs-type">-  __init__</span>.py <br>            |<span class="hljs-type">-  __pycache__</span><br></code></pre></td></tr></table></figure>

<h3 id="1-2创建爬虫模块"><a href="#1-2创建爬虫模块" class="headerlink" title="1.2创建爬虫模块"></a>1.2创建爬虫模块</h3><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> scrapy<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Spider</span>(<span class="hljs-params">scrapy.Spider</span>):</span>                       <span class="hljs-comment">#创建的Spider是继承scrapy.Spider类</span><br>    name = <span class="hljs-string">&quot;Spider&quot;</span>                                      <span class="hljs-comment">#爬虫的名称（必须是项目里面唯一的）</span><br>    allowed_domain = [<span class="hljs-string">&quot;xxx.com&quot;</span>]                <span class="hljs-comment">#允许的域名（就是这个爬虫爬取链接的范围）</span><br>    start_urls = [<span class="hljs-string">&quot;http://xxx.com/xxx/xxx&quot;</span>]     <span class="hljs-comment">#开始爬取的链接</span><br>    <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">parse</span>(<span class="hljs-params">self, response</span>):</span>                     <br>        <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure>
<p>在spiders文件夹创建出这份代码，除了以上解释外，里面的parse()是一个Spider方法，被调用时，每个初始url响应后返回的Response对象，将会作为唯一的参数传递给该方法。该方法负责解析返回的数据，提取数据以及生成需要进一步处理的url的Responst对象</p>
<h3 id="1-3网页解析"><a href="#1-3网页解析" class="headerlink" title="1.3网页解析"></a>1.3网页解析</h3><p> 创建完爬虫模块后就可以进行网页解析了，Scrapy有自己的一套数据提取机制，成为选择器（selector）,它们通过特定的XPath或者CSS表达式来选择HTML文件中的某个部分，Scrapy选择器构建与lxml库上，这意味着它们在速度和解析准确性上非常相似。当然，也可以使用自己的，比如BeautifulSoup进行解析</p>
<p> Selector对象有四个基本的方法</p>
<ul>
<li><p>xpath(query)：传入XPath表达式query，返回该表达式所对应的所有节点的selector list列表</p>
</li>
<li><p>css(query)：传入CSS表达式query，返回该表达式所对应的所有节点的selector list列表</p>
</li>
<li><p>extract(): 序列化该节点为Unicode字符串并返回list列表。</p>
</li>
<li><p>re(regex)：根据传入的正则表达式对数据进行提取，返回Unicode字符串列表。regex可以是一个已编译的正则，也可以是一个将为re.compile(regex)编译为正则表达式的字符串。</p>
<p>在spider类的parse()方法中，其中一个参数是response。所以使用选择器有两种方法</p>
</li>
<li><p>将response传入Selector：Selector(response).xpath()</p>
 <figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">Selector(response).xpath(<span class="hljs-string">&#x27;//span/text()&#x27;</span>).extract()<br></code></pre></td></tr></table></figure></li>
<li><p>或者直接调用：response.xpath()</p>
 <figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">response.xpath(<span class="hljs-string">&#x27;//span/text()&#x27;</span>).extract()<br></code></pre></td></tr></table></figure>

</li>
</ul>
<p>Scrapy提供了一个简便的方式来查看表达式是否正确<br>打开命令行窗口后输入：<br>$ scrapy shell “<a href="http://xxx.com&quot;/">http://xxx.com&quot;</a><br>或者响应后<br>&gt;&gt;&gt;response.xpath(‘//span/text()’).extract()<br>就可以抽取出响应的数据了，返回的是Unicode格式</p>
<p>示例代码中extract()是提取里面的文本，并返回一个 SelectorList实例<br>如果只想提取第一个匹配的元素，可以调用选择器 .extract_first()，如果获取不到则返回None<br>可以通过使用extract_first(default=’xxx’)来自定义返回数值</p>
<p>了解了这些后可以写出一个parse()的代码<br>假设这个网页我们要提取的数据有标题，时间，评论，链接，且他们在网页的xxx里面</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">parse</span>(<span class="hljs-params">self, response</span>):</span><br>    papers = response.xpath(<span class="hljs-string">&quot;.//*[@class=&#x27;xxx&#x27;]&quot;</span>) <br>    <span class="hljs-keyword">for</span> paper <span class="hljs-keyword">in</span> papers:<br>        url = paper.xpath(<span class="hljs-string">&quot;.//*[@class=&#x27;title&#x27;]/a/@href&quot;</span>).extract()[<span class="hljs-number">0</span>]<br>        title = paper.xpath(<span class="hljs-string">&quot;.//*[@class=&#x27;title&#x27;]/a/text()&quot;</span>).extract()[<span class="hljs-number">0</span>]<br>        time = paper.xpath(<span class="hljs-string">&quot;.//*[@class=&#x27;ttime&#x27;]/a/text())&quot;</span>.extract()[<span class="hljs-number">0</span>]<br>        content = paper.xpath(<span class="hljs-string">&quot;.//*[@class=&#x27;content&#x27;]/a/text()&quot;</span>).extract()[<span class="hljs-number">0</span>]<br>        item = SpiderItem(url=url, title=title, time=time,title=title, content=content)<br>        <span class="hljs-keyword">yield</span> item<br>        <span class="hljs-keyword">yield</span> scrapy.Request(url=url, callnack=self.parse)<br></code></pre></td></tr></table></figure>
<p>yield item是把所有获得的数据封装起来,存放在Spideritem<br>yield scrapy.Request(url=url, callnack=self.parse)则是把获取到的url利用request对象构造为请求再利用callback回调到自己指定的Spideritem</p>
<h3 id="1-4-item"><a href="#1-4-item" class="headerlink" title="1.4 item"></a>1.4 item</h3><p>Scrapy提供Item类。 Item对象是用于收集所抓取的数据的简单容器。它们提供了一个类似字典的 API，具有用于声明其可用字段的方便的语法<br>在items.py文件输入</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpiderItem</span>(<span class="hljs-params">scrapt.Item</span>):</span><br>    url = scrapy.Field()<br>    time = scrapy.Field()<br>    title = scrapy.Field()<br>    content = scrapy.Field()<br></code></pre></td></tr></table></figure>
<p>就创建好了，如果要拓展item就在原始item上来拓展item</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">newSpiderItem</span>(<span class="hljs-params">SpiderItem</span>):</span><br>    xxx = scrapy.Field()<br></code></pre></td></tr></table></figure>
<h3 id="1-5Item-Pipeline"><a href="#1-5Item-Pipeline" class="headerlink" title="1.5Item Pipeline"></a>1.5Item Pipeline</h3><p>当item在Spider中被手机后，它将会传递到Item PipeLine，利用Item PipeLine来进行数据保存<br>先上一个示例代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> json<br><span class="hljs-keyword">from</span> scrapy.exceptions <span class="hljs-keyword">import</span> DropItem<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpiderPipeline</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        self.file = <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;xxx.json&#x27;</span>,<span class="hljs-string">&#x27;w&#x27;</span>)<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">process_item</span>(<span class="hljs-params">self,item,spider</span>):</span><br>        <span class="hljs-keyword">if</span> item[<span class="hljs-string">&#x27;title&#x27;</span>]:<br>            line = json.dumps(<span class="hljs-built_in">dict</span>(item)) + <span class="hljs-string">&quot;\n&quot;</span><br>            self.file.write(line)<br>            <span class="hljs-keyword">return</span> item<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">raise</span> DropItem(<span class="hljs-string">&quot;没有找到标题&quot;</span>+title)<br></code></pre></td></tr></table></figure>
<p>之后在setting.py的ITEM_PIPELINES变了中进行激活</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">ITEM_PIPELINES</span> = &#123;<br>       <span class="hljs-string">&#x27;Spider.pipelines.spiderPipeline&#x27;</span>:300&#125;<br></code></pre></td></tr></table></figure>
<p>process_item()方法可以用来判断是来自于哪个爬虫，item是被爬取对象，spider是爬取该item的Spider<br>Dropitem是一个错误捕获<br>300是判断运行顺序，范围为0~1000</p>
<p>除此之外，Scrapy内置了一些简单的存储方式生成一个带有爬取数据的输出文件自带的类型有：</p>
<ul>
<li>JSON</li>
<li>JSON lines</li>
<li>CSV</li>
<li>XMl</li>
<li>Pickle</li>
<li>Marshal<br>食用方法：将命令行切换到项目目录，比如想保存为csv格式，输入命令：<br>$ scrapy crawl Spider -o papers.csv<br>就可以让Spider采集到的数据保存为papers.csv文件了</li>
</ul>
<h3 id="1-6运行"><a href="#1-6运行" class="headerlink" title="1.6运行"></a>1.6运行</h3><figure class="highlight elixir"><table><tr><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>scrapy crawl Spider<br></code></pre></td></tr></table></figure>
<p>就可以运行爬虫了，其中Spider就是我们定义的name<br>更过命令<a href="http://blog.csdn.net/inke88/article/details/60323856">这里</a></p>
<p>也可以在spider.py文件添加一下代码运行</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> __name ==<span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    process = CrawlerProcess(get_project_settings())<br>    process.crawl(<span class="hljs-string">&#x27;spider&#x27;</span>)<br>    process.start()<br></code></pre></td></tr></table></figure>
<h2 id="2-深入Scrapy"><a href="#2-深入Scrapy" class="headerlink" title="2.深入Scrapy"></a>2.深入Scrapy</h2><p>通过以上运行一个爬虫肯定会觉得还不如自己写代码来爬虫，但Scrapy框架还有很多厉害的地方</p>
<h3 id="2-1Spider"><a href="#2-1Spider" class="headerlink" title="2.1Spider"></a>2.1Spider</h3><h4 id="2-1-1Spider"><a href="#2-1-1Spider" class="headerlink" title="2.1.1Spider"></a>2.1.1Spider</h4><p>继承于Spider是最简单的spider，常用属性为：</p>
<ul>
<li>name<br>定义此爬虫名称的字符串。爬虫名称是爬虫如何由Scrapy定位（和实例化），因此它必须是唯一的。但是，没有什么能阻止你实例化同一个爬虫的多个实例。这是最重要的爬虫属性，它是必需的。</li>
<li>allowed_domains<br>允许此爬虫抓取的域的字符串的可选列表，指定一个列表可以抓取。</li>
<li>start_urls<br>当没有指定特定网址时，爬虫将开始抓取的网址列表。</li>
<li>custom_settings<br>运行此爬虫时将从项目宽配置覆盖的设置字典。<a href="http://scrapy.readthedocs.io/en/latest/topics/settings.html#topics-settings-ref">详情在这里</a></li>
<li>crawler<br>此属性from_crawler()在初始化类后由类方法设置，并链接Crawler到此爬虫实例绑定到的对象。<br>Crawlers在项目中封装了很多组件，用于单个条目访问（例如扩展，中间件，信号管理器等）</li>
<li>settings<br>运行此爬虫的配置。</li>
<li>logger<br>用Spider创建的Python记录器name。</li>
<li>start_requests（）<br>此方法必须返回一个可迭代对象，该方法只被调用一次。<br>主要用于在启动阶段需要post登录某个网站时才使用<br>示例代码：  <figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> scrapy<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Spider</span>(<span class="hljs-params">scrapy.Spider</span>):</span>                       <span class="hljs-comment">#创建的Spider是继承scrapy.Spider类</span><br>   	name = <span class="hljs-string">&quot;Spider&quot;</span>                                      <span class="hljs-comment">#爬虫的名称（必须是项目里面唯一的）</span><br>    allowed_domain = [<span class="hljs-string">&quot;xxx.com&quot;</span>]                <span class="hljs-comment">#允许的域名（就是这个爬虫爬取链接的范围）</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">start_requests</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> [scrapy.FromRequest(<span class="hljs-string">&quot;httP://www.xxx.com/login&quot;</span>,<br>                                                             formdata=&#123;<span class="hljs-string">&#x27;user&#x27;</span>:<span class="hljs-string">&#x27;xxx&#x27;</span>,<span class="hljs-string">&#x27;pass&#x27;</span>:<span class="hljs-string">&#x27;xxx&#x27;</span>&#125;,<br>                                                             callback=self.login)]<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">login</span>(<span class="hljs-params">self, response</span>):</span><br>    	<span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="2-1-2CrawlSpidel"><a href="#2-1-2CrawlSpidel" class="headerlink" title="2.1.2CrawlSpidel"></a>2.1.2CrawlSpidel</h4><p> CrawlCpider除了从Spider继承过来的属性外，还提供了一个新的属性rules，rules是一个包含一个或多个Rule对象的集合，每个Rule对爬取网站的动作定义了特定的规则。如果多个Rule匹配了相同的链接，则根据它们在rules属性中被定义的顺序，第一个会被使用。<br> Rule类的原型为：<br> <figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml">scrapy.contrib,spiders.<span class="hljs-constructor">Rule(<span class="hljs-params">link_extractor</span>,<span class="hljs-params">callback</span>=None,<span class="hljs-params">cb_kwargs</span>=None,<span class="hljs-params">follow</span>=None,<span class="hljs-params">process_links</span>=None, <span class="hljs-params">process_request</span>=None)</span><br></code></pre></td></tr></table></figure><br> 参数说明</p>
<blockquote>
<p>link_extractor 是一个LinkExtractor对象，定义了如何从爬取到的页面提取链接。<br>callback回调函数接受一个response作为一个参数，应避免使用parse作为回调函数<br>cb_kwargs包含传递给回调函数的参数的字典<br>follow是一个布尔值，指定了根据规则从respose提取的链接是否需要跟进<br>process_links是一个可调用的或一个字符串（在这种情况下，将使用具有该名称的爬虫对象的方法），将使用指定从每个响应提取的每个链接列表调用该方法link_extractor。这主要用于过滤目的。<br>process_request 是一个可调用的或一个字符串（在这种情况下，将使用具有该名称的爬虫对象的方法），它将被此规则提取的每个请求调用，并且必须返回一个请求或无（过滤出请求）</p>
</blockquote>
<p>link_extractor里面也大有乾坤，参数有：</p>
<blockquote>
<p>allow: 提取满足正则表达式的链接<br>deny: 排除正则表达式匹配的链接，优先级高于allow<br>allow_domains: 允许的域名，可以是str,list<br>deny_domains：排除的域名，同上<br>restrict_xpaths: 提取满足xpath选择条件的链接，可以是str,list<br>restrict_css: 提取满足css选择条件的链接，可以是str,list<br>tags: 提取指定标记下的链接，默认从a和area中提取，可以是str或list。<br>attrs: 提取满足拥有属性的链接，默认为href，类型为list<br>unique:链接是否去重，类型为boolean<br>process_value: 值处理函数（这个函数是对已经捕获的函数进行修补）<br>以上详细在<a href="http://scrapy-chs.readthedocs.io/zh_CN/latest/topics/link-extractors.html">这里</a><br>关于process_value可以看这两个函数示例（来自于stackoverflow）：</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> scrapy<br><span class="hljs-keyword">from</span> scrapy.contrib.spiders <span class="hljs-keyword">import</span> CrawlSpider, Rule<br><span class="hljs-keyword">from</span> scrapy.contrib.linkextractors <span class="hljs-keyword">import</span> LinkExtractor<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">dmozItem</span>(<span class="hljs-params">scrapy.Item</span>):</span><br>    basic_url = scrapy.Field()<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">dmozSpider</span>(<span class="hljs-params">CrawlSpider</span>):</span><br>    name = <span class="hljs-string">&quot;dmoz&quot;</span><br>    allowed_domains = [<span class="hljs-string">&quot;scrapy.org&quot;</span>]<br>    start_urls = [<br>        <span class="hljs-string">&quot;http://scrapy.org/&quot;</span>,<br>    ]<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">clean_url</span>(<span class="hljs-params">value</span>):</span><br>        <span class="hljs-keyword">return</span> value.replace(<span class="hljs-string">&#x27;/../&#x27;</span>, <span class="hljs-string">&#x27;/&#x27;</span>)<br><br>    rules = (<br>        Rule(<br>            LinkExtractor(<br>                allow=(<span class="hljs-string">&#x27;\S+/&#x27;</span>),<br>                restrict_xpaths=([<span class="hljs-string">&#x27;.//ul[@class=&quot;navigation&quot;]/a[1]&#x27;</span>,<br>                                  <span class="hljs-string">&#x27;.//ul[@class=&quot;navigation&quot;]/a[2]&#x27;</span>,<br>                                  <span class="hljs-string">&#x27;.//ul[@class=&quot;navigation&quot;]/a[3]&#x27;</span>,<br>                                  <span class="hljs-string">&#x27;.//ul[@class=&quot;navigation&quot;]/a[4]&#x27;</span>,<br>                                  <span class="hljs-string">&#x27;.//ul[@class=&quot;navigation&quot;]/a[5]&#x27;</span>]),<br>                process_value=clean_url<br>            ),<br>            callback=<span class="hljs-string">&#x27;first_level&#x27;</span>),<br>    )<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">first_level</span>(<span class="hljs-params">self, response</span>):</span><br>        taco = dmozItem()<br>        taco[<span class="hljs-string">&#x27;basic_url&#x27;</span>] = response.url<br>        <span class="hljs-keyword">return</span> taco<br></code></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">process_value</span>(<span class="hljs-params">value</span>):</span><br>    unique_id = re.search(<span class="hljs-string">r&quot;/item/(\d+)&quot;</span>, value).group(<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">if</span> unique_id <span class="hljs-keyword">in</span> already_crawled_site_ids:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>    <span class="hljs-keyword">return</span> value<br><br>rules = [Rule(SgmlLinkExtractor(allow=[<span class="hljs-string">&#x27;/item/\d+&#x27;</span>]), <span class="hljs-string">&#x27;parse_item&#x27;</span>, process_value=process_value)]<br></code></pre></td></tr></table></figure>

<h4 id="2-1-3-XMLFeedSpider"><a href="#2-1-3-XMLFeedSpider" class="headerlink" title="2.1.3 XMLFeedSpider"></a>2.1.3 XMLFeedSpider</h4><p>XMLFeedSpider设计用于通过以特定节点名称迭代XML订阅源来解析XML订阅源。迭代器可以选自：iternodes，xml和html。iternodes为了性能原因，建议使用迭代器，因为xml和迭代器html一次生成整个DOM为了解析它。但是，html当使用坏标记解析XML时，使用作为迭代器可能很有用。</p>
<p>要设置迭代器和标记名称，必须定义以下类属性：</p>
<ul>
<li><p>iterator<br>定义要使用的迭代器的字符串。它可以是：</p>
<ul>
<li>‘iternodes’ - 基于正则表达式的快速迭代器</li>
<li>‘html’- 使用的迭代器Selector。请记住，这使用DOM解析，并且必须加载所有DOM在内存中，这可能是一个大饲料的问题</li>
<li>‘xml’- 使用的迭代器Selector。请记住，这使用DOM解析，并且必须加载所有DOM在内存中，这可能是一个大饲料的问题<br>它默认为：’iternodes’。</li>
</ul>
</li>
<li><p>itertag<br>一个具有要迭代的节点（或元素）的名称的字符串。示例：<br>itertag = ‘product’</p>
</li>
<li><p>namespaces<br>定义该文档中将使用此爬虫处理的命名空间的元组列表。在 与将用于自动注册使用的命名空间 的方法。(prefix, uri)prefixuriregister_namespace()<br>示例代码：</p>
  <figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">YourSpider</span>(<span class="hljs-params">XMLFeedSpider</span>):</span><br><br>   	namespaces = [(<span class="hljs-string">&#x27;n&#x27;</span>, <span class="hljs-string">&#x27;http://www.sitemaps.org/schemas/sitemap/0.9&#x27;</span>)]<br>    itertag = <span class="hljs-string">&#x27;n:url&#x27;</span><br></code></pre></td></tr></table></figure></li>
<li><p>adapt_response(response)<br>一种在爬虫开始解析响应之前，在响应从爬虫中间件到达时立即接收的方法。它可以用于在解析之前修改响应主体。此方法接收响应并返回响应（它可以是相同的或另一个）。</p>
</li>
<li><p>parse_node(response, selector)<br>对于与提供的标记名称（itertag）匹配的节点，将调用此方法。接收Selector每个节点的响应和 。覆盖此方法是必需的。否则，你的爬虫将不工作。此方法必须返回一个Item对象，一个 Request对象或包含任何对象的迭代器。</p>
</li>
<li><p>process_results(response, results)<br>对于由爬虫返回的每个结果（Items or Requests），将调用此方法，并且它将在将结果返回到框架核心之前执行所需的任何最后处理，例如设置项目ID。它接收结果列表和产生那些结果的响应。它必须返回结果列表</p>
</li>
</ul>
<h3 id="2-2-Item-Loader"><a href="#2-2-Item-Loader" class="headerlink" title="2.2 Item Loader"></a>2.2 Item Loader</h3><p>Item Loader提供了一种便捷的方式填充抓取到的items。虽然items可以使用自带的类字典形式API填充，但是itemsLoader提供了更便捷的API可以分析原始数据并对item进行赋值。也就是Items提供保存捉取数据的容器，而Item Loader提供的是填充容器的机制，且可以方便的被拓展，重写不同字段的解析规则，这对大型的爬虫项目后期维护非常有利，拓展新的功能更加方便。<br>以下是Item和Item Loader的对比代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpiderItem</span>(<span class="hljs-params">scrapt.Item</span>):</span><br>    url = scrapy.Field()<br>    time = scrapy.Field()<br>    title = scrapy.Field()<br>    content = scrapy.Field()<br></code></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">parse</span>(<span class="hljs-params">self, response</span>):</span><br>    i = ItemLoader(item=Product(), response=response)<br>    l.add_xpath(<span class="hljs-string">&#x27;title&#x27;</span>, <span class="hljs-string">&#x27;//div[@class=&quot;title1&quot;]&#x27;</span>)<br>    l.add_xpath(<span class="hljs-string">&#x27;title&#x27;</span>, <span class="hljs-string">&#x27;//div[@class=&quot;title2&quot;]&#x27;</span>)<br>    l.add_xpath(<span class="hljs-string">&#x27;time&#x27;</span>, <span class="hljs-string">&#x27;//div[@class=&quot;time&quot;]&#x27;</span>)<br>    l.add_xpath(<span class="hljs-string">&#x27;content&#x27;</span>, <span class="hljs-string">&#x27;//div[@class=&quot;content&quot;]&#x27;</span>)<br>    <span class="hljs-keyword">return</span> l.load_item()<br></code></pre></td></tr></table></figure>
<p>可以发现的是ItemsLoader里面的name字段可以从页面中两个不同的XPAth位置提取，之后分配给name字段。下面类似操作后把所有数据收集起来，再使用l.load_item将数据实际填充到Item中</p>
<h4 id="2-2-1-输入与输出处理器"><a href="#2-2-1-输入与输出处理器" class="headerlink" title="2.2.1 输入与输出处理器"></a>2.2.1 输入与输出处理器</h4><p>Item Loder实现数据的收集处理和填充的功能都是通过输入与输出处理器来实现的，他们的功能是：</p>
<ul>
<li>Item Loder在每个字段中都包含了一个输入处理器和输出处理器</li>
<li>输入处理器收到response后时立刻通过add_xpath(),add_css()或者add_value()等方法提取数据，经过输入处理器的结果被手机起来并且保存在Item Loder内，</li>
<li>收集到所有的数据后，调用Item Loder.load_item()方法来填充并返回item对象。load_item()方法内部先调用输出处理器来处理收集到的数据，最后把结果存入Item中。</li>
</ul>
<p>下面是2个栗子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> scrapy.loader <span class="hljs-keyword">import</span> ItemLoader<br><span class="hljs-keyword">from</span> scrapy.loader.processors <span class="hljs-keyword">import</span> TakeFirst, MapCompose, Join<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProductLoader</span>(<span class="hljs-params">ItemLoader</span>):</span><br><br>    default_output_processor = TakeFirst()<br><br>    name_in = MapCompose(unicode.title)<br>    name_out = Join()<br><br>    price_in = MapCompose(unicode.strip)<br><br>    <span class="hljs-comment"># ...</span><br></code></pre></td></tr></table></figure>
<p>可以看到，输入处理器使用_in后缀声明，而输出处理器使用_out后缀声明。您还可以使用ItemLoader.default_input_processor和 ItemLoader.default_output_processor属性声明默认输入/输出 处理器。<br>输入和输出处理器可以在Item Loader定义中声明，这种方式声明输入处理器是很常见的。但是，还可以在item中声明：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> scrapy<br><span class="hljs-keyword">from</span> scrapy.loader.processors <span class="hljs-keyword">import</span> Join, MapCompose, TakeFirst<br><span class="hljs-keyword">from</span> w3lib.html <span class="hljs-keyword">import</span> remove_tags<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">filter_price</span>(<span class="hljs-params">value</span>):</span><br>    <span class="hljs-keyword">if</span> value.isdigit():<br>        <span class="hljs-keyword">return</span> value<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Product</span>(<span class="hljs-params">scrapy.Item</span>):</span><br>    name = scrapy.Field(<br>        input_processor=MapCompose(remove_tags),<br>        output_processor=Join(),<br>    )<br>    price = scrapy.Field(<br>        input_processor=MapCompose(remove_tags, filter_price),<br>        output_processor=TakeFirst(),<br>    )<br></code></pre></td></tr></table></figure>
<p>以上说了三种处理器声明方式：</p>
<ul>
<li>ItemLoader类中声明类似field_in和field_out的属性</li>
<li>itemd 的字段中声明</li>
<li> ItemLoader默认处理器ItemLoader.default_input_processor和 ItemLoader.default_output_processor<br>这三种方式响应优先级是从上到下依次递减</li>
</ul>
<h4 id="2-2-2-Item-Loader-Context"><a href="#2-2-2-Item-Loader-Context" class="headerlink" title="2.2.2 Item Loader Context"></a>2.2.2 Item Loader Context</h4><p>所有输入和输出处理器之间共享的任意键/值的dict。它可以在声明，实例化或使用Item Loader时传递。它们用于修改输入/输出处理器的行为。</p>
<p>例如，假设有一个parse_length接收文本值并从中提取长度的函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span>  <span class="hljs-title">parse_length</span> （<span class="hljs-title">text</span> ， <span class="hljs-title">loader_context</span> ）：</span><br>    unit  =  loader_context 。get （&#x27;unit&#x27; ， &#x27;m&#x27; ）<br>    ＃...长度解析代码在这里... <br>    <span class="hljs-keyword">return</span>  parsed_length<br></code></pre></td></tr></table></figure>
<p>通过接受一个loader_context参数，该函数显式地告诉Item Loader它能够接收一个Item Loader上下文，因此Item Loader在调用它时传递当前活动的上下文，因此处理器功能（parse_length在这种情况下）可以使用它们。<br>有几种方法可以修改Item Loader上下文值：</p>
<ul>
<li>通过修改当前活动的Item Loader上下文（context属性）：  <figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">loader = ItemLoader(product)<br>loader.context[<span class="hljs-string">&#x27;unit&#x27;</span>] = <span class="hljs-string">&#x27;cm&#x27;</span><br></code></pre></td></tr></table></figure></li>
<li>On Item Loader实例化（Item Loader构造函数的关键字参数存储在Item Loader上下文中）：  <figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">loader = ItemLoader(product, unit=<span class="hljs-string">&#x27;cm&#x27;</span>)<br></code></pre></td></tr></table></figure></li>
<li>On Item Loader声明，对于那些支持使用Item Loader上下文实例化的输入/输出处理器。MapCompose是其中之一：  <figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProductLoader</span>(<span class="hljs-params">ItemLoader</span>):</span><br>   	length_out = MapCompose(parse_length, unit=<span class="hljs-string">&#x27;cm&#x27;</span>)<br></code></pre></td></tr></table></figure>
<h4 id="2-2-3-重用和拓展-Item-Loader"><a href="#2-2-3-重用和拓展-Item-Loader" class="headerlink" title="2.2.3 重用和拓展 Item Loader"></a>2.2.3 重用和拓展 Item Loader</h4>随着你的项目越来越大，越来越多的爬虫，维护成为一个根本的问题，特别是当你必须处理每个爬虫的许多不同的解析规则，有很多异常，但也想重用公共处理器。</li>
</ul>
<p>项目加载器旨在减轻解析规则的维护负担，同时不会失去灵活性，同时提供了扩展和覆盖它们的方便的机制。因此，项目加载器支持传统的python类继承，以处理特定爬虫（或爬虫组）的差异。</p>
<p>例如，假设某个特定站点以三个短划线（例如）包含其产品名称，并且您不希望最终在最终产品名称中删除那些破折号。—Plasma TV—</p>
<p>以下是如何通过重用和扩展默认产品项目Loader（ProductLoader）来删除这些破折号：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> scrapy.loader.processors <span class="hljs-keyword">import</span> MapCompose<br><span class="hljs-keyword">from</span> myproject.ItemLoaders <span class="hljs-keyword">import</span> ProductLoader<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">strip_dashes</span>(<span class="hljs-params">x</span>):</span><br>    <span class="hljs-keyword">return</span> x.strip(<span class="hljs-string">&#x27;-&#x27;</span>)<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SiteSpecificLoader</span>(<span class="hljs-params">ProductLoader</span>):</span><br>    name_in = MapCompose(strip_dashes, ProductLoader.name_in)<br></code></pre></td></tr></table></figure>
<p>另一种扩展项目加载器可能非常有用的情况是，当您有多种源格式，例如XML和HTML。在XML版本中，您可能想要删除CDATA事件。下面是一个如何做的例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">from</span> scrapy.loader.processors <span class="hljs-keyword">import</span> MapCompose<br><span class="hljs-keyword">from</span> myproject.ItemLoaders <span class="hljs-keyword">import</span> ProductLoader<br><span class="hljs-keyword">from</span> myproject.utils.xml <span class="hljs-keyword">import</span> remove_cdata<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">XmlProductLoader</span>(<span class="hljs-params">ProductLoader</span>):</span><br>    name_in = MapCompose(remove_cdata, ProductLoader.name_in)<br></code></pre></td></tr></table></figure>
<p>对于输出处理器，更常用的方式是在item字段元数据里声明，因为通常它们依赖于具体的字段而不是网站</p>
<h4 id="2-2-4-内置的处理器"><a href="#2-2-4-内置的处理器" class="headerlink" title="2.2.4 内置的处理器"></a>2.2.4 内置的处理器</h4><p>除了可以使用可调用的函数作为输入输出处理器，Scrapy提供了一些常用的处理器，下面是一些内置的处理器</p>
<ul>
<li>Identity<br>类原型： class scrapy.loader.processors.Identity<br>最简单的处理器，不进行任何处理，直接返回原来的数据,无参数</li>
<li>TakeFirst<br>类原型： class scrapy.loader.processors.TakeFirst<br>从接收到的值中返回第一个非空值/非空值，因此它通常用作单值字段的输出处理器。它不接收任何构造函数参数，也不接受Loader上下文  <figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">    &gt;&gt;&gt; <span class="hljs-keyword">from</span> scrapy.loader.processors <span class="hljs-keyword">import</span> TakeFirst<br>    &gt;&gt;&gt; proc = TakeFirst()<br>    &gt;&gt;&gt; proc([<span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-string">&#x27;one&#x27;</span>, <span class="hljs-string">&#x27;two&#x27;</span>, <span class="hljs-string">&#x27;three&#x27;</span>])<br>    <span class="hljs-string">&#x27;one&#x27;</span><br>    ````<br>- Join<br>类原型： <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">scrapy</span>.<span class="hljs-title">loader</span>.<span class="hljs-title">processors</span>.<span class="hljs-title">Join</span>(<span class="hljs-params">separator=<span class="hljs-string">u&#x27;&#x27;</span></span>)</span><br><span class="hljs-class">返回用分隔符<span class="hljs-title">separatoe</span>连续后的值，分隔符<span class="hljs-title">seeparator</span>默认为空格。不接受<span class="hljs-title">Loader</span> <span class="hljs-title">contexts</span>。当使用默认分隔符的时候，这个处理器等同于<span class="hljs-title">Python</span>字符串对象中<span class="hljs-title">join</span>方法：&#x27;&#x27;.<span class="hljs-title">join</span></span><br></code></pre></td></tr></table></figure>
<blockquote>
<blockquote>
<blockquote>
<p>from scrapy.loader.processors import Join<br>proc = Join()<br>proc([‘one’, ‘two’, ‘three’])<br>  u’one two three’<br>proc = Join(‘<br>‘)<br>proc([‘one’, ‘two’, ‘three’])<br>  u’one<br>two<br>three’</p>
  <figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml">- Compose<br>类原型： <span class="hljs-keyword">class</span> scrapy.loader.processors.<span class="hljs-constructor">Compose(<span class="hljs-operator">*</span><span class="hljs-params">functions</span>,<span class="hljs-operator">**</span><span class="hljs-params">default_loader_context</span>)</span><br>由给定函数的组合构成的处理器。这意味着该处理器的每个输入值都被传递给第一个函数，并且该函数的结果被传递给第二个函数，依此类推，直到最后一个函数返回该处理器的输出值。<br>默认情况下，停止进程None值。可以通过传递关键字参数来更改此行为stop_on_none=False<br>    ```python<br>    &gt;&gt;&gt; from scrapy.loader.processors import Compose<br>    &gt;&gt;&gt; proc = <span class="hljs-constructor">Compose(<span class="hljs-params">lambda</span> <span class="hljs-params">v</span>: <span class="hljs-params">v</span>[0], <span class="hljs-params">str</span>.<span class="hljs-params">upper</span>)</span><br>    &gt;&gt;&gt; proc(<span class="hljs-literal">[&#x27;<span class="hljs-identifier">hello</span>&#x27;, &#x27;<span class="hljs-identifier">world</span>&#x27;]</span>)<br>    &#x27;HELLO&#x27;<br></code></pre></td></tr></table></figure></blockquote>
</blockquote>
</blockquote>
</li>
<li>MapCompose<br>类原型： class scrapy.loader.processors.MapCompose(*functions,**default_loader_context)<br>和Compose类似，也是用给定的多个方法的组合来构造处理器，不同的是内部结果在方法见传递的方式：<ul>
<li>该处理器的输入值被迭代，并且第一函数被应用于每个元素。这些函数调用的结果（每个元素一个）被连接以构造新的迭代，然后用于应用第二个函数，等等，直到最后一个函数被应用于收集的值列表的每个值远。最后一个函数的输出值被连接在一起以产生该处理器的输出。</li>
<li>每个特定函数可以返回值或值列表，这些值通过应用于其他输入值的相同函数返回的值列表展平。函数也可以返回None，在这种情况下，该函数的输出将被忽略，以便在链上进行进一步处理。</li>
<li>此处理器提供了一种方便的方法来组合只使用单个值（而不是iterables）的函数。由于这个原因， MapCompose处理器通常用作输入处理器，因为数据通常使用选择器的 extract()方法提取，选择器返回unicode字符串的列表。<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">filter_world</span>(<span class="hljs-params">x</span>):</span><br><span class="hljs-meta">... </span>    <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">if</span> x == <span class="hljs-string">&#x27;world&#x27;</span> <span class="hljs-keyword">else</span> x<br>...<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> scrapy.loader.processors <span class="hljs-keyword">import</span> MapCompose<br><span class="hljs-meta">&gt;&gt;&gt; </span>proc = MapCompose(filter_world, unicode.upper)<br><span class="hljs-meta">&gt;&gt;&gt; </span>proc([<span class="hljs-string">u&#x27;hello&#x27;</span>, <span class="hljs-string">u&#x27;world&#x27;</span>, <span class="hljs-string">u&#x27;this&#x27;</span>, <span class="hljs-string">u&#x27;is&#x27;</span>, <span class="hljs-string">u&#x27;scrapy&#x27;</span>])<br>[<span class="hljs-string">u&#x27;HELLO, u&#x27;</span>THIS<span class="hljs-string">&#x27;, u&#x27;</span>IS<span class="hljs-string">&#x27;, u&#x27;</span>SCRAPY<span class="hljs-string">&#x27;]</span><br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li>SelectJmes<br>类原型： class scrapy.loader.processors.SelectJmes(json_path)<br>使用提供给构造函数的json路径查询值，并返回输出。需要运行<a href="https://github.com/jmespath/jmespath.py">jmespath</a>。该处理器一次只需要一个输入。  <figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> scrapy.loader.processors <span class="hljs-keyword">import</span> SelectJmes, Compose, MapCompose<br><span class="hljs-meta">&gt;&gt;&gt; </span>proc = SelectJmes(<span class="hljs-string">&quot;foo&quot;</span>) <span class="hljs-comment">#for direct use on lists and dictionaries</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>proc(&#123;<span class="hljs-string">&#x27;foo&#x27;</span>: <span class="hljs-string">&#x27;bar&#x27;</span>&#125;)<br><span class="hljs-string">&#x27;bar&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>proc(&#123;<span class="hljs-string">&#x27;foo&#x27;</span>: &#123;<span class="hljs-string">&#x27;bar&#x27;</span>: <span class="hljs-string">&#x27;baz&#x27;</span>&#125;&#125;)<br>&#123;<span class="hljs-string">&#x27;bar&#x27;</span>: <span class="hljs-string">&#x27;baz&#x27;</span>&#125;<br></code></pre></td></tr></table></figure>
  和json一起使用  <figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> json<br><span class="hljs-meta">&gt;&gt;&gt; </span>proc_single_json_str = Compose(json.loads, SelectJmes(<span class="hljs-string">&quot;foo&quot;</span>))<br><span class="hljs-meta">&gt;&gt;&gt; </span>proc_single_json_str(<span class="hljs-string">&#x27;&#123;&quot;foo&quot;: &quot;bar&quot;&#125;&#x27;</span>)<br><span class="hljs-string">u&#x27;bar&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>proc_json_list = Compose(json.loads, MapCompose(SelectJmes(<span class="hljs-string">&#x27;foo&#x27;</span>)))<br><span class="hljs-meta">&gt;&gt;&gt; </span>proc_json_list(<span class="hljs-string">&#x27;[&#123;&quot;foo&quot;:&quot;bar&quot;&#125;, &#123;&quot;baz&quot;:&quot;tar&quot;&#125;]&#x27;</span>)<br>[<span class="hljs-string">u&#x27;bar&#x27;</span>]<br></code></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="2-3-Item-Pipeline"><a href="#2-3-Item-Pipeline" class="headerlink" title="2.3 Item Pipeline"></a>2.3 Item Pipeline</h3><p>前面已经说了Item Pipeline的基本用法了，现在看的是如何利用item Pipeline来进行数据存储</p>
<h4 id="2-3-1内置图片和文件下载"><a href="#2-3-1内置图片和文件下载" class="headerlink" title="2.3.1内置图片和文件下载"></a>2.3.1内置图片和文件下载</h4><p>item Pipeline提供了一些可以重用的Pipeline，其中有filesPipeline和imagesPipeline，他们都实现了以下特性：</p>
<ul>
<li>避免重新下载最近已经下载过的数据</li>
<li>指定存储的位置和方式</li>
</ul>
<p>此外，imagesPipeline还提供了二位的特性：</p>
<ul>
<li>将所有下载的图片转换成通用的格式（jpg）和模式（rgb）</li>
<li>粗略图生成</li>
<li>检测图像的宽/高，确保他们满足最小限制</li>
</ul>
<p>使用FIlesPipeline方法如下：<br>1）在setting.py的ITEM_PIPELINES中添加一条’scrapy.pipelines.files.FilesPipeline’:1<br>2）在item中添加两个字段，比如：<br>file_urls = scrapy.Field()<br>files = scrapy.Field()<br>3）在setting.py文件中添加下载路径，文件url所在的item字段，和文件结果信息所在item字段，比如：<br>FILES_STORE = ‘/HOME/XXX/SPIDER’<br>FILES_URLS_FIELD =’file_urls’<br>FILES_RESULT_FIELD = ‘files’<br>使用files_expires设置文件过期时间，示例如下：<br>FILES_EXPIRES = 30   #30天过期</p>
<p>使用ImagesPIpeline方法如下：<br>1）在setting.py的ITEM_PIPELINES中添加一条’scrapy.pipelines.images.ImagesPipeline’:1<br>2）在item中添加两个字段，比如：<br>image_urls = scrapy.Field()<br>images = scrapy.Field()<br>3 )在setting.py文件中添加下载路径，文件url所在的item字段，和文件结果信息所在item字段，比如：<br>IMAGES_STORE = ‘/HOME/XXX/SPIDER’<br>IMAGES_URLS_FIELD =’file_urls’<br>IMAGES_RESULT_FIELD = ‘files’<br>除此之外，使用IMAGES_THUMS制作缩略图，并这是缩略图尺寸大小，并使用IMAGES_EXPIRES设置文件过期时间，示例如下：<br>IMAGES_THUMBS = {<br>               ‘small’:(50, 50),<br>               ‘big’: (270,270),<br>}<br>IMAGES_EXPIRES = 30 #30天过期</p>
<p>除此之外，Item Pipeline还有三个方法非常常用</p>
<ul>
<li>open_spider(self, spider)<br>当spider被开启时，这个方法被调用</li>
<li>close_spider(self, spider)<br>当spider被关闭是，这个方法被调用</li>
<li>from_crawler(cls, crawler)<br>这个类方法从Crawles属性中创建一个pipeline实例，Crawle对象能够接触所有Scrapy的核心组件，比如setting</li>
</ul>
<p>以下是一个存储到MongoDB的示例代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pymongo<br><br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ZhihuspiderPipeline</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, mongo_url, mongo_db</span>):</span><br>        self.mongo_url = mongo_url<br>        self.mongo_db = mongo_db<br><br><span class="hljs-meta">    @classmethod</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">from_crawler</span>(<span class="hljs-params">cls, crawler</span>):</span><br>        <span class="hljs-keyword">return</span> cls(<br>            mongo_url=crawler.settings.get(<span class="hljs-string">&#x27;MONGO_URL&#x27;</span>),<br>            mongo_db=crawler.settings.get(<span class="hljs-string">&#x27;MONGO_DATABASE&#x27;</span>, <span class="hljs-string">&#x27;items&#x27;</span>)<br>        )<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">open_spider</span>(<span class="hljs-params">self, spider</span>):</span><br>        self.client = pymongo.MongoClient(self.mongo_url)<br>        self.db = self.client[self.mongo_db]<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">close_spider</span>(<span class="hljs-params">self, spider</span>):</span><br>        self.client.close()<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">process_item</span>(<span class="hljs-params">self, item, spider</span>):</span><br>    	self.db.UserInfo.insert(<span class="hljs-built_in">dict</span>(item))<br>    	<span class="hljs-keyword">return</span> item<br></code></pre></td></tr></table></figure>
<p>代码中首先通过from_crawler方法，获取setting中的MongoDB的URL和数据库名称，从而创建一个MongoPIpeline实例，在SPider开始运行是，在open_spider方法中建立数据库连接，当Spider关闭是，在close_spider方法中关闭数据库连接。<br>当是，这里配置的Pipeline会作用于所有的Spider，假如项目中有很多Spider在运行，处理起来就会很麻烦。所以通过process_item(self,item,spider)中的SPider参数判断是来自于哪个爬虫，不过还有更好的方法：<br>就是配置SPider类中的suctom_settings对象，为每一个Spider配置不同的pipeline</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MySpider</span>(<span class="hljs-params">CrawlSpider</span>):</span><br>    custom_settings = &#123;<br>        <span class="hljs-string">&#x27;ITEM_PIPELINES&#x27;</span>:&#123;<br>            <span class="hljs-string">&#x27;test.pipelines.TestPipeline.TestPipeline&#x27;</span>:<span class="hljs-number">1</span>,<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>

<h3 id="2-4-请求与响应"><a href="#2-4-请求与响应" class="headerlink" title="2.4 请求与响应"></a>2.4 请求与响应</h3><p>在编写Spider的模块中接触最紧密的是请求和响应。</p>
<h4 id="2-4-1Request对象"><a href="#2-4-1Request对象" class="headerlink" title="2.4.1Request对象"></a>2.4.1Request对象</h4><p>一个Request对象代表着一个HTTP请求，通常在Spider类中产生，然后传递给下载器，最后返回一个响应<br>类原型：class scrapy.http.Request(url[, callback, method=’GET’, headers, body, cookies, meta, encoding=’utf-8’, priority=0, dont_filter=False, errback])<br>构造参数说明：</p>
<ul>
<li>url（string） - 此请求的网址</li>
<li>callback（callable） - 将使用此请求的响应（一旦下载）作为其第一个参数调用的函数。如果请求没有指定回调，parse()将使用spider的 方法。请注意，如果在处理期间引发异常，则会调用errback。</li>
<li>method（string） - 此请求的HTTP方法。默认为’GET’。</li>
<li>meta（dict） - 属性的初始值Request.meta。如果给定，在此参数中传递的dict将被浅复制。</li>
<li>body（str或unicode） - 请求体。如果unicode传递了a，那么它被编码为 str使用传递的编码（默认为utf-8）。- 如果 body没有给出，则存储一个空字符串。不管这个参数的类型，存储的最终值将是一个str（不会是unicode或None）。</li>
<li>headers（dict） - 这个请求的头。dict值可以是字符串（对于单值标头）或列表（对于多值标头）。如果 None作为值传递，则不会发送HTTP头。</li>
<li>cookie（dict或list） - 请求cookie。这些可以以两种形式发送。</li>
<li>encoding（string） - 此请求的编码（默认为’utf-8’）。此编码将用于对URL进行百分比编码，并将正文转换为str（如果给定unicode）。</li>
<li>priority（int） - 此请求的优先级（默认为0）。调度器使用优先级来定义用于处理请求的顺序。具有较高优先级值的请求将较早执行。允许负值以指示相对低优先级。</li>
<li>dont_filter（boolean） - 表示此请求不应由调度程序过滤。当您想要多次执行相同的请求时忽略重复过滤器时使用。小心使用它，或者你会进入爬行循环。默认为False。</li>
<li>errback（callable） - 如果在处理请求时引发任何异常，将调用的函数。这包括失败的404 HTTP错误等页面。</li>
</ul>
<blockquote>
<p>cookies参数设置的两种方法<br>使用字典</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python">request_with_cookies = Request(url=<span class="hljs-string">&quot;http://www.example.com&quot;</span>,<br>                            cookies=&#123;<span class="hljs-string">&#x27;currency&#x27;</span>: <span class="hljs-string">&#x27;USD&#x27;</span>, <span class="hljs-string">&#x27;country&#x27;</span>: <span class="hljs-string">&#x27;UY&#x27;</span>&#125;)<br></code></pre></td></tr></table></figure>
<p>使用字典列表发送</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python">&gt;request_with_cookies = Request(url=<span class="hljs-string">&quot;http://www.example.com&quot;</span>,<br>                              cookies=[&#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;currency&#x27;</span>,<br>                                       <span class="hljs-string">&#x27;value&#x27;</span>: <span class="hljs-string">&#x27;USD&#x27;</span>,<br>                                       <span class="hljs-string">&#x27;domain&#x27;</span>: <span class="hljs-string">&#x27;example.com&#x27;</span>,<br>                                       <span class="hljs-string">&#x27;path&#x27;</span>: <span class="hljs-string">&#x27;/currency&#x27;</span>&#125;]) <br></code></pre></td></tr></table></figure>
<p>当某些网站返回Cookie（在响应中）时，这些Cookie会存储在该域的Cookie中，并在将来的请求中再次发送。这是任何常规网络浏览器的典型行为。但是，如果由于某种原因，想要避免与现有Cookie合并，可以设置Requ.meta中dont_merge_cookies字段的值。示例如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python">&gt;request_with_cookies = Request(url=<span class="hljs-string">&quot;http://www.example.com&quot;</span>,<br>                              cookies=&#123;<span class="hljs-string">&#x27;currency&#x27;</span>: <span class="hljs-string">&#x27;USD&#x27;</span>, <span class="hljs-string">&#x27;country&#x27;</span>: <span class="hljs-string">&#x27;UY&#x27;</span>&#125;,<br>                              meta=&#123;<span class="hljs-string">&#x27;dont_merge_cookies&#x27;</span>: <span class="hljs-literal">True</span>&#125;)<br></code></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>errback的使用方法示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">&gt;<span class="hljs-keyword">import</span> scrapy<br><br>&gt;<span class="hljs-keyword">from</span> scrapy.spidermiddlewares.httperror <span class="hljs-keyword">import</span> HttpError<br>&gt;<span class="hljs-keyword">from</span> twisted.internet.error <span class="hljs-keyword">import</span> DNSLookupError<br>&gt;<span class="hljs-keyword">from</span> twisted.internet.error <span class="hljs-keyword">import</span> TimeoutError, TCPTimedOutError<br><br>&gt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ErrbackSpider</span>(<span class="hljs-params">scrapy.Spider</span>):</span><br>   name = <span class="hljs-string">&quot;errback_example&quot;</span><br>   start_urls = [<br>       <span class="hljs-string">&quot;http://www.httpbin.org/&quot;</span>,              <span class="hljs-comment"># HTTP 200 expected</span><br>       <span class="hljs-string">&quot;http://www.httpbin.org/status/404&quot;</span>,    <span class="hljs-comment"># Not found error</span><br>       <span class="hljs-string">&quot;http://www.httpbin.org/status/500&quot;</span>,    <span class="hljs-comment"># server issue</span><br>       <span class="hljs-string">&quot;http://www.httpbin.org:12345/&quot;</span>,        <span class="hljs-comment"># non-responding host, timeout expected</span><br>       <span class="hljs-string">&quot;http://www.httphttpbinbin.org/&quot;</span>,       <span class="hljs-comment"># DNS error expected</span><br>   ]<br><br>   <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">start_requests</span>(<span class="hljs-params">self</span>):</span><br>       <span class="hljs-keyword">for</span> u <span class="hljs-keyword">in</span> self.start_urls:<br>           <span class="hljs-keyword">yield</span> scrapy.Request(u, callback=self.parse_httpbin,<br>                                   errback=self.errback_httpbin,<br>                                   dont_filter=<span class="hljs-literal">True</span>)<br><br>   <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">parse_httpbin</span>(<span class="hljs-params">self, response</span>):</span><br>       self.logger.info(<span class="hljs-string">&#x27;Got successful response from &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(response.url))<br>       <span class="hljs-comment"># do something useful here...</span><br><br>   <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">errback_httpbin</span>(<span class="hljs-params">self, failure</span>):</span><br>       <span class="hljs-comment"># log all failures</span><br>       self.logger.error(<span class="hljs-built_in">repr</span>(failure))<br><br>       <span class="hljs-comment"># in case you want to do something special for some errors,</span><br>       <span class="hljs-comment"># you may need the failure&#x27;s type:</span><br><br>       <span class="hljs-keyword">if</span> failure.check(HttpError):<br>           <span class="hljs-comment"># these exceptions come from HttpError spider middleware</span><br>           <span class="hljs-comment"># you can get the non-200 response</span><br>           response = failure.value.response<br>           self.logger.error(<span class="hljs-string">&#x27;HttpError on %s&#x27;</span>, response.url)<br><br>       <span class="hljs-keyword">elif</span> failure.check(DNSLookupError):<br>           <span class="hljs-comment"># this is the original request</span><br>           request = failure.request<br>           self.logger.error(<span class="hljs-string">&#x27;DNSLookupError on %s&#x27;</span>, request.url)<br><br>       <span class="hljs-keyword">elif</span> failure.check(TimeoutError, TCPTimedOutError):<br>           request = failure.request<br>           self.logger.error(<span class="hljs-string">&#x27;TimeoutError on %s&#x27;</span>, request.url)<br></code></pre></td></tr></table></figure>
</blockquote>
<p>下面写的是Request的子类 FormRquest类，专门用来处理html表单，尤其对隐藏表单的处理非常方便，适合用来完成登录操作<br>类原型：class scrapy.http.FormRequest(url[, formdata, …])<br>其中构造参数formdata可以是字典，也可以是可迭代的（key,value）元祖，代表着需要提交的表单数据。<br>示例如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">return</span> [FormRequest(url=<span class="hljs-string">&quot;http://www.example.com/post/action&quot;</span>,<br>                    formdata=&#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;John Doe&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-string">&#x27;27&#x27;</span>&#125;,<br>                    callback=self.after_post)]<br></code></pre></td></tr></table></figure>
<p>通常网站通过<input type="hidden">实现对某些表单字段的预填充，就像知乎的隐藏表单的_xfv数值，Scray在FromRequest类提供了一个类方法from_reponse来解决隐藏表单这个问题。方法原型如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">classmethod</span> from_response(response[, formname=<span class="hljs-literal">None</span>, formid=<span class="hljs-literal">None</span>, formnumber=<span class="hljs-number">0</span>, formdata=<span class="hljs-literal">None</span>, formxpath=<span class="hljs-literal">None</span>, formcss=<span class="hljs-literal">None</span>, clickdata=<span class="hljs-literal">None</span>, dont_click=<span class="hljs-literal">False</span>, ...])<br></code></pre></td></tr></table></figure>
<p>参数说明：</p>
<ul>
<li>response（Responseobject） - 包含将用于预填充表单字段的HTML表单的响应</li>
<li>formname（string） - 如果给定，将使用name属性设置为此值的形式。</li>
<li>formid（string） - 如果给定，将使用id属性设置为此值的形式。</li>
<li>formxpath（string） - 如果给定，将使用匹配xpath的第一个表单。</li>
<li>formcss（string） - 如果给定，将使用匹配css选择器的第一个形式。</li>
<li>formnumber（integer） - 当响应包含多个表单时要使用的表单的数量。第一个（也是默认）是0。</li>
<li>formdata（dict） - 要在表单数据中覆盖的字段。如果响应元素中已存在字段，则其值将被在此参数中传递的值覆盖。</li>
<li>clickdata（dict） - 查找控件被点击的属性。如果没有提供，表单数据将被提交，模拟第一个可点击元素的点击。除了html属性，控件可以通过其相对于表单中其他提交表输入的基于零的索引，通过nr属性来标识。</li>
<li>dont_click（boolean） - 如果为True，表单数据将在不点击任何元素的情况下提交。</li>
</ul>
<p>下面是一个实现登录功能的示例代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> scrapy<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginSpider</span>(<span class="hljs-params">scrapy.Spider</span>):</span><br>    name = <span class="hljs-string">&#x27;example.com&#x27;</span><br>    start_urls = [<span class="hljs-string">&#x27;http://www.example.com/users/login.php&#x27;</span>]<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">parse</span>(<span class="hljs-params">self, response</span>):</span><br>        <span class="hljs-keyword">return</span> scrapy.FormRequest.from_response(<br>            response,<br>            formdata=&#123;<span class="hljs-string">&#x27;username&#x27;</span>: <span class="hljs-string">&#x27;john&#x27;</span>, <span class="hljs-string">&#x27;password&#x27;</span>: <span class="hljs-string">&#x27;secret&#x27;</span>&#125;,<br>            callback=self.after_login<br>        )<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">after_login</span>(<span class="hljs-params">self, response</span>):</span><br>        <span class="hljs-comment"># check login succeed before going on</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;authentication failed&quot;</span> <span class="hljs-keyword">in</span> response.body:<br>            self.logger.error(<span class="hljs-string">&quot;Login failed&quot;</span>)<br>            <span class="hljs-keyword">return</span><br></code></pre></td></tr></table></figure>

<h4 id="2-4-2-Response对象"><a href="#2-4-2-Response对象" class="headerlink" title="2.4.2 Response对象"></a>2.4.2 Response对象</h4><p>Response对象代表着HTTP响应，Response通常是从下载器获取然后交给Spider处理：<br>类原型：class scrapy.http.Response(url[, status=200, headers=None, body=b’’, flags=None, request=None])<br>构造参数说明：</p>
<ul>
<li>url（string） - 此响应的URL</li>
<li>status（integer） - 响应的HTTP状态。默认为200。</li>
<li>headers（dict） - 这个响应的头。dict值可以是字符串（对于单值标头）或列表（对于多值标头）。</li>
<li>body（str） - 响应体。它必须是str，而不是unicode，除非你使用一个编码感知响应子类，如 TextResponse。</li>
<li>flags（list） - 是一个包含属性初始值的 Response.flags列表。如果给定，列表将被浅复制。</li>
<li>request（Requestobject） - 属性的初始值Response.request。这代表Request生成此响应。</li>
<li>meta(dict)：用来初始化Response.meta</li>
</ul>
<p>关于参数的其他补充：</p>
<ul>
<li>request<br>Request生成此响应的对象。在响应和请求通过所有下载中间件后，此属性在Scrapy引擎中分配。特别地，这意味着：<br>HTTP重定向将导致将原始请求（重定向之前的URL）分配给重定向响应（重定向后具有最终URL）。<br>Response.request.url并不总是等于Response.url<br>此属性仅在爬虫程序代码和 Spider Middleware中可用，但不能在Downloader Middleware中使用（尽管您有通过其他方式可用的请求）和处理程序response_downloaded。</li>
<li>meta<br>的快捷方式Request.meta的属性 Response.request对象（即self.request.meta）。<br>与Response.request属性不同，Response.meta 属性沿重定向和重试传播，因此您将获得Request.meta从您的爬虫发送的原始属性。<br>也可以看看<br>Request.meta 属性</li>
<li>flags<br>包含此响应的标志的列表。标志是用于标记响应的标签。例如：’cached’，’redirected ‘等等。它们显示在Response（_ str_ 方法）的字符串表示上，它被引擎用于日志记录。</li>
<li>copy（）<br>返回一个新的响应，它是此响应的副本。</li>
<li>replace（[ url，status，headers，body，request，flags，cls ] ）<br>返回具有相同成员的Response对象，但通过指定的任何关键字参数赋予新值的成员除外。该属性Response.meta是默认复制。</li>
<li>urljoin（url ）<br>通过将响应url与可能的相对URL 组合构造绝对url。<br>这是一个包装在urlparse.urljoin，它只是一个别名，使这个调用：<br>urlparse.urljoin(response.url, url)</li>
</ul>
<p>同样的，Response有一个子类TextResponse,多了一个智能编码的功能。<br>类原型：class scrapy.http.TextResponse(url[, encoding[, …]])<br>构造参数encoding是一个包含编码的字符串，如果使用一个unicode编码的body构造出TextResponse实例，那body属性会使用encoding进行编码。<br>TextResponse类除了具有Response属性，还拥有自己的属性：</p>
<ul>
<li>encoding：包含编码的字符串。编码的优先级由高到低如下所示：<br>1）首先选用构造器中传入的encoding<br>2）选用http头中Content-Type字段的编码。如果编码无效，则被忽略，继续尝试下面的规则<br>3）选用响应body中的编码<br>4）最后猜测响应的编码，这种方式是比较脆弱</li>
<li>selector:以当前响应为目标的选择器实例。<br>TextResponse类除了支持Response中的方法，还支持以下方法response</li>
<li>body_as_unicode():返回unicode编码的响应body内容。等价于：<br>response.body.decode(response.encoding)</li>
<li>xpath(query):等价于TextResponse.selector.xpath(query).示例如下：<br>response.xpath(‘//p’)</li>
<li>css(query):等价于TextResponse.selector.css(query).示例如下：<br>response.css(‘//p’)</li>
</ul>
<h3 id="2-5下载器中间件"><a href="#2-5下载器中间件" class="headerlink" title="2.5下载器中间件"></a>2.5下载器中间件</h3><p>下载器中间件是介于Scrapy的request/response处理的钩子框架，是用于全局修改Scrapy的request和response，可以帮助我们定制自己的爬虫系统<br>激活哦下载器中间件的方法如下<br>在setting.py里面的DOWNLOADER_MIDDLEWARES修改，示例如下：<br>DOWNLOADER_MIDDLEWARES = {<br>            ‘myproject.middlewares.CustomDownloaderMiddleware’: 543,<br>            }<br>后面数值的设置要看自己的需求，越接近0越靠近引擎，越接近1000越靠近下载器，数字设置一般看自己需要先用到哪些中间件，就把数字设定得比哪个中间件大<br>中间件组建定义了以下python类，可以根据这些类来编写自己的中间件</p>
<ul>
<li>process_request(request,spider)</li>
<li>process_response(request,response,spider)</li>
<li>process_exception(request,exception,spider)</li>
</ul>
<h4 id="2-5-1process-request-request-spider"><a href="#2-5-1process-request-request-spider" class="headerlink" title="2.5.1process_request(request,spider)"></a>2.5.1process_request(request,spider)</h4><p>当每个request通过下载中间件时，该方法被调用，返回值必须为none，response对象，request对象中的一个或raise IgnoreRequest异常<br>参数说明：<br>Request：处理的request<br>Spider：该Request对应的Spider<br>返回值：如果返回None,Scrapy将继续处理该Request，执行其他中间件的相应方法，直到合适的下载器处理函数被调用，该Request被执行（其Response下载）<br>如果返回Response对象，SCrapy不会调用下面2个方法，或相应的下载方法，将返回该response。已安装的中间件的process_response()方法则会在每个respon返回时被调用<br>如果返回request对象，Scrapy则停止调用process_request方法并重新调度放回的Request。当新返回的Request被执行后，相应地中间件链将会根据下载的Response被调用<br>如果是Raise IgnoreRequest异常，则安装的下载中间件的process_exception()方法会被调用。如果没有任何一个方法处理该异常，则Request的errback方法会被调用。如果没有代码处理抛出的异常，则该异常被忽略且不记录</p>
<h4 id="2-5-2process-request-request-response-spider"><a href="#2-5-2process-request-request-response-spider" class="headerlink" title="2.5.2process_request(request,response,spider)"></a>2.5.2process_request(request,response,spider)</h4><p>该方法主要用来处理产生的Response返回值必须为none，response对象，request对象中的一个或raise IgnoreRequest异常<br>参数说明：<br>Request：处理的request<br>response:处理的response<br>Spider：该Request对应的Spider<br>返回值：<br>如果返回Response对象，可以与传入的respon相同，也可以是新的对象，该Response会被链中的其他中间见的process_reponse()方法处理<br>如果返回request对象，Scrapy则停止调用process_request方法并重新调度放回的Request。当新返回的Request被执行后，相应地中间件链将会根据下载的Response被调用<br>如果是Raise IgnoreRequest异常，则安装的下载中间件的process_exception()方法会被调用。如果没有任何一个方法处理该异常，则Request的errback方法会被调用。如果没有代码处理抛出的异常，则该异常被忽略且不记录</p>
<h4 id="2-5-3process-request-request-exceptionmspider"><a href="#2-5-3process-request-request-exceptionmspider" class="headerlink" title="2.5.3process_request(request,exceptionmspider)"></a>2.5.3process_request(request,exceptionmspider)</h4><p>当下载处理器或process_request()抛出异常，比如IgnoreRequest异常时，Scrapy调用process_exception().process_exception()应该返回none，response对象，request对象中的一个<br>参数说明：<br>Request：处理的request<br>exception:抛出的异常<br>Spider：该Request对应的Spider<br>返回值：<br>如果返回None,Scrapy将会继续处理该异常，接着调用已安装的其他中间件的process_exception()方法，知道所有中间件都被调用完毕，则调用默认的异常处理<br>如果返回response对象，则已安装的中间级链的process_response()方法被调用。Scrapy将不会调用任何其他中间件的process_exception()方法<br>如果返回Request对象，则返回的request将会被重新调用下载，这将停止中间级的process_exception()方法执行，类似于返回respon对象的处理</p>
<p>下面是自定义下载器中间件的两个栗子：</p>
<blockquote>
<p>设置User-Agent字段，需要自己在setting,py中设置User-Agent列表</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RandomUserAgent</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self,agents</span>):</span><br>        self.agents =agents<br>        <br><span class="hljs-meta">	@classmethod</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">from_crawler</span>(<span class="hljs-params">cls,crawler</span>):</span><br>        <span class="hljs-keyword">return</span> cls(crawler.settings.getlist(<span class="hljs-string">&#x27;USER_AGENTS&#x27;</span>))<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">process_request</span>(<span class="hljs-params">self,request,spider</span>):</span><br>        request.headers.setdefault(<span class="hljs-string">&#x27;User-Agent&#x27;</span>, random.choice(self.agents))<br></code></pre></td></tr></table></figure>

<blockquote>
<p>动态设置request代理ip,需要自己在setting,py中设置IPlist列表</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RandomProxy</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self,iplist</span>):</span><br>        self.iplist=iplist<br><br><span class="hljs-meta">    @classmethod</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">from_crawler</span>(<span class="hljs-params">cls,crawler</span>):</span><br>        <span class="hljs-keyword">return</span> cls(crawler.settings.getlist(<span class="hljs-string">&#x27;IPLIST&#x27;</span>))<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">process_request</span>(<span class="hljs-params">self, request, spider</span>):</span><br>        proxy = random.choice(self.iplist)<br>        request.meta[<span class="hljs-string">&#x27;proxy&#x27;</span>] =proxy<br></code></pre></td></tr></table></figure>
<h3 id="2-6Spider中间件"><a href="#2-6Spider中间件" class="headerlink" title="2.6Spider中间件"></a>2.6Spider中间件</h3><p>这个看官方文档就好了 ——<a href="http://scrapy-chs.readthedocs.io/zh_CN/0.24/topics/spider-middleware.html">这里</a></p>
<h2 id="3-部署"><a href="#3-部署" class="headerlink" title="3.部署"></a>3.部署</h2><p>这里都是编写完爬虫代码后的其他一些应用，不完全属于部署</p>
<h3 id="3-1分布式下载器-Crawlea"><a href="#3-1分布式下载器-Crawlea" class="headerlink" title="3.1分布式下载器:Crawlea"></a>3.1分布式下载器:Crawlea</h3><p>官方提供了一个分布式下载器，用来帮助我们躲避反爬虫的措施。首先在官网注册。之后拿到APIKEY用作验证<br>不过是需要钱的<br>官网：<a href="https://app.scrapinghub.com/account/login/?next=/next=/account/login">https://app.scrapinghub.com/account/login/?next=/next=/account/login</a><br>安装：pip install scrapy-crawlera<br>之后修改setting.py<br>DOWNLOADER_MIDDLEWARES ={‘scrapy_crawlera.CrawleraMiddleware’:300}<br>CRAWLERA_ENABLED = True<br>CRAWLERA_APIKEY = ‘<API key>‘</p>
<h3 id="3-2Scrapyd"><a href="#3-2Scrapyd" class="headerlink" title="3.2Scrapyd"></a>3.2Scrapyd</h3><p>是的。官方又提供了一个部署爬虫非常有用的工具，Scrapyd是运行Scrapy爬虫的服务程序，它吃屎以http命令方式通过json api进行发布、删除、启动、停止爬虫程序的操作，而且它可以同时管理多个爬虫，每个爬虫还可以有多个版本，也是部署分布式爬虫有效手段<br>安装：pipi install scrapyd<br>使用：输入scrapyd启动，在浏览器输入：<a href="http://127.0.0.1:6800/%E5%B0%B1%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B0%E7%95%8C%E9%9D%A2%E4%BA%86">http://127.0.0.1:6800/就可以看到界面了</a><br>API使用示例如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># -*- coding: utf-8 -*-</span><br><br><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">import</span> json <br><br>baseUrl =<span class="hljs-string">&#x27;http://127.0.0.1:6800/&#x27;</span><br>daemUrl =<span class="hljs-string">&#x27;http://127.0.0.1:6800/daemonstatus.json&#x27;</span><br>listproUrl =<span class="hljs-string">&#x27;http://127.0.0.1:6800/listprojects.json&#x27;</span><br>listspdUrl =<span class="hljs-string">&#x27;http://127.0.0.1:6800/listspiders.json?project=%s&#x27;</span><br>listspdvUrl= <span class="hljs-string">&#x27;http://127.0.0.1:6800/listversions.json?project=%s&#x27;</span><br>listjobUrl =<span class="hljs-string">&#x27;http://127.0.0.1:6800/listjobs.json?project=%s&#x27;</span><br>delspdvUrl= <span class="hljs-string">&#x27;http://127.0.0.1:6800/delversion.json&#x27;</span><br><br><span class="hljs-comment">#http://127.0.0.1:6800/daemonstatus.json</span><br><span class="hljs-comment">#查看scrapyd服务器运行状态</span><br>r= requests.get(daemUrl)<br><span class="hljs-built_in">print</span> <span class="hljs-string">&#x27;1.stats :\n %s \n\n&#x27;</span>  %r.text  <br><br><span class="hljs-comment">#http://127.0.0.1:6800/listprojects.json</span><br><span class="hljs-comment">#获取scrapyd服务器上已经发布的工程列表</span><br>r= requests.get(listproUrl)<br><span class="hljs-built_in">print</span> <span class="hljs-string">&#x27;1.1.listprojects : [%s]\n\n&#x27;</span>  %r.text<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(json.loads(r.text)[<span class="hljs-string">&quot;projects&quot;</span>])&gt;<span class="hljs-number">0</span> :<br>    project = json.loads(r.text)[<span class="hljs-string">&quot;projects&quot;</span>][<span class="hljs-number">0</span>]<br><br><span class="hljs-comment">#http://127.0.0.1:6800/listspiders.json?project=myproject</span><br><span class="hljs-comment">#获取scrapyd服务器上名为myproject的工程下的爬虫清单</span><br>listspd=listspd % project<br>r= requests.get(listspdUrl)<br><span class="hljs-built_in">print</span> <span class="hljs-string">&#x27;2.listspiders : [%s]\n\n&#x27;</span>  %r.text <br><span class="hljs-keyword">if</span> json.loads(r.text).has_key(<span class="hljs-string">&quot;spiders&quot;</span>)&gt;<span class="hljs-number">0</span> :<br>    spider =json.loads(r.text)[<span class="hljs-string">&quot;spiders&quot;</span>][<span class="hljs-number">0</span>]<br><br><br><span class="hljs-comment">#http://127.0.0.1:6800/listversions.json?project=myproject</span><br><span class="hljs-comment">##获取scrapyd服务器上名为myproject的工程下的各爬虫的版本</span><br>listspdvUrl=listspdvUrl % project<br>r = requests.get(listspdvUrl)<br><span class="hljs-built_in">print</span> <span class="hljs-string">&#x27;3.listversions : [%s]\n\n&#x27;</span>  %rtext <br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(json.loads(r.text)[<span class="hljs-string">&quot;versions&quot;</span>])&gt;<span class="hljs-number">0</span> :<br>    version = json.loads(r.text)[<span class="hljs-string">&quot;versions&quot;</span>][<span class="hljs-number">0</span>]<br><br><span class="hljs-comment">#http://127.0.0.1:6800/listjobs.json?project=myproject</span><br><span class="hljs-comment">#获取scrapyd服务器上的所有任务清单，包括已结束，正在运行的，准备启动的。</span><br>listjobUrl=listjobUrl % proName<br>r=requests.get(listjobUrl)<br><span class="hljs-built_in">print</span> <span class="hljs-string">&#x27;4.listjobs : [%s]\n\n&#x27;</span>  %r.text <br><br><br><span class="hljs-comment">#schedule.json</span><br><span class="hljs-comment">#http://127.0.0.1:6800/schedule.json -d project=myproject -d spider=myspider</span><br><span class="hljs-comment">#启动scrapyd服务器上myproject工程下的myspider爬虫，使myspider立刻开始运行，注意必须以post方式</span><br>schUrl = baseurl + <span class="hljs-string">&#x27;schedule.json&#x27;</span><br>dictdata =&#123; <span class="hljs-string">&quot;project&quot;</span>:project,<span class="hljs-string">&quot;spider&quot;</span>:spider&#125;<br>r= reqeusts.post(schUrl, json= dictdata)<br><span class="hljs-built_in">print</span> <span class="hljs-string">&#x27;5.1.delversion : [%s]\n\n&#x27;</span>  %r.text <br><br><br><span class="hljs-comment">#http://127.0.0.1:6800/delversion.json -d project=myproject -d version=r99&#x27;</span><br><span class="hljs-comment">#删除scrapyd服务器上myproject的工程下的版本名为version的爬虫，注意必须以post方式</span><br>delverUrl = baseurl + <span class="hljs-string">&#x27;delversion.json&#x27;</span><br>dictdata=&#123;<span class="hljs-string">&quot;project&quot;</span>:project ,<span class="hljs-string">&quot;version&quot;</span>: version &#125;<br>r= reqeusts.post(delverUrl, json= dictdata)<br><span class="hljs-built_in">print</span> <span class="hljs-string">&#x27;6.1.delversion : [%s]\n\n&#x27;</span>  %r.text <br><br><span class="hljs-comment">#http://127.0.0.1:6800/delproject.json -d project=myproject</span><br><span class="hljs-comment">#删除scrapyd服务器上myproject工程，注意该命令会自动删除该工程下所有的spider，注意必须以post方式</span><br>delProUrl = baseurl + <span class="hljs-string">&#x27;delproject.json&#x27;</span><br>dictdata=&#123;<span class="hljs-string">&quot;project&quot;</span>:project  &#125;<br>r= reqeusts.post(delverUrl, json= dictdata)<br><span class="hljs-built_in">print</span> <span class="hljs-string">&#x27;6.2.delproject : [%s]\n\n&#x27;</span>  %r.text <br></code></pre></td></tr></table></figure>

<h3 id="3-3Scrapyd-client"><a href="#3-3Scrapyd-client" class="headerlink" title="3.3Scrapyd-client"></a>3.3Scrapyd-client</h3><p>懒得截图访问<a href="http://www.cnblogs.com/space007/p/5886177.html">这里</a>查看</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>学习笔记</tag>
        <tag>scrapy</tag>
      </tags>
  </entry>
  <entry>
    <title>vim命令</title>
    <url>/2017/08/17/11-vim/</url>
    <content><![CDATA[<p>vim常用命令</p>
<span id="more"></span>

<h2 id="vim命令"><a href="#vim命令" class="headerlink" title="vim命令"></a>vim命令</h2><h3 id="1-vim模式"><a href="#1-vim模式" class="headerlink" title="1.vim模式"></a>1.vim模式</h3><p>以下介绍内容来自维基百科Vim</p>
<p>从vi演生出来的Vim具有多种模式，这种独特的设计容易使初学者产生混淆。几乎所有的编辑器都会有插入和执行命令两种模式，并且大多数的编辑器使用了与Vim截然不同的方式：命令目录（鼠标或者键盘驱动），组合键（通常通过control键（CTRL）和alt键（ALT）组成）或者鼠标输入。Vim和vi一样，仅仅通过键盘来在这些模式之中切换。这就使得Vim可以不用进行菜单或者鼠标操作，并且最小化组合键的操作。对文字录入员或者程序员可以大大增强速度和效率。</p>
<p>Vim具有6种基本模式和5种派生模式，我们这里只简单介绍下6种基本模式：</p>
<ul>
<li><p>普通模式(Normal mode)<br>在普通模式中，用的编辑器命令，比如移动光标，删除文本等等。这也是Vim启动后的默认模式。这正好和许多新用户期待的操作方式相反（大多数编辑器默认模式为插入模式）。<br>Vim强大的编辑能来自于其普通模式命令。普通模式命令往往需要一个操作符结尾。例如普通模式命令dd删除当前行，但是第一个”d”的后面可以跟另外的移动命令来代替第二个d，比如用移动到下一行的”j”键就可以删除当前行和下一行。另外还可以指定命令重复次数，2dd（重复dd两次），和dj的效果是一样的。用户学习了各种各样的文本间移动／跳转的命令和其他的普通模式的编辑命令，并且能够灵活组合使用的话，能够比那些没有模式的编辑器更加高效的进行文本编辑。<br>在普通模式中，有很多方法可以进入插入模式。比较普通的方式是按a（append／追加）键或者i（insert／插入）键。</p>
</li>
<li><p>插入模式(Insert mode)<br>在这个模式中，大多数按键都会向文本缓冲中插入文本。大多数新用户希望文本编辑器编辑过程中一直保持这个模式。<br>在插入模式中，可以按ESC键回到普通模式。</p>
</li>
<li><p>可视模式(Visual mode)<br>这个模式与普通模式比较相似。但是移动命令会扩大高亮的文本区域。高亮区域可以是字符、行或者是一块文本。当执行一个非移动命令时，命令会被执行到这块高亮的区域上。Vim的”文本对象”也能和移动命令一样用在这个模式中。</p>
</li>
<li><p>选择模式(Select mode)<br>这个模式和无模式编辑器的行为比较相似（Windows标准文本控件的方式）。这个模式中，可以用鼠标或者光标键高亮选择文本，不过输入任何字符的话，Vim会用这个字符替换选择的高亮文本块，并且自动进入插入模式。</p>
</li>
<li><p>命令行模式(Command line mode)<br>在命令行模式中可以输入会被解释成并执行的文本。例如执行命令（:键），搜索（/和?键）或者过滤命令（!键）。在命令执行之后，Vim返回到命令行模式之前的模式，通常是普通模式。</p>
</li>
<li><p>Ex模式(Ex mode)<br>这和命令行模式比较相似，在使用:visual命令离开Ex模式前，可以一次执行多条命令。</p>
</li>
</ul>
<p>这其中我们常用到就是普通模式、插入模式和命令行模式。vim启动进入普通模式，处于插入模式或命令行模式时只需要按Esc或者Ctrl+[(这在vim课程环境中不管用)即可进入普通模式。普通模式中按i（插入）或a（附加）键都可以进入插入模式，普通模式中按:进入命令行模式。命令行模式中输入wq回车后保存并退出vim。</p>
<h3 id="2-普通模式按键说明"><a href="#2-普通模式按键说明" class="headerlink" title="2.普通模式按键说明"></a>2.普通模式按键说明</h3><p>1.移动光标</p>
<table>
<thead>
<tr>
<th>按键</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>h</td>
<td>左</td>
</tr>
<tr>
<td>l</td>
<td>右</td>
</tr>
<tr>
<td>j</td>
<td>下</td>
</tr>
<tr>
<td>k</td>
<td>上</td>
</tr>
<tr>
<td>w</td>
<td>移动到下一个单词</td>
</tr>
<tr>
<td>b</td>
<td>移动到上一个单词</td>
</tr>
</tbody></table>
<p>2.进入插入模式</p>
<table>
<thead>
<tr>
<th>按键</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>i</td>
<td>在当前光标除进行编辑</td>
</tr>
<tr>
<td>I(大写)</td>
<td>在行首插入</td>
</tr>
<tr>
<td>A</td>
<td>在行末插入</td>
</tr>
<tr>
<td>a</td>
<td>在光标后插入编辑</td>
</tr>
<tr>
<td>o</td>
<td>在当前行后插入一个新行</td>
</tr>
<tr>
<td>O(大写)</td>
<td>在当前行前插入一个新行</td>
</tr>
<tr>
<td>cw</td>
<td>替换从光标所在位置后到一个单词结尾的字符</td>
</tr>
</tbody></table>
<p>3.删除文本信息</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>x</td>
<td>删除游标所在的字符</td>
</tr>
<tr>
<td>X（大写）</td>
<td>删除游标所在前一个字符</td>
</tr>
<tr>
<td>Delete</td>
<td>同x（小写）</td>
</tr>
<tr>
<td>dd</td>
<td>删除整行</td>
</tr>
<tr>
<td>dw</td>
<td>删除一个单词（不可用于中文）</td>
</tr>
<tr>
<td>d$或D</td>
<td>删除至行尾</td>
</tr>
<tr>
<td>d^</td>
<td>删除至行首</td>
</tr>
<tr>
<td>dG</td>
<td>删除到文档结尾处</td>
</tr>
<tr>
<td>d1G</td>
<td></td>
</tr>
<tr>
<td>ndd</td>
<td>删除n行</td>
</tr>
</tbody></table>
<p>4.重复命令<br>输入.可以重复上一次的操作<br>还有10x可以删除10个怜恤字符<br>3dd删除3行<br>daw删除一个单词<br>dnw（n为数字）删除n个单词</p>
<p>4.行间跳转</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>nG,n shift+g</td>
<td>游标移动到第n行</td>
</tr>
<tr>
<td>gg</td>
<td>游标移动到第一行</td>
</tr>
<tr>
<td>G,Shift+g</td>
<td>游标移动到最后一行</td>
</tr>
</tbody></table>
<p>5.行内跳转</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>w</td>
<td>到下一个单词的开头</td>
</tr>
<tr>
<td>e</td>
<td>到下一个单词的结尾</td>
</tr>
<tr>
<td>b</td>
<td>到前一个单词的开头</td>
</tr>
<tr>
<td>ge</td>
<td>到前一个单词的结尾</td>
</tr>
<tr>
<td>0或^</td>
<td>到行头</td>
</tr>
<tr>
<td>$</td>
<td>到行尾</td>
</tr>
<tr>
<td>f&lt;字母&gt;</td>
<td>向后搜索&lt;字母&gt;并跳转到第一个匹配的位置（非常实用）</td>
</tr>
<tr>
<td>F&lt;字母&gt;</td>
<td>向前搜索&lt;字母&gt;并跳转到第一个匹配的位置</td>
</tr>
<tr>
<td>T&lt;字母&gt;</td>
<td>向后搜索&lt;字母&gt;并跳转到第一个匹配位置之前的一个字母（不常用）</td>
</tr>
<tr>
<td>t&lt;字母&gt;</td>
<td></td>
</tr>
</tbody></table>
<p>6.复制粘贴</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>3yy</td>
<td>复制游标所在的下3行</td>
</tr>
<tr>
<td>yy</td>
<td>复制游标所在的整行</td>
</tr>
<tr>
<td>y^</td>
<td>复制到行首，不行光标所在处字符（y0也可以）</td>
</tr>
<tr>
<td>y$</td>
<td>复制到行尾，包含光标所在处的字符</td>
</tr>
<tr>
<td>yw</td>
<td>复制一个单词</td>
</tr>
<tr>
<td>y2w</td>
<td>复制2个</td>
</tr>
<tr>
<td>yG</td>
<td>复制到文本末</td>
</tr>
<tr>
<td>y1G</td>
<td>复制到文本开头</td>
</tr>
<tr>
<td>p(小写)</td>
<td>粘贴在光标后或者下</td>
</tr>
<tr>
<td>p(大写)</td>
<td>粘贴在光标前或者上</td>
</tr>
</tbody></table>
<p>ps:dd其实为剪切，每次dd后都可以用p来粘贴</p>
<p>7.替换和撤销</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>r&lt;待替换字母&gt;</td>
<td>将游标所在字母替换为指定字母</td>
</tr>
<tr>
<td>R</td>
<td>怜恤替换，直到按下Esc</td>
</tr>
<tr>
<td>cc</td>
<td>替换整行</td>
</tr>
<tr>
<td>cw</td>
<td>替换一个单词</td>
</tr>
<tr>
<td>C(大写)</td>
<td>替换游标以后到行末</td>
</tr>
<tr>
<td>~</td>
<td>反转游标所在字母大小写</td>
</tr>
<tr>
<td>u{n}</td>
<td>撤销一个或n次操作</td>
</tr>
<tr>
<td>U(大写)</td>
<td>撤销当前行的所有修改</td>
</tr>
<tr>
<td>Ctrl+r</td>
<td>撤销undo的操作</td>
</tr>
</tbody></table>
<p>其他：<br>输入&gt;&gt;整行向有缩进，&lt;&lt;整行向左回退。在命令模式下对shiftwidh进行设置可以达到控制字符数目的<br>普通模式下输入/然后键入需要查找的字符串 按回车后就会进行查找。<br>？与/功能相同，只不过？是向上而/是向下查找。<br>进入查找之后，输入n和N可以继续查找<br>n表示继续查找，N反向查找</p>
<figure class="highlight taggerscript"><table><tr><td class="code"><pre><code class="hljs taggerscript">普通模式下输入<span class="hljs-symbol">\*</span>寻找游标所在处的单词<br>普通模式下输入<span class="hljs-symbol">\#</span>同上，但 <span class="hljs-symbol">\#</span> 是向前（上）找，<span class="hljs-symbol">\*</span>则是向后（下）找<br>普通模式下输入g<span class="hljs-symbol">\*</span>同<span class="hljs-symbol">\*</span> ，但部分符合该单词即可<br>普通模式下输入g<span class="hljs-symbol">\#</span>同<span class="hljs-symbol">\#</span> ，但部分符合该单词即可<br></code></pre></td></tr></table></figure>
<h3 id="3-命令模式快捷命令"><a href="#3-命令模式快捷命令" class="headerlink" title="3.命令模式快捷命令"></a>3.命令模式快捷命令</h3><p>1.退出vim</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>:q!</td>
<td>强制退出，不保存</td>
</tr>
<tr>
<td>:q</td>
<td>退出</td>
</tr>
<tr>
<td>:wq!</td>
<td>强制保存并退出</td>
</tr>
<tr>
<td>:w&lt;文件路径&gt;</td>
<td>另存为</td>
</tr>
<tr>
<td>:saveas 文件路径</td>
<td>另存为</td>
</tr>
<tr>
<td>:x</td>
<td>保存并退出</td>
</tr>
<tr>
<td>:wq</td>
<td></td>
</tr>
</tbody></table>
<p>2.显示行号</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><code class="hljs vim">:<span class="hljs-keyword">set</span> <span class="hljs-keyword">nu</span><br></code></pre></td></tr></table></figure>

<p>3.控制缩进和回退字符数</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros">:<span class="hljs-builtin-name">set</span> <span class="hljs-attribute">shiftwidth</span>=10<br></code></pre></td></tr></table></figure>

<p>4.调整文本位置</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><code class="hljs elixir"><span class="hljs-symbol">:ce</span>    <span class="hljs-comment">#居中</span><br><span class="hljs-symbol">:ri</span>     <span class="hljs-comment">#靠右</span><br><span class="hljs-symbol">:le</span>    <span class="hljs-comment">#靠左</span><br></code></pre></td></tr></table></figure>

<h3 id="4-其他"><a href="#4-其他" class="headerlink" title="4.其他"></a>4.其他</h3><p>命令摘取自实验楼的vim编辑器模块教程,墨迹功能<a href="https://www.shiyanlou.com/courses/2/labs/19/document">戳这里</a><br>如何搭配vim呢，<a href="https://www.zhihu.com/question/19655689">见这里（python部分）</a></p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>命令</tag>
      </tags>
  </entry>
  <entry>
    <title>Django入门的笔记</title>
    <url>/2017/08/17/10-Django-learn/</url>
    <content><![CDATA[<p>python文档入门的笔记，也就是创建一个投票应用那个，后面的文档就只看，没记了</p>
<span id="more"></span>

<h1 id="Django学习笔记"><a href="#Django学习笔记" class="headerlink" title="Django学习笔记"></a>Django学习笔记</h1><h2 id="1-前期准备"><a href="#1-前期准备" class="headerlink" title="1. 前期准备"></a>1. 前期准备</h2><ul>
<li>使用虚拟环境Virtualenv<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> pip install Virtualenv    <span class="hljs-comment">#安装Virtualenv</span></span><br><span class="hljs-meta">#</span><span class="bash">在要运行Django的目录创建 虚拟环境</span><br><span class="hljs-meta">   $</span><span class="bash"> virtualenv  djangoproject_env      <span class="hljs-comment">#运行后在当前目录生成djangoproject_env</span></span><br><span class="hljs-meta">   $</span><span class="bash"> <span class="hljs-built_in">source</span> djangoproject_env/bin/activate   <span class="hljs-comment">#启动虚拟环境</span></span><br><span class="hljs-meta">$</span><span class="bash"> django-admin startproject testproject    <span class="hljs-comment">#创建Django工程</span></span><br><span class="hljs-meta">$</span><span class="bash"> python manage.py runserver  <span class="hljs-comment">#进行测试</span></span><br><span class="hljs-meta">$</span><span class="bash"> python manage.py startapp testapp <span class="hljs-comment">#创建Django应用</span></span><br></code></pre></td></tr></table></figure>
Django 默认的语言是英语，所以显示给我们的欢迎页面是英文的。我们在 Django 的配置文件里稍作修改，让它支持中文。用任何一个文本编辑器打开 settings.py 文件，找到如下的两行代码：<figure class="highlight vala"><table><tr><td class="code"><pre><code class="hljs vala">blogproject/blogproject/settings.py<br><br><span class="hljs-meta">## 其它配置代码...</span><br><br>LANGUAGE_CODE = <span class="hljs-string">&#x27;en-us&#x27;</span><br>TIME_ZONE = <span class="hljs-string">&#x27;UTC&#x27;</span><br><br><span class="hljs-meta">## 其它配置代码...</span><br></code></pre></td></tr></table></figure>
把 LANGUAGE_CODE 的值改为 zh-hans，TIME_ZONE 的值改为 Asia/Shanghai：<figure class="highlight vala"><table><tr><td class="code"><pre><code class="hljs vala">blogproject/blogproject/settings.py<br><br><span class="hljs-meta">## 其它配置代码...</span><br><br><span class="hljs-meta"># 把英文改为中文</span><br>LANGUAGE_CODE = <span class="hljs-string">&#x27;zh-hans&#x27;</span><br><br><span class="hljs-meta"># 把国际时区改为中国时区</span><br>TIME_ZONE = <span class="hljs-string">&#x27;Asia/Shanghai&#x27;</span><br><br><span class="hljs-meta">## 其它配置代码...</span><br></code></pre></td></tr></table></figure>
寻找一个学习文章，英文有点渣，我就找中文的，英文看不懂的就切中文看<br><a href="http://python.usyiyi.cn/translate/django_182/index.html">中文文档</a>  <a href="https://docs.djangoproject.com/en/1.11/">原版英本文档</a></li>
</ul>
<h2 id="2-笔记（按目录分）"><a href="#2-笔记（按目录分）" class="headerlink" title="2.笔记（按目录分）"></a>2.笔记（按目录分）</h2><h3 id="1-编写你的第一个Django应用，第1部分"><a href="#1-编写你的第一个Django应用，第1部分" class="headerlink" title="1.编写你的第一个Django应用，第1部分"></a>1.编写你的第一个Django应用，第1部分</h3><p>运行django-admin startproject mysite后会生成如下文件夹或文件</p>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">mysite</span>/<br>    <span class="hljs-selector-tag">manage</span><span class="hljs-selector-class">.py</span><br>    <span class="hljs-selector-tag">mysite</span>/<br>        __<span class="hljs-selector-tag">init__</span><span class="hljs-selector-class">.py</span><br>        <span class="hljs-selector-tag">settings</span><span class="hljs-selector-class">.py</span><br>        <span class="hljs-selector-tag">urls</span><span class="hljs-selector-class">.py</span><br>        <span class="hljs-selector-tag">wsgi</span><span class="hljs-selector-class">.py</span><br></code></pre></td></tr></table></figure>
<ul>
<li>外层的mysite/根目录仅仅是项目的一个容器。它的命名对Django无关紧要；</li>
<li>manage.py：一个命令行工具，可以使你用多种方式对Django项目进行交互。</li>
<li>内层的mysite/目录是你的项目的真正的Python包。它是你导入任何东西时将需要使用的Python包的名字（例如 mysite.urls）。</li>
<li>mysite/<strong>init</strong>.py：一个空文件，它告诉Python这个目录应该被看做一个Python包。</li>
<li>mysite/settings.py：该Django 项目的设置/配置。</li>
<li>mysite/urls.py：该Django项目的URL声明；你的Django站点的“目录”。</li>
<li>mysite/wsgi.py：用于你的项目的与WSGI兼容的Web服务器入口。</li>
</ul>
<blockquote>
<p>项目 vs. 应用<br>项目和应用之间有什么不同？ 应用是一个Web应用程序，它完成具体的事项 —— 比如一个博客系统、一个存储公共档案的数据库或者一个简单的投票应用。 项目是一个特定网站中相关配置和应用的集合。一个项目可以包含多个应用。一个应用可以运用到多个项目中去。<br>如上面所创建的mysite就是一个项目</p>
</blockquote>
<p>运行： python manage.py startapp polls<br>生成如下结构：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">polls</span>/<br>    __<span class="hljs-selector-tag">init__</span><span class="hljs-selector-class">.py</span><br>    <span class="hljs-selector-tag">admin</span><span class="hljs-selector-class">.py</span><br>    <span class="hljs-selector-tag">migrations</span>/<br>        __<span class="hljs-selector-tag">init__</span><span class="hljs-selector-class">.py</span><br>    <span class="hljs-selector-tag">models</span><span class="hljs-selector-class">.py</span><br>    <span class="hljs-selector-tag">tests</span><span class="hljs-selector-class">.py</span><br>    <span class="hljs-selector-tag">views</span><span class="hljs-selector-class">.py</span><br></code></pre></td></tr></table></figure>
<p>这样的结构就是我们的polls应用，这个应用可以放在任何python path里</p>
<p>总结：实现模型变更的步骤</p>
<ul>
<li>修改你的模型（在models.py文件中）。 </li>
<li>激活模型<br> 编辑mysite/settings.py文件，并修改INSTALLED_APPS设置以包含字符串’polls’<br> 现在Django知道要包含polls应用。 让我们运行另外一个命令：$ python manage.py makemigrations polls</li>
<li>运行python manage.py makemigrations ，为这些修改创建迁移文件</li>
<li>运行python manage.py migrate ，将这些改变更新到数据库中。</li>
</ul>
<h3 id="2-编写你的第一个Django应用，第2部分"><a href="#2-编写你的第一个Django应用，第2部分" class="headerlink" title="2.编写你的第一个Django应用，第2部分"></a>2.编写你的第一个Django应用，第2部分</h3><p>创建一个管理员用户¶</p>
<blockquote>
<p>首先，我们需要创建一个能够登录管理站点的用户。 运行如下命令：<br>$ python manage.py createsuperuser<br>键入你想要使用的用户名，然后按下回车键：<br>Username: admin<br>然后提示你输入想要使用的邮件地址：<br>Email address: <a href="mailto:&#x61;&#x64;&#109;&#x69;&#x6e;&#64;&#x65;&#x78;&#x61;&#x6d;&#x70;&#108;&#101;&#x2e;&#x63;&#111;&#109;">&#x61;&#x64;&#109;&#x69;&#x6e;&#64;&#x65;&#x78;&#x61;&#x6d;&#x70;&#108;&#101;&#x2e;&#x63;&#111;&#109;</a><br>你需要输入两次密码，第二次输入是确认密码<br>Password:<br>Password (again):<br>Superuser created successfully.</p>
</blockquote>
<p>其中，django会自动检测密码，密码跟邮箱或者用户名太像也不会通过。。。</p>
<p>在polls/admin.py中，代码示例如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.contrib <span class="hljs-keyword">import</span> admin<br><br><span class="hljs-keyword">from</span> .models <span class="hljs-keyword">import</span> Choice, Question<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChoiceInline</span>(<span class="hljs-params">admin.StackedInline</span>):</span>   <span class="hljs-comment">#若是使用：admin.TabularInline则选项是紧凑型</span><br>    model = Choice            <br>    extra = <span class="hljs-number">3</span>        <span class="hljs-comment">#默认3个选项，可以自己增加，但最小为3个可以填写</span><br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">QuestionAdmin</span>(<span class="hljs-params">admin.ModelAdmin</span>):</span><br>    fields = [<span class="hljs-string">&#x27;pub_date&#x27;</span>, <span class="hljs-string">&#x27;question_text&#x27;</span>]    <span class="hljs-comment">#再同一个框</span><br>    fieldsets = [                                      <span class="hljs-comment">#非同一个框，且可以用classed方法来操作这个框</span><br>        (<span class="hljs-literal">None</span>,               &#123;<span class="hljs-string">&#x27;fields&#x27;</span>: [<span class="hljs-string">&#x27;question_text&#x27;</span>]&#125;),<br>        (<span class="hljs-string">&#x27;Date information&#x27;</span>, &#123;<span class="hljs-string">&#x27;fields&#x27;</span>: [<span class="hljs-string">&#x27;pub_date&#x27;</span>], <span class="hljs-string">&#x27;classes&#x27;</span>: [<span class="hljs-string">&#x27;collapse&#x27;</span>]&#125;),<br>    ]<br>    inlines = [ChoiceInline]            <span class="hljs-comment">#在创建Question对象的同时可以直接添加一组Choice将会更好</span><br>   list_display = (<span class="hljs-string">&#x27;question_text&#x27;</span>, <span class="hljs-string">&#x27;pub_date&#x27;</span>, <span class="hljs-string">&#x27;was_published_recently&#x27;</span>)    <span class="hljs-comment">#表可以分类显示</span><br>   list_filter = [<span class="hljs-string">&#x27;pub_date&#x27;</span>]    <span class="hljs-comment">#右边增加一个选项栏可以来操作</span><br>   <br>admin.site.register(Question, QuestionAdmin)                 <span class="hljs-comment">#注册question到QuestionAdmin</span><br></code></pre></td></tr></table></figure>

<h3 id="3-编写你的第一个Django应用，第3部分"><a href="#3-编写你的第一个Django应用，第3部分" class="headerlink" title="3.编写你的第一个Django应用，第3部分"></a>3.编写你的第一个Django应用，第3部分</h3><ul>
<li>创建视图<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#polls/views.py</span><br><span class="hljs-keyword">from</span> django.http <span class="hljs-keyword">import</span> HttpResponse<br></code></pre></td></tr></table></figure>


</li>
</ul>
<pre><code>def index(request):
    return HttpResponse(&quot;Hello, world. You&#39;re at the polls index.&quot;)
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">这就是一个视图，然而我们需要将这个视图映射到URL上 —— 利用一个URLconf。<br>要在polls目录中创建一个URLconf，创建一个名为urls.py的文件<br>```python<br><span class="hljs-comment">#polls/urls.py</span><br><span class="hljs-keyword">from</span> django.conf.urls <span class="hljs-keyword">import</span> url<br><br><span class="hljs-keyword">from</span> . <span class="hljs-keyword">import</span> views<br><br>urlpatterns = [<br>url(<span class="hljs-string">r&#x27;^$&#x27;</span>, views.index, name=<span class="hljs-string">&#x27;index&#x27;</span>),<br>    ]<br></code></pre></td></tr></table></figure>
下一步，让主URLconf可以链接到polls.urls模块。在mysite/urls.py中插入一个include()：
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#mysite/urls.py</span><br><span class="hljs-keyword">from</span> django.conf.urls <span class="hljs-keyword">import</span> include, url<br><span class="hljs-keyword">from</span> django.contrib <span class="hljs-keyword">import</span> admin<br><br>urlpatterns = [<br>    url(<span class="hljs-string">r&#x27;^polls/&#x27;</span>, include(<span class="hljs-string">&#x27;polls.urls&#x27;</span>)),<br>    url(<span class="hljs-string">r&#x27;^admin/&#x27;</span>, include(admin.site.urls)),<br>]<br></code></pre></td></tr></table></figure>
这样处理后就能在输入对应网址时跳转到对应的视图（[关于URL的更多参数][3]）
</code></pre>
<ul>
<li><p>模板编辑<br>模板应该位于 polls/templates/polls/index.html。由于app_directories 模板加载器按照上面描述的方式工作，在Django中你可以简单地用polls/index.html引用这个模板,不这样做Python会引用到别的模板。<br>因为django将选择它找到的名字匹配的第一个模板文件，如果你在不同 的应用有相同名字的模板文件，Django将不能区分它们。我们需要将Django指向正确的模板，最简单的方式是使用命名空间。具体实现方式是，将这些模板文件放在以应用的名字来命名的另一个目录下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-comment">#polls/views.py</span><br><span class="hljs-keyword">from</span> django.http <span class="hljs-keyword">import</span> HttpResponse<br><span class="hljs-keyword">from</span> django.template <span class="hljs-keyword">import</span> RequestContext, loader<br><br><span class="hljs-keyword">from</span> .models <span class="hljs-keyword">import</span> Question<br></code></pre></td></tr></table></figure>


</li>
</ul>
<pre><code>def index(request):
    latest_question_list = Question.objects.order_by(&#39;-pub_date&#39;)[:5]
    template = loader.get_template(&#39;polls/index.html&#39;)
    context = RequestContext(request, &#123;
        &#39;latest_question_list&#39;: latest_question_list,
    &#125;)
    return HttpResponse(template.render(context))
<figure class="highlight gradle"><table><tr><td class="code"><pre><code class="hljs gradle"><br>在这个栗子中，中文版的原文已经做了如下阐述：<br>&gt; 以上的代码载入polls<span class="hljs-regexp">/index.html模板，并传给它一个context。Context是一个字典，将模板变量的名字映射到Python 对象。将你的浏览器指向“/</span>polls/”来加载这个页面，你应该看到一个列表，包含来自教程<span class="hljs-number">1</span>中<span class="hljs-string">&quot;What&#x27;s up&quot;</span> Question。其链接指向Question的detail页面。<br>然而还是遇到了这个错误提示：<br></code></pre></td></tr></table></figure>
TypeError: context must be a dict rather than RequestContext.
<figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">    https:<span class="hljs-regexp">//</span>stackoverflow.com<span class="hljs-regexp">/questions/</span><span class="hljs-number">43787700</span>/django-<span class="hljs-number">1</span>-<span class="hljs-number">11</span>-typeerror-context-must-be-a-dict-rather-than-context<br>也说了是Django1.<span class="hljs-number">8</span>+后更改的问题<br>但是<span class="hljs-number">1.11</span>版教程是这样的：<br></code></pre></td></tr></table></figure>
from django.http import HttpResponse
from django.template import loader

from .models import Question


def index(request):
    latest_question_list = Question.objects.order_by(&#39;-pub_date&#39;)[:5]
    template = loader.get_template(&#39;polls/index.html&#39;)
    context = &#123;
        &#39;latest_question_list&#39;: latest_question_list,
    &#125;
    return HttpResponse(template.render(context, request))
```
也就是，改为字典传入就好了，至于为什么，等学完看源代码再说了～
</code></pre>
<ul>
<li>快捷方式以及404<a href="http://python.usyiyi.cn/documents/django_182/intro/tutorial03.html#a-shortcut-render">跳转查看</a></li>
</ul>
<h3 id="4-编写你的第一个Django应用，第4，5-6部分"><a href="#4-编写你的第一个Django应用，第4，5-6部分" class="headerlink" title="4.编写你的第一个Django应用，第4，5,6部分"></a>4.编写你的第一个Django应用，第4，5,6部分</h3><p>看后觉得有点不知所以然- -，好像也没什么重地，笔记略过</p>
<p>之后就开始撸文档了。。。。Django的文档好多啊    :(</p>
<p>这是一张在网上找的图～<br><img    class="lazyload" data-original="https://github.com/so1n/so1n_blog_photo/blob/master/blog_photo/1005320-20161029114328812-2116791249.png?raw=true" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">enter description here</span></p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>微博爬虫-发布微博以及获取微博资料</title>
    <url>/2017/08/12/9_spider_by_weibo/</url>
    <content><![CDATA[<p>简单的爬一下微博以及发微博</p>
<span id="more"></span>
<h2 id="微博爬虫-发布微博以及获取微博资料"><a href="#微博爬虫-发布微博以及获取微博资料" class="headerlink" title="微博爬虫-发布微博以及获取微博资料"></a>微博爬虫-发布微博以及获取微博资料</h2><h3 id="1-发布微博"><a href="#1-发布微博" class="headerlink" title="1.发布微博"></a>1.发布微博</h3><p>首先要解决登录问题（为了减少限制我们使用移动版本登录），这里我采用cookie来登录<br><img    class="lazyload" data-original="https://github.com/so1n/so1n_blog_photo/blob/master/blog_photo/%E7%99%BB%E5%BD%95.png?raw=true" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">enter description here</span><br><img    class="lazyload" data-original="https://github.com/so1n/so1n_blog_photo/blob/master/blog_photo/cookie.png?raw=true" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">enter description here</span><br>如图，登录后获得cookie ，<br>先发布一个微博查看需要传输什么值<br><img    class="lazyload" data-original="https://github.com/so1n/so1n_blog_photo/blob/master/blog_photo/%E6%9F%A5%E7%9C%8B%E5%8F%91%E9%80%81%E5%BE%AE%E5%8D%9A%E9%9C%80%E8%A6%81%E5%A1%AB%E5%86%99%E4%BB%80%E4%B9%88.png?raw=true" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">enter description here</span><br>图中可以看出，我们需要2个值，一个为st一个为content，且content已知值为我们要发送的微博<br>发送微博的url在图片里面可以看出是：<a href="https://m.weibo.cn/api/statuses/update">https://m.weibo.cn/api/statuses/update</a><br><img    class="lazyload" data-original="https://github.com/so1n/so1n_blog_photo/blob/master/blog_photo/%E6%89%BE%E5%87%BAst%E7%9A%84%E5%80%BC.png?raw=true" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">enter description here</span><br>接着我们从这个网页里面找到st值生成的地方，找到后我们就可以开始写发送微博的代码了</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> re<br><span class="hljs-keyword">import</span> requests<br><br><br>headers = &#123;<span class="hljs-string">&#x27;User-Agent&#x27;</span>: <span class="hljs-string">&#x27;Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Mobile Safari/537.36&#x27;</span>&#125;<br>cookie = &#123;<span class="hljs-string">&quot;Cookie&quot;</span>: <span class="hljs-string">&quot;你的cookie&quot;</span>&#125;<br>url = <span class="hljs-string">&#x27;https://m.weibo.cn/compose&#x27;</span><br>html = requests.get(url, cookies=cookie).text<br>pattern = <span class="hljs-string">r&#x27;st:(.+)&#x27;</span><br>st = re.findall(pattern, html)[<span class="hljs-number">0</span>].replace(<span class="hljs-string">&quot;&#x27;&quot;</span>,<span class="hljs-string">&#x27;&#x27;</span>).replace(<span class="hljs-string">&#x27;,&#x27;</span>,<span class="hljs-string">&#x27;&#x27;</span>).replace(<span class="hljs-string">&#x27; &#x27;</span>,<span class="hljs-string">&#x27;&#x27;</span>)<br>post_url = <span class="hljs-string">&#x27;https://m.weibo.cn/api/statuses/update&#x27;</span><br>postdata = &#123;<br>            <span class="hljs-string">&#x27;st&#x27;</span>:st,<br>            <span class="hljs-string">&#x27;content&#x27;</span>:<span class="hljs-string">&#x27;测试Python发微博!&#x27;</span>,<br>            &#125;<br>update = requests.post(post_url, data=postdata, headers=headers, cookies=cookie)<br></code></pre></td></tr></table></figure>
<p>在这里我用正则找出来，不过加了‘’就找不到了，所以只能粗略找出来再把不要的替换掉，接着就可以传入postdata进行发微博了<br>结果如图：<br><img    class="lazyload" data-original="https://github.com/so1n/so1n_blog_photo/blob/master/blog_photo/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_%E9%80%89%E6%8B%A9%E5%8C%BA%E5%9F%9F_20170815141038.png?raw=true" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">enter description here</span></p>
<h3 id="2-爬取评论"><a href="#2-爬取评论" class="headerlink" title="2.爬取评论"></a>2.爬取评论</h3><p>其实这个是我爬取一半遇到个坑，然后百度后找到的教程- -。。。<br>先贴上链接<a href="http://www.jianshu.com/p/cc72f42ee0cb">这里</a><br>然后是代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> lxml <span class="hljs-keyword">import</span> html<br><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">import</span> json<br><span class="hljs-keyword">import</span> re<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CrawlWeibo</span>:</span><br><br>    <span class="hljs-comment"># 获取指定博主的所有微博card的list</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getWeibo</span>(<span class="hljs-params">self,<span class="hljs-built_in">id</span>,page</span>):</span><span class="hljs-comment">#id（字符串类型）：博主的用户id，page（整型）：微博翻页参数</span><br><br>        url=<span class="hljs-string">&#x27;https://m.weibo.cn/api/container/getIndex?type=uid&amp;value=&#x27;</span>+<span class="hljs-built_in">id</span>+<span class="hljs-string">&#x27;&amp;containerid=107603&#x27;</span>+<span class="hljs-built_in">id</span>+<span class="hljs-string">&#x27;&amp;page=&#x27;</span>+<span class="hljs-built_in">str</span>(page)<br>        response=requests.get(url)<br>        ob_json=json.loads(response.text)<br><br>        list_cards=ob_json[<span class="hljs-string">&#x27;cards&#x27;</span>]<br>        <span class="hljs-keyword">return</span> list_cards<span class="hljs-comment"># 返回本页所有的cards</span><br><br>    <span class="hljs-comment"># 返回某条微博的热门评论的list</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getComments</span>(<span class="hljs-params">self,<span class="hljs-built_in">id</span>,page</span>):</span><span class="hljs-comment"># id（字符串类型）：某条微博的id，page（整型）：评论翻页参数</span><br>        url=<span class="hljs-string">&#x27;https://m.weibo.cn/api/comments/show?id=&#x27;</span>+<span class="hljs-built_in">id</span>+<span class="hljs-string">&#x27;&amp;page=&#x27;</span>+<span class="hljs-built_in">str</span>(page)<br>        response=requests.get(url)<br>        ob_json=json.loads(response.text)<br><br>        list_comments=ob_json[<span class="hljs-string">&#x27;hot_data&#x27;</span>]<br>        <span class="hljs-keyword">return</span> list_comments<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">printAllTopic</span>(<span class="hljs-params">self,page</span>):</span><br>        list_cards=self.getWeibo(<span class="hljs-string">&#x27;1713926427&#x27;</span>,page)<br>        <span class="hljs-comment"># 遍历当页所有微博，输出内容，并根据id查找输出热门评论</span><br>        <span class="hljs-keyword">for</span> card <span class="hljs-keyword">in</span> list_cards:<br>            <span class="hljs-keyword">if</span> card[<span class="hljs-string">&#x27;card_type&#x27;</span>]==<span class="hljs-number">9</span>:<span class="hljs-comment"># 过滤出微博，card_type=9的是微博card，card_type=11的是推荐有趣的人</span><br>                <span class="hljs-built_in">id</span>=card[<span class="hljs-string">&#x27;mblog&#x27;</span>][<span class="hljs-string">&#x27;id&#x27;</span>]<br>                text=card[<span class="hljs-string">&#x27;mblog&#x27;</span>][<span class="hljs-string">&#x27;text&#x27;</span>]<br>                <span class="hljs-keyword">if</span> re.search(<span class="hljs-string">&#x27;___&#x27;</span>, text)!=<span class="hljs-literal">None</span>:<span class="hljs-comment"># 用正则匹配，将博文有下划线的微博过滤出来，有下划线的是“话题微博”</span><br>                     <span class="hljs-built_in">print</span> (<span class="hljs-string">u&quot;### 话题: &quot;</span>+text+<span class="hljs-string">&#x27;\n&#x27;</span>)<br><br>                     <span class="hljs-comment">#根据微博id获取热门评论，并输出</span><br>                     list_comments=crawl_weibo.getComments(<span class="hljs-built_in">id</span>, <span class="hljs-number">1</span>)<span class="hljs-comment"># 热门评论只需要访问第一页</span><br>                     count_hotcomments=<span class="hljs-number">1</span><br>                     <span class="hljs-keyword">for</span> comment <span class="hljs-keyword">in</span> list_comments:<br>                         created_at=comment[<span class="hljs-string">&#x27;created_at&#x27;</span>]<span class="hljs-comment"># 发表日期时间</span><br>                         like_counts=comment[<span class="hljs-string">&#x27;like_counts&#x27;</span>]<span class="hljs-comment"># 点赞数</span><br><br>                         text=comment[<span class="hljs-string">&#x27;text&#x27;</span>]<span class="hljs-comment"># 评论内容</span><br>                         tree=html.fromstring(text)<br>                         text=tree.xpath(<span class="hljs-string">&#x27;string(.)&#x27;</span>)<span class="hljs-comment"># 用string函数过滤掉多余标签</span><br><br>                         name_user=comment[<span class="hljs-string">&#x27;user&#x27;</span>][<span class="hljs-string">&#x27;screen_name&#x27;</span>]<span class="hljs-comment"># 评论者的用户名</span><br><br>                         source=comment[<span class="hljs-string">&#x27;source&#x27;</span>]<span class="hljs-comment"># 来源于哪个终端</span><br>                         <span class="hljs-keyword">if</span> source==<span class="hljs-string">&#x27;&#x27;</span>:<br>                             source=<span class="hljs-string">u&#x27;未知&#x27;</span><br><br>                         pic_url=<span class="hljs-string">&#x27;&#x27;</span><span class="hljs-comment"># 评论内容的图片</span><br>                         <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;pic&#x27;</span> <span class="hljs-keyword">in</span> comment:<br>                             pic_url=comment[<span class="hljs-string">&#x27;pic&#x27;</span>][<span class="hljs-string">&#x27;url&#x27;</span>]<br><br>                        <span class="hljs-comment"># 输出评论数据</span><br>                         <span class="hljs-built_in">print</span> (<span class="hljs-built_in">str</span>(count_hotcomments),<span class="hljs-string">&#x27;: **&#x27;</span>,name_user,<span class="hljs-string">&#x27;**&#x27;</span>,<span class="hljs-string">u&#x27;  **发表于：**&#x27;</span>+created_at,<span class="hljs-string">u&#x27;  **点赞：**&#x27;</span>+<span class="hljs-built_in">str</span>(like_counts)+<span class="hljs-string">u&#x27;  **来自：**&#x27;</span>+source)<br>                         <span class="hljs-built_in">print</span> (text+<span class="hljs-string">&#x27;\n&#x27;</span>)<br>                         count_hotcomments=count_hotcomments+<span class="hljs-number">1</span><br>                     <span class="hljs-built_in">print</span> (<span class="hljs-string">&#x27;***&#x27;</span>)<br><br><span class="hljs-comment">#实例化爬虫类并调用成员方法进行输出                     </span><br>crawl_weibo=CrawlWeibo()<br>crawl_weibo.printAllTopic(<span class="hljs-number">1</span>)<span class="hljs-comment"># 只输出一页进行示例展示</span><br></code></pre></td></tr></table></figure>
<p>其实就是不断的解析JSON来获取自己想要的<br>，搜索到榜姐后，点他的微博<br><img    class="lazyload" data-original="https://github.com/so1n/so1n_blog_photo/blob/master/blog_photo/%E8%8E%B7%E5%8F%96%E6%A6%9C%E5%A7%90%E9%A6%96%E9%A1%B5JSON.png?raw=true" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">enter description here</span><br>可以找到生成微博的JSON文件<br>把URL提取后进去查看，可以看到JSON内容，然后COPY再到<a href="http://json.cn/">json.cn</a>查看<br><img    class="lazyload" data-original="https://github.com/so1n/so1n_blog_photo/blob/master/blog_photo/%E9%A6%96%E9%A1%B5JSON%E8%A7%A3%E9%87%8A.png?raw=true" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">enter description here</span><br>之后就会发现我们要的微博都再card 9里面，提取之<br>再点进去评论列表，跟分析博文一样进行分析<br><img    class="lazyload" data-original="https://github.com/so1n/so1n_blog_photo/blob/master/blog_photo/%E8%AF%84%E8%AE%BA.png?raw=true" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">enter description here</span><br>就能从里面提取精彩评论了，然而，只有8条- -<br>然后我就重新弄了一下，那里不是有个更多评论吗，点击后就能看到很多热门评论了，缺点是看不到图片。不过还好我主要捉取的是评论- -，然后就发现要下拉才能更新评论，难受: (<br>然而我找不到第一页，却找到了第二页- -<br><img    class="lazyload" data-original="https://github.com/so1n/so1n_blog_photo/blob/master/blog_photo/%E7%83%AD%E9%97%A8%E8%AF%84%E8%AE%BA1.png?raw=true" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">enter description here</span><br>查看JSON文件后，可以发现热门评论更改page就可以了1页有9个评论<br>然后更改里面的链接就差不多可以了，还有hot_data改为card_group</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getComments</span>(<span class="hljs-params">self,<span class="hljs-built_in">id</span>,page</span>):</span><span class="hljs-comment"># id（字符串类型）：某条微博的id，page（整型）：评论翻页参数</span><br>      <span class="hljs-comment">#url=&#x27;https://m.weibo.cn/api/comments/show?id=&#x27;+id+&#x27;&amp;page=&#x27;+str(page)</span><br>url = <span class="hljs-string">&#x27;https://m.weibo.cn/single/rcList?format=cards&amp;id=&#x27;</span>+<span class="hljs-built_in">id</span>+<span class="hljs-string">&#x27;&amp;type=comment&amp;hot=1&amp;page=&#x27;</span>+<span class="hljs-built_in">str</span>(page)<br>      response=requests.get(url)<br>      ob_json=json.loads(response.text)<br><br>      list_comments=ob_json[<span class="hljs-string">&#x27;card_group&#x27;</span>]<br>      <span class="hljs-keyword">return</span> list_comments<br></code></pre></td></tr></table></figure>
<h3 id="3-爬取微博内容"><a href="#3-爬取微博内容" class="headerlink" title="3.爬取微博内容"></a>3.爬取微博内容</h3><p>原来我写的有点乱，不好的代码还是扔在电脑里面好了。现在爬取微博内容直接对以上获取到的list_cards解析就行了，不过图片有3种形式，分别是缩略图，压缩图，原图</p>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css">&quot;<span class="hljs-selector-tag">thumbnail_pic</span>&quot;<span class="hljs-selector-pseudo">:&quot;http</span>://<span class="hljs-selector-tag">wx1</span><span class="hljs-selector-class">.sinaimg</span><span class="hljs-selector-class">.cn</span>/<span class="hljs-selector-tag">thumbnail</span>/6628711<span class="hljs-selector-tag">bgy1fca7isjl7nj215o15o167</span><span class="hljs-selector-class">.jpg</span>&quot;,<br> &quot;<span class="hljs-selector-tag">bmiddle_pic</span>&quot;<span class="hljs-selector-pseudo">:&quot;http</span>://<span class="hljs-selector-tag">wx1</span><span class="hljs-selector-class">.sinaimg</span><span class="hljs-selector-class">.cn</span>/<span class="hljs-selector-tag">bmiddle</span>/6628711<span class="hljs-selector-tag">bgy1fca7isjl7nj215o15o167</span><span class="hljs-selector-class">.jpg</span>&quot;,<br> &quot;<span class="hljs-selector-tag">original_pic</span>&quot;<span class="hljs-selector-pseudo">:&quot;http</span>://<span class="hljs-selector-tag">wx1</span><span class="hljs-selector-class">.sinaimg</span><span class="hljs-selector-class">.cn</span>/<span class="hljs-selector-tag">large</span>/6628711<span class="hljs-selector-tag">bgy1fca7isjl7nj215o15o167</span><span class="hljs-selector-class">.jpg</span>&quot;,<br></code></pre></td></tr></table></figure>
<h3 id="4-爬取用户信息"><a href="#4-爬取用户信息" class="headerlink" title="4.爬取用户信息"></a>4.爬取用户信息</h3><p>这个栗子同样也是使用移动版微博来获取资料（我这里是从我关注列表里面获取的）<br>然后再去查看关注列表的信息。因为是用下拉获取信息的，所以多次下拉后可以发现改变page = 的数值就可以获取到新的列表<br><img    class="lazyload" data-original="https://github.com/so1n/so1n_blog_photo/blob/master/blog_photo/%E5%85%B3%E6%B3%A8%E5%88%97%E8%A1%A8.png?raw=true" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">enter description here</span><br>可以看到列表里面有个链接：<a href="https://m.weibo.cn/api/container/getSecond?containerid=1005051896662273_-_FOLLOWERS&amp;page=2">https://m.weibo.cn/api/container/getSecond?containerid=1005051896662273_-_FOLLOWERS&amp;page=2</a>  这个containerid这个不知道是什么，之前也没看过。所以重新跑回主页查看<br><img    class="lazyload" data-original="https://github.com/so1n/so1n_blog_photo/blob/master/blog_photo/%E7%9C%9Fid%E8%8E%B7%E5%8F%96.png?raw=true" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">enter description here</span><br>可以发现，再这个页面已经出现这个containerid了<br>到这个页面获取就好了，然而我直接填写= =。。<br>接着获取到json后就像上面一样开始分析，下面是一个分析的记过栗子</p>
<figure class="highlight sqf"><table><tr><td class="code"><pre><code class="hljs sqf"><span class="hljs-string">&quot;card_type&quot;</span>:<span class="hljs-number">10</span>,<br><span class="hljs-string">&quot;user&quot;</span>:&#123;<br>    <span class="hljs-string">&quot;id&quot;</span>:<span class="hljs-number">5909185172</span>,<br>    <span class="hljs-string">&quot;screen_name&quot;</span>:<span class="hljs-string">&quot;拜托啦学妹&quot;</span>,<br>    <span class="hljs-string">&quot;profile_image_url&quot;</span>:<span class="hljs-string">&quot;https://tva1.sinaimg.cn/crop.0.0.976.976.180/006rUl0gjw8f4uuscl9p5j30r40r410i.jpg&quot;</span>,<br>    <span class="hljs-string">&quot;profile_url&quot;</span>:<span class="hljs-string">&quot;https://m.weibo.cn/u/5909185172?uid=5909185172&amp;luicode=10000012&amp;lfid=1005051896662273_-_FOLLOWERS&amp;featurecode=20000320&quot;</span>,<br>    <span class="hljs-string">&quot;statuses_count&quot;</span>:<span class="hljs-number">390</span>,<br>    <span class="hljs-string">&quot;verified&quot;</span>:<span class="hljs-literal">true</span>,         有没有认证<br>    <span class="hljs-string">&quot;verified_type&quot;</span>:<span class="hljs-number">0</span>,       -<span class="hljs-number">1</span> 为没认证。<span class="hljs-number">0</span>为个人认证，其余为企业认证<br>    <span class="hljs-string">&quot;verified_type_ext&quot;</span>:<span class="hljs-number">1</span>,     <span class="hljs-variable">_ext</span>为<span class="hljs-number">1</span>时(橙色V)， <span class="hljs-variable">_ext</span>为<span class="hljs-number">0</span>（黄色v）<span class="hljs-variable">_ext</span>   <br>    <span class="hljs-string">&quot;verified_reason&quot;</span>:<span class="hljs-string">&quot;微博知名搞笑视频博主 教育视频自媒体 微博签约自媒体&quot;</span>,       认证说明<br>    <span class="hljs-string">&quot;description&quot;</span>:<span class="hljs-string">&quot;一个只属于大学生的街访&quot;</span>,                             简介<br>    <span class="hljs-string">&quot;gender&quot;</span>:<span class="hljs-string">&quot;f&quot;</span>,                           性别：f为女m为男<br>    <span class="hljs-string">&quot;mbtype&quot;</span>:<span class="hljs-number">12</span>,                        <span class="hljs-number">12</span>都是个人账户，<span class="hljs-number">0</span>也是。<span class="hljs-number">2</span>有个人账户也有企业账户，<span class="hljs-number">11</span>也是企业账户<br>    <span class="hljs-string">&quot;urank&quot;</span>:<span class="hljs-number">27</span>,                           等级<br>    <span class="hljs-string">&quot;mbrank&quot;</span>:<span class="hljs-number">5</span>,                          会员等级<br>    <span class="hljs-string">&quot;follow_me&quot;</span>:<span class="hljs-literal">false</span>,                    是否关注我<br>    <span class="hljs-string">&quot;following&quot;</span>:<span class="hljs-literal">true</span>,                   我是否关注他<br>    <span class="hljs-string">&quot;followers_count&quot;</span>:<span class="hljs-number">5445128</span>,            粉丝数量<br>    <span class="hljs-string">&quot;follow_count&quot;</span>:<span class="hljs-number">69</span>,                   关注量<br>    <span class="hljs-string">&quot;cover_image_phone&quot;</span>:<span class="hljs-string">&quot;https://tva1.sinaimg.cn/crop.0.0.640.640.640/549d0121tw1egm1kjly3jj20hs0hsq4f.jpg&quot;</span>,<br>    <span class="hljs-string">&quot;desc1&quot;</span>:null,           <br>    <span class="hljs-string">&quot;desc2&quot;</span>:null<br>&#125;,<br></code></pre></td></tr></table></figure>
<p>然后就可以获取了，结果如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">id:</span> <span class="hljs-number">5364707424</span> <span class="hljs-string">姓名:</span> <span class="hljs-string">Just春苑</span> <span class="hljs-string">简介:</span> <span class="hljs-string">🐮</span> <span class="hljs-string">等级:</span> <span class="hljs-number">9</span> <span class="hljs-string">性别:</span> <span class="hljs-string">m</span> <span class="hljs-string">是否关注我:</span> <span class="hljs-literal">True</span><br><span class="hljs-attr">id:</span> <span class="hljs-number">5406572240</span> <span class="hljs-string">姓名:</span> <span class="hljs-string">魅蓝手机</span> <span class="hljs-string">简介:</span>  <span class="hljs-string">等级:</span> <span class="hljs-number">17</span> <span class="hljs-string">性别:</span> <span class="hljs-string">m</span> <span class="hljs-string">是否关注我:</span> <span class="hljs-literal">False</span><br><span class="hljs-attr">id:</span> <span class="hljs-number">3230122083</span> <span class="hljs-string">姓名:</span> <span class="hljs-string">Flyme</span> <span class="hljs-string">简介:</span> <span class="hljs-string">Flyme是魅族基于Android内核为旗下智能手机量身打造的操作系统，旨在为用户提供优秀的交互体验和贴心的在线服务。源自内心的设计，做最本质的思考，Flyme定会让你刮目相看！</span> <span class="hljs-string">等级:</span> <span class="hljs-number">35</span> <span class="hljs-string">性别:</span> <span class="hljs-string">m</span> <span class="hljs-string">是否关注我:</span> <span class="hljs-literal">False</span><br><span class="hljs-attr">id:</span> <span class="hljs-number">5608433557</span> <span class="hljs-string">姓名:</span> <span class="hljs-string">微博雷达</span> <span class="hljs-string">简介:</span>  <span class="hljs-string">等级:</span> <span class="hljs-number">5</span> <span class="hljs-string">性别:</span> <span class="hljs-string">f</span> <span class="hljs-string">是否关注我:</span> <span class="hljs-literal">False</span><br><span class="hljs-attr">id:</span> <span class="hljs-number">1861358972</span> <span class="hljs-string">姓名:</span> <span class="hljs-string">气势如虹Leslie</span> <span class="hljs-string">简介:</span> <span class="hljs-string">去认识更广阔的世界</span> <span class="hljs-string">等级:</span> <span class="hljs-number">16</span> <span class="hljs-string">性别:</span> <span class="hljs-string">m</span> <span class="hljs-string">是否关注我:</span> <span class="hljs-literal">True</span><br><span class="hljs-attr">id:</span> <span class="hljs-number">1992613670</span> <span class="hljs-string">姓名:</span> <span class="hljs-string">凤凰新闻客户端</span> <span class="hljs-string">简介:</span>  <span class="hljs-string">等级:</span> <span class="hljs-number">37</span> <span class="hljs-string">性别:</span> <span class="hljs-string">m</span> <span class="hljs-string">是否关注我:</span> <span class="hljs-literal">False</span><br><span class="hljs-attr">id:</span> <span class="hljs-number">2629306884</span> <span class="hljs-string">姓名:</span> <span class="hljs-string">CSDN产品客服</span> <span class="hljs-string">简介:</span> <span class="hljs-string">还在为你的下载积分太少发愁吗？快来参加CSDN做任务，拿积分活动~~攒下载积分啦~~http://task.csdn.net/rule.aspx</span> <span class="hljs-string">等级:</span> <span class="hljs-number">21</span> <span class="hljs-string">性别:</span> <span class="hljs-string">f</span> <span class="hljs-string">是否关注我:</span> <span class="hljs-literal">False</span><br><span class="hljs-attr">id:</span> <span class="hljs-number">2251036402</span> <span class="hljs-string">姓名:</span> <span class="hljs-string">Colombo丶Fd</span> <span class="hljs-string">简介:</span>  <span class="hljs-string">等级:</span> <span class="hljs-number">14</span> <span class="hljs-string">性别:</span> <span class="hljs-string">m</span> <span class="hljs-string">是否关注我:</span> <span class="hljs-literal">True</span><br><span class="hljs-attr">id:</span> <span class="hljs-number">1720064601</span> <span class="hljs-string">姓名:</span> <span class="hljs-string">RNF_牧牧子</span> <span class="hljs-string">简介:</span> <span class="hljs-string">|后院43024|轮协3.0|脱了一半的伪宅|世上稀有的腐男|绝对领域万岁|我终于过了CCIE|全(部)球(类)通</span> <span class="hljs-string">等级:</span> <span class="hljs-number">31</span> <span class="hljs-string">性别:</span> <span class="hljs-string">m</span> <span class="hljs-string">是否关注我:</span> <span class="hljs-literal">True</span><br><span class="hljs-attr">id:</span> <span class="hljs-number">2472362284</span> <span class="hljs-string">姓名:</span> <span class="hljs-string">RNF_某清</span> <span class="hljs-string">简介:</span> <span class="hljs-string">微不足道。</span> <span class="hljs-string">等级:</span> <span class="hljs-number">22</span> <span class="hljs-string">性别:</span> <span class="hljs-string">m</span> <span class="hljs-string">是否关注我:</span> <span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure>


<p>这部分内容的代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> re<br><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">import</span> json<br><span class="hljs-keyword">from</span> lxml <span class="hljs-keyword">import</span> etree<br><br><br>cookie = &#123;<span class="hljs-string">&quot;Cookie&quot;</span>: <span class="hljs-string">&quot;你的cookie&quot;</span>&#125;<br>url = <span class="hljs-string">&#x27;https://m.weibo.cn/api/container/getSecond?containerid=1005051896662273_-_FOLLOWERS&amp;page=7&#x27;</span><br>html = requests.get(url, cookies=cookie)<br>ob_json=json.loads(html.text)<br>list_cards=ob_json[<span class="hljs-string">&#x27;cards&#x27;</span>]<br><span class="hljs-keyword">for</span> card <span class="hljs-keyword">in</span> list_cards:<br>    <span class="hljs-keyword">if</span> card[<span class="hljs-string">&#x27;card_type&#x27;</span>] == <span class="hljs-number">10</span>:<br>        <span class="hljs-built_in">id</span> = card[<span class="hljs-string">&#x27;user&#x27;</span>][<span class="hljs-string">&#x27;id&#x27;</span>]<br>        name = card[<span class="hljs-string">&#x27;user&#x27;</span>][<span class="hljs-string">&#x27;screen_name&#x27;</span>]<br>        description = card[<span class="hljs-string">&#x27;user&#x27;</span>][<span class="hljs-string">&#x27;description&#x27;</span>]<br>        urank = card[<span class="hljs-string">&#x27;user&#x27;</span>][<span class="hljs-string">&#x27;urank&#x27;</span>]<br>        gender = card[<span class="hljs-string">&#x27;user&#x27;</span>][<span class="hljs-string">&#x27;gender&#x27;</span>]<br>        follow_me = card[<span class="hljs-string">&#x27;user&#x27;</span>][<span class="hljs-string">&#x27;follow_me&#x27;</span>]<br>        <span class="hljs-keyword">if</span> gender == <span class="hljs-string">&#x27;m&#x27;</span>:<br>            gender ==<span class="hljs-string">&#x27;男&#x27;</span><br>        <span class="hljs-keyword">if</span> gender == <span class="hljs-string">&#x27;f&#x27;</span>:<br>            gender ==<span class="hljs-string">&#x27;女&#x27;</span><br>        <span class="hljs-keyword">else</span>:<br>            gender == <span class="hljs-string">&#x27;其他&#x27;</span><br>        <span class="hljs-keyword">if</span> follow_me:<br>            follow_me == <span class="hljs-string">&#x27;是&#x27;</span><br>        <span class="hljs-keyword">else</span>:<br>            follow_me == <span class="hljs-string">&#x27;否&#x27;</span><br>        print(<span class="hljs-string">&#x27;id:&#x27;</span>, <span class="hljs-built_in">id</span>, <span class="hljs-string">&#x27;姓名:&#x27;</span>, name ,<span class="hljs-string">&#x27;简介:&#x27;</span>, description ,<span class="hljs-string">&#x27;等级:&#x27;</span>, urank, <span class="hljs-string">&#x27;性别:&#x27;</span>, gender ,<span class="hljs-string">&#x27;是否关注我:&#x27;</span>, follow_me)<br><br><br><br><br><br><br></code></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>制作一个火车票查询余票的爬虫</title>
    <url>/2017/08/10/8_12306_spider/</url>
    <content><![CDATA[<p>用python写出一个12306查询余票的爬虫</p>
<span id="more"></span>

<h3 id="制作一个火车票查询余票的爬虫"><a href="#制作一个火车票查询余票的爬虫" class="headerlink" title="制作一个火车票查询余票的爬虫"></a>制作一个火车票查询余票的爬虫</h3><p>PS：因为我要接入网页里面的，所以只做了个大概功能，其余后期做个接口接入到网页<br>这是代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> re<br><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">from</span> bs4 <span class="hljs-keyword">import</span> BeautifulSoup<br><span class="hljs-keyword">from</span> pprint <span class="hljs-keyword">import</span> pprint<br><span class="hljs-keyword">import</span> json<br><br>url = <span class="hljs-string">&#x27;https://kyfw.12306.cn/otn/leftTicket/query?leftTicketDTO.train_date=2017-09-02&amp;leftTicketDTO.from_station=CBQ&amp;leftTicketDTO.to_station=IZQ&amp;purpose_codes=ADULT&#x27;</span><br>response = requests.get(url, verify=<span class="hljs-literal">False</span>)<br>rowlists = json.loads(response.text)[<span class="hljs-string">&#x27;data&#x27;</span>][<span class="hljs-string">&#x27;result&#x27;</span>]<br>ticket_info_list = []<br><span class="hljs-keyword">for</span> rowlist <span class="hljs-keyword">in</span> rowlists:<br>    row9 = rowlist.split(<span class="hljs-string">&#x27;|&#x27;</span>)<br>    train_num = row[<span class="hljs-number">3</span>]<br>    from_station = row[<span class="hljs-number">4</span>]<br>    to_station = row[<span class="hljs-number">7</span>]<br>    from_time = row[<span class="hljs-number">8</span>]<br>    to_time = row[<span class="hljs-number">9</span>]<br>    all_time = row[<span class="hljs-number">10</span>]<br>    swz_num = row[<span class="hljs-number">32</span>] <span class="hljs-keyword">or</span> <span class="hljs-string">&#x27;--&#x27;</span><br>    ydz_num = row[<span class="hljs-number">31</span>] <span class="hljs-keyword">or</span> <span class="hljs-string">&#x27;--&#x27;</span><br>    edz_num = row[<span class="hljs-number">30</span>] <span class="hljs-keyword">or</span> <span class="hljs-string">&#x27;--&#x27;</span><br>    gjrw_num = row[<span class="hljs-number">21</span>] <span class="hljs-keyword">or</span> <span class="hljs-string">&#x27;--&#x27;</span><br>    rw_num = row[<span class="hljs-number">23</span>] <span class="hljs-keyword">or</span> <span class="hljs-string">&#x27;--&#x27;</span><br>    dw_num = row[<span class="hljs-number">27</span>] <span class="hljs-keyword">or</span> <span class="hljs-string">&#x27;--&#x27;</span><br>    yw_num = row[<span class="hljs-number">28</span>] <span class="hljs-keyword">or</span> <span class="hljs-string">&#x27;--&#x27;</span><br>    rz_num = row[<span class="hljs-number">24</span>] <span class="hljs-keyword">or</span> <span class="hljs-string">&#x27;--&#x27;</span><br>    yz_num = row[<span class="hljs-number">29</span>] <span class="hljs-keyword">or</span> <span class="hljs-string">&#x27;--&#x27;</span><br>    wz_num = row[<span class="hljs-number">26</span>] <span class="hljs-keyword">or</span> <span class="hljs-string">&#x27;--&#x27;</span><br>    ticket_info = [train_num, from_station, to_station, from_time, to_time, all_time , swz_num, ydz_num, edz_num, gjrw_num, rw_num, dw_num, yw_num, rz_num, yz_num, wz_num]<br>    ticket_info_list.append(ticket_info)<br>print(ticket_info_list)<br></code></pre></td></tr></table></figure>
<p>这是结果：</p>
<figure class="highlight scheme"><table><tr><td class="code"><pre><code class="hljs scheme">[[<span class="hljs-symbol">&#x27;G6343</span>&#x27;, <span class="hljs-symbol">&#x27;CBQ</span>&#x27;, <span class="hljs-symbol">&#x27;IZQ</span>&#x27;, <span class="hljs-symbol">&#x27;06:10</span>&#x27;, <span class="hljs-symbol">&#x27;08:44</span>&#x27;, <span class="hljs-symbol">&#x27;02:34</span>&#x27;, <span class="hljs-symbol">&#x27;5</span>&#x27;, <span class="hljs-symbol">&#x27;13</span>&#x27;, <span class="hljs-symbol">&#x27;无</span>&#x27;, <span class="hljs-symbol">&#x27;--</span>&#x27;, <span class="hljs-symbol">&#x27;--</span>&#x27;, <span class="hljs-symbol">&#x27;--</span>&#x27;, <span class="hljs-symbol">&#x27;--</span>&#x27;, <span class="hljs-symbol">&#x27;--</span>&#x27;, <span class="hljs-symbol">&#x27;--</span>&#x27;, <span class="hljs-symbol">&#x27;无</span>&#x27;],<br>[<span class="hljs-symbol">&#x27;G6347</span>&#x27;, <span class="hljs-symbol">&#x27;CBQ</span>&#x27;, <span class="hljs-symbol">&#x27;IZQ</span>&#x27;, <span class="hljs-symbol">&#x27;07:00</span>&#x27;, <span class="hljs-symbol">&#x27;09:50</span>&#x27;, <span class="hljs-symbol">&#x27;02:50</span>&#x27;, <span class="hljs-symbol">&#x27;5</span>&#x27;, <span class="hljs-symbol">&#x27;无</span>&#x27;, <span class="hljs-symbol">&#x27;无</span>&#x27;, <span class="hljs-symbol">&#x27;--</span>&#x27;, <span class="hljs-symbol">&#x27;--</span>&#x27;, <span class="hljs-symbol">&#x27;--</span>&#x27;, <span class="hljs-symbol">&#x27;--</span>&#x27;, <span class="hljs-symbol">&#x27;--</span>&#x27;, <span class="hljs-symbol">&#x27;--</span>&#x27;, <span class="hljs-symbol">&#x27;无</span>&#x27;], <br>[<span class="hljs-symbol">&#x27;D7531</span>&#x27;, <span class="hljs-symbol">&#x27;CBQ</span>&#x27;, <span class="hljs-symbol">&#x27;GGQ</span>&#x27;, <span class="hljs-symbol">&#x27;08:58</span>&#x27;, <span class="hljs-symbol">&#x27;12:05</span>&#x27;, <span class="hljs-symbol">&#x27;03:07</span>&#x27;, <span class="hljs-symbol">&#x27;--</span>&#x27;, <span class="hljs-symbol">&#x27;无</span>&#x27;, <span class="hljs-symbol">&#x27;无</span>&#x27;, <span class="hljs-symbol">&#x27;--</span>&#x27;, <span class="hljs-symbol">&#x27;--</span>&#x27;, <span class="hljs-symbol">&#x27;--</span>&#x27;, <span class="hljs-symbol">&#x27;--</span>&#x27;, <span class="hljs-symbol">&#x27;--</span>&#x27;, <span class="hljs-symbol">&#x27;--</span>&#x27;, <span class="hljs-symbol">&#x27;无</span>&#x27;], <br>[<span class="hljs-symbol">&#x27;G6319</span>&#x27;, <span class="hljs-symbol">&#x27;CBQ</span>&#x27;, <span class="hljs-symbol">&#x27;IZQ</span>&#x27;, <span class="hljs-symbol">&#x27;10:22</span>&#x27;, <span class="hljs-symbol">&#x27;13:10</span>&#x27;, <span class="hljs-symbol">&#x27;02:48</span>&#x27;, <span class="hljs-symbol">&#x27;5</span>&#x27;, <span class="hljs-symbol">&#x27;无</span>&#x27;, <span class="hljs-symbol">&#x27;无</span>&#x27;, <span class="hljs-symbol">&#x27;--</span>&#x27;, <span class="hljs-symbol">&#x27;--</span>&#x27;, <span class="hljs-symbol">&#x27;--</span>&#x27;, <span class="hljs-symbol">&#x27;--</span>&#x27;, <span class="hljs-symbol">&#x27;--</span>&#x27;, <span class="hljs-symbol">&#x27;--</span>&#x27;, <span class="hljs-symbol">&#x27;无</span>&#x27;], <br>[<span class="hljs-symbol">&#x27;D7511</span>&#x27;, <span class="hljs-symbol">&#x27;CBQ</span>&#x27;, <span class="hljs-symbol">&#x27;GGQ</span>&#x27;, <span class="hljs-symbol">&#x27;11:05</span>&#x27;, <span class="hljs-symbol">&#x27;14:15</span>&#x27;, <span class="hljs-symbol">&#x27;03:10</span>&#x27;, <span class="hljs-symbol">&#x27;--</span>&#x27;, <span class="hljs-symbol">&#x27;无</span>&#x27;, <span class="hljs-symbol">&#x27;无</span>&#x27;, <span class="hljs-symbol">&#x27;--</span>&#x27;, <span class="hljs-symbol">&#x27;--</span>&#x27;, <span class="hljs-symbol">&#x27;--</span>&#x27;, <span class="hljs-symbol">&#x27;--</span>&#x27;, <span class="hljs-symbol">&#x27;--</span>&#x27;, <span class="hljs-symbol">&#x27;--</span>&#x27;, <span class="hljs-symbol">&#x27;无</span>&#x27;], <br>[<span class="hljs-symbol">&#x27;G6303</span>&#x27;, <span class="hljs-symbol">&#x27;CBQ</span>&#x27;, <span class="hljs-symbol">&#x27;IZQ</span>&#x27;, <span class="hljs-symbol">&#x27;11:10</span>&#x27;, <span class="hljs-symbol">&#x27;14:11</span>&#x27;, <span class="hljs-symbol">&#x27;03:01</span>&#x27;, <span class="hljs-symbol">&#x27;4</span>&#x27;, <span class="hljs-symbol">&#x27;无</span>&#x27;, <span class="hljs-symbol">&#x27;无</span>&#x27;, <span class="hljs-symbol">&#x27;--</span>&#x27;, <span class="hljs-symbol">&#x27;--</span>&#x27;, <span class="hljs-symbol">&#x27;--</span>&#x27;, <span class="hljs-symbol">&#x27;--</span>&#x27;, <span class="hljs-symbol">&#x27;--</span>&#x27;, <span class="hljs-symbol">&#x27;--</span>&#x27;, <span class="hljs-symbol">&#x27;无</span>&#x27;], <br>[<span class="hljs-symbol">&#x27;G6307</span>&#x27;, <span class="hljs-symbol">&#x27;CBQ</span>&#x27;, <span class="hljs-symbol">&#x27;IZQ</span>&#x27;, <span class="hljs-symbol">&#x27;12:20</span>&#x27;, <span class="hljs-symbol">&#x27;15:12</span>&#x27;, <span class="hljs-symbol">&#x27;02:52</span>&#x27;, <span class="hljs-symbol">&#x27;1</span>&#x27;, <span class="hljs-symbol">&#x27;无</span>&#x27;, <span class="hljs-symbol">&#x27;无</span>&#x27;, <span class="hljs-symbol">&#x27;--</span>&#x27;, <span class="hljs-symbol">&#x27;--</span>&#x27;, <span class="hljs-symbol">&#x27;--</span>&#x27;, <span class="hljs-symbol">&#x27;--</span>&#x27;, <span class="hljs-symbol">&#x27;--</span>&#x27;, <span class="hljs-symbol">&#x27;--</span>&#x27;, <span class="hljs-symbol">&#x27;无</span>&#x27;], <br>[<span class="hljs-symbol">&#x27;D7503</span>&#x27;, <span class="hljs-symbol">&#x27;CBQ</span>&#x27;, <span class="hljs-symbol">&#x27;GGQ</span>&#x27;, <span class="hljs-symbol">&#x27;13:04</span>&#x27;, <span class="hljs-symbol">&#x27;16:26</span>&#x27;, <span class="hljs-symbol">&#x27;03:22</span>&#x27;, <span class="hljs-symbol">&#x27;--</span>&#x27;, <span class="hljs-symbol">&#x27;无</span>&#x27;, <span class="hljs-symbol">&#x27;无</span>&#x27;, <span class="hljs-symbol">&#x27;--</span>&#x27;, <span class="hljs-symbol">&#x27;--</span>&#x27;, <span class="hljs-symbol">&#x27;--</span>&#x27;, <span class="hljs-symbol">&#x27;--</span>&#x27;, <span class="hljs-symbol">&#x27;--</span>&#x27;, <span class="hljs-symbol">&#x27;--</span>&#x27;, <span class="hljs-symbol">&#x27;无</span>&#x27;], <br>[<span class="hljs-symbol">&#x27;G6327</span>&#x27;, <span class="hljs-symbol">&#x27;CBQ</span>&#x27;, <span class="hljs-symbol">&#x27;IZQ</span>&#x27;, <span class="hljs-symbol">&#x27;13:50</span>&#x27;, <span class="hljs-symbol">&#x27;16:41</span>&#x27;, <span class="hljs-symbol">&#x27;02:51</span>&#x27;, <span class="hljs-symbol">&#x27;4</span>&#x27;, <span class="hljs-symbol">&#x27;无</span>&#x27;, <span class="hljs-symbol">&#x27;无</span>&#x27;, <span class="hljs-symbol">&#x27;--</span>&#x27;, <span class="hljs-symbol">&#x27;--</span>&#x27;, <span class="hljs-symbol">&#x27;--</span>&#x27;, <span class="hljs-symbol">&#x27;--</span>&#x27;, <span class="hljs-symbol">&#x27;--</span>&#x27;, <span class="hljs-symbol">&#x27;--</span>&#x27;, <span class="hljs-symbol">&#x27;无</span>&#x27;], <br>[<span class="hljs-symbol">&#x27;D7523</span>&#x27;, <span class="hljs-symbol">&#x27;CBQ</span>&#x27;, <span class="hljs-symbol">&#x27;GGQ</span>&#x27;, <span class="hljs-symbol">&#x27;14:19</span>&#x27;, <span class="hljs-symbol">&#x27;17:34</span>&#x27;, <span class="hljs-symbol">&#x27;03:15</span>&#x27;, <span class="hljs-symbol">&#x27;--</span>&#x27;, <span class="hljs-symbol">&#x27;无</span>&#x27;, <span class="hljs-symbol">&#x27;无</span>&#x27;, <span class="hljs-symbol">&#x27;--</span>&#x27;, <span class="hljs-symbol">&#x27;--</span>&#x27;, <span class="hljs-symbol">&#x27;--</span>&#x27;, <span class="hljs-symbol">&#x27;--</span>&#x27;, <span class="hljs-symbol">&#x27;--</span>&#x27;, <span class="hljs-symbol">&#x27;--</span>&#x27;, <span class="hljs-symbol">&#x27;2</span>&#x27;], <br>[<span class="hljs-symbol">&#x27;D7507</span>&#x27;, <span class="hljs-symbol">&#x27;CBQ</span>&#x27;, <span class="hljs-symbol">&#x27;GGQ</span>&#x27;, <span class="hljs-symbol">&#x27;16:00</span>&#x27;, <span class="hljs-symbol">&#x27;19:16</span>&#x27;, <span class="hljs-symbol">&#x27;03:16</span>&#x27;, <span class="hljs-symbol">&#x27;--</span>&#x27;, <span class="hljs-symbol">&#x27;有</span>&#x27;, <span class="hljs-symbol">&#x27;无</span>&#x27;, <span class="hljs-symbol">&#x27;--</span>&#x27;, <span class="hljs-symbol">&#x27;--</span>&#x27;, <span class="hljs-symbol">&#x27;--</span>&#x27;, <span class="hljs-symbol">&#x27;--</span>&#x27;, <span class="hljs-symbol">&#x27;--</span>&#x27;, <span class="hljs-symbol">&#x27;--</span>&#x27;, <span class="hljs-symbol">&#x27;13</span>&#x27;],<br>[<span class="hljs-symbol">&#x27;G6339</span>&#x27;, <span class="hljs-symbol">&#x27;CBQ</span>&#x27;, <span class="hljs-symbol">&#x27;IZQ</span>&#x27;, <span class="hljs-symbol">&#x27;16:19</span>&#x27;, <span class="hljs-symbol">&#x27;19:22</span>&#x27;, <span class="hljs-symbol">&#x27;03:03</span>&#x27;, <span class="hljs-symbol">&#x27;无</span>&#x27;, <span class="hljs-symbol">&#x27;无</span>&#x27;, <span class="hljs-symbol">&#x27;无</span>&#x27;, <span class="hljs-symbol">&#x27;--</span>&#x27;, <span class="hljs-symbol">&#x27;--</span>&#x27;, <span class="hljs-symbol">&#x27;--</span>&#x27;, <span class="hljs-symbol">&#x27;--</span>&#x27;, <span class="hljs-symbol">&#x27;--</span>&#x27;, <span class="hljs-symbol">&#x27;--</span>&#x27;, <span class="hljs-symbol">&#x27;无</span>&#x27;], <br>[<span class="hljs-symbol">&#x27;D7527</span>&#x27;, <span class="hljs-symbol">&#x27;CBQ</span>&#x27;, <span class="hljs-symbol">&#x27;GGQ</span>&#x27;, <span class="hljs-symbol">&#x27;16:53</span>&#x27;, <span class="hljs-symbol">&#x27;20:10</span>&#x27;, <span class="hljs-symbol">&#x27;03:17</span>&#x27;, <span class="hljs-symbol">&#x27;--</span>&#x27;, <span class="hljs-symbol">&#x27;有</span>&#x27;, <span class="hljs-symbol">&#x27;无</span>&#x27;, <span class="hljs-symbol">&#x27;--</span>&#x27;, <span class="hljs-symbol">&#x27;--</span>&#x27;, <span class="hljs-symbol">&#x27;--</span>&#x27;, <span class="hljs-symbol">&#x27;--</span>&#x27;, <span class="hljs-symbol">&#x27;--</span>&#x27;, <span class="hljs-symbol">&#x27;--</span>&#x27;, <span class="hljs-symbol">&#x27;有</span>&#x27;], <br>[<span class="hljs-symbol">&#x27;G6323</span>&#x27;, <span class="hljs-symbol">&#x27;CBQ</span>&#x27;, <span class="hljs-symbol">&#x27;IZQ</span>&#x27;, <span class="hljs-symbol">&#x27;17:10</span>&#x27;, <span class="hljs-symbol">&#x27;20:07</span>&#x27;, <span class="hljs-symbol">&#x27;02:57</span>&#x27;, <span class="hljs-symbol">&#x27;5</span>&#x27;, <span class="hljs-symbol">&#x27;无</span>&#x27;, <span class="hljs-symbol">&#x27;无</span>&#x27;, <span class="hljs-symbol">&#x27;--</span>&#x27;, <span class="hljs-symbol">&#x27;--</span>&#x27;, <span class="hljs-symbol">&#x27;--</span>&#x27;, <span class="hljs-symbol">&#x27;--</span>&#x27;, <span class="hljs-symbol">&#x27;--</span>&#x27;, <span class="hljs-symbol">&#x27;--</span>&#x27;, <span class="hljs-symbol">&#x27;无</span>&#x27;], <br>[<span class="hljs-symbol">&#x27;G6315</span>&#x27;, <span class="hljs-symbol">&#x27;CBQ</span>&#x27;, <span class="hljs-symbol">&#x27;IZQ</span>&#x27;, <span class="hljs-symbol">&#x27;17:45</span>&#x27;, <span class="hljs-symbol">&#x27;20:41</span>&#x27;, <span class="hljs-symbol">&#x27;02:56</span>&#x27;, <span class="hljs-symbol">&#x27;无</span>&#x27;, <span class="hljs-symbol">&#x27;8</span>&#x27;, <span class="hljs-symbol">&#x27;无</span>&#x27;, <span class="hljs-symbol">&#x27;--</span>&#x27;, <span class="hljs-symbol">&#x27;--</span>&#x27;, <span class="hljs-symbol">&#x27;--</span>&#x27;, <span class="hljs-symbol">&#x27;--</span>&#x27;, <span class="hljs-symbol">&#x27;--</span>&#x27;, <span class="hljs-symbol">&#x27;--</span>&#x27;, <span class="hljs-symbol">&#x27;无</span>&#x27;], <br>[<span class="hljs-symbol">&#x27;D7515</span>&#x27;, <span class="hljs-symbol">&#x27;RVQ</span>&#x27;, <span class="hljs-symbol">&#x27;GGQ</span>&#x27;, <span class="hljs-symbol">&#x27;19:01</span>&#x27;, <span class="hljs-symbol">&#x27;22:16</span>&#x27;, <span class="hljs-symbol">&#x27;03:15</span>&#x27;, <span class="hljs-symbol">&#x27;--</span>&#x27;, <span class="hljs-symbol">&#x27;有</span>&#x27;, <span class="hljs-symbol">&#x27;无</span>&#x27;, <span class="hljs-symbol">&#x27;--</span>&#x27;, <span class="hljs-symbol">&#x27;--</span>&#x27;, <span class="hljs-symbol">&#x27;--</span>&#x27;, <span class="hljs-symbol">&#x27;--</span>&#x27;, <span class="hljs-symbol">&#x27;--</span>&#x27;, <span class="hljs-symbol">&#x27;--</span>&#x27;, <span class="hljs-symbol">&#x27;有</span>&#x27;],<br>[<span class="hljs-symbol">&#x27;G6311</span>&#x27;, <span class="hljs-symbol">&#x27;CBQ</span>&#x27;, <span class="hljs-symbol">&#x27;IZQ</span>&#x27;, <span class="hljs-symbol">&#x27;19:12</span>&#x27;, <span class="hljs-symbol">&#x27;22:06</span>&#x27;, <span class="hljs-symbol">&#x27;02:54</span>&#x27;, <span class="hljs-symbol">&#x27;5</span>&#x27;, <span class="hljs-symbol">&#x27;16</span>&#x27;, <span class="hljs-symbol">&#x27;有</span>&#x27;, <span class="hljs-symbol">&#x27;--</span>&#x27;, <span class="hljs-symbol">&#x27;--</span>&#x27;, <span class="hljs-symbol">&#x27;--</span>&#x27;, <span class="hljs-symbol">&#x27;--</span>&#x27;, <span class="hljs-symbol">&#x27;--</span>&#x27;, <span class="hljs-symbol">&#x27;--</span>&#x27;, <span class="hljs-symbol">&#x27;无</span>&#x27;], <br>[<span class="hljs-symbol">&#x27;D7519</span>&#x27;, <span class="hljs-symbol">&#x27;CBQ</span>&#x27;, <span class="hljs-symbol">&#x27;GGQ</span>&#x27;, <span class="hljs-symbol">&#x27;20:15</span>&#x27;, <span class="hljs-symbol">&#x27;23:31</span>&#x27;, <span class="hljs-symbol">&#x27;03:16</span>&#x27;, <span class="hljs-symbol">&#x27;--</span>&#x27;, <span class="hljs-symbol">&#x27;有</span>&#x27;, <span class="hljs-symbol">&#x27;有</span>&#x27;, <span class="hljs-symbol">&#x27;--</span>&#x27;, <span class="hljs-symbol">&#x27;--</span>&#x27;, <span class="hljs-symbol">&#x27;--</span>&#x27;, <span class="hljs-symbol">&#x27;--</span>&#x27;, <span class="hljs-symbol">&#x27;--</span>&#x27;, <span class="hljs-symbol">&#x27;--</span>&#x27;, <span class="hljs-symbol">&#x27;有</span>&#x27;], <br>[<span class="hljs-symbol">&#x27;G6331</span>&#x27;, <span class="hljs-symbol">&#x27;CBQ</span>&#x27;, <span class="hljs-symbol">&#x27;IZQ</span>&#x27;, <span class="hljs-symbol">&#x27;20:46</span>&#x27;, <span class="hljs-symbol">&#x27;23:29</span>&#x27;, <span class="hljs-symbol">&#x27;02:43</span>&#x27;, <span class="hljs-symbol">&#x27;5</span>&#x27;, <span class="hljs-symbol">&#x27;16</span>&#x27;, <span class="hljs-symbol">&#x27;有</span>&#x27;, <span class="hljs-symbol">&#x27;--</span>&#x27;, <span class="hljs-symbol">&#x27;--</span>&#x27;, <span class="hljs-symbol">&#x27;--</span>&#x27;, <span class="hljs-symbol">&#x27;--</span>&#x27;, <span class="hljs-symbol">&#x27;--</span>&#x27;, <span class="hljs-symbol">&#x27;--</span>&#x27;, <span class="hljs-symbol">&#x27;无</span>&#x27;]]<br></code></pre></td></tr></table></figure>
<h3 id="制作过程"><a href="#制作过程" class="headerlink" title="制作过程"></a>制作过程</h3><p>看着代码量挺少的，不过找东西浪费挺多的。。。<br>首先是链接的url</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>kyfw.<span class="hljs-number">12306</span>.cn<span class="hljs-regexp">/otn/</span>leftTicket/query?leftTicketDTO.train_date=<span class="hljs-number">2017</span>-<span class="hljs-number">09</span>-<span class="hljs-number">02</span>&amp;leftTicketDTO.from_station=CBQ&amp;leftTicketDTO.to_station=IZQ&amp;purpose_codes=ADULT<br></code></pre></td></tr></table></figure>
<p>在12306查询网页上，按下F12，点击netword。输入站点和时间后，点击查询，就能找到这个连接了<br><img    class="lazyload" data-original="https://github.com/so1n/so1n_blog_photo/blob/master/blog_photo/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_%E9%80%89%E6%8B%A9%E5%8C%BA%E5%9F%9F_20170810140208.png?raw=true" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">enter description here</span><br>可以看出有3个重要的值要传入，分别是时间：train_date=2017-09-02，出发站：from_station=CBQ终点站：to_station=IZQ<br>输入的城市他都会配到生成3个字母，而且没看出什么规律的，所以又得在netword里面翻一翻，最后看到一个叫station_name的，就找到链接了。里面是城市对应城市代码文件，然后又在网页源代码找到这个链接（因为这个文件会升级，所以就找到这个链接，制作一个可以随时生成城市-城市代码的文件）<br>代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> re<br><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">from</span> bs4 <span class="hljs-keyword">import</span> BeautifulSoup<br><span class="hljs-keyword">from</span> pprint <span class="hljs-keyword">import</span> pprint<br><span class="hljs-keyword">import</span> json<br><br>url = <span class="hljs-string">&#x27;https://kyfw.12306.cn/otn/leftTicket/init&#x27;</span><br>response = requests.get(url, verify=<span class="hljs-literal">False</span>)<br>soup = BeautifulSoup(response.text, <span class="hljs-string">&quot;html.parser&quot;</span>)<br>station_get = soup.find_all(<span class="hljs-string">&quot;script&quot;</span>, &#123;<span class="hljs-string">&quot;type&quot;</span>:<span class="hljs-string">&quot;text/javascript&quot;</span>&#125;)[<span class="hljs-number">7</span>]<br>a = re.sub(<span class="hljs-string">&#x27; &#x27;</span>,<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-built_in">str</span>(station_get))<br>a = re.sub(<span class="hljs-string">&#x27;&quot;&#x27;</span>, <span class="hljs-string">&quot;&quot;</span> ,a)<br>b = re.search(<span class="hljs-string">&#x27;otn(.+)type&#x27;</span>, a).group()<br>c = b[:-<span class="hljs-number">4</span>]<br>station_html = <span class="hljs-string">&quot;https://kyfw.12306.cn/&quot;</span>+c<br>response = requests.get(station_html, verify=<span class="hljs-literal">False</span>)<br>stations = re.findall(<span class="hljs-string">u&#x27;(\w+)\|([A-Z]+)&#x27;</span>, response.text)<br>stations_dict = <span class="hljs-built_in">dict</span>(stations)<br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;stations_dict.json&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>) <span class="hljs-keyword">as</span> fp:<br>    json.dump(stations_dict,fp=fp,ensure_ascii = <span class="hljs-literal">False</span>)<br></code></pre></td></tr></table></figure>
<p>这份代码里面的station_get用美丽汤匹配完是一个有包含这些元素的列表，而我要的那个刚好是第8个，就用切片取出来。<br>由于取出来后我用正则都正则不了，脑子没什么回路，于是就有了a,b,c这3行清洗数据的代码- -（后来也懒得改了）反正这样就匹配出来，然后就拼成一个连接就更get到那份城市-城市代码列表了=。=，之后在用正则就能取出来了,最后保存在json里面。注意一定要加入参数（ensure_ascii = False）不然就是生成\u23s这些东西</p>
<p>这份列表获取完了，可以进行下一步了（虽然我源代码里面没引用到- -。。。不过以后肯定得用到的）<br>由于12306有证书验证，所以要加（verify = False）<br>传入url后获取到的json可以看到我们的数据在[‘data’][‘result‘]里面，我们就可以把他取出来，由于取出来后是一个列表，我们就可以用split()来切割，切割完重点就来了 。。。前面站点，出发时间这些还好，后面那些票我得找好久啊，一直数也不是事。而且在网上，票数比较多就显示有，没票就显示无，其他也就显示几十张票，得查很久才能找到这些数据对应在哪里。(还好我比较懒，难得动脑筋-。-)。按下F12后按下面这张图找，如果右边那个框显示的格式不是这样的话，点击两个框中间的{}就可以了～～（还好12306容易找，然后搜索”–”就找到他对应的位置了。。），从图片可以看出什么票型对应在哪个位置，好像最后只有一个动卧我找不到，只能重新搜索，然后刚好哪个车次动卧有显示具体车票就找到了，然后发现网页的值是yb - -<br>python里面如果值为空显示其他值可以写（or ‘ 你期望的值’），果然python好啊！！！！<br><img    class="lazyload" data-original="https://github.com/so1n/so1n_blog_photo/blob/master/blog_photo/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_%E9%80%89%E6%8B%A9%E5%8C%BA%E5%9F%9F_20170810140330.png?raw=true" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">enter description here</span><br>虽然看似简单，但找链接，匹配正则，最后匹配数据费了许多时间。而且这个还是我半年前曾经看过关于查询火车票的教程，现在还依稀记得才节约点时间-。-（哪个教程我找不到了。。。。。）<br>好了，抓取数据就这样愉快的捉取完了，至于怎么引用，得看到学到那里啊。。。还有看到潮汕到广州开学那段时间的票空空如也t_t。。。</p>
]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>优化爬虫初级篇</title>
    <url>/2017/08/08/7_how_to%20optimize_the_spider/</url>
    <content><![CDATA[<h3 id="前记：之所以说是初级篇，是我现在用的爬虫最多也就是十万级数据，数据量还是不大，所以以下内容还是我实际遇到需要优化的内容或者网上看到的一些文章，该文章很多内容来自于网上，主要是做记录和写下个人理解。因为主要是记录，所以大多是只是阐述下有这个方法，具体还需要百度等去了解"><a href="#前记：之所以说是初级篇，是我现在用的爬虫最多也就是十万级数据，数据量还是不大，所以以下内容还是我实际遇到需要优化的内容或者网上看到的一些文章，该文章很多内容来自于网上，主要是做记录和写下个人理解。因为主要是记录，所以大多是只是阐述下有这个方法，具体还需要百度等去了解" class="headerlink" title="前记：之所以说是初级篇，是我现在用的爬虫最多也就是十万级数据，数据量还是不大，所以以下内容还是我实际遇到需要优化的内容或者网上看到的一些文章，该文章很多内容来自于网上，主要是做记录和写下个人理解。因为主要是记录，所以大多是只是阐述下有这个方法，具体还需要百度等去了解"></a>前记：之所以说是初级篇，是我现在用的爬虫最多也就是十万级数据，数据量还是不大，所以以下内容还是我实际遇到需要优化的内容或者网上看到的一些文章，该文章很多内容来自于网上，主要是做记录和写下个人理解。因为主要是记录，所以大多是只是阐述下有这个方法，具体还需要百度等去了解</h3><span id="more"></span>

<h3 id="1-增加爬行速度"><a href="#1-增加爬行速度" class="headerlink" title="1.增加爬行速度"></a>1.增加爬行速度</h3><p>爬虫是需要访问网络的，所以速度会比写入数据还慢，数据量少的话爬虫速度还看不出有多慢，当数据量多起来的时候，少则要几天，多则要几周的时间。</p>
<h4 id="1-1-分布式爬虫"><a href="#1-1-分布式爬虫" class="headerlink" title="1.1 分布式爬虫"></a>1.1 分布式爬虫</h4><p>分布式爬虫，简单来说就是本来由一台电脑运行的爬虫任务分给其他电脑一起运作，从而达到提升爬虫速度。<br>分布式爬虫主要有主从模式和对等模式，两种模式都有对应的缺点。例如主从模式的爬虫速度会因为控制节点的瓶颈限制到速度（因为控制节点上面有URL管理器、数据存储器和控制调度器，而其他爬虫节点只是从调度器那里领取任务再执行任务（<a href="https://pan.baidu.com/s/1hrWEOYg#list/path=/%E3%80%8APython%E7%88%AC%E8%99%AB%E5%BC%80%E5%8F%91%E4%B8%8E%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98%E3%80%8B%E8%AF%95%E8%AF%BB%E7%AB%A0%E8%8A%82">这里有一个简单的分布式爬虫主从模式的栗子</a>，书里第7章的内容）），而对等模式会因为当有一台服务器死机或者添加新的服务器，那么所有URL的哈希求余的结果就都要变化。也就是说，这种方式的扩展性不佳，不过对等模式也有进行改进。这两种方案的对比和结果图示可以参考<a href="http://f.dataguru.cn/thread-529666-1-1.html">这里</a><br>虽然我现在没有那么多电脑/服务器来跑分布式爬虫，但是可以通过一些资料了解到分布式爬虫的存在和大概结构，运行原理。目前网上的资料大多都是采用主从模式的。所以对等式我也只是了解一下，并没有找到案例（网上基本都是Scrapy+Redis的主从分布式爬虫，我试着跑一下，发现数据量还不会造成瓶颈- -估计要上千万的数据量才会有瓶颈吧）</p>
<h4 id="1-2-榨干性能去爬虫"><a href="#1-2-榨干性能去爬虫" class="headerlink" title="1.2 榨干性能去爬虫"></a>1.2 榨干性能去爬虫</h4><p>首先先了解几个概念</p>
<ul>
<li>进程<br>进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位。每个进程都有自己的独立内存空间，不同进程通过进程间通信来通信。由于进程比较重量，占据独立的内存，所以上下文进程间的切换开销（栈、寄存器、虚拟内存、文件句柄等）比较大，但相对比较稳定安全。</li>
<li>线程<br>线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。线程间通信主要通过共享内存，上下文切换很快，资源开销较少，但相比进程不够稳定容易丢失数据。<br>不过要注意的是，python的线程并不是并行，而是并发。这也是之前很多人在使用Python时摒弃线程的原因</li>
<li>协程<br>协程是一种用户态的轻量级线程，协程的调度完全由用户控制。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。<br>简单来说，协程相比线程来说有一个优势，就是在协程间切换时不需要很大的资源开销。在使用时可以开多个进程，然后每个进程开多个线程，每个线程开多个协程来综合使用。</li>
<li>并发与并行</li>
</ul>
<p><strong>并发</strong>：当有多个线程在操作时,如果系统只有一个CPU,则它根本不可能真正同时进行一个以上的线程，它只能把CPU运行时间划分成若干个时间段,再将时间 段分配给各个线程执行，在一个时间段的线程代码运行时，其它线程处于挂起状。.这种方式我们称之为并发(Concurrent)。<br><strong>并行</strong>：当系统有一个以上CPU时,则线程的操作有可能非并发。当一个CPU执行一个线程时，另一个CPU可以执行另一个线程，两个线程互不抢占CPU资源，可以同时进行，这种方式我们称之为并行(Parallel)。<br><strong>区别</strong>：并发和并行是即相似又有区别的两个概念，并行是指两个或者多个事件在同一时刻发生；而并发是指两个或多个事件在同一时间间隔内发生。在多道程序环境下，并发性是指在一段时间内宏观上有多个程序在同时运行，但在单处理机系统中，每一时刻却仅能有一道程序执行，故微观上这些程序只能是分时地交替执行。倘若在计算机系统中有多个处理机，则这些可以并发执行的程序便可被分配到多个处理机上，实现并行执行，即利用每个处理机来处理一个可并发执行的程序，这样，多个程序便可以同时执行。</p>
<ul>
<li>同步与异步，阻塞与非阻塞<br>这个的概念很多人都清楚了，这里贴个直白的解释，看了容易理解<br>老张爱喝茶，废话不说，煮开水。出场人物：老张，水壶两把（普通水壶，简称水壶；会响的水壶，简称响水壶）。1 老张把水壶放到火上，立等水开。（同步阻塞）老张觉得自己有点傻2 老张把水壶放到火上，去客厅看电视，时不时去厨房看看水开没有。（同步非阻塞）老张还是觉得自己有点傻，于是变高端了，买了把会响笛的那种水壶。水开之后，能大声发出嘀~~~~ 的噪音。3 老张把响水壶放到火上，立等水开。（异步阻塞）老张觉得这样傻等意义不大4 老张把响水壶放到火上，去客厅看电视，水壶响之前不再去看它了，响了再去拿壶。（异步非阻塞）老张觉得自己聪明了。所谓同步异步，只是对于水壶而言。普通水壶，同步；响水壶，异步。虽然都能干活，但响水壶可以在自己完工之后，提示老张水开了。这是普通水壶所不能及的。同步只能让调用者去轮询自己（情况2中），造成老张效率的低下。所谓阻塞非阻塞，仅仅对于老张而言。立等的老张，阻塞；看电视的老张，非阻塞。情况1和情况3中老张就是阻塞的，媳妇喊他都不知道。虽然3中响水壶是异步的，可对于立等的老张没有太大的意义。所以一般异步是配合非阻塞使用的，这样才能发挥异步的效用。<br>作者：愚抄<br>链接：<a href="https://www.zhihu.com/question/19732473/answer/23434554">https://www.zhihu.com/question/19732473/answer/23434554</a><br>来源：知乎</li>
<li>IO密集型任务 VS 计算密集型任务<br>所谓IO密集型任务，是指磁盘IO、网络IO占主要的任务，计算量很小。比如请求网页、读写文件等。当然我们在Python中可以利用sleep达到IO密集型任务的目的。<br>所谓计算密集型任务，是指CPU计算占主要的任务，CPU一直处于满负荷状态。比如在一个很大的列表中查找元素（当然这不合理），复杂的加减乘除等。</li>
</ul>
<p><a href="https://zhuanlan.zhihu.com/p/24118476">说了关于异步和爬虫的文章</a><br><a href="https://zhuanlan.zhihu.com/p/24283040">说了多线程与多进程的</a><br><a href="http://www.cnblogs.com/ydf0509/p/7223160.html">说了协程与线程的</a><br><a href="http://blog.csdn.net/lambert310/article/details/51162634">说了为什么要使用进程+协程的方案</a>，很多人都在使用这种方案<br>附加：<br><a href="http://blog.csdn.net/littlethunder/article/details/40983031"> python3下multiprocessing、threading和gevent性能对比</a><br><a href="https://thief.one/2016/11/23/Python-multiprocessing/">Multiprocessing基础</a><br>如果数据量大了，就要把爬虫大概分为URL访问，网页解析，数据库读写等几大类。<br>像URL访问，数据库读写可以用线程或者协程。网页解析用进程，同时，URL访问应该使用异步IO，网页访问等待的时间大大大于CPU操作的时间<br>协程是用户自己来编写调度逻辑的，对CPU来说，协程其实是单线程，所以CPU不用去考虑怎么调度、切换上下文，这就省去了CPU的切换开销，所以协程在一定程度上又好于多线程<br>有些时候线程最多只能开几百个，理论上协程可以开无数个（不过会遇cant watch more than 1024 sockets），如果网速不够的话，其实两个的速度差不多<br>有时还需要考虑下网络IO电脑配置情况（如CPU核数，内存大小等）</p>
<h3 id="2-解决反爬"><a href="#2-解决反爬" class="headerlink" title="2.解决反爬"></a>2.解决反爬</h3><p>爬虫速度上去了，基本都会跟反爬见面了。爬虫与反爬的斗争从有爬虫就开始了，虽然最后都是爬虫的胜利，但也付出了很多代价<br>要解决反爬虫，需要先了解有哪些反爬措施，反爬措施有以下几种：</p>
<ul>
<li><p><strong>基于验证码的反爬虫</strong>，这种反爬是我们从拥有一个网络账号开始就能看得见的反爬技术，而且已经从一开始的传统验证码、逻辑验证码，到现在12306的图片验证码，还有许多网站开始用的滑动验证码，和最近刚出现的那种用鼠标点击一个圆点就能通过的验证码（这种验证码我是暑假也就是7月后才看到的实在不知道他的原理是什么，也是滑动图片验证码的公司出的，好像是利用判断鼠标位置和移动的行为是不是用户来验证的- -）</p>
</li>
<li><p><strong>基于Headers的反爬</strong>，这是一种从请求头Headers进行反爬是比较常见的，大部分网站都有对请求头的User-Agent和Referer字段进行检测，同时也是最容易解决的一种反爬，直接从自己浏览器获取请求头，或搜索一些请求头来使用就可以了（下文不再描述）</p>
</li>
<li><p><strong>基于用户行为的反爬</strong>，通俗来见就是不像人为访问他的网站，例如同一ip短时间内大量的访问页面。</p>
</li>
<li><p><strong>基于动态页面的反爬</strong>，现在越来越多的网站采用动态加载技术，无法直接从页面上获取数据，需要分析Ajax请求，再进行发送接受。</p>
</li>
<li><p><strong>基于页面请求分析</strong>，有些网页在填写表单时会有一些隐藏的表单，他们在你登录时就会为一个值自动赋值，当提交表单时就把这个值提交，如果你的代码没填写这个值时，对面服务器就会拒绝你的访问，不过这个值 一般都很容易找到（例子为知乎的登录）。还有一种是加密数据，直接把用户提交的数据进行加密再传送（例如密码），这时就要通过多次登录来获取到哪些数据是是登录时才生成的，再分析是用哪个方法生成的，有时还有二次登录分开加密数据（例子为百度登录），这种反爬每个网站的规律都不一样，所以要逐一分析，这也是考验一个爬虫开发者的能力。（下文也不再对这种反爬方式再次描述）</p>
<p>了解了一些反爬措施后，我们可以来研究如何解决反爬了。</p>
<h4 id="2-1-解决验证码问题"><a href="#2-1-解决验证码问题" class="headerlink" title="2.1  解决验证码问题"></a>2.1  解决验证码问题</h4></li>
<li><p>COOKIE登录<br>我们可以把登录时获取的cookie获取到，并提取里面的信息，下次使用时再调用出来。具体调用方法得看使用使用的是什么库，不过原理都是提取cookies还有获取这个cookies时所使用的headera一起传给请求那里。</p>
</li>
<li><p>验证码识别<br>验证码识别中的传统验证码识别只要是肯下功夫，通常情况下识别率能达到90%以上了。<br>python的传统验证码识别需要安装tesseract-ocr,pytesseract和pillow<br>pillow主要是用来,把图像进行转换，比如将一个验证码图片进行二值化处理，字符翻转等最后生成一张容易被ocr引擎识别的图片。<br>pytesseract主要用来识别图片里面的内容，如果要识别更多内容，需要用tesseract-ocr来训练，生成数据。<br>还有一些比较奇葩的验证码，可以使用人工打码，不过需要一定的费用，具体打码平台自行百度吧～<br>还有一种这几年非常流行的滑动验证码，这种方法可以使用多账号登录后获取cookie信息再组建cookie池的方法绕行。关于如何破解这种验证码可以<a href="http://www.w2bc.com/article/170660">访问这里</a></p>
</li>
<li><p>移动端网页<br>这部分我不知道要放在哪里比较好- -，我在爬虫时，一般发现电脑端比较难爬取且移动端有我需要获取的数据时我都直接转到移动端了。。。<br>通过修改UA可以达到变成安卓手机，苹果手机或者平板电脑去访问，从而页面变成为移动端的页面，通常开头的WWW都变为M，加入这个页面比较难的话，还可以通过wap开头去访问<br>通常来说，移动端的页面验证码没那么复杂，也没用Ajax技术生成的动态网页</p>
</li>
</ul>
<h4 id="2-2-ip问题"><a href="#2-2-ip问题" class="headerlink" title="2.2 ip问题"></a>2.2 ip问题</h4><p>通常网站都会自行判断同一个IP的访问在一定时间内的访问速度，如果过高时，服务器就会拒绝给这个IP发送信息<br>解决方法有以下几种：<br>-Tor 代理<br>这个可以让你匿名浏览，可以对访问的网站隐藏IP地址，但是他的访问速度比较慢，一般很少人考虑用到</p>
<ul>
<li>VPN<br>这里说的VPN主要是利用VPN提供商可以分配不同的网络线路且自动更换IP，实时性很高，速度也很快，稳定性可靠。不过价格都不低。。。。。</li>
<li>ADSL拨号<br>也就是网上拨号，因为ADSL每次断开重连的时候接受的IP都会有变化，可以利用这个原理来改变IP，不过每次重连的时候时间比较久，所以实时性并不高（手机的打开飞行模式再关闭也是可以这样的）</li>
<li>IP代理池<br>IP代理池如果是商用的也是需要钱的，但是国内有些免费的IP，我们可以通过抓取IP并判断IP是否可以用了来组建IP代理池让自己的爬虫可以调用，当然，已经有一些开源的IP代理池项目了<br>首先是如何自己打造一个IP代理池<br><a href="http://www.cnblogs.com/demon89/p/proxy_ip.html?utm_source=itdadao&utm_medium=referral">第一篇文章</a><br><a href="http://blog.csdn.net/head_cow/article/details/52561637">第二篇文章</a><br>一些开源的代理池<br><a href="https://github.com/qiyeboy/IPProxyPool">IPProxyPool</a><br><a href="https://zhuanlan.zhihu.com/p/24165119">这个有说了设计思路且开源了自己制作的代理池</a></li>
</ul>
<h4 id="2-3动态页面加载问题"><a href="#2-3动态页面加载问题" class="headerlink" title="2.3动态页面加载问题"></a>2.3动态页面加载问题</h4><p>遇到一些需要动态加载的页面可以使用selenium+PhantomJS来解决，不过PhantomJS已经停止维护了，而我经常使用selenium+chrome，听说最近有个<a href="https://zhuanlan.zhihu.com/p/26810049">Headless Chrome</a>，<a href="https://github.com/yesvods/Blog/issues/10">这个网页也有介绍</a>官方文档请点击<a href="https://sites.google.com/a/chromium.org/chromedriver/home">这</a>里（这个网页并没有问题，自行解决）不过我还没了解。。<br>selenium可以对元素进行选取，可以对页面进行操作等等，几乎我们在页面进行的操作他都可以进行操作，如果要深入了解的建议访问<a href="http://selenium-python.readthedocs.io/index.html">官方文档（英文的）</a>或者可以看看这篇文章<a href="http://www.jianshu.com/p/520749be7377">了解一下</a><br>一般selenium+PhantomJS容易被反爬识别到，不建议使用了。。这种爬取方法可以说比较万能，但是速度有点慢</p>
<h4 id="3数据库选择（非次要）"><a href="#3数据库选择（非次要）" class="headerlink" title="3数据库选择（非次要）"></a>3数据库选择（非次要）</h4><p>一开始会总犹豫我爬取的数据放哪里好。现在觉得都无所谓了。<br>因为前面已经说过了，我现在爬取的数量只是十万级别，用哪个数据库都差不多。随心，不过这里放一下看的一些文章。反正我喜欢用mongoDB，不过要注意NOSQL虽说是非关系数据库，不过不是说没关系。NOSQL是 NOT ONLY SQL的意思，这一点要注意下<br><a href="http://blog.csdn.net/lijinqi1987/article/details/51823506">介绍了关系型和非关系型数据库的特点</a><br><a href="http://blog.csdn.net/longxingzhiwen/article/details/53896702">同样是说两大类数据库的区别，不过更详细，推荐看这个</a><br><a href="http://www.cnblogs.com/binyue/archive/2013/10/21/3380750.html">顺便放一个说到倒排索引的文章</a>大型数据读写时可以用到倒排索引。起这名字的人好奇葩，如果翻译为互换位置索引我还是容易理解，翻译为倒排，我以为是从后面数过来- -<br><a href="http://blog.csdn.net/chenfengdejuanlian/article/details/54574995">这篇文章讲了下关系型数据库的限制以及发展（简述）</a><br>最后推荐下MongoDB的中文社区<a href="http://mongoing.com/">点击这里跳转</a></p>
]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>Python数据结构以及排序</title>
    <url>/2017/08/01/6/</url>
    <content><![CDATA[<h3 id="前记："><a href="#前记：" class="headerlink" title="前记："></a>前记：</h3><p>Python自带了一些数据结构,不需要自己实现既可以快速调用.</p>
<span id="more"></span>

<h3 id="1-对数据的操作"><a href="#1-对数据的操作" class="headerlink" title="1.对数据的操作"></a>1.对数据的操作</h3><ul>
<li>从序列提取变量<br>首先是两个简单的提取变量栗子<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">&gt;&gt;&gt;p = (<span class="hljs-number">4</span>,<span class="hljs-number">5</span>)<br>&gt;&gt;&gt;x, y = p<br>&gt;&gt;&gt;x<br><span class="hljs-number">4</span><br>&gt;&gt;&gt;y<br><span class="hljs-number">5</span><br></code></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">&gt;&gt;&gt;data = [<span class="hljs-string">&#x27;ACME&#x27;</span>,  <span class="hljs-number">50</span>, <span class="hljs-number">91.1</span>, (<span class="hljs-number">2017</span>, <span class="hljs-number">8</span>, <span class="hljs-number">1</span>) ]<br>&gt;&gt;&gt;name, shares, price, (year, mon, day) = data<br>&gt;&gt;&gt;name<br><span class="hljs-string">&#x27;ACME&#x27;</span><br>&gt;&gt;&gt;shares<br><span class="hljs-number">50</span><br>&gt;&gt;&gt;price<br><span class="hljs-number">91.1</span><br>&gt;&gt;&gt;year<br><span class="hljs-number">2017</span><br>&gt;&gt;&gt;mon<br><span class="hljs-number">8</span><br>&gt;&gt;&gt;day<br><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>
python中的字符串可以分解（中文就不行。。。），在python中还可以通过函数来处理<br>如这个栗子，去掉序列的第一个和最后一个数字<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">drop_first_last</span>(<span class="hljs-params">grades</span>):</span><br>    first, *middle, last = grades<br>    <span class="hljs-keyword">return</span> avg(middle)<br></code></pre></td></tr></table></figure></li>
<li>保留后面N个元素（使用到Python里面的collections模块）<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> deque<br><span class="hljs-meta">&gt;&gt;&gt; </span>q = deque(maxlen = <span class="hljs-number">3</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>q.append(<span class="hljs-number">1</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>q.append(<span class="hljs-number">2</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>q.append(<span class="hljs-number">3</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>q<br>deque([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], maxlen=<span class="hljs-number">3</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>q.append(<span class="hljs-number">4</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>q.append(<span class="hljs-number">4</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>q<br>deque([<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>], maxlen=<span class="hljs-number">3</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>q.append(<span class="hljs-number">4</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>q.append(<span class="hljs-number">5</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>q.append(<span class="hljs-number">6</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>q.append(<span class="hljs-number">7</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>q<br>deque([<span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>], maxlen=<span class="hljs-number">3</span>)<br><br></code></pre></td></tr></table></figure></li>
<li>控制字典元素顺序<br>python中的字典元素是没有顺序的，OrderedDict()可以让字典拥有顺序<br>注：（1）如果要josn字段也拥有顺序，那么josn.dumps(d)就OK了<br>（2）OrderedDict()的大小是普通字典的两倍<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> OrderedDict<br><span class="hljs-meta">&gt;&gt;&gt; </span>d = OrderedDict()<br><span class="hljs-meta">&gt;&gt;&gt; </span>d[<span class="hljs-string">&#x27;foo&#x27;</span>] = <span class="hljs-number">1</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>d[<span class="hljs-string">&#x27;bar&#x27;</span>] = <span class="hljs-number">2</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>d[<span class="hljs-string">&#x27;spam&#x27;</span>] = <span class="hljs-number">3</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>d[<span class="hljs-string">&#x27;grok&#x27;</span>] = <span class="hljs-number">4</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">for</span> key <span class="hljs-keyword">in</span> d:<br><span class="hljs-meta">... </span>    print(key, d[key])<br><span class="hljs-meta">... </span><br>foo <span class="hljs-number">1</span><br>bar <span class="hljs-number">2</span><br>spam <span class="hljs-number">3</span><br>grok <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure>
ps：字典里面有个zip函数可以将字典的key值和value值进行反转<br>注意：zip()创建的是一个迭代器，内容只能被消费一次，例如只能print一次zipdict，第二次print时会报错<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">dict</span> = &#123;<span class="hljs-string">&#x27;a&#x27;</span>:<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;b&#x27;</span>:<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;c&#x27;</span>:<span class="hljs-number">3</span>&#125;<br>zipdict = <span class="hljs-built_in">zip</span>(<span class="hljs-built_in">dict</span>.vakues(), <span class="hljs-built_in">dict</span>.keys())<br></code></pre></td></tr></table></figure></li>
<li>找出列表中出现最频繁的单词<br>利用collections模块中的Counter类的most_commomn()方法可以直接显示结果<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> Counter<br><span class="hljs-built_in">list</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">6</span>,<span class="hljs-number">2</span>,<span class="hljs-number">7</span>,<span class="hljs-number">2</span>,<span class="hljs-number">8</span>,<span class="hljs-number">1</span>,<span class="hljs-number">9</span>,<span class="hljs-number">3</span>]<br>list_counts = Counter(<span class="hljs-built_in">list</span>)<br>top_three = list_counts.most_common(<span class="hljs-number">3</span>)<br>print(top_three)<br></code></pre></td></tr></table></figure>
显示结果：[(1, 4), (2, 3), (3, 2)]<br>当然，也可以用count计数，再用sorted进行排序<h3 id="2-语法糖"><a href="#2-语法糖" class="headerlink" title="2.语法糖"></a>2.语法糖</h3></li>
<li>map()函数<br>map()接受一个Iterable和一个函数，map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span>(<span class="hljs-params">x</span>):</span><br><span class="hljs-meta">... </span>    <span class="hljs-keyword">return</span> x * x<br>...<br><span class="hljs-meta">&gt;&gt;&gt; </span>r = <span class="hljs-built_in">map</span>(f, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>])<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">list</span>(r)<br>[<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">9</span>, <span class="hljs-number">16</span>, <span class="hljs-number">25</span>, <span class="hljs-number">36</span>, <span class="hljs-number">49</span>, <span class="hljs-number">64</span>, <span class="hljs-number">81</span>]<br></code></pre></td></tr></table></figure>
<ul>
<li>reduce()函数<br>reduce把一个函数作用在一个序列[x1, x2, x3, …]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> reduce<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span>(<span class="hljs-params">x, y</span>):</span><br><span class="hljs-meta">... </span>    <span class="hljs-keyword">return</span> x + y<br>...<br><span class="hljs-meta">&gt;&gt;&gt; </span>reduce(add, [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>])<br><span class="hljs-number">25</span><br></code></pre></td></tr></table></figure></li>
<li>filter()函数<br>filter()把传入的函数依次作用于每个元素，然后根据返回值是True还是False决定保留还是丢弃该元素。<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">is_odd</span>(<span class="hljs-params">n</span>):</span><br>    <span class="hljs-keyword">return</span> n % <span class="hljs-number">2</span> == <span class="hljs-number">1</span><br><br><span class="hljs-built_in">list</span>(<span class="hljs-built_in">filter</span>(is_odd, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">15</span>]))<br><span class="hljs-comment"># 结果: [1, 5, 9, 15]</span><br></code></pre></td></tr></table></figure></li>
<li>sorted()函数<br>sorted()函数也是一个高阶函数，它不仅可以排序，它还可以接收一个key函数来实现自定义的排序<br>默认排序<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">sorted</span>([<span class="hljs-number">36</span>, <span class="hljs-number">5</span>, -<span class="hljs-number">12</span>, <span class="hljs-number">9</span>, -<span class="hljs-number">21</span>])<br>[-<span class="hljs-number">21</span>, -<span class="hljs-number">12</span>, <span class="hljs-number">5</span>, <span class="hljs-number">9</span>, <span class="hljs-number">36</span>]<br></code></pre></td></tr></table></figure>
用key值实现排序<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">sorted</span>([<span class="hljs-number">36</span>, <span class="hljs-number">5</span>, -<span class="hljs-number">12</span>, <span class="hljs-number">9</span>, -<span class="hljs-number">21</span>], key=<span class="hljs-built_in">abs</span>)<br>[<span class="hljs-number">5</span>, <span class="hljs-number">9</span>, -<span class="hljs-number">12</span>, -<span class="hljs-number">21</span>, <span class="hljs-number">36</span>]<br></code></pre></td></tr></table></figure></li>
<li>匿名函数<br>在Python中，对匿名函数提供了有限支持。还是以map()函数为例，计算f(x)=x2时，除了定义一个f(x)的函数外，还可以直接传入匿名函数：<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-keyword">lambda</span> x: x * x, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>]))<br>[<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">9</span>, <span class="hljs-number">16</span>, <span class="hljs-number">25</span>, <span class="hljs-number">36</span>, <span class="hljs-number">49</span>, <span class="hljs-number">64</span>, <span class="hljs-number">81</span>]<br></code></pre></td></tr></table></figure>
通过对比可以看出，匿名函数lambda x: x * x实际上就是：<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span>(<span class="hljs-params">x</span>):</span><br>    <span class="hljs-keyword">return</span> x * x<br></code></pre></td></tr></table></figure>
匿名函数有个限制，就是只能有一个表达式，不用写return，返回值就是该表达式的结果<h3 id="3-算法排序"><a href="#3-算法排序" class="headerlink" title="3.算法排序"></a>3.算法排序</h3>虽然python本身有sorted，但还是了解一下比较好，毕竟你校招面试时别人问你用python写冒泡排序你直接写sorted()吧。。。（虽然我觉得这样的面试很奇怪，知道这部分思想就行了。。。）<br>排序按模型分类有：</li>
</ul>
<p>1.每次比较只有2个元素。包括插入排序，快速排序，堆排序，归并排序，冒泡排序。他们最好的效率只能到O(nlgn).可以通过画决策树证明。 一共有n!个节点。高度h的数最多有2^h个节点。所以有2^h≥n!。通过<a href="https://baike.baidu.com/item/%E6%96%AF%E7%89%B9%E6%9E%97%E5%85%AC%E5%BC%8F/9583086?fr=aladdin">斯特林公式</a>可以得证。<br>2.对数据做些操作。譬如计数排序。</p>
<ul>
<li>冒泡算法<br>之所以被叫为冒泡算法，是因为他就像泡泡一样，越大的元素会经由交换慢慢“浮”到数列的顶端<br>而冒泡算法需要：<br>（1）共循环 n-1 次<br>（2）每次循环中，如果 前面的数大于后面的数，就交换<br>（3）设置一个标签，如果上次没有交换，就说明这个是已经好了的（节省不必要的计算过程）。<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">bubble_sort</span>(<span class="hljs-params">l</span>):</span><br>    flag = <span class="hljs-literal">True</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(l)-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">if</span> flag: <br>            flag = <span class="hljs-literal">False</span><br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i):<br>                <span class="hljs-keyword">if</span> l[j] &gt; l[j + <span class="hljs-number">1</span>]:<br>                    l[j], l[j+<span class="hljs-number">1</span>] = l[j+<span class="hljs-number">1</span>], l[j]<br>                    flag = <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">break</span><br>num_list = [<span class="hljs-number">21</span>,<span class="hljs-number">44</span>,<span class="hljs-number">2</span>,<span class="hljs-number">45</span>,<span class="hljs-number">33</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">67</span>]<br>bubble_sort(num_list)<br>print(num_list)  <span class="hljs-comment"># [2, 3, 4, 21, 33, 44, 45, 67]</span><br></code></pre></td></tr></table></figure></li>
<li>选择排序<br>选择排序（Selection sort）是一种简单直观的排序算法。它的工作原理是每一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完。<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">insert_sort</span>(<span class="hljs-params">num_list</span>):</span><br>  <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(num_list)-<span class="hljs-number">1</span>):<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i+<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(num_list)):<br>      <span class="hljs-keyword">if</span> num_list[i]&gt;num_list[j]:<br>        num_list[i],num_list[j] = num_list[j],num_list[i]<br>  <span class="hljs-keyword">return</span> num_list<br><br>li = [<span class="hljs-number">21</span>,<span class="hljs-number">44</span>,<span class="hljs-number">2</span>,<span class="hljs-number">45</span>,<span class="hljs-number">33</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">67</span>]<br>print(insert_sort(li))<br></code></pre></td></tr></table></figure></li>
<li>插入排序<br>插入排序总结：</li>
</ul>
<p>1.当前需要排序的元素(array[i])，跟已经排序好的最后一个元素比较(array[i-1])，如果满足条件继续执行后面的程序，否则循环到下一个要排序的元素。<br>2.缓存当前要排序的元素的值，以便找到正确的位置进行插入。<br>3.排序的元素跟已经排序号的元素比较，比它大的向后移动(升序)。<br>4.要排序的元素，插入到正确的位置。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">insert_sort</span>(<span class="hljs-params">array</span>):</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(array)):<br>        <span class="hljs-keyword">if</span> array[i - <span class="hljs-number">1</span>] &gt; array[i]:<br>            temp = array[i]     <span class="hljs-comment"># 当前需要排序的元素</span><br>            index = i           <span class="hljs-comment"># 用来记录排序元素需要插入的位置</span><br>            <span class="hljs-keyword">while</span> index &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> array[index - <span class="hljs-number">1</span>] &gt; temp:<br>                array[index] = array[index - <span class="hljs-number">1</span>]     <span class="hljs-comment"># 把已经排序好的元素后移一位，留下需要插入的位置</span><br>                index -= <span class="hljs-number">1</span><br>                array[index] = temp <span class="hljs-comment"># 把需要排序的元素，插入到指定位置</span><br>    <span class="hljs-keyword">return</span> array<br>li = [<span class="hljs-number">21</span>,<span class="hljs-number">44</span>,<span class="hljs-number">2</span>,<span class="hljs-number">45</span>,<span class="hljs-number">33</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">67</span>]<br>print(insert_sort(li))<br></code></pre></td></tr></table></figure>
<p>这段程序主要就在while里面，每增加一个数，就要扔进while里面，再从里面列表的最后一个数开始比较，直到这个新增加的数比列表里面的数大才停止比较</p>
<ul>
<li><p>归并排序<br>归并排序描述起来好简单。就是把规模分成两组，一组都小于某个数n, 另一组都大于等于n。于是规模为n的问题，变成了2个n/2规模的问题。一次次这样划分下去，直到只剩下一个元素,一个元素当然是排好充的,然后再两两合并,直到得到原始问题的解。<br>其最坏情况是Θ(nlgn)<br>这个思想是分治法<br>可以看做是把他一直一半一半的切，切到为一个数据，再用类似选择排序那样慢慢比较大小，最后慢慢组合起来</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#升序</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">merge_sort</span>(<span class="hljs-params">literal</span>):</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">divide</span>(<span class="hljs-params">literal</span>):</span><br>        end = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">len</span>(literal)/<span class="hljs-number">2</span>)<br>        <span class="hljs-keyword">return</span> (literal[:end], literal[end:])<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">conquer</span>(<span class="hljs-params">literal</span>):</span><br>        <span class="hljs-keyword">return</span> merge_sort(literal)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">merge</span>(<span class="hljs-params">literal1, literal2</span>):</span><br>        ret = []<br>        len1 = <span class="hljs-built_in">len</span>(literal1)<br>        len2 = <span class="hljs-built_in">len</span>(literal2)<br>        i1 = <span class="hljs-number">0</span><br>        i2 = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> len1 <span class="hljs-keyword">or</span> len2:<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> len1 <span class="hljs-keyword">and</span> len2:<br>                ret.extend(literal2[i2:])<br>                <span class="hljs-keyword">return</span> ret<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> len2 <span class="hljs-keyword">and</span> len1:<br>                ret.extend(literal1[i1:])<br>                <span class="hljs-keyword">return</span> ret<br><br>            v1 = literal1[i1]<br>            v2 = literal2[i2]<br>            <span class="hljs-keyword">if</span> v1 &lt;= v2:<br>                ret.append(v1)<br>                len1 -= <span class="hljs-number">1</span><br>                i1 += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                ret.append(v2)<br>                len2 -= <span class="hljs-number">1</span><br>                i2 += <span class="hljs-number">1</span><br>            print(ret,<span class="hljs-string">&#x27;c&#x27;</span>)<br>        <span class="hljs-keyword">return</span> ret<br> <br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> literal <span class="hljs-keyword">or</span> <span class="hljs-built_in">len</span>(literal) == <span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">return</span> literal<br><br>    literal1, literal2 = divide(literal)<br>    print(literal1,literal2,<span class="hljs-string">&#x27;a&#x27;</span>)<br>    literal1 = conquer(literal1)<br>    literal2 = conquer(literal2)<br>    print(literal1,literal2,<span class="hljs-string">&#x27;b&#x27;</span>)<br>    <span class="hljs-keyword">return</span>  merge(literal1, literal2)<br>li = [<span class="hljs-number">21</span>,<span class="hljs-number">44</span>,<span class="hljs-number">2</span>,<span class="hljs-number">45</span>,<span class="hljs-number">33</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">67</span>]<br>print(merge_sort(li))<br></code></pre></td></tr></table></figure>
</li>
<li><p>快速排序<br>快速排序（Quicksort）是对冒泡排序的一种改进。由C. A. R. Hoare在1962年提出。它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">quick_sort</span>(<span class="hljs-params">num_list</span>):</span><br><br>  <span class="hljs-keyword">if</span> num_list == []:<br>    <span class="hljs-keyword">return</span> num_list<br>  smallList = []<br>  bigList = []<br>  middleElement = num_list[<span class="hljs-number">0</span>]<br>  <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> num_list[<span class="hljs-number">1</span>:]:<br>    <span class="hljs-keyword">if</span> i &lt;= middleElement:<br>      smallList.append(i)<br>    <span class="hljs-keyword">else</span>:<br>      bigList.append(i)<br>  <span class="hljs-keyword">return</span> quick_sort(smallList)+[middleElement]+quick_sort(bigList)<br>li = [<span class="hljs-number">21</span>,<span class="hljs-number">44</span>,<span class="hljs-number">2</span>,<span class="hljs-number">45</span>,<span class="hljs-number">33</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">67</span>]<br>print(quick_sort(li))<br></code></pre></td></tr></table></figure></li>
<li><p>算法排序小总结<br>当然还有堆排（暂时不知道怎么写- -），基数排序等/这些都是内部排序(内部排序是数据记录在内存中进行排序)，当n较大，则应采用时间复杂度为O(nlog2n)的排序方法：快速排序、堆排序或归并排序序<br>这些排序里面，快速排序是目前基于比较的内部排序中被认为是最好的方法，当待排序的关键字是随机分布时，快速排序的平均时间最短；插入排序是稳定的；<br>在写总结时，顺便百度了一下，结果发现有个dalao写了<a href="http://blog.csdn.net/hguisu/article/details/7776068/">这个</a>看后受益匪浅啊～</p>
</li>
</ul>
]]></content>
      <categories>
        <category>编程基础</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>编程基础</tag>
      </tags>
  </entry>
  <entry>
    <title>[Python玩微信（2）:wxpy的进阶]</title>
    <url>/2017/07/31/5_wxpy_2/</url>
    <content><![CDATA[<p>在网上发现了wxpy这个库，可以调取一些微信API来玩转微信<br>由于图截得不太好，看图的请访问<a href="http://www.jianshu.com/p/ef75e97146c2">这里</a></p>
<span id="more"></span>
<h2 id="Python玩微信（2）-wxpy的进阶"><a href="#Python玩微信（2）-wxpy的进阶" class="headerlink" title="Python玩微信（2）:wxpy的进阶"></a>Python玩微信（2）:wxpy的进阶</h2><h3 id="前记：其实我也不知道这个算不算进阶-。期初目的是因为我脑海里面有一个设想，通过微信机器人，自动完成对协会招新群的自动添加和群管理，还有自动接受他人报名协会，这些设想在当我发现WXPY这个库后才可以得以实现。一开始想从公众号那边入手的，但自己没有服务器很难弄，如果从其他现成的来弄这些功能的话，1是有限制，2是免费的量很少，3当然是学了就得拿来用一用，试一试。所以就开始写这些了（完整代码见最后面）"><a href="#前记：其实我也不知道这个算不算进阶-。期初目的是因为我脑海里面有一个设想，通过微信机器人，自动完成对协会招新群的自动添加和群管理，还有自动接受他人报名协会，这些设想在当我发现WXPY这个库后才可以得以实现。一开始想从公众号那边入手的，但自己没有服务器很难弄，如果从其他现成的来弄这些功能的话，1是有限制，2是免费的量很少，3当然是学了就得拿来用一用，试一试。所以就开始写这些了（完整代码见最后面）" class="headerlink" title="前记：其实我也不知道这个算不算进阶- -。期初目的是因为我脑海里面有一个设想，通过微信机器人，自动完成对协会招新群的自动添加和群管理，还有自动接受他人报名协会，这些设想在当我发现WXPY这个库后才可以得以实现。一开始想从公众号那边入手的，但自己没有服务器很难弄，如果从其他现成的来弄这些功能的话，1是有限制，2是免费的量很少，3当然是学了就得拿来用一用，试一试。所以就开始写这些了（完整代码见最后面）"></a>前记：其实我也不知道这个算不算进阶- -。期初目的是因为我脑海里面有一个设想，通过微信机器人，自动完成对协会招新群的自动添加和群管理，还有自动接受他人报名协会，这些设想在当我发现<a href="http://wxpy.readthedocs.io/zh/latest/index.html">WXPY</a>这个库后才可以得以实现。一开始想从公众号那边入手的，但自己没有服务器很难弄，如果从其他现成的来弄这些功能的话，1是有限制，2是免费的量很少，3当然是学了就得拿来用一用，试一试。所以就开始写这些了（完整代码见最后面）</h3><h3 id="1-自动添加好友"><a href="#1-自动添加好友" class="headerlink" title="1.自动添加好友"></a>1.自动添加好友</h3><p>首先为了自动添加，所以先注册一个好友添加功能的消息，并当好友添加后，自动回复</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">addfriend_request = <span class="hljs-string">&#x27;加好友&#x27;</span>  <span class="hljs-comment">#自动添加好友的条件</span><br><br><br><span class="hljs-comment"># 注册好友请求类消息</span><br><span class="hljs-meta">@bot.register(<span class="hljs-params">msg_types=FRIENDS,enabled=<span class="hljs-literal">True</span></span>)</span><br><span class="hljs-comment"># 自动接受验证信息中包含 &#x27;wxpy&#x27; 的好友请求</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">auto_accept_friends</span>(<span class="hljs-params">msg</span>):</span><br>    <span class="hljs-comment"># 判断好友请求中的验证文本</span><br>    <span class="hljs-keyword">if</span> addfriend_request <span class="hljs-keyword">in</span> msg.text.lower():<br>        <span class="hljs-comment"># 接受好友 (msg.card 为该请求的用户对象)</span><br>        new_friend = bot.accept_friend(msg.card)<br>        <span class="hljs-comment"># 或 new_friend = msg.card.accept()</span><br>        <span class="hljs-comment"># 向新的好友发送消息</span><br>        new_friend.send(<span class="hljs-string">&#x27;机器人自动接受了你的请求,你可以任意回复获取功能菜单，若机器人没回复菜单则表明机器人尚未工作，请等待&#x27;</span>)<br></code></pre></td></tr></table></figure>
<h3 id="2-自动回复好友"><a href="#2-自动回复好友" class="headerlink" title="2.自动回复好友"></a>2.自动回复好友</h3><p>好友通过非关键字发送可以获取机器人的功能菜单，再通过相应的命令进入其他功能，如果好友没有发送正确的命令，则return 开始菜单</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><br><span class="hljs-meta">@bot.register(<span class="hljs-params">Friend, msg_types=TEXT</span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">exist_friends</span>(<span class="hljs-params">msg</span>):</span><br>    <span class="hljs-keyword">if</span> menu_1 <span class="hljs-keyword">in</span> msg.text.lower():<br>    	invite(msg.sender)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> invite_text <br><br></code></pre></td></tr></table></figure>
<ul>
<li>拉好友入群<br>当好友输入的命令等同于menu_1定义的命令时，机器人自动发送群的邀请给好友，好友点击后可以进入<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">admin_puids = <span class="hljs-built_in">frozenset</span>([<span class="hljs-string">&#x27;XX&#x27;</span>, <span class="hljs-string">&#x27;YY&#x27;</span>])   <span class="hljs-comment">#不可变集合</span><br>admins = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-keyword">lambda</span> x: bot.friends().search(puid=x), admin_puids))<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">invite</span>(<span class="hljs-params">user</span>):</span><br>    groups = <span class="hljs-built_in">sorted</span>(bot.groups(update=<span class="hljs-literal">True</span>).search(group_name),<br>                    key=<span class="hljs-keyword">lambda</span> x: x.name)   <span class="hljs-comment">#sorted用于排序，lambda x:x.name用于群名排序</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(groups) &gt; <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">for</span> group <span class="hljs-keyword">in</span> groups:<br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(group.members) == <span class="hljs-number">500</span>:<br>                <span class="hljs-keyword">continue</span>    <br>            <span class="hljs-keyword">if</span> user <span class="hljs-keyword">in</span> group:<br>                content = <span class="hljs-string">&quot;您已经加入了&#123;&#125; [微笑]&quot;</span>.<span class="hljs-built_in">format</span>(group.nick_name)   <span class="hljs-comment">#经过format格式化的内容传递到&#123;&#125;</span><br>                user.send(content)<br>            <span class="hljs-keyword">else</span>:<br>                group.add_members(user, use_invitation=<span class="hljs-literal">True</span>)<br>            <span class="hljs-keyword">return</span><br>        <span class="hljs-keyword">else</span>:<br>            next_topic = group_tmpl.<span class="hljs-built_in">format</span>(re.search(<span class="hljs-string">r&#x27;\d+&#x27;</span>, s).group() + <span class="hljs-number">1</span>)  <span class="hljs-comment">#当前群的名字后面+1</span><br>            new_group = bot.create_group(admins, topic=next_topic)<br>            <span class="hljs-comment">#以上3句代码的解释为：利用for if else语句进行判断，如果从查找的群名里面找不到对应的群就自动创建一个新群并添加进去</span><br>    <span class="hljs-keyword">else</span>:<br>        print(<span class="hljs-string">&#x27;Invite Failed&#x27;</span>)<br></code></pre></td></tr></table></figure></li>
<li>表单填写<br>先发送填写要求和模板给好友，因为不是表单填写，而且我采用切片提取，所以提取的要求比较高，要求好友的填写要规范<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">elif</span> menu_2 <span class="hljs-keyword">in</span> msg.text.lower():<br>    content_2_1 = <span class="hljs-string">&quot;请复制下面的模板回复\nps：部门可以多填，如果是技术部和Hockey就填写 部门：技术部、Hockey\n填写示例：\n姓名：小明\n学号：111111111\n电话：18888888888\n部门：技术部&quot;</span><br>    content_2_2 = <span class="hljs-string">&quot;报名表\n姓名:\n学号:\n电话:\n部门:&quot;</span><br>    msg.sender.send(content_2_1)<br>    msg.sender.send(content_2_2)<br></code></pre></td></tr></table></figure>
  我选择把学号当为主要查询目标（后来想一想，应该是电话号码啊，如果不写入电话号码，怎么联系啊- -）<br>  先把填写的东东分类提取出来，并和判断是否缴费的一起写入list<br>  再读取表的内容，查看学号是否填写，如果没有就开始写入，最后再进行是否写入成功的判定<br>  注意：写入时要改为“a”即追加模式，不然会覆盖表<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#写表函数</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">table</span>(<span class="hljs-params">user, text</span>):</span><br>    <span class="hljs-comment">#提取用户的文本，把有用的写入表里</span><br>    msg_text = text<br>    tables = msg_text.split(<span class="hljs-string">&#x27;\n&#x27;</span>)<br>    table_name = tables[<span class="hljs-number">1</span>].split(<span class="hljs-string">&#x27;:&#x27;</span>)[<span class="hljs-number">1</span>]<br>    table_stu_num = tables[<span class="hljs-number">2</span>].split(<span class="hljs-string">&#x27;:&#x27;</span>)[<span class="hljs-number">1</span>]<br>    table_phone_num = tables[<span class="hljs-number">3</span>].split(<span class="hljs-string">&#x27;:&#x27;</span>)[<span class="hljs-number">1</span>]<br>    table_department = tables[<span class="hljs-number">4</span>].split(<span class="hljs-string">&#x27;:&#x27;</span>)[<span class="hljs-number">1</span>]<br>    table_list = [table_name, table_stu_num, table_phone_num, table_department, <span class="hljs-string">&#x27;等待缴费&#x27;</span>]<br>    user.send(<span class="hljs-string">&#x27;请稍等，后台处理中&#x27;</span>)<br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(csv_1, <span class="hljs-string">&#x27;r&#x27;</span>) <span class="hljs-keyword">as</span> f:   <span class="hljs-comment">#检查表里是否有登记的学号</span><br>        fr_csv = csv.reader(f)<br>        <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> fr_csv:<br>            <span class="hljs-keyword">if</span> table_stu_num <span class="hljs-keyword">in</span> row:<br>                user.send(<span class="hljs-string">&#x27;报名失败，该学号已经登记过了&#x27;</span>)<br>                <span class="hljs-keyword">break</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(csv_1, <span class="hljs-string">&#x27;a&#x27;</span>) <span class="hljs-keyword">as</span> f:          <span class="hljs-comment">#写入表</span><br>                fw_csv = csv.writer(f)<br>                fw_csv.writerow(table_list)<br>            <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(csv_1, <span class="hljs-string">&#x27;r&#x27;</span>) <span class="hljs-keyword">as</span> f:          <span class="hljs-comment">#查看是否写入成功</span><br>                fr_csv = csv.reader(f)<br>                <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> fr_csv:<br>                    <span class="hljs-keyword">if</span> table_stu_num <span class="hljs-keyword">in</span> row:<br>                        user.send(<span class="hljs-string">&#x27;报名成功,请回复‘支付宝’或者‘微信’进行支付&#x27;</span>)<br>                        <span class="hljs-keyword">break</span><br>                <span class="hljs-keyword">else</span>:<br>                    user.send(<span class="hljs-string">&#x27;报名失败，请重新报名或者联系管理员&#x27;</span>)<br></code></pre></td></tr></table></figure></li>
<li>查询<br>根据用户输入的学号查看是否缴费成功<br>设想是，用户交钱后，管理查看支付宝跟句是否缴费把“等待缴费”改为“缴费成功”<br>程序再次打开文件时就能进行查询了<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#查询表函数</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">check</span>(<span class="hljs-params">user, text</span>):</span><br>    check_text = text.split(<span class="hljs-string">&#x27;:&#x27;</span>)[<span class="hljs-number">1</span>]<br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(csv_1, <span class="hljs-string">&#x27;r&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>        fr_csv = csv.reader(f)<br>        <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> fr_csv:<br>            <span class="hljs-keyword">if</span> check_text <span class="hljs-keyword">in</span> row:<br>                user.send(<span class="hljs-string">&#x27;登记信息如下，如有疑问请联系管理员&#x27;</span>)<br>                user.send(<span class="hljs-string">&#x27;学号:&#x27;</span>+row[<span class="hljs-number">1</span>]+<span class="hljs-string">&quot;\n缴费情况:&quot;</span>+row[-<span class="hljs-number">1</span>])<br>                <span class="hljs-keyword">break</span><br>        <span class="hljs-keyword">else</span>:<br>            user.send(<span class="hljs-string">&#x27;暂无学号登记记录&#x27;</span>)	<br></code></pre></td></tr></table></figure></li>
<li>联系管理员（分享名片）<br>通过分享名片，让需要联系管理员的好友自己添加管理员<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">elif</span> <span class="hljs-string">&#x27;管理员&#x27;</span> <span class="hljs-keyword">in</span> msg.text:<br>    msg.sender.send(<span class="hljs-string">&#x27;请添加名片联系管理员&#x27;</span>)<br>    msg.sender.send_raw_msg(<br>    <span class="hljs-comment"># 名片的原始消息类型</span><br>    raw_type=<span class="hljs-number">42</span>,<br>    <span class="hljs-comment"># 注意 `username` 在这里应为微信 ID，且被发送的名片必须为自己的好友</span><br>    raw_content=<span class="hljs-string">&#x27;&lt;msg username=&quot;guanliyuan&quot; nickname=&quot;管理员&quot;/&gt;&#x27;</span><br>    )	<br></code></pre></td></tr></table></figure>
<h3 id="3-处理来自管理员的消息"><a href="#3-处理来自管理员的消息" class="headerlink" title="3.处理来自管理员的消息"></a>3.处理来自管理员的消息</h3>这部分比较简单，原本设想的许多功能觉得实用性不高就不添加了（如好友进群@好友提示），管理员这个充当开关的角色也就没什么功能了，只剩下管理员回复备份时能获得表格文件<br>注意：由于注册机制的问题，所以只能优先匹配后注册的（可以查看原文档），所以注册管理员的要放在注册好友回复后面，切管理员无法以好友身份跟机器人互动<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#处理管理员信息</span><br><span class="hljs-meta">@bot.register(<span class="hljs-params">adminer, msg_types=TEXT</span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">adminer</span>(<span class="hljs-params">msg</span>):</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;备份&#x27;</span> <span class="hljs-keyword">in</span> msg.text:<br>    	msg.sender.send_file(<span class="hljs-string">&#x27;test.csv&#x27;</span>)<br>    <span class="hljs-keyword">else</span>:<br>    	<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;请检查命令是否输入正确&quot;</span> 	<br></code></pre></td></tr></table></figure>
<h3 id="4-群聊功能"><a href="#4-群聊功能" class="headerlink" title="4.群聊功能"></a>4.群聊功能</h3>采用判断被@时，返回True来获取信息。如果文字里面含有“踢出”且消息来自于管理员时，可以踢掉“踢出”字段后面被@的人。因为只有管理员可以实现这个功能，一般管理员对踢出后面那个人也是自己点头像@的，所以我偷懒省去了被@的不是用户里的人的返回语句了-。-<br>如果语句里不含有踢出的话，就是机器人聊天模式了，所有人都可以和机器人聊天，而且WXPY封装挺不错的，几句代码就可以了（<a href="http://wxpy.readthedocs.io/zh/latest/utils.html#i">见这里</a>），而且他能自动识别用户A上下文，A的问题，B获取不了（描述不太好，见图）<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#群聊管理</span><br><span class="hljs-meta">@bot.register(<span class="hljs-params">my_group, msg_types=TEXT</span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">group</span>(<span class="hljs-params">msg</span>):</span><br>    <span class="hljs-keyword">if</span> msg.is_at :<br>        <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;踢出&#x27;</span> <span class="hljs-keyword">in</span> msg.text:<br>            <span class="hljs-keyword">if</span> msg.member == group_admin :<br>                <span class="hljs-keyword">for</span> member_name <span class="hljs-keyword">in</span> msg.text.split(<span class="hljs-string">&#x27;@&#x27;</span>)[<span class="hljs-number">2</span>:]:<br>                    print(member_name)<br>                    re_name = my_group.members.search(member_name)[<span class="hljs-number">0</span>].remove()<br>                    print(re_name)<br>                    msg.sender.send(<span class="hljs-string">&quot;已经移出:&quot;</span>+member_name)<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;你不是管理员不能进行踢人操作&quot;</span><br>        <span class="hljs-keyword">else</span>:<br>            xiaoi.do_reply(msg)		<br></code></pre></td></tr></table></figure>
<h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> wxpy <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> csv<br><br>addfriend_request = <span class="hljs-string">&#x27;加好友&#x27;</span>  <span class="hljs-comment">#自动添加好友的条件</span><br>admin_request_name = <span class="hljs-string">&#x27;微信名&#x27;</span>    <span class="hljs-comment">#定义管理员微信名（必须是机器人的好友）  ps：raw_content字段需要自己手动更改微信名，微信号</span><br>admin_request_num = <span class="hljs-string">&#x27;weixinhao&#x27;</span>   <span class="hljs-comment">#定义管理员微信号（必须是机器人的好友）</span><br>invite_text = <span class="hljs-string">&quot;Helo!回复&#x27;功能 + 数字&#x27;获取对应功能\n1.我要加群\n2.我要加入协会\n3.我要购买鞋子\n4.了解我们\n5.我需要帮助\n例如：要获取我要加群的功能时回复\n\n功能1&quot;</span>  <span class="hljs-comment">#任意回复获取的菜单</span><br>group_name = <span class="hljs-string">&#x27;17中南轮滑协会萌新裙&#x27;</span>    <span class="hljs-comment">#定义要查找群的名字</span><br>menu_1 = <span class="hljs-string">&#x27;功能1&#x27;</span>   <span class="hljs-comment">#菜单选项1 定义加群的条件</span><br>menu_2 = <span class="hljs-string">&#x27;功能2&#x27;</span>  <span class="hljs-comment">#菜单选项2</span><br>menu_3 = <span class="hljs-string">&#x27;功能3&#x27;</span>  <span class="hljs-comment">#菜单选项3</span><br>menu_4 = <span class="hljs-string">&#x27;功能4&#x27;</span>  <span class="hljs-comment">#菜单选项4  </span><br>menu_5 = <span class="hljs-string">&#x27;功能5&#x27;</span>  <span class="hljs-comment">#菜单选项5 </span><br>csv_1 = <span class="hljs-string">&#x27;test.csv&#x27;</span>   <span class="hljs-comment">#表格1</span><br><br><br>bot = Bot(cache_path = <span class="hljs-literal">True</span>)<br>bot.enable_puid()  <span class="hljs-comment">#启用聊天对象的puis属性</span><br>xiaoi = XiaoI(<span class="hljs-string">&#x27;PQunMu3c66bM&#x27;</span>, <span class="hljs-string">&#x27;FrQl1oi1YzpDSULeAIit&#x27;</span>)   <span class="hljs-comment">#小i机器人接口</span><br>adminer = bot.friends(update=<span class="hljs-literal">True</span>).search(admin_request_name)[<span class="hljs-number">0</span>]<br>my_group = bot.groups(update=<span class="hljs-literal">True</span>).search(group_name)[<span class="hljs-number">0</span>]<br>group_admin = my_group.members.search(admin_request_name)[<span class="hljs-number">0</span>]<br><br><br>admin_puids = <span class="hljs-built_in">frozenset</span>([<span class="hljs-string">&#x27;XX&#x27;</span>, <span class="hljs-string">&#x27;YY&#x27;</span>])   <span class="hljs-comment">#不可变集合</span><br>admins = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-keyword">lambda</span> x: bot.friends().search(puid=x), admin_puids))<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">invite</span>(<span class="hljs-params">user</span>):</span><br>    groups = <span class="hljs-built_in">sorted</span>(bot.groups(update=<span class="hljs-literal">True</span>).search(group_name),<br>                    key=<span class="hljs-keyword">lambda</span> x: x.name)   <span class="hljs-comment">#sorted用于排序，lambda x:x.name用于群名排序</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(groups) &gt; <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">for</span> group <span class="hljs-keyword">in</span> groups:<br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(group.members) == <span class="hljs-number">500</span>:<br>                <span class="hljs-keyword">continue</span>    <br>            <span class="hljs-keyword">if</span> user <span class="hljs-keyword">in</span> group:<br>                content = <span class="hljs-string">&quot;您已经加入了&#123;&#125; [微笑]&quot;</span>.<span class="hljs-built_in">format</span>(group.nick_name)   <span class="hljs-comment">#经过format格式化的内容传递到&#123;&#125;</span><br>                user.send(content)<br>            <span class="hljs-keyword">else</span>:<br>                group.add_members(user, use_invitation=<span class="hljs-literal">True</span>)<br>            <span class="hljs-keyword">return</span><br>        <span class="hljs-keyword">else</span>:<br>            next_topic = group_tmpl.<span class="hljs-built_in">format</span>(re.search(<span class="hljs-string">r&#x27;\d+&#x27;</span>, s).group() + <span class="hljs-number">1</span>)  <span class="hljs-comment">#当前群的名字后面+1</span><br>            new_group = bot.create_group(admins, topic=next_topic)<br>            <span class="hljs-comment">#以上3句代码的解释为：利用for if else语句进行判断，如果从查找的群名里面找不到对应的群就自动创建一个新群并添加进去</span><br>    <span class="hljs-keyword">else</span>:<br>        print(<span class="hljs-string">&#x27;Invite Failed&#x27;</span>)<br><br><span class="hljs-comment">#写表函数</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">table</span>(<span class="hljs-params">user, text</span>):</span><br>    <span class="hljs-comment">#提取用户的文本，把有用的写入表里</span><br>    msg_text = text<br>    tables = msg_text.split(<span class="hljs-string">&#x27;\n&#x27;</span>)<br>    table_name = tables[<span class="hljs-number">1</span>].split(<span class="hljs-string">&#x27;:&#x27;</span>)[<span class="hljs-number">1</span>]<br>    table_stu_num = tables[<span class="hljs-number">2</span>].split(<span class="hljs-string">&#x27;:&#x27;</span>)[<span class="hljs-number">1</span>]<br>    table_phone_num = tables[<span class="hljs-number">3</span>].split(<span class="hljs-string">&#x27;:&#x27;</span>)[<span class="hljs-number">1</span>]<br>    table_department = tables[<span class="hljs-number">4</span>].split(<span class="hljs-string">&#x27;:&#x27;</span>)[<span class="hljs-number">1</span>]<br>    table_list = [table_name, table_stu_num, table_phone_num, table_department, <span class="hljs-string">&#x27;等待缴费&#x27;</span>]<br>    user.send(<span class="hljs-string">&#x27;请稍等，后台处理中&#x27;</span>)<br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(csv_1, <span class="hljs-string">&#x27;r&#x27;</span>) <span class="hljs-keyword">as</span> f:   <span class="hljs-comment">#检查表里是否有登记的学号</span><br>        fr_csv = csv.reader(f)<br>        <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> fr_csv:<br>            <span class="hljs-keyword">if</span> table_stu_num <span class="hljs-keyword">in</span> row:<br>                user.send(<span class="hljs-string">&#x27;报名失败，该学号已经登记过了&#x27;</span>)<br>                <span class="hljs-keyword">break</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(csv_1, <span class="hljs-string">&#x27;a&#x27;</span>) <span class="hljs-keyword">as</span> f:          <span class="hljs-comment">#写入表</span><br>                fw_csv = csv.writer(f)<br>                fw_csv.writerow(table_list)<br>            <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(csv_1, <span class="hljs-string">&#x27;r&#x27;</span>) <span class="hljs-keyword">as</span> f:          <span class="hljs-comment">#查看是否写入成功</span><br>                fr_csv = csv.reader(f)<br>                <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> fr_csv:<br>                    <span class="hljs-keyword">if</span> table_stu_num <span class="hljs-keyword">in</span> row:<br>                        user.send(<span class="hljs-string">&#x27;报名成功,请回复‘支付宝’或者‘微信’进行支付&#x27;</span>)<br>                        <span class="hljs-keyword">break</span><br>                <span class="hljs-keyword">else</span>:<br>                    user.send(<span class="hljs-string">&#x27;报名失败，请重新报名或者联系管理员&#x27;</span>)<br><br><span class="hljs-comment">#查询表函数</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">check</span>(<span class="hljs-params">user, text</span>):</span><br>    check_text = text.split(<span class="hljs-string">&#x27;:&#x27;</span>)[<span class="hljs-number">1</span>]<br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(csv_1, <span class="hljs-string">&#x27;r&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>        fr_csv = csv.reader(f)<br>        <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> fr_csv:<br>            <span class="hljs-keyword">if</span> check_text <span class="hljs-keyword">in</span> row:<br>                user.send(<span class="hljs-string">&#x27;登记信息如下，如有疑问请联系管理员&#x27;</span>)<br>                user.send(<span class="hljs-string">&#x27;学号:&#x27;</span>+row[<span class="hljs-number">1</span>]+<span class="hljs-string">&quot;\n缴费情况:&quot;</span>+row[-<span class="hljs-number">1</span>])<br>                <span class="hljs-keyword">break</span><br>        <span class="hljs-keyword">else</span>:<br>            user.send(<span class="hljs-string">&#x27;暂无学号登记记录&#x27;</span>)	<br><br><span class="hljs-comment"># 注册好友请求类消息</span><br><span class="hljs-meta">@bot.register(<span class="hljs-params">msg_types=FRIENDS,enabled=<span class="hljs-literal">True</span></span>)</span><br><span class="hljs-comment"># 自动接受验证信息中包含 &#x27;wxpy&#x27; 的好友请求</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">auto_accept_friends</span>(<span class="hljs-params">msg</span>):</span><br>    <span class="hljs-comment"># 判断好友请求中的验证文本</span><br>    <span class="hljs-keyword">if</span> addfriend_request <span class="hljs-keyword">in</span> msg.text.lower():<br>        <span class="hljs-comment"># 接受好友 (msg.card 为该请求的用户对象)</span><br>        new_friend = bot.accept_friend(msg.card)<br>        <span class="hljs-comment"># 或 new_friend = msg.card.accept()</span><br>        <span class="hljs-comment"># 向新的好友发送消息</span><br>        new_friend.send(<span class="hljs-string">&#x27;机器人自动接受了你的请求,你可以任意回复获取功能菜单，若机器人没回复菜单则表明机器人尚未工作，请等待&#x27;</span>)<br><br><span class="hljs-comment">#注册自动回复好友消息</span><br><span class="hljs-meta">@bot.register(<span class="hljs-params">Friend, msg_types=TEXT</span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">exist_friends</span>(<span class="hljs-params">msg</span>):</span><br>    <span class="hljs-keyword">if</span> menu_1 <span class="hljs-keyword">in</span> msg.text.lower():<br>    	invite(msg.sender)<br>    <span class="hljs-keyword">elif</span> menu_2 <span class="hljs-keyword">in</span> msg.text.lower():<br>    	content_2_1 = <span class="hljs-string">&quot;请复制下面的模板回复\nps：部门可以多填，如果是技术部和Hockey就填写 部门：技术部、Hockey\n填写示例：\n姓名：小明\n学号：111111111\n电话：18888888888\n部门：技术部&quot;</span><br>    	content_2_2 = <span class="hljs-string">&quot;报名表\n姓名:\n学号:\n电话:\n部门:&quot;</span><br>    	msg.sender.send(content_2_1)<br>    	msg.sender.send(content_2_2)<br>    <span class="hljs-keyword">elif</span> menu_3 <span class="hljs-keyword">in</span> msg.text.lower():<br>    	<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;购买鞋子功能测试中&#x27;</span> <span class="hljs-comment">#跟报名的功能差不多就不写了。。。</span><br>    <span class="hljs-keyword">elif</span> menu_4 <span class="hljs-keyword">in</span> msg.text.lower():<br>    	msg.sender.send(<span class="hljs-string">&#x27;关注公众号可以了解更多&#x27;</span>)<br>    	msg.sender.send_raw_msg(<br>    	<span class="hljs-comment"># 名片的原始消息类型</span><br>    	raw_type=<span class="hljs-number">42</span>,<br>    	<span class="hljs-comment"># 注意 `username` 在这里应为微信 ID，且被发送的名片必须为自己的好友</span><br>    	raw_content=<span class="hljs-string">&#x27;&lt;msg username=&quot;zdnflunhua&quot; nickname=&quot;中大南方RNF&quot;/&gt;&#x27;</span><br>    	)	<br>    <span class="hljs-keyword">elif</span> menu_5 <span class="hljs-keyword">in</span> msg.text.lower():<br>    	<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;我要帮助功能测试中&#x27;</span>	   <span class="hljs-comment">#最初设想是返回从公众号获取的素材，结果没有相对应的Api。只能返回图片，语音，或者文本了，不过这个就一行代码的事，就不写了</span><br>    <span class="hljs-keyword">elif</span> <span class="hljs-string">&#x27;报名表&#x27;</span> <span class="hljs-keyword">in</span> msg.text.lower():<br>    	table(msg.sender, msg.text)<br>    <span class="hljs-keyword">elif</span> <span class="hljs-string">&#x27;支付宝&#x27;</span> <span class="hljs-keyword">in</span> msg.text.lower():<br>    	msg.sender.send(<span class="hljs-string">&#x27;请进入支付宝扫描二维码支付，备注姓名，电话\n支付完成后请第二天回复“查询:+学生号“查询情况\n示例：\n查询:111111111&#x27;</span>)<br>    	msg.sender.send(<span class="hljs-string">&#x27;二维码生成中&#x27;</span>)<br>    	msg.sender.send_image(<span class="hljs-string">&#x27;zfb.png&#x27;</span>)<br>    <span class="hljs-keyword">elif</span> <span class="hljs-string">&#x27;微信&#x27;</span> <span class="hljs-keyword">in</span> msg.text.lower():<br>    	msg.sender.send(<span class="hljs-string">&#x27;请进入微信扫描二维码支付，备注姓名，电话\n支付完成后请第二天回复“查询:+学生号“查询情况\n示例：\n查询:111111111&#x27;</span>)<br>    	msg.sender.send(<span class="hljs-string">&#x27;二维码生成中&#x27;</span>)<br>    	msg.sender.send_image(<span class="hljs-string">&#x27;wx.png&#x27;</span>)<br>    <span class="hljs-keyword">elif</span> <span class="hljs-string">&#x27;查询&#x27;</span> <span class="hljs-keyword">in</span> msg.text:<br>    	check(msg.sender, msg.text)<br>    <span class="hljs-keyword">elif</span> <span class="hljs-string">&#x27;管理员&#x27;</span> <span class="hljs-keyword">in</span> msg.text:<br>    	msg.sender.send(<span class="hljs-string">&#x27;请添加名片联系管理员&#x27;</span>)<br>    	msg.sender.send_raw_msg(<br>    	<span class="hljs-comment"># 名片的原始消息类型</span><br>    	raw_type=<span class="hljs-number">42</span>,<br>    	<span class="hljs-comment"># 注意 `username` 在这里应为微信 ID，且被发送的名片必须为自己的好友</span><br>    	raw_content=<span class="hljs-string">&#x27;&lt;msg username=&quot;bc9526&quot; nickname=&quot;陈思煜&quot;/&gt;&#x27;</span><br>    	)	<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> invite_text <br><br><span class="hljs-comment">#处理管理员信息</span><br><span class="hljs-meta">@bot.register(<span class="hljs-params">adminer, msg_types=TEXT</span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">adminer</span>(<span class="hljs-params">msg</span>):</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;备份&#x27;</span> <span class="hljs-keyword">in</span> msg.text:<br>    	msg.sender.send_file(<span class="hljs-string">&#x27;test.csv&#x27;</span>)<br>    <span class="hljs-keyword">else</span>:<br>    	<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;请检查命令是否输入正确&quot;</span> 	<br><br><span class="hljs-comment">#群聊管理</span><br><span class="hljs-meta">@bot.register(<span class="hljs-params">my_group, msg_types=TEXT</span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">group</span>(<span class="hljs-params">msg</span>):</span><br>    <span class="hljs-keyword">if</span> msg.is_at :<br>        <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;踢出&#x27;</span> <span class="hljs-keyword">in</span> msg.text:<br>            <span class="hljs-keyword">if</span> msg.member == group_admin :<br>                <span class="hljs-keyword">for</span> member_name <span class="hljs-keyword">in</span> msg.text.split(<span class="hljs-string">&#x27;@&#x27;</span>)[<span class="hljs-number">2</span>:]:<br>                    print(member_name)<br>                    re_name = my_group.members.search(member_name)[<span class="hljs-number">0</span>].remove()<br>                    print(re_name)<br>                    msg.sender.send(<span class="hljs-string">&quot;已经移出:&quot;</span>+member_name)<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;你不是管理员不能进行踢人操作&quot;</span><br>        <span class="hljs-keyword">else</span>:<br>            xiaoi.do_reply(msg)		<br>bot.join()                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         <br><br></code></pre></td></tr></table></figure>

</li>
</ul>
]]></content>
      <categories>
        <category>小玩具</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>玩具</tag>
      </tags>
  </entry>
  <entry>
    <title>[Python玩微信（1）:初探wxpy]</title>
    <url>/2017/07/28/4_wxpy_1/</url>
    <content><![CDATA[<p>在网上发现了wxpy这个库，可以调取一些微信API来玩转微信，本文主要是在提取微信好友数据</p>
<span id="more"></span>
<h2 id="Python玩微信（1）-初探wxpy"><a href="#Python玩微信（1）-初探wxpy" class="headerlink" title="Python玩微信（1）:初探wxpy"></a>Python玩微信（1）:初探wxpy</h2><h3 id="1-前期准备"><a href="#1-前期准备" class="headerlink" title="1.前期准备"></a>1.前期准备</h3><p><a href="http://wxpy.readthedocs.io/zh/latest/index.html">wxpy项目主页</a>里面有它的相关介绍<br><a href="https://github.com/chenjiandongx/pyecharts">pyecharts项目主页</a>，是python与百度echarts的桥梁，我用来做数据分析</p>
<h3 id="2-查看微信好友男女比例"><a href="#2-查看微信好友男女比例" class="headerlink" title="2.查看微信好友男女比例"></a>2.查看微信好友男女比例</h3><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> wxpy <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> pyecharts <span class="hljs-keyword">import</span> Pie<br><br>bot = Bot(cache_path = <span class="hljs-literal">True</span>)   <span class="hljs-comment">#定义一个微信机器人</span><br>friends = bot.friends(update=<span class="hljs-literal">False</span>)   <span class="hljs-comment">#获取更新好友列表</span><br>male = female = other = <span class="hljs-number">0</span>    <br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> friends[<span class="hljs-number">1</span>:]:     <span class="hljs-comment">#[1:]是因为整个好友列表里面自己市在第一个，排除掉</span><br>    sex = i.sex<br>    <span class="hljs-keyword">if</span> sex == <span class="hljs-number">1</span>:<br>        male += <span class="hljs-number">1</span><br>    <span class="hljs-keyword">elif</span> sex == <span class="hljs-number">2</span>:<br>        female += <span class="hljs-number">1</span><br>    <span class="hljs-keyword">else</span>:<br>        other += <span class="hljs-number">1</span><br>total = <span class="hljs-built_in">len</span>(friends[<span class="hljs-number">1</span>:])   <span class="hljs-comment">#计算总数</span><br><br><span class="hljs-comment">#下面为分析</span><br>attr = [<span class="hljs-string">&quot;男性&quot;</span>,<span class="hljs-string">&quot;女性&quot;</span>,<span class="hljs-string">&quot;其他&quot;</span>]<br>v1 = [<span class="hljs-built_in">float</span>(male),<span class="hljs-built_in">float</span>(female),<span class="hljs-built_in">float</span>(other)]<br>pie = Pie(<span class="hljs-string">&quot;饼图-圆环图示例&quot;</span>, title_pos=<span class="hljs-string">&#x27;center&#x27;</span>)<br>pie.add(<span class="hljs-string">&quot;&quot;</span>, attr, v1, radius=[<span class="hljs-number">40</span>, <span class="hljs-number">75</span>], label_text_color=<span class="hljs-literal">None</span>, is_label_show=<span class="hljs-literal">True</span>,<br>        legend_orient=<span class="hljs-string">&#x27;vertical&#x27;</span>, legend_pos=<span class="hljs-string">&#x27;left&#x27;</span>)<br>pie.render(<span class="hljs-string">&quot;sex.html&quot;</span>)<br></code></pre></td></tr></table></figure>
<p>结果输出如图<br><img    class="lazyload" data-original="https://github.com/so1n/so1n_blog_photo/blob/master/blog_photo/%E9%A5%BC%E5%9B%BE-%E5%9C%86%E7%8E%AF%E5%9B%BE%E7%A4%BA%E4%BE%8B.png?raw=true" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">enter description here</span><br>没想到我微信里面女性好友是男性好友的一半-。- ， 可能是跟我大学专业有关吧</p>
<h3 id="3-查看好友地区分布"><a href="#3-查看好友地区分布" class="headerlink" title="3.查看好友地区分布"></a>3.查看好友地区分布</h3><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> wxpy <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> pyecharts <span class="hljs-keyword">import</span> Map<br><br><span class="hljs-comment">#因为获取的列表城市都没有带市字，而pyecharts需要带个市字</span><br>b = <span class="hljs-string">&#x27;市&#x27;</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">s</span>(<span class="hljs-params">x</span>):</span><br>    <span class="hljs-keyword">return</span> x+b<br><br><span class="hljs-comment">#因为我好友里面除了广东的外和其他的，剩下非广东的寥寥无几，所以只提取广东的</span><br>bot = Bot(cache_path = <span class="hljs-literal">True</span>)<br>friends = bot.friends(update=<span class="hljs-literal">False</span>).search(province = <span class="hljs-string">&#x27;广东&#x27;</span>)<br>citys = []   <br><span class="hljs-keyword">for</span> f <span class="hljs-keyword">in</span> friends :<br>    city = f.city<br>    citys.append(city)<br>r = <span class="hljs-built_in">map</span>(s,citys)<br>cityss = <span class="hljs-built_in">list</span>(r)<br><br><span class="hljs-comment">#为城市计数</span><br>a = &#123;&#125;<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> cityss:<br>    a[i] = cityss.count(i)<br>a.pop(<span class="hljs-string">&#x27;市&#x27;</span>)<br><br><span class="hljs-comment">#把字典进行有序拆分为2个列表</span><br>attrs = []<br>values = []<br><span class="hljs-keyword">for</span> value, attr <span class="hljs-keyword">in</span> a.items():<br>    values.append(attr)<br>    attrs.append(value)<br><span class="hljs-comment">#开始绘图</span><br><span class="hljs-built_in">map</span> = Map(<span class="hljs-string">&quot;广东地图示例&quot;</span>, width=<span class="hljs-number">1200</span>, height=<span class="hljs-number">600</span>)<br><span class="hljs-built_in">map</span>.add(<span class="hljs-string">&quot;&quot;</span>, attrs, values, maptype=<span class="hljs-string">&#x27;广东&#x27;</span>, is_visualmap=<span class="hljs-literal">True</span>, visual_text_color=<span class="hljs-string">&#x27;#000&#x27;</span>)<br><span class="hljs-built_in">map</span>.render(<span class="hljs-string">&quot;city.html&quot;</span>)<br><br></code></pre></td></tr></table></figure>
<p>数据呈现如下：<br><img    class="lazyload" data-original="https://github.com/so1n/so1n_blog_photo/blob/master/blog_photo/%E6%B7%B1%E5%BA%A6%E5%BD%95%E5%B1%8F_%E9%80%89%E6%8B%A9%E5%8C%BA%E5%9F%9F_20170728182957.gif?raw=true" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">enter description here</span><br>我微信里面潮州多的原因就是我是潮州人啊，然后广州多的原因可能就是我在广州读书吧，很多人大学才玩微信的，如果是那时候定位，就直接定位为广州了</p>
<h3 id="4-查看好友签名，并利用jieba分词，再制作成词云"><a href="#4-查看好友签名，并利用jieba分词，再制作成词云" class="headerlink" title="4.查看好友签名，并利用jieba分词，再制作成词云"></a>4.查看好友签名，并利用jieba分词，再制作成词云</h3><figure class="highlight nix"><table><tr><td class="code"><pre><code class="hljs nix">from wxpy <span class="hljs-built_in">import</span> *<br><span class="hljs-built_in">import</span> re<br><span class="hljs-built_in">import</span> jieba<br><span class="hljs-built_in">import</span> matplotlib.pyplot as plt<br>from wordcloud <span class="hljs-built_in">import</span> WordCloud<br><span class="hljs-built_in">import</span> PIL.Image as Image<br><br><span class="hljs-attr">bot</span> = Bot(<span class="hljs-attr">cache_path</span> = True)<br><span class="hljs-attr">friends</span> = bot.friends(<span class="hljs-attr">update=False)</span><br><span class="hljs-attr">male</span> = <span class="hljs-attr">female</span> = <span class="hljs-attr">other</span> = <span class="hljs-number">0</span><br><br><span class="hljs-comment">#提取好友签名，并去掉span，class，emoji，emoji1f3c3等的字段</span><br><span class="hljs-attr">signatures</span> = []<br>for i <span class="hljs-keyword">in</span> friends:<br>    <span class="hljs-attr">signature</span> = i.signature.strip().replace(<span class="hljs-string">&quot;span&quot;</span>, <span class="hljs-string">&quot;&quot;</span>).replace(<span class="hljs-string">&quot;class&quot;</span>, <span class="hljs-string">&quot;&quot;</span>).replace(<span class="hljs-string">&quot;emoji&quot;</span>, <span class="hljs-string">&quot;&quot;</span>)<br><span class="hljs-comment"># 正则匹配过滤掉emoji表情，例如emoji1f3c3等</span><br>    <span class="hljs-attr">rep</span> = re.compile(<span class="hljs-string">&quot;1f\d.+&quot;</span>)<br>    <span class="hljs-attr">signature</span> = rep.sub(<span class="hljs-string">&quot;&quot;</span>, signature)<br>    signatures.append(signature)<br><span class="hljs-comment"># 拼接字符串</span><br><span class="hljs-attr">text</span> = <span class="hljs-string">&quot;&quot;</span>.join(signatures)<br><span class="hljs-comment"># jieba分词</span><br><span class="hljs-attr">wordlist_jieba</span> = jieba.cut(text, <span class="hljs-attr">cut_all=True)</span><br><span class="hljs-attr">wl_space_split</span> = <span class="hljs-string">&quot; &quot;</span>.join(wordlist_jieba)<br><br><span class="hljs-comment"># wordcloud词云</span><br><span class="hljs-attr">my_wordcloud</span> = WordCloud(<span class="hljs-attr">background_color=&quot;white&quot;,</span> <br>                         <span class="hljs-attr">max_words=2000,</span> <br>                         <span class="hljs-attr">max_font_size=1000,</span> <br>                         <span class="hljs-attr">random_state=42,</span><br>                         <span class="hljs-attr">font_path=&#x27;./hanyi.ttf&#x27;).generate(wl_space_split)</span><br><br>plt.imshow(my_wordcloud)<br>plt.axis(<span class="hljs-string">&quot;off&quot;</span>)<br>plt.show()<br></code></pre></td></tr></table></figure>
<p>结果显示如图：<br><img    class="lazyload" data-original="https://github.com/so1n/so1n_blog_photo/blob/master/blog_photo/Figure_1.png?raw=true" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">enter description here</span><br>结果可以发现，我好友里面最多的就是“努力”了，其次是“自己”，“一个”，“可以，一生”。还有“生活，成为，半生，喜欢，当下，轮滑，珍惜”<br>哈哈哈，出现轮滑是因为我好友列表里面很多都是学校里面的轮滑协会的。不过出现代理就。。。。。。（捂脸）</p>
]]></content>
      <categories>
        <category>小玩具</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>玩具</tag>
      </tags>
  </entry>
  <entry>
    <title>[爬虫-豆瓣读书]</title>
    <url>/2017/07/25/3_spider_by_douban_resd/</url>
    <content><![CDATA[<p>这是一个直接用别人的代码copy后再加上自己的想法来实现的小项目</p>
<span id="more"></span>
<p>这是一个直接用别人的代码copy后再加上自己的想法来实现的小项目</p>
<h2 id="爬虫入门项目实战"><a href="#爬虫入门项目实战" class="headerlink" title="爬虫入门项目实战"></a>爬虫入门项目实战</h2><h3 id="1-寻找项目"><a href="#1-寻找项目" class="headerlink" title="1.寻找项目"></a>1.寻找项目</h3><p><a href="http://www.jianshu.com/p/1be3d90b4c5f">直达票</a></p>
<h3 id="2-修改项目"><a href="#2-修改项目" class="headerlink" title="2.修改项目"></a>2.修改项目</h3><p>原来那个太简单了，按照自己这几天学习的内容，打算对其进行修改<br>修改想法如下：</p>
<ul>
<li><p>增加其他信息，如：作者，分类，说明等</p>
</li>
<li><p>总本书从网站直接提取，而不是自己输入</p>
</li>
<li><p>存储数据</p>
<p>想的容易做得难啊，果然没有实操，一些代码总以为这样就能操作，结果一直报错<br>然后我这份代码爬取量少，并没有设置错误判断等，还有直接修改原代码，我需要什么就写什么，没有考虑全局什么的，所以可能有点冗余<br>修改后代码如下：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><code class="hljs vim"> import urllib.request<br>from bs4 import BeautifulSoup<br>import time<br>import csv<br><br>num = <span class="hljs-number">0</span>  #用来计数，计算爬取的书一共有多少本<br>start_time = time.time()  #计算爬虫爬取过程时间<br><br>#第一页网页网址http<span class="hljs-variable">s:</span>//<span class="hljs-keyword">read</span>.douban.<span class="hljs-keyword">com</span>/columns/category/<span class="hljs-keyword">all</span>?<span class="hljs-keyword">sort</span>=hot&amp;start=<span class="hljs-number">0</span><br>#第二页网页网址http<span class="hljs-variable">s:</span>//<span class="hljs-keyword">read</span>.douban.<span class="hljs-keyword">com</span>/columns/category/<span class="hljs-keyword">all</span>?<span class="hljs-keyword">sort</span>=hot&amp;start=<span class="hljs-number">10</span><br>#第三页网页网址http<span class="hljs-variable">s:</span>//<span class="hljs-keyword">read</span>.douban.<span class="hljs-keyword">com</span>/columns/category/<span class="hljs-keyword">all</span>?<span class="hljs-keyword">sort</span>=hot&amp;start=<span class="hljs-number">20</span><br>#......发现规律了吗<br>url = <span class="hljs-string">&#x27;https://read.douban.com/columns/category/all?sort=hot&amp;start=&#x27;</span>  <br>#为各个数据创建列表<br>node_lists = []<br>authors = []<br>categorys = []<br>infos = []<br><span class="hljs-keyword">number</span> = []<br>html = urllib.request.urlopen(<span class="hljs-string">&#x27;https://read.douban.com/columns/category/all?sort=hot&amp;start=0&#x27;</span>)    <br>bsObj0 = BeautifulSoup(html,<span class="hljs-string">&#x27;lxml&#x27;</span>)  <br>cate_name = bsObj0.<span class="hljs-keyword">find</span>(<span class="hljs-string">&quot;span&quot;</span>,&#123;<span class="hljs-string">&quot;class&quot;</span>:<span class="hljs-string">&quot;cate-count&quot;</span>&#125;).get_text()<br><span class="hljs-keyword">for</span> i in <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,<span class="hljs-keyword">int</span>(cate_name),<span class="hljs-number">10</span>):  #这里的  <span class="hljs-built_in">range</span>（初始，结束，间隔）<br>    #urllib.request库用来向该网服务器发送请求，请求打开该网址链接<br>    html = urllib.request.urlopen(<span class="hljs-string">&#x27;https://read.douban.com/columns/category/all?sort=hot&amp;start=%d&#x27;</span> % i)    <br>    #BeautifulSoup库解析获得的网页，第二个参数一定记住要写上‘lxml’，记住就行<br>    bsObj = BeautifulSoup(html,<span class="hljs-string">&#x27;lxml&#x27;</span>)  <br><br>    <span class="hljs-keyword">print</span>(<span class="hljs-string">&#x27;==============&#x27;</span> + <span class="hljs-string">&#x27;第%d页&#x27;</span>%(i/<span class="hljs-number">10</span> + <span class="hljs-number">1</span>) + <span class="hljs-string">&#x27;==============&#x27;</span>)<br>    #分析网页发现，每页有<span class="hljs-number">10</span>本书，而<span class="hljs-symbol">&lt;h4&gt;</span>标签正好只有<span class="hljs-number">10</span>个。<br>    h4_node_list = bsObj.find_all(<span class="hljs-string">&#x27;h4&#x27;</span>)  # 这里返回的是h4标签的<span class="hljs-keyword">list</span>列表<br>    div_authors = bsObj.find_all(<span class="hljs-string">&quot;div&quot;</span>,&#123;<span class="hljs-string">&quot;class&quot;</span>:<span class="hljs-string">&quot;author&quot;</span>&#125;)<br>    div_categorys =bsObj.find_all(<span class="hljs-string">&quot;div&quot;</span>,&#123;<span class="hljs-string">&quot;class&quot;</span>:<span class="hljs-string">&quot;category&quot;</span>&#125;)<br>    div_infos = bsObj.find_all(<span class="hljs-string">&quot;div&quot;</span>,&#123;<span class="hljs-string">&quot;class&quot;</span>:<span class="hljs-string">&quot;update-info icon-cal&quot;</span>&#125;)<br>    #提取要的文本<br>    <span class="hljs-keyword">for</span> div_author in div_author<span class="hljs-variable">s:</span><br>        authors.<span class="hljs-keyword">append</span>(div_author.get_text()[<span class="hljs-number">2</span>:])<br><br>    <span class="hljs-keyword">for</span> div_category in div_category<span class="hljs-variable">s:</span><br>        category = div_category.get_text()[<span class="hljs-number">2</span>:] <br>        categorys.<span class="hljs-keyword">append</span>(category[:<span class="hljs-number">2</span>])<br><br>    <span class="hljs-keyword">for</span> div_info in div_info<span class="hljs-variable">s:</span><br>        infos.<span class="hljs-keyword">append</span>(div_info.get_text())<br><br>    <span class="hljs-keyword">for</span> h4_node in h4_node_lis<span class="hljs-variable">t:</span>  #遍历列表<br>        #获取h4标签内的<span class="hljs-keyword">a</span>标签，但这里返回是只含<span class="hljs-number">1</span>个元素的<span class="hljs-keyword">list</span><br>        a_node = h4_node.contents[<span class="hljs-number">0</span>] <br>        title = a_node.contents[<span class="hljs-number">0</span>]  #因为是列表，要<span class="hljs-keyword">list</span>[<span class="hljs-number">0</span>]，取出来<br>        node_lists.<span class="hljs-keyword">append</span>(title)<br>        #title = <span class="hljs-string">&#x27;&lt;&lt;&#x27;</span> + title + <span class="hljs-string">&#x27;&gt;&gt;&#x27;</span><br>        <span class="hljs-keyword">print</span>(<span class="hljs-string">&#x27;第%d本书&#x27;</span>%(num+<span class="hljs-number">1</span>), title)<br>        num = num + <span class="hljs-number">1</span><br>        <span class="hljs-keyword">number</span>.<span class="hljs-keyword">append</span>(num)<br>    #设置抓数据停顿时间为<span class="hljs-number">1</span>秒，防止过于频繁访问该网站，被封<br>    time.<span class="hljs-keyword">sleep</span>(<span class="hljs-number">1</span>)  <br><br>end_time = time.time()<br>duration_time = end_time - start_time<br><span class="hljs-keyword">print</span>(<span class="hljs-string">&#x27;运行时间共：%.2f&#x27;</span>  % duration_time + <span class="hljs-string">&#x27;秒&#x27;</span>)<br><span class="hljs-keyword">print</span>(<span class="hljs-string">&#x27;共抓到%d本书名&#x27;</span>%num)<br><span class="hljs-keyword">print</span>(<span class="hljs-string">&#x27;正在写入csv&#x27;</span>)<br>with <span class="hljs-keyword">open</span>(<span class="hljs-string">&#x27;so1n.csv&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>) <span class="hljs-keyword">as</span> <span class="hljs-keyword">f</span>:<br>    f_csv = csv.writer(<span class="hljs-keyword">f</span>)<br>    f_csv.writerow((<span class="hljs-string">&#x27;标题&#x27;</span>, <span class="hljs-string">&#x27;作者&#x27;</span>, <span class="hljs-string">&#x27;分类&#x27;</span>, <span class="hljs-string">&#x27;信息&#x27;</span>))<br>    <span class="hljs-keyword">for</span> n in <span class="hljs-keyword">number</span>:<br>        f_csv.writerow((node_lists.<span class="hljs-keyword">pop</span>(<span class="hljs-number">0</span>),authors.<span class="hljs-keyword">pop</span>(<span class="hljs-number">0</span>),categorys.<span class="hljs-keyword">pop</span>(<span class="hljs-number">0</span>),infos.<span class="hljs-keyword">pop</span>(<span class="hljs-number">0</span>)))<br></code></pre></td></tr></table></figure>
<h3 id="3-更改部分说明"><a href="#3-更改部分说明" class="headerlink" title="3.更改部分说明"></a>3.更改部分说明</h3></li>
<li><p>提取数据<br>一开始觉得文中提取的方法挺本的，然后我就想换个法子提取数据，正则不太会用，感觉跟BS4结合需要很多代码（要去恶补正则了），最后发现直接get_text()就好了，而且是列表，直接切片提取， So Easy！<br>还想着用BS4的各种父代/子代/兄弟标签去提取，发现有点难用，而且不成功。。。索性就改为for了</p>
</li>
<li><p>直接获取书的数目<br>原来哪里写着1650，然后我看了全部书是1979就加了几行代码获取总书数在弄进for循环了，不管套用原来的代码后觉得重复了- -</p>
</li>
<li><p>存储数据<br>这部分就纠结最久的了。。。都怪自己平时只看书和COPY，自己想写个存储数据饶了一堆路<br>用了最简单的把数据写入列表里面然后用for循环给取出来并一起存入到.csv文件<br>一开始用了切片提取，结果打开文档后发现存入的数据是这样的  [‘书名’]<br>然后就想换个法子，<br> 首先想到的是用<a href="http://www.runoob.com/python/att-string-strip.html">strip()</a>的方法，结果报错，list不能使用，我平时居然不知道- -惭愧<br> 后来就用了<a href="http://www.runoob.com/python/att-list-pop.html">pop()</a> [我居然忘记了-。-]<br> 完美解决，数据入库</p>
<h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p><img    class="lazyload" data-original="https://github.com/so1n/so1n_blog_photo/blob/master/blog_photo/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE20170725151248.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">enter description here</span><br><img    class="lazyload" data-original="https://github.com/so1n/so1n_blog_photo/blob/master/blog_photo/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE20170725151323.png?raw=true" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">enter description here</span></p>
</li>
</ul>
<h3 id="4-简单的数据分析"><a href="#4-简单的数据分析" class="headerlink" title="4.简单的数据分析"></a>4.简单的数据分析</h3><p>我现在选择的是<a href="https://me.bdp.cn/">BDP</a>这个网站<br>还有百度的echarts、tableau（这两个还没用过）<br>BDP有新手上手教程可以观看一下</p>
<ul>
<li>首先在左上角的工作表中上传自己刚保存的数据，我这个表是选择逗号分割</li>
<li>然后点击左上角的仪表盘创建一下自己的仪表盘并把自己上传的工作表打开</li>
<li>进入后维度选择分类，数值也选择分类，再选圆饼就可以看出如下数值<br><img    class="lazyload" data-original="https://github.com/so1n/so1n_blog_photo/blob/master/blog_photo/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE20170725153633.png?raw=true" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">enter description here</span></li>
<li>可以看出依次是文化、短故、情感占据1、 2、 3名，而且占了总量的一半</li>
</ul>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>爬虫</tag>
        <tag>数据分析</tag>
      </tags>
  </entry>
  <entry>
    <title>[搭建博客心得]</title>
    <url>/2017/07/24/1_build_blog_experience/</url>
    <content><![CDATA[<p>搭建这个博客用到的方法和遇到坑的解决过程</p>
<span id="more"></span>


<p>我是linux搭建的，<br>1.下载GIT<br><a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000">点击进入廖雪峰的GIT教程，查看安装部分并按教程安装就OK了</a></p>
<p>2.下载安装Node.js<br>后文的npm开头的命令都需要依赖Node.js。直接到<a href="https://nodejs.org/en/">Node官网</a>下载安装，看到最大的那两个绿色按钮，下载v6的就行。下载下来以后一路next下一步就可以了。</p>
<p>3.下载安装hexo<br><a href="https://hexo.io/zh-cn/docs/index.html">HEXO官网</a>说得很详细，包括如何部署在GITHUB上面，不太懂可以查看 <a href="http://www.jianshu.com/p/92b85c73aedf">这篇文章</a></p>
<p>4.适配主题<br>推荐使用<a href="http://theme-next.iissnan.com/getting-started.html">Next 主题</a>,，既简约又功能多还很完善</p>
<p>5.绑定个性域名</p>
<ul>
<li>阿里云<br>国内域名绑定首选，坑比较少，不过要身份验证什么的注册后就要等多几天，而且我注册完就没有.me域名了，心塞，我就换为GOdaddy了<br><a href="http://www.jianshu.com/p/e3169b681038">教程</a></li>
<li>GOdaddy<br>有中文，支持支付宝支付，除了阿里云外就选他了，不过坑有点多。。。<br><a href="http://www.ithao123.cn/content-3579965.html">教程</a></li>
</ul>
<p>6.遇到的坑。。。</p>
<ul>
<li><p>输入hexo g 后显示 hexo 命令找不到<br> 把npm install hexo-cli -g换为npm install hexo -g就行了</p>
</li>
<li><p>npm下载总卡主<br>换为淘宝镜像就解决了 <a href="http://blog.csdn.net/quuqu/article/details/64121812">教程</a></p>
</li>
<li><p>GOdaddy绑定域名<br><img    class="lazyload" data-original="https://github.com/so1n/so1n_blog_photo/blob/master/blog_photo/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE20170725160826.png?raw=true" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">Markdown</span><br>关注类型为A和类型为CNAME名称为WWW这两个就好了<br>比如我的博客域名为 so1n.me<br>A的值 为自己再电脑ping (库名).github.io 后得到的值也可以用github提供的<br>设置好后（CNAME文件也设置好）访问so1n.me后就会跳转为 （库名）github.io<br>www的值为 (库名).github.io   设置后，访问<a href="http://www.so1n.me/">www.so1n.me</a> 后就会跳转为so1n.me </p>
</li>
</ul>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>[MongoDB学习笔记]</title>
    <url>/2017/07/22/2_mondb_notes/</url>
    <content><![CDATA[<p>这是我在学习MongoＤＢ时的学习笔记，并且结合Ｐｙｔｈｏｎ调用mongodb数据库</p>
<span id="more"></span>

<h2 id="MongoDB-基础"><a href="#MongoDB-基础" class="headerlink" title="MongoDB 基础"></a>MongoDB 基础</h2><h3 id="1-SQL概念和MongoDB概念对比"><a href="#1-SQL概念和MongoDB概念对比" class="headerlink" title="1.SQL概念和MongoDB概念对比"></a>1.SQL概念和MongoDB概念对比</h3><table>
<thead>
<tr>
<th>SQL概念</th>
<th>MongoDB概念</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>database</td>
<td>database</td>
<td>数据库</td>
</tr>
<tr>
<td>table</td>
<td>collection</td>
<td>数据库表/集合</td>
</tr>
<tr>
<td>row</td>
<td>document</td>
<td>数据行/文档</td>
</tr>
<tr>
<td>column</td>
<td>field</td>
<td>数据字段列/域</td>
</tr>
<tr>
<td>index</td>
<td>index</td>
<td>索引</td>
</tr>
<tr>
<td>primary kye</td>
<td>primery key</td>
<td>主键，MongoDB 自动将_id字段设置为主键</td>
</tr>
</tbody></table>
<h3 id="2-创建-删除数据库"><a href="#2-创建-删除数据库" class="headerlink" title="2.创建/删除数据库"></a>2.创建/删除数据库</h3><p>创建数据库的语法：</p>
<figure class="highlight irpf90"><table><tr><td class="code"><pre><code class="hljs irpf90"><span class="hljs-keyword">use</span> DATABASE_NAME<br></code></pre></td></tr></table></figure>
<p>如果数据库不在则创建数据库，否则切换到指定数据库<br>查看所有数据库：</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">show </span>dbs<br></code></pre></td></tr></table></figure>
<p>删除数据库(删除当前数据库)：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">db</span><span class="hljs-selector-class">.dropDatabase</span>()<br></code></pre></td></tr></table></figure>
<p>创建数据库再删除示例<br><img   class="lazyload" data-original="http://ww2.sinaimg.cn/large/006HJ39wgy1fhsnpolv96j30f406n404.jpg" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" ></p>
<h3 id="3-集合中文档的增删改查"><a href="#3-集合中文档的增删改查" class="headerlink" title="3.集合中文档的增删改查"></a>3.集合中文档的增删改查</h3><p>插入文档</p>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">db</span><span class="hljs-selector-class">.COLLECTION_NAME</span><span class="hljs-selector-class">.insert</span>(<span class="hljs-selector-tag">document</span>)<br>示例：<br>&gt;<span class="hljs-selector-tag">db</span><span class="hljs-selector-class">.python</span><span class="hljs-selector-class">.insert</span>(&#123;<span class="hljs-attribute">title</span>: <span class="hljs-string">&#x27;python&#x27;</span>, <br>                   description: <span class="hljs-string">&#x27;动态语言&#x27;</span> , <br>                   url: <span class="hljs-string">&#x27;http://www.python.org&#x27;</span>, <br>                   tag: [<span class="hljs-string">&#x27;动态&#x27;</span>, <span class="hljs-string">&#x27;编程&#x27;</span>, <span class="hljs-string">&#x27;脚本&#x27;</span>],<br>                   likes: <span class="hljs-number">100</span><br> &#125;)<br></code></pre></td></tr></table></figure>
<p>以上示例中python是我们的集合名称，如果该集合不在该数据库中，MongoDB会自动创建该集合并插入文档。插入的数据必须符合json格式</p>
<p>查询文档</p>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">db</span><span class="hljs-selector-class">.COLLECTION_NAME</span><span class="hljs-selector-class">.find</span>()<span class="hljs-selector-class">.pretty</span>()<br>示例代码：<br><span class="hljs-selector-tag">db</span><span class="hljs-selector-class">.python</span><span class="hljs-selector-class">.find</span>()<br></code></pre></td></tr></table></figure>
<p>pretty()只是以易读的方式来读取数据，可以不加</p>
<center>MongoDB中的条件语句和操作符</center>

<table>
<thead>
<tr>
<th>操作</th>
<th>格式</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>等于</td>
<td>{&lt;key&gt;:&lt;value&gt;}</td>
<td>db.python.find({“likes”:100}).pretty()</td>
</tr>
<tr>
<td>小于</td>
<td>{&lt;key&gt;:$lt&lt;value&gt;}</td>
<td>db.python.find({“likes”:{$lt:100}}).pretty()</td>
</tr>
<tr>
<td>小于或等于</td>
<td>{&lt;key&gt;:$lte&lt;value&gt;}</td>
<td>db.python.find({“likes”:{$lte:100}}).pretty()</td>
</tr>
<tr>
<td>大于</td>
<td>{&lt;key&gt;:$gt&lt;value&gt;}</td>
<td>db.python.find({“likes”:{$gt:100}}).pretty()</td>
</tr>
<tr>
<td>大于或等于</td>
<td>{&lt;key&gt;:$gte&lt;value&gt;}</td>
<td>db.python.find({“likes”:{$gte:100}}).pretty()</td>
</tr>
<tr>
<td>不等于</td>
<td>{&lt;key&gt;:$ne&lt;value&gt;}</td>
<td>db.python.find({“likes”:{$ne:100}}).pretty()</td>
</tr>
</tbody></table>
<p>查询中的and和or</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros">通过<span class="hljs-builtin-name">find</span>()的方法传入多个key，实现<span class="hljs-keyword">and</span>：<br>&gt;db .COLLECTION_NAME.<span class="hljs-builtin-name">find</span>(&#123;key1:value1, key2:value2&#125;).pretty()<br>查找python集合中likes大于等于100切title等于python的文档，示例如下：<br>&gt;db.python.fing(&#123;<span class="hljs-string">&quot;like&quot;</span>: &#123;<span class="hljs-variable">$gte</span>:100&#125;, <span class="hljs-string">&quot;title&quot;</span>::<span class="hljs-string">&quot;python&quot;</span>&#125;).pretty()<br>通过“<span class="hljs-variable">$or</span>”关键字实现<span class="hljs-keyword">or</span>条件语句<br>查找集合中likes大于等于199或者title等于python的文档，示例如下：<br>&gt;db.python.<span class="hljs-builtin-name">find</span>(<br>   &#123;<br>       <span class="hljs-variable">$or</span>: &#123;<br>           &#123;<span class="hljs-string">&quot;likes&quot;</span>:&#123;<span class="hljs-variable">$gte</span>:100&#125;&#125;,&#123;<span class="hljs-string">&quot;title&quot;</span>:<span class="hljs-string">&quot;python&quot;</span>&#125;<br>       &#125;<br>   &#125;<br> ).pretty()<br> 联合使用<span class="hljs-keyword">and</span>和<span class="hljs-keyword">or</span><br> &gt;db.python.<span class="hljs-builtin-name">find</span>(&#123;<span class="hljs-string">&quot;like&quot;</span>: &#123;<span class="hljs-variable">$gt</span>:50&#125;, <span class="hljs-variable">$or</span>: [&#123;<span class="hljs-string">&quot;description&quot;</span>:<span class="hljs-string">&quot;动态语言&quot;</span>&#125;,&#123;<span class="hljs-string">&quot;title&quot;</span>:<span class="hljs-string">&quot;python&quot;</span>&#125;]&#125;).pretty()<br></code></pre></td></tr></table></figure>
<p>更新文档<br>把title的Python改为Python爬虫，multi默认为false，只更新找到的第一条记录，如果参数为true，就按条件查出来多条记录全部更新，还有一个upse参数，这个参数模式为false，如果设置为true，则如果不存在update记录就插入新的文档</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><code class="hljs vim">示例：<br>&gt;db.<span class="hljs-keyword">python</span>.<span class="hljs-keyword">update</span>(&#123;<span class="hljs-string">&#x27;title&#x27;</span>:<span class="hljs-string">&#x27;python&#x27;</span>&#125;,&#123;$<span class="hljs-keyword">se</span><span class="hljs-variable">t:</span>&#123;<span class="hljs-string">&#x27;title&#x27;</span>:<span class="hljs-string">&#x27;Python爬虫&#x27;</span>&#125;&#125;,&#123;multi:ture&#125;)<br></code></pre></td></tr></table></figure>
<p>删除文档<br>参数justOne如果设置为true或1，则只删除一个文档</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros">示例：<br>&gt;db.python.<span class="hljs-builtin-name">remove</span>(&#123;<span class="hljs-string">&#x27;tit;e’:&#x27;</span>Mongodb<span class="hljs-string">&#x27;&#125;)</span><br></code></pre></td></tr></table></figure>
<h3 id="4-Python操作mongodb"><a href="#4-Python操作mongodb" class="headerlink" title="4.Python操作mongodb"></a>4.Python操作mongodb</h3><p>建立连接</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">client</span>= pymongo.MongoClient()  <span class="hljs-comment">#连接默认的主机ip 和端口</span><br><span class="hljs-attr">client</span>= pymongo.MongoClient(<span class="hljs-string">&#x27;localhost&#x27;</span>,<span class="hljs-number">27017</span>)  <span class="hljs-comment">#显式指定ip和端口</span><br><span class="hljs-attr">client</span>= pymongo.MongoClient(<span class="hljs-string">&#x27;mongodb://localhost:27017/&#x27;</span>)  <span class="hljs-comment">#采用url格式进行连接</span><br></code></pre></td></tr></table></figure>
<p>获取数据库</p>
<figure class="highlight axapta"><table><tr><td class="code"><pre><code class="hljs axapta">db = <span class="hljs-keyword">client</span>.papers<br>如果数据库名字导致属性访问方式不能用（比如pa-pers），可以通过字典的方式访问数据库，示例：<br>db = <span class="hljs-keyword">client</span>[<span class="hljs-string">&#x27;pa-pers&#x27;</span>]<br></code></pre></td></tr></table></figure>
<p>获取一个集合</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><code class="hljs makefile">collection = db.books<br><span class="hljs-section">或者:</span><br>collection = db[&#x27;books&#x27;]<br></code></pre></td></tr></table></figure>
<p>插入文档<br>数据在MongoDB中是以JSON文件形式保存的。在pymongo中用字典的形式来代表文档，使用insert()插入文档</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><code class="hljs makefile">示例：<br>book =&#123;<span class="hljs-string">&quot;author&quot;</span>: <span class="hljs-string">&quot;mike&quot;</span>,<br>        <span class="hljs-string">&quot;text&quot;</span>:<span class="hljs-string">&quot;My first book!&quot;</span>,<br>        <span class="hljs-string">&quot;tags&quot;</span>:[<span class="hljs-string">&quot;爬虫&quot;</span>, <span class="hljs-string">&quot;python&quot;</span>, <span class="hljs-string">&quot;网络&quot;</span>],<br>        <span class="hljs-string">&quot;data&quot;</span>:datatime.tatatime.utcnow()<br>book_id = coolection.insert(book)<br></code></pre></td></tr></table></figure>
<p>查询文档</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><code class="hljs vim">collection.find_one() #返回一个符合条件的字典类型值可以修改find_on(&#123;<span class="hljs-string">&#x27;&#x27;</span>author<span class="hljs-string">&quot;: &quot;</span>mike<span class="hljs-comment">&quot;&#125;)来进行匹配查询</span><br>如果想获取多个文档，可以使用<span class="hljs-keyword">find</span>()方法。<span class="hljs-keyword">find</span>()返回一个Cursor实例，调用如下：<br><span class="hljs-keyword">for</span> book in collection.<span class="hljs-keyword">find</span>(&#123;<span class="hljs-string">&quot;author&quot;</span>: <span class="hljs-string">&quot;mike&quot;</span>&#125;):<br>    <span class="hljs-keyword">print</span> book<br>如果想知道符合查询条件的文件有多少可以用<span class="hljs-built_in">count</span>（）操作，示例：<br>collection.<span class="hljs-keyword">find</span>(&#123;<span class="hljs-string">&quot;author&quot;</span>:<span class="hljs-string">&quot;mike&quot;</span>&#125;).<span class="hljs-built_in">count</span>()<br></code></pre></td></tr></table></figure>
<p>修改、删除文档</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros">collection.update(&#123;<span class="hljs-string">&quot;author&quot;</span>:<span class="hljs-string">&quot;mike&quot;</span>&#125;,&#123;<span class="hljs-string">&quot;<span class="hljs-variable">$set</span>&quot;</span>:&#123;<span class="hljs-string">&quot;text&quot;</span>:<span class="hljs-string">&quot;python book&quot;</span>&#125;&#125;)  #修改文档<br>collection.<span class="hljs-builtin-name">remove</span>(&#123;<span class="hljs-string">&quot;author&quot;</span>:<span class="hljs-string">&quot;mike&quot;</span>&#125;)<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>数据库</tag>
        <tag>MongoDB</tag>
      </tags>
  </entry>
</search>
