

<!DOCTYPE html>
<html lang="zh-Hans" color-mode=light>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>RPC框架编写实践--自动负载均衡 - So1n blog</title>
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="google" content="notranslate" />
  
  <meta name="description" content="前记在业务早期，业务比较简单， 流量也比较少，单台机器...">
  <meta name="author" content="So1n">
  <link rel="icon" href="/images/icons/favicon.ico" type="image/png" sizes="16x16">
  <link rel="icon" href="/images/icons/favicon.ico" type="image/png" sizes="32x32">
  <link rel="apple-touch-icon" href="/images/icons/favicon.ico" sizes="180x180">
  <meta rel="mask-icon" href="/images/icons/stun-logo.svg" color="#333333">
  
    <meta rel="msapplication-TileImage" content="/images/icons/favicon.ico">
    <meta rel="msapplication-TileColor" content="#000000">
  

  
<link rel="stylesheet" href="/css/style.css">


  
    
<link rel="stylesheet" href="//at.alicdn.com/t/font_1445822_s6x2xcokxrl.css">

  

  
    
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css">

  

  
    
      
        
        
<link rel="stylesheet" href="https://cdn.bootcss.com/highlight.js/9.18.1/styles/atom-one-dark-reasonable.min.css" name="highlight-style" mode="light">

      
        
        
<link rel="stylesheet" href="https://cdn.bootcss.com/highlight.js/9.18.1/styles/atom-one-dark-reasonable.min.css" name="highlight-style" mode="dark">

      
  

  <script>
    var CONFIG = window.CONFIG || {};
    var ZHAOO = window.ZHAOO || {};
    CONFIG = {
      isHome: false,
      fancybox: true,
      pjax: false,
      lazyload: {
        enable: true,
        only_post: 'true',
        loading: '/images/theme/puff.svg'
      },
      donate: {
        enable: true,
        alipay: 'https://github.com/so1n/so1n_blog_photo/blob/master/blog_photo/4d2ebf32586d8799ee2e75333d6f5d2.jpg?raw=true',
        wechat: ''
      },
      galleries: {
        enable: true
      },
      fab: {
        enable: true,
        always_show: true
      },
      carrier: {
        enable: false
      },
      daovoice: {
        enable: false
      },
      preview: {
        background: {
          default: '',
          api: ''
        },
        motto: {
          default: 'I`m   So1n',
          typing: true,
          api: '',
          data_contents: '["data","content"]'
        },
      },
      qrcode: {
        enable: true,
        type: 'url',
        image: 'https://pic.izhaoo.com/weapp-code.jpg',
      },
      toc: {
        enable: true
      },
      scrollbar: {
        type: 'simple'
      },
      notification: {
        enable: false,
        delay: 4500,
        list: '',
        page_white_list: '',
        page_black_list: ''
      },
      search: {
        enable: true,
        path: 'search.xml'
      }
    }
  </script>

  

  

<meta name="generator" content="Hexo 5.3.0"></head>

<body class="lock-screen">
  <div class="loading"></div>
  
    


  <nav class="navbar">
    <div class="left">
      
        <i class="iconfont iconhome j-navbar-back-home"></i>
      
      
        <i class="iconfont iconqrcode j-navbar-qrcode"></i>
      
      
        <i class="iconfont iconmoono" id="color-toggle" color-toggle="light"></i>
      
      
        <i class="iconfont iconsearch j-navbar-search"></i>
      
    </div>
    <div class="center">RPC框架编写实践--自动负载均衡</div>
    <div class="right">
      <i class="iconfont iconmenu j-navbar-menu"></i>
    </div>
    
      <div id="qrcode-navbar"></div>
    
  </nav>

  
  

<nav class="menu">
  <div class="menu-container">
    <div class="menu-close">
      <i class="iconfont iconbaseline-close-px"></i>
    </div>
    <ul class="menu-content"><li class="menu-item">
        <a href="/ " class="underline "> 首页</a>
      </li><li class="menu-item">
        <a target="_blank" rel="noopener" href="http://so1nz.lofter.com/ " class="underline "> 时光</a>
      </li><li class="menu-item">
        <a href="/archives/ " class="underline "> 归档</a>
      </li><li class="menu-item">
        <a href="/tags/ " class="underline "> 标签</a>
      </li><li class="menu-item">
        <a href="/categories/ " class="underline "> 分类</a>
      </li><li class="menu-item">
        <a href="/project/ " class="underline "> 项目</a>
      </li><li class="menu-item">
        <a href="/about/ " class="underline "> 关于</a>
      </li></ul>
    
      <div class="menu-copyright"><p>Powered by <a target="_blank" href="https://hexo.io">Hexo</a>  |  Theme - <a target="_blank" href="https://github.com/izhaoo/hexo-theme-zhaoo">zhaoo</a></p></div>
    
  </div>
</nav>
  <main id="main">
  <div class="article-wrap">
    <div class="row container">
      <div class="col-xl-3"></div>
      <div class="col-xl-6"><article class="article">
  <div class="wrap">
    <section class="head">
  <img src="https://i.loli.net/2021/08/28/tJvKNbnLITB938R.png" draggable="false">
  <div class="head-mask">
    <h1 class="head-title">RPC框架编写实践--自动负载均衡</h1>
    <div class="head-info">
      <span class="post-info-item"><i class="iconfont iconcalendar"></i>October 19, 2021</span>
      
      本文总阅读量<span id="busuanzi_value_page_pv"></span>次
      <span class="post-info-item"><i class="iconfont iconfont-size"></i>11595</span>
    </div>
  </div>
</section>

    <section class="main">
      <section class="content">
        <!-- 展示文章摘录 -->
        <h2 id="前记"><a href="#前记" class="headerlink" title="前记"></a>前记</h2><p>在业务早期，业务比较简单， 流量也比较少，单台机器就可以抗下所有服务流量， 但随着业务的增长， 一些中间件会单独占有一台机器， 业务代码也会逐渐拆分， 从单机的单体架构慢慢的变为多机的微服务架构， 使服务方便管理和变得高可用。而对于用户来说， 他不知道自己的请求会分流到哪个机器， 但是不管分流到哪个机器（即使背后有成千上百的个机器）， 返回的结果必定要一致的， 其中承担用户流量分流到不同机器的技术组件会称为负载均衡, 但是由于微服务的特殊性， 它的负载均衡跟单体架构的负载均衡有很大的区别。</p>
        <h2 id="1-不同网络层的负载均衡组件"><a href="#1-不同网络层的负载均衡组件" class="headerlink" title="1.不同网络层的负载均衡组件"></a>1.不同网络层的负载均衡组件</h2><p>现在后端开发常见的负载均衡组件是<code>Nginx</code>, 没用过也有听过, 基本上所有的服务都有上<code>Nginx</code>, 但实际上所有请求都会接触的负载均衡则是<code>DNS</code>， 因为用户访问目标域名时， 实际上是由<code>DNS</code>分发到对应的ip, 然后用户的请求通过该ip请求到对应的服务器， 所以<code>DNS</code>也是属于一种负载均衡技术, 可见一般用户的请求都会经历<code>DNS</code>和<code>Nginx</code>两次负载均衡。<br>不过真正的大型系统中负载均衡往往是多级的， 比如用户流量会先访问域名， 然后<code>DNS</code>开始解析， 把用户的请求分发到最近的机器A， 机器A的四层负载均衡会把流量分到对应的机器B， 最后由机器B上的<code>Nginx</code>把流量分发到对应的web应用服务。</p>
<p>除了<code>DNS</code>和<code>CDN</code>这种大厂才有的负载均衡服务外， 我们常见的负载均衡可以分为四层负载均衡和七层负载均衡， 这里的四层和七层指的是经典OSI七层模式（见计算机网络相关书籍）中的第4层传输层和第7层应用层。 需要注意的是“四层”是说这些工作模式的共同特点是维持同一个TCP连接，而不是说它只工作在第四层, 事实上，这些模式主要都工作在第二层数据链路层（改写MAC地址）和第三层网络层（改写IP地址）上。<br>第四层负载均衡主要只做转发流量， 流量都是在单独一个TCP链接中流动，而第七层则是代理流量， 此时客户端，负载均衡组件， 服务端三者之间通过两条TCP连接传输着流量。<br>其中第四层性能比第七层高， 因为流量经过机器时， 机器不需要解过多的包， 只要识别MAC地址之类的就可以进行负载均衡转发， 同时这种模式适用于’单臂模式’， 流量从目标机器返回时，可以不直接经过负载均衡机器直接返回到请求机器中， 少走一个节点， 如下图：<br><img  src="https://files.catbox.moe/g169of.png"  ><span class="image-caption">image</span><br>这种方式可以使流量不用跨越太多的机器， 增加传输性能， 但是这种方案也带来了一定的限制， 比如负载均衡机器与节点可能要处于同一个子网， 无法跨VLAN。 可以看到第四层主要注重于性能以及简单的转发， 可定制性和功能也没有第七层的强和多， 适用场景少, 同时由于TCP协议的缺陷， 第四层负载均衡容易收到攻击， 所以一般的负载均衡实现方案都是四层负载和七层负载一起用， 并把第四层负载均衡放置在第七层负载均衡前面。</p>
<h2 id="2-七层负载均衡功能"><a href="#2-七层负载均衡功能" class="headerlink" title="2.七层负载均衡功能"></a>2.七层负载均衡功能</h2><p>第七层负载均衡的主要职能是选择哪个后台应用来处理网络请求， 由于后台应用比较多， 负载均衡必须确保每个请求都能去到最优的服务器， 让用户得到最好的网络响应， 为此出现了很多负载均衡策略， 常见的有：</p>
<ul>
<li>轮训均衡负载： 每一次来自网络的请求轮流分配给内部的服务器，从1至N然后重新开始， 讲究的是最均衡的分配， 每个机器最终处理的请求数量一致。</li>
<li>权重轮训负载均衡： 与轮训负载均衡很像， 但可以配置权重， 把请求更有倾向性的分配到不同的机器， 一般用于后端有多个性能不同的机器。</li>
<li>随机负载： 每次请求都随机负载到某个机器， 在数据量大时， 每个机器处理的请求数很相近</li>
<li>一致性哈希均衡： 根据请求的特征（token， ip）等等作为特征进行计算， 再根据计算结果把请求分配到某个机器上， 一般用于让某个用户只能访问一个机器的情况。</li>
<li>响应速度均衡： 根据过去一段时间内每个机器的响应速度进行计算， 优先把请求转发给响应时间短的机器</li>
<li>最少连接均衡：根据过去一段时间内每个机器的连接数进行计算， 优先把请求转发给处理请求数少的机器。</li>
</ul>
<p>为了上述的负载均衡策略得以实现， 负载均衡组件通常还必须拥有健康检查功能， 检查每个服务是否可用，同时也需要服务发现功能， 在节点变多后， 通过服务发现来动态修改后端节点。</p>
<p>此外， 常用的负载均衡组件， 如<code>Nginx</code>除了代理流量外， 还会承担一些静态文件请求， 以及缓存， 内容分发, 以及带有一些流量复制， 流量监控等等的功能 </p>
<h2 id="3-微服务的负载均衡组件"><a href="#3-微服务的负载均衡组件" class="headerlink" title="3.微服务的负载均衡组件"></a>3.微服务的负载均衡组件</h2><p>流量从客户端到后台应用的链路中， 所有组件应尽可能的避免使用单点组件。 一般在一开始接触<code>Nginx</code>时， 我们都会以一台<code>Nginx</code>来处理所有流量, 这种方法叫集中式的负载均衡， 这种负载均衡方法很致命的问题就是单点依赖问题, 当这个组件挂的时候， 后台所有服务都无法处理客户端的请求, 所以在整个后台系统中， 应当尽量避免这个情况。 由于微服务基本上都处于在一个内网之中， 可以不用考虑有个网关之类的服务来过滤非法请求， 同时在微服务设计中， 所有的服务都尽可能的拆成自己单一的服务， 此时若还依赖<code>Nginx</code>来做单点负载均衡， 则很容易使所有微服务由于<code>Nginx</code>出现问题而无法处理请求, 同时所有流量都需要经过一层<code>Nginx</code>进行转发， 会浪费机器资源, 所以微服务最好不去使用这种负载均衡模式， 那微服务的负载均衡该怎么做呢？</p>
<p>由于微服务有个明显的特征， 就是它处理的请求都是在内部集群中流转， 不像传统负载均衡一样需要处理外部的请求, 从微服务客户端请求的数据基本是可信的(代码是自己写的， 在发起请求前就能自动过滤掉非法的请求), 那么可以采用称为客户端负载均衡模式的分布式负载均衡， 这种模式相当于每个微服务都内置了自己的一个负载均衡实现， 把一个单一的负载均衡变为分布式的负载均衡， 这种方式十分灵活，每个服务都可以单独设置单种负载均衡方式，以及附加的功能， 同时可以避免单一组件的危险， 减少流量要在集群内部绕圈圈的局面。 但是这种方案也是有局限性的，它跟服务是同一个进程， 意味着它的实现必须与服务同一个语言，负载均衡的稳定性也会影响到同一个进程的CPU，内存等资源（所以就出现了服务网格与边车代理， 但不是本文的相关内容）。不过，这种模式只负责做负责均衡， 没办法自动发现有多少个可用节点， 还是会依赖一个单一组件–配置中心， 它需要通过配置中心来了解这个服务对应的集群ip是多少， 以及服务是否上下线。</p>
<h2 id="4-自动负载均衡的实现"><a href="#4-自动负载均衡的实现" class="headerlink" title="4.自动负载均衡的实现"></a>4.自动负载均衡的实现</h2><p>上面说了很多了， 那负载均衡该如何实现呢， 首先要明确自己的要求是什么：</p>
<ul>
<li>1.客户端能够自动感应服务端节点的上下线。</li>
<li>2.在没人工干预的情况下， 能自动隔离故障的节点， 并在节点恢复的时候自动恢复。</li>
<li>3.每次选择节点时，选取到的节点都是距离当前服务最近的，响应尽可能快, 负载尽可能小的。</li>
<li>4.不会因为负载均衡造成羊群效应， 一切的变动都是非常及时的。</li>
</ul>
<p>对于第一个要求， 则需要依赖于注册/配置中心， 通过注册中心来自动获取/感知对应服务的上下线， 通过配置中心来更改权重值等配置， 这会在注册中心的文章进行介绍。</p>
<p>对于第二个要求， 则采用健康检查的思路， 客户端会每隔一个时间后发送一个ping信息到对应的目标服务， 根据ping的成功率来决定是否要自动隔离目标节点以及恢复， 比如最近3次都ping失败就可以判断对应的节点已经故障， 可用性为0， 不再分发请求到该节点， 直到最近3次Ping都成功为止。</p>
<p>而第三种和第四种， 就是最复杂， 也是最重要的了, 是自动负载均衡的核心部分， 我的RPC务框架的客户端实现一定程度参考了<code>kratos</code>框架的1.x版本。 这个实现简单的说就是从连接池中挑选对应的多个连接， 通过打分的形式综合自己当前的连接状态和服务端的情况进行打分， 然后判断哪个连接的分数比较高， 并选取分数最高的连接作为本次请求的连接，其中涉及到的名词有从多个连接选取最想要的一个–p2c, 反映近期数值变化的加权平均数–EWMA和主观批评方法–mos。接下来将从离自动负载均衡最远到近一个一个参数进行介绍。</p>
<h3 id="4-1-mos"><a href="#4-1-mos" class="headerlink" title="4.1.mos"></a>4.1.mos</h3><p>首先是mos, mos是衡量服务端当前压力的值, 这是我在RTCP通话质量分析里面学到的词， 这个值只会在0-5波动, 0代表不可用， 5代表最佳。 为了减少资源消耗， 服务端会实时记录请求数据指标， 通过滑动窗口每隔一段时间计算一次mos值, 并保存在内存中, 或者更新内存中的值(详见<a href="https://so1n.me/2021/08/24/RPC%E6%A1%86%E6%9E%B6%E7%BC%96%E5%86%99%E5%AE%9E%E8%B7%B5--%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86%E7%9A%84%E5%9F%BA%E7%9F%B3/">服务治理的基石</a>)。<br>然后在客户端通过ping-pong请求发送ping到服务端时， 服务端会把位于内存的mos值放在响应体中返回给客户端, 客户端并不需要知道这个值是怎么来的, 是依赖哪些指标生成的， 只需要知道在自动负载均衡中对应的服务的mos值越高， 就更应该连接到这个服务。</p>
<blockquote>
<p>NOTE: <code>Kratos</code>框架会在每次请求都返回最新的服务端压力指标, 如cpu使用率，并发数等等，然后客户端收到指标数据后会实时的根据这些指标进行计算。 我在实践的时候感觉这样做作用不大，同时又很废网络流量，故而只通过ping-pong的请求来获取指标，减少客户端的计算量和网络传输资源的占用。</p>
</blockquote>
<p>那服务端依赖哪些指标来生成mos值呢， 前面说道， 这些值可以来衡量服务端当前的压力呢， 例如Linux系统有一个叫load的变量， 来衡量机器的负载， 而对于服务端来说， 可以衡量的值比较多， 具体需要根据场景来选用， 常用的有：</p>
<ul>
<li>QPS-每秒请求数， 意味着每秒收到的请求数量。此外还有一个叫预估峰值QPS, 原理是每天80%的访问集中在20%的时间里，这20%时间叫做峰值时间，而峰值QPS的计算是(每天的请求数<em>80%)/(每天秒数</em>20%)，假设每天的请求数为100W，那么峰值QPS为46。</li>
<li>TPS-每秒处理的事务数，系统整体处理能力取决于处理能力最低模块的TPS值。</li>
<li>RT-系统对请求作出响应的时间， 这个值对于用户来说是最直观的， 所以该值也是非常的重要。</li>
<li>并发数-该机器同一时刻的处理量， 该值越高，机器压力越大。</li>
<li>CPU使用率-CPU的使用量， 对于CPU密集型的应用来说， CPU使用率是一个很重要的指标。</li>
<li>请求错误数-一般来说，当服务出现错误时，可能会伴随这其他系统资源的占用并且没来得及释放， 当请求错误数变多时，可以假想机器的压力变大。</li>
</ul>
<p>我在为框架写一个通用的mos计算时， 去掉了一些业务相关的压力指标依赖， 选择了一些通用的压力指标如cpu使用率，请求数，响应数，错误数，当前正在处理请求数， 当前channel数量， 这些指标经过计算最后只会在0到1直接波动， 通过这些指标与5进行计算, 最后取值范围在0-5之间，具体代码见:<a target="_blank" rel="noopener" href="https://github.com/so1n/rap/blob/master/rap/server/plugin/processor/mos.py">https://github.com/so1n/rap/blob/master/rap/server/plugin/processor/mos.py</a></p>
<h3 id="4-2-EWMA"><a href="#4-2-EWMA" class="headerlink" title="4.2.EWMA"></a>4.2.EWMA</h3><p>客户端在获取了服务端的mos值后，客户端可以把mos与自己的指标进行计算去得出一个负载均衡的评分， 但是服务端的mos并不是实时获取出来的， 通常都会有一段延时， 这样算出来的评分可能没办法反映真实的情况， 需要一个算法来适当的修正， 而EWMA的修正则是可以让这个mos值变得更加的真实。</p>
<p>EWMA全称为Exponentially Weighted Averages，中文意思为指数移动加权平均， 它体现的是一段时间内的平均值，此算法是对观察值分别给予不同的权数，按不同权数求得移动平均值，并以最后的移动平均值为基础，确定预测值的方法。 采用加权移动平均法，是因为观察期的近期观察值对预测值有较大影响，它更能反映近期变化的趋势， 同时它不需要保存过去的所有数值， 计算量也不大， 适合经常更新数据的服务， 同时对于网络抖动比较敏感。</p>
<p>EWMA的公式如下：<br>$$V_t=w*V_{t-1} + (1-w)*T_{t}$$</p>
<p>这个公式中，Vt代表第t次请求时的EWMA值，Vt-1代表第t-1次请求的EWMA值，Tt代表第t次请求的实际耗时, 先把EWMA相关的值忽略当为1可以发现， 公式中参数<code>w</code>是跟请求频率相关的， 我们可以通过控制这个值来迅速的监控到网络毛刺， 比如当请求频繁时，说明节点负载变高了，我们就需要相对的调小该值，如果请求不频繁， 则可以调大该值， 这样计算出来的EWMA就越接近平均值。 在经过一番查找后， 发现可以运用牛顿冷却定律的衰减函数模型（见<a target="_blank" rel="noopener" href="https://blog.51cto.com/u_9269309/1865554">基于牛顿冷却定律的时间衰减函数模型</a>）来进行计算， 从而生成符合该条件的<code>w</code>值， 而牛顿冷却定律的时间衰减公式为：<code>w=1/e^(k*△t) </code>, 其中可以把<code>△t</code>认为是两次请求的间隔， 而e, k为常变量, 通常一个是1，另外一个需要自己根据响应时间的平均时长来进行计算。</p>
<p>了解完EWMA后就可以开始实现了， 代码如下(具体见：<a target="_blank" rel="noopener" href="https://github.com/so1n/rap/blob/master/rap/client/transport/transport.py#L193)%EF%BC%9A">https://github.com/so1n/rap/blob/master/rap/client/transport/transport.py#L193)：</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">ping</span>(<span class="hljs-params">self, conn: Connection, deadline: Deadline</span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>    start_time: <span class="hljs-built_in">float</span> = time.time()<br>    <span class="hljs-comment"># 初始化mos和延迟rtt</span><br>    mos: <span class="hljs-built_in">int</span> = <span class="hljs-number">5</span><br>    rtt: <span class="hljs-built_in">float</span> = <span class="hljs-number">0</span><br><br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_ping</span>() -&gt; <span class="hljs-keyword">None</span>:</span><br>        <span class="hljs-comment"># 发送ping请求， 并处理ping的响应体， 从而得出响应时长和服务端返回的mos</span><br>        <span class="hljs-keyword">nonlocal</span> mos<br>        <span class="hljs-keyword">nonlocal</span> rtt<br>        response: Response = <span class="hljs-keyword">await</span> self._base_request(Request.from_event(self.app, event.PingEvent(&#123;&#125;)), conn)<br>        rtt += time.time() - start_time<br>        mos += response.body.get(<span class="hljs-string">&quot;mos&quot;</span>, <span class="hljs-number">5</span>)<br><br>    <span class="hljs-comment"># 发送3次ping请求</span><br>    <span class="hljs-keyword">with</span> deadline.inherit():<br>        <span class="hljs-keyword">await</span> asyncio.gather(*[_ping(), _ping(), _ping()])<br><br>    <span class="hljs-comment"># 算出这3次请求的平均值</span><br>    mos = mos // <span class="hljs-number">3</span><br>    rtt = rtt / <span class="hljs-number">3</span><br><br>    <span class="hljs-comment"># 获取初始值与上次请求的值</span><br>    now_time: <span class="hljs-built_in">float</span> = time.time()<br>    old_last_ping_timestamp: <span class="hljs-built_in">float</span> = conn.last_ping_timestamp<br>    old_rtt: <span class="hljs-built_in">float</span> = conn.rtt<br>    old_mos: <span class="hljs-built_in">int</span> = conn.mos<br><br>    <span class="hljs-comment"># 计算两次请求间隔， 从而计算出w, 由于我的ping是随机间隔1-3秒， 所以self._decay_time设定在600左右 </span><br>    td: <span class="hljs-built_in">float</span> = now_time - old_last_ping_timestamp<br>    w: <span class="hljs-built_in">float</span> = math.exp(-td / self._decay_time)<br><br>    <span class="hljs-keyword">if</span> rtt &lt; <span class="hljs-number">0</span>:<br>        rtt = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">if</span> old_rtt &lt;= <span class="hljs-number">0</span>:<br>        w = <span class="hljs-number">0</span><br><br>    <span class="hljs-comment"># 通过EWMA公式来计算rtt和mos</span><br>    conn.rtt = old_rtt * w + rtt * (<span class="hljs-number">1</span> - w)<br>    conn.mos = <span class="hljs-built_in">int</span>(old_mos * w + mos * (<span class="hljs-number">1</span> - w))<br>    conn.last_ping_timestamp = now_time<br>    <span class="hljs-comment"># 通过本次rtt, mos以及用户指定的权重值进行计算打分， 得出对应的分数</span><br>    conn.score = (conn.weight * mos) / conn.rtt<br></code></pre></td></tr></table></figure>
<h3 id="4-3-选择最佳节点"><a href="#4-3-选择最佳节点" class="headerlink" title="4.3.选择最佳节点"></a>4.3.选择最佳节点</h3><p>一般来说， 为了增加服务的可用性， 同一个服务会由多个服务端来提供， 这样对于客户端来说会有很多可选节点， 如果客户端每次请求都从所有节点进行比较, 再选出最合适的连接来进行请求则会比较消耗计算资源与时间，这是没必要的。 因为大部分节点在大部分时间内的状态都是正常的, 只有在一些特殊情况才会发生异常状况， 而我们要做到的就是在有异常情况的时候尽量的不要去选择有问题的连接， 这时就需要P2C。 P2C很容易理解， 就是从多个节点中随机选择两个节点， 通过随机选取的方式， 可以在占用极小的计算资源的情况下选取合适的连接， 同时尽量的避免在异常情况下选到不可用的连接（都选到的不可用的连接的概率非常的小, 即使选到了， 也可以通过其他服务治理来规避问题）， 除了随机外， 也支可以持其他方式（当然， 这种方式需要尽量的简单）， 类似于2里面说的负载均衡，具体实现代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">picker</span>(<span class="hljs-params">self, cnt: Optional[<span class="hljs-built_in">int</span>] = <span class="hljs-literal">None</span></span>) -&gt; Picker:</span><br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    自动算出需要一次获取多少个连接数， P2C默认是获取2个， 我这里则是默认获取3次， 因为获取的连接有可能是不可用的</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> cnt:<br>        <span class="hljs-keyword">if</span> self._connected_cnt &lt;= <span class="hljs-number">3</span>:<br>            cnt = self._connected_cnt<br>        <span class="hljs-keyword">else</span>:<br>            cnt = <span class="hljs-number">3</span><br>    <span class="hljs-keyword">if</span> cnt &lt;= <span class="hljs-number">0</span>:<br>        cnt = <span class="hljs-number">1</span><br><br>    conn_list: List[Connection] = self._pick_conn(cnt)<br>    <span class="hljs-keyword">return</span> Picker(conn_list)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_pick_conn</span>(<span class="hljs-params">self, cnt: <span class="hljs-built_in">int</span></span>) -&gt; List[Connection]:</span><br>    <span class="hljs-string">&quot;&quot;&quot;默认的获取连接方法， 通过启动配置可以配置成下面对应的获取连接方法&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">pass</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_random_pick_conn</span>(<span class="hljs-params">self, cnt: <span class="hljs-built_in">int</span></span>) -&gt; List[Connection]:</span><br>    <span class="hljs-string">&quot;&quot;&quot;随机获取连接的方法， 一般来说获取的连接都是无规律的&quot;&quot;&quot;</span><br>    cnt = <span class="hljs-built_in">min</span>(cnt, <span class="hljs-built_in">len</span>(self._conn_dict))<br>    key_list: List[<span class="hljs-built_in">tuple</span>] = <span class="hljs-built_in">list</span>(self._conn_dict.keys())<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> key_list:<br>        <span class="hljs-keyword">raise</span> ConnectionError(<span class="hljs-string">&quot;Endpoint Can not found available conn&quot;</span>)<br>    conn_list: List[Connection] = []<br>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(cnt):<br>        key: <span class="hljs-built_in">tuple</span> = random.choice(key_list)<br>        conn: Connection = self._conn_dict[key]<br>        <span class="hljs-keyword">if</span> conn.available:<br>            conn_list.append(conn)<br><br>    <span class="hljs-keyword">return</span> conn_list<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_round_robin_pick_conn</span>(<span class="hljs-params">self, cnt: <span class="hljs-built_in">int</span></span>) -&gt; List[Connection]:</span><br>    <span class="hljs-string">&quot;&quot;&quot;轮训获取连接的方法， 不加锁可能导致获取的连接是不连续的， 但是影响不大&quot;&quot;&quot;</span><br>    conn_list: List[Connection] = []<br>    key_list: List[<span class="hljs-built_in">tuple</span>] = <span class="hljs-built_in">list</span>(self._conn_dict.keys())<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> key_list:<br>        <span class="hljs-keyword">raise</span> ConnectionError(<span class="hljs-string">&quot;Endpoint Can not found available conn&quot;</span>)<br>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(cnt):<br>        self._round_robin_index += <span class="hljs-number">1</span><br>        index = self._round_robin_index % (<span class="hljs-built_in">len</span>(self._conn_dict))<br>        conn: Connection = self._conn_dict[key_list[index]]<br>        <span class="hljs-keyword">if</span> conn.available:<br>            conn_list.append(conn)<br>    <span class="hljs-keyword">return</span> conn_list<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_pick_faster_conn</span>(<span class="hljs-params">self, cnt: <span class="hljs-built_in">int</span></span>) -&gt; List[Connection]:</span><br>    <span class="hljs-string">&quot;&quot;&quot;根据响应时间来获取连接， 通常来说会经常使用响应速度最快的连接， 不太推荐&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">sorted</span>([i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> self._conn_dict.values() <span class="hljs-keyword">if</span> i.available], key=<span class="hljs-keyword">lambda</span> c: c.rtt)[:cnt]<br></code></pre></td></tr></table></figure>
<p>选择完了连接后， 就需要依赖打分机制来决定最终需要选谁了， 上面说过，客户端可以通过ping-pong机制获取到服务对应的mos值, 并进行打分， 但是ping-pong的间隔是随机的1-3秒, 所以客户端更新对应服务的分数的间隔时间也是随机的1-3秒， 这样的更新频率并不快, 如果直接使用该值做自动化负载均衡的话， 那就会造成短时间内流量都跑到该更新时间周期内压力最少的机器上面， 从而产生羊群效应，造成这些机器短时间内产生极大的压力， 整个内部网络环境的流量也是极不均衡的， 所以还需要客户端依赖自己的一些连接数据来生成最后的打分情况。<br>这个值就是客户端与每个服务的正在请求数, 通过连接数可以衡量当前客户端会把流量发送到哪里， 如果发现发送的量不均衡， 那么正在请求的数会变得不均衡, 在<code>rap</code>这个框架中， 负责这个功能的类叫<code>Picker</code>, 它除了管理获取最佳连接外， 还通过信号量来管理每个连接的使用情况， 包括当前连接有多少个请求， 是否超过使用量等等， 具体代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Picker</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, conn_list: List[Connection]</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;该类是由上面picker函数创建的, 所以这些值也就是那个阶段中确定了&quot;&quot;&quot;</span><br>        self._conn: Connection = self._pick(conn_list)<br>        self._start_time: <span class="hljs-built_in">float</span> = time.time()<br><br><span class="hljs-meta">    @staticmethod</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_pick</span>(<span class="hljs-params">conn_list: List[Connection]</span>) -&gt; Connection:</span><br>        <span class="hljs-string">&quot;&quot;&quot;pick by score&quot;&quot;&quot;</span><br>        pick_conn: Optional[Connection] = <span class="hljs-literal">None</span><br>        conn_len: <span class="hljs-built_in">int</span> = <span class="hljs-built_in">len</span>(conn_list)<br>        <span class="hljs-keyword">if</span> conn_len == <span class="hljs-number">1</span>:<br>            <span class="hljs-comment"># 如果只有一个可用的连接， 则不用进行对比， 直接采用</span><br>            pick_conn = conn_list[<span class="hljs-number">0</span>]<br>        <span class="hljs-keyword">elif</span> conn_len &gt; <span class="hljs-number">1</span>:<br>            <span class="hljs-comment"># 如果可用连接多于一个， 就开始进入对比阶段</span><br>            score: <span class="hljs-built_in">float</span> = <span class="hljs-number">0.0</span><br>            <span class="hljs-keyword">for</span> conn <span class="hljs-keyword">in</span> conn_list:<br>                <span class="hljs-comment"># 通过信号量获取当前正在使用连接的量</span><br>                conn_inflight: <span class="hljs-built_in">float</span> = conn.semaphore.inflight<br>                <span class="hljs-comment"># 服务端返回的值计算出的评分</span><br>                _score: <span class="hljs-built_in">float</span> = conn.score<br>                <span class="hljs-keyword">if</span> conn_inflight:<br>                    <span class="hljs-comment"># 通过正在使用连接的量计算正真的评分 </span><br>                    _score = _score / conn_inflight<br>                logging.debug(<span class="hljs-string">&quot;conn:%s available:%s rtt:%s score:%s&quot;</span>, conn.peer_tuple, conn.available, conn.rtt, _score)<br>                <span class="hljs-keyword">if</span> _score &gt; score:<br>                    score = _score<br>                    pick_conn = conn<br>        <span class="hljs-comment"># 如果没有可用连接，则报错</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> pick_conn:<br>            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&quot;Can not found available conn&quot;</span>)<br>        <span class="hljs-keyword">return</span> pick_conn<br><br>    <span class="hljs-comment"># 通过__aenter__和__aexit__限制了调用端只能通过async with pick来获取可用的连接， 以此方便通过信号量来管理连接的使用量</span><br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__aenter__</span>(<span class="hljs-params">self</span>) -&gt; Connection:</span><br>        <span class="hljs-keyword">await</span> self._conn.semaphore.acquire()<br>        <span class="hljs-keyword">return</span> self._conn<br><br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__aexit__</span>(<span class="hljs-params">self, exc_type: Any, exc_val: Any, exc_tb: Any</span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        self._conn.semaphore.release()<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br></code></pre></td></tr></table></figure>
<h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5.总结"></a>5.总结</h2><p>第一次调差自动负载均衡的资料时， 理解了很久， 但在经过实践后， 发现只要理解了EWMA的方法并去理解它同时自动化负载均衡的原理十分简单， 就是在正常的情况下尽可能的平均的去请求到服务端， 同时保证在某个服务端压力变大时， 尽量的不去选取它即可。 但是上面实现起来有一个弊端， 就是自动化负载均衡跟客户端是在同一个进程内的， 所以跨语言的话就得重新开发一个， 负载均衡的实现好坏也会影响到客户端对应的性能， 所以更好的方法是采用边车代理的方式来实现自动负载均衡。</p>
      </section>
      <section class="extra">
        
          <ul class="copyright">
  
    <li><strong>本文作者：</strong>So1n</li>
    <li><strong>本文链接：</strong><a href="http://so1n.me/2021/10/19/RPC%E6%A1%86%E6%9E%B6%E7%BC%96%E5%86%99%E5%AE%9E%E8%B7%B5--%E8%87%AA%E5%8A%A8%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/index.html" title="http:&#x2F;&#x2F;so1n.me&#x2F;2021&#x2F;10&#x2F;19&#x2F;RPC%E6%A1%86%E6%9E%B6%E7%BC%96%E5%86%99%E5%AE%9E%E8%B7%B5--%E8%87%AA%E5%8A%A8%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1&#x2F;index.html">http:&#x2F;&#x2F;so1n.me&#x2F;2021&#x2F;10&#x2F;19&#x2F;RPC%E6%A1%86%E6%9E%B6%E7%BC%96%E5%86%99%E5%AE%9E%E8%B7%B5--%E8%87%AA%E5%8A%A8%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1&#x2F;index.html</a></li>
    <li><strong>版权声明：</strong>本博客所有文章均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" title="BY-NC-SA" target="_blank" rel="noopener">BY-NC-SA</a> 许可协议，转载请注明出处！</li>
  
</ul>
        
        
          <section class="donate">
  <div id="qrcode-donate">
    <img src="https://github.com/so1n/so1n_blog_photo/blob/master/blog_photo/4d2ebf32586d8799ee2e75333d6f5d2.jpg?raw=true">
  </div>
  <div class="icon">
    <a href="javascript:;" id="alipay"><i class="iconfont iconalipay"></i></a>
    <a href="javascript:;" id="wechat"><i class="iconfont iconwechat-fill"></i></a>
  </div>
</section>
        
        
  <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python/" rel="tag">Python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RPC/" rel="tag">RPC</a></li></ul> 

        
  <nav class="nav">
    <a></a>
    <a href="/2021/08/28/RPC%E6%A1%86%E6%9E%B6%E7%BC%96%E5%86%99%E5%AE%9E%E8%B7%B5--%E4%BC%98%E9%9B%85%E7%9A%84%E9%87%8D%E5%90%AF/">RPC框架编写实践--服务的优雅的重启<i class="iconfont iconright"></i></a>
  </nav>

      </section>
      
        <section class="comments">
  
    <div class="btn" id="comments-btn">查看评论</div>
  
  
<link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<div id="gitalk" class="gitalk"></div>
<script defer src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
<script>
  window.onload = function () {
    var gitalk = new Gitalk({
      clientID: '59f804e526b05c378470',
      clientSecret: '36679ff697cec424936a0f7c4bcd6d2988dac28e',
      id: window.location.pathname,
      repo: 'so1n.github.io',
      owner: 'so1n',
      admin: 'so1n'
    });
    if ( true ) {
      $("#comments-btn").on("click", function () {
        $(this).hide();
        gitalk.render('gitalk');
      });
    } else {
      gitalk.render('gitalk');
    }
  }
</script>

</section>
      
    </section>
  </div>
</article>
</div>
      <div class="col-xl-3">
          
  <aside class="toc-wrap">
    <h3 class="toc-title">文章目录：</h3>
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%AE%B0"><span class="toc-text">前记</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E4%B8%8D%E5%90%8C%E7%BD%91%E7%BB%9C%E5%B1%82%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%BB%84%E4%BB%B6"><span class="toc-text">1.不同网络层的负载均衡组件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E4%B8%83%E5%B1%82%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%8A%9F%E8%83%BD"><span class="toc-text">2.七层负载均衡功能</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%BB%84%E4%BB%B6"><span class="toc-text">3.微服务的负载均衡组件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E8%87%AA%E5%8A%A8%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-text">4.自动负载均衡的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-mos"><span class="toc-text">4.1.mos</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-EWMA"><span class="toc-text">4.2.EWMA</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E9%80%89%E6%8B%A9%E6%9C%80%E4%BD%B3%E8%8A%82%E7%82%B9"><span class="toc-text">4.3.选择最佳节点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E6%80%BB%E7%BB%93"><span class="toc-text">5.总结</span></a></li></ol>
  </aside>

        
          
  <aside class="toc-wrap">
    <h3 class="toc-title">文章目录：</h3>
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%AE%B0"><span class="toc-text">前记</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E4%B8%8D%E5%90%8C%E7%BD%91%E7%BB%9C%E5%B1%82%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%BB%84%E4%BB%B6"><span class="toc-text">1.不同网络层的负载均衡组件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E4%B8%83%E5%B1%82%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%8A%9F%E8%83%BD"><span class="toc-text">2.七层负载均衡功能</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%BB%84%E4%BB%B6"><span class="toc-text">3.微服务的负载均衡组件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E8%87%AA%E5%8A%A8%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-text">4.自动负载均衡的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-mos"><span class="toc-text">4.1.mos</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-EWMA"><span class="toc-text">4.2.EWMA</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E9%80%89%E6%8B%A9%E6%9C%80%E4%BD%B3%E8%8A%82%E7%82%B9"><span class="toc-text">4.3.选择最佳节点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E6%80%BB%E7%BB%93"><span class="toc-text">5.总结</span></a></li></ol>
  </aside>

        
      </div>
    </div>
  </div>
</main>

  <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js">
</script>


<footer class="footer">
  <div class="footer-social"><a 
        href="https://github.com/so1n "
        target="_blank"
        class="footer-social-item"
        onMouseOver="this.style.color= '#9f7be1'" 
        onMouseOut="this.style.color='#33333D'">
          <i class="iconfont  icongithub-fill "></i>
      </a></div>
  
    <div class="footer-copyright"><p>Powered by <a target="_blank" href="https://hexo.io">Hexo</a>  |  Theme - <a target="_blank" href="https://github.com/izhaoo/hexo-theme-zhaoo">zhaoo</a></p></div>
  
  <div class="footer-copyright">
    总访问量<span id="busuanzi_value_site_pv"></span>次
    访客数<span id="busuanzi_value_site_uv"></span>人次
  </div>

</footer>

  
      <div class="fab fab-plus">
    <i class="iconfont iconplus"></i>
  </div>
  
  
  <div class="fab fab-up">
    <i class="iconfont iconcaret-up"></i>
  </div>
  
  
    <div class="scrollbar j-scrollbar">
  <div class="scrollbar-current j-scrollbar-current"></div>
</div>
  
  
    
<script src="/js/color-mode.js"></script>

  
  
    <div class="search">
  <div class="search-container">
    <div class="search-close">
      <i class="iconfont iconbaseline-close-px"></i>
    </div>
    <div class="search-input-wrapper">
      <i class="search-input-icon iconfont iconsearch"></i>
      <input class="search-input" type="search" id="search-input" placeholder="Search..." autofocus autocomplete="off"
        autocorrect="off" autocapitalize="off">
    </div>
    <div class="search-output" id="search-output"></div>
  </div>
</div>
  
</body>

<script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script>



  
<script src="https://cdn.bootcdn.net/ajax/libs/jquery.lazyload/1.9.1/jquery.lazyload.min.js"></script>




  
<script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js"></script>






  
<script src="https://cdn.bootcdn.net/ajax/libs/jquery.qrcode/1.0/jquery.qrcode.min.js"></script>




<script src="/js/utils.js"></script>
<script src="/js/script.js"></script>







  <script>
    (function () {
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
      } else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>













</html>