

<!DOCTYPE html>
<html lang="zh-Hans" color-mode=light>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>starlette源码分析 - So1n blog</title>
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="google" content="notranslate" />
  
  <meta name="description" content="前记上一篇分析了uvicorn， 但是uvicorn只...">
  <meta name="author" content="So1n">
  <link rel="icon" href="/images/icons/favicon.ico" type="image/png" sizes="16x16">
  <link rel="icon" href="/images/icons/favicon.ico" type="image/png" sizes="32x32">
  <link rel="apple-touch-icon" href="/images/icons/favicon.ico" sizes="180x180">
  <meta rel="mask-icon" href="/images/icons/stun-logo.svg" color="#333333">
  
    <meta rel="msapplication-TileImage" content="/images/icons/favicon.ico">
    <meta rel="msapplication-TileColor" content="#000000">
  

  
<link rel="stylesheet" href="/css/style.css">


  
    
<link rel="stylesheet" href="//at.alicdn.com/t/font_1445822_s6x2xcokxrl.css">

  

  
    
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css">

  

  
    
      
        
        
<link rel="stylesheet" href="https://cdn.bootcss.com/highlight.js/9.18.1/styles/atom-one-dark-reasonable.min.css" name="highlight-style" mode="light">

      
        
        
<link rel="stylesheet" href="https://cdn.bootcss.com/highlight.js/9.18.1/styles/atom-one-dark-reasonable.min.css" name="highlight-style" mode="dark">

      
  

  <script>
    var CONFIG = window.CONFIG || {};
    var ZHAOO = window.ZHAOO || {};
    CONFIG = {
      isHome: false,
      fancybox: true,
      pjax: false,
      lazyload: {
        enable: true,
        only_post: 'true',
        loading: '/images/theme/puff.svg'
      },
      donate: {
        enable: true,
        alipay: 'https://github.com/so1n/so1n_blog_photo/blob/master/blog_photo/4d2ebf32586d8799ee2e75333d6f5d2.jpg?raw=true',
        wechat: ''
      },
      galleries: {
        enable: true
      },
      fab: {
        enable: true,
        always_show: true
      },
      carrier: {
        enable: false
      },
      daovoice: {
        enable: false
      },
      preview: {
        background: {
          default: '',
          api: ''
        },
        motto: {
          default: 'I`m   So1n',
          typing: true,
          api: '',
          data_contents: '["data","content"]'
        },
      },
      qrcode: {
        enable: true,
        type: 'url',
        image: 'https://pic.izhaoo.com/weapp-code.jpg',
      },
      toc: {
        enable: true
      },
      scrollbar: {
        type: 'simple'
      },
      notification: {
        enable: false,
        delay: 4500,
        list: '',
        page_white_list: '',
        page_black_list: ''
      },
      search: {
        enable: true,
        path: 'search.xml'
      }
    }
  </script>

  

  

<meta name="generator" content="Hexo 5.4.0"></head>

<body class="lock-screen">
  <div class="loading"></div>
  
    


  <nav class="navbar">
    <div class="left">
      
        <i class="iconfont iconhome j-navbar-back-home"></i>
      
      
        <i class="iconfont iconqrcode j-navbar-qrcode"></i>
      
      
        <i class="iconfont iconmoono" id="color-toggle" color-toggle="light"></i>
      
      
        <i class="iconfont iconsearch j-navbar-search"></i>
      
    </div>
    <div class="center">starlette源码分析</div>
    <div class="right">
      <i class="iconfont iconmenu j-navbar-menu"></i>
    </div>
    
      <div id="qrcode-navbar"></div>
    
  </nav>

  
  

<nav class="menu">
  <div class="menu-container">
    <div class="menu-close">
      <i class="iconfont iconbaseline-close-px"></i>
    </div>
    <ul class="menu-content"><li class="menu-item">
        <a href="/ " class="underline "> 首页</a>
      </li><li class="menu-item">
        <a target="_blank" rel="noopener" href="http://so1nz.lofter.com/ " class="underline "> 时光</a>
      </li><li class="menu-item">
        <a href="/archives/ " class="underline "> 归档</a>
      </li><li class="menu-item">
        <a href="/tags/ " class="underline "> 标签</a>
      </li><li class="menu-item">
        <a href="/categories/ " class="underline "> 分类</a>
      </li><li class="menu-item">
        <a href="/project/ " class="underline "> 项目</a>
      </li><li class="menu-item">
        <a href="/about/ " class="underline "> 关于</a>
      </li></ul>
    
      <div class="menu-copyright"><p>Powered by <a target="_blank" href="https://hexo.io">Hexo</a>  |  Theme - <a target="_blank" href="https://github.com/izhaoo/hexo-theme-zhaoo">zhaoo</a></p></div>
    
  </div>
</nav>
  <main id="main">
  <div class="article-wrap">
    <div class="row container">
      <div class="col-xl-3"></div>
      <div class="col-xl-6"><article class="article">
  <div class="wrap">
    <section class="head">
  <img src="https://www.starlette.io/img/starlette.png" draggable="false">
  <div class="head-mask">
    <h1 class="head-title">starlette源码分析</h1>
    <div class="head-info">
      <span class="post-info-item"><i class="iconfont iconcalendar"></i>November 15, 2021</span>
      
      本文总阅读量<span id="busuanzi_value_page_pv"></span>次
      <span class="post-info-item"><i class="iconfont iconfont-size"></i>33868</span>
    </div>
  </div>
</section>

    <section class="main">
      <section class="content">
        <!-- 展示文章摘录 -->
        <h2 id="前记"><a href="#前记" class="headerlink" title="前记"></a>前记</h2><p>上一篇分析了<code>uvicorn</code>， 但是<code>uvicorn</code>只是一个ASGI容器， 真正处理请求的是ASGI应用程序，而<code>starlette</code>是最出名也是最标准的ASGI应用程序， 通过了解<code>starlette</code>, 可以了解到每个组件都是ASGI APP的设计理念， 了解ASGI APP的兼容性， 能更完整的理解ASGI生态。</p>
<blockquote>
<p>NOTE: 使用了几年的<code>starlette</code>以来， 简单了翻过了几次源码， 觉得<code>starlette</code>堪称工艺品， 设计很完美， 各种逻辑实现起来很简单(也可能是我一开始就使用了sanic框架)， 从使用至今， 除了初始化中间件， 在中间件读取body以及官方示例文档比较少这些缺点外， 感觉不出有其他的槽点。</p>
</blockquote>
        <blockquote>
<p>NOTE: 本文偏代码+注释比较多</p>
</blockquote>
<h2 id="1-starlette的应用"><a href="#1-starlette的应用" class="headerlink" title="1.starlette的应用"></a>1.starlette的应用</h2><p>在之前的<a href="https://so1n.me/2021/08/19/uvicorn/">文章</a>了解过， <code>Uvicron</code>通过一个通用的协定接口与ASGI应用程序交互， 应用程序只要实现如下代码， 即可通过<code>Uvicorn</code>发送和接收信息：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">app</span>(<span class="hljs-params">scope, receive, send</span>):</span><br>    <span class="hljs-comment"># 一个最简单的ASGI应用程序</span><br>    <span class="hljs-keyword">assert</span> scope[<span class="hljs-string">&#x27;type&#x27;</span>] == <span class="hljs-string">&#x27;http&#x27;</span><br>    <span class="hljs-keyword">await</span> send(&#123;<br>        <span class="hljs-string">&#x27;type&#x27;</span>: <span class="hljs-string">&#x27;http.response.start&#x27;</span>,<br>        <span class="hljs-string">&#x27;status&#x27;</span>: <span class="hljs-number">200</span>,<br>        <span class="hljs-string">&#x27;headers&#x27;</span>: [<br>            [<span class="hljs-string">b&#x27;content-type&#x27;</span>, <span class="hljs-string">b&#x27;text/plain&#x27;</span>],<br>        ]<br>    &#125;)<br>    <span class="hljs-keyword">await</span> send(&#123;<br>        <span class="hljs-string">&#x27;type&#x27;</span>: <span class="hljs-string">&#x27;http.response.body&#x27;</span>,<br>        <span class="hljs-string">&#x27;body&#x27;</span>: <span class="hljs-string">b&#x27;Hello, world!&#x27;</span>,<br>    &#125;)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    <span class="hljs-comment"># uvicorn服务</span><br>    <span class="hljs-keyword">import</span> uvicorn<br>    uvicorn.run(app, host=<span class="hljs-string">&quot;127.0.0.1&quot;</span>, port=<span class="hljs-number">5000</span>, log_level=<span class="hljs-string">&quot;info&quot;</span>)<br></code></pre></td></tr></table></figure>
<p>而使用<code>uvicorn</code>启动<code>starlette</code>的方式是：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">from</span> starlette.applications <span class="hljs-keyword">import</span> Starlette<br><span class="hljs-keyword">from</span> starlette.middleware.gzip <span class="hljs-keyword">import</span> GZipMiddleware<br><br><br>app: Starlette = Starlette()<br><br><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&quot;/&quot;</span></span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">demo_route</span>() -&gt; <span class="hljs-keyword">None</span>:</span> <span class="hljs-keyword">pass</span><br><br><br><span class="hljs-meta">@app.websocket_route(<span class="hljs-params"><span class="hljs-string">&quot;/&quot;</span></span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">demo_websocket_route</span>() -&gt; <span class="hljs-keyword">None</span>:</span> <span class="hljs-keyword">pass</span><br><br><br><span class="hljs-meta">@app.add_exception_handlers(<span class="hljs-params"><span class="hljs-number">404</span></span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">not_found_route</span>() -&gt; <span class="hljs-keyword">None</span>:</span> <span class="hljs-keyword">pass</span><br><br><br><span class="hljs-meta">@app.on_event(<span class="hljs-params"><span class="hljs-string">&quot;startup&quot;</span></span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">startup_event_demo</span>() -&gt; <span class="hljs-keyword">None</span>:</span> <span class="hljs-keyword">pass</span><br><br><br><span class="hljs-meta">@app.on_event(<span class="hljs-params"><span class="hljs-string">&quot;shutdown&quot;</span></span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">shutdown_event_demo</span>() -&gt; <span class="hljs-keyword">None</span>:</span> <span class="hljs-keyword">pass</span><br><br><br>app.add_middleware(GZipMiddleware)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    <span class="hljs-keyword">import</span> uvicorn<br>    uvicorn.run(app, host=<span class="hljs-string">&quot;127.0.0.1&quot;</span>, port=<span class="hljs-number">5000</span>)<br><br></code></pre></td></tr></table></figure>
<p>这段代码<code>Starlette</code>先执行了初始化, 然后注册路由，异常处理， 事件，中间件到自身， 然后传给<code>uvicorn.run</code>, <code>uvicorn.run</code>通过调用<code>starlette</code>的<code>__call__</code>的方法传递请求数据。</p>
<p>简单的了解完启动后， 先从<code>starlette</code>初始化看是分析：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Starlette</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">        self,</span></span><br><span class="hljs-function"><span class="hljs-params">        debug: <span class="hljs-built_in">bool</span> = <span class="hljs-literal">False</span>,</span></span><br><span class="hljs-function"><span class="hljs-params">        routes: typing.Sequence[BaseRoute] = <span class="hljs-literal">None</span>,</span></span><br><span class="hljs-function"><span class="hljs-params">        middleware: typing.Sequence[Middleware] = <span class="hljs-literal">None</span>,</span></span><br><span class="hljs-function"><span class="hljs-params">        exception_handlers: typing.Dict[</span></span><br><span class="hljs-function"><span class="hljs-params">            typing.Union[<span class="hljs-built_in">int</span>, typing.Type[Exception]], typing.Callable</span></span><br><span class="hljs-function"><span class="hljs-params">        ] = <span class="hljs-literal">None</span>,</span></span><br><span class="hljs-function"><span class="hljs-params">        on_startup: typing.Sequence[typing.Callable] = <span class="hljs-literal">None</span>,</span></span><br><span class="hljs-function"><span class="hljs-params">        on_shutdown: typing.Sequence[typing.Callable] = <span class="hljs-literal">None</span>,</span></span><br><span class="hljs-function"><span class="hljs-params">        lifespan: typing.Callable[[<span class="hljs-string">&quot;Starlette&quot;</span>], typing.AsyncGenerator] = <span class="hljs-literal">None</span>,</span></span><br><span class="hljs-function"><span class="hljs-params">    </span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :param debug: 决定是否启用debug功能</span><br><span class="hljs-string">        :param route: 一个路由列表, 提供HTTP和WebSocket服务.</span><br><span class="hljs-string">        :param middleware: 中间件列表， 应用于每个请求</span><br><span class="hljs-string">        :param exception_handler: 存放异常回调的字典， 键为HTTP状态码， 值为回调函数</span><br><span class="hljs-string">        :on_startup: 启动时调用的回调函数</span><br><span class="hljs-string">        :on_shutdown: 关闭时的回调函数</span><br><span class="hljs-string">        :lifespan: ASGI中的lifespan功能</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br><br>        <span class="hljs-comment"># 这里表示如果有传入lifespan， 则不可传入on_startup以及on_shutdown</span><br>        <span class="hljs-comment"># 因为本质上starlette的通过把on_start_up和on_shutdown转为一个lifespan来接收uvicorn调用的</span><br>        <span class="hljs-keyword">assert</span> lifespan <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">or</span> (<br>            on_startup <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> on_shutdown <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span><br>        ), <span class="hljs-string">&quot;Use either &#x27;lifespan&#x27; or &#x27;on_startup&#x27;/&#x27;on_shutdown&#x27;, not both.&quot;</span><br><br>        <span class="hljs-comment"># 初始化变量</span><br>        self._debug = debug<br>        self.state = State()<br>        self.router = Router(<br>            routes, on_startup=on_startup, on_shutdown=on_shutdown, lifespan=lifespan<br>        )<br>        self.exception_handlers = (<br>            &#123;&#125; <span class="hljs-keyword">if</span> exception_handlers <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">else</span> <span class="hljs-built_in">dict</span>(exception_handlers)<br>        )<br>        self.user_middleware = [] <span class="hljs-keyword">if</span> middleware <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">else</span> <span class="hljs-built_in">list</span>(middleware)<br>        <span class="hljs-comment"># 构建中间件</span><br>        self.middleware_stack = self.build_middleware_stack()<br></code></pre></td></tr></table></figure>
<p>通过代码可以看到初始化这里已经满足了大多数功能了, 不过还有一个构建中间件的函数, 需要进一步分析:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Starlette</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">build_middleware_stack</span>(<span class="hljs-params">self</span>) -&gt; ASGIApp:</span><br>        debug = self.debug<br>        error_handler = <span class="hljs-literal">None</span><br>        exception_handlers = &#123;&#125;<br><br>        <span class="hljs-comment"># 解析异常处理的回调， 分别存放在error_handler和exception_handlers</span><br>        <span class="hljs-comment"># 只有HTTP状态码为500的才会存入到error_handler</span><br>        <span class="hljs-keyword">for</span> key, value <span class="hljs-keyword">in</span> self.exception_handlers.items():<br>            <span class="hljs-keyword">if</span> key <span class="hljs-keyword">in</span> (<span class="hljs-number">500</span>, Exception):<br>                error_handler = value<br>            <span class="hljs-keyword">else</span>:<br>                exception_handlers[key] = value<br><br>        <span class="hljs-comment"># 为不同种类的中间件排好顺序</span><br>        <span class="hljs-comment"># 第一层为ServerErrorMiddleware, 它能在发现异常的时候打印错误堆栈， 或者在debug模式的时候展示错误页面， 方便调试</span><br>        <span class="hljs-comment"># 第二层是用户中间件层， 用户自己注册的所有中间件都会存放在这里</span><br>        <span class="hljs-comment"># 第三层是ExceptionMiddleware, 它是异常处理层, 它会处理路由执行时抛出的所有异常</span><br>        middleware = (<br>            [Middleware(ServerErrorMiddleware, handler=error_handler, debug=debug)]<br>            + self.user_middleware<br>            + [<br>                Middleware(<br>                    ExceptionMiddleware, handlers=exception_handlers, debug=debug<br>                )<br>            ]<br>        )<br><br>        <span class="hljs-comment"># 最后把中间件装填到app中</span><br>        app = self.router<br>        <span class="hljs-keyword">for</span> cls, options <span class="hljs-keyword">in</span> <span class="hljs-built_in">reversed</span>(middleware):<br>            <span class="hljs-comment"># cls是中间件类本身， options也就是我们传的参数</span><br>            <span class="hljs-comment"># 可以看出中间件本身也是一个ASGIAPP， 装填中间件就是一个ASGI APP套上另外一个ASGI APP， 一直套娃。</span><br>            app = cls(app=app, **options)<br>        <br>        <span class="hljs-comment"># 由于中间件的装填方式是不断的套娃， 而调用是不断的通过`call_next`调用装填它的上级ASGI APP， 所以要采用逆序的方法</span><br>        <span class="hljs-keyword">return</span> app<br></code></pre></td></tr></table></figure>
<p>构建完中间件后， 初始化就算完成了， 接着就会通过<code>uvicorn.run</code>方法从而调用到<code>__call__</code>方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Starlette</span>:</span><br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__call__</span>(<span class="hljs-params">self, scope: Scope, receive: Receive, send: Send</span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        scope[<span class="hljs-string">&quot;app&quot;</span>] = self<br>        <span class="hljs-keyword">await</span> self.middleware_stack(scope, receive, send)<br></code></pre></td></tr></table></figure>
<p>这个方法很简单， 就是通过scope， 把app设置到请求流程中， 方便后续调用， 然后通过调用<code>middleware_stack</code>开始请求的处理。 通过这个方法和中间件的初始化可以看出， <code>starlette</code>中的中间件本身也是一个ASGI APP（也可以看出route是一个ASGI APP， 处于调用栈的最后一层）， 同时<code>starlette</code>也把异常的处理也交给了中间件处理， 这在其他的Web应用框架很少见到， 可以看出<code>starlette</code>的设计是每个组件都尽量是ASGI APP。</p>
<blockquote>
<p>虽然<code>starlette</code>中间件的设计是非常不错的， 但是它的这种初始化方式我不太喜欢， 因为在编写的时候IDE无法帮你传入的参数做校验， 比如上面示例的<code>GZip</code>中间件, 你知道需要传<code>minimum_size</code>参数， 但是你有可能打错， 只是没到运行时的时候， 压根不知道它是否有异常:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Python">app.add_middleware(GZipMiddleware, minimum_size = <span class="hljs-number">500</span>)<br></code></pre></td></tr></table></figure>
<p>我在设计我的rpc框架<a target="_blank" rel="noopener" href="https://github.com/so1n/rap">rap</a>时也参考了<code>startlette</code>的中间件设计， 但是在这一块进行了优化， 不过与本篇文章关系不大， 有兴趣可以参考:<a target="_blank" rel="noopener" href="https://github.com/so1n/rap/blob/master/rap/server/plugin/middleware/base.py">https://github.com/so1n/rap/blob/master/rap/server/plugin/middleware/base.py</a></p>
</blockquote>
<h2 id="2-中间件"><a href="#2-中间件" class="headerlink" title="2.中间件"></a>2.中间件</h2><p>上面说到， 在<code>startlette</code>中， 中间件是一个ASGI APP， 所以在<code>startlette</code>的所有中间件都必定是一个满足如下形式的类：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseMiddleware</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, app: ASGIApp</span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        <span class="hljs-keyword">pass</span><br><br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__call__</span>(<span class="hljs-params">self, scope: Scope, receive: Receive, send: Send</span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure>
<p>在<code>starlette.middleware</code>中， 有很多的中间件实现， 他们都满足这一点， 不过本章节不会讲所有的中间件， 只会挑选几个有代表性的中间件从最靠近<code>Route</code>到远进行分析。</p>
<h3 id="2-1-异常处理中间件-ExceptionMiddleware"><a href="#2-1-异常处理中间件-ExceptionMiddleware" class="headerlink" title="2.1.异常处理中间件-ExceptionMiddleware"></a>2.1.异常处理中间件-ExceptionMiddleware</h3><p>第一个就是ExceptionMiddleware中间件, 这个中间件用户是不会直接接触到的(所以没有放在<code>starlette.middleware</code>里面)， 而是通过下面的这个方法间接的接触到:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-meta">@app.app_exception_handlers(<span class="hljs-params"><span class="hljs-number">404</span></span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">not_found_route</span>() -&gt; <span class="hljs-keyword">None</span>:</span> <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure>
<p>当用户使用这个方法时， <code>startlette</code>会把回调函数挂在对应的字典里面， 这个字典以HTTP状态码为key, 回调函数为value。<br>当ExceptionMiddleware发现<code>Route</code>请求处理异常时， 可以通过异常的响应HTTP状态码找到对应的回调函数， 并把请求和异常传给用户挂载的对应的回调函数, 最后把用户的回调函数结果抛回上一个ASGI APP。<br>此外ExceptionMiddleware还支持异常注册， 当<code>Route</code>抛出的异常与注册的异常匹配时， 调用该异常注册的对应的回调函数。<br>该类的源码和注释如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExceptionMiddleware</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">        self, app: ASGIApp, handlers: <span class="hljs-built_in">dict</span> = <span class="hljs-literal">None</span>, debug: <span class="hljs-built_in">bool</span> = <span class="hljs-literal">False</span></span></span><br><span class="hljs-function"><span class="hljs-params">    </span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        self.app = app<br>        self.debug = debug  <span class="hljs-comment"># <span class="hljs-doctag">TODO:</span> We ought to handle 404 cases if debug is set.</span><br>        <span class="hljs-comment"># startletter是支持HTTP状态码和Exception两种类型</span><br>        self._status_handlers = &#123;&#125;  <span class="hljs-comment"># type: typing.Dict[int, typing.Callable]</span><br>        self._exception_handlers = &#123;<br>            HTTPException: self.http_exception<br>        &#125;  <span class="hljs-comment"># type: typing.Dict[typing.Type[Exception], typing.Callable]</span><br>        <span class="hljs-keyword">if</span> handlers <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">for</span> key, value <span class="hljs-keyword">in</span> handlers.items():<br>                self.add_exception_handler(key, value)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add_exception_handler</span>(<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">        self,</span></span><br><span class="hljs-function"><span class="hljs-params">        exc_class_or_status_code: typing.Union[<span class="hljs-built_in">int</span>, typing.Type[Exception]],</span></span><br><span class="hljs-function"><span class="hljs-params">        handler: typing.Callable,</span></span><br><span class="hljs-function"><span class="hljs-params">    </span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        <span class="hljs-comment"># 用户通过调用startlette app的方法挂载的异常回调最后都是通过该方法挂载到类里面的_status_handlers或者是_exception_handler里面</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(exc_class_or_status_code, <span class="hljs-built_in">int</span>):<br>            self._status_handlers[exc_class_or_status_code] = handler<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">assert</span> <span class="hljs-built_in">issubclass</span>(exc_class_or_status_code, Exception)<br>            self._exception_handlers[exc_class_or_status_code] = handler<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_lookup_exception_handler</span>(<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">        self, exc: Exception</span></span><br><span class="hljs-function"><span class="hljs-params">    </span>) -&gt; typing.Optional[typing.Callable]:</span><br>        <span class="hljs-comment"># 查找注册异常相关的回调函数, 通过mro发现异常的对应回调函数</span><br>        <span class="hljs-comment"># </span><br>        <span class="hljs-comment"># 用户挂载的可能是一个基类， 后续在遇到挂载异常的子类时， 也会调用基类注册的回调</span><br>        <span class="hljs-comment"># 比如用户注册了一个基类， 然后会有用户异常和系统异常两个异常都继承于这个基类</span><br>        <span class="hljs-comment"># 后续函数抛出用户异常或系统异常时， 都会执行到基类注册的对应回调</span><br>        <span class="hljs-keyword">for</span> cls <span class="hljs-keyword">in</span> <span class="hljs-built_in">type</span>(exc).__mro__:<br>            <span class="hljs-keyword">if</span> cls <span class="hljs-keyword">in</span> self._exception_handlers:<br>                <span class="hljs-keyword">return</span> self._exception_handlers[cls]<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br><br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__call__</span>(<span class="hljs-params">self, scope: Scope, receive: Receive, send: Send</span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        <span class="hljs-comment"># 熟悉的ASGI 调用方法</span><br>        <span class="hljs-keyword">if</span> scope[<span class="hljs-string">&quot;type&quot;</span>] != <span class="hljs-string">&quot;http&quot;</span>:<br>            <span class="hljs-comment"># 不支持websocket请求</span><br>            <span class="hljs-keyword">await</span> self.app(scope, receive, send)<br>            <span class="hljs-keyword">return</span><br><br>        <span class="hljs-comment"># 防止同一个响应产生多个异常</span><br>        response_started = <span class="hljs-literal">False</span><br><br>        <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sender</span>(<span class="hljs-params">message: Message</span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>            <span class="hljs-keyword">nonlocal</span> response_started<br><br>            <span class="hljs-keyword">if</span> message[<span class="hljs-string">&quot;type&quot;</span>] == <span class="hljs-string">&quot;http.response.start&quot;</span>:<br>                response_started = <span class="hljs-literal">True</span><br>            <span class="hljs-keyword">await</span> send(message)<br><br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-comment"># 调用下一个ASGI APP</span><br>            <span class="hljs-keyword">await</span> self.app(scope, receive, sender)<br>        <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> exc:<br>            handler = <span class="hljs-literal">None</span><br><br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(exc, HTTPException):<br>                <span class="hljs-comment"># 如果是HTTPException异常， 则从注册HTTP回调字典中寻找</span><br>                handler = self._status_handlers.get(exc.status_code)<br><br>            <span class="hljs-keyword">if</span> handler <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>                <span class="hljs-comment"># 如果是普通的异常， 则从异常回调字典去寻找</span><br>                handler = self._lookup_exception_handler(exc)<br><br>            <span class="hljs-keyword">if</span> handler <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>                <span class="hljs-comment"># 找不到对应的异常， 则往上面抛</span><br>                <span class="hljs-keyword">raise</span> exc <span class="hljs-keyword">from</span> <span class="hljs-literal">None</span><br><br>            <span class="hljs-comment"># 一个响应只接收一次异常处理</span><br>            <span class="hljs-keyword">if</span> response_started:<br>                msg = <span class="hljs-string">&quot;Caught handled exception, but response already started.&quot;</span><br>                <span class="hljs-keyword">raise</span> RuntimeError(msg) <span class="hljs-keyword">from</span> exc<br><br>            request = Request(scope, receive=receive)<br>            <span class="hljs-keyword">if</span> asyncio.iscoroutinefunction(handler):<br>                response = <span class="hljs-keyword">await</span> handler(request, exc)<br>            <span class="hljs-keyword">else</span>:<br>                response = <span class="hljs-keyword">await</span> run_in_threadpool(handler, request, exc)<br>            <span class="hljs-comment"># 通过回调函数生成的response处理请求</span><br>            <span class="hljs-keyword">await</span> response(scope, receive, sender)<br></code></pre></td></tr></table></figure>
<h3 id="2-2-用户中间件"><a href="#2-2-用户中间件" class="headerlink" title="2.2.用户中间件"></a>2.2.用户中间件</h3><p>接着就是用户中间件了， 这个也是我们接触最多的中间件， 在使用<code>starlette.middleware</code>时， 我们都会继承于一个叫<code>BaseHTTPMiddleware</code>的中间件， 然后基于如下代码进行拓展：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DemoMiddleware</span>(<span class="hljs-params">BaseHTTPMiddleware</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">        self,</span></span><br><span class="hljs-function"><span class="hljs-params">        app: ASGIApp,</span></span><br><span class="hljs-function"><span class="hljs-params">    </span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        <span class="hljs-built_in">super</span>(DemoMiddleware, self).__init__(app)<br><br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dispatch</span>(<span class="hljs-params">self, request: Request, call_next: RequestResponseEndpoint</span>) -&gt; Response:</span><br>        <span class="hljs-comment"># before</span><br>        response: Response = <span class="hljs-keyword">await</span> call_next(request)<br>        <span class="hljs-comment"># after</span><br>        <span class="hljs-keyword">return</span> response<br></code></pre></td></tr></table></figure>
<p>如果在请求之前进行预处理， 就在before块编写相关代码，如果要在请求之后进行处理的， 就在after块编写代码， 使用非常简单， 而且他们是处于同一个作用域的， 这就意味着该方法里面的变量不用通过上下文或者动态变量来传播（如果你接触了Django或者Flask的类中间件实现， 也就懂得了starlette这种实现的优雅）。</p>
<p>接下来就来看看它是怎么实现的， 代码非常简单， 大概60行左右, 不过我注释写了很多:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseHTTPMiddleware</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, app: ASGIApp, dispatch: DispatchFunction = <span class="hljs-literal">None</span></span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        <span class="hljs-comment"># 赋值下一级的ASGI app</span><br>        self.app = app<br>        <span class="hljs-comment"># 如果用户有传dispatch， 就使用用户传的函数， 否则使用自身的dispatch</span><br>        <span class="hljs-comment"># 一般用户都是继承于BaseHTTPMiddleware, 然后复写dispatch方法</span><br>        self.dispatch_func = self.dispatch <span class="hljs-keyword">if</span> dispatch <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">else</span> dispatch<br><br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__call__</span>(<span class="hljs-params">self, scope: Scope, receive: Receive, send: Send</span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        ASGI 标准的函数签名函数， 代表着ASGI的请求会从这里进来</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> scope[<span class="hljs-string">&quot;type&quot;</span>] != <span class="hljs-string">&quot;http&quot;</span>:<br>            <span class="hljs-comment"># 如果类型不是http的， 则不会走中间件(也就是websocket的不支持)</span><br>            <span class="hljs-comment"># 要支持websocket的话， 中间件就很难这样实现了， 我在实现rap框架时， 为了支持类websocket的流量中间件处理， 牺牲了一些功能才可以实现</span><br>            <span class="hljs-keyword">await</span> self.app(scope, receive, send)<br>            <span class="hljs-keyword">return</span><br><br>        <span class="hljs-comment"># 通过scope生成request对象</span><br>        request = Request(scope, receive=receive)<br>        <span class="hljs-comment"># 进入dispatch逻辑， 也就是用户的处理逻辑</span><br>        <span class="hljs-comment"># 这个逻辑得到的respone实际上是call_next函数生成的， dispatch函数只做了传递的作用</span><br>        response = <span class="hljs-keyword">await</span> self.dispatch_func(request, self.call_next)<br>        <span class="hljs-comment"># 根据生成的response, 返回数据到上一层</span><br>        <span class="hljs-keyword">await</span> response(scope, receive, send)<br><br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">call_next</span>(<span class="hljs-params">self, request: Request</span>) -&gt; Response:</span><br>        loop = asyncio.get_event_loop()<br>        <span class="hljs-comment"># 通过queue生产消费模式来获取下一级的消息</span><br>        queue: <span class="hljs-string">&quot;asyncio.Queue[typing.Optional[Message]]&quot;</span> = asyncio.Queue()<br><br>        scope = request.scope<br>        <span class="hljs-comment"># 通过request.receive对象把uvicorn的receive对象传过来</span><br>        <span class="hljs-comment"># 这里用到的receive对象还是uvicorn初始化时的receive对象</span><br>        receive = request.receive<br>        send = queue.put<br><br>        <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">coro</span>() -&gt; <span class="hljs-keyword">None</span>:</span><br>            <span class="hljs-keyword">try</span>:<br>                <span class="hljs-keyword">await</span> self.app(scope, receive, send)<br>            <span class="hljs-keyword">finally</span>:<br>                <span class="hljs-comment"># 这个put操作能确保get那边不会被卡死</span><br>                <span class="hljs-keyword">await</span> queue.put(<span class="hljs-literal">None</span>)<br><br>        <span class="hljs-comment"># 通过loop.create_task， 在另一个协程跑下一个ASGI APP</span><br>        task = loop.create_task(coro())<br>        <span class="hljs-comment"># 等待下一个ASGI APP的返回</span><br>        message = <span class="hljs-keyword">await</span> queue.get()<br>        <span class="hljs-keyword">if</span> message <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-comment"># 如果拿到是空的， 则代表下一个ASGI APP没有返回响应， 这时可能出错， </span><br>            <span class="hljs-comment"># 通过调用task.result()， 如果该协程出现异常, 则会把该协程的错误抛出来</span><br>            task.result()<br>            <span class="hljs-comment"># 如果没有异常抛出来， 就可能是用户写错等原因， 返回了一个空响应, </span><br>            <span class="hljs-comment"># 这时候是没办法返回响应给客户端的， 需要自己制造一个异常， 方便后续生成一个500的响应</span><br>            <span class="hljs-keyword">raise</span> RuntimeError(<span class="hljs-string">&quot;No response returned.&quot;</span>)<br>        <br>        <span class="hljs-comment"># ASGI处理响应的时候会分多步走， 正常情况下， 上面的queue.get， 是获取响应的第一步</span><br>        <span class="hljs-keyword">assert</span> message[<span class="hljs-string">&quot;type&quot;</span>] == <span class="hljs-string">&quot;http.response.start&quot;</span><br><br>        <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">body_stream</span>() -&gt; typing.AsyncGenerator[bytes, <span class="hljs-keyword">None</span>]:</span><br>            <span class="hljs-comment"># 其他的处理会交给body_stream函数处理</span><br>            <span class="hljs-comment"># 这个方法所做的就是一直返回数据流</span><br>            <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>                message = <span class="hljs-keyword">await</span> queue.get()<br>                <span class="hljs-keyword">if</span> message <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>                    <span class="hljs-keyword">break</span><br>                <span class="hljs-keyword">assert</span> message[<span class="hljs-string">&quot;type&quot;</span>] == <span class="hljs-string">&quot;http.response.body&quot;</span><br>                <span class="hljs-keyword">yield</span> message.get(<span class="hljs-string">&quot;body&quot;</span>, <span class="hljs-string">b&quot;&quot;</span>)<br>            task.result()<br><br>        <span class="hljs-comment"># 将body_stream函数放到Response方法中</span><br>        <span class="hljs-comment"># response本身也是一个类ASGI APP的类， 用户根据教程， 在dispatch方法中通过call_next获得response对象， </span><br>        <span class="hljs-comment"># 并在最后返回， 所以这个reponse对象将会交给__call__方法中进行处理。</span><br>        response = StreamingResponse(<br>            status_code=message[<span class="hljs-string">&quot;status&quot;</span>], content=body_stream()<br>        )<br>        response.raw_headers = message[<span class="hljs-string">&quot;headers&quot;</span>]<br>        <span class="hljs-keyword">return</span> response<br><br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dispatch</span>(<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">        self, request: Request, call_next: RequestResponseEndpoint</span></span><br><span class="hljs-function"><span class="hljs-params">    </span>) -&gt; Response:</span><br>        <span class="hljs-keyword">raise</span> NotImplementedError()  <span class="hljs-comment"># pragma: no cover</span><br></code></pre></td></tr></table></figure>
<h3 id="2-3-ServerErrorMiddleware"><a href="#2-3-ServerErrorMiddleware" class="headerlink" title="2.3.ServerErrorMiddleware"></a>2.3.ServerErrorMiddleware</h3><p>ServerErrorMiddleware跟ExceptionMiddleware很像(所以这一part也不做更多的说明), 整个逻辑基本上都是一致的， 不过ExceptionMiddleware负责的是把用户的路由异常进行捕获处理， ServerErrorMiddleware主要负责是做兜底， 确保返回的一定是合法的HTTP响应。</p>
<p>ServerErrorMiddleware的间接调用函数也跟ExceptionMiddleware一样, 不过只有注册的HTTP状态码为500时， 才会把回调注册到ServerErrorMiddleware中：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-meta">@app.exception_handlers(<span class="hljs-params"><span class="hljs-number">500</span></span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">not_found_route</span>() -&gt; <span class="hljs-keyword">None</span>:</span> <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure>
<p>ServerErrorMiddleware是处于ASGI APP中的最顶级， 它负责异常兜底的工作， 它要做的事情很简单， 如果下一级ASGI APP处理发生异常， 就进入兜底逻辑：</p>
<ul>
<li>1.如果启用debug, 则返回debug页面</li>
<li>2.如果有注册回调， 则执行注册回调</li>
<li>3.如果都没则返回500响应</li>
</ul>
<h2 id="3-Route"><a href="#3-Route" class="headerlink" title="3.Route"></a>3.Route</h2><p>在<code>starlette</code>中， <code>Route</code>分为两部分， 一部分我把它称为<code>Real App</code>的<code>Router</code>， 它处于中间件的下一层级， 但它负责的是<code>Starlette</code>除中间件外的所有事情， 主要包括路由查找匹配， APP启动关闭处理等， 另外一部分则是注册到<code>Router</code>的路由。</p>
<h3 id="3-1-Router"><a href="#3-1-Router" class="headerlink" title="3.1.Router"></a>3.1.Router</h3><p><code>Router</code>很简单， 他的主要责任就是装载路由和匹配路由， 以下是除装载路由外的源码和注释：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Router</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">        self,</span></span><br><span class="hljs-function"><span class="hljs-params">        routes: typing.Sequence[BaseRoute] = <span class="hljs-literal">None</span>,</span></span><br><span class="hljs-function"><span class="hljs-params">        redirect_slashes: <span class="hljs-built_in">bool</span> = <span class="hljs-literal">True</span>,</span></span><br><span class="hljs-function"><span class="hljs-params">        default: ASGIApp = <span class="hljs-literal">None</span>,</span></span><br><span class="hljs-function"><span class="hljs-params">        on_startup: typing.Sequence[typing.Callable] = <span class="hljs-literal">None</span>,</span></span><br><span class="hljs-function"><span class="hljs-params">        on_shutdown: typing.Sequence[typing.Callable] = <span class="hljs-literal">None</span>,</span></span><br><span class="hljs-function"><span class="hljs-params">        lifespan: typing.Callable[[typing.Any], typing.AsyncGenerator] = <span class="hljs-literal">None</span>,</span></span><br><span class="hljs-function"><span class="hljs-params">    </span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        <span class="hljs-comment"># 装填starlette初始化时的信息</span><br>        self.routes = [] <span class="hljs-keyword">if</span> routes <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">else</span> <span class="hljs-built_in">list</span>(routes)<br>        self.redirect_slashes = redirect_slashes<br>        self.default = self.not_found <span class="hljs-keyword">if</span> default <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">else</span> default<br>        self.on_startup = [] <span class="hljs-keyword">if</span> on_startup <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">else</span> <span class="hljs-built_in">list</span>(on_startup)<br>        self.on_shutdown = [] <span class="hljs-keyword">if</span> on_shutdown <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">else</span> <span class="hljs-built_in">list</span>(on_shutdown)<br><br>        <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">default_lifespan</span>(<span class="hljs-params">app: typing.Any</span>) -&gt; typing.AsyncGenerator:</span><br>            <span class="hljs-keyword">await</span> self.startup()<br>            <span class="hljs-keyword">yield</span><br>            <span class="hljs-keyword">await</span> self.shutdown()<br><br>        <span class="hljs-comment"># 如果初始化lifespan为空， 则把on_startup和on_shuatdown转化为lifespan</span><br>        self.lifespan_context = default_lifespan <span class="hljs-keyword">if</span> lifespan <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">else</span> lifespan<br><br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">not_found</span>(<span class="hljs-params">self, scope: Scope, receive: Receive, send: Send</span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        <span class="hljs-string">&quot;&quot;&quot;匹配不到路由执行的逻辑&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> scope[<span class="hljs-string">&quot;type&quot;</span>] == <span class="hljs-string">&quot;websocket&quot;</span>:<br>            <span class="hljs-comment"># websocket匹配失败</span><br>            websocket_close = WebSocketClose()<br>            <span class="hljs-keyword">await</span> websocket_close(scope, receive, send)<br>            <span class="hljs-keyword">return</span><br><br>        <span class="hljs-comment"># If we&#x27;re running inside a starlette application then raise an</span><br>        <span class="hljs-comment"># exception, so that the configurable exception handler can deal with</span><br>        <span class="hljs-comment"># returning the response. For plain ASGI apps, just return the response.</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;app&quot;</span> <span class="hljs-keyword">in</span> scope:<br>            <span class="hljs-comment"># 在starlette.applications的__call__方法可以看到starlette把自身存入scope中</span><br>            <span class="hljs-comment"># 这里抛出异常后， 可以被ServerErrorMiddleware捕获</span><br>            <span class="hljs-keyword">raise</span> HTTPException(status_code=<span class="hljs-number">404</span>)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-comment"># 对于不是starlette调用的， 直接返回错误</span><br>            response = PlainTextResponse(<span class="hljs-string">&quot;Not Found&quot;</span>, status_code=<span class="hljs-number">404</span>)<br>        <span class="hljs-keyword">await</span> response(scope, receive, send)<br><br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">lifespan</span>(<span class="hljs-params">self, scope: Scope, receive: Receive, send: Send</span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        Handle ASGI lifespan messages, which allows us to manage application</span><br><span class="hljs-string">        startup and shutdown events.</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-comment"># lifespan执行的逻辑， 在执行的时候starlette会与ASGI服务器进行通信， 但目前这样的代码估计还有一些待开发的功能</span><br>        first = <span class="hljs-literal">True</span><br>        app = scope.get(<span class="hljs-string">&quot;app&quot;</span>)<br>        <span class="hljs-keyword">await</span> receive()<br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-keyword">if</span> inspect.isasyncgenfunction(self.lifespan_context):<br>                <span class="hljs-keyword">async</span> <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> self.lifespan_context(app):<br>                    <span class="hljs-keyword">assert</span> first, <span class="hljs-string">&quot;Lifespan context yielded multiple times.&quot;</span><br>                    first = <span class="hljs-literal">False</span><br>                    <span class="hljs-keyword">await</span> send(&#123;<span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;lifespan.startup.complete&quot;</span>&#125;)<br>                    <span class="hljs-keyword">await</span> receive()<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> self.lifespan_context(app):  <span class="hljs-comment"># type: ignore</span><br>                    <span class="hljs-keyword">assert</span> first, <span class="hljs-string">&quot;Lifespan context yielded multiple times.&quot;</span><br>                    first = <span class="hljs-literal">False</span><br>                    <span class="hljs-keyword">await</span> send(&#123;<span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;lifespan.startup.complete&quot;</span>&#125;)<br>                    <span class="hljs-keyword">await</span> receive()<br>        <span class="hljs-keyword">except</span> BaseException:<br>            <span class="hljs-keyword">if</span> first:<br>                exc_text = traceback.format_exc()<br>                <span class="hljs-keyword">await</span> send(&#123;<span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;lifespan.startup.failed&quot;</span>, <span class="hljs-string">&quot;message&quot;</span>: exc_text&#125;)<br>            <span class="hljs-keyword">raise</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">await</span> send(&#123;<span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;lifespan.shutdown.complete&quot;</span>&#125;)<br><br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__call__</span>(<span class="hljs-params">self, scope: Scope, receive: Receive, send: Send</span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        The main entry point to the Router class.</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-comment"># 匹配以及执行路由的主要函数</span><br>        <span class="hljs-comment"># 目前只支持http, websocket, lifespan三种类型</span><br>        <span class="hljs-keyword">assert</span> scope[<span class="hljs-string">&quot;type&quot;</span>] <span class="hljs-keyword">in</span> (<span class="hljs-string">&quot;http&quot;</span>, <span class="hljs-string">&quot;websocket&quot;</span>, <span class="hljs-string">&quot;lifespan&quot;</span>)<br><br>        <span class="hljs-comment"># 初始化router到scope中</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;router&quot;</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> scope:<br>            scope[<span class="hljs-string">&quot;router&quot;</span>] = self<br><br>        <span class="hljs-keyword">if</span> scope[<span class="hljs-string">&quot;type&quot;</span>] == <span class="hljs-string">&quot;lifespan&quot;</span>:<br>            <span class="hljs-comment"># 执行lifespan逻辑</span><br>            <span class="hljs-keyword">await</span> self.lifespan(scope, receive, send)<br>            <span class="hljs-keyword">return</span><br><br>        partial = <span class="hljs-literal">None</span><br><br>        <span class="hljs-comment"># 进行路由匹配</span><br>        <span class="hljs-keyword">for</span> route <span class="hljs-keyword">in</span> self.routes:<br>            match, child_scope = route.matches(scope)<br>            <span class="hljs-keyword">if</span> match == Match.FULL:<br>                <span class="hljs-comment"># 如果是完整匹配（url匹配， method匹配）</span><br>                <span class="hljs-comment"># 则进行路由正常处理</span><br>                scope.update(child_scope)<br>                <span class="hljs-keyword">await</span> route.handle(scope, receive, send)<br>                <span class="hljs-keyword">return</span><br>            <span class="hljs-keyword">elif</span> match == Match.PARTIAL <span class="hljs-keyword">and</span> partial <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>                <span class="hljs-comment"># 如果是不完整匹配（url匹配， method不匹配）</span><br>                <span class="hljs-comment"># 则保留值， 继续匹配</span><br>                partial = route<br>                partial_scope = child_scope<br><br>        <span class="hljs-keyword">if</span> partial <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-comment"># 如果存在不完整匹配的路由, 也继续执行， 但这时路由会响应HTTP 方法不对的错误</span><br>            scope.update(partial_scope)<br>            <span class="hljs-keyword">await</span> partial.handle(scope, receive, send)<br>            <span class="hljs-keyword">return</span><br><br>        <span class="hljs-keyword">if</span> scope[<span class="hljs-string">&quot;type&quot;</span>] == <span class="hljs-string">&quot;http&quot;</span> <span class="hljs-keyword">and</span> self.redirect_slashes <span class="hljs-keyword">and</span> scope[<span class="hljs-string">&quot;path&quot;</span>] != <span class="hljs-string">&quot;/&quot;</span>:<br>            <span class="hljs-comment"># 未匹配的情况, 判断重定向</span><br>            redirect_scope = <span class="hljs-built_in">dict</span>(scope)<br>            <span class="hljs-keyword">if</span> scope[<span class="hljs-string">&quot;path&quot;</span>].endswith(<span class="hljs-string">&quot;/&quot;</span>):<br>                redirect_scope[<span class="hljs-string">&quot;path&quot;</span>] = redirect_scope[<span class="hljs-string">&quot;path&quot;</span>].rstrip(<span class="hljs-string">&quot;/&quot;</span>)<br>            <span class="hljs-keyword">else</span>:<br>                redirect_scope[<span class="hljs-string">&quot;path&quot;</span>] = redirect_scope[<span class="hljs-string">&quot;path&quot;</span>] + <span class="hljs-string">&quot;/&quot;</span><br><br>            <span class="hljs-keyword">for</span> route <span class="hljs-keyword">in</span> self.routes:<br>                match, child_scope = route.matches(redirect_scope)<br>                <span class="hljs-keyword">if</span> match != Match.NONE:<br>                    <span class="hljs-comment"># 再次进行匹配, 如果结果不为空, 则发送重定向response</span><br>                    redirect_url = URL(scope=redirect_scope)<br>                    response = RedirectResponse(url=<span class="hljs-built_in">str</span>(redirect_url))<br>                    <span class="hljs-keyword">await</span> response(scope, receive, send)<br>                    <span class="hljs-keyword">return</span><br><br>        <span class="hljs-comment"># 上面流程都没命中时， 则代表没有找到任务路由， 这时候会执行默认路由， 默认的默认路由是404 not found</span><br>        <span class="hljs-keyword">await</span> self.default(scope, receive, send)<br></code></pre></td></tr></table></figure>
<p>可以看出<code>Router</code>的代码非常的简单， 主要的代码都集中在<code>__call__</code>中， 但是在这里出现了多次遍历查询路由且每个路由都是执行一遍正则表达式来判断是否匹配。可能会有人觉得这样的执行速度会很慢,<br>我曾经也觉得这样的路由查找很慢， 然后就实现了一个路由树来代替它详见<a target="_blank" rel="noopener" href="https://github.com/so1n/fast-tools/blob/master/fast_tools/base/route_trie.py">route_trie.py</a>, 然而在我实现后做了一次性能测试， 发现在路由没超过50个的情况下， 循环匹配性能是优于路由树的， 在没超过100条的情况下， 两者是相当的， 而在正常情况下， 我们指定的路由都不会超过100个， 所以不用去担心这部分路由的匹配性能， 如果还是很担心， 那么可以使用<code>Mount</code>来对路由进行分组， 使匹配的次数减少。</p>
<h3 id="3-2-其他Route"><a href="#3-2-其他Route" class="headerlink" title="3.2.其他Route"></a>3.2.其他Route</h3><p><code>Moute</code>是继承于<code>BaseRoute</code>, 其它的<code>Route</code>, <code>HostRoute</code>, <code>WebsocketRoute</code>也是一样继承于<code>BaseRoute</code>, 它们提供的方法都差不多， 只是具体实现略有差别而已(主要是初始化，路由匹配和反向查找略有区别)， 我们先来看看<code>BaseRoute</code>:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseRoute</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">matches</span>(<span class="hljs-params">self, scope: Scope</span>) -&gt; typing.Tuple[Match, Scope]:</span><br>        <span class="hljs-comment"># 一个标准的匹配函数签名， 每个Route都要返回一个(Match, Scope)的元祖</span><br>        <span class="hljs-comment"># Match有3种， 分别是</span><br>        <span class="hljs-comment">#   NONE： 没有匹配到</span><br>        <span class="hljs-comment">#   PARTIAL： 部分匹配（url匹配了， method匹配失败）</span><br>        <span class="hljs-comment">#   FULL： 完全匹配（url和method都匹配成功）</span><br>        <span class="hljs-comment"># Scope基本上都会返回如下格式, 不过Mount返回的内容更多：</span><br>        <span class="hljs-comment">#   &#123;&quot;endpoint&quot;: self.endpoint, &quot;path_params&quot;: path_params&#125;</span><br>        <span class="hljs-keyword">raise</span> NotImplementedError()  <span class="hljs-comment"># pragma: no cover</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">url_path_for</span>(<span class="hljs-params">self, name: <span class="hljs-built_in">str</span>, **path_params: <span class="hljs-built_in">str</span></span>) -&gt; URLPath:</span><br>        <span class="hljs-comment"># 根据名字生成反向查找</span><br>        <span class="hljs-keyword">raise</span> NotImplementedError()  <span class="hljs-comment"># pragma: no cover</span><br><br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">handle</span>(<span class="hljs-params">self, scope: Scope, receive: Receive, send: Send</span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        <span class="hljs-comment"># 被Router匹配后可以调用的函数</span><br>        <span class="hljs-keyword">raise</span> NotImplementedError()  <span class="hljs-comment"># pragma: no cover</span><br><br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__call__</span>(<span class="hljs-params">self, scope: Scope, receive: Receive, send: Send</span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        A route may be used in isolation as a stand-alone ASGI app.</span><br><span class="hljs-string">        This is a somewhat contrived case, as they&#x27;ll almost always be used</span><br><span class="hljs-string">        within a Router, but could be useful for some tooling and minimal apps.</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-comment"># 如果该路由被当做ASGI APP单独调用， 则自己进行匹配并响应结果</span><br>        match, child_scope = self.matches(scope)<br>        <span class="hljs-keyword">if</span> match == Match.NONE:<br>            <span class="hljs-keyword">if</span> scope[<span class="hljs-string">&quot;type&quot;</span>] == <span class="hljs-string">&quot;http&quot;</span>:<br>                response = PlainTextResponse(<span class="hljs-string">&quot;Not Found&quot;</span>, status_code=<span class="hljs-number">404</span>)<br>                <span class="hljs-keyword">await</span> response(scope, receive, send)<br>            <span class="hljs-keyword">elif</span> scope[<span class="hljs-string">&quot;type&quot;</span>] == <span class="hljs-string">&quot;websocket&quot;</span>:<br>                websocket_close = WebSocketClose()<br>                <span class="hljs-keyword">await</span> websocket_close(scope, receive, send)<br>            <span class="hljs-keyword">return</span><br><br>        scope.update(child_scope)<br>        <span class="hljs-keyword">await</span> self.handle(scope, receive, send)<br></code></pre></td></tr></table></figure>
<p>可以看到<code>BaseRoute</code>提供的功能不多， 其他的路由则是基于<code>BaseRoute</code>进行拓展：</p>
<ul>
<li>Route: 标准的HTTP路由， 负责通过HTTP URL和HTTP Method进行路由匹配， 然后提供调用HTTP路由的方法</li>
<li>WebSocketRoute: 标准的WebSocketRoute， 根据HTTP URL进行路由匹配, 然后通过<code>starlette.websocket</code>的WebSocket生成session再传入对应的函数</li>
<li>Mount: 一个路由的套娃封装， 他的匹配方法是URL的前缀匹配, 把请求转发给符合规则的下一级ASGI  APP， 当他的下一级ASGI APP是<code>Router</code>时, 他的调用链可能会像这样<code>Router-&gt;Mount-&gt;Router-&gt;Mount-&gt;Router-&gt;Route</code>， 通过使用Mount可以对路由进行分组， 同时也能加快匹配速度， 推荐使用。 不过， 它还支持把请求分发给其他ASGI APP， 也可以做到如<code>Starlette-&gt;ASGI Middleware-&gt;Mount-&gt;Other Starlette-&gt;...</code></li>
<li>Host: 它会根据用户请求的Host分发到对应的ASGI APP， 可以选择<code>Route</code>, <code>Mount</code>， 中间件等等ASGI APP</li>
</ul>
<h2 id="4-其它组件"><a href="#4-其它组件" class="headerlink" title="4.其它组件"></a>4.其它组件</h2><p>从上面可以看到， <code>starlette</code>中的组件基本上都设计成ASGI APP， 可以任意的兼容， 这种设计是非常棒的， 虽然会牺牲一点点性能， 但是它的兼容性非常的强, 而其他的组件也都或多或少的设计得像ASGI APP一样， 在介绍其他组件之前， 先看看整个<code>starlette</code>的整个项目结构:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs Python">├── middleware                       <span class="hljs-comment"># 中间件</span><br>├── applications.py                  <span class="hljs-comment"># 启动的应用程序</span><br>├── authentication.py                <span class="hljs-comment"># 验证相关</span><br>├── background.py                    <span class="hljs-comment"># 封装后台任务， 会在返回响应后执行</span><br>├── concurrency.py                   <span class="hljs-comment"># 一些小的asyncio相关的封装， 在新版本中， 直接使用了anyio库来代替</span><br>├── config.py                        <span class="hljs-comment"># 配置</span><br>├── convertors.py                    <span class="hljs-comment"># 一些类型的转换方法</span><br>├── datastructures.py                <span class="hljs-comment"># 一些数据结构， 比如Url, Header, Form, QueryParam, State等等</span><br>├── endpoints.py                     <span class="hljs-comment"># 支持cbv的路由以及一个稍微高级点的Websocket封装</span><br>├── exceptions.py                    <span class="hljs-comment"># 异常处理</span><br>├── formparsers.py                   <span class="hljs-comment"># Form，File之类的解析</span><br>├── graphql.py                       <span class="hljs-comment"># 负责处理graphql相关的</span><br>├── __init__.py<br>├── py.typed                         <span class="hljs-comment"># starlette需要用到的TypeHints</span><br>├── requests.py                      <span class="hljs-comment"># 请求, 供用户获取数据</span><br>├── responses.py                     <span class="hljs-comment"># 响应, 负责初始化Header和Cookies， 同时根据不同的Respnose类生成响应数据， 然后有个类ASGI调用接口， 该接口会发送ASGI协议到uvicorn服务， 发送完后如果有backgroud task, 则执行backgroud task， 直到执行完成， 该响应流程才结束。</span><br>├── routing.py                       <span class="hljs-comment"># 路由</span><br>├── schemas.py                       <span class="hljs-comment"># OpenApi相关的Schemas</span><br>├── staticfiles.py                   <span class="hljs-comment"># 静态文件</span><br>├── status.py                        <span class="hljs-comment"># HTTP状态码</span><br>├── templating.py                    <span class="hljs-comment"># 基于jinja的模板响应</span><br>├── testclient.py                    <span class="hljs-comment"># 测试客户端</span><br>├── types.py                         <span class="hljs-comment"># 类型</span><br>└── websockets.py                    <span class="hljs-comment"># websocket</span><br></code></pre></td></tr></table></figure>
<p>上面的文件有很多， 有些比较简单就直接略过。</p>
<h3 id="4-1-Request"><a href="#4-1-Request" class="headerlink" title="4.1.Request"></a>4.1.Request</h3><p><code>Request</code>非常的简单， 它继承于<code>HttpConnection</code>, 这个类主要是通过ASGI协议传过来的Scope进行解析， 提取如url, method等信息， 而<code>Request</code>增加了读取请求数据和返回数据(HTTP1.1支持服务端push数据给客户端)的功能， 其中， 读取数据都依赖于一个核心函数–<code>stram</code>，它的源码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">stream</span>(<span class="hljs-params">self</span>) -&gt; typing.AsyncGenerator[bytes, <span class="hljs-keyword">None</span>]:</span><br>    <span class="hljs-comment"># 如果已经读取过的， 则从缓存中获取数据</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">hasattr</span>(self, <span class="hljs-string">&quot;_body&quot;</span>):<br>        <span class="hljs-keyword">yield</span> self._body<br>        <span class="hljs-keyword">yield</span> <span class="hljs-string">b&quot;&quot;</span><br>        <span class="hljs-keyword">return</span><br><br>    <span class="hljs-keyword">if</span> self._stream_consumed:<br>        <span class="hljs-keyword">raise</span> RuntimeError(<span class="hljs-string">&quot;Stream consumed&quot;</span>)<br><br>    self._stream_consumed = <span class="hljs-literal">True</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        <span class="hljs-comment"># 从ASGI容器的receive循环获取数据</span><br>        message = <span class="hljs-keyword">await</span> self._receive()<br>        <span class="hljs-keyword">if</span> message[<span class="hljs-string">&quot;type&quot;</span>] == <span class="hljs-string">&quot;http.request&quot;</span>:<br>            body = message.get(<span class="hljs-string">&quot;body&quot;</span>, <span class="hljs-string">b&quot;&quot;</span>)<br>            <span class="hljs-keyword">if</span> body:<br>                <span class="hljs-comment"># 获取的数据不为空就返回数据</span><br>                <span class="hljs-keyword">yield</span> body<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> message.get(<span class="hljs-string">&quot;more_body&quot;</span>, <span class="hljs-literal">False</span>):<br>                <span class="hljs-comment"># 代表body数据已经被获取完</span><br>                <span class="hljs-keyword">break</span><br>        <span class="hljs-keyword">elif</span> message[<span class="hljs-string">&quot;type&quot;</span>] == <span class="hljs-string">&quot;http.disconnect&quot;</span>:<br>            <span class="hljs-comment"># 代表与客户端的连接已经关闭了</span><br>            self._is_disconnected = <span class="hljs-literal">True</span><br>            <span class="hljs-comment"># 抛出异常， 用户调用await request.body()   await request.json()之类的会抛出异常</span><br>            <span class="hljs-keyword">raise</span> ClientDisconnect()<br>    <span class="hljs-comment"># 返回空字节，标记结束</span><br>    <span class="hljs-keyword">yield</span> <span class="hljs-string">b&quot;&quot;</span><br></code></pre></td></tr></table></figure>
<p>这个实现非常简单， 但是却有一个小bug, 如果有了解<code>Nginx</code>或者其他Web服务的都会知道， 一般的中间服务器是不会处理body数据的, 只做传递。ASGI也是如此, <code>uvicorn</code>在处理完url和header后就开始调用ASGI APP， 并把<code>send</code>和<code>receive</code>对象传递下去, 这两个对象会在经过多个ASGI APP后，抵达路由这个ASGI APP， 并在函数里供用户使用，， 所以Request接收的<code>receive</code>对象是<code>uvicorn</code>生成的。 而<code>receive</code>的数据源是源自于是一个<code>asyncio.Queue</code>队列， 从中间件的分析可以知道， 每个ASGI APP都依据<code>scope</code>, <code>receive</code>来生成一个<code>Request</code>对象, 意味着每层ASGI APP的<code>Request</code>对象是不一致的, 如果在中间件调用<code>Request</code>对象读取Body的话， 就会提前消费通过<code>receive</code>消费了队列的数据， 导致后续的ASGI APP无法通过<code>Request</code>对象读取Body数据， 该问题示例代码如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> asyncio<br><span class="hljs-keyword">from</span> starlette.applications <span class="hljs-keyword">import</span> Starlette<br><span class="hljs-keyword">from</span> starlette.middleware.base <span class="hljs-keyword">import</span> BaseHTTPMiddleware, RequestResponseEndpoint<br><span class="hljs-keyword">from</span> starlette.requests <span class="hljs-keyword">import</span> Request<br><span class="hljs-keyword">from</span> starlette.responses <span class="hljs-keyword">import</span> JSONResponse, Response<br><br>app: Starlette = Starlette()<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DemoMiddleware</span>(<span class="hljs-params">BaseHTTPMiddleware</span>):</span><br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dispatch</span>(<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">        self, request: Request, call_next: RequestResponseEndpoint</span></span><br><span class="hljs-function"><span class="hljs-params">    </span>) -&gt; Response:</span><br>        print(request, <span class="hljs-keyword">await</span> request.body())<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> call_next(request)<br><br><br>app.add_middleware(DemoMiddleware)<br><br><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&quot;/&quot;</span></span>)</span><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">demo</span>(<span class="hljs-params">request: Request</span>) -&gt; JSONResponse:</span><br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-keyword">await</span> asyncio.wait_for(request.body(), <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> JSONResponse(&#123;<span class="hljs-string">&quot;result&quot;</span>: <span class="hljs-literal">True</span>&#125;)<br>    <span class="hljs-keyword">except</span> asyncio.TimeoutError:<br>        <span class="hljs-keyword">return</span> JSONResponse(&#123;<span class="hljs-string">&quot;result&quot;</span>: <span class="hljs-literal">False</span>&#125;)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    <span class="hljs-keyword">import</span> uvicorn  <span class="hljs-comment"># type: ignore</span><br><br>    uvicorn.run(app)<br></code></pre></td></tr></table></figure>
<p>运行后执行请求查看结果:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Bash">-&gt; curl http://127.0.0.1:8000<br>&#123;<span class="hljs-string">&quot;result&quot;</span>:<span class="hljs-literal">false</span>&#125; <br></code></pre></td></tr></table></figure>
<p>可以看到执行的结果是<code>false</code>, 意味着执行<code>request.body</code>超时了， 因为此时<code>receive</code>队列已经空了， 是拿不到数据的， 如果不加超时的话这个请求就会一直卡主。<br>那么要怎么去解决问题呢， 先看看<code>Request</code>获取是如何获取body的， 因为用户可以同时获取多次body, 但一直都是相同的数据， 它的实现思路是获取数据后， 把数据缓存到一个变量里面， 我们也可以采取这个思路, 由于数据都是通过<code>receive</code>获取的， 那么可以在在读取数据后， 构造一个<code>receive</code>函数， 该函数返回类似于ASGI的通信协议的数据， 并且有完整的body数据(满足Request.stream获取body的构造)， 代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">proxy_get_body</span>(<span class="hljs-params">request: Request</span>) -&gt; bytes:</span><br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">receive</span>() -&gt; Message:</span><br>        <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;http.request&quot;</span>, <span class="hljs-string">&quot;body&quot;</span>: body&#125;<br><br>    body = <span class="hljs-keyword">await</span> request.body()<br>    request._receive = receive<br>    <span class="hljs-keyword">return</span> body<br></code></pre></td></tr></table></figure>
<p>之后任意层级的ASGI APP如果需要获取Body数据的话， 就可以调用该函数来获取Body数据， 同时又不影响后续的ASGI APP获取Body数据。</p>
<h3 id="4-2-TestClient"><a href="#4-2-TestClient" class="headerlink" title="4.2.TestClient"></a>4.2.TestClient</h3><p>在基于<code>TestCLient</code>的测试用例运行时， 没有流量转发， 而是通过请求调用到路由函数， 并根据返回数据转化为一个响应对象。<br>同时， 它还能会自动运行<code>on_startup</code>和<code>on_shutdown</code>挂载的函数以及挂载的中间件, 我在一开始接触时， 我很好奇它是怎么实现的， 因为大多数的测试用例框架都很难做到直接调用到路由函数， 同时又满足于框架的其他中间件, <code>on_startup</code>和<code>on_shutdown</code>的功能(特别是Python的gRPC自带的测试用例封装…)。</p>
<p>在了解<code>TestClient</code>的运行原理之前， 先看看<code>TestClient</code>的使用用例如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">from</span> starlette.testclient <span class="hljs-keyword">import</span> TestClient<br><span class="hljs-keyword">from</span> requests <span class="hljs-keyword">import</span> Response  <span class="hljs-comment"># type: ignore</span><br><br><br>app: Starlette = Starlette()<br><span class="hljs-keyword">with</span> TestClient(app) <span class="hljs-keyword">as</span> client:<br>    response: Response = client.get(<span class="hljs-string">&quot;/&quot;</span>)<br></code></pre></td></tr></table></figure>
<p>这段代码中， 分为几步走: </p>
<ul>
<li>1:初始化一个app对象</li>
<li>2:把app对象传入<code>TestClient</code>中, 并通过<code>with</code>语法启动一个上下文</li>
<li>3:通过返回的client进行调用， 最后返回一个<code>requests.Response</code>对象。</li>
</ul>
<p>其中第一点非常简单， 我们也分析过了， 对于第二点， 很难明白为什么要<code>with</code>上下文， 在官方文档说明是可以这样直接运行:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Python">response: Response = TestClient(app).get(<span class="hljs-string">&quot;/&quot;</span>)<br></code></pre></td></tr></table></figure>
<p>但是没办法执行<code>on_startup</code>和<code>on_shutdown</code>这两个事件挂载的函数， 所以初步判定<code>with</code>语法与它们有关， 而至于第三步则很难猜透<code>starlette</code>是怎么实现的， 但是返回的是<code>requests.Respnose</code>的对象， 那么一定跟<code>requests</code>这个框架有一些关联， 具体需要分析源码才能知道。</p>
<p>接下来就开始带着问题分析源码, 首先是类和<code>__init__</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestClient</span>(<span class="hljs-params">requests.Session</span>):</span><br>    __test__ = <span class="hljs-literal">False</span>  <span class="hljs-comment"># For pytest to not discover this up.</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">        self,</span></span><br><span class="hljs-function"><span class="hljs-params">        app: typing.Union[ASGI2App, ASGI3App],</span></span><br><span class="hljs-function"><span class="hljs-params">        base_url: <span class="hljs-built_in">str</span> = <span class="hljs-string">&quot;http://testserver&quot;</span>,</span></span><br><span class="hljs-function"><span class="hljs-params">        raise_server_exceptions: <span class="hljs-built_in">bool</span> = <span class="hljs-literal">True</span>,</span></span><br><span class="hljs-function"><span class="hljs-params">        root_path: <span class="hljs-built_in">str</span> = <span class="hljs-string">&quot;&quot;</span>,</span></span><br><span class="hljs-function"><span class="hljs-params">    </span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        <span class="hljs-built_in">super</span>(TestClient, self).__init__()<br>        <span class="hljs-keyword">if</span> _is_asgi3(app):<br>            app = typing.cast(ASGI3App, app)<br>            asgi_app = app<br>        <span class="hljs-keyword">else</span>:<br>            app = typing.cast(ASGI2App, app)<br>            asgi_app = _WrapASGI2(app)  <span class="hljs-comment">#  type: ignore</span><br>        <span class="hljs-comment"># 使用了request的Adapter功能， </span><br>        adapter = _ASGIAdapter(<br>            asgi_app,<br>            raise_server_exceptions=raise_server_exceptions,<br>            root_path=root_path,<br>        )<br>        self.mount(<span class="hljs-string">&quot;http://&quot;</span>, adapter)<br>        self.mount(<span class="hljs-string">&quot;https://&quot;</span>, adapter)<br>        self.mount(<span class="hljs-string">&quot;ws://&quot;</span>, adapter)<br>        self.mount(<span class="hljs-string">&quot;wss://&quot;</span>, adapter)<br>        self.headers.update(&#123;<span class="hljs-string">&quot;user-agent&quot;</span>: <span class="hljs-string">&quot;testclient&quot;</span>&#125;)<br>        self.app = asgi_app<br>        self.base_url = base_url<br></code></pre></td></tr></table></figure>
<p>从这个可以看出， TestClient继承于requests.Session的方法， 证明可以在编写测试用例时， 直接调用到requests.Session的相关的方法。然后在<code>__init__</code>方法中实例化了一个<code>adapter</code>, 这里是使用了<code>requests</code>的adapter机制， 通过adpater机制， 可以拦截请求的数据和响应的数据。<br><code>_ASGIdapter</code>的代码比较多， 但是它的实现逻辑很简单， 它重载了<code>Adapter</code>的<code>send</code>方法， 当执行到<code>send</code>方法时， 它会变成执行<code>app(scope, receive, send)</code>, 其中<code>receive</code>是负责把请求的数据转换为ASGI协议，供下一级ASGI APP调用。而<code>send</code>(位于<code>Adapter.send</code>里面的闭包函数)则获取ASGI APP返回的数据并存放到字典中， 当ASGI APP执行完毕的时候， <code>Adapter</code>的<code>send</code>方法会根据执行是否异常以及存放数据的字典转化为一个<code>request.Response</code>的实例返回给用户。</p>
<p>通过<code>_ASGIdapter</code>了解了<code>starlette</code>是如何解决第三个问题的， 接下来是<code>with</code>语法相关的<code>__enter__</code>, <code>__exit__</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestClient</span>(<span class="hljs-params">requests.Session</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__enter__</span>(<span class="hljs-params">self</span>) -&gt; &quot;TestClient&quot;:</span><br>        loop = asyncio.get_event_loop()<br>        self.send_queue = asyncio.Queue()  <span class="hljs-comment"># type: asyncio.Queue</span><br>        self.receive_queue = asyncio.Queue()  <span class="hljs-comment"># type: asyncio.Queue</span><br>        self.task = loop.create_task(self.lifespan())<br>        loop.run_until_complete(self.wait_startup())<br>        <span class="hljs-keyword">return</span> self<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__exit__</span>(<span class="hljs-params">self, *args: typing.Any</span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        loop = asyncio.get_event_loop()<br>        loop.run_until_complete(self.wait_shutdown())<br></code></pre></td></tr></table></figure>
<p>可以看出， 在使用进入上下文和退出上下文时， 自动调用了<code>lifespan</code>方法， 然后通过<code>lifespan</code>机制来实现<code>on_startup</code>和<code>on_shutdown</code>功能, 具体的源码和注释如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestClient</span>(<span class="hljs-params">requests.Session</span>):</span><br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">lifespan</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        <span class="hljs-comment"># 构造lifespan的scope</span><br>        scope = &#123;<span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;lifespan&quot;</span>&#125;<br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-comment"># 发送到starlette, 然后starlette就会根据receive执行对应的事件</span><br>            <span class="hljs-keyword">await</span> self.app(scope, self.receive_queue.get, self.send_queue.put)<br>        <span class="hljs-keyword">finally</span>:<br>            <span class="hljs-keyword">await</span> self.send_queue.put(<span class="hljs-literal">None</span>)<br><br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">wait_startup</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        <span class="hljs-comment"># 发送lifespan开始信息</span><br>        <span class="hljs-keyword">await</span> self.receive_queue.put(&#123;<span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;lifespan.startup&quot;</span>&#125;)<br>        <span class="hljs-comment"># 监听starlette返回的lifespan信息, 并判断信息是否正确</span><br>        message = <span class="hljs-keyword">await</span> self.send_queue.get()<br>        <span class="hljs-keyword">if</span> message <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            self.task.result()<br>        <span class="hljs-keyword">assert</span> message[<span class="hljs-string">&quot;type&quot;</span>] <span class="hljs-keyword">in</span> (<br>            <span class="hljs-string">&quot;lifespan.startup.complete&quot;</span>,<br>            <span class="hljs-string">&quot;lifespan.startup.failed&quot;</span>,<br>        )<br>        <span class="hljs-comment"># 如果错误， 则消费task.result</span><br>        <span class="hljs-keyword">if</span> message[<span class="hljs-string">&quot;type&quot;</span>] == <span class="hljs-string">&quot;lifespan.startup.failed&quot;</span>:<br>            message = <span class="hljs-keyword">await</span> self.send_queue.get()<br>            <span class="hljs-keyword">if</span> message <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>                self.task.result()<br><br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">wait_shutdown</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        <span class="hljs-comment"># 发送lifespan关闭信息</span><br>        <span class="hljs-keyword">await</span> self.receive_queue.put(&#123;<span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;lifespan.shutdown&quot;</span>&#125;)<br>        message = <span class="hljs-keyword">await</span> self.send_queue.get()<br>        <span class="hljs-keyword">if</span> message <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            self.task.result()<br>        <span class="hljs-keyword">assert</span> message[<span class="hljs-string">&quot;type&quot;</span>] == <span class="hljs-string">&quot;lifespan.shutdown.complete&quot;</span><br>        <span class="hljs-comment"># 等待starlette的lifespan执行结束</span><br>        <span class="hljs-keyword">await</span> self.task<br></code></pre></td></tr></table></figure>
<h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5.总结"></a>5.总结</h2><p>至此， <code>starlette</code>的几个重要的功能代码都分析完了， <code>starlette</code>是一个非常棒的库， 它的设计思路也是非常的棒， 建议大家自己读一遍<code>starlette</code>的源代码， 对以后自己写框架是有帮助的。</p>
      </section>
      <section class="extra">
        
          <ul class="copyright">
  
    <li><strong>本文作者：</strong>So1n</li>
    <li><strong>本文链接：</strong><a href="http://so1n.me/2021/11/15/starlette_source_code_analysis/index.html" title="http:&#x2F;&#x2F;so1n.me&#x2F;2021&#x2F;11&#x2F;15&#x2F;starlette_source_code_analysis&#x2F;index.html">http:&#x2F;&#x2F;so1n.me&#x2F;2021&#x2F;11&#x2F;15&#x2F;starlette_source_code_analysis&#x2F;index.html</a></li>
    <li><strong>版权声明：</strong>本博客所有文章均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" title="BY-NC-SA" target="_blank" rel="noopener">BY-NC-SA</a> 许可协议，转载请注明出处！</li>
  
</ul>
        
        
          <section class="donate">
  <div id="qrcode-donate">
    <img src="https://github.com/so1n/so1n_blog_photo/blob/master/blog_photo/4d2ebf32586d8799ee2e75333d6f5d2.jpg?raw=true">
  </div>
  <div class="icon">
    <a href="javascript:;" id="alipay"><i class="iconfont iconalipay"></i></a>
    <a href="javascript:;" id="wechat"><i class="iconfont iconwechat-fill"></i></a>
  </div>
</section>
        
        
  <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python/" rel="tag">Python</a></li></ul> 

        
  <nav class="nav">
    <a href="/2021/11/15/RPC%E6%A1%86%E6%9E%B6%E7%BC%96%E5%86%99%E5%AE%9E%E8%B7%B5--%E9%99%90%E6%B5%81/"><i class="iconfont iconleft"></i>RPC框架编写实践--简介注册与发现的</a>
    <a href="/2021/11/15/RPC%E6%A1%86%E6%9E%B6%E7%BC%96%E5%86%99%E5%AE%9E%E8%B7%B5--%E5%B8%B8%E8%A7%81%E9%99%90%E6%B5%81%E6%96%B9%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0/">RPC框架编写实践-RPC常见限流方法的实现<i class="iconfont iconright"></i></a>
  </nav>

      </section>
      
        <section class="comments">
  
    <div class="btn" id="comments-btn">查看评论</div>
  
  
<link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<div id="gitalk" class="gitalk"></div>
<script defer src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
<script>
  window.onload = function () {
    var gitalk = new Gitalk({
      clientID: '59f804e526b05c378470',
      clientSecret: '36679ff697cec424936a0f7c4bcd6d2988dac28e',
      id: window.location.pathname,
      repo: 'so1n.github.io',
      owner: 'so1n',
      admin: 'so1n'
    });
    if ( true ) {
      $("#comments-btn").on("click", function () {
        $(this).hide();
        gitalk.render('gitalk');
      });
    } else {
      gitalk.render('gitalk');
    }
  }
</script>

</section>
      
    </section>
  </div>
</article>
</div>
      <div class="col-xl-3">
          
  <aside class="toc-wrap">
    <h3 class="toc-title">文章目录：</h3>
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%AE%B0"><span class="toc-text">前记</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-starlette%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-text">1.starlette的应用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E4%B8%AD%E9%97%B4%E4%BB%B6"><span class="toc-text">2.中间件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E4%B8%AD%E9%97%B4%E4%BB%B6-ExceptionMiddleware"><span class="toc-text">2.1.异常处理中间件-ExceptionMiddleware</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E7%94%A8%E6%88%B7%E4%B8%AD%E9%97%B4%E4%BB%B6"><span class="toc-text">2.2.用户中间件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-ServerErrorMiddleware"><span class="toc-text">2.3.ServerErrorMiddleware</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Route"><span class="toc-text">3.Route</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-Router"><span class="toc-text">3.1.Router</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E5%85%B6%E4%BB%96Route"><span class="toc-text">3.2.其他Route</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%85%B6%E5%AE%83%E7%BB%84%E4%BB%B6"><span class="toc-text">4.其它组件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-Request"><span class="toc-text">4.1.Request</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-TestClient"><span class="toc-text">4.2.TestClient</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E6%80%BB%E7%BB%93"><span class="toc-text">5.总结</span></a></li></ol>
  </aside>

        
          
  <aside class="toc-wrap">
    <h3 class="toc-title">文章目录：</h3>
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%AE%B0"><span class="toc-text">前记</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-starlette%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-text">1.starlette的应用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E4%B8%AD%E9%97%B4%E4%BB%B6"><span class="toc-text">2.中间件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E4%B8%AD%E9%97%B4%E4%BB%B6-ExceptionMiddleware"><span class="toc-text">2.1.异常处理中间件-ExceptionMiddleware</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E7%94%A8%E6%88%B7%E4%B8%AD%E9%97%B4%E4%BB%B6"><span class="toc-text">2.2.用户中间件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-ServerErrorMiddleware"><span class="toc-text">2.3.ServerErrorMiddleware</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Route"><span class="toc-text">3.Route</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-Router"><span class="toc-text">3.1.Router</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E5%85%B6%E4%BB%96Route"><span class="toc-text">3.2.其他Route</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%85%B6%E5%AE%83%E7%BB%84%E4%BB%B6"><span class="toc-text">4.其它组件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-Request"><span class="toc-text">4.1.Request</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-TestClient"><span class="toc-text">4.2.TestClient</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E6%80%BB%E7%BB%93"><span class="toc-text">5.总结</span></a></li></ol>
  </aside>

        
      </div>
    </div>
  </div>
</main>

  <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js">
</script>


<footer class="footer">
  <div class="footer-social"><a 
        href="https://github.com/so1n "
        target="_blank"
        class="footer-social-item"
        onMouseOver="this.style.color= '#9f7be1'" 
        onMouseOut="this.style.color='#33333D'">
          <i class="iconfont  icongithub-fill "></i>
      </a></div>
  
    <div class="footer-copyright"><p>Powered by <a target="_blank" href="https://hexo.io">Hexo</a>  |  Theme - <a target="_blank" href="https://github.com/izhaoo/hexo-theme-zhaoo">zhaoo</a></p></div>
  
  <div class="footer-copyright">
    总访问量<span id="busuanzi_value_site_pv"></span>次
    访客数<span id="busuanzi_value_site_uv"></span>人次
  </div>

</footer>

  
      <div class="fab fab-plus">
    <i class="iconfont iconplus"></i>
  </div>
  
  
  <div class="fab fab-up">
    <i class="iconfont iconcaret-up"></i>
  </div>
  
  
    <div class="scrollbar j-scrollbar">
  <div class="scrollbar-current j-scrollbar-current"></div>
</div>
  
  
    
<script src="/js/color-mode.js"></script>

  
  
    <div class="search">
  <div class="search-container">
    <div class="search-close">
      <i class="iconfont iconbaseline-close-px"></i>
    </div>
    <div class="search-input-wrapper">
      <i class="search-input-icon iconfont iconsearch"></i>
      <input class="search-input" type="search" id="search-input" placeholder="Search..." autofocus autocomplete="off"
        autocorrect="off" autocapitalize="off">
    </div>
    <div class="search-output" id="search-output"></div>
  </div>
</div>
  
</body>

<script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script>



  
<script src="https://cdn.bootcdn.net/ajax/libs/jquery.lazyload/1.9.1/jquery.lazyload.min.js"></script>




  
<script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js"></script>






  
<script src="https://cdn.bootcdn.net/ajax/libs/jquery.qrcode/1.0/jquery.qrcode.min.js"></script>




<script src="/js/utils.js"></script>
<script src="/js/script.js"></script>







  <script>
    (function () {
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
      } else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>













</html>