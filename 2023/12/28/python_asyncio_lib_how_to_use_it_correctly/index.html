

<!DOCTYPE html>
<html lang="zh-Hans" color-mode=light>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Python Asyncio 之常见的三个坑 - So1n blog</title>
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="google" content="notranslate" />
  
  <meta name="description" content="前记Python Asyncio是一个用户态协程的实现...">
  <meta name="author" content="So1n">
  <link rel="icon" href="/images/icons/favicon.ico" type="image/png" sizes="16x16">
  <link rel="icon" href="/images/icons/favicon.ico" type="image/png" sizes="32x32">
  <link rel="apple-touch-icon" href="/images/icons/favicon.ico" sizes="180x180">
  <meta rel="mask-icon" href="/images/icons/stun-logo.svg" color="#333333">
  
    <meta rel="msapplication-TileImage" content="/images/icons/favicon.ico">
    <meta rel="msapplication-TileColor" content="#000000">
  

  
<link rel="stylesheet" href="/css/style.css">


  
    
<link rel="stylesheet" href="//at.alicdn.com/t/font_1445822_s6x2xcokxrl.css">

  

  
    
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css">

  

  
    
      
        
        
<link rel="stylesheet" href="https://cdn.bootcss.com/highlight.js/9.18.1/styles/atom-one-dark-reasonable.min.css" name="highlight-style" mode="light">

      
        
        
<link rel="stylesheet" href="https://cdn.bootcss.com/highlight.js/9.18.1/styles/atom-one-dark-reasonable.min.css" name="highlight-style" mode="dark">

      
  

  <script>
    var CONFIG = window.CONFIG || {};
    var ZHAOO = window.ZHAOO || {};
    CONFIG = {
      isHome: false,
      fancybox: true,
      pjax: false,
      loading: {
        gif: '',
        lottie: ''
      },
      lazyload: {
        enable: true,
        only_post: 'true',
        loading: {
          gif: '',
          lottie: ''
        }
      },
      donate: {
        enable: true,
        alipay: 'https://fastly.jsdelivr.net/gh/so1n/so1n_blog_photo@master/blog_photo/16550449287744d2ebf32586d8799ee2e75333d6f5d2.jpg',
        wechat: ''
      },
      galleries: {
        enable: true
      },
      fab: {
        enable: true,
        always_show: true
      },
      carrier: {
        enable: false
      },
      daovoice: {
        enable: false
      },
      preview: {
        background: {
          default: '',
          api: ''
        },
        motto: {
          default: 'I`m   So1n',
          typing: true,
          api: '',
          data_contents: '["data","content"]'
        },
      },
      qrcode: {
        enable: true,
        type: 'url',
        image: 'https://pic.izhaoo.com/weapp-code.jpg',
      },
      toc: {
        enable: true
      },
      scrollbar: {
        type: 'simple'
      },
      notification: {
        enable: false,
        delay: 4500,
        list: '',
        page_white_list: '',
        page_black_list: ''
      },
      search: {
        enable: true,
        path: 'search.xml'
      }
    }
  </script>

  

  

<meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="So1n blog" type="application/atom+xml">
</head>

<body class="lock-screen">
  <div class="loading" id="loading"></div>
  
    


  <nav class="navbar">
    <div class="left">
      
        <i class="iconfont iconhome j-navbar-back-home"></i>
      
      
        <i class="iconfont iconqrcode j-navbar-qrcode"></i>
      
      
        <i class="iconfont iconmoono" id="color-toggle" color-toggle="light"></i>
      
      
        <i class="iconfont iconsearch j-navbar-search"></i>
      
    </div>
    <div class="center">Python Asyncio 之常见的三个坑</div>
    <div class="right">
      <i class="iconfont iconmenu j-navbar-menu"></i>
    </div>
    
      <div id="qrcode-navbar"></div>
    
  </nav>


  
  

<nav class="menu">
  <div class="menu-container">
    <div class="menu-close">
      <i class="iconfont iconbaseline-close-px"></i>
    </div>
    <ul class="menu-content"><li class="menu-item">
        <a href="/ " class="underline "> 首页</a>
      </li><li class="menu-item">
        <a href="/archives/ " class="underline "> 归档</a>
      </li><li class="menu-item">
        <a href="/tags/ " class="underline "> 标签</a>
      </li><li class="menu-item">
        <a href="/categories/ " class="underline "> 分类</a>
      </li><li class="menu-item">
        <a href="/project/ " class="underline "> 项目</a>
      </li><li class="menu-item">
        <a href="/about/ " class="underline "> 关于</a>
      </li></ul>
    
      <div class="menu-copyright"><p>Powered by <a target="_blank" href="https://hexo.io">Hexo</a>  |  Theme - <a target="_blank" href="https://github.com/izhaoo/hexo-theme-zhaoo">zhaoo</a>| <a target="_blank" href="/atom.xml">RSS</a> </p></div>
    
  </div>
</nav>
  <main id="main">
  <div class="article-wrap">
    <div class="row container">
      <div class="col-xl-3"></div>
      <div class="col-xl-6"><article class="article">
  <div class="wrap">
    <section class="head">
  <img src="https://fastly.jsdelivr.net/gh/so1n/so1n_blog_photo@master/blog_photo/16550442517731649661119526images.png" draggable="false">
  <div class="head-mask">
    <h1 class="head-title">Python Asyncio 之常见的三个坑</h1>
    <div class="head-info">
      <span class="post-info-item"><i class="iconfont iconcalendar"></i>December 28, 2023</span>
      
      本文总阅读量<span id="busuanzi_value_page_pv"></span>次
      <span class="post-info-item"><i class="iconfont iconfont-size"></i>9917</span>
    </div>
  </div>
</section>

    <section class="main">
      <section class="content">
        <!-- 展示文章摘录 -->
        
          <p><h2 id="前记"><a href="#前记" class="headerlink" title="前记"></a>前记</h2><p><code>Python Asyncio</code>是一个用户态协程的实现，没有任何系统级的调度干扰，这意味着它能更快的被调度，但是由于<code>Asyncio</code>是后面才被加入到<code>Python</code>中，所以带来一些不方便的使用和容易踩坑的用法。</p></p>
        
        <h2 id="1-不同事件循环问题"><a href="#1-不同事件循环问题" class="headerlink" title="1.不同事件循环问题"></a>1.不同事件循环问题</h2><p>在<code>asyncio</code>诞生初期，<code>loop.get_event_loop</code>的设计不是很友好，需要多次调用才能知道当前的事件循环已经在运行以及获取到对应的事件循环，如下代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> asyncio<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_event_loop</span>() -&gt; asyncio.AbstractEventLoop:</span><br>    <span class="hljs-string">&quot;&quot;&quot;get event loop in runtime&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">if</span> sys.version_info &gt;= (<span class="hljs-number">3</span>, <span class="hljs-number">7</span>):<br>        <span class="hljs-keyword">return</span> asyncio.get_running_loop()<br><br>    loop: asyncio.AbstractEventLoop = asyncio.get_event_loop()<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> loop.is_running():<br>        <span class="hljs-keyword">raise</span> RuntimeError(<span class="hljs-string">&quot;no running event loop&quot;</span>)<br>    <span class="hljs-keyword">return</span> loop<br><br></code></pre></td></tr></table></figure>
<p>通过代码可以看到，在<code>Python3.7</code>之后只需要调用<code>asyncio.get_running_loop</code>方法则可以判断当前是否有事件循环运行，也可以获取到事件循环。而在<code>Python3.6</code>之前需要分多步走，于是很多<code>asyncio</code>相关的库都会采用如下用法获取正在运行的事件循环对象:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> asyncio<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, loop=<span class="hljs-literal">None</span></span>):</span><br>        <span class="hljs-keyword">if</span> loop <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            loop = asyncio.get_event_loop()<br>        <span class="hljs-keyword">else</span>:<br>            loop = loop<br></code></pre></td></tr></table></figure>
<p>但是这样很容易引发不同事件循环的问题，如下例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> asyncio<br><span class="hljs-keyword">import</span> uvicorn<br><span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> FastAPI<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BadClient</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        self._loop = asyncio.get_event_loop()<br><br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fake_request</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        <span class="hljs-keyword">await</span> self._loop.create_task(asyncio.sleep(<span class="hljs-number">1</span>))<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br><br><br>app = FastAPI()<br>client = BadClient()<br><br><br><span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&quot;/&quot;</span></span>)</span><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">demo</span>() -&gt; str:</span><br>    <span class="hljs-keyword">await</span> client.fake_request()<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello World!&quot;</span><br><br><br>uvicorn.run(app)<br></code></pre></td></tr></table></figure>
<p>在这个例子中会虚构了一个不可用的客户端–<code>BadClient</code>，它在初始化时会获取或者创建当前的事件循环，并在<code>fake_request</code>这个模拟请求的方法中使用，但是在通过<code>uvicorn</code>运行<code>app</code>并访问路由后可以发现程序会抛出如下异常信息:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">attached to a different loop<br></code></pre></td></tr></table></figure>
<p>该信息告知当前程序被连接了两个事件循环，这是一个非常严重的错误。造成这个错误的原因是<code>BadClient</code>在初始化的时候会自动的选择一个事件循环，但是<code>uvicorn</code>在运行的时候会重新为当前程序设置一个新的事件循环，这就导致后续运行路由的事件循环与<code>BadClient</code>并不是同一个事件循环。</p>
<p>这是一个<code>asyncio</code>设计导致的历史遗留问题，好在现在很多库在抛弃<code>Python3.6</code>的支持后就不在<code>__init__</code>方法中进行事件循环的初始化，而是哪里用到了就在哪里获取，保证使用时用到的事件循环会与当前程序的事件循环一致，所以大部分问题都可以通过升级对应的依赖库来解决。<br>此外，也可以通过延迟加载的方式，使<code>client</code>在<code>uvicorn</code>启动之后再初始化，并绑定到<code>app</code>实例中，如下代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">省略一些代码...</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br>app = FastAPI()<br><br><span class="hljs-meta">@app.on_event(<span class="hljs-params"><span class="hljs-string">&quot;startup&quot;</span></span>)</span><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">startup</span>() -&gt; <span class="hljs-keyword">None</span>:</span><br>    app.client = BadClient()<br><br><br><span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&quot;/&quot;</span></span>)</span><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">demo</span>(<span class="hljs-params">request: Request</span>) -&gt; str:</span><br>    <span class="hljs-keyword">await</span> request.app.client.fake_request()<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello World!&quot;</span><br><br><br>uvicorn.run(app)<br></code></pre></td></tr></table></figure>

<p>这样既能解决正常运行时的不同事件循环问题，也能解决测试用例中不同事件循环的问题。</p>
<h2 id="2-阻塞代码问题"><a href="#2-阻塞代码问题" class="headerlink" title="2.阻塞代码问题"></a>2.阻塞代码问题</h2><p><code>Python Asyncio</code>有许多优势，在正确的使用下可以让程序发挥出极高的性能，特别是在使用<code>uvloop</code>后，程序的性能甚至能够媲美<code>node</code>和<code>go</code>的性能。但是由于<code>Python Asyncio</code>的<code>async</code>传染性原因以及<code>Asyncio</code>是后面才加入到<code>Python</code>生态中，导致<code>asyncio</code>有一套与<code>sync</code>相独立的生态。</p>
<p>所以<code>Python</code>虽然有着跟<code>js</code>，<code>dart</code>相似的<code>async</code>，<code>await</code>语法使开发者能更简单方便的进行异步编程，但是仍有一些网络库没有适配<code>asyncio</code>生态而使用者却不知情从而导致代码阻塞的情况。</p>
<p>举个例子，很多新接触的开发者因为<code>FastAPI</code>的便利性选择了<code>FastAPI</code>进行<code>Web</code>开发，大部分路由也会选择用<code>async</code>函数，如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> uvicorn<br><span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> FastAPI<br><br>app = FastAPI()<br><br><br><span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&quot;/&quot;</span></span>)</span><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">demo</span>() -&gt; str:</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello World!&quot;</span><br><br><br>uvicorn.run(app)<br></code></pre></td></tr></table></figure>
<p>然而在涉及到外部请求时，很多开发者会选择用<code>requests</code>库，因为它在<code>Python</code>生态中实在是太出名了，于是编写出来的代码可能是这样的:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">import</span> uvicorn<br><span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> FastAPI<br><br>app = FastAPI()<br><br><br><span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&quot;/&quot;</span></span>)</span><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">demo</span>() -&gt; str:</span><br>    status_code: <span class="hljs-built_in">int</span> = requests.get(<span class="hljs-string">&quot;https://baidu.com&quot;</span>).status_code<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">f&quot;Hello World!, status code:<span class="hljs-subst">&#123;status_code&#125;</span>&quot;</span><br><br><br>uvicorn.run(app)<br></code></pre></td></tr></table></figure>
<p>此时的任何库的使用方法都是正确的，使用用浏览器进行请求也可以得出数据，但是通过ab压测出来的数据却是出奇的差，如下是我使用<code>ab</code>进行50个请求，10并发的压测(省略不重要的数据):</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">ab -n 50 -c 10 http://127.0.0.1:8000/<br><br>Concurrency Level:      10<br>Time taken <span class="hljs-keyword">for</span> tests:   12.946 seconds<br>Complete requests:      50<br>Failed requests:        0<br>Requests per second:    3.86 [<span class="hljs-comment">#/sec] (mean)</span><br>Time per request:       2589.251 [ms] (mean)<br>Time per request:       258.925 [ms] (mean, across all concurrent requests)<br>Transfer rate:          0.66 [Kbytes/sec] received<br></code></pre></td></tr></table></figure>
<p>通过结果可以发现用了12秒才能处理完50个请求，换算出来的QPS只有4左右，这个性能是非常的拉跨的，而造成这个问题的原因是在<code>async</code>路由中用到了阻塞代码导致的。当堵塞代码运行时，整个事件循环都没有机会运行，所以整个程序只能串行的处理所有请求。</p>
<p>在这个示例代码是错误的用到了<code>requests</code>这个库，大部分开发者都知道它不与<code>asyncio</code>兼容，所以可以很快速的定位出来，但是有些库并没有明显的说明，得如何去定位呢？有两种办法，一种是通过使用经验去排查，另一种是通过<code>asyncio</code>的<code>Debug</code>模式。</p>
<h3 id="2-1-使用经验法排查"><a href="#2-1-使用经验法排查" class="headerlink" title="2.1.使用经验法排查"></a>2.1.使用经验法排查</h3><p>所谓经验法排查，就是只看代码就知道哪些代码会阻塞<code>Asyncio</code>的运行，而这需要开发者知道<code>Asyncio</code>能调度的对象是什么，因为只有<code>Asyncio</code>能调度的对象才不会阻塞<code>Asyncio</code>的运行。</p>
<p>在<a href="https://so1n.me/2022/06/08/python_asyncio_schedule/#1-%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D">Python Asyncio调度原理</a>中介绍过，<code>Asyncio</code>就是一个简单的循环程序，每一次循环执行一件事。当它发现有<code>Handle</code>和<code>TimerHandle</code>两个调度对象中的一个可以运行时，就会把执行权交给调度对象，直到调度对象让步时<code>Asyncio</code>的循环程序才会继续执行，所以当调度对象执行的代码消耗的时间比较久时会阻塞到整个<code>Asyncio</code>的运行进而影响程序的执行性能。但是如果把这些阻塞代码交给非CPU执行，并通过<code>Handle</code>和<code>TimeHandle</code>来告知<code>Asyncio</code>的循环程序自己什么时候可以继续执行什么时候可以让出，那么CPU就能一直执行<code>Asyncio</code>的调度工作，<code>Asyncio</code>就能发挥极其强大的调度性能了，程序也就能够跑的更快。</p>
<p>比如<code>asyncio</code>中的时间处理，它会把时间何时到期的逻辑封装到<code>TimerHandle</code>中，再扔进事件循环中的数据结构–堆，事件循环每次循环时都会获取堆中时间最近的<code>TimerHandle</code>，如果发现确实到期了就马上执行，否则就继续循环，直到到期的<code>TimerHandle</code>可以被执行。<code>asyncio.sleep</code>就是采用这种处理方式，这种方式相比于<code>time.sleep</code>虽然会多费一点CPU，但是在空闲的时候并不会完全占用当前线程的执行，所以<code>Asyncio</code>的事件循环能一直运行着。</p>
<p>而<code>Handle</code>对象也是类似的，只不过它承载的是<code>Task</code>，<code>Future</code>，<code>sock&amp;epoll</code>等事件的处理，不过它们之间的关系比较复杂，如果想具体了解的可以看我之前写的关于<code>Asyncio</code>的文章，它们的简要关系如下图：<br><img  src="https://fastly.jsdelivr.net/gh/so1n/so1n_blog_photo@master/blog_photo/1703087980156%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E7%9A%84%E4%BD%BF%E7%94%A8asyncio-%E5%8F%AF%E8%B0%83%E5%BA%A6%E7%9A%84%E5%88%86%E7%B1%BB.png"  ><span class="image-caption">如何正确的使用asyncio-可调度的分类.png</span></p>
<p>通过图可以发现在使用<code>asyncio</code>提供的方法后大部分的时间，交互，网络IO都不会阻塞到事件循环的运行。<br>不过网络IO中有一个例外的就是DNS查询，因为DNS查询的方法–<code>socket.getaddrinfo</code>与其他<code>sock</code>的方法是有区别，其它的<code>sock</code>方法都可以异步执行，而它是阻塞执行。这也就意味着在一个线程中，如果执行了<code>socket.getaddrinfo</code>方法就会把整个<code>asyncio</code>的事件循环阻塞住。为此<code>asyncio</code>通过<code>run_in_executor</code>方法来解决这个问题，具体源码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-comment"># 位于:Lib/asyncio/base_events.py</span><br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getaddrinfo</span>(<span class="hljs-params">self, host, port, *, family=<span class="hljs-number">0</span>, <span class="hljs-built_in">type</span>=<span class="hljs-number">0</span>, proto=<span class="hljs-number">0</span>, flags=<span class="hljs-number">0</span></span>):</span><br>        <span class="hljs-keyword">if</span> self._debug:<br>            getaddr_func = self._getaddrinfo_debug<br>        <span class="hljs-keyword">else</span>:<br>            getaddr_func = socket.getaddrinfo<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> self.run_in_executor(<br>            <span class="hljs-literal">None</span>, getaddr_func, host, port, family, <span class="hljs-built_in">type</span>, proto, flags)<br></code></pre></td></tr></table></figure>
<p>通过源码可以看出，在使用<code>asyncio.getaddrinfo</code>进行DNS查询时是会把这个任务委托给给线程池处理，这样DNS查询就不会影响事件循环的运行。不过默认的线程数量是有限的，如果需要更多的线程帮忙工作则可以通过如下方法把<code>Asyncio</code>事件循环的默认线程池调大一些：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> asyncio<br><span class="hljs-keyword">from</span> concurrent.futures <span class="hljs-keyword">import</span> ThreadPoolExecutor<br><br>loop = asyncio.get_event_loop()<br>loop.set_default_executor(ThreadPoolExecutor(<span class="hljs-number">10</span>))<br></code></pre></td></tr></table></figure>

<p>此外，通过图中还可以发现文件IO也标注了需要通过线程池去运行的，这是因为*unix系统目前并没有一个稳定好用的文件io异步API，所以epoll暂未支持文件IO相关的异步操作，相信再不久的将来可以通过<code>io_uring</code>使用到文件的异步。</p>
<blockquote>
<p>Linux中的AIO设计的不好，且不是所有API都是异步的， 如果有兴趣，可以通过<a target="_blank" rel="noopener" href="https://arthurchiao.art/blog/intro-to-io-uring-zh/">[译] Linux 异步 I/O 框架 io_uring：基本原理、程序示例与性能压测（2020）</a>了解</p>
</blockquote>
<h3 id="2-2-asyncio-debug排查"><a href="#2-2-asyncio-debug排查" class="headerlink" title="2.2.asyncio debug排查"></a>2.2.<code>asyncio debug</code>排查</h3><p>很显然，经验法排查比较考验开发者的使用经验的技术储备，而且也容易出现漏网之鱼。此外还有一些容易被忽视的场景，比如大消息体的Json序列化或者加解密等费CPU的逻辑代码，如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> asyncio<br><span class="hljs-keyword">import</span> httpx<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>() -&gt; <span class="hljs-keyword">None</span>:</span><br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> httpx.AsyncClient() <span class="hljs-keyword">as</span> client:<br>        response = <span class="hljs-keyword">await</span> client.get(<span class="hljs-string">&quot;http://example.com&quot;</span>)<br>        print(response.json())<br><br><br>asyncio.run(main())<br></code></pre></td></tr></table></figure>
<p>这段代码使用到了<code>Asyncio</code>生态的HTTP库去获取一个URL的资源，按照经验法分析，这段代码基本没有什么阻塞<code>Asyncio</code>事件循环的可能性，但是如果这个网址返回了一个巨大的Json内容，那么就有可能因为<code>Json</code>序列化而阻塞到<code>Asyncio</code>事件循环的运行。</p>
<p>这种问题通常都是非常难排查到的，好在<code>Asyncio</code>提供了一个<code>debug</code>选项，通过这个选项可以知道哪些代码有可能阻塞到<code>Asyncio</code>事件循环的运行，如下代码:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> asyncio<br><span class="hljs-keyword">import</span> time<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sub_task1</span>() -&gt; <span class="hljs-keyword">None</span>:</span><br>    time.sleep(<span class="hljs-number">1</span>)<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sub_task2</span>() -&gt; <span class="hljs-keyword">None</span>:</span><br>    print(<span class="hljs-string">&quot;Hello!&quot;</span>)<br>    <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">1</span>)<br>    print(<span class="hljs-string">&quot;Hi&quot;</span>)<br>    <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">1</span>)<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sub_task3</span>() -&gt; <span class="hljs-keyword">None</span>:</span><br>    <span class="hljs-keyword">await</span> sub_task1()<br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sub_task4</span>() -&gt; <span class="hljs-keyword">None</span>:</span><br>    t = asyncio.create_task(sub_task1())<br>    <span class="hljs-keyword">await</span> t<br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>() -&gt; <span class="hljs-keyword">None</span>:</span><br>    t1 = asyncio.create_task(sub_task1())<br>    t2 = asyncio.create_task(sub_task2())<br>    t3 = asyncio.create_task(sub_task3())<br>    t4 = asyncio.create_task(sub_task4())<br>    <span class="hljs-keyword">await</span> asyncio.gather(t1, t2, t3, t4)<br><br><br>asyncio.run(main(), debug=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure>
<p>这个程序会并发执行4个任务，每个任务都是一个协程，分别为t1，t2，t3和t4。理论上它们四个协程能够并行运行的，但是由于<code>time.sleep(1)</code>的存在，会导致一部分时间<code>Asyncio</code>会被<code>time.sleep(1)</code>阻塞着，在运行程序之后可以看到终端打印如下输出(其中每行输出的开头是我手动标识的，用于标识是哪个协程输出的信息):</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">(t1) Executing &lt;Task finished coro=&lt;sub_task1() <span class="hljs-keyword">done</span>, defined at example.py:5&gt; result=None created at /usr/lib/python3.7/asyncio/tasks.py:325&gt; took 1.001 seconds<br>(t2) Hello!<br>(t3) Executing &lt;Task finished coro=&lt;sub_task3() <span class="hljs-keyword">done</span>, defined at example.py:16&gt; result=None created at /usr/lib/python3.7/asyncio/tasks.py:325&gt; took 1.001 seconds<br>(t4) Executing &lt;Task finished coro=&lt;sub_task1() <span class="hljs-keyword">done</span>, defined at example:5&gt; result=None created at /usr/lib/python3.7/asyncio/tasks.py:325&gt; took 1.001 seconds<br>(t2) Hi<br></code></pre></td></tr></table></figure>
<p>通过输出可以发现，<code>Asyncio</code>能够识别<code>sub_task1</code>和<code>sub_task3</code>都包含阻塞性的代码，<code>sub_task1</code>阻塞了两次，而且它们的阻塞时间都是在1秒左右。<br>在更进一步分析，并标识了输出信息与协程的关系后可以知道：</p>
<ul>
<li>t1协程是直接以<code>sub_task1</code>开始调用的，所以它一开始就被<code>sub_task1</code>阻塞了。</li>
<li>t2协程虽然通过<code>asyncio.sleep</code>休眠了两秒，但这两秒是通过把控制权让步给事件循环的，所以事件循环执行t2的时间是很快的，所以不会发出警告信息。</li>
<li>t3协程与t1协程类似，都是被<code>sub_task1</code>函数阻塞了。不过唯一的区别是t3协程的开始函数是<code>sub_task3</code>，所以在输出警告信息时会显示执行<code>sub_task3</code>函数(或者整个协程链)阻塞了1秒。</li>
<li>t4协程则是采用套娃的模式，在t4协程中会通过<code>asycniot.create_task</code>方法创建出一个新的协程来执行<code>sub_task1</code>函数，所以此时是有两个协程链，分别为<code>sub_task4</code>开头和<code>sub_task1</code>开头的协程链。其中<code>sub_task4</code>协程链只需要等待<code>sub_task1</code>协程链执行完成，所以不会阻塞事件循环，而<code>sub_task1</code>协程链则与t1协程一样阻塞了事件循环，所以最后<code>asyncio</code>会报<code>sub_task1</code>函数阻塞了1秒。</li>
</ul>
<p>通过这些分析可以知道，这个示例代码中的阻塞点就是<code>sub_task1</code>函数，不过他只显示哪个协程链有异常，具体哪里有问题还是需要根据经验法继续排查。更多<code>asyncio Debug</code>的开启方式和参数配置可以参考<a target="_blank" rel="noopener" href="https://docs.python.org/3/library/asyncio-dev.html#debug-mode">asyncio Debug Mode</a></p>
<blockquote>
<p>协程链这个名字是我取的，实际上每个<code>asyncio.create_task</code>创建的<code>Task</code>都可以理解为一个任务链，<code>Task</code>会通过<code>await</code>来传递协程的让步和继续点信息，详细可以通过<a href="https://so1n.me/2022/04/11/python's_waitable_objects_in_asyncio/#3-2-Task">Python的可等待对象在Asyncio的作用</a>了解。</p>
</blockquote>
<h2 id="3-少用loop-xxx，多用asyncio-xxx"><a href="#3-少用loop-xxx，多用asyncio-xxx" class="headerlink" title="3.少用loop.xxx，多用asyncio.xxx"></a>3.少用loop.xxx，多用asyncio.xxx</h2><p><code>Asyncio</code>最重要的就是事件循环，所以初期很多方法都是跟<code>EventLoop</code>有关，但是这些方法太底层了，同时又支持一个程序起多个<code>EventLoop</code>，所以对于一个刚接触<code>Asyncio</code>的新手容易因为<code>loop.xxx</code>方法而踩坑。</p>
<p>为了解决这些问题，<code>Python</code>在后续的版本中推出与<code>loop.xxx</code>相对应的<code>asyncio.xxx</code>方法，开发者只要使用这些方法，基本可以避免很多错误的使用事件循环的问题。因为它们在执行的时候都会找到当前运行的事件循环或者初始化一个事件循环，比如开始运行协程程序的方法:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> asyncio<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>() -&gt; <span class="hljs-keyword">None</span>:</span><br>    <span class="hljs-keyword">pass</span><br><br><br>loop = asyncio.get_event_loop()<br><span class="hljs-keyword">try</span>:<br>    loop.run_until_complete(main())<br><span class="hljs-keyword">finally</span>:<br>    loop.close()<br></code></pre></td></tr></table></figure>
<p>现在已经可以使用<code>asyncio.run</code>代替了，如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> asyncio<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>() -&gt; <span class="hljs-keyword">None</span>:</span><br>    <span class="hljs-keyword">pass</span><br><br><br>asyncio.run(main())<br></code></pre></td></tr></table></figure>
<p><code>asyncio.run</code>不仅使代码更加简便，同时也做了很多额外的工作，比如<code>asyncgen</code>资源的回收，线程池的回收以及防止在同一个线程起多个事件循环等。而与<code>asyncio.run</code>相同的还有<code>asyncio.to_thread</code>，它是<code>loop.run_in_executor</code>的变种版本，但是使用者无需考虑<code>loop</code>对象的使用。</p>
<p>不过在许多<code>asyncio.xxx</code>方法中有一个例外的是–<code>run_coroutine_threadsafe</code>，由于它是负责跨线程的调度，所以无法自动的匹配到正确的<code>loop</code>对象，所以需要手动传递<code>loop</code>对象，如下代码:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> asyncio<br><span class="hljs-keyword">from</span> threading <span class="hljs-keyword">import</span> Thread<br><br>event_loop = asyncio.get_event_loop()<br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">do_something</span>():</span><br>    print(<span class="hljs-string">&quot;Hi&quot;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">new_event_loop</span>():</span><br>    event_loop.run_forever() <span class="hljs-comment"># 线程内阻塞</span><br><br>t = Thread(target=new_event_loop).start()<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">100</span>):<br>    asyncio.run_coroutine_threadsafe(do_something(), loop=event_loop)<br></code></pre></td></tr></table></figure>
<p>这段代码是创建一个事件循环并放到子线程中运行，然后在通过<code>asyncio.run_coroutine_threadsafe</code>方法安排子线程的事件循环去执行对应的任务，如果不手动自定事件循环的话，它就只能找到当前主线程的事件循环。</p>
<h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h2><p>由于<code>Asyncio</code>是后面才出现的，且不像<code>go</code>，<code>Dart</code>，<code>js</code>一样隐式的运行事件循环，又使用了<code>async</code>,<code>await</code>的语法，所以导致很容易用错。而<code>gevent</code>不会污染原有代码，只需要注意猴子补丁的使用方法即可，随着使用的时间越来越多，我越觉得<code>gevent</code>才是<code>Python</code>的正确协程之道，不过<code>Asyncio</code>是受官方支持的，后面肯定会越来越好的。</p>
      </section>
      <section class="extra">
        
          <ul class="copyright">
  
    <li><strong>本文作者：</strong>So1n</li>
    <li><strong>本文链接：</strong><a href="http://so1n.me/2023/12/28/python_asyncio_lib_how_to_use_it_correctly/index.html" title="http:&#x2F;&#x2F;so1n.me&#x2F;2023&#x2F;12&#x2F;28&#x2F;python_asyncio_lib_how_to_use_it_correctly&#x2F;index.html">http:&#x2F;&#x2F;so1n.me&#x2F;2023&#x2F;12&#x2F;28&#x2F;python_asyncio_lib_how_to_use_it_correctly&#x2F;index.html</a></li>
    <li><strong>版权声明：</strong>本博客所有文章均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" title="BY-NC-SA" target="_blank" rel="noopener">BY-NC-SA</a> 许可协议，转载请注明出处！</li>
  
  <img src="https://raw.githubusercontent.com/so1n/so1n_blog_photo/master/blog_photo/%E6%89%AB%E7%A0%81_%E6%90%9C%E7%B4%A2%E8%81%94%E5%90%88%E4%BC%A0%E6%92%AD%E6%A0%B7%E5%BC%8F-%E6%A0%87%E5%87%86%E8%89%B2%E7%89%88.png" alt="text">

</ul>

        
        
          <section class="donate">
  <div id="qrcode-donate">
    <img src="https://fastly.jsdelivr.net/gh/so1n/so1n_blog_photo@master/blog_photo/16550449287744d2ebf32586d8799ee2e75333d6f5d2.jpg">
  </div>
  <div class="icon">
    <a href="javascript:;" id="alipay"><i class="iconfont iconalipay"></i></a>
    <a href="javascript:;" id="wechat"><i class="iconfont iconwechat-fill"></i></a>
  </div>
</section>
        
        
  <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Asyncio/" rel="tag">Asyncio</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python/" rel="tag">Python</a></li></ul> 

        
  <nav class="nav">
    <a href="/2024/10/01/how_to_solve_fastapi_lager_file/"><i class="iconfont iconleft"></i>如何解决FastAPI的大文件传输问题</a>
    <a href="/2023/12/07/how-to-use-dependency-injection-in-fastapi/">如何在FastAPI正确的使用依赖注入<i class="iconfont iconright"></i></a>
  </nav>

      </section>
      
        <section class="comments">
  
    <div class="btn" id="comments-btn">查看评论</div>
  
  
<link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<div id="gitalk" class="gitalk"></div>
<script defer src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
<script>
  window.onload = function () {
    var gitalk = new Gitalk({
      clientID: '59f804e526b05c378470',
      clientSecret: '36679ff697cec424936a0f7c4bcd6d2988dac28e',
      id: window.location.pathname,
      repo: 'so1n.github.io',
      owner: 'so1n',
      admin: 'so1n'
    });
    if ( true ) {
      $("#comments-btn").on("click", function () {
        $(this).hide();
        gitalk.render('gitalk');
      });
    } else {
      gitalk.render('gitalk');
    }
  }
</script>

</section>
      
    </section>
  </div>
</article>
</div>
      <div class="col-xl-3">
          
  <aside class="toc-wrap">
    <h3 class="toc-title">文章目录：</h3>
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%AE%B0"><span class="toc-text">前记</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E4%B8%8D%E5%90%8C%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E9%97%AE%E9%A2%98"><span class="toc-text">1.不同事件循环问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E9%98%BB%E5%A1%9E%E4%BB%A3%E7%A0%81%E9%97%AE%E9%A2%98"><span class="toc-text">2.阻塞代码问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E4%BD%BF%E7%94%A8%E7%BB%8F%E9%AA%8C%E6%B3%95%E6%8E%92%E6%9F%A5"><span class="toc-text">2.1.使用经验法排查</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-asyncio-debug%E6%8E%92%E6%9F%A5"><span class="toc-text">2.2.asyncio debug排查</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%B0%91%E7%94%A8loop-xxx%EF%BC%8C%E5%A4%9A%E7%94%A8asyncio-xxx"><span class="toc-text">3.少用loop.xxx，多用asyncio.xxx</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E6%80%BB%E7%BB%93"><span class="toc-text">4.总结</span></a></li></ol>
  </aside>

        
          
  <aside class="toc-wrap">
    <h3 class="toc-title">文章目录：</h3>
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%AE%B0"><span class="toc-text">前记</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E4%B8%8D%E5%90%8C%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E9%97%AE%E9%A2%98"><span class="toc-text">1.不同事件循环问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E9%98%BB%E5%A1%9E%E4%BB%A3%E7%A0%81%E9%97%AE%E9%A2%98"><span class="toc-text">2.阻塞代码问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E4%BD%BF%E7%94%A8%E7%BB%8F%E9%AA%8C%E6%B3%95%E6%8E%92%E6%9F%A5"><span class="toc-text">2.1.使用经验法排查</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-asyncio-debug%E6%8E%92%E6%9F%A5"><span class="toc-text">2.2.asyncio debug排查</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%B0%91%E7%94%A8loop-xxx%EF%BC%8C%E5%A4%9A%E7%94%A8asyncio-xxx"><span class="toc-text">3.少用loop.xxx，多用asyncio.xxx</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E6%80%BB%E7%BB%93"><span class="toc-text">4.总结</span></a></li></ol>
  </aside>

        
      </div>
    </div>
  </div>
</main>

  <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js">
</script>


<footer class="footer">
  <div class="footer-social"><a 
        href="https://github.com/so1n "
        target="_blank"
        class="footer-social-item"
        onMouseOver="this.style.color= '#9f7be1'" 
        onMouseOut="this.style.color='#33333D'">
          <i class="iconfont  icongithub-fill "></i>
      </a></div>
  
    <div class="footer-copyright"><p>Powered by <a target="_blank" href="https://hexo.io">Hexo</a>  |  Theme - <a target="_blank" href="https://github.com/izhaoo/hexo-theme-zhaoo">zhaoo</a>| <a target="_blank" href="/atom.xml">RSS</a> </p></div>
  
  <div class="footer-copyright">
      <a href="/atom.xml">
  </div>
  <div class="footer-copyright">
    总访问量<span id="busuanzi_value_site_pv"></span>次
    访客数<span id="busuanzi_value_site_uv"></span>人次
  </div>

</footer>

  
      <div class="fab fab-plus">
    <i class="iconfont iconplus"></i>
  </div>
  
  
  
  <div class="fab fab-up">
    <i class="iconfont iconcaret-up"></i>
  </div>
  
  
    <div class="scrollbar j-scrollbar">
  <div class="scrollbar-current j-scrollbar-current"></div>
</div>
  
  
    
<script src="/js/color-mode.js"></script>

  
  
    <div class="search">
  <div class="search-container">
    <div class="search-close">
      <i class="iconfont iconbaseline-close-px"></i>
    </div>
    <div class="search-input-wrapper">
      <i class="search-input-icon iconfont iconsearch"></i>
      <input class="search-input" type="search" id="search-input" placeholder="Search..." autofocus autocomplete="off"
        autocorrect="off" autocapitalize="off">
    </div>
    <div class="search-output" id="search-output"></div>
  </div>
</div>
  
</body>

<script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>





  
<script src="https://cdn.bootcdn.net/ajax/libs/jquery.lazyload/1.9.1/jquery.lazyload.min.js"></script>




  
<script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js"></script>






  
<script src="https://cdn.bootcdn.net/ajax/libs/jquery.qrcode/1.0/jquery.qrcode.min.js"></script>




<script src="/js/utils.js"></script>
<script src="/js/script.js"></script>







  <script>
    (function () {
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
      } else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>












</html>
