

<!DOCTYPE html>
<html lang="zh-Hans" color-mode=light>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Python Asyncio 之网络编程方法详解 - So1n blog</title>
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="google" content="notranslate" />
  
  <meta name="description" content="前记Python Asyncio不仅提供了简单的Soc...">
  <meta name="author" content="So1n">
  <link rel="icon" href="/images/icons/favicon.ico" type="image/png" sizes="16x16">
  <link rel="icon" href="/images/icons/favicon.ico" type="image/png" sizes="32x32">
  <link rel="apple-touch-icon" href="/images/icons/favicon.ico" sizes="180x180">
  <meta rel="mask-icon" href="/images/icons/stun-logo.svg" color="#333333">
  
    <meta rel="msapplication-TileImage" content="/images/icons/favicon.ico">
    <meta rel="msapplication-TileColor" content="#000000">
  

  
<link rel="stylesheet" href="/css/style.css">


  
    
<link rel="stylesheet" href="//at.alicdn.com/t/font_1445822_s6x2xcokxrl.css">

  

  
    
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css">

  

  
    
      
        
        
<link rel="stylesheet" href="https://cdn.bootcss.com/highlight.js/9.18.1/styles/atom-one-dark-reasonable.min.css" name="highlight-style" mode="light">

      
        
        
<link rel="stylesheet" href="https://cdn.bootcss.com/highlight.js/9.18.1/styles/atom-one-dark-reasonable.min.css" name="highlight-style" mode="dark">

      
  

  <script>
    var CONFIG = window.CONFIG || {};
    var ZHAOO = window.ZHAOO || {};
    CONFIG = {
      isHome: false,
      fancybox: true,
      pjax: false,
      loading: {
        gif: '',
        lottie: ''
      },
      lazyload: {
        enable: true,
        only_post: 'true',
        loading: {
          gif: '',
          lottie: ''
        }
      },
      donate: {
        enable: true,
        alipay: 'https://fastly.jsdelivr.net/gh/so1n/so1n_blog_photo@master/blog_photo/16550449287744d2ebf32586d8799ee2e75333d6f5d2.jpg',
        wechat: ''
      },
      galleries: {
        enable: true
      },
      fab: {
        enable: true,
        always_show: true
      },
      carrier: {
        enable: false
      },
      daovoice: {
        enable: false
      },
      preview: {
        background: {
          default: '',
          api: ''
        },
        motto: {
          default: 'I`m   So1n',
          typing: true,
          api: '',
          data_contents: '["data","content"]'
        },
      },
      qrcode: {
        enable: true,
        type: 'url',
        image: 'https://pic.izhaoo.com/weapp-code.jpg',
      },
      toc: {
        enable: true
      },
      scrollbar: {
        type: 'simple'
      },
      notification: {
        enable: false,
        delay: 4500,
        list: '',
        page_white_list: '',
        page_black_list: ''
      },
      search: {
        enable: true,
        path: 'search.xml'
      }
    }
  </script>

  

  

<meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="So1n blog" type="application/atom+xml">
</head>

<body class="lock-screen">
  <div class="loading" id="loading"></div>
  
    


  <nav class="navbar">
    <div class="left">
      
        <i class="iconfont iconhome j-navbar-back-home"></i>
      
      
        <i class="iconfont iconqrcode j-navbar-qrcode"></i>
      
      
        <i class="iconfont iconmoono" id="color-toggle" color-toggle="light"></i>
      
      
        <i class="iconfont iconsearch j-navbar-search"></i>
      
    </div>
    <div class="center">Python Asyncio 之网络编程方法详解</div>
    <div class="right">
      <i class="iconfont iconmenu j-navbar-menu"></i>
    </div>
    
      <div id="qrcode-navbar"></div>
    
  </nav>


  
  

<nav class="menu">
  <div class="menu-container">
    <div class="menu-close">
      <i class="iconfont iconbaseline-close-px"></i>
    </div>
    <ul class="menu-content"><li class="menu-item">
        <a href="/ " class="underline "> 首页</a>
      </li><li class="menu-item">
        <a href="/archives/ " class="underline "> 归档</a>
      </li><li class="menu-item">
        <a href="/tags/ " class="underline "> 标签</a>
      </li><li class="menu-item">
        <a href="/categories/ " class="underline "> 分类</a>
      </li><li class="menu-item">
        <a href="/project/ " class="underline "> 项目</a>
      </li><li class="menu-item">
        <a href="/about/ " class="underline "> 关于</a>
      </li></ul>
    
      <div class="menu-copyright"><p>Powered by <a target="_blank" href="https://hexo.io">Hexo</a>  |  Theme - <a target="_blank" href="https://github.com/izhaoo/hexo-theme-zhaoo">zhaoo</a>| <a target="_blank" href="/atom.xml">RSS</a> </p></div>
    
  </div>
</nav>
  <main id="main">
  <div class="article-wrap">
    <div class="row container">
      <div class="col-xl-3"></div>
      <div class="col-xl-6"><article class="article">
  <div class="wrap">
    <section class="head">
  <img src="https://fastly.jsdelivr.net/gh/so1n/so1n_blog_photo@master/blog_photo/16550442517731649661119526images.png" draggable="false">
  <div class="head-mask">
    <h1 class="head-title">Python Asyncio 之网络编程方法详解</h1>
    <div class="head-info">
      <span class="post-info-item"><i class="iconfont iconcalendar"></i>August 29, 2023</span>
      
      本文总阅读量<span id="busuanzi_value_page_pv"></span>次
      <span class="post-info-item"><i class="iconfont iconfont-size"></i>38523</span>
    </div>
  </div>
</section>

    <section class="main">
      <section class="content">
        <!-- 展示文章摘录 -->
        
          <p><h2 id="前记"><a href="#前记" class="headerlink" title="前记"></a>前记</h2><p><code>Python Asyncio</code>不仅提供了简单的<code>Socket</code>接口，还基于<code>Asyncio.Socket</code>提供了<code>Protocol</code>&amp;<code>Transport</code>接口以及更高级的<code>Stream</code>接口，这些接口大大的减轻了开发者进行网络编程的心理负担。<br>本文主要介绍了<code>Asyncio</code>这些接口的简单使用以及对应的原理分析。</p></p>
        
        <h2 id="1-简单介绍"><a href="#1-简单介绍" class="headerlink" title="1.简单介绍"></a>1.简单介绍</h2><p><code>Python Asyncio</code>提供了一套完整的高性能网络编程接口，它包括了兼容位于网络编程最底层的<code>Socket</code>–<code>Asyncio.Socket</code>，以及在<code>Asyncio.Socket</code>上层封装的<code>Protocol</code>&amp;<code>Transport</code>接口，还有在<code>Protocol</code>&amp;<code>Transport</code>上层封装的<code>Stream</code>接口。<br>这三套接口各有特色，开发者可以根据自己的需求选择其中一套接口来使用，进而减少网络编程的一些心理负担。</p>
<p><code>Python Asyncio</code>三套接口的关系就跟套娃一样，<code>Stream</code> 套在<code>Protocol</code>&amp;<code>Transport</code>上面 ，而<code>Protocol</code>&amp;<code>Transport</code>套在<code>Socket</code>上面，由于<code>Stream</code>是最上层的封装，所以它的易用性最高，不过适用范围最少，其次是<code>Protocol</code>&amp;<code>Transport</code>，最后是<code>Socket</code>，它的易用性最差，但是适用范围最广，不过它们的性能却跟套娃顺序无关。<br>根据<code>uvloop</code>的性能比较得出他们的性能关系为<code>Protocol</code>&amp;<code>Transport</code> &gt; <code>Stream</code> &gt; <code>Socket</code>，具体结果如图：</p>
<p><img src="https://raw.githubusercontent.com/MagicStack/uvloop/master/performance.png"></p>
<p>在第一次见到这个性能的比较结果时我觉得是非常神奇的，因为对于一些分层架构来说，越上层的封装越多，易用性越好，而性能反而越低，但在性能比较结果中性能最好的却是处于中间的<code>Protocol</code>&amp;<code>Transport</code>，然后是<code>Stream</code>，最后才是<code>Asycnio Socket</code>。为了了解这个原因，需要通过网络编程接口的使用方法和源码一起分析。</p>
<h3 id="1-1-Socket的简单介绍"><a href="#1-1-Socket的简单介绍" class="headerlink" title="1.1.Socket的简单介绍"></a>1.1.Socket的简单介绍</h3><p>无论<code>Asyncio</code>的网络编程接口是怎么封装，如果要了解它是怎么实现的，那么需要对<code>Socket</code>有一定的了解。<br>不过本文只对<code>Socket</code>进行简单的介绍，并不会对<code>Socket</code>的原理进行详细的描述，同时<code>Python Asyncio</code>的<code>Stream</code>接口只支持流传输，所以本文只采用<code>Socket</code>进行TCP传输的编程实例进行讲述，其他的编程方式和<code>Socket</code>介绍见下文:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://gist.github.com/kevinkindom/108ffd675cb9253f8f71">Python Socket 编程详细介绍</a></li>
<li><a target="_blank" rel="noopener" href="https://realpython.com/python-sockets/">Socket Programming in Python (Guide)</a></li>
</ul>
<p><code>Socket</code>是计算机之间进行通信的一种协议，通过<code>Socket</code>开发者可以在无需关心底层是如何实现的情况下在不同的计算机进行端到端之间的通信，<br><code>Socket</code>常见的交互流程如下图：<br><img  src="https://fastly.jsdelivr.net/gh/so1n/so1n_blog_photo@master/blog_photo/1692807503149asyncio%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-socket.png"  ><span class="image-caption">1692807503149asyncio网络编程-socket.png</span></p>
<p>在交互的流程的示例图中，<code>Socket</code>分为五个交互阶段，每个阶段的作用如下：</p>
<ul>
<li>创建<code>Socket</code>: 初始化一个<code>Socket</code>对象。</li>
<li>初始化<code>Socket</code>: 客户端无需任何操作，而服务端的<code>Socket</code>在初始化时比客户端的<code>Socket</code>多了两个方法–<code>bind</code>和<code>listen</code>，它们的作用分别是绑定一个端口，以及监听这个端口建立的新连接。</li>
<li>建立连接： 客户端<code>Socket</code>的专属方法为<code>connect</code>，这个方法会直接与服务端建立连接。而服务端的专属方法为<code>accept</code>，<code>accept</code>这个方法比较特殊，因为其他<code>socket</code>的方法都是针对于<code>socket</code>进行操作，而<code>accept</code>方法除了针对<code>socket</code>进行操作外还会额外返回一个新的<code>socket</code>。<br>同时服务端原先的<code>socket</code>只携带服务端的IP和地址信息，而新的<code>socket</code>携带的是客户端与服务端两个端点的四元组信息（客户端IP，客户端端口，服务端IP，服务端端口）。<br>这一点是非常重要的，因为这两个<code>socket</code>对应的文件描述符是不一样的，它们的责任也是不一样的，<br>原来的<code>socket</code>只用于跟客户端建立新的连接，而新的<code>socket</code>用于客户端与服务端进行数据交互，这意味着服务端的事件循环在处理的时候，对两个<code>socket</code>的读事件的触发时机也是不一样的。其中服务端原先<code>socket</code>的读事件被触发时意味着有新的连接可以被<code>accept</code>，而新<code>socket</code>的读事件被触发则是代表当前连接有新的数据可以被接收，这与客户端的<code>Socket</code>读事件的一样的，这意味着在<code>Socket</code>建立成功后，客户端和服务端的连接的读写逻辑都可以统一，不用进行区分了。</li>
<li>数据交互阶段：由于服务端<code>accept</code>方法返回的<code>Socket</code>与客户端的类似，所以这个阶段的客户端与服务端的逻辑是类似的，不过双端程序的数据只是与各自的<code>Socket</code>进行交互，而不是直接进行交互的。因为每个<code>Socket</code>都维护着读和写两个缓冲区，缓冲区的底层数据结构与队列类似，创建<code>Socket</code>的程序只能把数据投递到缓冲区或者从缓冲区获取数据，而无法触碰到网卡发送/接收数据的领域。<br>这也意味着在把<code>Socket</code>设置为非阻塞的情况下，当<code>Socket</code>的写缓冲区不满时，<code>Socket</code>的写操作是不会阻塞的，同样当<code>Socket</code>的读缓冲区拥有的量大于<code>Socket</code>读方法需要的量时，读操作也是不会阻塞的。</li>
<li>关闭阶段：由于<code>Socket</code>有两个缓冲区，所以关闭阶段分为<code>close</code>和<code>shutdowm</code>两个方法，其中<code>close</code>为关闭两个缓冲区，而<code>shuwdown</code>可以关闭指定的缓冲区(详细的流程见后文)。示例中的例子是服务端先调用了<code>close</code>方法，然后服务端会发送一个<code>EOF</code>事件给客户端，客户端从读缓冲区读到<code>EOF</code>事件后发现读通道已经关闭了，才调用<code>close</code>方法把整个<code>socket</code>一起关闭。</li>
</ul>
<h2 id="2-Asyncio-Socket"><a href="#2-Asyncio-Socket" class="headerlink" title="2.Asyncio Socket"></a>2.Asyncio Socket</h2><p>在文章<a href="https://so1n.me/2021/11/08/%E5%88%9D%E8%AF%86Python%20Async%E7%9A%84%E5%AE%9E%E7%8E%B0/">《初识Python协程的实现》</a>中介绍了如何把同步请求通过<code>selector</code>库和<code>yield</code>语法改造成一个简单的基于协程的异步请求，但是改造后的代码增加了很多监听和移除文件描述符的回调代码，编写起来比较麻烦，很不易懂。</p>
<p>不过在采用了<code>Asyncio</code>的思想并引入了<code>Task</code>和<code>Future</code>后，异步回调的代码都被消除了，但是大量的监听和移除文件描述符的代码还是存在，而<code>Asyncio.Socket</code>则封装了大量的读写事件的监听和移除的操作，只暴露了与<code>Socket</code>类似的方法，开发者通过这些方法可以简单快速的把同步请求改为基于协程的异步请求，比如<a href="https://so1n.me/2021/11/08/%E5%88%9D%E8%AF%86Python%20Async%E7%9A%84%E5%AE%9E%E7%8E%B0/">《初识Python协程的实现》</a>中的同步请求，它的源码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> socket<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">request</span>(<span class="hljs-params">host: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>    url: <span class="hljs-built_in">str</span> = <span class="hljs-string">f&quot;http://<span class="hljs-subst">&#123;host&#125;</span>&quot;</span><br>    sock: socket.SocketType = socket.socket()<br>    sock.connect((host, <span class="hljs-number">80</span>))<br>    sock.send(<span class="hljs-string">f&quot;GET <span class="hljs-subst">&#123;url&#125;</span> HTTP/1.0\r\nHost: <span class="hljs-subst">&#123;host&#125;</span>\r\n\r\n&quot;</span>.encode(<span class="hljs-string">&quot;ascii&quot;</span>))<br><br>    response_bytes: <span class="hljs-built_in">bytes</span> = <span class="hljs-string">b&quot;&quot;</span><br>    chunk: <span class="hljs-built_in">bytes</span> = sock.recv(<span class="hljs-number">4096</span>)<br>    <span class="hljs-keyword">while</span> chunk:<br>        response_bytes += chunk<br>        chunk = sock.recv(<span class="hljs-number">4096</span>)<br>    print(<span class="hljs-string">&quot;\n&quot;</span>.join([i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> response_bytes.decode().split(<span class="hljs-string">&quot;\r\n&quot;</span>)]))<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    request(<span class="hljs-string">&quot;so1n.me&quot;</span>)<br></code></pre></td></tr></table></figure>
<p>这份代码只对<code>Socket</code>进行简单的调用，其中涉及到<code>Socket</code>的调用方法有:</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>作用</th>
<th>是否涉及到IO</th>
</tr>
</thead>
<tbody><tr>
<td>socket.socket</td>
<td>初始化socket</td>
<td>否</td>
</tr>
<tr>
<td>socket.connect</td>
<td>建立连接</td>
<td>是</td>
</tr>
<tr>
<td>socket.send</td>
<td>发送数据</td>
<td>是</td>
</tr>
<tr>
<td>socket.recv</td>
<td>接收数据</td>
<td>是</td>
</tr>
</tbody></table>
<p>在把它改为<code>Asyncio.Socket</code>时，只需要把涉及到IO的<code>Socket</code>方法以<code>loop.sock_xxx(sock, *param)</code>的形式进行修改，其中<code>xxx</code>是原来的方法名，<code>sock</code>则是通过<code>socket.socket</code>实例化的一个<code>sock</code>对象，而<code>param</code>则保持跟之前的一样的参数，更改后的代码如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> asyncio<br><span class="hljs-keyword">import</span> socket<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">request</span>(<span class="hljs-params">host: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>    url: <span class="hljs-built_in">str</span> = <span class="hljs-string">f&quot;http://<span class="hljs-subst">&#123;host&#125;</span>&quot;</span><br>    loop = asyncio.get_event_loop()<br>    sock: socket.SocketType = socket.socket()<br>    <span class="hljs-keyword">await</span> loop.sock_connect(sock, (host, <span class="hljs-number">80</span>))<br>    <span class="hljs-keyword">await</span> loop.sock_sendall(sock, <span class="hljs-string">f&quot;GET <span class="hljs-subst">&#123;url&#125;</span> HTTP/1.0\r\nHost: <span class="hljs-subst">&#123;host&#125;</span>\r\n\r\n&quot;</span>.encode(<span class="hljs-string">&quot;ascii&quot;</span>))<br><br>    response_bytes: <span class="hljs-built_in">bytes</span> = <span class="hljs-string">b&quot;&quot;</span><br>    chunk: <span class="hljs-built_in">bytes</span> = <span class="hljs-keyword">await</span> loop.sock_recv(sock, <span class="hljs-number">4096</span>)<br>    <span class="hljs-keyword">while</span> chunk:<br>        response_bytes += chunk<br>        chunk = <span class="hljs-keyword">await</span> loop.sock_recv(sock, <span class="hljs-number">4096</span>)<br>    print(<span class="hljs-string">&quot;\n&quot;</span>.join([i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> response_bytes.decode().split(<span class="hljs-string">&quot;\r\n&quot;</span>)]))<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    asyncio.run(request(<span class="hljs-string">&quot;so1n.me&quot;</span>))<br></code></pre></td></tr></table></figure>

<blockquote>
<p><code>Asyncio Socket</code>没有提供<code>send</code>方法，这里需要改为<code>sendall</code>。</p>
</blockquote>
<p>可以看到，代码的改动并没有很大，除了传染性的<code>async</code>和<code>await</code>语法外，其它逻辑并没有什么明显的变化，在运行代码之后可以看到程序运行成功，并输出如下响应结果：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs bash">HTTP/1.1 301 Moved Permanently<br>Connection: close<br>Content-Length: 162<br>Server: GitHub.com<br>Content-Type: text/html<br>Location: https://so1n.me/<br>X-GitHub-Request-Id: 9E20:2767:4FED3D:55C800:64E46CAF<br>Accept-Ranges: bytes<br>Date: Tue, 22 Aug 2023 08:11:04 GMT<br>Via: 1.1 varnish<br>Age: 233<br>X-Served-By: cache-hkg17935-HKG<br>X-Cache: HIT<br>X-Cache-Hits: 1<br>X-Timer: S1692691865.899948,VS0,VE1<br>Vary: Accept-Encoding<br>X-Fastly-Request-ID: 7180dce567d15eacaf44c9b93a2fb84bd67ab444<br><br>&lt;html&gt;<br>&lt;head&gt;&lt;title&gt;301 Moved Permanently&lt;/title&gt;&lt;/head&gt;<br>&lt;body&gt;<br>&lt;center&gt;&lt;h1&gt;301 Moved Permanently&lt;/h1&gt;&lt;/center&gt;<br>&lt;hr&gt;&lt;center&gt;nginx&lt;/center&gt;<br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure>
<p>可以看到程序是正常运行的，为了了解<code>Asyncio.Socket</code>做了什么工作，接下来会翻阅源码，探究它的处理方法，首先是<code>loop.sock_connect</code>，它的源码如下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-comment"># 位于:Lib/asyncio/selector_events.py</span><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sock_connect</span>(<span class="hljs-params">self, sock, address</span>):</span><br>    <span class="hljs-comment"># 检查ssl sock以及检查是否为阻塞的sock</span><br>    base_events._check_ssl_socket(sock)<br>    <span class="hljs-keyword">if</span> self._debug <span class="hljs-keyword">and</span> sock.gettimeout() != <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&quot;the socket must be non-blocking&quot;</span>)<br><br>    <span class="hljs-keyword">if</span> sock.family == socket.AF_INET <span class="hljs-keyword">or</span> (<br>            base_events._HAS_IPv6 <span class="hljs-keyword">and</span> sock.family == socket.AF_INET6):<br>        <span class="hljs-comment"># 通过dns将域名转为ip地址</span><br>        resolved = <span class="hljs-keyword">await</span> self._ensure_resolved(<br>            address, family=sock.family, <span class="hljs-built_in">type</span>=sock.<span class="hljs-built_in">type</span>, proto=sock.proto,<br>            loop=self,<br>        )<br>        _, _, _, _, address = resolved[<span class="hljs-number">0</span>]<br><br>    <span class="hljs-comment"># 创建一个future，这个future会等待soc连连接成功才返回数据。</span><br>    fut = self.create_future()<br>    self._sock_connect(fut, sock, address)<br>    <span class="hljs-comment"># 通过future等待soc床创建成功</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> fut<br></code></pre></td></tr></table></figure>
<p>这个方法分为三部分，首先是检查<code>Socket</code>的ssl并进行一些参数校验，然后通过<code>self._ensure_resolved</code>方法进行dns解析，最后才通过<code>self._sock_connect</code>方法进行真正建立连接。其中，dns解析方法<code>self._ensure_resolved</code>是<code>sock_connect</code>方法与其他<code>Socket</code>方法的不同点，它的源码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-comment"># 位于:Lib/asyncio/selector_events.py</span><br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_ensure_resolved</span>(<span class="hljs-params">self, address, *, family=<span class="hljs-number">0</span>, <span class="hljs-built_in">type</span>=socket.SOCK_STREAM, proto=<span class="hljs-number">0</span>, flags=<span class="hljs-number">0</span>, loop</span>):</span><br>        host, port = address[:<span class="hljs-number">2</span>]<br>    	<span class="hljs-comment"># 判断是否已经解析，已经解析了就直接使用</span><br>        info = _ipaddr_info(host, port, family, <span class="hljs-built_in">type</span>, proto, *address[<span class="hljs-number">2</span>:])<br>        <span class="hljs-keyword">if</span> info <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-comment"># &quot;host&quot; is already a resolved IP.</span><br>            <span class="hljs-keyword">return</span> [info]<br>        <span class="hljs-keyword">else</span>:<br>    		<span class="hljs-comment"># 没有解析则调用socket.getaddrinfo进行解析</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> loop.getaddrinfo(host, port, family=family, <span class="hljs-built_in">type</span>=<span class="hljs-built_in">type</span>, proto=proto, flags=flags)<br>    <br><span class="hljs-comment"># 位于:Lib/asyncio/base_events.py</span><br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getaddrinfo</span>(<span class="hljs-params">self, host, port, *, family=<span class="hljs-number">0</span>, <span class="hljs-built_in">type</span>=<span class="hljs-number">0</span>, proto=<span class="hljs-number">0</span>, flags=<span class="hljs-number">0</span></span>):</span><br>        <span class="hljs-keyword">if</span> self._debug:<br>            getaddr_func = self._getaddrinfo_debug<br>        <span class="hljs-keyword">else</span>:<br>            getaddr_func = socket.getaddrinfo<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> self.run_in_executor(<br>            <span class="hljs-literal">None</span>, getaddr_func, host, port, family, <span class="hljs-built_in">type</span>, proto, flags)<br></code></pre></td></tr></table></figure>
<p>通过源码发现，dns解析的逻辑中涉及到了<code>run_in_executor</code>方法，这个方法是把任务交给线程池进行处理。<br>在这里使用<code>run_in_executor</code>方法的原因是<code>POSIX</code>的DNS解析API是阻塞的，且没有提供异步选项，如果直接执行这个方法会卡住整个<code>Asyncio Event Loop</code>的运行，所以只能通过线程去调用这个API完成DNS解析，<br>不过<code>Asyncio</code>的默认线程池数量很小，如果是做爬虫类等需要频繁的进行DNS解析的项目，需要把默认的线程池改大一些。</p>
<blockquote>
<p>uvloop使用的libuv也选择了POSIX API，它的工作原理也是通过线程去执行DNS解析，详情见<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/44603059/why-libuv-do-dns-request-by-multiple-thread">why libuv do DNS request by multiple thread</a></p>
</blockquote>
<p>在通过DNS进行地址解析后就拿到了真正的地址，这时可以开始进行真正的连接了，此时会调用<code>_sock_connect</code>方法去建立连接，它的源码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-comment"># 位于:Lib/asyncio/selector_events.py</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_sock_connect</span>(<span class="hljs-params">self, fut, sock, address</span>):</span><br>    fd = sock.fileno()<br>    <span class="hljs-keyword">try</span>:<br>        sock.connect(address)<br>    <span class="hljs-keyword">except</span> (BlockingIOError, InterruptedError):<br>        <span class="hljs-comment"># 检查对应的文件描述符对应的连接是否还在运行</span><br>        <span class="hljs-comment"># 如果还在运行则抛错</span><br>        self._ensure_fd_no_transport(fd)<br>        <span class="hljs-comment"># 注册文件描述符的读回调</span><br>        handle = self._add_writer(fd, self._sock_connect_cb, fut, sock, address)<br>        <span class="hljs-comment"># 通过fut添加fut完成时移除监听的回调</span><br>        fut.add_done_callback(functools.partial(self._sock_write_done, fd, handle=handle))<br>    <span class="hljs-keyword">except</span> (SystemExit, KeyboardInterrupt):<br>        <span class="hljs-keyword">raise</span><br>    <span class="hljs-keyword">except</span> BaseException <span class="hljs-keyword">as</span> exc:<br>        fut.set_exception(exc)<br>    <span class="hljs-keyword">else</span>:<br>        fut.set_result(<span class="hljs-literal">None</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_sock_write_done</span>(<span class="hljs-params">self, fd, fut, handle=<span class="hljs-literal">None</span></span>):</span><br>    <span class="hljs-comment"># 移除事件的监听</span><br>    <span class="hljs-keyword">if</span> handle <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> handle.cancelled():<br>        self.remove_writer(fd)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_sock_connect_cb</span>(<span class="hljs-params">self, fut, sock, address</span>):</span><br>    <span class="hljs-keyword">if</span> fut.done():<br>        <span class="hljs-keyword">return</span><br>    <span class="hljs-comment"># 当有写事件除非时代表着连接建立这个行为已经执行完毕了，但是需要检查建立结果</span><br>    <span class="hljs-keyword">try</span>:<br>        err = sock.getsockopt(socket.SOL_SOCKET, socket.SO_ERROR)<br>        <span class="hljs-keyword">if</span> err != <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">raise</span> OSError(err, <span class="hljs-string">f&#x27;Connect call failed <span class="hljs-subst">&#123;address&#125;</span>&#x27;</span>)<br>    <span class="hljs-keyword">except</span> (BlockingIOError, InterruptedError):<br>        <span class="hljs-keyword">pass</span><br>    <span class="hljs-keyword">except</span> (SystemExit, KeyboardInterrupt):<br>        <span class="hljs-keyword">raise</span><br>    <span class="hljs-keyword">except</span> BaseException <span class="hljs-keyword">as</span> exc:<br>        fut.set_exception(exc)<br>    <span class="hljs-keyword">else</span>:<br>        fut.set_result(<span class="hljs-literal">None</span>)<br></code></pre></td></tr></table></figure>
<p>这个方法的执行逻辑与其他的<code>Socket</code>方法的执行逻辑是类似，它们都会先尝试去执行<code>Socket</code>原先的方法，这时候如果操作系统准备就绪，那么意味着可以无阻塞的执行了<code>Socket</code>方法，否则是操作系统尚未准备好，需要捕获异常并对异常进行处理。</p>
<p>在捕获到异常后，会通过<code>_add_writer</code>添加了一个写事件的回调<code>_sock_connect_cb</code>，再通过fut添加一个fut完成时的<code>_sock_write_done</code>回调，然后就会把控制权交给了事件循环。<br>当事件循环发现文件描述符有事件被触发时，会调用<code>_sock_connect_cb</code>获取建立连接的结果，如果结果有异常，则把异常添加到fut中，否则就把结果放置到fut中，这样fut都会从<code>peding</code>状态变为<code>done</code>，fut也就会触发<code>_sock_write_done</code>移除掉事件循环对文件描述符的监听。</p>
<blockquote>
<p><code>_add_reader</code>，<code>_remove_reader</code>，<code>_add_writer</code>与<code>_remove_writer</code>是<code>Asyncio</code>为<code>socket</code>与<code>selector</code>直接交互封装的方法，可以通过文章<a href="https://so1n.me/2022/06/08/python_asyncio_schedule">《Python Asyncio调度原理》</a>进行了解。</p>
</blockquote>
<p>除了<code>Socket.connect</code>方法外，与<code>Asyncio.Socket</code>相关的方法还有很多，不过原理是一样的，它们的流程都可以简化为下图：<br><img  src="https://fastly.jsdelivr.net/gh/so1n/so1n_blog_photo@master/blog_photo/1693295513482asyncio%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-asycnio-socket%E7%9A%84%E6%89%A7%E8%A1%8C%E9%80%BB%E8%BE%91.png"  ><span class="image-caption">asyncio网络编程-asycnio-socket的执行逻辑.png</span></p>
<p>该图展示的是每个<code>Asyncio.Socket</code>方法的核心逻辑，各个方法具体的执行逻辑可以通过<a target="_blank" rel="noopener" href="https://github.com/python/cpython/blob/677320348728ce058fa3579017e985af74a236d4/Lib/asyncio/selector_events.py">源码</a>进行详细的了解，常见的<code>socket</code>方法与<code>Asyncio Socket</code>方法对照表如下：</p>
<table>
<thead>
<tr>
<th>sock方法</th>
<th>Asyncio Sock方法</th>
<th>归属</th>
</tr>
</thead>
<tbody><tr>
<td>bind</td>
<td>无</td>
<td>服务端</td>
</tr>
<tr>
<td>listen</td>
<td>无</td>
<td>服务端</td>
</tr>
<tr>
<td>accept</td>
<td>sock_accept</td>
<td>服务端</td>
</tr>
<tr>
<td>connect</td>
<td>sock_connect</td>
<td>客户端</td>
</tr>
<tr>
<td>connect_ex</td>
<td>无</td>
<td>客户端</td>
</tr>
<tr>
<td>recv</td>
<td>sock_recv</td>
<td>共用</td>
</tr>
<tr>
<td>recv_info</td>
<td>sock_recv_into</td>
<td>共用</td>
</tr>
<tr>
<td>recvfrom</td>
<td>sock_recvfrom</td>
<td>共用</td>
</tr>
<tr>
<td>sendto</td>
<td>sock_sendto</td>
<td>共用</td>
</tr>
</tbody></table>
<h2 id="3-Protocol-amp-Transport"><a href="#3-Protocol-amp-Transport" class="headerlink" title="3.Protocol&amp;Transport"></a>3.Protocol&amp;Transport</h2><p><code>Asyncio.Socket</code>提供了<code>Socket</code>的调用方法的封装，但是如果直接基于<code>Socket</code>进行网络编程仍然会比较复杂，特别是TCP网络编程还需要处理很多东西。<br>为此<code>Asyncio</code>提供了一套<code>Protocol</code>&amp;<code>Transport</code>接口，它们面向开发者提供的方法都会屏蔽底层的<code>Socket</code>细节，并基于TCP或UDP协议封装了一些方法调用，开发者只要根据<code>Protocol</code>&amp;<code>Transport</code>协定的几个方法就可以快速开发出一个能够稳定使用的TCP服务。</p>
<p>在<code>Asyncio</code>的定义中，<code>Protocol</code>&amp;<code>Transport</code>是无法分开的一个整体，它们一起定义了网络I/O和进程间I/O的抽象接口，对于开发者来说可以简单的把<code>Protocol</code>理解为专门负责处理被动调用的，也就是连接什么时候建立，连接什么时候接收了数据；而<code>Transport</code>则是提供了许多开发者可以主动调用的接口，包括了向连接发送数据，关闭连接等等。</p>
<h3 id="3-1使用示例"><a href="#3-1使用示例" class="headerlink" title="3.1使用示例"></a>3.1使用示例</h3><p>官方的<code>Protocol</code>&amp;<code>Transport</code>的示例是<code>TCP Echo</code>，在这个示例中，服务端会接收客户端的消息并返回给客户端一样的消息，然后再关闭连接。而客户端会发送消息，并在接收消息后等待被关闭，其中服务端的示例代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> asyncio<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EchoServerProtocol</span>(<span class="hljs-params">asyncio.Protocol</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">connection_made</span>(<span class="hljs-params">self, transport</span>):</span><br>        <span class="hljs-comment"># transport创建成功后的回调，这里需要跟Protocol进行绑定</span><br>        peername = transport.get_extra_info(<span class="hljs-string">&#x27;peername&#x27;</span>)<br>        print(<span class="hljs-string">&#x27;Connection from &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(peername))<br>        self.transport = transport<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">data_received</span>(<span class="hljs-params">self, data</span>):</span><br>        <span class="hljs-comment"># socket收到数据的回调事件，这里先接收消息，再把内容返回给客户端最后再关闭</span><br>        message = data.decode()<br>        print(<span class="hljs-string">&#x27;Data received: &#123;!r&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(message))<br><br>        print(<span class="hljs-string">&#x27;Send: &#123;!r&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(message))<br>        self.transport.write(data)<br><br>        print(<span class="hljs-string">&#x27;Close the client socket&#x27;</span>)<br>        self.transport.close()<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    server = <span class="hljs-keyword">await</span> asyncio.get_running_loop().create_server(<br>        <span class="hljs-keyword">lambda</span>: EchoServerProtocol(), <span class="hljs-string">&#x27;127.0.0.1&#x27;</span>, <span class="hljs-number">8888</span><br>    )<br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> server:<br>        <span class="hljs-keyword">await</span> server.serve_forever()<br><br><br>asyncio.run(main())<br></code></pre></td></tr></table></figure>
<p>这份示例代码分为两大部分，一部分是<code>main</code>函数，它主要的工作是通过<code>create_server</code>创建一个TCP服务并通过<code>server.serve_forever()</code>运行服务。另一部分是<code>EchoServerProtocol</code>，它主要是在TCP服务<code>accept</code>了请求后被创建的，除此之外，<code>EchoServerProtocol</code>在收到请求数据后会把对应的数据通过<code>Protocol</code>的不同方法传递给使用者，而客户端的行为则不一样，它对应的源码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> asyncio<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EchoClientProtocol</span>(<span class="hljs-params">asyncio.Protocol</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, on_con_lost, received_queue</span>):</span><br>        <span class="hljs-comment"># 这里的on_con_lost是一个future对象，用于通知连接已经断开</span><br>        self.on_con_lost = on_con_lost<br>        <span class="hljs-comment"># 这里的received_queue是一个queue对象，用于接收消息</span><br>        self.received_queue = received_queue<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">connection_made</span>(<span class="hljs-params">self, transport</span>):</span><br>        <span class="hljs-comment"># transport创建成功后的回调，这里需要跟Protocol进行绑定</span><br>        self.transport = transport<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">data_received</span>(<span class="hljs-params">self, data</span>):</span><br>        self.received_queue.put_nowait(data.decode())<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">connection_lost</span>(<span class="hljs-params">self, exc</span>):</span><br>        <span class="hljs-comment"># socket连接断开的回调事件，这里需要通知on_con_lost</span><br>        self.on_con_lost.set_result(<span class="hljs-literal">True</span>)<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    loop = asyncio.get_running_loop()<br>    on_con_lost = loop.create_future()<br>    received_queue = asyncio.Queue()<br><br>    <span class="hljs-comment"># 初始化连接并接收返回的transport和protocol</span><br>    transport, protocol = <span class="hljs-keyword">await</span> loop.create_connection(<br>        <span class="hljs-keyword">lambda</span>: EchoClientProtocol(on_con_lost, received_queue),<br>        <span class="hljs-string">&#x27;127.0.0.1&#x27;</span>, <span class="hljs-number">8888</span>)<br><br>    <span class="hljs-comment"># 通过transport发送消息，写入消息是直接投递到系统的socket缓冲区，不会阻塞</span><br>    transport.write(<span class="hljs-string">&#x27;Hello World!&#x27;</span>.encode())<br>    <span class="hljs-comment"># 等待消息的返回</span><br>    rece_msg = <span class="hljs-keyword">await</span> received_queue.get()<br>    print(<span class="hljs-string">&quot;Data received:&quot;</span> + rece_msg)<br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-comment"># 等待连接被远方断开</span><br>        <span class="hljs-keyword">await</span> on_con_lost<br>    <span class="hljs-keyword">finally</span>:<br>        <span class="hljs-comment"># 确保连接被关闭</span><br>        transport.close()<br><br><br>asyncio.run(main())<br></code></pre></td></tr></table></figure>
<p>通过源码可以看到客户端也分为两部分，首先是<code>EchoClientProtocol</code>，它与服务端的<code>Protocol</code>类似，主要的区别是在初始化时的多了<code>on_con_lost</code>和<code>received_queue</code>参数，通过它们可以把异步回调转为同步调用。其中<code>on_con_lost</code>是用于监听连接什么时候丢失，<code>received_queue</code>则是接收了来自<code>Socket</code>的数据以供调用者获取。<br>另一部分的<code>main</code>函数的不同点是先通过<code>create_connection</code>建立了连接并返回了<code>Protocol</code>&amp;<code>Transport</code>，在建立连接成功后使用者可以通过<code>Transport</code>发送数据，或者通过<code>received_queue</code>获取数据以及通过<code>on_con_lost</code>等待连接被断开。</p>
<p>在把客户端与服务端的代码编写完毕后，先运行服务端的代码，然后再运行客户端的代码，会发现服务端打印了如下数据:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">Connection from (<span class="hljs-string">&#x27;127.0.0.1&#x27;</span>, 49072)<br>Data received: <span class="hljs-string">&#x27;Hello World!&#x27;</span><br>Send: <span class="hljs-string">&#x27;Hello World!&#x27;</span><br>Close the client socket<br></code></pre></td></tr></table></figure>
<p>而客户端打印了如下数据:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">Data received:Hello World!<br></code></pre></td></tr></table></figure>
<p>通过输出结果可以看到示例代码是正常运行的，它们基于<code>Protocol</code>&amp;<code>Transport</code>完成了数据的传输，<br>同时在运行的过程中涵盖了<code>Protocol</code>&amp;<code>Transport</code>的主要方法，对应的执行过程如下图：<br><img  src="https://fastly.jsdelivr.net/gh/so1n/so1n_blog_photo@master/blog_photo/1692808529149asyncio%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-ProtocolTransport.png"  ><span class="image-caption">1692808529149asyncio网络编程-ProtocolTransport.png</span></p>
<p>图中<code>loop</code>代表事件循环的方法，<code>t</code>代表<code>Transport</code>的方法，<code>p</code>则代表<code>Protoccol</code>的方法，通过图的执行过程可以看到除了<code>loop</code>的方法是在进行初始化外，不管对于客户端还是服务端，<code>Protocol</code>负责做回调的事情，<code>Transport</code>则是做主动调用的事情。此外客户端和服务端的<code>Protocol</code>&amp;<code>Transport</code>在建立连接和数据交互阶段的作用是一致的，可以看出<code>Protocol</code>&amp;<code>Transport</code>的逻辑是客户端和服务端共享的。</p>
<p>不过再回过头看示例代码则可以发现示例代码基于它们进行拓展开发的方式有所不同，对于服务端，由于它得等到客户端调用才能开始处理请求，它属于被动的一方，所以对服务端进行拓展开发时需要在它们的回调事件中编写对应的业务代码，并对<code>Transport</code>进行调用。<br>而客户端则处于主动的一方，需要初始化一些容器把异步回调变为同步调用，比如<code>asyncio.Future</code>，<code>asyncio.Queue</code>等交给<code>Protocol</code>接收数据，然后与<code>loop.create_connection</code>返回的<code>transport</code>一起进行主动调用。</p>
<h3 id="3-2-源码分析"><a href="#3-2-源码分析" class="headerlink" title="3.2.源码分析"></a>3.2.源码分析</h3><p>在了解了<code>Protocol</code>&amp;<code>Transport</code>的使用方法后，可以发现在<code>Protocol</code>&amp;<code>Transport</code>中已经看不到<code>Socket</code>的影子了，需要通过对<code>Protocol</code>&amp;<code>Transport</code>的源码进行分析，才能了解它性能更强的秘密。</p>
<p>在示例代码中可以看到客户端与服务端使用的<code>Protocol</code>&amp;<code>Transport</code>是一致的，所以先从它们各自的初始化方法<code>create_connection</code>和<code>create_server</code>开始下手。<br>其中<code>create_connection</code>方法非常简单，它先是对<code>Socket</code>和其他参数进行校验，接着再进行DNS解析以及通过<code>Happy Eyeballs</code>快速的选择IP地址，然后再调用<code>_create_connection_transport</code>方法。</p>
<p>而<code>_create_connection_transport</code>方法只是创建并返回<code>Transport</code>实例和<code>Protocol</code>实例，其中<code>Protocol</code>实例是通过用户传递的<code>Protocol</code>构造函数创建的，<code>Transport</code>则是由对应的事件循环创建的。</p>
<blockquote>
<ul>
<li>快乐眼球算法见:<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Happy_Eyeballs">Happy Eyeballs</a></li>
<li><code>create_connection</code>的源码比较简单，具体见:<a target="_blank" rel="noopener" href="https://github.com/python/cpython/blob/677320348728ce058fa3579017e985af74a236d4/Lib/asyncio/base_events.py#L976">https://github.com/python/cpython/blob/677320348728ce058fa3579017e985af74a236d4/Lib/asyncio/base_events.py#L976</a></li>
</ul>
</blockquote>
<p>对于服务端的<code>create_server</code>方法，它的处理逻辑一开始也是跟<code>create_connection</code>方法类似，也是先对<code>socket</code>和其他参数进行校验，然后再把参数和<code>Socket</code>放到<code>Server</code>实例中，接着再调用<code>Server</code>实例的<code>serve_forever</code>方法启动服务，而<code>serve_forever</code>的主要方法会调用到<code>_start_serving</code>方法(asyncio/base_events.py)，如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-comment"># 位于:Lib/asyncio/selector_events.py</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_start_serving</span>(<span class="hljs-params">self</span>):</span><br>   <span class="hljs-keyword">if</span> self._serving:<br>       <span class="hljs-keyword">return</span><br>   self._serving = <span class="hljs-literal">True</span><br>   <span class="hljs-keyword">for</span> sock <span class="hljs-keyword">in</span> self._sockets:<br>       sock.listen(self._backlog)  <span class="hljs-comment"># &lt;--重点，后面有说</span><br>       self._loop._start_serving(<br>           self._protocol_factory, sock, self._ssl_context,<br>           self, self._backlog, self._ssl_handshake_timeout,<br>           self._ssl_shutdown_timeout)<br></code></pre></td></tr></table></figure>
<p>该方法会对所有托管的<code>socket</code>进行<code>listen</code>操作，并调用事件循环的<code>_start_serving</code>方法(asyncio/selector_events.py)为<code>Socket</code>向事件循环注册对应的可读事件回调，源码如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 位于:Lib/asyncio/selector_events.py</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_start_serving</span>(<span class="hljs-params">self, protocol_factory, sock,</span></span><br><span class="hljs-function"><span class="hljs-params">                   sslcontext=<span class="hljs-literal">None</span>, server=<span class="hljs-literal">None</span>, backlog=<span class="hljs-number">100</span>,</span></span><br><span class="hljs-function"><span class="hljs-params">                   ssl_handshake_timeout=constants.SSL_HANDSHAKE_TIMEOUT,</span></span><br><span class="hljs-function"><span class="hljs-params">                   ssl_shutdown_timeout=constants.SSL_SHUTDOWN_TIMEOUT</span>):</span><br>    self._add_reader(sock.fileno(), self._accept_connection,<br>                     protocol_factory, sock, sslcontext, server, backlog,<br>                     ssl_handshake_timeout, ssl_shutdown_timeout)<br></code></pre></td></tr></table></figure>
<p>通过源码可以看到这个方法是添加<code>Socket</code>文件描述符的可读事件回调，在添加之后每当<code>Socket</code>与客户端建立连接时，事件循环就会发现并调用<code>_accept_connection</code>方法，<code>_accept_connection</code>方法的源码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-comment"># 位于:Lib/asyncio/selector_events.py</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_accept_connection</span>(<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">        self, protocol_factory, sock,</span></span><br><span class="hljs-function"><span class="hljs-params">        sslcontext=<span class="hljs-literal">None</span>, server=<span class="hljs-literal">None</span>, backlog=<span class="hljs-number">100</span>,</span></span><br><span class="hljs-function"><span class="hljs-params">        ssl_handshake_timeout=constants.SSL_HANDSHAKE_TIMEOUT,</span></span><br><span class="hljs-function"><span class="hljs-params">        ssl_shutdown_timeout=constants.SSL_SHUTDOWN_TIMEOUT</span>):</span><br>    <span class="hljs-comment"># 执行n次accept，直到没有新的请求建立或者执行完毕</span><br>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(backlog):<br>        <span class="hljs-keyword">try</span>:<br>            conn, addr = sock.accept()<br>            conn.setblocking(<span class="hljs-literal">False</span>)<br>        <span class="hljs-keyword">except</span> (BlockingIOError, InterruptedError, ConnectionAbortedError):<br>            <span class="hljs-comment"># socket accept的缓冲区为空，所以不用处理了</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>        <span class="hljs-keyword">except</span> OSError <span class="hljs-keyword">as</span> exc:<br>            <span class="hljs-comment"># 如果有错误，则应该移除监听，再重新调用`_start_serving`进行监听</span><br>            <span class="hljs-keyword">if</span> exc.errno <span class="hljs-keyword">in</span> (errno.EMFILE, errno.ENFILE,<br>                             errno.ENOBUFS, errno.ENOMEM):<br>                <span class="hljs-comment"># 兼容accept多次后Linux一直将文件描述符标记为准备就绪的bug，先移除监听再重新监听</span><br>                self.call_exception_handler(&#123;<br>                    <span class="hljs-string">&#x27;message&#x27;</span>: <span class="hljs-string">&#x27;socket.accept() out of system resource&#x27;</span>,<br>                    <span class="hljs-string">&#x27;exception&#x27;</span>: exc,<br>                    <span class="hljs-string">&#x27;socket&#x27;</span>: trsock.TransportSocket(sock),<br>                &#125;)<br>                self._remove_reader(sock.fileno())<br>                self.call_later(constants.ACCEPT_RETRY_DELAY,<br>                                self._start_serving,<br>                                protocol_factory, sock, sslcontext, server,<br>                                backlog, ssl_handshake_timeout,<br>                                ssl_shutdown_timeout)<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">raise</span>  <span class="hljs-comment"># The event loop will catch, log and ignore it.</span><br>        <span class="hljs-keyword">else</span>:<br>            extra = &#123;<span class="hljs-string">&#x27;peername&#x27;</span>: addr&#125;<br>            <span class="hljs-comment"># 每个acccept都可以认为是一个新的客户端建立的请求，为了提高并发性，需要创建一个新的协程去处理。 </span><br>            accept = self._accept_connection2(<br>                protocol_factory, conn, extra, sslcontext, server,<br>                ssl_handshake_timeout, ssl_shutdown_timeout)<br>            self.create_task(accept)<br></code></pre></td></tr></table></figure>
<p>通过源码可以发现<code>_accept_connection</code>方法的主要作用就是同时处理backlog个<code>socket</code>的<code>accept</code>方法。<br>这个处理是专门针对事件循环进行优化的，因为<code>Socket</code>在接收到新的请求后会马上通知给事件循环，然后等待事件循环去调用事件对应的回调，虽然<code>epoll</code>的处理速度很快了，但是<code>Socket</code>收到新的请求与回调的执行仍有一定的延迟。<br>如果是触发一次事件就执行一次<code>accept</code>，那么处理整个程序<code>accept</code>的效率会降低，但是同时处理<code>Socket</code>的多个<code>accept</code>则可能会使系统的瞬间负载提高，所以这个方法会提供一个<code>backlog</code>参数供开发者选择<code>backlog</code>的大小以决定每次收到事件后执行多少次<code>accept</code>方法。</p>
<p>那么<code>backlog</code>的大小要怎么定义呢，其实这里的<code>backlog</code>与<code>_start_serving</code>方法(asyncio/base_events.py)中<code>listen</code>用到的<code>backlog</code>是一样的，而对于<code>listen</code>的backlog大小是需要根据场景来进行选择的，在Linux中，默认的backlog为128，而常见的后端服务的应用<code>Nginx</code>与<code>Redis</code>的默认值为511，这里不对<code>backlog</code>进行详细介绍，有兴趣的可以通过以下文章了解:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.modb.pro/db/156775">再聊 TCP backlog</a></li>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/36594400/what-is-backlog-in-tcp-connections">What is “backlog” in TCP connections?</a></li>
</ul>
<p>当<code>accept</code>成功后，则会调用<code>_accept_connection2</code>方法，<code>_accept_connection2</code>与客户端的<code>_create_connection_transport</code>一样，它创建了<code>Transport</code>实例和<code>Protocol</code>实例。不过在服务端中为了提高性能，通常都是一个协程对应一个<code>Protocol</code>&amp;<code>Transport</code>，所以是通过<code>create_task</code>来执行<code>_accept_connection2</code>方法。</p>
<h3 id="3-2-1-Transport"><a href="#3-2-1-Transport" class="headerlink" title="3.2.1.Transport"></a>3.2.1.Transport</h3><p><code>create_server</code>和<code>create_connection</code>只是负责对参数的校验以及创建和监听<code>Socket</code>，真正负责数据交互的逻辑都藏在<code>Protocol</code>&amp;<code>Transport</code>之中。<br>在<code>Protocol</code>&amp;<code>Transport</code>的协定中，<code>Transport</code>可以理解为<code>Socket</code>的上层，它负责控制<code>Socket</code>的所有行为，包括数据的读，写，限制流的传输还有最重要的是对<code>Protocol</code>的流进行控制。比如在对<code>Tranposrt</code>进行初始化时，它会在<code>Socket</code>创建完毕后调用<code>Protocol</code>的<code>connection_made</code>方法，<code>Transport</code>初始化的源码如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-comment"># 位于:Lib/asyncio/selector_events.py</span><br><span class="hljs-comment">#  Transport有多个实现，而_SelectorSocketTransport是专门适配UnixSelector事件循环的Transport的实现，它有一定的代表意义。</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">_SelectorSocketTransport</span>(<span class="hljs-params">_SelectorTransport</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, loop, sock, protocol, waiter=<span class="hljs-literal">None</span>,</span></span><br><span class="hljs-function"><span class="hljs-params">                 extra=<span class="hljs-literal">None</span>, server=<span class="hljs-literal">None</span></span>):</span><br>        self._read_ready_cb = <span class="hljs-literal">None</span><br>        <span class="hljs-comment"># 初始化参数以及通过`set_protocol`设置Protocol</span><br>        <span class="hljs-built_in">super</span>().__init__(loop, sock, protocol, extra, server)<br>        self._eof = <span class="hljs-literal">False</span><br>        self._paused = <span class="hljs-literal">False</span><br>        self._empty_waiter = <span class="hljs-literal">None</span><br><br>        <span class="hljs-comment"># 设置TCP_NODELAY，禁用Nagle算法以提升提升性能</span><br>        base_events._set_nodelay(self._sock)<br>        <span class="hljs-comment"># transport创建完毕</span><br>        self._loop.call_soon(self._protocol.connection_made, self)<br>        <span class="hljs-comment"># 注册读事件的回调</span><br>        self._loop.call_soon(self._add_reader, self._sock_fd, self._read_ready)<br>        <span class="hljs-keyword">if</span> waiter <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            self._loop.call_soon(futures._set_result_unless_cancelled, waiter, <span class="hljs-literal">None</span>)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">set_protocol</span>(<span class="hljs-params">self, protocol</span>):</span><br>        <span class="hljs-comment"># 根据协议设置对应的已读回调</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(protocol, protocols.BufferedProtocol):<br>            self._read_ready_cb = self._read_ready__get_buffer<br>        <span class="hljs-keyword">else</span>:<br>            self._read_ready_cb = self._read_ready__data_received<br><br>        <span class="hljs-built_in">super</span>().set_protocol(protocol)<br></code></pre></td></tr></table></figure>
<p>源码中，<code>Transport</code>在初始化时会先初始化参数并设置已读事件的回调，然后再对<code>sock</code>进行处理，在这里只设置TCP_NODELAY为True以禁用Nagle算法。</p>
<p>Ngale算法是为了优化网络传输而诞生的，但是优化网络传输跟时代是有关系的，在以前网络带宽都比较小的互联网初期，如果都是传输小流量的请求体会比较容易引起网络堵塞。<br>比如要传输10个字节长度为1的请求体，它们都会被装载在TCP报文上面，而TCP本身Header的长度在40字节左右，那么此时网络要传输的字节总数为10*(40 + 1) = 410字节。而在应用Ngale算法后，它可以把10个请求体合并在一起，那么传输的字节总数为40 + 1 * 10 = 50字节，可见在使用Ngale算法后可以减少大量的网络传输。</p>
<p>然而到了现在，大部分设备的网络带宽已经变得很大，而且Nagle算法与delay-ACK搭配会带来网络延迟，这对于类似HTTP1.1的请求来说影响可能不大，但对于那些小频快跑的实时数据交互场景却容易受到Nagle影响进而影响网络传输性能，为此<code>Transport</code>在初始化的时候就默认禁用了Nagle算法以减少网络数据交互的延迟。</p>
<blockquote>
<p>这里只做简单易懂的举例和介绍，实际上是比较复杂的，可以通过下面的连接进一步的了解。</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Nagle%27s_algorithm">Nagle算法(英)</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/python/asyncio/pull/373">关于讨论Asyncio是否默认禁用Nagle算法的Issue(英)</a></li>
</ul>
</blockquote>
<p>在<code>Socket</code>创建完毕后，<code>Transport</code>会调用<code>Protocol</code>的<code>connection_made</code>表示<code>transport</code>创建完毕，然后再调用<code>_add_reader</code>方法向<code>socket</code>文件描述符注册了可读事件的回调函数<code>self._read_ready</code>。</p>
<blockquote>
<p><code>__init__</code>方法无法被标记为<code>async</code>函数，所以这里使用了一个<code>waiter</code>用于标识<code>__init__</code>方法何时执行完毕，使其达到类似<code>async</code>函数的实现。</p>
</blockquote>
<p>在<code>Transport</code>创建完毕后，每当<code>socket</code>收到一条消息，就会触发一个可读事件，然后事件循环就会执行<code>self._read_ready</code>去处理消息。<br>这里假设<code>self._read_ready_cb</code>为<code>self._read_ready__data_received</code>，它对应的源码如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-comment"># 位于:Lib/asyncio/selector_events.py</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">_SelectorSocketTransport</span>(<span class="hljs-params">_SelectorTransport</span>):</span><br>    ...<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_read_ready__data_received</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">if</span> self._conn_lost:<br>            <span class="hljs-keyword">return</span><br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-comment"># 通过sock获获取数据</span><br>            data = self._sock.recv(self.max_size)<br>    	<span class="hljs-comment"># 省去一些异常处理</span><br>        <span class="hljs-keyword">except</span> BaseException <span class="hljs-keyword">as</span> exc:<br>            self._fatal_error(exc, <span class="hljs-string">&#x27;Fatal read error on socket transport&#x27;</span>)<br>            <span class="hljs-keyword">return</span><br>    <br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> data:<br>            <span class="hljs-comment"># 没有数据则代表收到eof</span><br>            self._read_ready__on_eof()<br>            <span class="hljs-keyword">return</span><br>    <br>        <span class="hljs-keyword">try</span>:<br>            self._protocol.data_received(data)<br>    	<span class="hljs-comment"># 省去一些异常处理</span><br>        <span class="hljs-keyword">except</span> BaseException <span class="hljs-keyword">as</span> exc:<br>            self._fatal_error(<br>                exc, <span class="hljs-string">&#x27;Fatal error: protocol.data_received() call failed.&#x27;</span>)<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_read_ready__on_eof</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">try</span>:<br>            keep_open = self._protocol.eof_received()<br>    	<span class="hljs-comment"># 省去一些异常处理</span><br>        <span class="hljs-keyword">except</span> BaseException <span class="hljs-keyword">as</span> exc:<br>            self._fatal_error(<br>                exc, <span class="hljs-string">&#x27;Fatal error: protocol.eof_received() call failed.&#x27;</span>)<br>            <span class="hljs-keyword">return</span><br>    <br>        <span class="hljs-keyword">if</span> keep_open:<br>            self._loop._remove_reader(self._sock_fd)<br>        <span class="hljs-keyword">else</span>:<br>            self.close()<br></code></pre></td></tr></table></figure>
<p>在去掉其中的异常处理后可以发现，实际上它的工作原理就是通过<code>sock.recv</code>接收数据，当收到的数据不为空时就调用<code>Protocol</code>的<code>data_received</code>把数据传递给开发者定义的方法中，为空时就调用<code>self._read_ready__on_eof</code>。<br>而<code>_read_ready__on_eof</code>的逻辑也是很简单的，它会调用<code>Protocol</code>的<code>eof_received</code>方法获取返回结果，这个结果是开发者定义的，开发者可以定义它返回的是<code>True</code>还是<code>False</code>，如果是返回<code>True</code>则只移除读监听事件，这样方便在关闭连接之前<code>Socket</code>还能继续发送消息，如果返回<code>False</code>则是直接关闭连接<code>Socket</code>，使<code>Socket</code>既不能读也不能写。</p>
<p>此外，还可以从源码看到在执行读事件的回调时如果有异常发生就会调用<code>_fatal_error</code>方法进行处理，这个方法除了报告异常外，还会关闭<code>Socket</code>。<br>在之前的介绍中<code>Socket</code>是拥有读写两个缓冲区，也介绍了<code>Socket</code>支持只关闭一个缓冲区，另外一个缓冲区还能继续工作的情况，而在<code>Transport</code>中，只关闭写缓冲区称为普通关闭，两个缓冲区都关闭称为强制关闭，它们对应的方法为<code>close</code>和<code>abort</code>，其中<code>abort</code>方法与<code>_fatal_error</code>的功能是类似的，它们对应的源码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-comment"># 位于:Lib/asyncio/selector_events.py</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">_SelectorTransport</span>(<span class="hljs-params">transports._FlowControlMixin, transports.Transport</span>):</span><br>    ...<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">abort</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-comment"># 强制关闭连接</span><br>        self._force_close(<span class="hljs-literal">None</span>)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">is_closing</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> self._closing<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">close</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">if</span> self._closing:<br>            <span class="hljs-keyword">return</span><br>        <span class="hljs-comment"># close只移除读事件监听，buffer没有数据才会强制关闭</span><br>        self._closing = <span class="hljs-literal">True</span><br>        self._loop._remove_reader(self._sock_fd)<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self._buffer:<br>            self._conn_lost += <span class="hljs-number">1</span><br>            self._loop._remove_writer(self._sock_fd)<br>            self._loop.call_soon(self._call_connection_lost, <span class="hljs-literal">None</span>)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__del__</span>(<span class="hljs-params">self, _warn=warnings.warn</span>):</span><br>        <span class="hljs-keyword">if</span> self._sock <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            _warn(<span class="hljs-string">f&quot;unclosed transport <span class="hljs-subst">&#123;self!r&#125;</span>&quot;</span>, ResourceWarning, source=self)<br>            <span class="hljs-comment"># 确保sock被回收，如果没有这个操作，可能会导致内存溢出</span><br>            self._sock.close()<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_fatal_error</span>(<span class="hljs-params">self, exc, message=<span class="hljs-string">&#x27;Fatal error on transport&#x27;</span></span>):</span><br>        <span class="hljs-comment"># 省略的异常处理...</span><br>        self._force_close(exc)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_force_close</span>(<span class="hljs-params">self, exc</span>):</span><br>        <span class="hljs-keyword">if</span> self._conn_lost:<br>            <span class="hljs-comment"># 如果连接丢失就不管了</span><br>            <span class="hljs-keyword">return</span><br>        <span class="hljs-keyword">if</span> self._buffer:<br>            <span class="hljs-comment"># 移除写事件监听以及缓存的buffer</span><br>            self._buffer.clear()<br>            self._loop._remove_writer(self._sock_fd)<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self._closing:<br>            <span class="hljs-comment"># 移除读事件监听</span><br>            self._closing = <span class="hljs-literal">True</span><br>            self._loop._remove_reader(self._sock_fd)<br>        <span class="hljs-comment"># 稍后才关闭连接</span><br>        self._loop.call_soon(self._call_connection_lost, exc)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_call_connection_lost</span>(<span class="hljs-params">self, exc</span>):</span><br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-keyword">if</span> self._protocol_connected:<br>                <span class="hljs-comment"># 如果当前还处于连接中，那么需要通过Protocol的`connection_lost`方法把连接丢失的原因告诉使用方。</span><br>                self._protocol.connection_lost(exc)<br>        <span class="hljs-keyword">finally</span>:<br>            <span class="hljs-comment"># 关闭sock等一切资源</span><br>            self._sock.close()<br>            self._sock = <span class="hljs-literal">None</span><br>            self._protocol = <span class="hljs-literal">None</span><br>            self._loop = <span class="hljs-literal">None</span><br>            server = self._server<br>            <span class="hljs-keyword">if</span> server <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>                server._detach()<br>                self._server = <span class="hljs-literal">None</span><br></code></pre></td></tr></table></figure>
<p>通过源码可以发现<code>abort</code>与<code>_fatal_error</code>方法的唯一区别是<code>_fatal_error</code>方法会携带异常参数，<code>abort</code>的异常参数为空，而它们的执行逻辑都是调用<code>_force_close</code>方法对<code>Socket</code>进行强制关闭。<br>在<code>_force_close</code>方法被调用后，它会移除对应的事件监听，并把关闭连接的方法<code>_call_connection_lost</code>安排到<code>Asyncio Event Loop</code>中，交给<code>Asyncio Event Loop</code>调用。<br>这样做的目的是考虑到了还有一些读事件和写事件正在等待被<code>Asyncio Event Loop</code>执行，这时如果强制关闭<code>Socket</code>会导致这些事件被调用时由于<code>Socket</code>已经关闭而无法发送或获取数据，所以需要把<code>_call_connection_lost</code>的调用安排在读/写事件之后被运行。(asyncio的调度是按照先进先出为原则)</p>
<p>通过源码也可以发现<code>close</code>方法相对<code>_force_close</code>方法的唯一的区别是在buffer缓冲不为空时不会移除写事件监听也不会调用<code>_call_connection_lost</code>方法，从而确保所有在buffer缓冲区的消息都能正常发送。另外<code>Transport</code>还有一个方法–<code>__del__</code>，它是确保<code>Transport</code>被回收时，<code>Socket</code>会被完全关闭，不然可能造成内存溢出。</p>
<blockquote>
<p>关于<code>Python Socket</code>的内存溢出困扰了多个开源项目多年后才被解决，具体可以通过文章<a target="_blank" rel="noopener" href="https://www.paulsprogrammingnotes.com/2021/12/python-memory-leaks.html">《Fixing Memory Leaks In Popular Python Libraries》</a>了解。</p>
</blockquote>
<p>最后，只剩下一个写数据的方法尚未窥探，它的相关源码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-comment"># 位于:Lib/asyncio/selector_events.py</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">_SelectorSocketTransport</span>(<span class="hljs-params">_SelectorTransport</span>):</span><br>    ...<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">write</span>(<span class="hljs-params">self, data</span>):</span><br>        ...<br>        <span class="hljs-comment"># 省略一些校验的</span><br>        <span class="hljs-keyword">if</span> self._eof:<br>            <span class="hljs-comment"># 已经eof了，不能写数据</span><br>            <span class="hljs-keyword">raise</span> RuntimeError(<span class="hljs-string">&#x27;Cannot call write() after write_eof()&#x27;</span>)<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self._buffer:<br>            <span class="hljs-comment"># 如果没有buffer,就代表当前的发送缓冲区可能为空，先发发试一试</span><br>            <span class="hljs-keyword">try</span>:<br>                <span class="hljs-comment"># 先看看能扔多少数据去缓冲区</span><br>                n = self._sock.send(data)<br>            <span class="hljs-keyword">except</span> (BlockingIOError, InterruptedError):<br>                <span class="hljs-comment"># 缓冲区满了，无法发送...</span><br>                <span class="hljs-keyword">pass</span><br>            <span class="hljs-comment"># 省去一些异常处理</span><br>            <span class="hljs-keyword">except</span> BaseException <span class="hljs-keyword">as</span> exc:<br>                self._fatal_error(exc, <span class="hljs-string">&#x27;Fatal write error on socket transport&#x27;</span>)<br>                <span class="hljs-keyword">return</span><br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-comment"># 去掉已经扔到缓冲区的数据</span><br>                data = data[n:]<br>                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> data:<br>                    <span class="hljs-keyword">return</span><br>            <span class="hljs-comment"># 如果缓冲区满了，那么还有剩余的数据，需要等待socket可写时才调用回调写数据</span><br>            self._loop._add_writer(self._sock_fd, self._write_ready)<br><br>        <span class="hljs-comment"># 把数据加入buffer中，buffer默认是bytesarray，效率很高</span><br>        self._buffer.extend(data)<br>        <span class="hljs-comment"># 如果写的压力很高，就需要暂停一下 </span><br>        self._maybe_pause_protocol()<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_write_ready</span>(<span class="hljs-params">self</span>):</span><br><br>        <span class="hljs-keyword">if</span> self._conn_lost:<br>            <span class="hljs-keyword">return</span><br>        <span class="hljs-keyword">try</span>:<br>            n = self._sock.send(self._buffer)<br>        <span class="hljs-comment"># 省去一些异常处理</span><br>        <span class="hljs-keyword">except</span> BaseException <span class="hljs-keyword">as</span> exc:<br>            <span class="hljs-comment"># 如果有异常，就移除监听，清空buffer</span><br>            self._loop._remove_writer(self._sock_fd)<br>            self._buffer.clear()<br>            <span class="hljs-comment"># 抛出异常并通过`force`强制关闭socket</span><br>            self._fatal_error(exc, <span class="hljs-string">&#x27;Fatal write error on socket transport&#x27;</span>)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">if</span> n:<br>                <span class="hljs-comment"># 从buffer清除掉已经发送的buffer</span><br>                <span class="hljs-keyword">del</span> self._buffer[:n]<br>            self._maybe_resume_protocol()  <span class="hljs-comment"># May append to buffer.</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self._buffer:<br>                <span class="hljs-comment"># 发送完了需要进行善后处理，因为有可能socket在发送完消息后就要关闭</span><br>                self._loop._remove_writer(self._sock_fd)<br>                <span class="hljs-keyword">if</span> self._closing:<br>                    self._call_connection_lost(<span class="hljs-literal">None</span>)<br>                <span class="hljs-keyword">elif</span> self._eof:<br>                    self._sock.shutdown(socket.SHUT_WR)<br></code></pre></td></tr></table></figure>
<p>这里比较特别的是写数据的方法<code>write</code>是一个普通的函数，这是因为<code>socket</code>底层有缓冲区，所以写入数据是非常方便的，且在设置不阻塞后，只要调用<code>socket.send</code>就可以把数据投递到缓冲区并马上返回，这个方法不涉及任何IO。</p>
<p>然而缓冲区也有满的情况，于是<code>Transport</code>对缓冲区满的情况做一些处理，正常情况下缓冲区的满有两种情况，如下图：<br><img  src="https://fastly.jsdelivr.net/gh/so1n/so1n_blog_photo@master/blog_photo/1693299214481asyncio%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-socket%E5%86%99%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BB%A1%E7%9A%84%E6%83%85%E5%86%B5.png"  ><span class="image-caption">asyncio网络编程-socket写缓冲区满的情况.png</span></p>
<p>图中假设缓冲区的大小为5，而投递数据的大小为3，对于图的左边，在投递数据的时候会发现缓冲区已经满，这时候操作系统会返回一个错误；而右边是投递时还没满的情况，这种情况下只能投递前面两个消息，此时<code>Transport</code>在执行<code>socket.send</code>方法后会获得到返回值为2，接着就删除<code>buffer</code>中前面的两个消息，只留下一个消息等待缓冲区可投递时再进行投递。</p>
<p>在后续如果缓冲区还不可投递时且仍有数据通过<code>write</code>方法被发送过来，<code>Transport</code>会把数据添加到<code>buffer</code>中，再监听可写事件，当<code>socket</code>可写时，才会调用<code>_write_ready</code>方法把<code>buffer</code>中的数据发送，这一个过程会随着可读事件的监听移除才结束，而只有<code>buffer</code>为空或者发送异常时，才会移除可读事件的监听。</p>
<p>在<code>write</code>源码中还可以看到<code>_maybe_resume_protocol</code>和<code>_maybe_pause_protocol</code>方法的相关调用，这两个方法都是为了控制写入速度的，毕竟<code>buffer</code>的长度是无限的，如果一些恶意客户端与服务端建立请求后，客户端选择拒收消息从而导致<code>buffer</code>会堆积一堆数据，而这些数据也是无意义同时在积累过多后可能导致服务端崩溃，所以需要根据<code>buffer</code>的积累数据的量决定暂停写入还是恢复写入。</p>
<p>除此之外，在<code>_ready_write</code>方法中还涉及到了<code>eof</code>机制，<code>eof</code>是<code>end of file</code>的缩写，它是表示流的结尾的标志。由于TCP是双工的协议，如果其中一端想关闭连接时，另一端可能正在发送数据，虽然程序不需要再写数据了，但不能直接关闭<code>Socket</code>，需要获取对方发送过来的所有数据后才能关闭。<br>而<code>socket</code>的<code>eof</code>机制就是用于告诉对位的读端在收到这个标记后就不需要再接收数据，且后续的数据发送完后也请尽快的关闭。<br>在<code>Transport</code>中通过<code>write_eof</code>方法提供了一个主动标记写通道为<code>eof</code>的功能，使用者也通过<code>can_write_eof</code>判断当前<code>Transport</code>是否可以使用<code>eof</code>机制，它们对应的源码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-comment"># 位于:Lib/asyncio/selector_events.py</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">_SelectorSocketTransport</span>(<span class="hljs-params">_SelectorTransport</span>):</span><br>    ...<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">write_eof</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">if</span> self._closing <span class="hljs-keyword">or</span> self._eof:<br>            <span class="hljs-keyword">return</span><br>        self._eof = <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self._buffer:<br>            self._sock.shutdown(socket.SHUT_WR)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">can_write_eof</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure>
<p>可以看到<code>Transport</code>中与<code>eof</code>相关的源码很简单，它主要是先标记<code>_eof</code>为True，然后再判断当前的<code>buffer</code>是否为空，是的话就通过<code>sock.shutdown(socket.SHUT_WR)</code>关闭<code>Socket</code>中的写缓冲区。如果<code>buffer</code>不为空，则不做任何处理，在<code>_write_ready</code>发送完<code>buffer</code>的所有数据后再调用<code>sock.shutdown(socket.SHUT_WR)</code>关闭。</p>
<blockquote>
<p>注：</p>
<ul>
<li>当服务端调用<code>sock.shutdown(socket.SHUT_WR)</code>后，客户端会通过<code>socket.recv</code>收到一条空消息，客户端会通过空消息判定是服务端到发送端已经<code>eof</code>了。</li>
<li><code>shutdown</code>与<code>close</code>的区别：<code>socket</code>对应的是操作系统的一个资源，多个进程可以拥有同一个<code>socket</code>的句柄，当调用<code>close</code>时，会把句柄的计数减为1,当句柄技计数为0的时候，<code>socket</code>才会真正的关闭并释放资源。而<code>shutdown</code>则是会关闭底层的连接，比如它可以关闭读端，写端或者同时关闭读写端，并等待对方发送FIN/EOF，但是它不会释放<code>socket</code>占用的资源，调用者仍然需要调用<code>shutdown</code>。</li>
</ul>
</blockquote>
<h2 id="4-Stream"><a href="#4-Stream" class="headerlink" title="4.Stream"></a>4.Stream</h2><p><code>Stream</code>是<code>Asyncio</code>中的高级API，通过<code>Stream</code>可以方便的为流式服务进行编程，同时通过<code>Stream</code>编写出来的代码既简洁又容易理解，如官方文档的<code>TCP Echo client</code>示例代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> asyncio<br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">tcp_echo_client</span>(<span class="hljs-params">message</span>):</span><br>    reader, writer = <span class="hljs-keyword">await</span> asyncio.open_connection(<br>        <span class="hljs-string">&#x27;127.0.0.1&#x27;</span>, <span class="hljs-number">8888</span>)<br><br>    print(<span class="hljs-string">f&#x27;Send: <span class="hljs-subst">&#123;message!r&#125;</span>&#x27;</span>)<br>    writer.write(message.encode())<br>    <span class="hljs-keyword">await</span> writer.drain()<br><br>    data = <span class="hljs-keyword">await</span> reader.read(<span class="hljs-number">100</span>)<br>    print(<span class="hljs-string">f&#x27;Received: <span class="hljs-subst">&#123;data.decode()!r&#125;</span>&#x27;</span>)<br><br>    print(<span class="hljs-string">&#x27;Close the connection&#x27;</span>)<br>    writer.close()<br>    <span class="hljs-keyword">await</span> writer.wait_closed()<br><br>asyncio.run(tcp_echo_client(<span class="hljs-string">&#x27;Hello World!&#x27;</span>))<br></code></pre></td></tr></table></figure>
<p>可以看到，这份示例代码十分简单，它在初始化时会返回<code>reader</code>和<code>writer</code>对象，后续调用者可以通过<code>reader</code>读取消息，并通过<code>writer</code>发送消息和关闭连接。<br>而基于<code>Stream</code>接口编写的服务端的也变得简单了， <code>TCP Echo Server</code>源码如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> asyncio<br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">handle_echo</span>(<span class="hljs-params">reader, writer</span>):</span><br>    addr = writer.get_extra_info(<span class="hljs-string">&#x27;peername&#x27;</span>)<br><br>    data = <span class="hljs-keyword">await</span> reader.read(<span class="hljs-number">100</span>)<br>    message = data.decode()<br>    print(<span class="hljs-string">f&quot;Received <span class="hljs-subst">&#123;message!r&#125;</span> from <span class="hljs-subst">&#123;addr!r&#125;</span>&quot;</span>)<br><br>    print(<span class="hljs-string">f&quot;Send: <span class="hljs-subst">&#123;message!r&#125;</span>&quot;</span>)<br>    writer.write(data)<br>    <span class="hljs-keyword">await</span> writer.drain()<br><br>    print(<span class="hljs-string">&quot;Close the connection&quot;</span>)<br>    writer.close()<br>    <span class="hljs-keyword">await</span> writer.wait_closed()<br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    server = <span class="hljs-keyword">await</span> asyncio.start_server(<br>        handle_echo, <span class="hljs-string">&#x27;127.0.0.1&#x27;</span>, <span class="hljs-number">8888</span>)<br><br>    addrs = <span class="hljs-string">&#x27;, &#x27;</span>.join(<span class="hljs-built_in">str</span>(sock.getsockname()) <span class="hljs-keyword">for</span> sock <span class="hljs-keyword">in</span> server.sockets)<br>    print(<span class="hljs-string">f&#x27;Serving on <span class="hljs-subst">&#123;addrs&#125;</span>&#x27;</span>)<br><br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> server:<br>        <span class="hljs-keyword">await</span> server.serve_forever()<br><br>asyncio.run(main())<br></code></pre></td></tr></table></figure>
<p>通过代码可以发现，基于<code>Stream</code>编写的TCP Echo服务中<code>main</code>函数的用法与<code>Protocol</code>&amp;<code>Transport</code>类似创建一个<code>Server</code>实例，而处理连接的<code>handle_echo</code>方法的代码量比<code>Protocol</code>&amp;<code>Transport</code>还要少，同时它不再像<code>Protocol</code>&amp;<code>Transport</code>一样包含大量的异步回调方法。</p>
<p>下图是<code>Stream</code>客户端与<code>Stream</code>服务端的<code>TCP Echo</code>示例：<br><img  src="https://fastly.jsdelivr.net/gh/so1n/so1n_blog_photo@master/blog_photo/1693300383481asyncio%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-Stream.png"  ><span class="image-caption">1693300383481asyncio网络编程-Stream.png</span></p>
<p>通过图可以发现它们交互的形式与<code>Protocol</code>&amp;<code>Transport</code>类似，实际上<code>Stream</code>的核心<code>StreamProtocol</code>就是基于<code>Protocol</code>&amp;<code>Transport</code>进行拓展，然后<code>Stream</code>还抽象出<code>StreamReader</code>和<code>StreamWrite</code>两个对象用于连接用户和<code>StreamProtocol</code>的数据交互，使用户可以使用同步的思想进行网络编程。</p>
<h3 id="4-1-源码分析"><a href="#4-1-源码分析" class="headerlink" title="4.1.源码分析"></a>4.1.源码分析</h3><p><code>Stream</code>最大的特点就是把回调事件转为同步给用户使用以及运用了一些限流手段，但是它把细节全都隐藏起来了，需要通过源码去窥探它的运行逻辑。</p>
<p>首先是客户端和服务端建立连接和初始化的方法，它们的源码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-comment"># 位于:Lib/asyncio/stream.py</span><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">open_connection</span>(<span class="hljs-params">host=<span class="hljs-literal">None</span>, port=<span class="hljs-literal">None</span>, *, limit=_DEFAULT_LIMIT, **kwds</span>):</span><br>    <span class="hljs-comment"># 客户端建立连接的方法</span><br>    loop = events.get_running_loop()<br>    reader = StreamReader(limit=limit, loop=loop)<br>    protocol = StreamReaderProtocol(reader, loop=loop)<br>    transport, _ = <span class="hljs-keyword">await</span> loop.create_connection(<br>        <span class="hljs-keyword">lambda</span>: protocol, host, port, **kwds)<br>    writer = StreamWriter(transport, protocol, reader, loop)<br>    <span class="hljs-keyword">return</span> reader, writer<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">start_server</span>(<span class="hljs-params">client_connected_cb, host=<span class="hljs-literal">None</span>, port=<span class="hljs-literal">None</span>, *, limit=_DEFAULT_LIMIT, **kwds</span>):</span><br>    <span class="hljs-comment"># 服务端建立连接的方法</span><br>    loop = events.get_running_loop()<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">factory</span>():</span><br>        reader = StreamReader(limit=limit, loop=loop)<br>        protocol = StreamReaderProtocol(reader, client_connected_cb, loop=loop)<br>        <span class="hljs-keyword">return</span> protocol<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> loop.create_server(factory, host, port, **kwds)<br></code></pre></td></tr></table></figure>
<p>通过源码可以知道，<code>open_connection</code>与<code>start_server</code>类似，它们都是先创建好<code>StreamReaderProtocol</code>，再交给<code>create_connection</code>或者<code>create_server</code>运行。<br>而<code>StreamReaderProtocol</code>是继承于<code>Protocol</code>，它相比于<code>Protocol</code>多了一些适配了<code>StreamReader</code>和<code>StreamWriter</code>的调用。</p>
<blockquote>
<p><code>StreamProtocol</code>只是一个中间者，很多逻辑与<code>Protocol</code>&amp;<code>Transport</code>类似，故不会进行分析。</p>
</blockquote>
<h4 id="4-1-1-StreamWriter"><a href="#4-1-1-StreamWriter" class="headerlink" title="4.1.1.StreamWriter"></a>4.1.1.StreamWriter</h4><p>对于<code>StreamWriter</code>可以认为是<code>Transport</code>的代理对象，所以它负责的也是主动调用的那部分，它的很多方法都是直接调用到<code>Transport</code>的同名方法，它与<code>Transport</code>的唯一区别就是多了<code>wait_closed</code>和<code>drain</code>方法两个方法，对应的源码如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-comment"># 位于:Lib/asyncio/stream.py</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StreamWriter</span>:</span><br>    <span class="hljs-comment"># 初始化...</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, transport, protocol, reader, loop</span>):</span><br>        self._transport = transport<br>        self._protocol = protocol<br>        self._reader = reader<br>        self._loop = loop<br><br>    <span class="hljs-comment"># 省略了一堆代理transport的方法</span><br>    ...<br><br>    <span class="hljs-comment"># 相比transport多出来的方法</span><br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">wait_closed</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">await</span> self._protocol._get_close_waiter(self)<br><br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">drain</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">if</span> self._reader <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            exc = self._reader.exception()<br>            <span class="hljs-keyword">if</span> exc <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>                <span class="hljs-keyword">raise</span> exc<br>        <span class="hljs-keyword">if</span> self._transport.is_closing():<br>            <span class="hljs-keyword">await</span> sleep(<span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">await</span> self._protocol._drain_helper()<br></code></pre></td></tr></table></figure>
<p>源码中的<code>wait_closed</code>是等待<code>Protocol</code>的<code>_get_close_waiter</code>的方法，这个方法会一直阻塞直到<code>Protocol</code>的<code>connection_lost</code>被调用，所以在调用<code>await transport.wait_closed()</code>实际上等于<code>Protocol</code>&amp;<code>Transport</code>示例代码中的<code>on_con_lost</code>。<br>而<code>drain</code>方法则是<code>Stream</code>的流控制功能，它是结合<code>Write</code>一起使用的，它能防止写缓冲区被写满，以及及早的发现写缓冲区的异常，所以在使用<code>Stream</code>进行网络编程时，在执行<code>write.write()</code>后，一定要调用<code>await write.drain()</code>方法。</p>
<p>此外，源码中的<code>drain</code>方法有一句奇特的代码–<code>await sleep(0)</code>，这段代码出现在这里的原因是在<code>Protocol</code>&amp;<code>Transport</code>中，<code>write</code>的调用出错后会让事件循环尽快的执行<code>_connection_lost</code>的调用，但是用户在调用</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">write.write()<br><span class="hljs-keyword">await</span> write.drain()<br></code></pre></td></tr></table></figure>
<p>的过程中并没有让步在事件循环，如果不添加<code>await sleep(0)</code>显式的让步给事件循环，就会导致<code>Protocol</code>的<code>_drain_helper</code>方法会在<code>_connection_lost</code>之前调用，最终导致写入数据这个操作无法感知到连接已经丢失。</p>
<blockquote>
<p><code>drain_helper</code>方法是与流控制相结合的，它在<code>Protocol</code>&amp;<code>Transport</code>调用了<code>_maybe_pause_protocol</code>时会阻塞，直到<code>_maybe_resume_protocol</code>被调用的时候才会释放，流控制的相关代码可以通过<a target="_blank" rel="noopener" href="https://github.com/python/cpython/blob/677320348728ce058fa3579017e985af74a236d4/Lib/asyncio/streams.py#L116">FlowControlMixin的源码</a>了解。</p>
</blockquote>
<h4 id="4-1-1-StreamReader"><a href="#4-1-1-StreamReader" class="headerlink" title="4.1.1.StreamReader"></a>4.1.1.StreamReader</h4><p>用户在调用<code>StreamReader</code>时，通常都会调用到<code>read*</code>系列方法来获取数据，但是在<code>Protocol</code>&amp;<code>Transport</code>中的数据是通过回调把数据传递给用户的。<code>Stream</code>为了解决这个问题，它把<code>StreamReader</code>设计成一个类似于先进先出的容器，当<code>Protocol</code>&amp;<code>Transport</code>有数据时会把数据通过投喂数据的方法写入到<code>SteamReader</code>中，并提供获取数据，中止投递数据等方法交给用户调用。</p>
<p>其中投喂数据的源码如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StreamReader</span>:</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_wakeup_waiter</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-comment"># 告诉read系列的方法，已经有数据进来了，可以继续执行了</span><br>        waiter = self._waiter<br>        <span class="hljs-keyword">if</span> waiter <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            self._waiter = <span class="hljs-literal">None</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> waiter.cancelled():<br>                waiter.set_result(<span class="hljs-literal">None</span>)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">feed_eof</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-comment"># 投递了一个eof的信息</span><br>        self._eof = <span class="hljs-literal">True</span><br>        self._wakeup_waiter()<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">at_eof</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;给StreamProtocol判断是否需要投递`eof`&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">return</span> self._eof <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> self._buffer<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">feed_data</span>(<span class="hljs-params">self, data</span>):</span><br>        <span class="hljs-keyword">assert</span> <span class="hljs-keyword">not</span> self._eof, <span class="hljs-string">&#x27;feed_data after feed_eof&#x27;</span><br><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> data:<br>            <span class="hljs-keyword">return</span><br><br>        <span class="hljs-comment"># 把数据添加到buffer中</span><br>        self._buffer.extend(data)<br>        <span class="hljs-comment"># 通过`wakeup_waiter`唤醒read系列方法</span><br>        self._wakeup_waiter()<br><br>        <span class="hljs-keyword">if</span> (self._transport <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> self._paused <span class="hljs-keyword">and</span> <span class="hljs-built_in">len</span>(self._buffer) &gt; <span class="hljs-number">2</span> * self._limit):<br>            <span class="hljs-comment"># 如果当前的buffer数据超过了限制，就暂停数据的读取</span><br>            <span class="hljs-keyword">try</span>:<br>                self._transport.pause_reading()<br>            <span class="hljs-keyword">except</span> NotImplementedError:<br>                <span class="hljs-comment"># 如果当前transport不支持暂停，就直接忘掉它，后面需要调用者通过`set_transport`重新设置transport</span><br>                self._transport = <span class="hljs-literal">None</span><br>            <span class="hljs-keyword">else</span>:<br>                self._paused = <span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure>
<p>通过源码可以看出，<code>StreamReader</code>中的投喂数据方法和用户调用方法会共享<code>self._waiter</code>和<code>self._buffer</code>对象，其中<code>self._buffer</code>用于接收和读取数据，而<code>self._waiter</code>用于通知<code>read</code>系列等方法，告诉它们有数据来了，可以继续处理，<code>StreamReader</code>的读数据相关源码如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StreamReader</span>:</span><br>    ... <span class="hljs-comment"># 省略设置异常的方法</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_maybe_resume_transport</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-comment"># 由于读取了数据了，`buffer`当前的水位已经降低，需要尝试恢复从transport读取数据。</span><br>        <span class="hljs-keyword">if</span> self._paused <span class="hljs-keyword">and</span> <span class="hljs-built_in">len</span>(self._buffer) &lt;= self._limit:<br>            self._paused = <span class="hljs-literal">False</span><br>            self._transport.resume_reading()<br><br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_wait_for_data</span>(<span class="hljs-params">self, func_name</span>):</span><br>        <span class="hljs-keyword">if</span> self._waiter <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">raise</span> RuntimeError(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;func_name&#125;</span>() called while another coroutine is already waiting for incoming data&#x27;</span>)<br><br>        <span class="hljs-comment"># 如果已经被暂停，那么应该恢复数据的读取</span><br>        <span class="hljs-keyword">if</span> self._paused:<br>            self._paused = <span class="hljs-literal">False</span><br>            self._transport.resume_reading()<br><br>        <span class="hljs-comment"># 创建_waiter并等待被唤醒。</span><br>        self._waiter = self._loop.create_future()<br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-keyword">await</span> self._waiter<br>        <span class="hljs-keyword">finally</span>:<br>            self._waiter = <span class="hljs-literal">None</span><br><br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">read</span>(<span class="hljs-params">self, n=-<span class="hljs-number">1</span></span>):</span><br>        <span class="hljs-comment"># 有异常直接抛异常</span><br>        <span class="hljs-keyword">if</span> self._exception <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">raise</span> self._exception<br><br>        <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span>:<br>            <span class="hljs-comment"># 如果为0,那么直接返回</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-string">b&#x27;&#x27;</span><br><br>        <span class="hljs-comment"># 省去小于0的情况，小于0时会一直获取数据，直到接收到EOF</span><br>        ...<br>        <br>        <span class="hljs-comment"># 如果没有buffer，则需要等待</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self._buffer <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> self._eof:<br>            <span class="hljs-keyword">await</span> self._wait_for_data(<span class="hljs-string">&#x27;read&#x27;</span>)<br><br>        <span class="hljs-comment"># 从buffer获取数据（同时也清空了它们在buffer中的占用）</span><br>        data = <span class="hljs-built_in">bytes</span>(self._buffer[:n])<br>        <span class="hljs-keyword">del</span> self._buffer[:n]<br><br>        self._maybe_resume_transport()<br>        <span class="hljs-keyword">return</span> data<br></code></pre></td></tr></table></figure>
<p>通过源码可以看到<code>StreamReader</code>获取数据的方法比<code>Protocol</code>&amp;<code>Transport</code>复杂了一点，它在调用<code>read</code>时，如果发现<code>buffer</code>有数据，就直接返回数据，否则就需要通过<code>wait_for_data</code>方法等待<code>waiter</code>对象被投喂数据的方法设置为不阻塞。</p>
<p>在这个流程中，<code>Stream</code>通过<code>waiter</code>对象和<code>buffer</code>完成异步回调到同步调用的转换，但是这样会导致每当有一条消息进来的时候，<code>StreamReader</code>需要通过<code>Asyncio Event Loop</code>的两次调用才能获取到消息，这也正是<code>Stream</code>比<code>Protocol</code>&amp;<code>Protocol</code>性能差点原因。</p>
<h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5.总结"></a>5.总结</h2><p>通过<code>Protocol</code>&amp;<code>Transport</code>中的源码可以看到，<code>Protocol</code>&amp;<code>Transport</code>通过一次事件批量<code>accept</code>以及使用了<code>buffer</code>加快了发送速度来获得了比<code>Asyncio Socket</code>高出很多的性能，而<code>Stream</code>通过<code>asyncio.Future</code>和<code>asyncio.Queue</code>把<code>Protocol</code>&amp;<code>Transport</code>的异步回调转换为同步调用，以一定的性能消耗换取了易用性。</p>
<p>在TCP编程的场景中，这两个网络编程接口都有它们对应的使用场景，我们可以通过使用场景来选择对应的接口进行网络编程开发，通常情况下，默认服务端都会使用<code>Protocol</code>&amp;<code>Transport</code>进行网络编程开发，因为它们都会追求极高的性能。<br>而客户端则默认会使用<code>Stream</code>进行网络编程开发，因为客户端会偏通过同步调用的方式进行开发，如果使用<code>Protocol</code>&amp;<code>Transport</code>进行开发，也需要用到<code>asyncio.Future</code>和<code>asycnio.Queue</code>容器把异步回调转换为同步调用，这样一来使用<code>Protocol</code>&amp;<code>Transport</code>开发和使用<code>Stream</code>进行开发的客户端性能是差不多的。</p>
<blockquote>
<p>本文是偏理论的分析<code>Python Asyncio</code>的网络编程相关的接口原理，在后续将介绍如何通过<code>Protocol</code>&amp;<code>Transport</code>开发一个Web框架。</p>
</blockquote>
      </section>
      <section class="extra">
        
          <ul class="copyright">
  
    <li><strong>本文作者：</strong>So1n</li>
    <li><strong>本文链接：</strong><a href="http://so1n.me/2023/08/29/python_asyncio_lib_network/index.html" title="http:&#x2F;&#x2F;so1n.me&#x2F;2023&#x2F;08&#x2F;29&#x2F;python_asyncio_lib_network&#x2F;index.html">http:&#x2F;&#x2F;so1n.me&#x2F;2023&#x2F;08&#x2F;29&#x2F;python_asyncio_lib_network&#x2F;index.html</a></li>
    <li><strong>版权声明：</strong>本博客所有文章均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" title="BY-NC-SA" target="_blank" rel="noopener">BY-NC-SA</a> 许可协议，转载请注明出处！</li>
  
  <img src="https://raw.githubusercontent.com/so1n/so1n_blog_photo/master/blog_photo/%E6%89%AB%E7%A0%81_%E6%90%9C%E7%B4%A2%E8%81%94%E5%90%88%E4%BC%A0%E6%92%AD%E6%A0%B7%E5%BC%8F-%E6%A0%87%E5%87%86%E8%89%B2%E7%89%88.png" alt="text">

</ul>

        
        
          <section class="donate">
  <div id="qrcode-donate">
    <img src="https://fastly.jsdelivr.net/gh/so1n/so1n_blog_photo@master/blog_photo/16550449287744d2ebf32586d8799ee2e75333d6f5d2.jpg">
  </div>
  <div class="icon">
    <a href="javascript:;" id="alipay"><i class="iconfont iconalipay"></i></a>
    <a href="javascript:;" id="wechat"><i class="iconfont iconwechat-fill"></i></a>
  </div>
</section>
        
        
  <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Asyncio/" rel="tag">Asyncio</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python/" rel="tag">Python</a></li></ul> 

        
  <nav class="nav">
    <a></a>
    <a href="/2023/08/14/python_asyncio_concunrrency_result_share/">Python Asyncio实践--高并发下如何防止缓存击穿<i class="iconfont iconright"></i></a>
  </nav>

      </section>
      
        <section class="comments">
  
    <div class="btn" id="comments-btn">查看评论</div>
  
  
<link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<div id="gitalk" class="gitalk"></div>
<script defer src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
<script>
  window.onload = function () {
    var gitalk = new Gitalk({
      clientID: '59f804e526b05c378470',
      clientSecret: '36679ff697cec424936a0f7c4bcd6d2988dac28e',
      id: window.location.pathname,
      repo: 'so1n.github.io',
      owner: 'so1n',
      admin: 'so1n'
    });
    if ( true ) {
      $("#comments-btn").on("click", function () {
        $(this).hide();
        gitalk.render('gitalk');
      });
    } else {
      gitalk.render('gitalk');
    }
  }
</script>

</section>
      
    </section>
  </div>
</article>
</div>
      <div class="col-xl-3">
          
  <aside class="toc-wrap">
    <h3 class="toc-title">文章目录：</h3>
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%AE%B0"><span class="toc-text">前记</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D"><span class="toc-text">1.简单介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-Socket%E7%9A%84%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D"><span class="toc-text">1.1.Socket的简单介绍</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Asyncio-Socket"><span class="toc-text">2.Asyncio Socket</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Protocol-amp-Transport"><span class="toc-text">3.Protocol&amp;Transport</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B"><span class="toc-text">3.1使用示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-text">3.2.源码分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-1-Transport"><span class="toc-text">3.2.1.Transport</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-Stream"><span class="toc-text">4.Stream</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-text">4.1.源码分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E6%80%BB%E7%BB%93"><span class="toc-text">5.总结</span></a></li></ol>
  </aside>

        
          
  <aside class="toc-wrap">
    <h3 class="toc-title">文章目录：</h3>
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%AE%B0"><span class="toc-text">前记</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D"><span class="toc-text">1.简单介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-Socket%E7%9A%84%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D"><span class="toc-text">1.1.Socket的简单介绍</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Asyncio-Socket"><span class="toc-text">2.Asyncio Socket</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Protocol-amp-Transport"><span class="toc-text">3.Protocol&amp;Transport</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B"><span class="toc-text">3.1使用示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-text">3.2.源码分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-1-Transport"><span class="toc-text">3.2.1.Transport</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-Stream"><span class="toc-text">4.Stream</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-text">4.1.源码分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E6%80%BB%E7%BB%93"><span class="toc-text">5.总结</span></a></li></ol>
  </aside>

        
      </div>
    </div>
  </div>
</main>

  <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js">
</script>


<footer class="footer">
  <div class="footer-social"><a 
        href="https://github.com/so1n "
        target="_blank"
        class="footer-social-item"
        onMouseOver="this.style.color= '#9f7be1'" 
        onMouseOut="this.style.color='#33333D'">
          <i class="iconfont  icongithub-fill "></i>
      </a></div>
  
    <div class="footer-copyright"><p>Powered by <a target="_blank" href="https://hexo.io">Hexo</a>  |  Theme - <a target="_blank" href="https://github.com/izhaoo/hexo-theme-zhaoo">zhaoo</a>| <a target="_blank" href="/atom.xml">RSS</a> </p></div>
  
  <div class="footer-copyright">
      <a href="/atom.xml">
  </div>
  <div class="footer-copyright">
    总访问量<span id="busuanzi_value_site_pv"></span>次
    访客数<span id="busuanzi_value_site_uv"></span>人次
  </div>

</footer>

  
      <div class="fab fab-plus">
    <i class="iconfont iconplus"></i>
  </div>
  
  
  
  <div class="fab fab-up">
    <i class="iconfont iconcaret-up"></i>
  </div>
  
  
    <div class="scrollbar j-scrollbar">
  <div class="scrollbar-current j-scrollbar-current"></div>
</div>
  
  
    
<script src="/js/color-mode.js"></script>

  
  
    <div class="search">
  <div class="search-container">
    <div class="search-close">
      <i class="iconfont iconbaseline-close-px"></i>
    </div>
    <div class="search-input-wrapper">
      <i class="search-input-icon iconfont iconsearch"></i>
      <input class="search-input" type="search" id="search-input" placeholder="Search..." autofocus autocomplete="off"
        autocorrect="off" autocapitalize="off">
    </div>
    <div class="search-output" id="search-output"></div>
  </div>
</div>
  
</body>

<script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>





  
<script src="https://cdn.bootcdn.net/ajax/libs/jquery.lazyload/1.9.1/jquery.lazyload.min.js"></script>




  
<script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js"></script>






  
<script src="https://cdn.bootcdn.net/ajax/libs/jquery.qrcode/1.0/jquery.qrcode.min.js"></script>




<script src="/js/utils.js"></script>
<script src="/js/script.js"></script>







  <script>
    (function () {
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
      } else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>












</html>
